{"data":{"index":1,"total":1,"posts":[{"title":"扇形等分-突然想到的一个数学问题","slug":"扇形等分-突然想到的一个数学问题","date":"2020-09-01T07:13:00.000Z","updated":"2025-05-20T11:46:57.000Z","comments":true,"url":"2020/09/01/扇形等分-突然想到的一个数学问题/","excerpt":"<p>note:博客有可能会因为一些 markdown 兼容性不支持，可以查看：<br><a href=\"https://www.douban.com/note/776327336/\">https://www.douban.com/note/776327336/</a></p>\n<p>如图所示，今天突然产生一个想法，如何对扇形进行非角度的平分，数学语言表达的话：我们有一角度为θ的扇形，已知半径为R,我们在R1、R2、R3…..Rn-1处对扇形进行n次分割，使得划分之后的部分面积相等，即S1&#x3D;S2&#x3D;S3….Sn-1&#x3D;Sn，求R之间的关系表达式。</p>\n<img src=\"https://cdn.julis.wang/blog/img/1521743510550.jpg\">\n<p>对于每个区域有：<br>$$<br>f(1)&#x3D;\\frac{ πθ(R_1)^2} {360}<br>$$</p>\n<p>$$<br>f(2)&#x3D;\\frac{ πθ(R_2)^2} {360} - f(1) &#x3D; \\frac{ πθ(R_2)^2} {360} - \\frac{ πθ(R_1)^2} {360}<br>$$</p>\n<p>$$<br>f(3)&#x3D;\\frac{ πθ(R_3)^2} {360} - f(2) &#x3D;  \\frac{ πθ(R_3)^2} {360} - \\frac{ πθ(R_2)^2} {360}<br>$$</p>\n<p>$$<br>……<br>$$</p>\n<p>$$<br>f(n)&#x3D;\\frac{ πθ(R_n)^2} {360}- f(n) &#x3D;  \\frac{ πθ(R_n)^2} {360} - \\frac{ πθ(R_{n-1})^2} {360}<br>$$<br>对于<br>$$<br>f(R_n)-f(R_{n-1}) &#x3D; \\frac{ πθ(R_n)^2} {360} - \\frac{ πθ(R_{n-1})^2} {360}<br>$$<br>由于<br>$$<br>f(R_1)&#x3D;f(R_2)&#x3D;f(R_3)……&#x3D;f(R_{n-1})&#x3D;f(R_n)<br>$$<br>即<br>$$<br>\\frac{ πθ(R_1)^2} {360}&#x3D;\\frac{ πθ(R_2)^2} {360} - \\frac{ πθ(R_1)^2} {360} &#x3D;\\frac{ πθ(R_3)^2} {360} - \\frac{ πθ(R_2)^2} {360} ……&#x3D; \\frac{ πθ(R_n)^2} {360} - \\frac{ πθ(R_{n-1})^2} {360}<br>$$<br>推出<br>$$<br>R_1^2&#x3D;R_2^2-R_1^2  \\longrightarrow R_2 &#x3D; \\frac  {R_1} {\\sqrt{2}}<br>$$</p>\n<p>$$<br>R_2^2&#x3D;R_3^2-R_2^2  \\longrightarrow R_3 &#x3D; \\frac  {R_2} {\\sqrt{2}} &#x3D;\\frac  {R_1} {\\sqrt{2} ^2}<br>$$</p>\n<p>$$<br>R_4 &#x3D; \\frac  {R_1} {\\sqrt{2} ^3}<br>\\<br>$$</p>\n<p>$$<br>……<br>$$</p>\n<p>$$<br>R_n&#x3D; \\frac  {R_1} {\\sqrt{2} ^{n-1}}<br>$$</p>\n<p>$$<br>对于R_1有\\frac{ πθ(R_1)^2} {360} &#x3D; \\frac{ πθ(R_n)^2} {360n} \\longrightarrow R_1&#x3D; \\frac R {\\sqrt {n}}<br>$$</p>\n<p>$$<br>Rn &#x3D;\\frac R {\\sqrt {n}({\\sqrt{2}) ^{n-1}} }<br>$$</p>\n<img src=\"https://cdn.julis.wang/blog/img/dc37c754ce6f4fd1ae224ac2a40416c0.png\">\n<p>从上的公式推导可以看出，对于“扇形”的平分也可以推广到圆的平分上面去，因为从公式中我们看到θ已经被约掉了。从晚上六七点想问题，到下班回家后，推导到了十一点，出来了结论，感觉还是蛮有趣的，遂记录一笔。</p>\n","cover":null,"images":["https://cdn.julis.wang/blog/img/1521743510550.jpg","https://cdn.julis.wang/blog/img/dc37c754ce6f4fd1ae224ac2a40416c0.png"],"content":"<p>note:博客有可能会因为一些 markdown 兼容性不支持，可以查看：<br><a href=\"https://www.douban.com/note/776327336/\">https://www.douban.com/note/776327336/</a></p>\n<p>如图所示，今天突然产生一个想法，如何对扇形进行非角度的平分，数学语言表达的话：我们有一角度为θ的扇形，已知半径为R,我们在R1、R2、R3…..Rn-1处对扇形进行n次分割，使得划分之后的部分面积相等，即S1&#x3D;S2&#x3D;S3….Sn-1&#x3D;Sn，求R之间的关系表达式。</p>\n<img src=\"https://cdn.julis.wang/blog/img/1521743510550.jpg\">\n<p>对于每个区域有：<br>$$<br>f(1)&#x3D;\\frac{ πθ(R_1)^2} {360}<br>$$</p>\n<p>$$<br>f(2)&#x3D;\\frac{ πθ(R_2)^2} {360} - f(1) &#x3D; \\frac{ πθ(R_2)^2} {360} - \\frac{ πθ(R_1)^2} {360}<br>$$</p>\n<p>$$<br>f(3)&#x3D;\\frac{ πθ(R_3)^2} {360} - f(2) &#x3D;  \\frac{ πθ(R_3)^2} {360} - \\frac{ πθ(R_2)^2} {360}<br>$$</p>\n<p>$$<br>……<br>$$</p>\n<p>$$<br>f(n)&#x3D;\\frac{ πθ(R_n)^2} {360}- f(n) &#x3D;  \\frac{ πθ(R_n)^2} {360} - \\frac{ πθ(R_{n-1})^2} {360}<br>$$<br>对于<br>$$<br>f(R_n)-f(R_{n-1}) &#x3D; \\frac{ πθ(R_n)^2} {360} - \\frac{ πθ(R_{n-1})^2} {360}<br>$$<br>由于<br>$$<br>f(R_1)&#x3D;f(R_2)&#x3D;f(R_3)……&#x3D;f(R_{n-1})&#x3D;f(R_n)<br>$$<br>即<br>$$<br>\\frac{ πθ(R_1)^2} {360}&#x3D;\\frac{ πθ(R_2)^2} {360} - \\frac{ πθ(R_1)^2} {360} &#x3D;\\frac{ πθ(R_3)^2} {360} - \\frac{ πθ(R_2)^2} {360} ……&#x3D; \\frac{ πθ(R_n)^2} {360} - \\frac{ πθ(R_{n-1})^2} {360}<br>$$<br>推出<br>$$<br>R_1^2&#x3D;R_2^2-R_1^2  \\longrightarrow R_2 &#x3D; \\frac  {R_1} {\\sqrt{2}}<br>$$</p>\n<p>$$<br>R_2^2&#x3D;R_3^2-R_2^2  \\longrightarrow R_3 &#x3D; \\frac  {R_2} {\\sqrt{2}} &#x3D;\\frac  {R_1} {\\sqrt{2} ^2}<br>$$</p>\n<p>$$<br>R_4 &#x3D; \\frac  {R_1} {\\sqrt{2} ^3}<br>\\<br>$$</p>\n<p>$$<br>……<br>$$</p>\n<p>$$<br>R_n&#x3D; \\frac  {R_1} {\\sqrt{2} ^{n-1}}<br>$$</p>\n<p>$$<br>对于R_1有\\frac{ πθ(R_1)^2} {360} &#x3D; \\frac{ πθ(R_n)^2} {360n} \\longrightarrow R_1&#x3D; \\frac R {\\sqrt {n}}<br>$$</p>\n<p>$$<br>Rn &#x3D;\\frac R {\\sqrt {n}({\\sqrt{2}) ^{n-1}} }<br>$$</p>\n<img src=\"https://cdn.julis.wang/blog/img/dc37c754ce6f4fd1ae224ac2a40416c0.png\">\n<p>从上的公式推导可以看出，对于“扇形”的平分也可以推广到圆的平分上面去，因为从公式中我们看到θ已经被约掉了。从晚上六七点想问题，到下班回家后，推导到了十一点，出来了结论，感觉还是蛮有趣的，遂记录一笔。</p>\n","categories":[{"name":"算法研究","slug":"算法研究","api":"api/categories/算法研究.json"}],"tags":[{"name":"数学","slug":"数学","api":"api/tags/数学.json"}],"api":"api/posts/2020/09/01/扇形等分-突然想到的一个数学问题.json"},{"title":"哈夫曼树与编码","slug":"数据结构-哈夫曼Huffman树","date":"2020-03-24T01:38:00.000Z","updated":"2025-05-20T11:46:57.000Z","comments":true,"url":"2020/03/24/数据结构-哈夫曼Huffman树/","excerpt":"<p><strong>哈夫曼树定义：</strong></p>\n<blockquote>\n<p>给定N个权值作为N个叶子结点，构造一棵二叉树，若该树的带权路径长度达到最小，称这样的二叉树为最优二叉树，也称为哈夫曼树(Huffman<br>Tree)。哈夫曼树是带权路径长度最短的树，权值较大的结点离根较近。</p>\n</blockquote>\n<p>例：在数据通信中，需要将传送的文字转换成二进制的字符串，用0，1码的不同排列来表示字符。例如，需传送的报文为“AFTER DATA EAR ARE ART AREA”，这里用到的字符集为“A，E，R，T，F，D”，各字母出现的次数为{8，4，5，3，1，1}。现要求为这些字母设计编码。要区别6个字母，最简单的二进制编码方式是等长编码，固定采用3位二进制，可分别用000、001、010、011、100、101对“A，E，R，T，F，D”进行编码发送，当对方接收报文时再按照三位一分进行译码。显然编码的长度取决报文中不同字符的个数。</p>\n<h2 id=\"哈夫曼树创建方法\"><a href=\"#哈夫曼树创建方法\" class=\"headerlink\" title=\"哈夫曼树创建方法\"></a>哈夫曼树创建方法</h2><p>摘自：<a href=\"https://blog.csdn.net/FX677588/article/details/70767446\">《详细图解哈夫曼Huffman编码树》</a></p>\n<h3 id=\"2-1-初始队列\"><a href=\"#2-1-初始队列\" class=\"headerlink\" title=\"2.1 初始队列\"></a>2.1 初始队列</h3><p>　　我们按出现频率高低将其放入一个优先级队列中，从左到右依次为频率逐渐增加。\n　</p>\n<img src=\"https://cdn.julis.wang/blog/img/20200319094704131.png\">\n<p>　　下面我们需要将这个队列转换成哈夫曼二叉树，哈夫曼二叉树是一颗带权重的二叉树，权重是由队列中每个字符出现的次数所决定的。并且哈夫曼二叉树始终保证权重越大的字符出现在越高的地方。</p>\n<h3 id=\"2-2-第一步合并\"><a href=\"#2-2-第一步合并\" class=\"headerlink\" title=\"2.2 第一步合并\"></a>2.2 第一步合并</h3><p>　　首先我们从左到右进行合并，依次构建二叉树。第一步取前两个字符u和r来构造初始二叉树，第一个字符作为左节点，第二个元素作为右节点，然后两个元素相加作为新空元素，并且两者权重相加作为新元素的权重。\n　　</p>\n<img src=\"https://cdn.julis.wang/blog/img/20200319094810712.png\">\n\n<p>　　同理，新元素可以和字符i再合并，如下：</p>\n<img src=\"https://cdn.julis.wang/blog/img/20200319094824181.png\">\n\n<h3 id=\"2-3-重新调整队列\"><a href=\"#2-3-重新调整队列\" class=\"headerlink\" title=\"2.3 重新调整队列\"></a>2.3 重新调整队列</h3><p>　　上图新元素权重相加后结果是变大了，需要对权重进行重新排序。\n　　</p>\n<img src=\"https://cdn.julis.wang/blog/img/20200319094841561.png\">\n<p>　　然后再依次从左到右合并，每合并一次则进行一次队列重新排序调整。如下：</p>\n<img src=\"https://cdn.julis.wang/blog/img/2020031909485354.png\">\n<p>　　经过多步操作之后，得到以下的哈夫曼二叉树结构，也就是一个带有权重的二叉树：</p>\n<img src=\"https://cdn.julis.wang/blog/img/20200319094902609.png\">\n\n<h3 id=\"2-4-哈夫曼编码\"><a href=\"#2-4-哈夫曼编码\" class=\"headerlink\" title=\"2.4 哈夫曼编码\"></a>2.4 哈夫曼编码</h3><p>　　有了上面带权重的二叉树之后，我们就可以进行编码了。我们把二叉树分支中左边的支路编码为0，右边分支表示为1，如下图：\n　</p>\n<img src=\"https://cdn.julis.wang/blog/img/20200319094918382.png\">\n<p>　　这样依次遍历这颗二叉树就可以获取得到所有字符的编码了。例如：‘ ’的编码为10，‘l’的编码为00，‘u’的编码为11100等等。经过这个编码设置之后我们可以发现，出现频率越高的字符越会在上层，这样它的编码越短；出现频率越低的字符越会在下层，编码越短。经过这样的设计，最终整个文本存储空间才会最大化的缩减。<br>　　最终我们可以得到下面这张编码表：</p>\n<img src=\"https://cdn.julis.wang/blog/img/20200319094927897.png\">\n\n<h3 id=\"2-5-字符串编码\"><a href=\"#2-5-字符串编码\" class=\"headerlink\" title=\"2.5 字符串编码\"></a>2.5 字符串编码</h3><p>　　有了上面的编码表之后，”we will we will r u”这句重新进行编码就可以得到很大的压缩，编码表示为：01 110 10 01 1111 00 00 10 01 110 10 01 1111 00 00 10 11101 10 11100。这样最终我们只需50位内存，比原ASCII码表示节约了2&#x2F;3空间，效果还是很理想的。当然现实中不是简单这样表示的，还需要考虑很多问题。</p>\n<h2 id=\"三、哈夫曼编码的压缩与解压\"><a href=\"#三、哈夫曼编码的压缩与解压\" class=\"headerlink\" title=\"三、哈夫曼编码的压缩与解压\"></a>三、哈夫曼编码的压缩与解压</h2><p>1、使用IO流逐字节读取文档。用一个数组（0~255,下标表示ASCII码）来保存不同字符出现的次数<br>2、建一个节点类，保存节点对象的信息。将数组每一位表示的字符和出现频次存入创建的节点，把所有节点存入一个链表。<br>3、根据节点存储的频次值，对链表进行从小到大排序<br>4、从链表中取出并删除最小的两个节点，创建一个他们的父节点，父节点不存字符，值为那两个节点的和，把那两个节点分别作为其左子节点和右子节点，最后把这个父节点存入链表。再次排序，取出并删除最小的两个节点，生成父节点，再存入…以此类推，最终生成一棵哈夫曼树。<br>5、对哈夫曼树进行遍历，使得叶子结点获得相应编码，同时把字符和它对应的哈夫曼编码存入HashMap</p>\n<h2 id=\"四、疑问\"><a href=\"#四、疑问\" class=\"headerlink\" title=\"四、疑问\"></a>四、疑问</h2><h3 id=\"4-1对于字符频率相等的情况\"><a href=\"#4-1对于字符频率相等的情况\" class=\"headerlink\" title=\"4.1对于字符频率相等的情况\"></a>4.1对于字符频率相等的情况</h3><p>我们在构建哈夫曼树的时候在想，如果我们的字符出现的频率相等的情况，那哈夫曼树岂不是很糟？<br>我们假设原来字符串长度为N，那么对于普通的ASCII编码得到的长度为8N，如果利用哈夫曼编码，对于每一个字符，最大的长度不会超过8层树因为ASCII编码总共只有2^8个字符，也就是说最极端的情况：一个文件中所有字符串中出现256个字符且重复次数是一样的，但这仍然对原来的文本有进行过压缩（毕竟出现次数相等的话，构造的哈夫曼树在8层之前还是有数据的，那些数据的位数&lt;8）最终的编码数一定是会&lt;8N</p>\n<h3 id=\"4-2解码冲突问题\"><a href=\"#4-2解码冲突问题\" class=\"headerlink\" title=\"4.2解码冲突问题\"></a>4.2解码冲突问题</h3><p>我们在解压遍历哈夫曼的时候，最终的编码不会冲突么？举例：上面我们得到得最终的编码是<br>01 110 10 01 1111 00 00 10 01 110 10 01 1111 00 00 10 11101 10 11100但是在实际的压缩中我们不会有分隔符最终的情况将会是：<br>0111010 0111110000100111010011111000010111011011100<br>于是我们怎么知道：前面的01是一个编码，为什那么0111就是一个编码呢？也就是说01是0111的前缀 。其实我们从这张图就能看出来：对于上述的字符串一定不会存在一个叫0111的编码，因为“w”字母代表的01已经没有子节点。其实中也可以看出一些区域是空着的比如：11、111、111、1110 没有数据，其实这都是满足了哈夫曼树的 <strong>左起字串不冲突原则</strong></p>\n<img src=\"https://cdn.julis.wang/blog/img/20200319094918382.png\">\n\n\n\n","cover":null,"images":["https://cdn.julis.wang/blog/img/20200319094704131.png","https://cdn.julis.wang/blog/img/20200319094810712.png","https://cdn.julis.wang/blog/img/20200319094824181.png","https://cdn.julis.wang/blog/img/20200319094841561.png","https://cdn.julis.wang/blog/img/2020031909485354.png","https://cdn.julis.wang/blog/img/20200319094902609.png","https://cdn.julis.wang/blog/img/20200319094918382.png","https://cdn.julis.wang/blog/img/20200319094927897.png"],"content":"<p><strong>哈夫曼树定义：</strong></p>\n<blockquote>\n<p>给定N个权值作为N个叶子结点，构造一棵二叉树，若该树的带权路径长度达到最小，称这样的二叉树为最优二叉树，也称为哈夫曼树(Huffman<br>Tree)。哈夫曼树是带权路径长度最短的树，权值较大的结点离根较近。</p>\n</blockquote>\n<p>例：在数据通信中，需要将传送的文字转换成二进制的字符串，用0，1码的不同排列来表示字符。例如，需传送的报文为“AFTER DATA EAR ARE ART AREA”，这里用到的字符集为“A，E，R，T，F，D”，各字母出现的次数为{8，4，5，3，1，1}。现要求为这些字母设计编码。要区别6个字母，最简单的二进制编码方式是等长编码，固定采用3位二进制，可分别用000、001、010、011、100、101对“A，E，R，T，F，D”进行编码发送，当对方接收报文时再按照三位一分进行译码。显然编码的长度取决报文中不同字符的个数。</p>\n<h2 id=\"哈夫曼树创建方法\"><a href=\"#哈夫曼树创建方法\" class=\"headerlink\" title=\"哈夫曼树创建方法\"></a>哈夫曼树创建方法</h2><p>摘自：<a href=\"https://blog.csdn.net/FX677588/article/details/70767446\">《详细图解哈夫曼Huffman编码树》</a></p>\n<h3 id=\"2-1-初始队列\"><a href=\"#2-1-初始队列\" class=\"headerlink\" title=\"2.1 初始队列\"></a>2.1 初始队列</h3><p>　　我们按出现频率高低将其放入一个优先级队列中，从左到右依次为频率逐渐增加。\n　</p>\n<img src=\"https://cdn.julis.wang/blog/img/20200319094704131.png\">\n<p>　　下面我们需要将这个队列转换成哈夫曼二叉树，哈夫曼二叉树是一颗带权重的二叉树，权重是由队列中每个字符出现的次数所决定的。并且哈夫曼二叉树始终保证权重越大的字符出现在越高的地方。</p>\n<h3 id=\"2-2-第一步合并\"><a href=\"#2-2-第一步合并\" class=\"headerlink\" title=\"2.2 第一步合并\"></a>2.2 第一步合并</h3><p>　　首先我们从左到右进行合并，依次构建二叉树。第一步取前两个字符u和r来构造初始二叉树，第一个字符作为左节点，第二个元素作为右节点，然后两个元素相加作为新空元素，并且两者权重相加作为新元素的权重。\n　　</p>\n<img src=\"https://cdn.julis.wang/blog/img/20200319094810712.png\">\n\n<p>　　同理，新元素可以和字符i再合并，如下：</p>\n<img src=\"https://cdn.julis.wang/blog/img/20200319094824181.png\">\n\n<h3 id=\"2-3-重新调整队列\"><a href=\"#2-3-重新调整队列\" class=\"headerlink\" title=\"2.3 重新调整队列\"></a>2.3 重新调整队列</h3><p>　　上图新元素权重相加后结果是变大了，需要对权重进行重新排序。\n　　</p>\n<img src=\"https://cdn.julis.wang/blog/img/20200319094841561.png\">\n<p>　　然后再依次从左到右合并，每合并一次则进行一次队列重新排序调整。如下：</p>\n<img src=\"https://cdn.julis.wang/blog/img/2020031909485354.png\">\n<p>　　经过多步操作之后，得到以下的哈夫曼二叉树结构，也就是一个带有权重的二叉树：</p>\n<img src=\"https://cdn.julis.wang/blog/img/20200319094902609.png\">\n\n<h3 id=\"2-4-哈夫曼编码\"><a href=\"#2-4-哈夫曼编码\" class=\"headerlink\" title=\"2.4 哈夫曼编码\"></a>2.4 哈夫曼编码</h3><p>　　有了上面带权重的二叉树之后，我们就可以进行编码了。我们把二叉树分支中左边的支路编码为0，右边分支表示为1，如下图：\n　</p>\n<img src=\"https://cdn.julis.wang/blog/img/20200319094918382.png\">\n<p>　　这样依次遍历这颗二叉树就可以获取得到所有字符的编码了。例如：‘ ’的编码为10，‘l’的编码为00，‘u’的编码为11100等等。经过这个编码设置之后我们可以发现，出现频率越高的字符越会在上层，这样它的编码越短；出现频率越低的字符越会在下层，编码越短。经过这样的设计，最终整个文本存储空间才会最大化的缩减。<br>　　最终我们可以得到下面这张编码表：</p>\n<img src=\"https://cdn.julis.wang/blog/img/20200319094927897.png\">\n\n<h3 id=\"2-5-字符串编码\"><a href=\"#2-5-字符串编码\" class=\"headerlink\" title=\"2.5 字符串编码\"></a>2.5 字符串编码</h3><p>　　有了上面的编码表之后，”we will we will r u”这句重新进行编码就可以得到很大的压缩，编码表示为：01 110 10 01 1111 00 00 10 01 110 10 01 1111 00 00 10 11101 10 11100。这样最终我们只需50位内存，比原ASCII码表示节约了2&#x2F;3空间，效果还是很理想的。当然现实中不是简单这样表示的，还需要考虑很多问题。</p>\n<h2 id=\"三、哈夫曼编码的压缩与解压\"><a href=\"#三、哈夫曼编码的压缩与解压\" class=\"headerlink\" title=\"三、哈夫曼编码的压缩与解压\"></a>三、哈夫曼编码的压缩与解压</h2><p>1、使用IO流逐字节读取文档。用一个数组（0~255,下标表示ASCII码）来保存不同字符出现的次数<br>2、建一个节点类，保存节点对象的信息。将数组每一位表示的字符和出现频次存入创建的节点，把所有节点存入一个链表。<br>3、根据节点存储的频次值，对链表进行从小到大排序<br>4、从链表中取出并删除最小的两个节点，创建一个他们的父节点，父节点不存字符，值为那两个节点的和，把那两个节点分别作为其左子节点和右子节点，最后把这个父节点存入链表。再次排序，取出并删除最小的两个节点，生成父节点，再存入…以此类推，最终生成一棵哈夫曼树。<br>5、对哈夫曼树进行遍历，使得叶子结点获得相应编码，同时把字符和它对应的哈夫曼编码存入HashMap</p>\n<h2 id=\"四、疑问\"><a href=\"#四、疑问\" class=\"headerlink\" title=\"四、疑问\"></a>四、疑问</h2><h3 id=\"4-1对于字符频率相等的情况\"><a href=\"#4-1对于字符频率相等的情况\" class=\"headerlink\" title=\"4.1对于字符频率相等的情况\"></a>4.1对于字符频率相等的情况</h3><p>我们在构建哈夫曼树的时候在想，如果我们的字符出现的频率相等的情况，那哈夫曼树岂不是很糟？<br>我们假设原来字符串长度为N，那么对于普通的ASCII编码得到的长度为8N，如果利用哈夫曼编码，对于每一个字符，最大的长度不会超过8层树因为ASCII编码总共只有2^8个字符，也就是说最极端的情况：一个文件中所有字符串中出现256个字符且重复次数是一样的，但这仍然对原来的文本有进行过压缩（毕竟出现次数相等的话，构造的哈夫曼树在8层之前还是有数据的，那些数据的位数&lt;8）最终的编码数一定是会&lt;8N</p>\n<h3 id=\"4-2解码冲突问题\"><a href=\"#4-2解码冲突问题\" class=\"headerlink\" title=\"4.2解码冲突问题\"></a>4.2解码冲突问题</h3><p>我们在解压遍历哈夫曼的时候，最终的编码不会冲突么？举例：上面我们得到得最终的编码是<br>01 110 10 01 1111 00 00 10 01 110 10 01 1111 00 00 10 11101 10 11100但是在实际的压缩中我们不会有分隔符最终的情况将会是：<br>0111010 0111110000100111010011111000010111011011100<br>于是我们怎么知道：前面的01是一个编码，为什那么0111就是一个编码呢？也就是说01是0111的前缀 。其实我们从这张图就能看出来：对于上述的字符串一定不会存在一个叫0111的编码，因为“w”字母代表的01已经没有子节点。其实中也可以看出一些区域是空着的比如：11、111、111、1110 没有数据，其实这都是满足了哈夫曼树的 <strong>左起字串不冲突原则</strong></p>\n<img src=\"https://cdn.julis.wang/blog/img/20200319094918382.png\">\n\n\n\n","categories":[{"name":"算法研究","slug":"算法研究","api":"api/categories/算法研究.json"}],"tags":[{"name":"技术文章","slug":"technology","api":"api/tags/technology.json"}],"api":"api/posts/2020/03/24/数据结构-哈夫曼Huffman树.json"},{"title":"(转)算法之优先队列 PriorityQueue解决Top K 问题","slug":"算法之优先队列-PriorityQueue解决Top-K-问题","date":"2019-10-10T01:51:00.000Z","updated":"2025-05-20T11:46:57.000Z","comments":true,"url":"2019/10/10/算法之优先队列-PriorityQueue解决Top-K-问题/","excerpt":"<p>转自：<a href=\"https://www.jianshu.com/p/a4a1984fc4ff\">https://www.jianshu.com/p/a4a1984fc4ff</a></p>\n<p>解决方法：<br>维护一个大小为 K 的小顶堆，依次将数据放入堆中，当堆的大小满了的时候，只需要将堆顶元素与下一个数比较：如果大于堆顶元素，则将当前的堆顶元素抛弃，并将该元素插入堆中。遍历完全部数据，Top K 的元素也自然都在堆里面了。</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/8807674-d32bc53ef9cadc8d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/770/format/webp\"></p>\n<p>当然，如果是求前 K 个最小的数，只需要改为大顶堆即可</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/8807674-e67fb606d0f5766a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/776/format/webp\"></p>\n<p> 将数据插入堆  95 大于 20，进行替换 95 下沉，维持小顶堆<br>对于海量数据，我们不需要一次性将全部数据取出来，可以一次只取一部分，因为我们只需要将数据一个个拿来与堆顶比较。</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/8807674-15eac9a1c7fb75e2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/788/format/webp\"></p>\n<p>另外还有一个优势就是对于动态数组，我们可以一直都维护一个 K 大小的小顶堆，当有数据被添加到集合中时，我们就直接拿它与堆顶的元素对比。这样，无论任何时候需要查询当前的前 K 大数据，我们都可以里立刻返回给他。</p>\n<p>整个操作中，遍历数组需要 O(n) 的时间复杂度，一次堆化操作需要 O(logK)，加起来就是 O(nlogK) 的复杂度，换个角度来看，如果 K 远小于 n 的话， O(nlogK) 其实就接近于 O(n) 了，甚至会更快，因此也是十分高效的。</p>\n<p>最后，对于 Java，我们可以直接使用优先队列 PriorityQueue 来实现一个小顶堆，这里给个代码：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">public static List&lt;Integer&gt; solutionByHeap(int[] input, int k) &#123;</span><br><span class=\"line\">        List&lt;Integer&gt; list = new ArrayList&lt;&gt;();</span><br><span class=\"line\">        if (k &gt; input.length || k == 0) &#123;</span><br><span class=\"line\">            return list;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        Queue&lt;Integer&gt; queue = new PriorityQueue&lt;&gt;();</span><br><span class=\"line\">        for (int num : input) &#123;</span><br><span class=\"line\">            if (queue.size() &lt; k) &#123;</span><br><span class=\"line\">                queue.add(num);</span><br><span class=\"line\">            &#125; else if (queue.peek() &lt; num) &#123;</span><br><span class=\"line\">                queue.poll();</span><br><span class=\"line\">                queue.add(num);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        while (k-- &gt; 0) &#123;</span><br><span class=\"line\">            list.add(queue.poll());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return list;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>","cover":null,"images":["https://upload-images.jianshu.io/upload_images/8807674-d32bc53ef9cadc8d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/770/format/webp","https://upload-images.jianshu.io/upload_images/8807674-e67fb606d0f5766a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/776/format/webp","https://upload-images.jianshu.io/upload_images/8807674-15eac9a1c7fb75e2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/788/format/webp"],"content":"<p>转自：<a href=\"https://www.jianshu.com/p/a4a1984fc4ff\">https://www.jianshu.com/p/a4a1984fc4ff</a></p>\n<p>解决方法：<br>维护一个大小为 K 的小顶堆，依次将数据放入堆中，当堆的大小满了的时候，只需要将堆顶元素与下一个数比较：如果大于堆顶元素，则将当前的堆顶元素抛弃，并将该元素插入堆中。遍历完全部数据，Top K 的元素也自然都在堆里面了。</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/8807674-d32bc53ef9cadc8d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/770/format/webp\"></p>\n<p>当然，如果是求前 K 个最小的数，只需要改为大顶堆即可</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/8807674-e67fb606d0f5766a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/776/format/webp\"></p>\n<p> 将数据插入堆  95 大于 20，进行替换 95 下沉，维持小顶堆<br>对于海量数据，我们不需要一次性将全部数据取出来，可以一次只取一部分，因为我们只需要将数据一个个拿来与堆顶比较。</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/8807674-15eac9a1c7fb75e2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/788/format/webp\"></p>\n<p>另外还有一个优势就是对于动态数组，我们可以一直都维护一个 K 大小的小顶堆，当有数据被添加到集合中时，我们就直接拿它与堆顶的元素对比。这样，无论任何时候需要查询当前的前 K 大数据，我们都可以里立刻返回给他。</p>\n<p>整个操作中，遍历数组需要 O(n) 的时间复杂度，一次堆化操作需要 O(logK)，加起来就是 O(nlogK) 的复杂度，换个角度来看，如果 K 远小于 n 的话， O(nlogK) 其实就接近于 O(n) 了，甚至会更快，因此也是十分高效的。</p>\n<p>最后，对于 Java，我们可以直接使用优先队列 PriorityQueue 来实现一个小顶堆，这里给个代码：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">public static List&lt;Integer&gt; solutionByHeap(int[] input, int k) &#123;</span><br><span class=\"line\">        List&lt;Integer&gt; list = new ArrayList&lt;&gt;();</span><br><span class=\"line\">        if (k &gt; input.length || k == 0) &#123;</span><br><span class=\"line\">            return list;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        Queue&lt;Integer&gt; queue = new PriorityQueue&lt;&gt;();</span><br><span class=\"line\">        for (int num : input) &#123;</span><br><span class=\"line\">            if (queue.size() &lt; k) &#123;</span><br><span class=\"line\">                queue.add(num);</span><br><span class=\"line\">            &#125; else if (queue.peek() &lt; num) &#123;</span><br><span class=\"line\">                queue.poll();</span><br><span class=\"line\">                queue.add(num);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        while (k-- &gt; 0) &#123;</span><br><span class=\"line\">            list.add(queue.poll());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return list;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>","categories":[{"name":"算法研究","slug":"算法研究","api":"api/categories/算法研究.json"}],"tags":[{"name":"算法","slug":"algorithm","api":"api/tags/algorithm.json"}],"api":"api/posts/2019/10/10/算法之优先队列-PriorityQueue解决Top-K-问题.json"}],"info":{"type":"category","name":"算法研究","slug":"算法研究"}},"api":"api/categories/算法研究/page.1.json"}