{"data":{"index":1,"total":1,"posts":[{"title":"JPEG压缩之DCT离散余弦变换","slug":"JPEG压缩之DCT离散余弦变换","date":"2025-11-04T14:25:17.000Z","updated":"2025-11-08T03:17:35.317Z","comments":true,"url":"2025/11/04/JPEG压缩之DCT离散余弦变换/","excerpt":"<p>在<a href=\"https://github.com/leandromoreira/digital_video_introduction.git\">digital_video_introduction</a>的一节中讲解 <a href=\"https://github.com/leandromoreira/digital_video_introduction/blob/master/README-cn.md#%E8%A7%86%E9%A2%91%E7%BC%96%E8%A7%A3%E7%A0%81%E5%99%A8%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84\">视频编解码器是如何工作的？</a>提到了 DCT，此前没有太关注，最近有对相关的原理进行学习了解，本文对 DCT 离散余弦变换相关的内容进行整理总结。<br>JPEG 使用的是 <strong>二维 DCT</strong>，因为它处理的是图像（二维信号）,理解二维 DCT 的基础是一维 DCT。</p>\n<h3 id=\"一维离散余弦变换\"><a href=\"#一维离散余弦变换\" class=\"headerlink\" title=\"一维离散余弦变换\"></a>一维离散余弦变换</h3><p>一维 DCT 将一个长度为 N 的信号序列（例如一行像素值）从空间域转换到频域。最常用的是 <strong>DCT-II</strong> 类型，这也是 JPEG 标准所使用的。</p>\n<p><strong>正变换：</strong> 从空间域到频域</p>\n<script type=\"math/tex; mode=display\">\n\nF(u) = C(u) \\sum_{x=0}^{N-1} f(x) \\cdot \\cos\\left[\\frac{\\pi u (2x + 1)}{2N}\\right]</script><p>其中：</p>\n<ul>\n<li><script type=\"math/tex\">f(x)</script>  是输入信号在位置 <script type=\"math/tex\">x</script> 的值（例如，像素亮度）。</li>\n<li><script type=\"math/tex\">F(u)</script>  是变换后得到的第 <script type=\"math/tex\">u</script> 个频率分量（DCT 系数）。</li>\n<li><script type=\"math/tex\">N</script>  是信号的长度（在 JPEG 中，通常是 8）。</li>\n<li><script type=\"math/tex\">u</script> 是频率索引，<script type=\"math/tex\">u = 0, 1, \\dots, N-1</script>。</li>\n<li><script type=\"math/tex\">x</script> 是空间位置索引，<script type=\"math/tex\">x = 0, 1, \\dots, N-1</script>。</li>\n<li><script type=\"math/tex\">C(u)</script> 是一个归一化系数，定义为：</li>\n</ul>\n<script type=\"math/tex; mode=display\">\n  C(u) = \\begin{cases}\n  \\sqrt{\\frac{1}{N}} & \\text{if } u = 0 \\\\\n  \\sqrt{\\frac{2}{N}} & \\text{if } u > 0\n  \\end{cases}</script><p><strong>关键点：</strong></p>\n<ul>\n<li>当 <script type=\"math/tex\">u = 0</script> 时，<script type=\"math/tex\">F(0)</script> 被称为 <strong>直流系数</strong>。它实际上是整个信号块的平均值。</li>\n<li>当 <script type=\"math/tex\">u > 0</script> 时，<script type=\"math/tex\">F(u)</script> 被称为 <strong>交流系数</strong>。它们代表了信号中不同频率的振荡模式。<script type=\"math/tex\">u</script> 越大，代表的频率越高。</li>\n</ul>\n<h3 id=\"二维离散余弦变换\"><a href=\"#二维离散余弦变换\" class=\"headerlink\" title=\"二维离散余弦变换\"></a>二维离散余弦变换</h3><p>JPEG 将图像分割成 8x8 的小块，然后对每个块独立进行二维 DCT。二维 DCT 可以看作先对每一行进行一维 DCT，然后再对每一列进行一维 DCT（顺序可互换）。</p>\n<p><strong>正变换：</strong> 从空间域到频域</p>\n<script type=\"math/tex; mode=display\">\n\nF(u, v) = C(u) C(v) \\sum_{x=0}^{N-1} \\sum_{y=0}^{N-1} f(x, y) \\cdot \\cos\\left[\\frac{\\pi u (2x + 1)}{2N}\\right] \\cdot \\cos\\left[\\frac{\\pi v (2y + 1)}{2N}\\right]</script><p>其中：</p>\n<ul>\n<li><script type=\"math/tex\">f(x, y)</script> 是 8x8 图像块中在位置 <script type=\"math/tex\">(x, y)</script> 的像素值。在计算前，通常会先将像素值减去 128（即 -128 到 127 的范围），使其围绕零对称。</li>\n<li><script type=\"math/tex\">F(u, v)</script> 是变换后得到的在频率 <script type=\"math/tex\">(u, v)</script> 上的 DCT 系数。</li>\n<li><script type=\"math/tex\">N = 8</script>（对于标准的 JPEG）。</li>\n<li><script type=\"math/tex\">u, v</script> 是频率索引，<script type=\"math/tex\">u, v = 0, 1, \\dots, 7</script>。</li>\n<li><script type=\"math/tex\">x, y</script> 是空间位置索引，<script type=\"math/tex\">x, y = 0, 1, \\dots, 7</script>。</li>\n<li><script type=\"math/tex\">C(u)</script> 和 <script type=\"math/tex\">C(v)</script> 的定义与一维情况相同：</li>\n</ul>\n<script type=\"math/tex; mode=display\">\n  C(u) = \\begin{cases}\n  \\sqrt{\\frac{1}{8}} & \\text{if } u = 0 \\\\\n  \\sqrt{\\frac{2}{8}} & \\text{if } u > 0\n  \\end{cases}</script><p>  同理于 <script type=\"math/tex\">C(v)</script>。</p>\n<p><strong>关键点：</strong></p>\n<ul>\n<li><script type=\"math/tex\">F(0, 0)</script> 是 <strong>直流系数</strong>，代表整个 8x8 块的平均亮度。</li>\n<li>所有其他的 <script type=\"math/tex\">F(u, v)</script> 都是 <strong>交流系数</strong>。</li>\n<li>系数 <script type=\"math/tex\">F(u, v)</script> 的 <script type=\"math/tex\">u</script> 和 <script type=\"math/tex\">v</script> 值越大，代表在水平和垂直方向上的频率越高。</li>\n<li>在变换后的 8x8 系数矩阵中，<strong>左上角是低频系数，右下角是高频系数</strong>。图像的大部分能量（信息）都集中在低频区域，这是 JPEG 能够实现高压缩比的关键。</li>\n</ul>\n<h3 id=\"逆离散余弦变换\"><a href=\"#逆离散余弦变换\" class=\"headerlink\" title=\"逆离散余弦变换\"></a>逆离散余弦变换</h3><p>为了从频域数据重建图像，需要使用逆 DCT。</p>\n<p><strong>逆变换：</strong> 从频域回到空间域</p>\n<script type=\"math/tex; mode=display\">\nf(x, y) = \\sum_{u=0}^{N-1} \\sum_{v=0}^{N-1} C(u) C(v) F(u, v) \\cdot \\cos\\left[\\frac{\\pi u (2x + 1)}{2N}\\right] \\cdot \\cos\\left[\\frac{\\pi v (2y + 1)}{2N}\\right]</script><p>公式中的各项含义与正变换完全相同。</p>\n<h3 id=\"简单理解\"><a href=\"#简单理解\" class=\"headerlink\" title=\"简单理解\"></a>简单理解</h3><p><strong>DCT的本质与核心直觉</strong></p>\n<p>DCT可以看作离散傅里叶变换（DFT）的一种特殊形式，主要处理实数信号，并且有很好的能量集中特性。</p>\n<p><strong>它的核心思想是</strong>：任何一个8x8的像素块，都可以看作是64种不同频率的标准余弦波（即“基础图案”）按照特定权重（也就是DCT系数）叠加而成的。<br><img src=\"https://ww2.mathworks.cn/help/images/basis8.gif\" alt=\"\"><br>在这些基础图案中：</p>\n<ul>\n<li><p>低频成分（对应于系数矩阵左上角，u和v值较小的部分）代表了图像块的大致轮廓和平滑变化的背景。</p>\n</li>\n<li><p>高频成分（对应于系数矩阵右下角，u和v值较大的部分）代表了图像块的细节、锐利边缘和纹理。</p>\n</li>\n</ul>\n<p>图像的大部分视觉能量（信息） 通常都集中在低频区域。这意味著，我们往往只需要少数几个大的低频系数，就能大致描述出图像块的主要样貌。</p>\n<p><strong>用二进制分解来类比DCT的能量集中</strong></p>\n<script type=\"math/tex; mode=display\">\n171=2^7+2^5+2^3+2^1+2^0</script><p>如果我们将所有的0系数也补上</p>\n<script type=\"math/tex; mode=display\">\n171=2^7+0*2^6+2^5+0*2^4+2^3+0*2^2+2^1+2^0</script><p>那么对应的系数数组为：[1,0,1,0,1,0,1,1]</p>\n<p>如果我们简单将数组低索引称之为”低频”，高索引为”高频”,将数据压缩只包含”低频”系数<br>[1,0,0,0,0,0,0,0]=&gt;2^7=128 大概丢了25%的信息<br>[1,0,1,0,0,0,0,0]=&gt;2^7+2^5=160 大概丢了6%的信息<br>[1,0,1,0,1,0,0,0]=&gt;2^7+2^5=160 大概丢了1%的信息<br>……</p>\n<p>可以看到“高频”信号对整个数据的影响比较小，这与DCT的思想不谋而合：我们保留对整体影响大的主要成分（低频系数），而舍弃或粗略表示那些影响细微的成分（高频系数），从而实现压缩。</p>\n<h3 id=\"总结-JPEG-压缩的流程\"><a href=\"#总结-JPEG-压缩的流程\" class=\"headerlink\" title=\"总结 JPEG 压缩的流程\"></a>总结 JPEG 压缩的流程</h3><ol>\n<li><strong>颜色空间转换</strong>：将图像从 RGB 转换到 YCbCr。</li>\n<li><strong>分块</strong>：将每个分量（Y, Cb, Cr）图像分割成 8x8 的块。</li>\n<li><strong>前向 DCT</strong>：对每个 8x8 块应用上述的二维 DCT 公式，得到频率系数。</li>\n<li><strong>量化</strong>：将 DCT 系数除以一个对应的量化步长（来自量化表），并四舍五入到整数。<strong>这一步是有损的，是信息丢失的主要来源</strong>。高频系数通常会被量化为 0。</li>\n<li><strong>熵编码</strong>：对量化后的系数进行 Zigzag 扫描、差分脉冲编码调制和霍夫曼编码，生成最终的 .jpg 文件。</li>\n</ol>\n<p>当解码时，过程是反过来的：熵解码 -&gt; 反量化 -&gt; 逆 DCT -&gt; 合并块 -&gt; 转换回 RGB。</p>\n<h3 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h3><p> <a href=\"https://zhuanlan.zhihu.com/p/40356456\">《影像算法解析——JPEG 压缩算法》</a><br> <a href=\"https://www.cnblogs.com/zxporz/p/16072580.html\">《白话文理解DCT离散余弦变换》</a><br> <a href=\"https://ww2.mathworks.cn/help/images/discrete-cosine-transform.html\">《离散余弦变换》</a><br> <strong>视频</strong><br> <a href=\"https://www.youtube.com/watch?v=0me3guauqOU\">The Unreasonable Effectiveness of JPEG: A Signal Processing Approach</a><br>中文翻译版本<a href=\"https://www.bilibili.com/video/BV1bc411q7YG/?spm_id_from=333.1387.favlist.content.click&amp;vd_source=3fd1362ef2060381db6c532cb37979dc\">《离散余弦变换可视化讲解》</a></p>\n","cover":null,"images":["https://ww2.mathworks.cn/help/images/basis8.gif"],"content":"<p>在<a href=\"https://github.com/leandromoreira/digital_video_introduction.git\">digital_video_introduction</a>的一节中讲解 <a href=\"https://github.com/leandromoreira/digital_video_introduction/blob/master/README-cn.md#%E8%A7%86%E9%A2%91%E7%BC%96%E8%A7%A3%E7%A0%81%E5%99%A8%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84\">视频编解码器是如何工作的？</a>提到了 DCT，此前没有太关注，最近有对相关的原理进行学习了解，本文对 DCT 离散余弦变换相关的内容进行整理总结。<br>JPEG 使用的是 <strong>二维 DCT</strong>，因为它处理的是图像（二维信号）,理解二维 DCT 的基础是一维 DCT。</p>\n<h3 id=\"一维离散余弦变换\"><a href=\"#一维离散余弦变换\" class=\"headerlink\" title=\"一维离散余弦变换\"></a>一维离散余弦变换</h3><p>一维 DCT 将一个长度为 N 的信号序列（例如一行像素值）从空间域转换到频域。最常用的是 <strong>DCT-II</strong> 类型，这也是 JPEG 标准所使用的。</p>\n<p><strong>正变换：</strong> 从空间域到频域</p>\n<script type=\"math/tex; mode=display\">\n\nF(u) = C(u) \\sum_{x=0}^{N-1} f(x) \\cdot \\cos\\left[\\frac{\\pi u (2x + 1)}{2N}\\right]</script><p>其中：</p>\n<ul>\n<li><script type=\"math/tex\">f(x)</script>  是输入信号在位置 <script type=\"math/tex\">x</script> 的值（例如，像素亮度）。</li>\n<li><script type=\"math/tex\">F(u)</script>  是变换后得到的第 <script type=\"math/tex\">u</script> 个频率分量（DCT 系数）。</li>\n<li><script type=\"math/tex\">N</script>  是信号的长度（在 JPEG 中，通常是 8）。</li>\n<li><script type=\"math/tex\">u</script> 是频率索引，<script type=\"math/tex\">u = 0, 1, \\dots, N-1</script>。</li>\n<li><script type=\"math/tex\">x</script> 是空间位置索引，<script type=\"math/tex\">x = 0, 1, \\dots, N-1</script>。</li>\n<li><script type=\"math/tex\">C(u)</script> 是一个归一化系数，定义为：</li>\n</ul>\n<script type=\"math/tex; mode=display\">\n  C(u) = \\begin{cases}\n  \\sqrt{\\frac{1}{N}} & \\text{if } u = 0 \\\\\n  \\sqrt{\\frac{2}{N}} & \\text{if } u > 0\n  \\end{cases}</script><p><strong>关键点：</strong></p>\n<ul>\n<li>当 <script type=\"math/tex\">u = 0</script> 时，<script type=\"math/tex\">F(0)</script> 被称为 <strong>直流系数</strong>。它实际上是整个信号块的平均值。</li>\n<li>当 <script type=\"math/tex\">u > 0</script> 时，<script type=\"math/tex\">F(u)</script> 被称为 <strong>交流系数</strong>。它们代表了信号中不同频率的振荡模式。<script type=\"math/tex\">u</script> 越大，代表的频率越高。</li>\n</ul>\n<h3 id=\"二维离散余弦变换\"><a href=\"#二维离散余弦变换\" class=\"headerlink\" title=\"二维离散余弦变换\"></a>二维离散余弦变换</h3><p>JPEG 将图像分割成 8x8 的小块，然后对每个块独立进行二维 DCT。二维 DCT 可以看作先对每一行进行一维 DCT，然后再对每一列进行一维 DCT（顺序可互换）。</p>\n<p><strong>正变换：</strong> 从空间域到频域</p>\n<script type=\"math/tex; mode=display\">\n\nF(u, v) = C(u) C(v) \\sum_{x=0}^{N-1} \\sum_{y=0}^{N-1} f(x, y) \\cdot \\cos\\left[\\frac{\\pi u (2x + 1)}{2N}\\right] \\cdot \\cos\\left[\\frac{\\pi v (2y + 1)}{2N}\\right]</script><p>其中：</p>\n<ul>\n<li><script type=\"math/tex\">f(x, y)</script> 是 8x8 图像块中在位置 <script type=\"math/tex\">(x, y)</script> 的像素值。在计算前，通常会先将像素值减去 128（即 -128 到 127 的范围），使其围绕零对称。</li>\n<li><script type=\"math/tex\">F(u, v)</script> 是变换后得到的在频率 <script type=\"math/tex\">(u, v)</script> 上的 DCT 系数。</li>\n<li><script type=\"math/tex\">N = 8</script>（对于标准的 JPEG）。</li>\n<li><script type=\"math/tex\">u, v</script> 是频率索引，<script type=\"math/tex\">u, v = 0, 1, \\dots, 7</script>。</li>\n<li><script type=\"math/tex\">x, y</script> 是空间位置索引，<script type=\"math/tex\">x, y = 0, 1, \\dots, 7</script>。</li>\n<li><script type=\"math/tex\">C(u)</script> 和 <script type=\"math/tex\">C(v)</script> 的定义与一维情况相同：</li>\n</ul>\n<script type=\"math/tex; mode=display\">\n  C(u) = \\begin{cases}\n  \\sqrt{\\frac{1}{8}} & \\text{if } u = 0 \\\\\n  \\sqrt{\\frac{2}{8}} & \\text{if } u > 0\n  \\end{cases}</script><p>  同理于 <script type=\"math/tex\">C(v)</script>。</p>\n<p><strong>关键点：</strong></p>\n<ul>\n<li><script type=\"math/tex\">F(0, 0)</script> 是 <strong>直流系数</strong>，代表整个 8x8 块的平均亮度。</li>\n<li>所有其他的 <script type=\"math/tex\">F(u, v)</script> 都是 <strong>交流系数</strong>。</li>\n<li>系数 <script type=\"math/tex\">F(u, v)</script> 的 <script type=\"math/tex\">u</script> 和 <script type=\"math/tex\">v</script> 值越大，代表在水平和垂直方向上的频率越高。</li>\n<li>在变换后的 8x8 系数矩阵中，<strong>左上角是低频系数，右下角是高频系数</strong>。图像的大部分能量（信息）都集中在低频区域，这是 JPEG 能够实现高压缩比的关键。</li>\n</ul>\n<h3 id=\"逆离散余弦变换\"><a href=\"#逆离散余弦变换\" class=\"headerlink\" title=\"逆离散余弦变换\"></a>逆离散余弦变换</h3><p>为了从频域数据重建图像，需要使用逆 DCT。</p>\n<p><strong>逆变换：</strong> 从频域回到空间域</p>\n<script type=\"math/tex; mode=display\">\nf(x, y) = \\sum_{u=0}^{N-1} \\sum_{v=0}^{N-1} C(u) C(v) F(u, v) \\cdot \\cos\\left[\\frac{\\pi u (2x + 1)}{2N}\\right] \\cdot \\cos\\left[\\frac{\\pi v (2y + 1)}{2N}\\right]</script><p>公式中的各项含义与正变换完全相同。</p>\n<h3 id=\"简单理解\"><a href=\"#简单理解\" class=\"headerlink\" title=\"简单理解\"></a>简单理解</h3><p><strong>DCT的本质与核心直觉</strong></p>\n<p>DCT可以看作离散傅里叶变换（DFT）的一种特殊形式，主要处理实数信号，并且有很好的能量集中特性。</p>\n<p><strong>它的核心思想是</strong>：任何一个8x8的像素块，都可以看作是64种不同频率的标准余弦波（即“基础图案”）按照特定权重（也就是DCT系数）叠加而成的。<br><img src=\"https://ww2.mathworks.cn/help/images/basis8.gif\" alt=\"\"><br>在这些基础图案中：</p>\n<ul>\n<li><p>低频成分（对应于系数矩阵左上角，u和v值较小的部分）代表了图像块的大致轮廓和平滑变化的背景。</p>\n</li>\n<li><p>高频成分（对应于系数矩阵右下角，u和v值较大的部分）代表了图像块的细节、锐利边缘和纹理。</p>\n</li>\n</ul>\n<p>图像的大部分视觉能量（信息） 通常都集中在低频区域。这意味著，我们往往只需要少数几个大的低频系数，就能大致描述出图像块的主要样貌。</p>\n<p><strong>用二进制分解来类比DCT的能量集中</strong></p>\n<script type=\"math/tex; mode=display\">\n171=2^7+2^5+2^3+2^1+2^0</script><p>如果我们将所有的0系数也补上</p>\n<script type=\"math/tex; mode=display\">\n171=2^7+0*2^6+2^5+0*2^4+2^3+0*2^2+2^1+2^0</script><p>那么对应的系数数组为：[1,0,1,0,1,0,1,1]</p>\n<p>如果我们简单将数组低索引称之为”低频”，高索引为”高频”,将数据压缩只包含”低频”系数<br>[1,0,0,0,0,0,0,0]=&gt;2^7=128 大概丢了25%的信息<br>[1,0,1,0,0,0,0,0]=&gt;2^7+2^5=160 大概丢了6%的信息<br>[1,0,1,0,1,0,0,0]=&gt;2^7+2^5=160 大概丢了1%的信息<br>……</p>\n<p>可以看到“高频”信号对整个数据的影响比较小，这与DCT的思想不谋而合：我们保留对整体影响大的主要成分（低频系数），而舍弃或粗略表示那些影响细微的成分（高频系数），从而实现压缩。</p>\n<h3 id=\"总结-JPEG-压缩的流程\"><a href=\"#总结-JPEG-压缩的流程\" class=\"headerlink\" title=\"总结 JPEG 压缩的流程\"></a>总结 JPEG 压缩的流程</h3><ol>\n<li><strong>颜色空间转换</strong>：将图像从 RGB 转换到 YCbCr。</li>\n<li><strong>分块</strong>：将每个分量（Y, Cb, Cr）图像分割成 8x8 的块。</li>\n<li><strong>前向 DCT</strong>：对每个 8x8 块应用上述的二维 DCT 公式，得到频率系数。</li>\n<li><strong>量化</strong>：将 DCT 系数除以一个对应的量化步长（来自量化表），并四舍五入到整数。<strong>这一步是有损的，是信息丢失的主要来源</strong>。高频系数通常会被量化为 0。</li>\n<li><strong>熵编码</strong>：对量化后的系数进行 Zigzag 扫描、差分脉冲编码调制和霍夫曼编码，生成最终的 .jpg 文件。</li>\n</ol>\n<p>当解码时，过程是反过来的：熵解码 -&gt; 反量化 -&gt; 逆 DCT -&gt; 合并块 -&gt; 转换回 RGB。</p>\n<h3 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h3><p> <a href=\"https://zhuanlan.zhihu.com/p/40356456\">《影像算法解析——JPEG 压缩算法》</a><br> <a href=\"https://www.cnblogs.com/zxporz/p/16072580.html\">《白话文理解DCT离散余弦变换》</a><br> <a href=\"https://ww2.mathworks.cn/help/images/discrete-cosine-transform.html\">《离散余弦变换》</a><br> <strong>视频</strong><br> <a href=\"https://www.youtube.com/watch?v=0me3guauqOU\">The Unreasonable Effectiveness of JPEG: A Signal Processing Approach</a><br>中文翻译版本<a href=\"https://www.bilibili.com/video/BV1bc411q7YG/?spm_id_from=333.1387.favlist.content.click&amp;vd_source=3fd1362ef2060381db6c532cb37979dc\">《离散余弦变换可视化讲解》</a></p>\n","categories":[{"name":"算法研究","slug":"算法研究","api":"api/categories/算法研究.json"}],"tags":[{"name":"数学","slug":"数学","api":"api/tags/数学.json"}],"api":"api/posts/2025/11/04/JPEG压缩之DCT离散余弦变换.json"},{"title":"扇形等分-突然想到的一个数学问题","slug":"扇形等分-突然想到的一个数学问题","date":"2020-09-01T07:13:00.000Z","updated":"2025-11-08T03:27:40.918Z","comments":true,"url":"2020/09/01/扇形等分-突然想到的一个数学问题/","excerpt":"<p>ps:博客有可能会因为一些 markdown 兼容性不支持，可以查看：<br><a href=\"https://www.douban.com/note/776327336/\">https://www.douban.com/note/776327336/</a></p>\n<img src=\"https://cdn.julis.wang/blog/img/1521743510550.jpg\">\n","cover":null,"images":["https://cdn.julis.wang/blog/img/1521743510550.jpg"],"content":"<p>ps:博客有可能会因为一些 markdown 兼容性不支持，可以查看：<br><a href=\"https://www.douban.com/note/776327336/\">https://www.douban.com/note/776327336/</a></p>\n<img src=\"https://cdn.julis.wang/blog/img/1521743510550.jpg\">\n","categories":[{"name":"算法研究","slug":"算法研究","api":"api/categories/算法研究.json"}],"tags":[{"name":"数学","slug":"数学","api":"api/tags/数学.json"}],"api":"api/posts/2020/09/01/扇形等分-突然想到的一个数学问题.json"},{"title":"哈夫曼树与编码","slug":"数据结构-哈夫曼Huffman树","date":"2020-03-24T01:38:00.000Z","updated":"2025-05-20T11:46:57.000Z","comments":true,"url":"2020/03/24/数据结构-哈夫曼Huffman树/","excerpt":"<p><strong>哈夫曼树定义：</strong></p>\n<blockquote>\n<p>给定N个权值作为N个叶子结点，构造一棵二叉树，若该树的带权路径长度达到最小，称这样的二叉树为最优二叉树，也称为哈夫曼树(Huffman<br>Tree)。哈夫曼树是带权路径长度最短的树，权值较大的结点离根较近。</p>\n</blockquote>\n<p>例：在数据通信中，需要将传送的文字转换成二进制的字符串，用0，1码的不同排列来表示字符。例如，需传送的报文为“AFTER DATA EAR ARE ART AREA”，这里用到的字符集为“A，E，R，T，F，D”，各字母出现的次数为{8，4，5，3，1，1}。现要求为这些字母设计编码。要区别6个字母，最简单的二进制编码方式是等长编码，固定采用3位二进制，可分别用000、001、010、011、100、101对“A，E，R，T，F，D”进行编码发送，当对方接收报文时再按照三位一分进行译码。显然编码的长度取决报文中不同字符的个数。</p>\n<h2 id=\"哈夫曼树创建方法\"><a href=\"#哈夫曼树创建方法\" class=\"headerlink\" title=\"哈夫曼树创建方法\"></a>哈夫曼树创建方法</h2><p>摘自：<a href=\"https://blog.csdn.net/FX677588/article/details/70767446\">《详细图解哈夫曼Huffman编码树》</a></p>\n<h3 id=\"2-1-初始队列\"><a href=\"#2-1-初始队列\" class=\"headerlink\" title=\"2.1 初始队列\"></a>2.1 初始队列</h3><p>　　我们按出现频率高低将其放入一个优先级队列中，从左到右依次为频率逐渐增加。<br>　<br><img src=\"https://cdn.julis.wang/blog/img/20200319094704131.png\"><br>　　下面我们需要将这个队列转换成哈夫曼二叉树，哈夫曼二叉树是一颗带权重的二叉树，权重是由队列中每个字符出现的次数所决定的。并且哈夫曼二叉树始终保证权重越大的字符出现在越高的地方。</p>\n<h3 id=\"2-2-第一步合并\"><a href=\"#2-2-第一步合并\" class=\"headerlink\" title=\"2.2 第一步合并\"></a>2.2 第一步合并</h3><p>　　首先我们从左到右进行合并，依次构建二叉树。第一步取前两个字符u和r来构造初始二叉树，第一个字符作为左节点，第二个元素作为右节点，然后两个元素相加作为新空元素，并且两者权重相加作为新元素的权重。<br>　　<br><img src=\"https://cdn.julis.wang/blog/img/20200319094810712.png\"></p>\n<p>　　同理，新元素可以和字符i再合并，如下：</p>\n<img src=\"https://cdn.julis.wang/blog/img/20200319094824181.png\">\n<h3 id=\"2-3-重新调整队列\"><a href=\"#2-3-重新调整队列\" class=\"headerlink\" title=\"2.3 重新调整队列\"></a>2.3 重新调整队列</h3><p>　　上图新元素权重相加后结果是变大了，需要对权重进行重新排序。<br>　　<br><img src=\"https://cdn.julis.wang/blog/img/20200319094841561.png\"><br>　　然后再依次从左到右合并，每合并一次则进行一次队列重新排序调整。如下：<br><img src=\"https://cdn.julis.wang/blog/img/2020031909485354.png\"><br>　　经过多步操作之后，得到以下的哈夫曼二叉树结构，也就是一个带有权重的二叉树：</p>\n<img src=\"https://cdn.julis.wang/blog/img/20200319094902609.png\">\n<h3 id=\"2-4-哈夫曼编码\"><a href=\"#2-4-哈夫曼编码\" class=\"headerlink\" title=\"2.4 哈夫曼编码\"></a>2.4 哈夫曼编码</h3><p>　　有了上面带权重的二叉树之后，我们就可以进行编码了。我们把二叉树分支中左边的支路编码为0，右边分支表示为1，如下图：\n　</p>\n<img src=\"https://cdn.julis.wang/blog/img/20200319094918382.png\">\n<p>　　这样依次遍历这颗二叉树就可以获取得到所有字符的编码了。例如：‘ ’的编码为10，‘l’的编码为00，‘u’的编码为11100等等。经过这个编码设置之后我们可以发现，出现频率越高的字符越会在上层，这样它的编码越短；出现频率越低的字符越会在下层，编码越短。经过这样的设计，最终整个文本存储空间才会最大化的缩减。<br>　　最终我们可以得到下面这张编码表：</p>\n<img src=\"https://cdn.julis.wang/blog/img/20200319094927897.png\">\n<h3 id=\"2-5-字符串编码\"><a href=\"#2-5-字符串编码\" class=\"headerlink\" title=\"2.5 字符串编码\"></a>2.5 字符串编码</h3><p>　　有了上面的编码表之后，”we will we will r u”这句重新进行编码就可以得到很大的压缩，编码表示为：01 110 10 01 1111 00 00 10 01 110 10 01 1111 00 00 10 11101 10 11100。这样最终我们只需50位内存，比原ASCII码表示节约了2/3空间，效果还是很理想的。当然现实中不是简单这样表示的，还需要考虑很多问题。</p>\n<h2 id=\"三、哈夫曼编码的压缩与解压\"><a href=\"#三、哈夫曼编码的压缩与解压\" class=\"headerlink\" title=\"三、哈夫曼编码的压缩与解压\"></a>三、哈夫曼编码的压缩与解压</h2><p>1、使用IO流逐字节读取文档。用一个数组（0~255,下标表示ASCII码）来保存不同字符出现的次数<br>2、建一个节点类，保存节点对象的信息。将数组每一位表示的字符和出现频次存入创建的节点，把所有节点存入一个链表。<br>3、根据节点存储的频次值，对链表进行从小到大排序<br>4、从链表中取出并删除最小的两个节点，创建一个他们的父节点，父节点不存字符，值为那两个节点的和，把那两个节点分别作为其左子节点和右子节点，最后把这个父节点存入链表。再次排序，取出并删除最小的两个节点，生成父节点，再存入…以此类推，最终生成一棵哈夫曼树。<br>5、对哈夫曼树进行遍历，使得叶子结点获得相应编码，同时把字符和它对应的哈夫曼编码存入HashMap</p>\n<h2 id=\"四、疑问\"><a href=\"#四、疑问\" class=\"headerlink\" title=\"四、疑问\"></a>四、疑问</h2><h3 id=\"4-1对于字符频率相等的情况\"><a href=\"#4-1对于字符频率相等的情况\" class=\"headerlink\" title=\"4.1对于字符频率相等的情况\"></a>4.1对于字符频率相等的情况</h3><p>我们在构建哈夫曼树的时候在想，如果我们的字符出现的频率相等的情况，那哈夫曼树岂不是很糟？<br>我们假设原来字符串长度为N，那么对于普通的ASCII编码得到的长度为8N，如果利用哈夫曼编码，对于每一个字符，最大的长度不会超过8层树因为ASCII编码总共只有2^8个字符，也就是说最极端的情况：一个文件中所有字符串中出现256个字符且重复次数是一样的，但这仍然对原来的文本有进行过压缩（毕竟出现次数相等的话，构造的哈夫曼树在8层之前还是有数据的，那些数据的位数&lt;8）最终的编码数一定是会&lt;8N</p>\n<h3 id=\"4-2解码冲突问题\"><a href=\"#4-2解码冲突问题\" class=\"headerlink\" title=\"4.2解码冲突问题\"></a>4.2解码冲突问题</h3><p>我们在解压遍历哈夫曼的时候，最终的编码不会冲突么？举例：上面我们得到得最终的编码是<br>01 110 10 01 1111 00 00 10 01 110 10 01 1111 00 00 10 11101 10 11100但是在实际的压缩中我们不会有分隔符最终的情况将会是：<br>0111010 0111110000100111010011111000010111011011100<br>于是我们怎么知道：前面的01是一个编码，为什那么0111就是一个编码呢？也就是说01是0111的前缀 。其实我们从这张图就能看出来：对于上述的字符串一定不会存在一个叫0111的编码，因为“w”字母代表的01已经没有子节点。其实中也可以看出一些区域是空着的比如：11、111、111、1110 没有数据，其实这都是满足了哈夫曼树的 <strong>左起字串不冲突原则</strong></p>\n<img src=\"https://cdn.julis.wang/blog/img/20200319094918382.png\">\n","cover":null,"images":["https://cdn.julis.wang/blog/img/20200319094704131.png","https://cdn.julis.wang/blog/img/20200319094810712.png","https://cdn.julis.wang/blog/img/20200319094824181.png","https://cdn.julis.wang/blog/img/20200319094841561.png","https://cdn.julis.wang/blog/img/20200319094902609.png","https://cdn.julis.wang/blog/img/20200319094918382.png","https://cdn.julis.wang/blog/img/20200319094927897.png"],"content":"<p><strong>哈夫曼树定义：</strong></p>\n<blockquote>\n<p>给定N个权值作为N个叶子结点，构造一棵二叉树，若该树的带权路径长度达到最小，称这样的二叉树为最优二叉树，也称为哈夫曼树(Huffman<br>Tree)。哈夫曼树是带权路径长度最短的树，权值较大的结点离根较近。</p>\n</blockquote>\n<p>例：在数据通信中，需要将传送的文字转换成二进制的字符串，用0，1码的不同排列来表示字符。例如，需传送的报文为“AFTER DATA EAR ARE ART AREA”，这里用到的字符集为“A，E，R，T，F，D”，各字母出现的次数为{8，4，5，3，1，1}。现要求为这些字母设计编码。要区别6个字母，最简单的二进制编码方式是等长编码，固定采用3位二进制，可分别用000、001、010、011、100、101对“A，E，R，T，F，D”进行编码发送，当对方接收报文时再按照三位一分进行译码。显然编码的长度取决报文中不同字符的个数。</p>\n<h2 id=\"哈夫曼树创建方法\"><a href=\"#哈夫曼树创建方法\" class=\"headerlink\" title=\"哈夫曼树创建方法\"></a>哈夫曼树创建方法</h2><p>摘自：<a href=\"https://blog.csdn.net/FX677588/article/details/70767446\">《详细图解哈夫曼Huffman编码树》</a></p>\n<h3 id=\"2-1-初始队列\"><a href=\"#2-1-初始队列\" class=\"headerlink\" title=\"2.1 初始队列\"></a>2.1 初始队列</h3><p>　　我们按出现频率高低将其放入一个优先级队列中，从左到右依次为频率逐渐增加。<br>　<br><img src=\"https://cdn.julis.wang/blog/img/20200319094704131.png\"><br>　　下面我们需要将这个队列转换成哈夫曼二叉树，哈夫曼二叉树是一颗带权重的二叉树，权重是由队列中每个字符出现的次数所决定的。并且哈夫曼二叉树始终保证权重越大的字符出现在越高的地方。</p>\n<h3 id=\"2-2-第一步合并\"><a href=\"#2-2-第一步合并\" class=\"headerlink\" title=\"2.2 第一步合并\"></a>2.2 第一步合并</h3><p>　　首先我们从左到右进行合并，依次构建二叉树。第一步取前两个字符u和r来构造初始二叉树，第一个字符作为左节点，第二个元素作为右节点，然后两个元素相加作为新空元素，并且两者权重相加作为新元素的权重。<br>　　<br><img src=\"https://cdn.julis.wang/blog/img/20200319094810712.png\"></p>\n<p>　　同理，新元素可以和字符i再合并，如下：</p>\n<img src=\"https://cdn.julis.wang/blog/img/20200319094824181.png\">\n<h3 id=\"2-3-重新调整队列\"><a href=\"#2-3-重新调整队列\" class=\"headerlink\" title=\"2.3 重新调整队列\"></a>2.3 重新调整队列</h3><p>　　上图新元素权重相加后结果是变大了，需要对权重进行重新排序。<br>　　<br><img src=\"https://cdn.julis.wang/blog/img/20200319094841561.png\"><br>　　然后再依次从左到右合并，每合并一次则进行一次队列重新排序调整。如下：<br><img src=\"https://cdn.julis.wang/blog/img/2020031909485354.png\"><br>　　经过多步操作之后，得到以下的哈夫曼二叉树结构，也就是一个带有权重的二叉树：</p>\n<img src=\"https://cdn.julis.wang/blog/img/20200319094902609.png\">\n<h3 id=\"2-4-哈夫曼编码\"><a href=\"#2-4-哈夫曼编码\" class=\"headerlink\" title=\"2.4 哈夫曼编码\"></a>2.4 哈夫曼编码</h3><p>　　有了上面带权重的二叉树之后，我们就可以进行编码了。我们把二叉树分支中左边的支路编码为0，右边分支表示为1，如下图：\n　</p>\n<img src=\"https://cdn.julis.wang/blog/img/20200319094918382.png\">\n<p>　　这样依次遍历这颗二叉树就可以获取得到所有字符的编码了。例如：‘ ’的编码为10，‘l’的编码为00，‘u’的编码为11100等等。经过这个编码设置之后我们可以发现，出现频率越高的字符越会在上层，这样它的编码越短；出现频率越低的字符越会在下层，编码越短。经过这样的设计，最终整个文本存储空间才会最大化的缩减。<br>　　最终我们可以得到下面这张编码表：</p>\n<img src=\"https://cdn.julis.wang/blog/img/20200319094927897.png\">\n<h3 id=\"2-5-字符串编码\"><a href=\"#2-5-字符串编码\" class=\"headerlink\" title=\"2.5 字符串编码\"></a>2.5 字符串编码</h3><p>　　有了上面的编码表之后，”we will we will r u”这句重新进行编码就可以得到很大的压缩，编码表示为：01 110 10 01 1111 00 00 10 01 110 10 01 1111 00 00 10 11101 10 11100。这样最终我们只需50位内存，比原ASCII码表示节约了2/3空间，效果还是很理想的。当然现实中不是简单这样表示的，还需要考虑很多问题。</p>\n<h2 id=\"三、哈夫曼编码的压缩与解压\"><a href=\"#三、哈夫曼编码的压缩与解压\" class=\"headerlink\" title=\"三、哈夫曼编码的压缩与解压\"></a>三、哈夫曼编码的压缩与解压</h2><p>1、使用IO流逐字节读取文档。用一个数组（0~255,下标表示ASCII码）来保存不同字符出现的次数<br>2、建一个节点类，保存节点对象的信息。将数组每一位表示的字符和出现频次存入创建的节点，把所有节点存入一个链表。<br>3、根据节点存储的频次值，对链表进行从小到大排序<br>4、从链表中取出并删除最小的两个节点，创建一个他们的父节点，父节点不存字符，值为那两个节点的和，把那两个节点分别作为其左子节点和右子节点，最后把这个父节点存入链表。再次排序，取出并删除最小的两个节点，生成父节点，再存入…以此类推，最终生成一棵哈夫曼树。<br>5、对哈夫曼树进行遍历，使得叶子结点获得相应编码，同时把字符和它对应的哈夫曼编码存入HashMap</p>\n<h2 id=\"四、疑问\"><a href=\"#四、疑问\" class=\"headerlink\" title=\"四、疑问\"></a>四、疑问</h2><h3 id=\"4-1对于字符频率相等的情况\"><a href=\"#4-1对于字符频率相等的情况\" class=\"headerlink\" title=\"4.1对于字符频率相等的情况\"></a>4.1对于字符频率相等的情况</h3><p>我们在构建哈夫曼树的时候在想，如果我们的字符出现的频率相等的情况，那哈夫曼树岂不是很糟？<br>我们假设原来字符串长度为N，那么对于普通的ASCII编码得到的长度为8N，如果利用哈夫曼编码，对于每一个字符，最大的长度不会超过8层树因为ASCII编码总共只有2^8个字符，也就是说最极端的情况：一个文件中所有字符串中出现256个字符且重复次数是一样的，但这仍然对原来的文本有进行过压缩（毕竟出现次数相等的话，构造的哈夫曼树在8层之前还是有数据的，那些数据的位数&lt;8）最终的编码数一定是会&lt;8N</p>\n<h3 id=\"4-2解码冲突问题\"><a href=\"#4-2解码冲突问题\" class=\"headerlink\" title=\"4.2解码冲突问题\"></a>4.2解码冲突问题</h3><p>我们在解压遍历哈夫曼的时候，最终的编码不会冲突么？举例：上面我们得到得最终的编码是<br>01 110 10 01 1111 00 00 10 01 110 10 01 1111 00 00 10 11101 10 11100但是在实际的压缩中我们不会有分隔符最终的情况将会是：<br>0111010 0111110000100111010011111000010111011011100<br>于是我们怎么知道：前面的01是一个编码，为什那么0111就是一个编码呢？也就是说01是0111的前缀 。其实我们从这张图就能看出来：对于上述的字符串一定不会存在一个叫0111的编码，因为“w”字母代表的01已经没有子节点。其实中也可以看出一些区域是空着的比如：11、111、111、1110 没有数据，其实这都是满足了哈夫曼树的 <strong>左起字串不冲突原则</strong></p>\n<img src=\"https://cdn.julis.wang/blog/img/20200319094918382.png\">\n","categories":[{"name":"算法研究","slug":"算法研究","api":"api/categories/算法研究.json"}],"tags":[{"name":"技术文章","slug":"technology","api":"api/tags/technology.json"}],"api":"api/posts/2020/03/24/数据结构-哈夫曼Huffman树.json"},{"title":"(转)算法之优先队列 PriorityQueue解决Top K 问题","slug":"算法之优先队列-PriorityQueue解决Top-K-问题","date":"2019-10-10T01:51:00.000Z","updated":"2025-05-20T11:46:57.000Z","comments":true,"url":"2019/10/10/算法之优先队列-PriorityQueue解决Top-K-问题/","excerpt":"<p>转自：<a href=\"https://www.jianshu.com/p/a4a1984fc4ff\">https://www.jianshu.com/p/a4a1984fc4ff</a></p>\n<p>解决方法：<br>维护一个大小为 K 的小顶堆，依次将数据放入堆中，当堆的大小满了的时候，只需要将堆顶元素与下一个数比较：如果大于堆顶元素，则将当前的堆顶元素抛弃，并将该元素插入堆中。遍历完全部数据，Top K 的元素也自然都在堆里面了。</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/8807674-d32bc53ef9cadc8d.png?imageMogr2/auto-orient/strip|imageView2/2/w/770/format/webp\" alt=\"\"></p>\n<p>当然，如果是求前 K 个最小的数，只需要改为大顶堆即可</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/8807674-e67fb606d0f5766a.png?imageMogr2/auto-orient/strip|imageView2/2/w/776/format/webp\" alt=\"\"></p>\n<p> 将数据插入堆  95 大于 20，进行替换 95 下沉，维持小顶堆<br>对于海量数据，我们不需要一次性将全部数据取出来，可以一次只取一部分，因为我们只需要将数据一个个拿来与堆顶比较。</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/8807674-15eac9a1c7fb75e2.png?imageMogr2/auto-orient/strip|imageView2/2/w/788/format/webp\" alt=\"\"></p>\n<p>另外还有一个优势就是对于动态数组，我们可以一直都维护一个 K 大小的小顶堆，当有数据被添加到集合中时，我们就直接拿它与堆顶的元素对比。这样，无论任何时候需要查询当前的前 K 大数据，我们都可以里立刻返回给他。</p>\n<p>整个操作中，遍历数组需要 O(n) 的时间复杂度，一次堆化操作需要 O(logK)，加起来就是 O(nlogK) 的复杂度，换个角度来看，如果 K 远小于 n 的话， O(nlogK) 其实就接近于 O(n) 了，甚至会更快，因此也是十分高效的。</p>\n<p>最后，对于 Java，我们可以直接使用优先队列 PriorityQueue 来实现一个小顶堆，这里给个代码：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">public static List&lt;Integer&gt; solutionByHeap(int[] input, int k) &#123;</span><br><span class=\"line\">        List&lt;Integer&gt; list = new ArrayList&lt;&gt;();</span><br><span class=\"line\">        if (k &gt; input.length || k == 0) &#123;</span><br><span class=\"line\">            return list;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        Queue&lt;Integer&gt; queue = new PriorityQueue&lt;&gt;();</span><br><span class=\"line\">        for (int num : input) &#123;</span><br><span class=\"line\">            if (queue.size() &lt; k) &#123;</span><br><span class=\"line\">                queue.add(num);</span><br><span class=\"line\">            &#125; else if (queue.peek() &lt; num) &#123;</span><br><span class=\"line\">                queue.poll();</span><br><span class=\"line\">                queue.add(num);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        while (k-- &gt; 0) &#123;</span><br><span class=\"line\">            list.add(queue.poll());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return list;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>","cover":null,"images":["https://upload-images.jianshu.io/upload_images/8807674-d32bc53ef9cadc8d.png?imageMogr2/auto-orient/strip|imageView2/2/w/770/format/webp","https://upload-images.jianshu.io/upload_images/8807674-e67fb606d0f5766a.png?imageMogr2/auto-orient/strip|imageView2/2/w/776/format/webp","https://upload-images.jianshu.io/upload_images/8807674-15eac9a1c7fb75e2.png?imageMogr2/auto-orient/strip|imageView2/2/w/788/format/webp"],"content":"<p>转自：<a href=\"https://www.jianshu.com/p/a4a1984fc4ff\">https://www.jianshu.com/p/a4a1984fc4ff</a></p>\n<p>解决方法：<br>维护一个大小为 K 的小顶堆，依次将数据放入堆中，当堆的大小满了的时候，只需要将堆顶元素与下一个数比较：如果大于堆顶元素，则将当前的堆顶元素抛弃，并将该元素插入堆中。遍历完全部数据，Top K 的元素也自然都在堆里面了。</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/8807674-d32bc53ef9cadc8d.png?imageMogr2/auto-orient/strip|imageView2/2/w/770/format/webp\" alt=\"\"></p>\n<p>当然，如果是求前 K 个最小的数，只需要改为大顶堆即可</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/8807674-e67fb606d0f5766a.png?imageMogr2/auto-orient/strip|imageView2/2/w/776/format/webp\" alt=\"\"></p>\n<p> 将数据插入堆  95 大于 20，进行替换 95 下沉，维持小顶堆<br>对于海量数据，我们不需要一次性将全部数据取出来，可以一次只取一部分，因为我们只需要将数据一个个拿来与堆顶比较。</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/8807674-15eac9a1c7fb75e2.png?imageMogr2/auto-orient/strip|imageView2/2/w/788/format/webp\" alt=\"\"></p>\n<p>另外还有一个优势就是对于动态数组，我们可以一直都维护一个 K 大小的小顶堆，当有数据被添加到集合中时，我们就直接拿它与堆顶的元素对比。这样，无论任何时候需要查询当前的前 K 大数据，我们都可以里立刻返回给他。</p>\n<p>整个操作中，遍历数组需要 O(n) 的时间复杂度，一次堆化操作需要 O(logK)，加起来就是 O(nlogK) 的复杂度，换个角度来看，如果 K 远小于 n 的话， O(nlogK) 其实就接近于 O(n) 了，甚至会更快，因此也是十分高效的。</p>\n<p>最后，对于 Java，我们可以直接使用优先队列 PriorityQueue 来实现一个小顶堆，这里给个代码：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">public static List&lt;Integer&gt; solutionByHeap(int[] input, int k) &#123;</span><br><span class=\"line\">        List&lt;Integer&gt; list = new ArrayList&lt;&gt;();</span><br><span class=\"line\">        if (k &gt; input.length || k == 0) &#123;</span><br><span class=\"line\">            return list;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        Queue&lt;Integer&gt; queue = new PriorityQueue&lt;&gt;();</span><br><span class=\"line\">        for (int num : input) &#123;</span><br><span class=\"line\">            if (queue.size() &lt; k) &#123;</span><br><span class=\"line\">                queue.add(num);</span><br><span class=\"line\">            &#125; else if (queue.peek() &lt; num) &#123;</span><br><span class=\"line\">                queue.poll();</span><br><span class=\"line\">                queue.add(num);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        while (k-- &gt; 0) &#123;</span><br><span class=\"line\">            list.add(queue.poll());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return list;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>","categories":[{"name":"算法研究","slug":"算法研究","api":"api/categories/算法研究.json"}],"tags":[{"name":"算法","slug":"algorithm","api":"api/tags/algorithm.json"}],"api":"api/posts/2019/10/10/算法之优先队列-PriorityQueue解决Top-K-问题.json"}],"info":{"type":"category","name":"算法研究","slug":"算法研究"}},"api":"api/categories/算法研究/page.1.json"}