{"data":{"index":4,"total":5,"posts":[{"title":"Android 插件化之ClassLoader","slug":"Android-插件化之ClassLoader","date":"2019-08-26T08:47:00.000Z","updated":"2025-05-20T11:46:57.000Z","comments":true,"url":"2019/08/26/Android-插件化之ClassLoader/","excerpt":"<p><strong>插件化要解决的三个核心问题：类加载、资源加载、组件生命周期管理。</strong></p>\n<p>在Android插件化中其原理实际是 Java ClassLoader的原理，此博文主要对Android插件化中类加载中的DexClassLoader做总结，便于之后对Android插件化的理解学习。</p>\n<p>Android的Dalvik虚拟机和Java虚拟机的运行原理相同都是将对应的java类加载在内存中运行。而Java虚拟机是加载class文件，也可以将一段二进制流通过defineClass方法生产Class进行加载。Dalvik虚拟机加载的dex文件。dex文件是Android对与Class文件做的优化，以便于提高手机的性能。可以想象dex为class文件的一个压缩文件。dex在Android中的加载和class在jvm中的相同都是基于双亲委派模型，都是调用ClassLoader的loadClass方法加载类。</p>\n<h2 id=\"1、DexClassLoader和PathClassLoader区别\"><a href=\"#1、DexClassLoader和PathClassLoader区别\" class=\"headerlink\" title=\"1、DexClassLoader和PathClassLoader区别\"></a><strong>1、DexClassLoader和PathClassLoader区别</strong></h2><p>Android 也有自己的 ClassLoader，分为 <code>DexClassLoader</code>和<code>PathClassLoader</code>，这两者有什么区别和关联呢？</p>\n<p>阅读源码可以看到两者的构造方法分别为：</p>\n<pre><code>public class PathClassLoader extends BaseDexClassLoader &#123;\n    public PathClassLoader(String dexPath, ClassLoader parent) &#123;\n        super(dexPath, null, null, parent);\n    &#125;\n    public PathClassLoader(String dexPath, String libraryPath,\n            ClassLoader parent) &#123;\n        super(dexPath, null, libraryPath, parent);\n    &#125;\n&#125;\n\npublic class DexClassLoader extends BaseDexClassLoader &#123;\n    public DexClassLoader(String dexPath, String optimizedDirectory,\n            String libraryPath, ClassLoader parent) &#123;\n        super(dexPath, new File(optimizedDirectory), libraryPath, parent);\n    &#125;\n&#125;\n</code></pre><p>可以发现<code>DexClassLoader</code> 比 <code>PathClassLoader</code> 多一个参数<code>String optimizedDirectory</code>，那这个参数具体做什么的呢？继续查看源码我们可以知道<code>optimizedDirectory</code>是用来缓存我们需要加载的dex文件的，并创建一个<code>DexFile</code>对象，如果它为null，那么会直接使用dex文件原有的路径来创建DexFile 对象，其具体体现在如下代码区域：</p>\n<pre><code>private static DexFile loadDexFile(File file, File optimizedDirectory)\n        throws IOException &#123;\n    if (optimizedDirectory == null) &#123;\n        return new DexFile(file);\n    &#125; else &#123;\n        String optimizedPath = optimizedPathFor(file, optimizedDirectory);\n        return DexFile.loadDex(file.getPath(), optimizedPath, 0);\n    &#125;\n&#125;\n</code></pre><p>因此两者区别在于 <code>PathClassLoader</code> 不能直接从 zip 包中得到 dex，因此只支持直接操作 dex 文件或者已经安装过的 apk。而 <code>DexClassLoader</code> 可以加载外部的 apk、jar 或 dex文件，并且会在指定的 outpath 路径存放其 dex 文件。所以在插件化中我们使用<code>DexClassLoader</code>来加载class的，接下来讲解<code>DexClassLoader</code>的用法。</p>\n<h2 id=\"2、DexClassLoader用法\"><a href=\"#2、DexClassLoader用法\" class=\"headerlink\" title=\"2、DexClassLoader用法\"></a><strong>2、DexClassLoader用法</strong></h2><p>其构造方法为：</p>\n<pre><code>DexClassLoader(\n    String dexPath, \n       String optimizedDirectory, \n    String librarySearchPath,\n     ClassLoader parent)\n</code></pre><p><code>dexPath</code>:被解压的apk路径，不能为空。<br><code>optimizedDirectory</code>：解压后的.dex文件的存储路径，不能为空。这个路径强烈建议使用应用程序的私有路径，不要放到sdcard上，否则代码容易被注入攻击。<br><code>libraryPath</code>：os库的存放路径，可以为空，若有os库，必须填写。<br><code>parent</code>：父亲加载器，一般为context.getClassLoader(),使用当前上下文的类加载器。</p>\n<p>接下来讲解具体使用流程：</p>\n<p>1、新建一个名为plugin的project，其中新建一个<code>Bean</code>类，只有一个方法<code>getName()</code>返回一个字符串“My App”，然后对plugin这个工程打包为apk，将apk放在主工程的asser目录中。</p>\n<img src=\"https://cdn.julis.wang/blog/img/20190827104738557.png\">\n<p>2、构造Classloader</p>\n<pre><code>  File extractFile = getFileStreamPath(&quot;app-debug.apk&quot;);\n  String dexPath = extractFile.getPath();\n  File fileRelease = getDir(&quot;dex&quot;, 0);\n  ClassLoader classLoader = new DexClassLoader(dexPath, fileRelease.getAbsolutePath(), null, getClassLoader());\n</code></pre><p>3、利用构造好的Classloader反射调用插件类中的方法</p>\n<pre><code>  Class mLoadClassBean;\n  try &#123;\n        mLoadClassBean = classLoader.loadClass(&quot;com.example.plugin.Bean&quot;);\n        Object beanObject = mLoadClassBean.newInstance();\n        Method getNameMethod = mLoadClassBean.getMethod(&quot;getName&quot;);\n        getNameMethod.setAccessible(true);\n        String name = (String) getNameMethod.invoke(beanObject);\n        Log.e(&quot;julis&quot;, name);\n    &#125; catch(Exception e) &#123;\n        e.printStackTrace();\n    &#125;\n</code></pre><p>成功打印出结果：</p>\n<img src=\"https://cdn.julis.wang/blog/img/20190827143354781.png\">\n<p>参考：</p>\n<p><a href=\"https://www.jianshu.com/p/4b4f1fa6633c\">https://www.jianshu.com/p/4b4f1fa6633c</a></p>\n<p><a href=\"https://www.jianshu.com/p/53aa2de20cf8\">https://www.jianshu.com/p/53aa2de20cf8</a></p>\n<p><a href=\"https://cloud.tencent.com/developer/article/1071815\">https://cloud.tencent.com/developer/article/1071815</a></p>\n","cover":null,"images":["https://cdn.julis.wang/blog/img/20190827104738557.png","https://cdn.julis.wang/blog/img/20190827143354781.png"],"content":"<p><strong>插件化要解决的三个核心问题：类加载、资源加载、组件生命周期管理。</strong></p>\n<p>在Android插件化中其原理实际是 Java ClassLoader的原理，此博文主要对Android插件化中类加载中的DexClassLoader做总结，便于之后对Android插件化的理解学习。</p>\n<p>Android的Dalvik虚拟机和Java虚拟机的运行原理相同都是将对应的java类加载在内存中运行。而Java虚拟机是加载class文件，也可以将一段二进制流通过defineClass方法生产Class进行加载。Dalvik虚拟机加载的dex文件。dex文件是Android对与Class文件做的优化，以便于提高手机的性能。可以想象dex为class文件的一个压缩文件。dex在Android中的加载和class在jvm中的相同都是基于双亲委派模型，都是调用ClassLoader的loadClass方法加载类。</p>\n<h2 id=\"1、DexClassLoader和PathClassLoader区别\"><a href=\"#1、DexClassLoader和PathClassLoader区别\" class=\"headerlink\" title=\"1、DexClassLoader和PathClassLoader区别\"></a><strong>1、DexClassLoader和PathClassLoader区别</strong></h2><p>Android 也有自己的 ClassLoader，分为 <code>DexClassLoader</code>和<code>PathClassLoader</code>，这两者有什么区别和关联呢？</p>\n<p>阅读源码可以看到两者的构造方法分别为：</p>\n<pre><code>public class PathClassLoader extends BaseDexClassLoader &#123;\n    public PathClassLoader(String dexPath, ClassLoader parent) &#123;\n        super(dexPath, null, null, parent);\n    &#125;\n    public PathClassLoader(String dexPath, String libraryPath,\n            ClassLoader parent) &#123;\n        super(dexPath, null, libraryPath, parent);\n    &#125;\n&#125;\n\npublic class DexClassLoader extends BaseDexClassLoader &#123;\n    public DexClassLoader(String dexPath, String optimizedDirectory,\n            String libraryPath, ClassLoader parent) &#123;\n        super(dexPath, new File(optimizedDirectory), libraryPath, parent);\n    &#125;\n&#125;\n</code></pre><p>可以发现<code>DexClassLoader</code> 比 <code>PathClassLoader</code> 多一个参数<code>String optimizedDirectory</code>，那这个参数具体做什么的呢？继续查看源码我们可以知道<code>optimizedDirectory</code>是用来缓存我们需要加载的dex文件的，并创建一个<code>DexFile</code>对象，如果它为null，那么会直接使用dex文件原有的路径来创建DexFile 对象，其具体体现在如下代码区域：</p>\n<pre><code>private static DexFile loadDexFile(File file, File optimizedDirectory)\n        throws IOException &#123;\n    if (optimizedDirectory == null) &#123;\n        return new DexFile(file);\n    &#125; else &#123;\n        String optimizedPath = optimizedPathFor(file, optimizedDirectory);\n        return DexFile.loadDex(file.getPath(), optimizedPath, 0);\n    &#125;\n&#125;\n</code></pre><p>因此两者区别在于 <code>PathClassLoader</code> 不能直接从 zip 包中得到 dex，因此只支持直接操作 dex 文件或者已经安装过的 apk。而 <code>DexClassLoader</code> 可以加载外部的 apk、jar 或 dex文件，并且会在指定的 outpath 路径存放其 dex 文件。所以在插件化中我们使用<code>DexClassLoader</code>来加载class的，接下来讲解<code>DexClassLoader</code>的用法。</p>\n<h2 id=\"2、DexClassLoader用法\"><a href=\"#2、DexClassLoader用法\" class=\"headerlink\" title=\"2、DexClassLoader用法\"></a><strong>2、DexClassLoader用法</strong></h2><p>其构造方法为：</p>\n<pre><code>DexClassLoader(\n    String dexPath, \n       String optimizedDirectory, \n    String librarySearchPath,\n     ClassLoader parent)\n</code></pre><p><code>dexPath</code>:被解压的apk路径，不能为空。<br><code>optimizedDirectory</code>：解压后的.dex文件的存储路径，不能为空。这个路径强烈建议使用应用程序的私有路径，不要放到sdcard上，否则代码容易被注入攻击。<br><code>libraryPath</code>：os库的存放路径，可以为空，若有os库，必须填写。<br><code>parent</code>：父亲加载器，一般为context.getClassLoader(),使用当前上下文的类加载器。</p>\n<p>接下来讲解具体使用流程：</p>\n<p>1、新建一个名为plugin的project，其中新建一个<code>Bean</code>类，只有一个方法<code>getName()</code>返回一个字符串“My App”，然后对plugin这个工程打包为apk，将apk放在主工程的asser目录中。</p>\n<img src=\"https://cdn.julis.wang/blog/img/20190827104738557.png\">\n<p>2、构造Classloader</p>\n<pre><code>  File extractFile = getFileStreamPath(&quot;app-debug.apk&quot;);\n  String dexPath = extractFile.getPath();\n  File fileRelease = getDir(&quot;dex&quot;, 0);\n  ClassLoader classLoader = new DexClassLoader(dexPath, fileRelease.getAbsolutePath(), null, getClassLoader());\n</code></pre><p>3、利用构造好的Classloader反射调用插件类中的方法</p>\n<pre><code>  Class mLoadClassBean;\n  try &#123;\n        mLoadClassBean = classLoader.loadClass(&quot;com.example.plugin.Bean&quot;);\n        Object beanObject = mLoadClassBean.newInstance();\n        Method getNameMethod = mLoadClassBean.getMethod(&quot;getName&quot;);\n        getNameMethod.setAccessible(true);\n        String name = (String) getNameMethod.invoke(beanObject);\n        Log.e(&quot;julis&quot;, name);\n    &#125; catch(Exception e) &#123;\n        e.printStackTrace();\n    &#125;\n</code></pre><p>成功打印出结果：</p>\n<img src=\"https://cdn.julis.wang/blog/img/20190827143354781.png\">\n<p>参考：</p>\n<p><a href=\"https://www.jianshu.com/p/4b4f1fa6633c\">https://www.jianshu.com/p/4b4f1fa6633c</a></p>\n<p><a href=\"https://www.jianshu.com/p/53aa2de20cf8\">https://www.jianshu.com/p/53aa2de20cf8</a></p>\n<p><a href=\"https://cloud.tencent.com/developer/article/1071815\">https://cloud.tencent.com/developer/article/1071815</a></p>\n","categories":[{"name":"技术文章","slug":"technology","api":"api/categories/technology.json"}],"tags":[{"name":"插件化","slug":"plugins","api":"api/tags/plugins.json"}],"api":"api/posts/2019/08/26/Android-插件化之ClassLoader.json"},{"title":"单例模式的设计","slug":"单例模式的设计","date":"2019-07-09T01:56:00.000Z","updated":"2025-05-20T11:46:57.000Z","comments":true,"url":"2019/07/09/单例模式的设计/","excerpt":"<p>原文回答于知乎(<a href=\"https://www.zhihu.com/question/277243683/answer/392772061\">如何把一段简单的代码变复杂？ - 落叶挽歌的回答</a>)</p>\n<p>我们都知道单例模式很简单，大概是这样：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//单线程单例模式实现</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Singleton</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Singleton instance=<span class=\"literal\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Singleton <span class=\"title function_\">getInstance</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(<span class=\"literal\">null</span>==instance)&#123;</span><br><span class=\"line\">            instance = <span class=\"keyword\">new</span> <span class=\"title class_\">Singleton</span>();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>但是呢，在多线程条件下getInstance()并不是一个原子操作。由于代码没有使用任何同步机制，因此该线程可能会出现线程交错的情形：在instance还是null的时候，如果两个线程同时执行到 if(null==instance)那么会创建两个实例，从而违背了初衷。于是通过简单加锁来解决这种问题：<br><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//简单加锁实现单例模式</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Singleton</span>  &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Singleton instance=<span class=\"literal\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Singleton <span class=\"title function_\">getInstance</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span> (Singleton.class)&#123;<span class=\"comment\">//加入synchronized同步</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(<span class=\"literal\">null</span>==instance)&#123;</span><br><span class=\"line\">                instance = <span class=\"keyword\">new</span> <span class=\"title class_\">Singleton</span>();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>这种方式实现单例模式固然安全，但意味着每次调用 getInstance()都会申请锁，为了避免开销，我们想到了另一种办法：<br><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//基于双重检查锁定的错误单例模式实现</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Singleton</span>  &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Singleton instance=<span class=\"literal\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Singleton <span class=\"title function_\">getInstance</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(<span class=\"literal\">null</span>==instance)&#123;<span class=\"comment\">//先检查是否为null，再执行之上的代码</span></span><br><span class=\"line\">            <span class=\"keyword\">synchronized</span> (Singleton.class)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(<span class=\"literal\">null</span>==instance)&#123;</span><br><span class=\"line\">                    instance = <span class=\"keyword\">new</span> <span class=\"title class_\">Singleton</span>();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>通过这种方法，虽然第一次检查对变量instance的访问没有加锁从而使竞态仍然可能存在，它似乎避免了锁的开销又保障了线程的安全。然后对 instance = new Singleton();进行伪代码独立子操作：<br><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">obj=allocate(Singleton.class);<span class=\"comment\">//1、分配对象所需的存储空间</span></span><br><span class=\"line\">invokeConstructor(obj);<span class=\"comment\">//2、初始化obj的引用对象</span></span><br><span class=\"line\">instance=obj;<span class=\"comment\">//3、将对象引用写入共享变量</span></span><br></pre></td></tr></table></figure><br>由于重排序的规则，临界区内的操作可以再临界区内重排序，因此JIT编译器可能将上述子操作重排序为：1-&gt;3-&gt;2，即在初始化对象之前将对象引用写入实例变量instace。由于锁对有序性的保障是有条件的，而操作1读取intance变量的时候并没有加锁，因此重排序是对1操作是有影响的：该线程可能看到一个未初始化（或者为初始化完毕）的实例，即intance不为null。于是该线程直接就直接返回这个instance变量所引用的实例，而实例可能是未初始化完毕的，这就是可能导致程序出错。明白问题的原因之后，解决方法也不难想到了：<strong>只需将instance变量加入volatile修饰则可</strong>。于是代码变成：<br><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//基于双重检查锁定的正确单例模式实现</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Singleton</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">volatile</span> Singleton instance=<span class=\"literal\">null</span>;<span class=\"comment\">//加入volatile修饰</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Singleton <span class=\"title function_\">getInstance</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(<span class=\"literal\">null</span>==instance)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">synchronized</span> (Singleton.class)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(<span class=\"literal\">null</span>==instance)&#123;</span><br><span class=\"line\">                    instance = <span class=\"keyword\">new</span> <span class=\"title class_\">Singleton</span>();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>到此为止，才正确实现安全的“单例模式”。</p>\n<p>参考：《黄文海-Java多线程编程实战指南（核心篇）》</p>\n","cover":null,"images":[],"content":"<p>原文回答于知乎(<a href=\"https://www.zhihu.com/question/277243683/answer/392772061\">如何把一段简单的代码变复杂？ - 落叶挽歌的回答</a>)</p>\n<p>我们都知道单例模式很简单，大概是这样：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//单线程单例模式实现</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Singleton</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Singleton instance=<span class=\"literal\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Singleton <span class=\"title function_\">getInstance</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(<span class=\"literal\">null</span>==instance)&#123;</span><br><span class=\"line\">            instance = <span class=\"keyword\">new</span> <span class=\"title class_\">Singleton</span>();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>但是呢，在多线程条件下getInstance()并不是一个原子操作。由于代码没有使用任何同步机制，因此该线程可能会出现线程交错的情形：在instance还是null的时候，如果两个线程同时执行到 if(null==instance)那么会创建两个实例，从而违背了初衷。于是通过简单加锁来解决这种问题：<br><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//简单加锁实现单例模式</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Singleton</span>  &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Singleton instance=<span class=\"literal\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Singleton <span class=\"title function_\">getInstance</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span> (Singleton.class)&#123;<span class=\"comment\">//加入synchronized同步</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(<span class=\"literal\">null</span>==instance)&#123;</span><br><span class=\"line\">                instance = <span class=\"keyword\">new</span> <span class=\"title class_\">Singleton</span>();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>这种方式实现单例模式固然安全，但意味着每次调用 getInstance()都会申请锁，为了避免开销，我们想到了另一种办法：<br><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//基于双重检查锁定的错误单例模式实现</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Singleton</span>  &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Singleton instance=<span class=\"literal\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Singleton <span class=\"title function_\">getInstance</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(<span class=\"literal\">null</span>==instance)&#123;<span class=\"comment\">//先检查是否为null，再执行之上的代码</span></span><br><span class=\"line\">            <span class=\"keyword\">synchronized</span> (Singleton.class)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(<span class=\"literal\">null</span>==instance)&#123;</span><br><span class=\"line\">                    instance = <span class=\"keyword\">new</span> <span class=\"title class_\">Singleton</span>();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>通过这种方法，虽然第一次检查对变量instance的访问没有加锁从而使竞态仍然可能存在，它似乎避免了锁的开销又保障了线程的安全。然后对 instance = new Singleton();进行伪代码独立子操作：<br><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">obj=allocate(Singleton.class);<span class=\"comment\">//1、分配对象所需的存储空间</span></span><br><span class=\"line\">invokeConstructor(obj);<span class=\"comment\">//2、初始化obj的引用对象</span></span><br><span class=\"line\">instance=obj;<span class=\"comment\">//3、将对象引用写入共享变量</span></span><br></pre></td></tr></table></figure><br>由于重排序的规则，临界区内的操作可以再临界区内重排序，因此JIT编译器可能将上述子操作重排序为：1-&gt;3-&gt;2，即在初始化对象之前将对象引用写入实例变量instace。由于锁对有序性的保障是有条件的，而操作1读取intance变量的时候并没有加锁，因此重排序是对1操作是有影响的：该线程可能看到一个未初始化（或者为初始化完毕）的实例，即intance不为null。于是该线程直接就直接返回这个instance变量所引用的实例，而实例可能是未初始化完毕的，这就是可能导致程序出错。明白问题的原因之后，解决方法也不难想到了：<strong>只需将instance变量加入volatile修饰则可</strong>。于是代码变成：<br><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//基于双重检查锁定的正确单例模式实现</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Singleton</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">volatile</span> Singleton instance=<span class=\"literal\">null</span>;<span class=\"comment\">//加入volatile修饰</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Singleton <span class=\"title function_\">getInstance</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(<span class=\"literal\">null</span>==instance)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">synchronized</span> (Singleton.class)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(<span class=\"literal\">null</span>==instance)&#123;</span><br><span class=\"line\">                    instance = <span class=\"keyword\">new</span> <span class=\"title class_\">Singleton</span>();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>到此为止，才正确实现安全的“单例模式”。</p>\n<p>参考：《黄文海-Java多线程编程实战指南（核心篇）》</p>\n","categories":[{"name":"技术文章","slug":"technology","api":"api/categories/technology.json"}],"tags":[{"name":"设计模式","slug":"design","api":"api/tags/design.json"}],"api":"api/posts/2019/07/09/单例模式的设计.json"},{"title":"Android监听截屏事件之媒体读取的探索","slug":"Android监听截屏事件之媒体读取的探索","date":"2019-07-02T09:58:00.000Z","updated":"2025-05-20T11:46:57.000Z","comments":true,"url":"2019/07/02/Android监听截屏事件之媒体读取的探索/","excerpt":"<p>最近做了一个需求：监听用户截屏，然后生成相关海报。<br>参考了<a href=\"https://blog.csdn.net/xietansheng/article/details/52692163\" title=\"Android 截屏事件监听\">Android 截屏事件监听</a>的文章，大致思路是：</p>\n<p>1、利用ContentObserver用来监听指定Uri的所有资源变化,当媒体库中有相关图片新增的时候，则发送相关的通知。</p>\n<p>2、得到回调的Uri后，借助ContentResolver在媒体数据库中查询最后一条数据</p>\n<p>3、对数据做一些过滤。比如短时间重复截屏的情况以及其他App也插入了媒体文件等情况做处理。</p>\n<p>不过有一些适配性的问题：</p>\n<p>1、截屏后读取文件数据库后获取到件的绝对路径后，利用“screenshot”等关键字判断是否是截屏图片，并不能适配所有手机截屏的命名规则，以及其他应用同时间产生带有“screenshot”等关键词的文件也会有问题。</p>\n<p>2、在某些型号手机中(现遇到Vivo)从数据库中读取的文件并不是获取到的最新的截屏文件，而且其他目录的文件，这里就有些难以理解了，所以今天取探究一下媒体数据库的读取。</p>\n<p>其中ContentObserver如下代码所示：<br><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">   * 媒体内容观察者(观察媒体数据库的改变)</span></span><br><span class=\"line\"><span class=\"comment\">   */</span></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">class</span> <span class=\"title class_\">MediaContentObserver</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">ContentObserver</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">private</span> Uri mContentUri;</span><br><span class=\"line\">      <span class=\"keyword\">public</span> <span class=\"title function_\">MediaContentObserver</span><span class=\"params\">(Uri contentUri, Handler handler)</span> &#123;</span><br><span class=\"line\">          <span class=\"built_in\">super</span>(handler);</span><br><span class=\"line\">          mContentUri = contentUri;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      [<span class=\"meta\">@Override</span>](https:<span class=\"comment\">//my.oschina.net/u/1162528)</span></span><br><span class=\"line\">      <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">onChange</span><span class=\"params\">(<span class=\"type\">boolean</span> selfChange)</span> &#123;</span><br><span class=\"line\">          <span class=\"built_in\">super</span>.onChange(selfChange);</span><br><span class=\"line\">          handleMediaContentChange(mContentUri);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure></p>\n<p>其中获取最后一次更新的媒体文件时的代码(为便于查看 删除了判空处理代码)：<br> <figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">\t<span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">    * 处理媒体数据库的内容改变</span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">   <span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">handleMediaContentChange</span><span class=\"params\">(Uri contentUri)</span> &#123;</span><br><span class=\"line\">       <span class=\"type\">Cursor</span> <span class=\"variable\">cursor</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">       <span class=\"comment\">/** 读取媒体数据库时需要读取的列 */</span></span><br><span class=\"line\">       <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String[] MEDIA_PROJECTIONS =  &#123;</span><br><span class=\"line\">           MediaStore.Images.ImageColumns.DATA,</span><br><span class=\"line\">           MediaStore.Images.ImageColumns.DATE_TAKEN &#125;;</span><br><span class=\"line\">       <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">           <span class=\"comment\">// 数据改变时查询数据库中最后加入的一条数据</span></span><br><span class=\"line\">           cursor = mContext.getContentResolver().query(</span><br><span class=\"line\">                   contentUri,</span><br><span class=\"line\">                    MEDIA_PROJECTIONS,</span><br><span class=\"line\">                   <span class=\"literal\">null</span>,</span><br><span class=\"line\">                   <span class=\"literal\">null</span>,</span><br><span class=\"line\">                   MediaStore.Images.ImageColumns.DATE_ADDED + <span class=\"string\">&quot; desc limit 1&quot;</span></span><br><span class=\"line\">           );</span><br><span class=\"line\">           <span class=\"comment\">// 获取各列的索引</span></span><br><span class=\"line\">           <span class=\"type\">int</span> <span class=\"variable\">dataIndex</span> <span class=\"operator\">=</span> cursor.getColumnIndex(MediaStore.Images.ImageColumns.DATA);</span><br><span class=\"line\">           <span class=\"type\">int</span> <span class=\"variable\">dateTakenIndex</span> <span class=\"operator\">=</span> cursor.getColumnIndex(MediaStore.Images.ImageColumns.DATE_TAKEN);</span><br><span class=\"line\"></span><br><span class=\"line\">           <span class=\"comment\">// 获取行数据</span></span><br><span class=\"line\">           <span class=\"type\">String</span> <span class=\"variable\">data</span> <span class=\"operator\">=</span> cursor.getString(dataIndex);</span><br><span class=\"line\">           <span class=\"type\">long</span> <span class=\"variable\">dateTaken</span> <span class=\"operator\">=</span> cursor.getLong(dateTakenIndex);</span><br><span class=\"line\"></span><br><span class=\"line\">           <span class=\"comment\">// 处理获取到的第一行数据</span></span><br><span class=\"line\">           handleMediaRowData(data, dateTaken);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>这次的目的主要探究的是从数据库获取相关信息的过程</p>\n<p><strong>1、Android 的多媒体如何存储？</strong></p>\n<p>Android的多媒体文件主要存储在 /data/data/com.android.providers.media/databases 目录下，该目录下有连个db文件：</p>\n<p>内部存储数据库文件：internal.db</p>\n<p>存储卡数据库：external-XXXX.db</p>\n<p>媒体文件的操作主要是围绕着这两个数据库来进行，这两个数据库的结构是一样的。</p>\n<p>这两个数据库包含这些表：<br>album_art 、audio 、search 、album_info 、audio_genres、 searchhelpertitle、albums、 audio_genres_map、 thumbnails、<br>android_metadata、 audio_meta、 video、artist_info 、audio_playlists 、videothumbnails、artists 、audio_playlists_map、<br>artists_albums_map 、images</p>\n<p><strong>2、表的结构</strong><br>对于Images表：主要存储images信息。表结构如下：<br><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">CREATE TABLE <span class=\"title function_\">images</span> <span class=\"params\">(</span></span><br><span class=\"line\"><span class=\"params\">   _id INTEGER PRIMARY KEY, </span></span><br><span class=\"line\"><span class=\"params\">   _data TEXT,</span></span><br><span class=\"line\"><span class=\"params\">   _size INTEGER,</span></span><br><span class=\"line\"><span class=\"params\">   _display_name TEXT,</span></span><br><span class=\"line\"><span class=\"params\">   mime_type TEXT,</span></span><br><span class=\"line\"><span class=\"params\">   title TEXT, </span></span><br><span class=\"line\"><span class=\"params\">   date_added INTEGER, </span></span><br><span class=\"line\"><span class=\"params\">   date_modified INTEGER,</span></span><br><span class=\"line\"><span class=\"params\">   description TEXT,</span></span><br><span class=\"line\"><span class=\"params\">   picasa_id TEXT,</span></span><br><span class=\"line\"><span class=\"params\">   isprivate INTEGER,</span></span><br><span class=\"line\"><span class=\"params\">   latitude DOUBLE, </span></span><br><span class=\"line\"><span class=\"params\">   longitude DOUBLE, </span></span><br><span class=\"line\"><span class=\"params\">   datetaken INTEGER, </span></span><br><span class=\"line\"><span class=\"params\">   orientation INTEGER, </span></span><br><span class=\"line\"><span class=\"params\">   mini_thumb_magic INTEGER, </span></span><br><span class=\"line\"><span class=\"params\">   bucket_id TEXT, </span></span><br><span class=\"line\"><span class=\"params\">   bucket_display_name TEXT )</span>;</span><br></pre></td></tr></table></figure></p>\n<p>各字段所表示意思，如图所示：</p>\n<img src=\"https://cdn.julis.wang/blog/img/2eb1be5d3ece2831fa9ca6d00678bf520a7.jpg\">\n<p><em>图片来自：<a href=\"https://blog.csdn.net/love_xsq/article/details/50387747\" title=\"Android MediaProvider数据库模式说明\">Android MediaProvider数据库模式说明</a></em></p>\n<p>所以在截屏监听数据的时候所读取的数据库返回值，分别为：</p>\n<p>_data  :图片据对路径</p>\n<p>datetaken：取子EXIF照片拍摄事件，空的话为文件修改时间</p>\n<pre><code>  private static final String[] MEDIA_PROJECTIONS =  &#123;\n        MediaStore.Images.ImageColumns.DATA,\n        MediaStore.Images.ImageColumns.DATE_TAKEN &#125;;\n</code></pre><p>在查询过程中构造的数据库代码为：</p>\n<pre><code>public final Cursor query (Uri uri, \n    String[] projection,\n    String selection, \n    String[] selectionArgs, \n    String sortOrder)\n</code></pre><p>`<br>其中对应的构造参数官方解释为：</p>\n<blockquote>\n<p>uri    The URI, using the content:// scheme, for the content to retrieve.</p>\n<p>projection    A list of which columns to return. Passing null will return all columns, which is inefficient.  </p>\n<p>selection    A filter declaring which rows to return, formatted as an SQL WHERE clause (excluding the WHERE itself). Passing null will return all rows for the given URI.</p>\n<p>selectionArgs    You may include ?s in selection, which will be replaced by the values from selectionArgs, in the order that they appear in the selection. The values will be bound as Strings.</p>\n<p>sortOrder    How to order the rows, formatted as an SQL ORDER BY clause (excluding the ORDER BY itself). Passing null will use the default sort order, which may be unordered.</p>\n</blockquote>\n<hr>\n<p>所以参数依次为：<br>所要查找的目标、所要的返回值、条件限制(类似sql中where)、匹配项、排序规则</p>\n<p>所以这里的查询就显而易见了：获取最新图片数据库下data和datatoken列的数据<br><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">cursor = mContext.getContentResolver().query(</span><br><span class=\"line\">                 contentUri,</span><br><span class=\"line\">                 MEDIA_PROJECTIONS,</span><br><span class=\"line\">                 <span class=\"literal\">null</span>,</span><br><span class=\"line\">                 <span class=\"literal\">null</span>,</span><br><span class=\"line\">                 MediaStore.Images.ImageColumns.DATE_ADDED + <span class=\"string\">&quot; desc limit 1&quot;</span></span><br><span class=\"line\">         );</span><br></pre></td></tr></table></figure><br>然而…并不能解释vivo手机为什么查找出来不是最新截图的图片的问题</p>\n","cover":null,"images":["https://cdn.julis.wang/blog/img/2eb1be5d3ece2831fa9ca6d00678bf520a7.jpg"],"content":"<p>最近做了一个需求：监听用户截屏，然后生成相关海报。<br>参考了<a href=\"https://blog.csdn.net/xietansheng/article/details/52692163\" title=\"Android 截屏事件监听\">Android 截屏事件监听</a>的文章，大致思路是：</p>\n<p>1、利用ContentObserver用来监听指定Uri的所有资源变化,当媒体库中有相关图片新增的时候，则发送相关的通知。</p>\n<p>2、得到回调的Uri后，借助ContentResolver在媒体数据库中查询最后一条数据</p>\n<p>3、对数据做一些过滤。比如短时间重复截屏的情况以及其他App也插入了媒体文件等情况做处理。</p>\n<p>不过有一些适配性的问题：</p>\n<p>1、截屏后读取文件数据库后获取到件的绝对路径后，利用“screenshot”等关键字判断是否是截屏图片，并不能适配所有手机截屏的命名规则，以及其他应用同时间产生带有“screenshot”等关键词的文件也会有问题。</p>\n<p>2、在某些型号手机中(现遇到Vivo)从数据库中读取的文件并不是获取到的最新的截屏文件，而且其他目录的文件，这里就有些难以理解了，所以今天取探究一下媒体数据库的读取。</p>\n<p>其中ContentObserver如下代码所示：<br><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">   * 媒体内容观察者(观察媒体数据库的改变)</span></span><br><span class=\"line\"><span class=\"comment\">   */</span></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">class</span> <span class=\"title class_\">MediaContentObserver</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">ContentObserver</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">private</span> Uri mContentUri;</span><br><span class=\"line\">      <span class=\"keyword\">public</span> <span class=\"title function_\">MediaContentObserver</span><span class=\"params\">(Uri contentUri, Handler handler)</span> &#123;</span><br><span class=\"line\">          <span class=\"built_in\">super</span>(handler);</span><br><span class=\"line\">          mContentUri = contentUri;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      [<span class=\"meta\">@Override</span>](https:<span class=\"comment\">//my.oschina.net/u/1162528)</span></span><br><span class=\"line\">      <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">onChange</span><span class=\"params\">(<span class=\"type\">boolean</span> selfChange)</span> &#123;</span><br><span class=\"line\">          <span class=\"built_in\">super</span>.onChange(selfChange);</span><br><span class=\"line\">          handleMediaContentChange(mContentUri);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure></p>\n<p>其中获取最后一次更新的媒体文件时的代码(为便于查看 删除了判空处理代码)：<br> <figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">\t<span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">    * 处理媒体数据库的内容改变</span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">   <span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">handleMediaContentChange</span><span class=\"params\">(Uri contentUri)</span> &#123;</span><br><span class=\"line\">       <span class=\"type\">Cursor</span> <span class=\"variable\">cursor</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">       <span class=\"comment\">/** 读取媒体数据库时需要读取的列 */</span></span><br><span class=\"line\">       <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String[] MEDIA_PROJECTIONS =  &#123;</span><br><span class=\"line\">           MediaStore.Images.ImageColumns.DATA,</span><br><span class=\"line\">           MediaStore.Images.ImageColumns.DATE_TAKEN &#125;;</span><br><span class=\"line\">       <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">           <span class=\"comment\">// 数据改变时查询数据库中最后加入的一条数据</span></span><br><span class=\"line\">           cursor = mContext.getContentResolver().query(</span><br><span class=\"line\">                   contentUri,</span><br><span class=\"line\">                    MEDIA_PROJECTIONS,</span><br><span class=\"line\">                   <span class=\"literal\">null</span>,</span><br><span class=\"line\">                   <span class=\"literal\">null</span>,</span><br><span class=\"line\">                   MediaStore.Images.ImageColumns.DATE_ADDED + <span class=\"string\">&quot; desc limit 1&quot;</span></span><br><span class=\"line\">           );</span><br><span class=\"line\">           <span class=\"comment\">// 获取各列的索引</span></span><br><span class=\"line\">           <span class=\"type\">int</span> <span class=\"variable\">dataIndex</span> <span class=\"operator\">=</span> cursor.getColumnIndex(MediaStore.Images.ImageColumns.DATA);</span><br><span class=\"line\">           <span class=\"type\">int</span> <span class=\"variable\">dateTakenIndex</span> <span class=\"operator\">=</span> cursor.getColumnIndex(MediaStore.Images.ImageColumns.DATE_TAKEN);</span><br><span class=\"line\"></span><br><span class=\"line\">           <span class=\"comment\">// 获取行数据</span></span><br><span class=\"line\">           <span class=\"type\">String</span> <span class=\"variable\">data</span> <span class=\"operator\">=</span> cursor.getString(dataIndex);</span><br><span class=\"line\">           <span class=\"type\">long</span> <span class=\"variable\">dateTaken</span> <span class=\"operator\">=</span> cursor.getLong(dateTakenIndex);</span><br><span class=\"line\"></span><br><span class=\"line\">           <span class=\"comment\">// 处理获取到的第一行数据</span></span><br><span class=\"line\">           handleMediaRowData(data, dateTaken);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>这次的目的主要探究的是从数据库获取相关信息的过程</p>\n<p><strong>1、Android 的多媒体如何存储？</strong></p>\n<p>Android的多媒体文件主要存储在 /data/data/com.android.providers.media/databases 目录下，该目录下有连个db文件：</p>\n<p>内部存储数据库文件：internal.db</p>\n<p>存储卡数据库：external-XXXX.db</p>\n<p>媒体文件的操作主要是围绕着这两个数据库来进行，这两个数据库的结构是一样的。</p>\n<p>这两个数据库包含这些表：<br>album_art 、audio 、search 、album_info 、audio_genres、 searchhelpertitle、albums、 audio_genres_map、 thumbnails、<br>android_metadata、 audio_meta、 video、artist_info 、audio_playlists 、videothumbnails、artists 、audio_playlists_map、<br>artists_albums_map 、images</p>\n<p><strong>2、表的结构</strong><br>对于Images表：主要存储images信息。表结构如下：<br><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">CREATE TABLE <span class=\"title function_\">images</span> <span class=\"params\">(</span></span><br><span class=\"line\"><span class=\"params\">   _id INTEGER PRIMARY KEY, </span></span><br><span class=\"line\"><span class=\"params\">   _data TEXT,</span></span><br><span class=\"line\"><span class=\"params\">   _size INTEGER,</span></span><br><span class=\"line\"><span class=\"params\">   _display_name TEXT,</span></span><br><span class=\"line\"><span class=\"params\">   mime_type TEXT,</span></span><br><span class=\"line\"><span class=\"params\">   title TEXT, </span></span><br><span class=\"line\"><span class=\"params\">   date_added INTEGER, </span></span><br><span class=\"line\"><span class=\"params\">   date_modified INTEGER,</span></span><br><span class=\"line\"><span class=\"params\">   description TEXT,</span></span><br><span class=\"line\"><span class=\"params\">   picasa_id TEXT,</span></span><br><span class=\"line\"><span class=\"params\">   isprivate INTEGER,</span></span><br><span class=\"line\"><span class=\"params\">   latitude DOUBLE, </span></span><br><span class=\"line\"><span class=\"params\">   longitude DOUBLE, </span></span><br><span class=\"line\"><span class=\"params\">   datetaken INTEGER, </span></span><br><span class=\"line\"><span class=\"params\">   orientation INTEGER, </span></span><br><span class=\"line\"><span class=\"params\">   mini_thumb_magic INTEGER, </span></span><br><span class=\"line\"><span class=\"params\">   bucket_id TEXT, </span></span><br><span class=\"line\"><span class=\"params\">   bucket_display_name TEXT )</span>;</span><br></pre></td></tr></table></figure></p>\n<p>各字段所表示意思，如图所示：</p>\n<img src=\"https://cdn.julis.wang/blog/img/2eb1be5d3ece2831fa9ca6d00678bf520a7.jpg\">\n<p><em>图片来自：<a href=\"https://blog.csdn.net/love_xsq/article/details/50387747\" title=\"Android MediaProvider数据库模式说明\">Android MediaProvider数据库模式说明</a></em></p>\n<p>所以在截屏监听数据的时候所读取的数据库返回值，分别为：</p>\n<p>_data  :图片据对路径</p>\n<p>datetaken：取子EXIF照片拍摄事件，空的话为文件修改时间</p>\n<pre><code>  private static final String[] MEDIA_PROJECTIONS =  &#123;\n        MediaStore.Images.ImageColumns.DATA,\n        MediaStore.Images.ImageColumns.DATE_TAKEN &#125;;\n</code></pre><p>在查询过程中构造的数据库代码为：</p>\n<pre><code>public final Cursor query (Uri uri, \n    String[] projection,\n    String selection, \n    String[] selectionArgs, \n    String sortOrder)\n</code></pre><p>`<br>其中对应的构造参数官方解释为：</p>\n<blockquote>\n<p>uri    The URI, using the content:// scheme, for the content to retrieve.</p>\n<p>projection    A list of which columns to return. Passing null will return all columns, which is inefficient.  </p>\n<p>selection    A filter declaring which rows to return, formatted as an SQL WHERE clause (excluding the WHERE itself). Passing null will return all rows for the given URI.</p>\n<p>selectionArgs    You may include ?s in selection, which will be replaced by the values from selectionArgs, in the order that they appear in the selection. The values will be bound as Strings.</p>\n<p>sortOrder    How to order the rows, formatted as an SQL ORDER BY clause (excluding the ORDER BY itself). Passing null will use the default sort order, which may be unordered.</p>\n</blockquote>\n<hr>\n<p>所以参数依次为：<br>所要查找的目标、所要的返回值、条件限制(类似sql中where)、匹配项、排序规则</p>\n<p>所以这里的查询就显而易见了：获取最新图片数据库下data和datatoken列的数据<br><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">cursor = mContext.getContentResolver().query(</span><br><span class=\"line\">                 contentUri,</span><br><span class=\"line\">                 MEDIA_PROJECTIONS,</span><br><span class=\"line\">                 <span class=\"literal\">null</span>,</span><br><span class=\"line\">                 <span class=\"literal\">null</span>,</span><br><span class=\"line\">                 MediaStore.Images.ImageColumns.DATE_ADDED + <span class=\"string\">&quot; desc limit 1&quot;</span></span><br><span class=\"line\">         );</span><br></pre></td></tr></table></figure><br>然而…并不能解释vivo手机为什么查找出来不是最新截图的图片的问题</p>\n","categories":[{"name":"技术文章","slug":"technology","api":"api/categories/technology.json"}],"tags":[{"name":"安卓","slug":"Android","api":"api/tags/Android.json"}],"api":"api/posts/2019/07/02/Android监听截屏事件之媒体读取的探索.json"},{"title":"Android在子线程中创建Handler为什么会抛出异常？","slug":"Android在子线程中创建Handler为什么会抛出异常？","date":"2019-06-24T09:27:00.000Z","updated":"2025-05-20T11:46:57.000Z","comments":true,"url":"2019/06/24/Android在子线程中创建Handler为什么会抛出异常？/","excerpt":"<p>复习一下消息机制，如下代码：<br><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>() &#123;</span><br><span class=\"line\">           <span class=\"type\">Handler</span> <span class=\"variable\">handler</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">           [<span class=\"meta\">@Override</span>](https:<span class=\"comment\">//my.oschina.net/u/1162528)</span></span><br><span class=\"line\">           <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">               handler = <span class=\"keyword\">new</span> <span class=\"title class_\">Handler</span>();</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">       &#125;.start();</span><br></pre></td></tr></table></figure><br>如果执行会抛出异常：</p>\n<blockquote>\n<p>Can’t create handler inside thread Thread.currentThread() that has not called Looper.prepare()</p>\n</blockquote>\n<p>这是为什么呢？</p>\n<p>我们进入Handler的构造方法<br><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"> <span class=\"keyword\">public</span> <span class=\"title function_\">Handler</span><span class=\"params\">(Callback callback, <span class=\"type\">boolean</span> async)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (FIND_POTENTIAL_LEAKS) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> Class&lt;? <span class=\"keyword\">extends</span> <span class=\"title class_\">Handler</span>&gt; klass = getClass();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((klass.isAnonymousClass() || klass.isMemberClass() || klass.isLocalClass()) &amp;&amp;</span><br><span class=\"line\">                (klass.getModifiers() &amp; Modifier.STATIC) == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            Log.w(TAG, <span class=\"string\">&quot;The following Handler class should be static or leaks might occur: &quot;</span> +</span><br><span class=\"line\">                klass.getCanonicalName());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    mLooper = Looper.myLooper();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mLooper == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">RuntimeException</span>(</span><br><span class=\"line\">            <span class=\"string\">&quot;Can&#x27;t create handler inside thread &quot;</span> + Thread.currentThread()</span><br><span class=\"line\">                    + <span class=\"string\">&quot; that has not called Looper.prepare()&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    mQueue = mLooper.mQueue;</span><br><span class=\"line\">    mCallback = callback;</span><br><span class=\"line\">    mAsynchronous = async;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>从上面的代码我们很清新的可以知道mLooper  为null,那么就会抛出这样的异常，那么mLooper 为什么会为空呢？这是因为在线程中的Looper还未被创建，所以在Looper.myLooper()中sThreadLocal.get()就会返回null。</p>\n<p>我们知道 Handler的作用是处理消息，将消息传递给MessageQueue，而MessageQueue存在于Looper中，如果没有Looper那么就没有MessageQueue，所以创建Handler时，Looper不能够为空。</p>\n<p>所以以上代码可以进行一个修改：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">test</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>() &#123;</span><br><span class=\"line\">        <span class=\"type\">Handler</span> <span class=\"variable\">handler</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">        [<span class=\"meta\">@Override</span>](https:<span class=\"comment\">//my.oschina.net/u/1162528)</span></span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">            Looper.prepare();</span><br><span class=\"line\">            handler = <span class=\"keyword\">new</span> <span class=\"title class_\">Handler</span>();</span><br><span class=\"line\">            Looper.loop();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;.start();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>其中     Looper.prepare();为当前线程创建Looper并绑定在ThreadLocal中<br>    Looper.loop();执行消息循环，这样子 Handler就能够正常工作了。</p>\n","cover":null,"images":[],"content":"<p>复习一下消息机制，如下代码：<br><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>() &#123;</span><br><span class=\"line\">           <span class=\"type\">Handler</span> <span class=\"variable\">handler</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">           [<span class=\"meta\">@Override</span>](https:<span class=\"comment\">//my.oschina.net/u/1162528)</span></span><br><span class=\"line\">           <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">               handler = <span class=\"keyword\">new</span> <span class=\"title class_\">Handler</span>();</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">       &#125;.start();</span><br></pre></td></tr></table></figure><br>如果执行会抛出异常：</p>\n<blockquote>\n<p>Can’t create handler inside thread Thread.currentThread() that has not called Looper.prepare()</p>\n</blockquote>\n<p>这是为什么呢？</p>\n<p>我们进入Handler的构造方法<br><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"> <span class=\"keyword\">public</span> <span class=\"title function_\">Handler</span><span class=\"params\">(Callback callback, <span class=\"type\">boolean</span> async)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (FIND_POTENTIAL_LEAKS) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> Class&lt;? <span class=\"keyword\">extends</span> <span class=\"title class_\">Handler</span>&gt; klass = getClass();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((klass.isAnonymousClass() || klass.isMemberClass() || klass.isLocalClass()) &amp;&amp;</span><br><span class=\"line\">                (klass.getModifiers() &amp; Modifier.STATIC) == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            Log.w(TAG, <span class=\"string\">&quot;The following Handler class should be static or leaks might occur: &quot;</span> +</span><br><span class=\"line\">                klass.getCanonicalName());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    mLooper = Looper.myLooper();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mLooper == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">RuntimeException</span>(</span><br><span class=\"line\">            <span class=\"string\">&quot;Can&#x27;t create handler inside thread &quot;</span> + Thread.currentThread()</span><br><span class=\"line\">                    + <span class=\"string\">&quot; that has not called Looper.prepare()&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    mQueue = mLooper.mQueue;</span><br><span class=\"line\">    mCallback = callback;</span><br><span class=\"line\">    mAsynchronous = async;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>从上面的代码我们很清新的可以知道mLooper  为null,那么就会抛出这样的异常，那么mLooper 为什么会为空呢？这是因为在线程中的Looper还未被创建，所以在Looper.myLooper()中sThreadLocal.get()就会返回null。</p>\n<p>我们知道 Handler的作用是处理消息，将消息传递给MessageQueue，而MessageQueue存在于Looper中，如果没有Looper那么就没有MessageQueue，所以创建Handler时，Looper不能够为空。</p>\n<p>所以以上代码可以进行一个修改：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">test</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>() &#123;</span><br><span class=\"line\">        <span class=\"type\">Handler</span> <span class=\"variable\">handler</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">        [<span class=\"meta\">@Override</span>](https:<span class=\"comment\">//my.oschina.net/u/1162528)</span></span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">            Looper.prepare();</span><br><span class=\"line\">            handler = <span class=\"keyword\">new</span> <span class=\"title class_\">Handler</span>();</span><br><span class=\"line\">            Looper.loop();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;.start();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>其中     Looper.prepare();为当前线程创建Looper并绑定在ThreadLocal中<br>    Looper.loop();执行消息循环，这样子 Handler就能够正常工作了。</p>\n","categories":[{"name":"技术文章","slug":"technology","api":"api/categories/technology.json"}],"tags":[{"name":"安卓","slug":"Android","api":"api/tags/Android.json"}],"api":"api/posts/2019/06/24/Android在子线程中创建Handler为什么会抛出异常？.json"},{"title":"基于Volley框架的返回数据的范型处理","slug":"基于Volley框架的返回数据的范型处理","date":"2019-05-13T06:56:00.000Z","updated":"2025-05-20T11:46:57.000Z","comments":true,"url":"2019/05/13/基于Volley框架的返回数据的范型处理/","excerpt":"<p>在平时最普通的Volley的网络请求中，我们StringRequest是这样请求网络数据的：<br><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">StringRequest</span> <span class=\"variable\">stringRequest</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">StringRequest</span>(<span class=\"string\">&quot;http://www.baidu.com&quot;</span>,</span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">Response</span>.Listener&lt;String&gt;() &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">onResponse</span><span class=\"params\">(String response)</span> &#123;</span><br><span class=\"line\">                Log.d(<span class=\"string\">&quot;TAG&quot;</span>, response);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;, <span class=\"keyword\">new</span> <span class=\"title class_\">Response</span>.ErrorListener() &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">onErrorResponse</span><span class=\"params\">(VolleyError error)</span> &#123;</span><br><span class=\"line\">        Log.e(<span class=\"string\">&quot;TAG&quot;</span>, error.getMessage(), error);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure><br>注意在onResponse的时候是拿到的string类型，拿到string后对其再进行相关的解析，我们是否是可以对其直接封装然后拿到具体想要类型的model数据结构呢？所以对其网络请求架构进行一次封装，到达如下效果：<br><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">GetGoodDetailByGidRequest</span> <span class=\"variable\">getGoodDetailByGidRequest</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">GetGoodDetailByGidRequest</span>(mCouponId,</span><br><span class=\"line\">              <span class=\"keyword\">new</span> <span class=\"title class_\">RequestListener</span>&lt;List&lt;CouponModel&gt;&gt;() &#123;</span><br><span class=\"line\">                  <span class=\"meta\">@Override</span></span><br><span class=\"line\">                  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">onSuccess</span><span class=\"params\">(List&lt;CouponModel&gt; result)</span> &#123;</span><br><span class=\"line\">                  &#125;</span><br><span class=\"line\">                  <span class=\"meta\">@Override</span></span><br><span class=\"line\">                  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">onError</span><span class=\"params\">(Exception e)</span> &#123;</span><br><span class=\"line\">                      e.printStackTrace();</span><br><span class=\"line\">                      stopLoadingDialog();</span><br><span class=\"line\">                  &#125;</span><br><span class=\"line\">              &#125;);</span><br></pre></td></tr></table></figure><br>这里我们在构造Request的时候指定了返回数据的类型，这样的话就方便了我们在写业务的时候直接使用解析好的数据结构，具体如何做到的呢？</p>\n<p><strong>一、让每个Request基于一个带有范型请求类</strong><br><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">class</span> <span class=\"title class_\">BaseApiRequest</span>&lt;T&gt;  </span><br></pre></td></tr></table></figure><br>这里的T就是目标请求期望的model类<br>在具体实现的时候继承基类，并指定返回类型，下面是一个例子：<br><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">GetGoodDetailByGidRequest</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">BaseApiRequest</span>&lt;List&lt;CouponModel&gt;&gt; &#123;</span><br><span class=\"line\">   \t<span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">String</span> <span class=\"variable\">url</span> <span class=\"operator\">=</span> CURL.GoodDetailURL;</span><br><span class=\"line\">   \t<span class=\"keyword\">public</span> <span class=\"title function_\">GetGoodDetailByGidRequest</span><span class=\"params\">(String goodId, RequestListener&lt;List&lt;CouponModel&gt;&gt; requestListener)</span> &#123;</span><br><span class=\"line\">       \t\t<span class=\"built_in\">super</span>(requestListener);</span><br><span class=\"line\">       \t\t<span class=\"built_in\">this</span>.mUrlParams.put(<span class=\"string\">&quot;id&quot;</span>, goodId);</span><br><span class=\"line\">   \t&#125;</span><br><span class=\"line\">   \t<span class=\"meta\">@Override</span></span><br><span class=\"line\">   \t<span class=\"keyword\">public</span> String <span class=\"title function_\">getBaseUrl</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">       \t\t<span class=\"keyword\">return</span> url;</span><br><span class=\"line\">  \t\t &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br><strong>二、在基类中构造网络请求</strong><br><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">protected</span> StringRequest <span class=\"title function_\">getStringRequest</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">     <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">StringRequest</span>(requestMethod, getRequestUrl(),</span><br><span class=\"line\">             response -&gt; parseJson(response),</span><br><span class=\"line\">             error -&gt; requestListener.onError(error)) &#123;</span><br><span class=\"line\">         <span class=\"meta\">@Override</span></span><br><span class=\"line\">         <span class=\"keyword\">protected</span> Map&lt;String, String&gt; <span class=\"title function_\">getParams</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">             <span class=\"keyword\">return</span> mEntityParams;</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">     &#125;;</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure><br>在此处实现可以看到Request在基类中进行，然后分别处理返回结果</p>\n<p><strong>三、对返回结果进行解析</strong><br><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">parseJson</span><span class=\"params\">(String response)</span> &#123;</span><br><span class=\"line\">      <span class=\"type\">int</span> <span class=\"variable\">responseCode</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">      <span class=\"type\">int</span> <span class=\"variable\">errorCode</span> <span class=\"operator\">=</span> <span class=\"number\">400</span>;</span><br><span class=\"line\">      <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">          <span class=\"type\">JSONObject</span> <span class=\"variable\">jsonObject</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">JSONObject</span>(response);</span><br><span class=\"line\"></span><br><span class=\"line\">          <span class=\"type\">String</span> <span class=\"variable\">resultString</span> <span class=\"operator\">=</span> jsonObject.getString(<span class=\"string\">&quot;data&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">          <span class=\"keyword\">if</span> (jsonObject.has(<span class=\"string\">&quot;code&quot;</span>)) &#123;</span><br><span class=\"line\">              responseCode = jsonObject.getInt(<span class=\"string\">&quot;code&quot;</span>);</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">          <span class=\"keyword\">if</span> (jsonObject.has(<span class=\"string\">&quot;error&quot;</span>)) &#123;</span><br><span class=\"line\">              errorCode = jsonObject.getInt(<span class=\"string\">&quot;error&quot;</span>);</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">          <span class=\"keyword\">if</span> (responseCode == <span class=\"number\">200</span> || errorCode == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">              <span class=\"keyword\">if</span> (!TextUtils.isEmpty(response)) &#123;</span><br><span class=\"line\">                  <span class=\"type\">Type</span> <span class=\"variable\">type</span> <span class=\"operator\">=</span> getTType(requestListener.getClass());</span><br><span class=\"line\">                  <span class=\"comment\">//泛型是实体或者List等类型</span></span><br><span class=\"line\">                  <span class=\"type\">T</span> <span class=\"variable\">t</span> <span class=\"operator\">=</span> JsonUtils.fromJson(resultString, type);</span><br><span class=\"line\">                  requestListener.onSuccess(t);</span><br><span class=\"line\">                  <span class=\"keyword\">return</span>;</span><br><span class=\"line\">              &#125;</span><br><span class=\"line\">              ToastUtils.showToast(<span class=\"string\">&quot;Data is empty!&quot;</span>);</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">          ToastUtils.showToast(<span class=\"string\">&quot;Response code is error.&quot;</span>);</span><br><span class=\"line\">          requestListener.onError(<span class=\"keyword\">new</span> <span class=\"title class_\">ParseError</span>());</span><br><span class=\"line\">      &#125; <span class=\"keyword\">catch</span> (JSONException e) &#123;</span><br><span class=\"line\">          ToastUtils.showToast(e.toString());</span><br><span class=\"line\">          e.printStackTrace();</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure><br>这里是最关键的一步，由于和后端约定好相关返回字段，那么只需要解析字段中目标model的数据，其中比较重要的是这段代码<br><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">\t<span class=\"type\">Type</span> <span class=\"variable\">type</span> <span class=\"operator\">=</span> getTType(requestListener.getClass());</span><br><span class=\"line\">    <span class=\"comment\">//泛型是实体或者List等类型</span></span><br><span class=\"line\">     <span class=\"type\">T</span> <span class=\"variable\">t</span> <span class=\"operator\">=</span> JsonUtils.fromJson(resultString, type);</span><br><span class=\"line\">     requestListener.onSuccess(t);</span><br><span class=\"line\">```\t </span><br><span class=\"line\">通过封装好的 JsonUtils将String转化为对应的model类型，我们知道json转实体对象的时候，需要指明其类type，那这里的type是如何获取到的呢？</span><br><span class=\"line\"></span><br><span class=\"line\">其中getTType ()的具体实现为：</span><br><span class=\"line\"> ```java</span><br><span class=\"line\">     <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Type <span class=\"title function_\">getTType</span><span class=\"params\">(Class&lt;?&gt; clazz)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//以Type的形式返回本类直接实现的接口.</span></span><br><span class=\"line\">        Type[] types = clazz.getGenericInterfaces();</span><br><span class=\"line\">        clazz.getInterfaces();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (types.length &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//返回表示此类型实际类型参数的 Type 对象的数组</span></span><br><span class=\"line\">            Type[] interfacesTypes = ((ParameterizedType) types[<span class=\"number\">0</span>]).getActualTypeArguments();</span><br><span class=\"line\">            <span class=\"keyword\">return</span> interfacesTypes[<span class=\"number\">0</span>];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure><br>通过次方法能够获取到请求实现中所指明的请求类型，其中getGenericInterfaces等相关原理可以阅读：<a href=\"https://my.oschina.net/617669559/blog/3012228\">https://my.oschina.net/617669559/blog/3012228</a></p>\n<p>所以对于<br><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">GetGoodDetailByGidRequest</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">BaseApiRequest</span>&lt;List&lt;CouponModel&gt;&gt;</span><br></pre></td></tr></table></figure><br>那么获取到的就是List<CouponModel>类型</p>\n<p><strong>四、通过Listener回调相关解析结果</strong>    </p>\n<p>拿到解析好的result并回调给构造Request方法中的listener使用<br><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">T</span> <span class=\"variable\">t</span> <span class=\"operator\">=</span> JsonUtils.fromJson(resultString, type);</span><br><span class=\"line\">requestListener.onSuccess(t);</span><br></pre></td></tr></table></figure></p>\n<p>这样对整个网络请求后的返回数据直接进行解析方便多了。</p>\n<p><strong>总结：</strong></p>\n<p>1、本文最主要是对基本Request类进行改造，以达到不需要每次重复写解析返回的String数据</p>\n<p>2、在获取目标的类的类型的时候，主要是去获取基类中的“T”类型</p>\n<p>3、设计不仅适用用Volley同样适用于其他类似的网络请求框架</p>\n","cover":null,"images":[],"content":"<p>在平时最普通的Volley的网络请求中，我们StringRequest是这样请求网络数据的：<br><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">StringRequest</span> <span class=\"variable\">stringRequest</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">StringRequest</span>(<span class=\"string\">&quot;http://www.baidu.com&quot;</span>,</span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">Response</span>.Listener&lt;String&gt;() &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">onResponse</span><span class=\"params\">(String response)</span> &#123;</span><br><span class=\"line\">                Log.d(<span class=\"string\">&quot;TAG&quot;</span>, response);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;, <span class=\"keyword\">new</span> <span class=\"title class_\">Response</span>.ErrorListener() &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">onErrorResponse</span><span class=\"params\">(VolleyError error)</span> &#123;</span><br><span class=\"line\">        Log.e(<span class=\"string\">&quot;TAG&quot;</span>, error.getMessage(), error);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure><br>注意在onResponse的时候是拿到的string类型，拿到string后对其再进行相关的解析，我们是否是可以对其直接封装然后拿到具体想要类型的model数据结构呢？所以对其网络请求架构进行一次封装，到达如下效果：<br><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">GetGoodDetailByGidRequest</span> <span class=\"variable\">getGoodDetailByGidRequest</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">GetGoodDetailByGidRequest</span>(mCouponId,</span><br><span class=\"line\">              <span class=\"keyword\">new</span> <span class=\"title class_\">RequestListener</span>&lt;List&lt;CouponModel&gt;&gt;() &#123;</span><br><span class=\"line\">                  <span class=\"meta\">@Override</span></span><br><span class=\"line\">                  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">onSuccess</span><span class=\"params\">(List&lt;CouponModel&gt; result)</span> &#123;</span><br><span class=\"line\">                  &#125;</span><br><span class=\"line\">                  <span class=\"meta\">@Override</span></span><br><span class=\"line\">                  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">onError</span><span class=\"params\">(Exception e)</span> &#123;</span><br><span class=\"line\">                      e.printStackTrace();</span><br><span class=\"line\">                      stopLoadingDialog();</span><br><span class=\"line\">                  &#125;</span><br><span class=\"line\">              &#125;);</span><br></pre></td></tr></table></figure><br>这里我们在构造Request的时候指定了返回数据的类型，这样的话就方便了我们在写业务的时候直接使用解析好的数据结构，具体如何做到的呢？</p>\n<p><strong>一、让每个Request基于一个带有范型请求类</strong><br><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">class</span> <span class=\"title class_\">BaseApiRequest</span>&lt;T&gt;  </span><br></pre></td></tr></table></figure><br>这里的T就是目标请求期望的model类<br>在具体实现的时候继承基类，并指定返回类型，下面是一个例子：<br><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">GetGoodDetailByGidRequest</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">BaseApiRequest</span>&lt;List&lt;CouponModel&gt;&gt; &#123;</span><br><span class=\"line\">   \t<span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">String</span> <span class=\"variable\">url</span> <span class=\"operator\">=</span> CURL.GoodDetailURL;</span><br><span class=\"line\">   \t<span class=\"keyword\">public</span> <span class=\"title function_\">GetGoodDetailByGidRequest</span><span class=\"params\">(String goodId, RequestListener&lt;List&lt;CouponModel&gt;&gt; requestListener)</span> &#123;</span><br><span class=\"line\">       \t\t<span class=\"built_in\">super</span>(requestListener);</span><br><span class=\"line\">       \t\t<span class=\"built_in\">this</span>.mUrlParams.put(<span class=\"string\">&quot;id&quot;</span>, goodId);</span><br><span class=\"line\">   \t&#125;</span><br><span class=\"line\">   \t<span class=\"meta\">@Override</span></span><br><span class=\"line\">   \t<span class=\"keyword\">public</span> String <span class=\"title function_\">getBaseUrl</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">       \t\t<span class=\"keyword\">return</span> url;</span><br><span class=\"line\">  \t\t &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br><strong>二、在基类中构造网络请求</strong><br><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">protected</span> StringRequest <span class=\"title function_\">getStringRequest</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">     <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">StringRequest</span>(requestMethod, getRequestUrl(),</span><br><span class=\"line\">             response -&gt; parseJson(response),</span><br><span class=\"line\">             error -&gt; requestListener.onError(error)) &#123;</span><br><span class=\"line\">         <span class=\"meta\">@Override</span></span><br><span class=\"line\">         <span class=\"keyword\">protected</span> Map&lt;String, String&gt; <span class=\"title function_\">getParams</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">             <span class=\"keyword\">return</span> mEntityParams;</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">     &#125;;</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure><br>在此处实现可以看到Request在基类中进行，然后分别处理返回结果</p>\n<p><strong>三、对返回结果进行解析</strong><br><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">parseJson</span><span class=\"params\">(String response)</span> &#123;</span><br><span class=\"line\">      <span class=\"type\">int</span> <span class=\"variable\">responseCode</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">      <span class=\"type\">int</span> <span class=\"variable\">errorCode</span> <span class=\"operator\">=</span> <span class=\"number\">400</span>;</span><br><span class=\"line\">      <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">          <span class=\"type\">JSONObject</span> <span class=\"variable\">jsonObject</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">JSONObject</span>(response);</span><br><span class=\"line\"></span><br><span class=\"line\">          <span class=\"type\">String</span> <span class=\"variable\">resultString</span> <span class=\"operator\">=</span> jsonObject.getString(<span class=\"string\">&quot;data&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">          <span class=\"keyword\">if</span> (jsonObject.has(<span class=\"string\">&quot;code&quot;</span>)) &#123;</span><br><span class=\"line\">              responseCode = jsonObject.getInt(<span class=\"string\">&quot;code&quot;</span>);</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">          <span class=\"keyword\">if</span> (jsonObject.has(<span class=\"string\">&quot;error&quot;</span>)) &#123;</span><br><span class=\"line\">              errorCode = jsonObject.getInt(<span class=\"string\">&quot;error&quot;</span>);</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">          <span class=\"keyword\">if</span> (responseCode == <span class=\"number\">200</span> || errorCode == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">              <span class=\"keyword\">if</span> (!TextUtils.isEmpty(response)) &#123;</span><br><span class=\"line\">                  <span class=\"type\">Type</span> <span class=\"variable\">type</span> <span class=\"operator\">=</span> getTType(requestListener.getClass());</span><br><span class=\"line\">                  <span class=\"comment\">//泛型是实体或者List等类型</span></span><br><span class=\"line\">                  <span class=\"type\">T</span> <span class=\"variable\">t</span> <span class=\"operator\">=</span> JsonUtils.fromJson(resultString, type);</span><br><span class=\"line\">                  requestListener.onSuccess(t);</span><br><span class=\"line\">                  <span class=\"keyword\">return</span>;</span><br><span class=\"line\">              &#125;</span><br><span class=\"line\">              ToastUtils.showToast(<span class=\"string\">&quot;Data is empty!&quot;</span>);</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">          ToastUtils.showToast(<span class=\"string\">&quot;Response code is error.&quot;</span>);</span><br><span class=\"line\">          requestListener.onError(<span class=\"keyword\">new</span> <span class=\"title class_\">ParseError</span>());</span><br><span class=\"line\">      &#125; <span class=\"keyword\">catch</span> (JSONException e) &#123;</span><br><span class=\"line\">          ToastUtils.showToast(e.toString());</span><br><span class=\"line\">          e.printStackTrace();</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure><br>这里是最关键的一步，由于和后端约定好相关返回字段，那么只需要解析字段中目标model的数据，其中比较重要的是这段代码<br><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">\t<span class=\"type\">Type</span> <span class=\"variable\">type</span> <span class=\"operator\">=</span> getTType(requestListener.getClass());</span><br><span class=\"line\">    <span class=\"comment\">//泛型是实体或者List等类型</span></span><br><span class=\"line\">     <span class=\"type\">T</span> <span class=\"variable\">t</span> <span class=\"operator\">=</span> JsonUtils.fromJson(resultString, type);</span><br><span class=\"line\">     requestListener.onSuccess(t);</span><br><span class=\"line\">```\t </span><br><span class=\"line\">通过封装好的 JsonUtils将String转化为对应的model类型，我们知道json转实体对象的时候，需要指明其类type，那这里的type是如何获取到的呢？</span><br><span class=\"line\"></span><br><span class=\"line\">其中getTType ()的具体实现为：</span><br><span class=\"line\"> ```java</span><br><span class=\"line\">     <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Type <span class=\"title function_\">getTType</span><span class=\"params\">(Class&lt;?&gt; clazz)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//以Type的形式返回本类直接实现的接口.</span></span><br><span class=\"line\">        Type[] types = clazz.getGenericInterfaces();</span><br><span class=\"line\">        clazz.getInterfaces();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (types.length &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//返回表示此类型实际类型参数的 Type 对象的数组</span></span><br><span class=\"line\">            Type[] interfacesTypes = ((ParameterizedType) types[<span class=\"number\">0</span>]).getActualTypeArguments();</span><br><span class=\"line\">            <span class=\"keyword\">return</span> interfacesTypes[<span class=\"number\">0</span>];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure><br>通过次方法能够获取到请求实现中所指明的请求类型，其中getGenericInterfaces等相关原理可以阅读：<a href=\"https://my.oschina.net/617669559/blog/3012228\">https://my.oschina.net/617669559/blog/3012228</a></p>\n<p>所以对于<br><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">GetGoodDetailByGidRequest</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">BaseApiRequest</span>&lt;List&lt;CouponModel&gt;&gt;</span><br></pre></td></tr></table></figure><br>那么获取到的就是List<CouponModel>类型</p>\n<p><strong>四、通过Listener回调相关解析结果</strong>    </p>\n<p>拿到解析好的result并回调给构造Request方法中的listener使用<br><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">T</span> <span class=\"variable\">t</span> <span class=\"operator\">=</span> JsonUtils.fromJson(resultString, type);</span><br><span class=\"line\">requestListener.onSuccess(t);</span><br></pre></td></tr></table></figure></p>\n<p>这样对整个网络请求后的返回数据直接进行解析方便多了。</p>\n<p><strong>总结：</strong></p>\n<p>1、本文最主要是对基本Request类进行改造，以达到不需要每次重复写解析返回的String数据</p>\n<p>2、在获取目标的类的类型的时候，主要是去获取基类中的“T”类型</p>\n<p>3、设计不仅适用用Volley同样适用于其他类似的网络请求框架</p>\n","categories":[{"name":"技术文章","slug":"technology","api":"api/categories/technology.json"}],"tags":[{"name":"安卓","slug":"Android","api":"api/tags/Android.json"}],"api":"api/posts/2019/05/13/基于Volley框架的返回数据的范型处理.json"},{"title":"Java反射中getGenericInterfaces和getInterfaces的解读","slug":"My-Java反射中getGenericInterfaces和getInterfaces的解读","date":"2019-05-05T11:12:00.000Z","updated":"2025-05-20T11:46:57.000Z","comments":true,"url":"2019/05/05/My-Java反射中getGenericInterfaces和getInterfaces的解读/","excerpt":"<p>今天在做解析网络请求后得到的数据的转化的时候用到了：getGenericInterfaces这个方法。<br> <figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">\t</span><br><span class=\"line\"> <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">  * 获取回调接口中 T 的具体类型</span></span><br><span class=\"line\"><span class=\"comment\">  *</span></span><br><span class=\"line\"><span class=\"comment\">  * <span class=\"doctag\">@param</span> clazz</span></span><br><span class=\"line\"><span class=\"comment\">  * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\">   <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Type <span class=\"title function_\">getTType</span><span class=\"params\">(Class clazz)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//以Type的形式返回本类直接实现的接口.</span></span><br><span class=\"line\">    Type[] types = clazz.getGenericInterfaces();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (types.length &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//返回表示此类型实际类型参数的 Type 对象的数组</span></span><br><span class=\"line\">        Type[] interfacesTypes = ((ParameterizedType) types[<span class=\"number\">0</span>]).getActualTypeArguments();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> interfacesTypes[<span class=\"number\">0</span>];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>其中回调接口为：<br><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"title class_\">RequestListener</span> &lt;&gt; () &#123;</span><br><span class=\"line\">     <span class=\"meta\">@Override</span></span><br><span class=\"line\">     <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">onSuccess</span> <span class=\"params\">(List result)</span>&#123;</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">     <span class=\"comment\">//在解析数据的时候这样操作，目的是为了对所有返回的数据进行数据转化为所指定的类型：</span></span><br><span class=\"line\"></span><br><span class=\"line\">     <span class=\"type\">Type</span> <span class=\"variable\">type</span> <span class=\"operator\">=</span> getTType(requestListener.getClass());</span><br><span class=\"line\">     <span class=\"comment\">//泛型是实体或者List等类型</span></span><br><span class=\"line\">     <span class=\"type\">T</span> <span class=\"variable\">t</span> <span class=\"operator\">=</span> JsonUtils.fromJson(resultString, type);</span><br><span class=\"line\">     requestListener.onSuccess(t);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>类RequestListener为：<br><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">RequestListener</span> &#123;</span><br><span class=\"line\">   \t<span class=\"keyword\">void</span> <span class=\"title function_\">onSuccess</span><span class=\"params\">(T result)</span>;</span><br><span class=\"line\">   \t<span class=\"keyword\">void</span> <span class=\"title function_\">onError</span><span class=\"params\">(Exception e)</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>使用Gson进行json的解析，T fromJson(String json, Type typeOfT);那么怎么才能获取到RequestListener中的的类型呢？<br>于是我们从接口获取参数化类型处理。</p>\n<p>官方文档解释</p>\n<p>getGenericInterfaces：</p>\n<blockquote>\n<p>Returns the {@code Type}s representing the interfaces directly implemented by the class or interface represented by this object.释意：返回表示由此对象表示的类或接口直接实现的接口的{@code Type}。</p>\n</blockquote>\n<p>getInterfaces：</p>\n<blockquote>\n<p>Determines the interfaces implemented by the class or interface represented by this object.<br> 释意：返回由此对象表示的类或接口实现的接口。</p>\n</blockquote>\n<p>从解释上面来看出来了，差异在于“接口实现的接口的Type”，接下来用具体示例来解释区别<br><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Food</span>&#123;</span><br><span class=\"line\">    String foodName;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">Eat</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">void</span> <span class=\"title function_\">eat</span><span class=\"params\">(String things)</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">Run</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Dog</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Eat</span>,Run&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span> &#123; &#125;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">eat</span><span class=\"params\">(String things)</span> &#123; &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">Class</span> <span class=\"variable\">clazz</span> <span class=\"operator\">=</span> Dog.class;</span><br><span class=\"line\">    Type[] genericInterfaces = clazz.getGenericInterfaces();</span><br><span class=\"line\">    Class[] interfaces = clazz.getInterfaces();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>    运行结果<br>    <img src=\"https://cdn.julis.wang/blog/img/245442107557694aef0f07c25be0740187c.jpg\"></p>\n<p>我们可以看到，clazz.getGenericInterfaces()与clazz.getInterfaces()并没有任何差异。因为 并没有：“实现的接口的Type”</p>\n<p>接下来看另一段代码,我们对Eat接口改造一下，增加一个参数化类型</p>\n<pre class=\" language-lang-java\"><code class=\"language-lang-java\">    private class Food&#123;\n        String foodName;\n    &#125;\n    private interface Eat&#123;\n        void eat(T things);\n    &#125;\n    private interface Run&#123;\n        void run();\n    &#125;\n\n    private class Dog implements Eat,Run&#123;\n        @Override\n        public void run() &#123; &#125;\n        @Override\n        public void eat(Food things) &#123; &#125;\n    &#125;\n    private void main() &#123;\n        Class clazz = Dog.class;\n        Type[] genericInterfaces = clazz.getGenericInterfaces();\n        Class[] interfaces = clazz.getInterfaces();\n    &#125;\n</code></pre>\n<pre><code>运行结果：\n</code></pre><img src=\"https://cdn.julis.wang/blog/img/1e8dd5258232de0b459be594f9793283c0a.jpg\">","cover":null,"images":["https://cdn.julis.wang/blog/img/245442107557694aef0f07c25be0740187c.jpg","https://cdn.julis.wang/blog/img/1e8dd5258232de0b459be594f9793283c0a.jpg"],"content":"<p>今天在做解析网络请求后得到的数据的转化的时候用到了：getGenericInterfaces这个方法。<br> <figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">\t</span><br><span class=\"line\"> <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">  * 获取回调接口中 T 的具体类型</span></span><br><span class=\"line\"><span class=\"comment\">  *</span></span><br><span class=\"line\"><span class=\"comment\">  * <span class=\"doctag\">@param</span> clazz</span></span><br><span class=\"line\"><span class=\"comment\">  * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\">   <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Type <span class=\"title function_\">getTType</span><span class=\"params\">(Class clazz)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//以Type的形式返回本类直接实现的接口.</span></span><br><span class=\"line\">    Type[] types = clazz.getGenericInterfaces();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (types.length &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//返回表示此类型实际类型参数的 Type 对象的数组</span></span><br><span class=\"line\">        Type[] interfacesTypes = ((ParameterizedType) types[<span class=\"number\">0</span>]).getActualTypeArguments();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> interfacesTypes[<span class=\"number\">0</span>];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>其中回调接口为：<br><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"title class_\">RequestListener</span> &lt;&gt; () &#123;</span><br><span class=\"line\">     <span class=\"meta\">@Override</span></span><br><span class=\"line\">     <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">onSuccess</span> <span class=\"params\">(List result)</span>&#123;</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">     <span class=\"comment\">//在解析数据的时候这样操作，目的是为了对所有返回的数据进行数据转化为所指定的类型：</span></span><br><span class=\"line\"></span><br><span class=\"line\">     <span class=\"type\">Type</span> <span class=\"variable\">type</span> <span class=\"operator\">=</span> getTType(requestListener.getClass());</span><br><span class=\"line\">     <span class=\"comment\">//泛型是实体或者List等类型</span></span><br><span class=\"line\">     <span class=\"type\">T</span> <span class=\"variable\">t</span> <span class=\"operator\">=</span> JsonUtils.fromJson(resultString, type);</span><br><span class=\"line\">     requestListener.onSuccess(t);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>类RequestListener为：<br><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">RequestListener</span> &#123;</span><br><span class=\"line\">   \t<span class=\"keyword\">void</span> <span class=\"title function_\">onSuccess</span><span class=\"params\">(T result)</span>;</span><br><span class=\"line\">   \t<span class=\"keyword\">void</span> <span class=\"title function_\">onError</span><span class=\"params\">(Exception e)</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>使用Gson进行json的解析，T fromJson(String json, Type typeOfT);那么怎么才能获取到RequestListener中的的类型呢？<br>于是我们从接口获取参数化类型处理。</p>\n<p>官方文档解释</p>\n<p>getGenericInterfaces：</p>\n<blockquote>\n<p>Returns the {@code Type}s representing the interfaces directly implemented by the class or interface represented by this object.释意：返回表示由此对象表示的类或接口直接实现的接口的{@code Type}。</p>\n</blockquote>\n<p>getInterfaces：</p>\n<blockquote>\n<p>Determines the interfaces implemented by the class or interface represented by this object.<br> 释意：返回由此对象表示的类或接口实现的接口。</p>\n</blockquote>\n<p>从解释上面来看出来了，差异在于“接口实现的接口的Type”，接下来用具体示例来解释区别<br><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Food</span>&#123;</span><br><span class=\"line\">    String foodName;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">Eat</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">void</span> <span class=\"title function_\">eat</span><span class=\"params\">(String things)</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">Run</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Dog</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Eat</span>,Run&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span> &#123; &#125;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">eat</span><span class=\"params\">(String things)</span> &#123; &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">Class</span> <span class=\"variable\">clazz</span> <span class=\"operator\">=</span> Dog.class;</span><br><span class=\"line\">    Type[] genericInterfaces = clazz.getGenericInterfaces();</span><br><span class=\"line\">    Class[] interfaces = clazz.getInterfaces();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>    运行结果<br>    <img src=\"https://cdn.julis.wang/blog/img/245442107557694aef0f07c25be0740187c.jpg\"></p>\n<p>我们可以看到，clazz.getGenericInterfaces()与clazz.getInterfaces()并没有任何差异。因为 并没有：“实现的接口的Type”</p>\n<p>接下来看另一段代码,我们对Eat接口改造一下，增加一个参数化类型</p>\n<pre class=\" language-lang-java\"><code class=\"language-lang-java\">    private class Food&#123;\n        String foodName;\n    &#125;\n    private interface Eat&#123;\n        void eat(T things);\n    &#125;\n    private interface Run&#123;\n        void run();\n    &#125;\n\n    private class Dog implements Eat,Run&#123;\n        @Override\n        public void run() &#123; &#125;\n        @Override\n        public void eat(Food things) &#123; &#125;\n    &#125;\n    private void main() &#123;\n        Class clazz = Dog.class;\n        Type[] genericInterfaces = clazz.getGenericInterfaces();\n        Class[] interfaces = clazz.getInterfaces();\n    &#125;\n</code></pre>\n<pre><code>运行结果：\n</code></pre><img src=\"https://cdn.julis.wang/blog/img/1e8dd5258232de0b459be594f9793283c0a.jpg\">","categories":[{"name":"技术文章","slug":"technology","api":"api/categories/technology.json"}],"tags":[{"name":"网络","slug":"网络","api":"api/tags/网络.json"}],"api":"api/posts/2019/05/05/My-Java反射中getGenericInterfaces和getInterfaces的解读.json"},{"title":"关于大学生活总结","slug":"关于大学生活总结","date":"2019-04-30T02:23:05.000Z","updated":"2025-08-25T14:08:00.224Z","comments":true,"url":"2019/04/30/关于大学生活总结/","excerpt":"<p>这篇文章原发布于知乎，原问题为：<a href=\"https://www.zhihu.com/question/317346252/answer/655840980\">如何看待 B 站用户「—刃舞—」大学退学在家自学编程？</a>,当时毕业刚不久，有感而发，写了很多关于大学生活的事。主要是想告诉大家，大学并不是只有学习这一件事，还可以做很多很多有意思的事。</p>\n<h2 id=\"原文\"><a href=\"#原文\" class=\"headerlink\" title=\"原文\"></a>原文</h2><p>看到 @刃舞 了经历，彷佛看到了自己当初的自己。以一个 学长的身份来回答这个问题吧，也算是对自己大学四年生活的一个总结吧。<br>曾几何时，我也向像他一样，满腔热情，不可一世，感觉自己很牛逼了，好像学校教的东西太少了，不能满足自己对编程技术的追求，我想学东西，我想搞出个牛逼的东西出来。于是大一开始接触Linux+php+Mysql来,这篇文章讲了自己的一些相关真实经历。<br>感觉真的成就感爆棚，做一个论坛什么之类的，数据库的增删改查用得6得不得了。<br>自己做了各种各样花里胡哨的东西，把什么Thinkphp、Bootstrap、Jquery、Foundation……之类的名字听起来很高端的框架都用了起来。我也不满足于这些东西，于是啥都学，学了C\\C++\\C#、php、又Java、后来听说爬虫这玩意儿，又接触了python,反正就是花里胡哨的东西就是一顿学！、我当时也认为大学所教授课程效率低下而且没有实际用处，但是我并没有选择退学课呀什么的，老师讲得都是啥啊，于是就逃课咯，我也给一些老师说了（比如在上Java课，而那时候我已经开始接触安卓相关了，我说这门课我能不能不用去，老师说：学校有免修，你牛逼，你去提前考试了通过了就可以不用修了。当然老师不是这么说的，大概就是这种意思吧，可是傻傻的我并没有去走免修这条路，因为我感觉自己能拿到60分，但是拿不到80分才通过的分。）但我还是没有去上课，老师也知道我不去上课也都知道我在干嘛，虽然早上没有课，但我也会保证每天是最早到学院的人，都会去工作室待在电脑面前，基本上都很晚才会回去。<br>这样一直持续了两三年，直到大三下，我才开始慌了起来，我感觉自己好像什么都懂，但是又懂得不是特别深，在大三下的时候投了简历，在下面回答有讲过相关经历:<br>经历过种种面试，大三下暑假终于进入了一家公司开始实习，以PHP开发岗位进去的，在这里有很多牛逼的人，也有各个方面的专家。我的工位就在安卓开发团队旁边，因为之前有花很多心思去做了一个安卓App,于是在闲暇时间向其中一个大哥请教：你觉得我这App怎么样？ 他稍微滑了几滑说道：这不就是大学里面期末课程设计的么？ 我瞬间就懵逼了，也被打击了，我连续搞了大半年的App，多少个日夜搞出来的，就被他这样一句话给怼了…… 之后我才渐渐知道 闭门造车，出门而不能合辙。 自己虽造了很多车，但是车拿出去之后压根就跑步太起来。在公司实习后，在导师的指导下，我知道了该学习的东西和方向，每天下班回家后也都会坚持学习，我发现我收获到的东西是在学校里面的很多倍，可能这些东西更加的实用了，因为都在面向平时所会接触到的问题靠近。我有动力，一方面是来自于实力与前辈们的差距，另一方面也是来源于内心，我想过更好的生活。<br>难道 我的大学的价值就没有太大用了么？<br>当然不是。反而充实的大学生活让我收获到了更多，也让我在那里留下了一段美好的青葱岁月。收获到的并不是金钱那么简单，大学对我的心智得到了锻炼，养成了各种良好的品行，以及各种经历让我生活更加的有趣。<br>生活在这个地球上，工作与学习只是其中的一小小部分。我们可以结交很多志同道合的朋友，我们可以在仅有的青春岁月里做一些年轻时大胆去尝试的事，我们可以做的还有很多很多……</p>\n<p>在大学里<br>曾经和这些小伙伴们一起踢过足球<br><img src=\"https://pic3.zhimg.com/80/v2-a0d4cb5f97bbac56501ad42c0ee6eb9d_1440w.jpg\" alt=\"那年莱斯特城英超冠军\"></p>\n<p><img src=\"https://pic3.zhimg.com/80/v2-8cd73363031f575f79007877c7ac8002_1440w.jpg\" alt=\"那年多特蒙德德甲冠军\"></p>\n<p>在大学里<br>曾经和这些小伙伴们代表学院参加排球赛<br>![]<a href=\"https://pic1.zhimg.com/80/v2-96a34d0bd4d1c42d52b13fc0ed7367b2_1440w.jpg\">https://pic1.zhimg.com/80/v2-96a34d0bd4d1c42d52b13fc0ed7367b2_1440w.jpg</a></p>\n<p>在大学里<br>曾在学生会“浪里白条”，从干事到部长<br><img src=\"https://pic1.zhimg.com/80/v2-74a4684a4d7a25de124a90f70efa66a4_1440w.jpg\" alt=\"\"><br><img src=\"https://pic2.zhimg.com/80/v2-8501116a0851253846bacf280e9be84f_1440w.jpg\" alt=\"\"></p>\n<p>在大学里<br>曾带着“五元”到城中“生存挑战”一天<br><img src=\"https://pic4.zhimg.com/80/v2-18d0e4b154b7a7659e11facb02ee6552_1440w.jpg\" alt=\"\"></p>\n<p>在大学里<br>曾与小伙伴们游西湖并与互联网企业CEO谈话<br><img src=\"https://pic2.zhimg.com/80/v2-29480a8f92602e90681f56956403abb8_1440w.jpg\" alt=\"\"><br><img src=\"https://pic1.zhimg.com/80/v2-7b5ef03b0f4ceb0f4e6d4faad5411f2c_1440w.jpg\" alt=\"\"></p>\n<p>在大学里<br>曾意气风发<br><img src=\"https://pic4.zhimg.com/80/v2-644f7664f01204de27133bb4fca4e65b_1440w.jpg\" alt=\"\"></p>\n<p>在大学里<br>曾组织拍摄了一部微电影<br><img src=\"https://pic3.zhimg.com/80/v2-bc65d00bc60fbc653c97b5e8d2f8af90_1440w.jpg\" alt=\"\"></p>\n<p>在大学里<br>曾与室友“醉生梦死”<br><img src=\"https://pic4.zhimg.com/80/v2-f0a2637f8107628a3b0b23a8078d9124_1440w.jpg\" alt=\"\"></p>\n<p>在大学里<br>曾给大一的学弟妹们上课，教C与网页编程相关<br><img src=\"https://pic3.zhimg.com/80/v2-918fdcd42c73cb48b46192985369297e_1440w.jpg\" alt=\"\"></p>\n<p>在大学里<br>曾上台表演小品，一口“川普”的效果引得大家哈哈大笑<br><img src=\"https://pic3.zhimg.com/80/v2-972c28867f964e1a87ec4c121410f750_1440w.jpg\" alt=\"\"><br><img src=\"https://pic4.zhimg.com/80/v2-9c34e008f37ce17a896765e58ea1dd00_1440w.jpg\" alt=\"\"></p>\n<p>在大学里<br>也曾与大学的川籍老乡畅叙幽情<br><img src=\"https://pic1.zhimg.com/80/v2-cdb0f5459c52a12c66606ef29c4c346c_1440w.jpg\" alt=\"\"><br><img src=\"https://pic1.zhimg.com/80/v2-691923471213264b8fd61aa50717aacf_1440w.jpg\" alt=\"\"><br>在大学里<br>也曾和我的班级同学们团结向上<br><img src=\"https://pic3.zhimg.com/80/v2-f1789a51241abb0e642dbc75e5441ced_1440w.jpg\" alt=\"\"></p>\n<p>在大学里<br>曾与本地企业管理层一起学习<br><img src=\"https://pic4.zhimg.com/80/v2-d97d238747e2f1229f9728f178debcb8_1440w.jpg\" alt=\"\"><br><img src=\"https://pic4.zhimg.com/80/v2-5013f2bdfc163dfa72aa65e3c9d7c269_1440w.jpg\" alt=\"\"></p>\n<p>在大学里<br>曾与那群“黑哥们儿” Did something interesting<br><img src=\"https://pic1.zhimg.com/80/v2-d1d29b2d2a6ff24dfe21dc3e91e330b8_1440w.jpg\" alt=\"\"><br><img src=\"https://pic1.zhimg.com/80/v2-7e7b869bed9954e104c25304a86671aa_1440w.jpg\" alt=\"\"></p>\n<p>在大学里<br>也曾和我的“战友”一起战斗<br><img src=\"https://pic2.zhimg.com/80/v2-a7538607dc1e4bdc28e81bcf7d8b4b41_1440w.jpg\" alt=\"\"><br><img src=\"https://pic4.zhimg.com/80/v2-8c6543eefb3046ffe05f18109bdf56fa_1440w.jpg\" alt=\"\"><br><img src=\"https://pic4.zhimg.com/80/v2-f3678242091c39a78c86972eac336df1_1440w.jpg\" alt=\"\"><br><img src=\"https://pic2.zhimg.com/80/v2-4e93b5299cbb5b1da5e696ebab39ad64_1440w.jpg\" alt=\"\"><br><img src=\"https://pic4.zhimg.com/80/v2-25062350c962b976ab1312a16c5fe761_1440w.jpg\" alt=\"\"></p>\n<p>在大学里<br>也曾在创业尝试<br>xxx</p>\n<p>在大学里<br>也曾“到处奔波”<br><img src=\"https://pic4.zhimg.com/80/v2-566607d0578e8f5ee74d37079a1e11db_1440w.jpg\" alt=\"\"></p>\n<p>添加图片注释，不超过 140 字（可选）<br>在大学里<br>也曾…</p>\n<p>在大学里<br>我见到了各式各样的人，我也去了各种各样的地方，也结交了各种各样的朋友，做了各式各样的事，真的没有什么遗憾的了。</p>\n<p>感谢大学，不仅教授了知识，也让我四年的青春没有虚度，把这些美好都永远留在了我得青春岁月里了吧。</p>\n<p>加油吧！相信自己的选择，每个人都有每个人的努力方向，只要自己不会后悔。</p>\n<p>祝成功。</p>\n<p>当时的评论存档</p>\n<blockquote>\n<p>坠入苦海销尘垢<br>认出了好多一起踢过球的同学，好像是野球社？我记得我也在的😂</p>\n<p>坠入苦海销尘垢<br>关注我的人<br>看傻了，这不是我学校吗😂题主是19届的么<br>2020-04-07</p>\n<p>刃舞<br>…… 并没有不可一世，也没觉得自己牛 x，我只想说题主描述有虚假煽动成分，自己分辨吧<br>2019-04-23<br>落叶挽歌&gt;<br>这里或许是我表达错误吧，觉得自己牛X啥啥的，但是你这样表现出来的确实是这样的。也不清楚为什么知乎这里开始议论你了，如果你真心想做些东西或者研究什么，那就自己悄悄摸摸地做吧，不需要让所有人知道，也不用去反驳别人，当你真正“出山”了，再告诉我们吧，不需要把你一阶段一阶段的东西告诉我们。我没有针对你的意思，也不认为有什么虚假煽动信息。<br>2019-04-23<br>刃舞&gt;落叶挽歌<br>我说的是题主 ……<br>哈皮做游戏&gt;落叶挽歌<br>单纯享受快乐多好。除非家里很穷，穷得交不起学费。<br>落叶挽歌&gt;哈皮做游戏<br>享受就有点过了吧，还是要正能量积极一点哈[调皮]<br>哈皮做游戏&gt;落叶挽歌<br>以前也想学知识，学东西，出去好找工作。<br>以后工作大把学习东西的时间，就缺谈恋爱的时间。<br>落叶挽歌&gt;哈皮做游戏<br>那你工作很忙哈，我还好的。</p>\n<p>知乎用户IZr076<br>真的是良心回答。答主的大学，没有遗憾了。</p>\n</blockquote>\n","cover":null,"images":["https://pic3.zhimg.com/80/v2-a0d4cb5f97bbac56501ad42c0ee6eb9d_1440w.jpg","https://pic3.zhimg.com/80/v2-8cd73363031f575f79007877c7ac8002_1440w.jpg","https://pic1.zhimg.com/80/v2-74a4684a4d7a25de124a90f70efa66a4_1440w.jpg","https://pic4.zhimg.com/80/v2-18d0e4b154b7a7659e11facb02ee6552_1440w.jpg","https://pic2.zhimg.com/80/v2-29480a8f92602e90681f56956403abb8_1440w.jpg","https://pic4.zhimg.com/80/v2-644f7664f01204de27133bb4fca4e65b_1440w.jpg","https://pic3.zhimg.com/80/v2-bc65d00bc60fbc653c97b5e8d2f8af90_1440w.jpg","https://pic4.zhimg.com/80/v2-f0a2637f8107628a3b0b23a8078d9124_1440w.jpg","https://pic3.zhimg.com/80/v2-918fdcd42c73cb48b46192985369297e_1440w.jpg","https://pic3.zhimg.com/80/v2-972c28867f964e1a87ec4c121410f750_1440w.jpg","https://pic1.zhimg.com/80/v2-cdb0f5459c52a12c66606ef29c4c346c_1440w.jpg","https://pic4.zhimg.com/80/v2-d97d238747e2f1229f9728f178debcb8_1440w.jpg","https://pic1.zhimg.com/80/v2-d1d29b2d2a6ff24dfe21dc3e91e330b8_1440w.jpg","https://pic2.zhimg.com/80/v2-a7538607dc1e4bdc28e81bcf7d8b4b41_1440w.jpg","https://pic4.zhimg.com/80/v2-566607d0578e8f5ee74d37079a1e11db_1440w.jpg"],"content":"<p>这篇文章原发布于知乎，原问题为：<a href=\"https://www.zhihu.com/question/317346252/answer/655840980\">如何看待 B 站用户「—刃舞—」大学退学在家自学编程？</a>,当时毕业刚不久，有感而发，写了很多关于大学生活的事。主要是想告诉大家，大学并不是只有学习这一件事，还可以做很多很多有意思的事。</p>\n<h2 id=\"原文\"><a href=\"#原文\" class=\"headerlink\" title=\"原文\"></a>原文</h2><p>看到 @刃舞 了经历，彷佛看到了自己当初的自己。以一个 学长的身份来回答这个问题吧，也算是对自己大学四年生活的一个总结吧。<br>曾几何时，我也向像他一样，满腔热情，不可一世，感觉自己很牛逼了，好像学校教的东西太少了，不能满足自己对编程技术的追求，我想学东西，我想搞出个牛逼的东西出来。于是大一开始接触Linux+php+Mysql来,这篇文章讲了自己的一些相关真实经历。<br>感觉真的成就感爆棚，做一个论坛什么之类的，数据库的增删改查用得6得不得了。<br>自己做了各种各样花里胡哨的东西，把什么Thinkphp、Bootstrap、Jquery、Foundation……之类的名字听起来很高端的框架都用了起来。我也不满足于这些东西，于是啥都学，学了C\\C++\\C#、php、又Java、后来听说爬虫这玩意儿，又接触了python,反正就是花里胡哨的东西就是一顿学！、我当时也认为大学所教授课程效率低下而且没有实际用处，但是我并没有选择退学课呀什么的，老师讲得都是啥啊，于是就逃课咯，我也给一些老师说了（比如在上Java课，而那时候我已经开始接触安卓相关了，我说这门课我能不能不用去，老师说：学校有免修，你牛逼，你去提前考试了通过了就可以不用修了。当然老师不是这么说的，大概就是这种意思吧，可是傻傻的我并没有去走免修这条路，因为我感觉自己能拿到60分，但是拿不到80分才通过的分。）但我还是没有去上课，老师也知道我不去上课也都知道我在干嘛，虽然早上没有课，但我也会保证每天是最早到学院的人，都会去工作室待在电脑面前，基本上都很晚才会回去。<br>这样一直持续了两三年，直到大三下，我才开始慌了起来，我感觉自己好像什么都懂，但是又懂得不是特别深，在大三下的时候投了简历，在下面回答有讲过相关经历:<br>经历过种种面试，大三下暑假终于进入了一家公司开始实习，以PHP开发岗位进去的，在这里有很多牛逼的人，也有各个方面的专家。我的工位就在安卓开发团队旁边，因为之前有花很多心思去做了一个安卓App,于是在闲暇时间向其中一个大哥请教：你觉得我这App怎么样？ 他稍微滑了几滑说道：这不就是大学里面期末课程设计的么？ 我瞬间就懵逼了，也被打击了，我连续搞了大半年的App，多少个日夜搞出来的，就被他这样一句话给怼了…… 之后我才渐渐知道 闭门造车，出门而不能合辙。 自己虽造了很多车，但是车拿出去之后压根就跑步太起来。在公司实习后，在导师的指导下，我知道了该学习的东西和方向，每天下班回家后也都会坚持学习，我发现我收获到的东西是在学校里面的很多倍，可能这些东西更加的实用了，因为都在面向平时所会接触到的问题靠近。我有动力，一方面是来自于实力与前辈们的差距，另一方面也是来源于内心，我想过更好的生活。<br>难道 我的大学的价值就没有太大用了么？<br>当然不是。反而充实的大学生活让我收获到了更多，也让我在那里留下了一段美好的青葱岁月。收获到的并不是金钱那么简单，大学对我的心智得到了锻炼，养成了各种良好的品行，以及各种经历让我生活更加的有趣。<br>生活在这个地球上，工作与学习只是其中的一小小部分。我们可以结交很多志同道合的朋友，我们可以在仅有的青春岁月里做一些年轻时大胆去尝试的事，我们可以做的还有很多很多……</p>\n<p>在大学里<br>曾经和这些小伙伴们一起踢过足球<br><img src=\"https://pic3.zhimg.com/80/v2-a0d4cb5f97bbac56501ad42c0ee6eb9d_1440w.jpg\" alt=\"那年莱斯特城英超冠军\"></p>\n<p><img src=\"https://pic3.zhimg.com/80/v2-8cd73363031f575f79007877c7ac8002_1440w.jpg\" alt=\"那年多特蒙德德甲冠军\"></p>\n<p>在大学里<br>曾经和这些小伙伴们代表学院参加排球赛<br>![]<a href=\"https://pic1.zhimg.com/80/v2-96a34d0bd4d1c42d52b13fc0ed7367b2_1440w.jpg\">https://pic1.zhimg.com/80/v2-96a34d0bd4d1c42d52b13fc0ed7367b2_1440w.jpg</a></p>\n<p>在大学里<br>曾在学生会“浪里白条”，从干事到部长<br><img src=\"https://pic1.zhimg.com/80/v2-74a4684a4d7a25de124a90f70efa66a4_1440w.jpg\" alt=\"\"><br><img src=\"https://pic2.zhimg.com/80/v2-8501116a0851253846bacf280e9be84f_1440w.jpg\" alt=\"\"></p>\n<p>在大学里<br>曾带着“五元”到城中“生存挑战”一天<br><img src=\"https://pic4.zhimg.com/80/v2-18d0e4b154b7a7659e11facb02ee6552_1440w.jpg\" alt=\"\"></p>\n<p>在大学里<br>曾与小伙伴们游西湖并与互联网企业CEO谈话<br><img src=\"https://pic2.zhimg.com/80/v2-29480a8f92602e90681f56956403abb8_1440w.jpg\" alt=\"\"><br><img src=\"https://pic1.zhimg.com/80/v2-7b5ef03b0f4ceb0f4e6d4faad5411f2c_1440w.jpg\" alt=\"\"></p>\n<p>在大学里<br>曾意气风发<br><img src=\"https://pic4.zhimg.com/80/v2-644f7664f01204de27133bb4fca4e65b_1440w.jpg\" alt=\"\"></p>\n<p>在大学里<br>曾组织拍摄了一部微电影<br><img src=\"https://pic3.zhimg.com/80/v2-bc65d00bc60fbc653c97b5e8d2f8af90_1440w.jpg\" alt=\"\"></p>\n<p>在大学里<br>曾与室友“醉生梦死”<br><img src=\"https://pic4.zhimg.com/80/v2-f0a2637f8107628a3b0b23a8078d9124_1440w.jpg\" alt=\"\"></p>\n<p>在大学里<br>曾给大一的学弟妹们上课，教C与网页编程相关<br><img src=\"https://pic3.zhimg.com/80/v2-918fdcd42c73cb48b46192985369297e_1440w.jpg\" alt=\"\"></p>\n<p>在大学里<br>曾上台表演小品，一口“川普”的效果引得大家哈哈大笑<br><img src=\"https://pic3.zhimg.com/80/v2-972c28867f964e1a87ec4c121410f750_1440w.jpg\" alt=\"\"><br><img src=\"https://pic4.zhimg.com/80/v2-9c34e008f37ce17a896765e58ea1dd00_1440w.jpg\" alt=\"\"></p>\n<p>在大学里<br>也曾与大学的川籍老乡畅叙幽情<br><img src=\"https://pic1.zhimg.com/80/v2-cdb0f5459c52a12c66606ef29c4c346c_1440w.jpg\" alt=\"\"><br><img src=\"https://pic1.zhimg.com/80/v2-691923471213264b8fd61aa50717aacf_1440w.jpg\" alt=\"\"><br>在大学里<br>也曾和我的班级同学们团结向上<br><img src=\"https://pic3.zhimg.com/80/v2-f1789a51241abb0e642dbc75e5441ced_1440w.jpg\" alt=\"\"></p>\n<p>在大学里<br>曾与本地企业管理层一起学习<br><img src=\"https://pic4.zhimg.com/80/v2-d97d238747e2f1229f9728f178debcb8_1440w.jpg\" alt=\"\"><br><img src=\"https://pic4.zhimg.com/80/v2-5013f2bdfc163dfa72aa65e3c9d7c269_1440w.jpg\" alt=\"\"></p>\n<p>在大学里<br>曾与那群“黑哥们儿” Did something interesting<br><img src=\"https://pic1.zhimg.com/80/v2-d1d29b2d2a6ff24dfe21dc3e91e330b8_1440w.jpg\" alt=\"\"><br><img src=\"https://pic1.zhimg.com/80/v2-7e7b869bed9954e104c25304a86671aa_1440w.jpg\" alt=\"\"></p>\n<p>在大学里<br>也曾和我的“战友”一起战斗<br><img src=\"https://pic2.zhimg.com/80/v2-a7538607dc1e4bdc28e81bcf7d8b4b41_1440w.jpg\" alt=\"\"><br><img src=\"https://pic4.zhimg.com/80/v2-8c6543eefb3046ffe05f18109bdf56fa_1440w.jpg\" alt=\"\"><br><img src=\"https://pic4.zhimg.com/80/v2-f3678242091c39a78c86972eac336df1_1440w.jpg\" alt=\"\"><br><img src=\"https://pic2.zhimg.com/80/v2-4e93b5299cbb5b1da5e696ebab39ad64_1440w.jpg\" alt=\"\"><br><img src=\"https://pic4.zhimg.com/80/v2-25062350c962b976ab1312a16c5fe761_1440w.jpg\" alt=\"\"></p>\n<p>在大学里<br>也曾在创业尝试<br>xxx</p>\n<p>在大学里<br>也曾“到处奔波”<br><img src=\"https://pic4.zhimg.com/80/v2-566607d0578e8f5ee74d37079a1e11db_1440w.jpg\" alt=\"\"></p>\n<p>添加图片注释，不超过 140 字（可选）<br>在大学里<br>也曾…</p>\n<p>在大学里<br>我见到了各式各样的人，我也去了各种各样的地方，也结交了各种各样的朋友，做了各式各样的事，真的没有什么遗憾的了。</p>\n<p>感谢大学，不仅教授了知识，也让我四年的青春没有虚度，把这些美好都永远留在了我得青春岁月里了吧。</p>\n<p>加油吧！相信自己的选择，每个人都有每个人的努力方向，只要自己不会后悔。</p>\n<p>祝成功。</p>\n<p>当时的评论存档</p>\n<blockquote>\n<p>坠入苦海销尘垢<br>认出了好多一起踢过球的同学，好像是野球社？我记得我也在的😂</p>\n<p>坠入苦海销尘垢<br>关注我的人<br>看傻了，这不是我学校吗😂题主是19届的么<br>2020-04-07</p>\n<p>刃舞<br>…… 并没有不可一世，也没觉得自己牛 x，我只想说题主描述有虚假煽动成分，自己分辨吧<br>2019-04-23<br>落叶挽歌&gt;<br>这里或许是我表达错误吧，觉得自己牛X啥啥的，但是你这样表现出来的确实是这样的。也不清楚为什么知乎这里开始议论你了，如果你真心想做些东西或者研究什么，那就自己悄悄摸摸地做吧，不需要让所有人知道，也不用去反驳别人，当你真正“出山”了，再告诉我们吧，不需要把你一阶段一阶段的东西告诉我们。我没有针对你的意思，也不认为有什么虚假煽动信息。<br>2019-04-23<br>刃舞&gt;落叶挽歌<br>我说的是题主 ……<br>哈皮做游戏&gt;落叶挽歌<br>单纯享受快乐多好。除非家里很穷，穷得交不起学费。<br>落叶挽歌&gt;哈皮做游戏<br>享受就有点过了吧，还是要正能量积极一点哈[调皮]<br>哈皮做游戏&gt;落叶挽歌<br>以前也想学知识，学东西，出去好找工作。<br>以后工作大把学习东西的时间，就缺谈恋爱的时间。<br>落叶挽歌&gt;哈皮做游戏<br>那你工作很忙哈，我还好的。</p>\n<p>知乎用户IZr076<br>真的是良心回答。答主的大学，没有遗憾了。</p>\n</blockquote>\n","categories":[{"name":"技术文章","slug":"technology","api":"api/categories/technology.json"}],"tags":[{"name":"大学","slug":"大学","api":"api/tags/大学.json"}],"api":"api/posts/2019/04/30/关于大学生活总结.json"},{"title":"关于位运算和HashMap中一个求最小2次幂的算法","slug":"关于位运算和HashMap中一个求最小2次幂的算法","date":"2019-04-13T01:36:00.000Z","updated":"2025-05-20T11:46:57.000Z","comments":true,"url":"2019/04/13/关于位运算和HashMap中一个求最小2次幂的算法/","excerpt":"<p>今天在HashMap的内部源码的时候，看到这样一个算法：<br><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"> <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Returns a power of two size for the given target capacity.</span></span><br><span class=\"line\"><span class=\"comment\">* 返回大于或等于 cap 的最小2次幂</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"title function_\">tableSizeFor</span><span class=\"params\">(<span class=\"type\">int</span> cap)</span> &#123;</span><br><span class=\"line\">     <span class=\"type\">int</span> <span class=\"variable\">n</span> <span class=\"operator\">=</span> cap - <span class=\"number\">1</span>;</span><br><span class=\"line\">     n |= n &gt;&gt;&gt; <span class=\"number\">1</span>;</span><br><span class=\"line\">     n |= n &gt;&gt;&gt; <span class=\"number\">2</span>;</span><br><span class=\"line\">     n |= n &gt;&gt;&gt; <span class=\"number\">4</span>;</span><br><span class=\"line\">     n |= n &gt;&gt;&gt; <span class=\"number\">8</span>;</span><br><span class=\"line\">     n |= n &gt;&gt;&gt; <span class=\"number\">16</span>;</span><br><span class=\"line\">     <span class=\"keyword\">return</span> (n &lt; <span class=\"number\">0</span>) ? <span class=\"number\">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class=\"number\">1</span>;</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure><br>第一眼看起来确实是一脸懵逼，通过只知道这是一个获取该数的<strong>大于或等于 cap 的最小2次幂</strong>，这么厉害，咋实现的呀？</p>\n<p><strong>1、数据在内存中如何存储？</strong></p>\n<p>我们知道”&lt;&lt;” 和 “&gt;&gt;” 分别代表 左移和右移位运算符号，表示 乘以2 和除以2（大多数时候适用），”&gt;&gt;&gt;”还是第一次见，这是代表什么意思呢？说到这里我们不得不去了解一下数据是如何存储在内存中的：</p>\n<p>在32位的计算机系统中，int型数据占几个字节？ 4字节。其中每个字节有8个比特位，表示二进制位，位是计算机内部数据储存的最小单位。这是所有编程语言学习者都知道的。也就是说 int类型在内存中有4*8 == 32个比特为 所以如果以整形数10为例，那么它在内存中完整存储的形式为：</p>\n<blockquote>\n<p>00000000 00000000 00000000 00001010 -&gt;对应 1x2^3+0x2^2+1x2^1+0x2^0 =10</p>\n</blockquote>\n<p>那么int类型表示最大的数是不是就是:</p>\n<blockquote>\n<p>11111111 11111111 11111111 11111111 -&gt;对应 1x2^31+1x2^30…1x2^1+1x2^0</p>\n</blockquote>\n<p>但为我们知道int类型的最大值为：2^31-1,显然上面的答案不是正确的。</p>\n<p>这是因为在所有被int类型占用的比特位中，左起第一个位（即最高位）就是符号位。int类型的符号位上，0表示正数，1表示负数。在32位操作系统下，其余后面31位是数值位。也就是说：</p>\n<blockquote>\n<p>11111111 11111111 11111111 11111111 所代表的数字为：1x2^<strong>30</strong>+1x2^29…1x2^1+1x2^0 的相反数为：-(2^31-1)</p>\n</blockquote>\n<p>这里需要注意的是，按原先的逻辑去理解的话</p>\n<blockquote>\n<p>00000000 00000000 00000000 00000000 为+0 </p>\n<p>10000000 00000000 00000000 00000000 为-0</p>\n</blockquote>\n<p>那他们表示的意义是一样的么？<br>实际上，在32位系统下int类型中，我们计算机已经强行规定了这种情况，数字0采用“+0”的表示方法，即 00000000 00000000 00000000 00000000；而“-0”这个特殊的数字被定义为了-2^31。</p>\n<p>因此我们看到32位系统下int类型的取值范围中，负数部分比正数部分多了一个数字，正数的最大取值是2^31-1，而负数的最小取值是-2^31。正数部分之所以要减去1，是因为被数字0占用了“+0”，而负数部分不需要用来表示0，因此原本的“-0”就用来表示-2^31这个数字。</p>\n<p><strong>2、位运算如何进行？</strong></p>\n<p>至此我们明白了数据在计算机中的存储形式，那位运算具体怎么运行的呢？<br>以10和-10为例，其二进制完整表示为：00000000 00000000 00000000 00001010 和 10000000 00000000 00000000 00001010 为了便于观察，我们取后面8位：00001010</p>\n<ul>\n<li>对于符号位移 </li>\n</ul>\n<p>例如将10的二进制向左移1位：那么变成 0001010 0 == 20 原先二进制数的第一位被移除，而最后一位被舍弃。将10的二进制向右移1位 原先二进制数最后一位被移除，第一位补0，则变成 000101 ==5</p>\n<p>如将-10的二进制向左移1位， 10000000 00000000 00000000 00001010则变成：</p>\n<blockquote>\n<p> 10000000 00000000 00000000 0010100 为-20</p>\n</blockquote>\n<p>如将-10的二进制向右移1位， 10000000 00000000 00000000 00001010则变成  ：</p>\n<blockquote>\n<p>注意这里多了一个0-&gt; 1 00000000 00000000 00000000 0000101 &lt;-注意这里少了位</p>\n</blockquote>\n<p><strong>也就是说符号移动，会保留原来的符号位，不会因为右移左移而带走符号位。</strong></p>\n<ul>\n<li>对于无符号位移 </li>\n</ul>\n<p><strong>相反无符号位移会不关注符号位。</strong><br>例如将-10向右无符号右移就会变成：</p>\n<blockquote>\n<p>010000000 00000000 00000000 0000101  变成了一个很大的正数了！！</p>\n</blockquote>\n<p>如果将-10无符号左移，则变成：</p>\n<blockquote>\n<p>00000000 00000000 00000000 00001010 = 20</p>\n</blockquote>\n<p>但是！！并没有无符号左移动这样一件事情！<br>跟右移运算不同的是，无符号左移和左移是一样的。因此java没有无符号左移运算。(&lt;&lt;&lt;和&lt;&lt;&lt;=将报错)</p>\n<p>因为无符号右移运算需要考虑符号位的右移，而符号位只存在于二进制表示的最左边，最右边没有。所以不用区分无符号左移和左移运算。</p>\n<p><strong>3、关于返回大于或等于 cap 的最小2次幂的算法</strong></p>\n<p>我们以传入10为例子</p>\n<img src=\"https://cdn.julis.wang/blog/img/a9a6035a8d949d27c7fdba39c694d9840c6.jpg\">\n<p>由这张图看起来，算法很容易懂了，其实最主要的是为了去让各个位从高到低 从0变成1或者维持1不变，这样就能找到该数最小的2次幂</p>\n<blockquote>\n<p>另外，需要注意一下的是，第一步  int n = cap - 1; 这个操作，执行这个操作的主要原因是为了防止在cap已经是2的n次幂的情况下，经过运算后得到的结果是cap的二倍的结果，例如如果n为l6，经过一系列运算之后，得到的结果是0001 1111，此时最后一步n+1 执行之后，就会返回32，有兴趣的可以自己进行尝试；</p>\n</blockquote>\n<p>参考来源：</p>\n<p><a href=\"https://blog.csdn.net/c10WTiybQ1Ye3/article/details/89411471\">https://blog.csdn.net/c10WTiybQ1Ye3/article/details/89411471</a><br><a href=\"https://www.jianshu.com/p/927009730809\">https://www.jianshu.com/p/927009730809</a></p>\n","cover":null,"images":["https://cdn.julis.wang/blog/img/a9a6035a8d949d27c7fdba39c694d9840c6.jpg"],"content":"<p>今天在HashMap的内部源码的时候，看到这样一个算法：<br><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"> <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Returns a power of two size for the given target capacity.</span></span><br><span class=\"line\"><span class=\"comment\">* 返回大于或等于 cap 的最小2次幂</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"title function_\">tableSizeFor</span><span class=\"params\">(<span class=\"type\">int</span> cap)</span> &#123;</span><br><span class=\"line\">     <span class=\"type\">int</span> <span class=\"variable\">n</span> <span class=\"operator\">=</span> cap - <span class=\"number\">1</span>;</span><br><span class=\"line\">     n |= n &gt;&gt;&gt; <span class=\"number\">1</span>;</span><br><span class=\"line\">     n |= n &gt;&gt;&gt; <span class=\"number\">2</span>;</span><br><span class=\"line\">     n |= n &gt;&gt;&gt; <span class=\"number\">4</span>;</span><br><span class=\"line\">     n |= n &gt;&gt;&gt; <span class=\"number\">8</span>;</span><br><span class=\"line\">     n |= n &gt;&gt;&gt; <span class=\"number\">16</span>;</span><br><span class=\"line\">     <span class=\"keyword\">return</span> (n &lt; <span class=\"number\">0</span>) ? <span class=\"number\">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class=\"number\">1</span>;</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure><br>第一眼看起来确实是一脸懵逼，通过只知道这是一个获取该数的<strong>大于或等于 cap 的最小2次幂</strong>，这么厉害，咋实现的呀？</p>\n<p><strong>1、数据在内存中如何存储？</strong></p>\n<p>我们知道”&lt;&lt;” 和 “&gt;&gt;” 分别代表 左移和右移位运算符号，表示 乘以2 和除以2（大多数时候适用），”&gt;&gt;&gt;”还是第一次见，这是代表什么意思呢？说到这里我们不得不去了解一下数据是如何存储在内存中的：</p>\n<p>在32位的计算机系统中，int型数据占几个字节？ 4字节。其中每个字节有8个比特位，表示二进制位，位是计算机内部数据储存的最小单位。这是所有编程语言学习者都知道的。也就是说 int类型在内存中有4*8 == 32个比特为 所以如果以整形数10为例，那么它在内存中完整存储的形式为：</p>\n<blockquote>\n<p>00000000 00000000 00000000 00001010 -&gt;对应 1x2^3+0x2^2+1x2^1+0x2^0 =10</p>\n</blockquote>\n<p>那么int类型表示最大的数是不是就是:</p>\n<blockquote>\n<p>11111111 11111111 11111111 11111111 -&gt;对应 1x2^31+1x2^30…1x2^1+1x2^0</p>\n</blockquote>\n<p>但为我们知道int类型的最大值为：2^31-1,显然上面的答案不是正确的。</p>\n<p>这是因为在所有被int类型占用的比特位中，左起第一个位（即最高位）就是符号位。int类型的符号位上，0表示正数，1表示负数。在32位操作系统下，其余后面31位是数值位。也就是说：</p>\n<blockquote>\n<p>11111111 11111111 11111111 11111111 所代表的数字为：1x2^<strong>30</strong>+1x2^29…1x2^1+1x2^0 的相反数为：-(2^31-1)</p>\n</blockquote>\n<p>这里需要注意的是，按原先的逻辑去理解的话</p>\n<blockquote>\n<p>00000000 00000000 00000000 00000000 为+0 </p>\n<p>10000000 00000000 00000000 00000000 为-0</p>\n</blockquote>\n<p>那他们表示的意义是一样的么？<br>实际上，在32位系统下int类型中，我们计算机已经强行规定了这种情况，数字0采用“+0”的表示方法，即 00000000 00000000 00000000 00000000；而“-0”这个特殊的数字被定义为了-2^31。</p>\n<p>因此我们看到32位系统下int类型的取值范围中，负数部分比正数部分多了一个数字，正数的最大取值是2^31-1，而负数的最小取值是-2^31。正数部分之所以要减去1，是因为被数字0占用了“+0”，而负数部分不需要用来表示0，因此原本的“-0”就用来表示-2^31这个数字。</p>\n<p><strong>2、位运算如何进行？</strong></p>\n<p>至此我们明白了数据在计算机中的存储形式，那位运算具体怎么运行的呢？<br>以10和-10为例，其二进制完整表示为：00000000 00000000 00000000 00001010 和 10000000 00000000 00000000 00001010 为了便于观察，我们取后面8位：00001010</p>\n<ul>\n<li>对于符号位移 </li>\n</ul>\n<p>例如将10的二进制向左移1位：那么变成 0001010 0 == 20 原先二进制数的第一位被移除，而最后一位被舍弃。将10的二进制向右移1位 原先二进制数最后一位被移除，第一位补0，则变成 000101 ==5</p>\n<p>如将-10的二进制向左移1位， 10000000 00000000 00000000 00001010则变成：</p>\n<blockquote>\n<p> 10000000 00000000 00000000 0010100 为-20</p>\n</blockquote>\n<p>如将-10的二进制向右移1位， 10000000 00000000 00000000 00001010则变成  ：</p>\n<blockquote>\n<p>注意这里多了一个0-&gt; 1 00000000 00000000 00000000 0000101 &lt;-注意这里少了位</p>\n</blockquote>\n<p><strong>也就是说符号移动，会保留原来的符号位，不会因为右移左移而带走符号位。</strong></p>\n<ul>\n<li>对于无符号位移 </li>\n</ul>\n<p><strong>相反无符号位移会不关注符号位。</strong><br>例如将-10向右无符号右移就会变成：</p>\n<blockquote>\n<p>010000000 00000000 00000000 0000101  变成了一个很大的正数了！！</p>\n</blockquote>\n<p>如果将-10无符号左移，则变成：</p>\n<blockquote>\n<p>00000000 00000000 00000000 00001010 = 20</p>\n</blockquote>\n<p>但是！！并没有无符号左移动这样一件事情！<br>跟右移运算不同的是，无符号左移和左移是一样的。因此java没有无符号左移运算。(&lt;&lt;&lt;和&lt;&lt;&lt;=将报错)</p>\n<p>因为无符号右移运算需要考虑符号位的右移，而符号位只存在于二进制表示的最左边，最右边没有。所以不用区分无符号左移和左移运算。</p>\n<p><strong>3、关于返回大于或等于 cap 的最小2次幂的算法</strong></p>\n<p>我们以传入10为例子</p>\n<img src=\"https://cdn.julis.wang/blog/img/a9a6035a8d949d27c7fdba39c694d9840c6.jpg\">\n<p>由这张图看起来，算法很容易懂了，其实最主要的是为了去让各个位从高到低 从0变成1或者维持1不变，这样就能找到该数最小的2次幂</p>\n<blockquote>\n<p>另外，需要注意一下的是，第一步  int n = cap - 1; 这个操作，执行这个操作的主要原因是为了防止在cap已经是2的n次幂的情况下，经过运算后得到的结果是cap的二倍的结果，例如如果n为l6，经过一系列运算之后，得到的结果是0001 1111，此时最后一步n+1 执行之后，就会返回32，有兴趣的可以自己进行尝试；</p>\n</blockquote>\n<p>参考来源：</p>\n<p><a href=\"https://blog.csdn.net/c10WTiybQ1Ye3/article/details/89411471\">https://blog.csdn.net/c10WTiybQ1Ye3/article/details/89411471</a><br><a href=\"https://www.jianshu.com/p/927009730809\">https://www.jianshu.com/p/927009730809</a></p>\n","categories":[{"name":"技术文章","slug":"technology","api":"api/categories/technology.json"}],"tags":[{"name":"算法","slug":"algorithm","api":"api/tags/algorithm.json"}],"api":"api/posts/2019/04/13/关于位运算和HashMap中一个求最小2次幂的算法.json"},{"title":"Java虚拟机类的加载机制","slug":"Java虚拟机类的加载机制","date":"2019-03-21T01:35:00.000Z","updated":"2025-05-20T11:46:57.000Z","comments":true,"url":"2019/03/21/Java虚拟机类的加载机制/","excerpt":"<p><strong>什么是虚拟机类的加载机制？</strong></p>\n<blockquote>\n<p>虚拟机把描述类的数据从class文件加载到内存，并对数据进行校验，转换，解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这就是虚拟机的类加载机制。</p>\n</blockquote>\n<p>类从加载到虚拟机的内存中开始，直到卸载出内存为止，整个生命周期为：</p>\n<ul>\n<li><p>加载（loading）</p>\n</li>\n<li><p>验证（verification）</p>\n</li>\n<li><p>准备(preparation)</p>\n</li>\n<li><p>解析(resolution)</p>\n</li>\n<li><p>初始化(initialization)</p>\n</li>\n<li><p>使用(using)</p>\n</li>\n<li><p>卸载（unloading）</p>\n</li>\n</ul>\n<p>其中 验证、准备、解析部分统称为连接</p>\n<img src=\"https://cdn.julis.wang/blog/img/6870166cdec78b95356d73621e32757829b.jpg\">\n<p>接下来依次讲解，各个步骤所做的事</p>\n<h2 id=\"第一部分-加载\"><a href=\"#第一部分-加载\" class=\"headerlink\" title=\"第一部分 加载\"></a><strong>第一部分 加载</strong></h2><hr>\n<p>“加载”是“类加载”的一个阶段，注意区分概念。类的加载由<strong>类加载器</strong>（后面介绍）加载主要完成三件事情：</p>\n<p><strong>1、通过一个类的全限定名来获取其定义的二进制字节流。</strong></p>\n<p><strong>2、将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。</strong></p>\n<p><strong>3、在Java堆中生成一个代表这个类的java.lang.Class对象，作为对方法区中这些数据的访问入口。</strong></p>\n<blockquote>\n<p>加载阶段完成后，虚拟机外部的二进制字节流将按照虚拟机所需的格式存储在方法区中，同时在内存中实例化一个java.lang.Class的实例对象。相对于HotSpot，这个实例对象比较特殊，虽然是一个对象，但并没有放置在堆中，而是放置在方法区中。这个对象将作为程序访问方法区中这些类数据的外部接口。</p>\n</blockquote>\n<h2 id=\"第二部分-验证\"><a href=\"#第二部分-验证\" class=\"headerlink\" title=\"第二部分 验证\"></a><strong>第二部分 验证</strong></h2><hr>\n<p>这一步主要是确保Class文件的字节流符合虚拟机的规范</p>\n<p>主要验证以下几个部分：</p>\n<p><strong>1、文件格式验证</strong><br>验证是否以魔数开头、主次版本号是否在当前虚拟机处理范围内…</p>\n<p>这一验证阶段主要是保证输入的字节流能正确地解析并存储与方法区内，格式上符合Java类型信息的要求。只有通过这个阶段，字节流才会进入内存的方法区中存储，后面的三个验证方式也都是给予方法区中的数据验证，不再会操作字节流。</p>\n<p><strong>2、元数据验证</strong>  验证这个类是否有父类、这个类是否继承了不允许继承的类…</p>\n<p>该阶段主要对类的元数据进行语义校验，保证符合java语言规范的元数据信息。</p>\n<p><strong>3、字节码验证</strong></p>\n<p>最复杂的一个阶段，主要目的是通过数据流和控制流分析，确定程序语义是否合法、符合逻辑。</p>\n<p><strong>4、符号引用验证</strong> </p>\n<p>这个阶段的校验发生在虚拟机将符号引用转化为直接引用的时候，这个转化动作发生在连接的解析阶段。目的是确保解析动作正常执行，如果无法通过验证，将抛出 IllegalAccessError、NoSuchFieldError、NoSuchMethodError等异常。</p>\n<h2 id=\"第三部分-准备\"><a href=\"#第三部分-准备\" class=\"headerlink\" title=\"第三部分 准备\"></a><strong>第三部分 准备</strong></h2><hr>\n<p>准备阶段是正式为类变量分配内存并设置<strong>类变量初始值</strong>的阶段，这些变量所实用的内存将在<strong>方法区</strong>中进行分配。</p>\n<p><strong>这时候的分配仅仅是类变量(staic修饰的变量)，而实例变量将会在对象实例化时随对象一起分配在Java对中。</strong></p>\n<p>假设一个类变量为：public static int count = 10;这时候会分配0，而不是10，分配10是在程序编译后。</p>\n<h2 id=\"第四部分-解析\"><a href=\"#第四部分-解析\" class=\"headerlink\" title=\"第四部分 解析\"></a><strong>第四部分 解析</strong></h2><hr>\n<p>解析阶段是虚拟机将常量池的符号引用替换为直接引用的阶段</p>\n<p><strong>1、类或者接口的的解析</strong></p>\n<p><strong>2、字段解析</strong></p>\n<p><strong>3、类方法解析</strong></p>\n<p><strong>4、接口方法解析</strong></p>\n<blockquote>\n<p><strong>符号引用</strong>与虚拟机实现的布局无关，引用的目标并不一定要已经加载到内存中。各种虚拟机实现的内存布局可以各不相同，但是它们能接受的符号引用必须是一致的，因为符号引用的字面量形式明确定义在Java虚拟机规范的Class文件格式中。</p>\n<p><strong>直接引用</strong>可以是指向目标的指针，相对偏移量或是一个能间接定位到目标的句柄。如果有了直接引用，那引用的目标必定已经在内存中存在。</p>\n</blockquote>\n<h2 id=\"第五部分-初始化\"><a href=\"#第五部分-初始化\" class=\"headerlink\" title=\"第五部分 初始化\"></a><strong>第五部分 初始化</strong></h2><hr>\n<p>在准备阶段，变量已经被分配赋值过初始值，在初始化阶段根据代码的逻辑初始化真实的变量和其他资源。</p>\n<h2 id=\"关于类加载器\"><a href=\"#关于类加载器\" class=\"headerlink\" title=\"关于类加载器\"></a><strong>关于类加载器</strong></h2><hr>\n<p><strong>什么是类加载器？</strong></p>\n<p>在“加载”阶段中，通过一个类的全限定名来获取其定义的二进制字节流。这一动作是放到了Java虚拟机外部去实现的，是为了方便让应用自己去决定如何获取所需要的类，实现这个动作的功能是常说的“类加载器（ClassLoader）”</p>\n<p>类加载器主要有三种：</p>\n<p><strong>1.启动类加载器(Bootstrap ClassLoader)</strong></p>\n<pre><code>负责加载&lt;JAVA_HOME&gt;\\lib\n</code></pre><p><strong>2.扩展类加载器(Exension ClassLoader)</strong></p>\n<pre><code>负责加载&lt;JAVA_HOME&gt;\\lib\\ext\n</code></pre><p><strong>3.应用程序类加载器(Applicaion ClassLoader)</strong></p>\n<pre><code>负责加载ClassPath上指定的类库\n</code></pre><p><strong>类加载器工作原理</strong></p>\n<p>介绍类加载器原理之前，必须得了解<strong>双亲委派模型</strong>(Parents Delegation Model)</p>\n<blockquote>\n<p>双亲委派模式的工作原理的是：如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行，如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器，如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载。</p>\n</blockquote>\n<img src=\"https://cdn.julis.wang/blog/img/853820dea41988382e4e0872063ec33315e.jpg\">\n<p>如图所示，这种层次结构关系被称为<strong>双亲委派模型</strong><br>以下为其实现代码，集中在java.lang.ClassLoader中的loadClass()方法中<br><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">protected</span> Class&lt;?&gt; loadClass(String name, <span class=\"type\">boolean</span> resolve)</span><br><span class=\"line\">      <span class=\"keyword\">throws</span> ClassNotFoundException</span><br><span class=\"line\">  \t&#123;</span><br><span class=\"line\">      <span class=\"keyword\">synchronized</span> (getClassLoadingLock(name)) &#123;</span><br><span class=\"line\">          <span class=\"comment\">// First, check if the class has already been loaded</span></span><br><span class=\"line\"><span class=\"comment\">//首先检查类是否被加载</span></span><br><span class=\"line\">          Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class=\"line\">          <span class=\"keyword\">if</span> (c == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">              <span class=\"type\">long</span> <span class=\"variable\">t0</span> <span class=\"operator\">=</span> System.nanoTime();</span><br><span class=\"line\">              <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                  <span class=\"keyword\">if</span> (parent != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">\t<span class=\"comment\">//如果有父加载器，则先委托父加载，否则由启动类加载器加载，如果启动类加载器没有找到，则返回null</span></span><br><span class=\"line\">                      c = parent.loadClass(name, <span class=\"literal\">false</span>);</span><br><span class=\"line\">                  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                      c = findBootstrapClassOrNull(name);</span><br><span class=\"line\">                  &#125;</span><br><span class=\"line\">              &#125; <span class=\"keyword\">catch</span> (ClassNotFoundException e) &#123;</span><br><span class=\"line\">                  <span class=\"comment\">// ClassNotFoundException thrown if class not found</span></span><br><span class=\"line\">                  <span class=\"comment\">// from the non-null parent class loader</span></span><br><span class=\"line\">\t<span class=\"comment\">//这里的ClassNotFoundException来自父加载器</span></span><br><span class=\"line\">              &#125;</span><br><span class=\"line\">              <span class=\"keyword\">if</span> (c == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">                  <span class=\"comment\">// If still not found, then invoke findClass in order</span></span><br><span class=\"line\">                  <span class=\"comment\">// to find the class.</span></span><br><span class=\"line\">\t<span class=\"comment\">//在父类Classloader还没办法加载的时候</span></span><br><span class=\"line\">\t<span class=\"comment\">//再调用本身的findclass方法来加载类</span></span><br><span class=\"line\">                  <span class=\"type\">long</span> <span class=\"variable\">t1</span> <span class=\"operator\">=</span> System.nanoTime();</span><br><span class=\"line\">                  c = findClass(name);</span><br><span class=\"line\">              &#125;</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">          <span class=\"keyword\">if</span> (resolve) &#123;</span><br><span class=\"line\">              resolveClass(c);</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">          <span class=\"keyword\">return</span> c;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure><br>代码的逻辑很清楚：</p>\n<blockquote>\n<p><strong>先加载类是否已经被加载过，若没有则调用父的loadClass()方法，如果父 类加载器为空，则使用启动类加载器作为父加载器，如果父 类加载器加载失败，再调用自己的findClass()方法进行加载</strong></p>\n</blockquote>\n","cover":null,"images":["https://cdn.julis.wang/blog/img/6870166cdec78b95356d73621e32757829b.jpg","https://cdn.julis.wang/blog/img/853820dea41988382e4e0872063ec33315e.jpg"],"content":"<p><strong>什么是虚拟机类的加载机制？</strong></p>\n<blockquote>\n<p>虚拟机把描述类的数据从class文件加载到内存，并对数据进行校验，转换，解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这就是虚拟机的类加载机制。</p>\n</blockquote>\n<p>类从加载到虚拟机的内存中开始，直到卸载出内存为止，整个生命周期为：</p>\n<ul>\n<li><p>加载（loading）</p>\n</li>\n<li><p>验证（verification）</p>\n</li>\n<li><p>准备(preparation)</p>\n</li>\n<li><p>解析(resolution)</p>\n</li>\n<li><p>初始化(initialization)</p>\n</li>\n<li><p>使用(using)</p>\n</li>\n<li><p>卸载（unloading）</p>\n</li>\n</ul>\n<p>其中 验证、准备、解析部分统称为连接</p>\n<img src=\"https://cdn.julis.wang/blog/img/6870166cdec78b95356d73621e32757829b.jpg\">\n<p>接下来依次讲解，各个步骤所做的事</p>\n<h2 id=\"第一部分-加载\"><a href=\"#第一部分-加载\" class=\"headerlink\" title=\"第一部分 加载\"></a><strong>第一部分 加载</strong></h2><hr>\n<p>“加载”是“类加载”的一个阶段，注意区分概念。类的加载由<strong>类加载器</strong>（后面介绍）加载主要完成三件事情：</p>\n<p><strong>1、通过一个类的全限定名来获取其定义的二进制字节流。</strong></p>\n<p><strong>2、将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。</strong></p>\n<p><strong>3、在Java堆中生成一个代表这个类的java.lang.Class对象，作为对方法区中这些数据的访问入口。</strong></p>\n<blockquote>\n<p>加载阶段完成后，虚拟机外部的二进制字节流将按照虚拟机所需的格式存储在方法区中，同时在内存中实例化一个java.lang.Class的实例对象。相对于HotSpot，这个实例对象比较特殊，虽然是一个对象，但并没有放置在堆中，而是放置在方法区中。这个对象将作为程序访问方法区中这些类数据的外部接口。</p>\n</blockquote>\n<h2 id=\"第二部分-验证\"><a href=\"#第二部分-验证\" class=\"headerlink\" title=\"第二部分 验证\"></a><strong>第二部分 验证</strong></h2><hr>\n<p>这一步主要是确保Class文件的字节流符合虚拟机的规范</p>\n<p>主要验证以下几个部分：</p>\n<p><strong>1、文件格式验证</strong><br>验证是否以魔数开头、主次版本号是否在当前虚拟机处理范围内…</p>\n<p>这一验证阶段主要是保证输入的字节流能正确地解析并存储与方法区内，格式上符合Java类型信息的要求。只有通过这个阶段，字节流才会进入内存的方法区中存储，后面的三个验证方式也都是给予方法区中的数据验证，不再会操作字节流。</p>\n<p><strong>2、元数据验证</strong>  验证这个类是否有父类、这个类是否继承了不允许继承的类…</p>\n<p>该阶段主要对类的元数据进行语义校验，保证符合java语言规范的元数据信息。</p>\n<p><strong>3、字节码验证</strong></p>\n<p>最复杂的一个阶段，主要目的是通过数据流和控制流分析，确定程序语义是否合法、符合逻辑。</p>\n<p><strong>4、符号引用验证</strong> </p>\n<p>这个阶段的校验发生在虚拟机将符号引用转化为直接引用的时候，这个转化动作发生在连接的解析阶段。目的是确保解析动作正常执行，如果无法通过验证，将抛出 IllegalAccessError、NoSuchFieldError、NoSuchMethodError等异常。</p>\n<h2 id=\"第三部分-准备\"><a href=\"#第三部分-准备\" class=\"headerlink\" title=\"第三部分 准备\"></a><strong>第三部分 准备</strong></h2><hr>\n<p>准备阶段是正式为类变量分配内存并设置<strong>类变量初始值</strong>的阶段，这些变量所实用的内存将在<strong>方法区</strong>中进行分配。</p>\n<p><strong>这时候的分配仅仅是类变量(staic修饰的变量)，而实例变量将会在对象实例化时随对象一起分配在Java对中。</strong></p>\n<p>假设一个类变量为：public static int count = 10;这时候会分配0，而不是10，分配10是在程序编译后。</p>\n<h2 id=\"第四部分-解析\"><a href=\"#第四部分-解析\" class=\"headerlink\" title=\"第四部分 解析\"></a><strong>第四部分 解析</strong></h2><hr>\n<p>解析阶段是虚拟机将常量池的符号引用替换为直接引用的阶段</p>\n<p><strong>1、类或者接口的的解析</strong></p>\n<p><strong>2、字段解析</strong></p>\n<p><strong>3、类方法解析</strong></p>\n<p><strong>4、接口方法解析</strong></p>\n<blockquote>\n<p><strong>符号引用</strong>与虚拟机实现的布局无关，引用的目标并不一定要已经加载到内存中。各种虚拟机实现的内存布局可以各不相同，但是它们能接受的符号引用必须是一致的，因为符号引用的字面量形式明确定义在Java虚拟机规范的Class文件格式中。</p>\n<p><strong>直接引用</strong>可以是指向目标的指针，相对偏移量或是一个能间接定位到目标的句柄。如果有了直接引用，那引用的目标必定已经在内存中存在。</p>\n</blockquote>\n<h2 id=\"第五部分-初始化\"><a href=\"#第五部分-初始化\" class=\"headerlink\" title=\"第五部分 初始化\"></a><strong>第五部分 初始化</strong></h2><hr>\n<p>在准备阶段，变量已经被分配赋值过初始值，在初始化阶段根据代码的逻辑初始化真实的变量和其他资源。</p>\n<h2 id=\"关于类加载器\"><a href=\"#关于类加载器\" class=\"headerlink\" title=\"关于类加载器\"></a><strong>关于类加载器</strong></h2><hr>\n<p><strong>什么是类加载器？</strong></p>\n<p>在“加载”阶段中，通过一个类的全限定名来获取其定义的二进制字节流。这一动作是放到了Java虚拟机外部去实现的，是为了方便让应用自己去决定如何获取所需要的类，实现这个动作的功能是常说的“类加载器（ClassLoader）”</p>\n<p>类加载器主要有三种：</p>\n<p><strong>1.启动类加载器(Bootstrap ClassLoader)</strong></p>\n<pre><code>负责加载&lt;JAVA_HOME&gt;\\lib\n</code></pre><p><strong>2.扩展类加载器(Exension ClassLoader)</strong></p>\n<pre><code>负责加载&lt;JAVA_HOME&gt;\\lib\\ext\n</code></pre><p><strong>3.应用程序类加载器(Applicaion ClassLoader)</strong></p>\n<pre><code>负责加载ClassPath上指定的类库\n</code></pre><p><strong>类加载器工作原理</strong></p>\n<p>介绍类加载器原理之前，必须得了解<strong>双亲委派模型</strong>(Parents Delegation Model)</p>\n<blockquote>\n<p>双亲委派模式的工作原理的是：如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行，如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器，如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载。</p>\n</blockquote>\n<img src=\"https://cdn.julis.wang/blog/img/853820dea41988382e4e0872063ec33315e.jpg\">\n<p>如图所示，这种层次结构关系被称为<strong>双亲委派模型</strong><br>以下为其实现代码，集中在java.lang.ClassLoader中的loadClass()方法中<br><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">protected</span> Class&lt;?&gt; loadClass(String name, <span class=\"type\">boolean</span> resolve)</span><br><span class=\"line\">      <span class=\"keyword\">throws</span> ClassNotFoundException</span><br><span class=\"line\">  \t&#123;</span><br><span class=\"line\">      <span class=\"keyword\">synchronized</span> (getClassLoadingLock(name)) &#123;</span><br><span class=\"line\">          <span class=\"comment\">// First, check if the class has already been loaded</span></span><br><span class=\"line\"><span class=\"comment\">//首先检查类是否被加载</span></span><br><span class=\"line\">          Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class=\"line\">          <span class=\"keyword\">if</span> (c == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">              <span class=\"type\">long</span> <span class=\"variable\">t0</span> <span class=\"operator\">=</span> System.nanoTime();</span><br><span class=\"line\">              <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                  <span class=\"keyword\">if</span> (parent != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">\t<span class=\"comment\">//如果有父加载器，则先委托父加载，否则由启动类加载器加载，如果启动类加载器没有找到，则返回null</span></span><br><span class=\"line\">                      c = parent.loadClass(name, <span class=\"literal\">false</span>);</span><br><span class=\"line\">                  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                      c = findBootstrapClassOrNull(name);</span><br><span class=\"line\">                  &#125;</span><br><span class=\"line\">              &#125; <span class=\"keyword\">catch</span> (ClassNotFoundException e) &#123;</span><br><span class=\"line\">                  <span class=\"comment\">// ClassNotFoundException thrown if class not found</span></span><br><span class=\"line\">                  <span class=\"comment\">// from the non-null parent class loader</span></span><br><span class=\"line\">\t<span class=\"comment\">//这里的ClassNotFoundException来自父加载器</span></span><br><span class=\"line\">              &#125;</span><br><span class=\"line\">              <span class=\"keyword\">if</span> (c == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">                  <span class=\"comment\">// If still not found, then invoke findClass in order</span></span><br><span class=\"line\">                  <span class=\"comment\">// to find the class.</span></span><br><span class=\"line\">\t<span class=\"comment\">//在父类Classloader还没办法加载的时候</span></span><br><span class=\"line\">\t<span class=\"comment\">//再调用本身的findclass方法来加载类</span></span><br><span class=\"line\">                  <span class=\"type\">long</span> <span class=\"variable\">t1</span> <span class=\"operator\">=</span> System.nanoTime();</span><br><span class=\"line\">                  c = findClass(name);</span><br><span class=\"line\">              &#125;</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">          <span class=\"keyword\">if</span> (resolve) &#123;</span><br><span class=\"line\">              resolveClass(c);</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">          <span class=\"keyword\">return</span> c;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure><br>代码的逻辑很清楚：</p>\n<blockquote>\n<p><strong>先加载类是否已经被加载过，若没有则调用父的loadClass()方法，如果父 类加载器为空，则使用启动类加载器作为父加载器，如果父 类加载器加载失败，再调用自己的findClass()方法进行加载</strong></p>\n</blockquote>\n","categories":[{"name":"技术文章","slug":"technology","api":"api/categories/technology.json"}],"tags":[{"name":"Java","slug":"java","api":"api/tags/java.json"}],"api":"api/posts/2019/03/21/Java虚拟机类的加载机制.json"},{"title":" Android中Handler使用导致的内存泄漏","slug":"Android中Handler使用导致的内存泄漏","date":"2019-03-18T01:37:00.000Z","updated":"2025-05-20T11:46:57.000Z","comments":true,"url":"2019/03/18/Android中Handler使用导致的内存泄漏/","excerpt":"<p><strong>1.什么是内存泄漏</strong></p>\n<p>用动态存储分配函数动态开辟的空间，在使用完毕后未被得到释放，结果一直占据该用内存单元，直到程序结束，即所谓的内存泄漏。</p>\n<p><strong>2.是内存泄漏与内存溢出的区别</strong></p>\n<p>内存溢出 Out of Memory，是指程序在申请内存时，没有足够的内存空间供其使用，出现out of memory；比如申请了一个integer,但给它存了long才能存下的数，那就是内存溢出。</p>\n<p>内存泄露 Memory Leak，是指程序在申请内存后，无法释放已申请的内存空间，一次内存泄露危害可以忽略，但内存泄露堆积后果很严重，无论多少内存,迟早会被占光。</p>\n<p>用一个很形象的例子来说明：一个仓库，被无用的物资所占据，而得不到管理员的清理，这里的无用货物占用仓库空间的行为被叫做”内存泄漏“，而某一天仓库由于所存储的物品太多，而无法继续存放物资，这个时候就被叫做“内存溢出”。</p>\n<p><strong>3.内存泄漏导致的问题</strong></p>\n<p>相关内存无法被系统给回收，随着程序运行可以用的内存会越来越少，机子越来越卡，直到内存溢出。（这也是为什么手机电脑很卡之后重启一下后会好很多，主要是相关未被系统回收的内存被回收）</p>\n<p><strong>4、安卓中的内存泄漏</strong></p>\n<p>典型的可能产生内存泄漏的代码：<br><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">MemoryLeakActivity</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">MyActivity</span> &#123;</span><br><span class=\"line\">   <span class=\"comment\">//可能会导致内存泄漏的代码</span></span><br><span class=\"line\">   <span class=\"keyword\">private</span> <span class=\"type\">Handler</span> <span class=\"variable\">handler</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Handler</span>() &#123;</span><br><span class=\"line\">       [<span class=\"meta\">@Override</span>](https:<span class=\"comment\">//my.oschina.net/u/1162528)</span></span><br><span class=\"line\">       <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">handleMessage</span><span class=\"params\">(Message msg)</span> &#123;</span><br><span class=\"line\">           <span class=\"built_in\">super</span>.handleMessage(msg);</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">   &#125;;&#125;</span><br></pre></td></tr></table></figure><br>产生内存泄漏可能的原因：Handler的工作机制中Handler与Looper以及MessageQueue一起工作的，App启动之后，系统会默认创建一个为主线程服务的Looper对象，负责处理主线程中所有的Message对象，它的生命周期则为整个应用的生命周期。在主线程使用Handler都会默认绑定到这个Looper上面，主线程创建Handler对象，会立即关联Looper对象的MessageQueue，这时发送MessageQueue重的Message会持有Handler的引用， 这样在Looper处理Message时候才会回调到Handler的handleMessage方法。因此，如果Message没有被处理完成，那么Handler对象就不会被垃圾回收。<br><img src=\"https://cdn.julis.wang/blog/img/6e154da75042608bc2e6e970e2452f7a857.jpg\"><br>上面的代码，将Handler的实例声明为MemoryLeakActivity类的内部类，在Java中：<strong>非静态内部匿名类会持有外部类的一个隐式引用，这样就可能导致外部类无法被垃圾回收。</strong></p>\n<p>最终由于MessageQueue中的Message 没有处理完成，就会持有Handler对象的引用，而非静态的Handler对象会持有外部类Activity的引用，这个activity无法被回收，从而导致内存泄漏。</p>\n<p><strong>5、解决方案</strong></p>\n<p>1、将Handler声明为静态内部类，这样就不会持有对外部类的引用。</p>\n<p>2、创建一个Looper与一般Java对象一样的生命周期</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> InnerHandler <span class=\"keyword\">extends</span> <span class=\"title class_\">Handler</span>&#123;       </span><br><span class=\"line\"> \t\t<span class=\"comment\">// 声明一个静态Handler类，并持有外部类引用</span></span><br><span class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">final</span> WeakReference&lt;MemoryLeakActivity&gt; mActivity;</span><br><span class=\"line\">       \t<span class=\"keyword\">public</span> <span class=\"title function_\">InnerHandler</span><span class=\"params\">(MemoryLeakActivity activity)</span>&#123;</span><br><span class=\"line\">          \t\t <span class=\"built_in\">this</span>.mActivity = <span class=\"keyword\">new</span> <span class=\"title class_\">WeakReference</span>&lt;MemoryLeakActivity&gt;(activity);</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>","cover":null,"images":["https://cdn.julis.wang/blog/img/6e154da75042608bc2e6e970e2452f7a857.jpg"],"content":"<p><strong>1.什么是内存泄漏</strong></p>\n<p>用动态存储分配函数动态开辟的空间，在使用完毕后未被得到释放，结果一直占据该用内存单元，直到程序结束，即所谓的内存泄漏。</p>\n<p><strong>2.是内存泄漏与内存溢出的区别</strong></p>\n<p>内存溢出 Out of Memory，是指程序在申请内存时，没有足够的内存空间供其使用，出现out of memory；比如申请了一个integer,但给它存了long才能存下的数，那就是内存溢出。</p>\n<p>内存泄露 Memory Leak，是指程序在申请内存后，无法释放已申请的内存空间，一次内存泄露危害可以忽略，但内存泄露堆积后果很严重，无论多少内存,迟早会被占光。</p>\n<p>用一个很形象的例子来说明：一个仓库，被无用的物资所占据，而得不到管理员的清理，这里的无用货物占用仓库空间的行为被叫做”内存泄漏“，而某一天仓库由于所存储的物品太多，而无法继续存放物资，这个时候就被叫做“内存溢出”。</p>\n<p><strong>3.内存泄漏导致的问题</strong></p>\n<p>相关内存无法被系统给回收，随着程序运行可以用的内存会越来越少，机子越来越卡，直到内存溢出。（这也是为什么手机电脑很卡之后重启一下后会好很多，主要是相关未被系统回收的内存被回收）</p>\n<p><strong>4、安卓中的内存泄漏</strong></p>\n<p>典型的可能产生内存泄漏的代码：<br><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">MemoryLeakActivity</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">MyActivity</span> &#123;</span><br><span class=\"line\">   <span class=\"comment\">//可能会导致内存泄漏的代码</span></span><br><span class=\"line\">   <span class=\"keyword\">private</span> <span class=\"type\">Handler</span> <span class=\"variable\">handler</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Handler</span>() &#123;</span><br><span class=\"line\">       [<span class=\"meta\">@Override</span>](https:<span class=\"comment\">//my.oschina.net/u/1162528)</span></span><br><span class=\"line\">       <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">handleMessage</span><span class=\"params\">(Message msg)</span> &#123;</span><br><span class=\"line\">           <span class=\"built_in\">super</span>.handleMessage(msg);</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">   &#125;;&#125;</span><br></pre></td></tr></table></figure><br>产生内存泄漏可能的原因：Handler的工作机制中Handler与Looper以及MessageQueue一起工作的，App启动之后，系统会默认创建一个为主线程服务的Looper对象，负责处理主线程中所有的Message对象，它的生命周期则为整个应用的生命周期。在主线程使用Handler都会默认绑定到这个Looper上面，主线程创建Handler对象，会立即关联Looper对象的MessageQueue，这时发送MessageQueue重的Message会持有Handler的引用， 这样在Looper处理Message时候才会回调到Handler的handleMessage方法。因此，如果Message没有被处理完成，那么Handler对象就不会被垃圾回收。<br><img src=\"https://cdn.julis.wang/blog/img/6e154da75042608bc2e6e970e2452f7a857.jpg\"><br>上面的代码，将Handler的实例声明为MemoryLeakActivity类的内部类，在Java中：<strong>非静态内部匿名类会持有外部类的一个隐式引用，这样就可能导致外部类无法被垃圾回收。</strong></p>\n<p>最终由于MessageQueue中的Message 没有处理完成，就会持有Handler对象的引用，而非静态的Handler对象会持有外部类Activity的引用，这个activity无法被回收，从而导致内存泄漏。</p>\n<p><strong>5、解决方案</strong></p>\n<p>1、将Handler声明为静态内部类，这样就不会持有对外部类的引用。</p>\n<p>2、创建一个Looper与一般Java对象一样的生命周期</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> InnerHandler <span class=\"keyword\">extends</span> <span class=\"title class_\">Handler</span>&#123;       </span><br><span class=\"line\"> \t\t<span class=\"comment\">// 声明一个静态Handler类，并持有外部类引用</span></span><br><span class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">final</span> WeakReference&lt;MemoryLeakActivity&gt; mActivity;</span><br><span class=\"line\">       \t<span class=\"keyword\">public</span> <span class=\"title function_\">InnerHandler</span><span class=\"params\">(MemoryLeakActivity activity)</span>&#123;</span><br><span class=\"line\">          \t\t <span class=\"built_in\">this</span>.mActivity = <span class=\"keyword\">new</span> <span class=\"title class_\">WeakReference</span>&lt;MemoryLeakActivity&gt;(activity);</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>","categories":[{"name":"技术文章","slug":"technology","api":"api/categories/technology.json"}],"tags":[{"name":"安卓","slug":"Android","api":"api/tags/Android.json"}],"api":"api/posts/2019/03/18/Android中Handler使用导致的内存泄漏.json"}],"info":{"type":"category","name":"技术文章","slug":"technology"}},"api":"api/categories/technology/page.4.json"}