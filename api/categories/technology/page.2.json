{"data":{"index":2,"total":4,"posts":[{"title":"Android音视频-初识FFmpeg","slug":"音视频-初识FFmpeg","date":"2021-11-14T01:49:00.000Z","updated":"2025-05-20T11:46:57.000Z","comments":true,"url":"2021/11/14/音视频-初识FFmpeg/","excerpt":"<p>已经很久没有写过技术博客了，这段时间加入了新公司，主要时间花在熟悉新业务的技术上。而新的业务主要跟音视频相关，关于音视频的尝试在加入新公司之前，自己有做相关demo的尝试与学习，可以参看<a href=\"https://github.com/VomPom/JProject/tree/master/app/src/main/java/wang/julis/jproject/example/media\">音视频相关学习demo</a>。当然，那都是自己“想当然”学习的一些东西，虽然实际工作中并没有派上太大的用处，但让我对音视频相关的基础知识有了一定的概念，对后面的技术尝试做了铺垫。第一个技术挑战比较大的就是进行：<strong>视频抽帧</strong>，关于视频抽帧网上有很多很多文章进行讲解，但……我始终没有找到一个效率很高的解决方案。直到我遇见了 ffmpeg，仿佛打开了新世界的大门……</p>\n<h2 id=\"关于FFmpeg\"><a href=\"#关于FFmpeg\" class=\"headerlink\" title=\"关于FFmpeg\"></a>关于FFmpeg</h2><p>刚接触 ffmpeg 时，我一脸懵逼，完全不知道该怎么做，也不知道在哪里开始进行学习，后来在<a href=\"https://blog.csdn.net/leixiaohua1020\">雷霄骅大神的博客</a>中渐渐找到了感觉，膜拜！不过雷神的博客代码是基于老版本的 ffmpeg api，推荐搭配<a href=\"https://github.com/FFmpeg/FFmpeg/tree/master/doc/examples\">官方example</a>，先跑通雷声的博客，再对照官方的例子对进行api相关接口的修改。</p>\n<p>当然，想要使用 ffmpeg编写代码之前，我们首先要做的是对 FFmpeg 进行so库编译，这一步也是难倒了众多的英雄好汉，引用<a href=\"https://juejin.cn/post/6844904039524597773\">FFmpeg so库编译</a>作者的话：</p>\n<blockquote>\n<p>为什么FFmpeg让人觉得很难搞？<br>我想主要是因为迈出第一步就很困难，连so库都编译不出来，后面的都是扯淡了。</p>\n</blockquote>\n<p>参考<a href=\"https://juejin.cn/post/6844904039524597773\">FFmpeg so库编译</a>文章能成功地打包出 ffmpeg.so，接下来就是添加在项目中运行。</p>\n<h2 id=\"踏上-FFmpeg-音视频之路\"><a href=\"#踏上-FFmpeg-音视频之路\" class=\"headerlink\" title=\"踏上 FFmpeg 音视频之路\"></a>踏上 FFmpeg 音视频之路</h2><p>关于音视频等开发，无论是做特效渲染还是做视频播放，那么最重要也是最基本的步骤就是：<strong>音视频解码</strong></p>\n<p>众所周知的是视频是由一帧帧视频帧(图片)&#x2F;音频帧编码组合而成</p>\n<p>视频解码要做的就是解码出视频文件中的每一帧，我们以:<strong>将视频转化为一帧帧的图片</strong>作为例进行学习。</p>\n<h2 id=\"FFmpeg-提取视频每一帧图像\"><a href=\"#FFmpeg-提取视频每一帧图像\" class=\"headerlink\" title=\"FFmpeg 提取视频每一帧图像\"></a>FFmpeg 提取视频每一帧图像</h2><p>在学习之前，我们思考一个问题：抛开 ffmpeg，如果让你去设计一个提取的代码，n你会怎么设计？</p>\n<p>因为视频是以文件流的形式存在，我相信很多人一上来就能想到这样的结构：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">while</span> (!EOF) &#123; <span class=\"comment\">//当文件流没有结束</span></span><br><span class=\"line\">    <span class=\"type\">Stream</span> <span class=\"variable\">stream</span> <span class=\"operator\">=</span> getStream(); <span class=\"comment\">//获取一定区域的stream</span></span><br><span class=\"line\">    <span class=\"type\">Frame</span> <span class=\"variable\">steam</span> <span class=\"operator\">=</span> getFrame(stream); <span class=\"comment\">//Stream转化为视频帧</span></span><br><span class=\"line\">    <span class=\"type\">Picture</span> <span class=\"variable\">picture</span> <span class=\"operator\">=</span> decodeFrame(steam); <span class=\"comment\">//将视频帧转化为 .jpeg等格式图片</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>的确是这样的，这里是给出一份ffmpeg提取视频帧图片的核心逻辑：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\">AVFrame frame = av_frame_alloc(); </span><br><span class=\"line\"><span class=\"keyword\">while</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (av_read_frame(fmt_ctx, &amp;avpkt) &gt;= <span class=\"number\">0</span>) &#123; <span class=\"comment\">// Return the next frame of a stream.</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (avpkt.stream_index == video_stream_index) &#123; <span class=\"comment\">//标识该AVPacket所属的视频/音频流。</span></span><br><span class=\"line\">            avcodec_send_packet(codeCtx, &amp;avpkt); <span class=\"comment\">//Supply raw packet data as input to a decoder.</span></span><br><span class=\"line\">            <span class=\"keyword\">while</span> (avcodec_receive_frame(codeCtx, frame) == <span class=\"number\">0</span>) &#123; <span class=\"comment\">//Return decoded output data from a decoder.</span></span><br><span class=\"line\">                <span class=\"built_in\">snprintf</span>(buf, <span class=\"keyword\">sizeof</span>(buf), <span class=\"string\">&quot;%s/frame-%d.jpg&quot;</span>, out_filename, frame_count);</span><br><span class=\"line\">                saveJpg(frame, buf);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            frame_count++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        av_packet_unref(&amp;avpkt);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        LOGE(<span class=\"string\">&quot;//Exit&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面的代码块就是 ffmpeg 进行视频解码最核心的逻辑了，主要的注释也贴在了代码上，完整代码请查看<a href=\"https://github.com/VomPom/FFmpegLearn/blob/main/app/src/main/cpp/func/video_to_jpeg.cpp\">video_to_jpeg.cpp</a>，查看完整的代码后，会感觉到很惊讶：为什么这么复杂？特别是前面的初始化操作。放心，ffmpeg就像一套组合拳，有固定不变的套路，写一次就足够了，了解了其中的流程，之后理解起来就会很容易了。</p>\n<p>上面的代码我们还可以做一些其他处理，比如只获取关键帧、查找指定时间戳位置的帧、视频按2s一帧进行抽取、视频不保存为jpeg文件转化为Java的bitmap？</p>\n<p>这些实现需求也都是基于上述核心模块进行修改：</p>\n<p>如果<strong>想只获取关键帧</strong>，可以利用<code>AVFrame</code>对象的属性<code>AVFrame-&gt;key_frame</code>进行判断。</p>\n<p><strong>查找指定时间戳位置的帧</strong>：利用 <code>av_seek_frame</code>查找到指定帧时间最近的关键帧，然后依次进行编码，直到<code>pts</code>与目标时间相近</p>\n<p><strong>视频按2s一帧进行抽取</strong>：简单的操作可以去获取视频fps，比如视频25fps，可以使用一个计数器判断<code>if(frame_count%25==0)</code>,这时候则是刚好1s。当然这样子性能不太好。如果需要追求性能，那么也可以利用<code>av_seek_frame</code>，查找目标时间附近，然后循环进行解码直到目标时间。</p>\n<p><strong>视频不保存为jpeg文件转化为Java的Bitmap</strong>：只需要对最终获取的 <code>AVFrame</code>做不一样的操作进行了，获取到对应的buffer，再利用jni调用构造 Java 的 bitmap 对象。</p>\n<p>可以做的还有很多……</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>提取视频图片这个功能只是 FFmpeg 强大功能的九牛一毛，需要探究的还有很多很多……</p>\n<p>如果能跑起来 FFmpeg 最简单的例子，已经迈出了很大一步了，但如果要理解其中的原理，还需要更多的基础知识，以及像<code>AVPacket</code>、<code>AVFrame</code>、 <code>AVCodec</code> ……每一个类的数据结构，以及实现都需要仔细研究。</p>\n<p>自己在网上找到的 FFmpeg 相关的教程，以及自己想要去实现的功能的资源太少，很多东西都需要自己去摸索。有时候我总在怀疑：<strong>为什么这么基础且很实用的功能没有现成的轮子？</strong> 这可能也是现在音视频相关开发的现状吧，成熟可用的轮子相对而言较少，以及相关技术的分享可能不太好做。既然没有，那就靠自己一点点积累吧。</p>\n<p>学习之路，任重而道远呐。</p>\n","cover":null,"images":[],"content":"<p>已经很久没有写过技术博客了，这段时间加入了新公司，主要时间花在熟悉新业务的技术上。而新的业务主要跟音视频相关，关于音视频的尝试在加入新公司之前，自己有做相关demo的尝试与学习，可以参看<a href=\"https://github.com/VomPom/JProject/tree/master/app/src/main/java/wang/julis/jproject/example/media\">音视频相关学习demo</a>。当然，那都是自己“想当然”学习的一些东西，虽然实际工作中并没有派上太大的用处，但让我对音视频相关的基础知识有了一定的概念，对后面的技术尝试做了铺垫。第一个技术挑战比较大的就是进行：<strong>视频抽帧</strong>，关于视频抽帧网上有很多很多文章进行讲解，但……我始终没有找到一个效率很高的解决方案。直到我遇见了 ffmpeg，仿佛打开了新世界的大门……</p>\n<h2 id=\"关于FFmpeg\"><a href=\"#关于FFmpeg\" class=\"headerlink\" title=\"关于FFmpeg\"></a>关于FFmpeg</h2><p>刚接触 ffmpeg 时，我一脸懵逼，完全不知道该怎么做，也不知道在哪里开始进行学习，后来在<a href=\"https://blog.csdn.net/leixiaohua1020\">雷霄骅大神的博客</a>中渐渐找到了感觉，膜拜！不过雷神的博客代码是基于老版本的 ffmpeg api，推荐搭配<a href=\"https://github.com/FFmpeg/FFmpeg/tree/master/doc/examples\">官方example</a>，先跑通雷声的博客，再对照官方的例子对进行api相关接口的修改。</p>\n<p>当然，想要使用 ffmpeg编写代码之前，我们首先要做的是对 FFmpeg 进行so库编译，这一步也是难倒了众多的英雄好汉，引用<a href=\"https://juejin.cn/post/6844904039524597773\">FFmpeg so库编译</a>作者的话：</p>\n<blockquote>\n<p>为什么FFmpeg让人觉得很难搞？<br>我想主要是因为迈出第一步就很困难，连so库都编译不出来，后面的都是扯淡了。</p>\n</blockquote>\n<p>参考<a href=\"https://juejin.cn/post/6844904039524597773\">FFmpeg so库编译</a>文章能成功地打包出 ffmpeg.so，接下来就是添加在项目中运行。</p>\n<h2 id=\"踏上-FFmpeg-音视频之路\"><a href=\"#踏上-FFmpeg-音视频之路\" class=\"headerlink\" title=\"踏上 FFmpeg 音视频之路\"></a>踏上 FFmpeg 音视频之路</h2><p>关于音视频等开发，无论是做特效渲染还是做视频播放，那么最重要也是最基本的步骤就是：<strong>音视频解码</strong></p>\n<p>众所周知的是视频是由一帧帧视频帧(图片)&#x2F;音频帧编码组合而成</p>\n<p>视频解码要做的就是解码出视频文件中的每一帧，我们以:<strong>将视频转化为一帧帧的图片</strong>作为例进行学习。</p>\n<h2 id=\"FFmpeg-提取视频每一帧图像\"><a href=\"#FFmpeg-提取视频每一帧图像\" class=\"headerlink\" title=\"FFmpeg 提取视频每一帧图像\"></a>FFmpeg 提取视频每一帧图像</h2><p>在学习之前，我们思考一个问题：抛开 ffmpeg，如果让你去设计一个提取的代码，n你会怎么设计？</p>\n<p>因为视频是以文件流的形式存在，我相信很多人一上来就能想到这样的结构：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">while</span> (!EOF) &#123; <span class=\"comment\">//当文件流没有结束</span></span><br><span class=\"line\">    <span class=\"type\">Stream</span> <span class=\"variable\">stream</span> <span class=\"operator\">=</span> getStream(); <span class=\"comment\">//获取一定区域的stream</span></span><br><span class=\"line\">    <span class=\"type\">Frame</span> <span class=\"variable\">steam</span> <span class=\"operator\">=</span> getFrame(stream); <span class=\"comment\">//Stream转化为视频帧</span></span><br><span class=\"line\">    <span class=\"type\">Picture</span> <span class=\"variable\">picture</span> <span class=\"operator\">=</span> decodeFrame(steam); <span class=\"comment\">//将视频帧转化为 .jpeg等格式图片</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>的确是这样的，这里是给出一份ffmpeg提取视频帧图片的核心逻辑：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\">AVFrame frame = av_frame_alloc(); </span><br><span class=\"line\"><span class=\"keyword\">while</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (av_read_frame(fmt_ctx, &amp;avpkt) &gt;= <span class=\"number\">0</span>) &#123; <span class=\"comment\">// Return the next frame of a stream.</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (avpkt.stream_index == video_stream_index) &#123; <span class=\"comment\">//标识该AVPacket所属的视频/音频流。</span></span><br><span class=\"line\">            avcodec_send_packet(codeCtx, &amp;avpkt); <span class=\"comment\">//Supply raw packet data as input to a decoder.</span></span><br><span class=\"line\">            <span class=\"keyword\">while</span> (avcodec_receive_frame(codeCtx, frame) == <span class=\"number\">0</span>) &#123; <span class=\"comment\">//Return decoded output data from a decoder.</span></span><br><span class=\"line\">                <span class=\"built_in\">snprintf</span>(buf, <span class=\"keyword\">sizeof</span>(buf), <span class=\"string\">&quot;%s/frame-%d.jpg&quot;</span>, out_filename, frame_count);</span><br><span class=\"line\">                saveJpg(frame, buf);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            frame_count++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        av_packet_unref(&amp;avpkt);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        LOGE(<span class=\"string\">&quot;//Exit&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面的代码块就是 ffmpeg 进行视频解码最核心的逻辑了，主要的注释也贴在了代码上，完整代码请查看<a href=\"https://github.com/VomPom/FFmpegLearn/blob/main/app/src/main/cpp/func/video_to_jpeg.cpp\">video_to_jpeg.cpp</a>，查看完整的代码后，会感觉到很惊讶：为什么这么复杂？特别是前面的初始化操作。放心，ffmpeg就像一套组合拳，有固定不变的套路，写一次就足够了，了解了其中的流程，之后理解起来就会很容易了。</p>\n<p>上面的代码我们还可以做一些其他处理，比如只获取关键帧、查找指定时间戳位置的帧、视频按2s一帧进行抽取、视频不保存为jpeg文件转化为Java的bitmap？</p>\n<p>这些实现需求也都是基于上述核心模块进行修改：</p>\n<p>如果<strong>想只获取关键帧</strong>，可以利用<code>AVFrame</code>对象的属性<code>AVFrame-&gt;key_frame</code>进行判断。</p>\n<p><strong>查找指定时间戳位置的帧</strong>：利用 <code>av_seek_frame</code>查找到指定帧时间最近的关键帧，然后依次进行编码，直到<code>pts</code>与目标时间相近</p>\n<p><strong>视频按2s一帧进行抽取</strong>：简单的操作可以去获取视频fps，比如视频25fps，可以使用一个计数器判断<code>if(frame_count%25==0)</code>,这时候则是刚好1s。当然这样子性能不太好。如果需要追求性能，那么也可以利用<code>av_seek_frame</code>，查找目标时间附近，然后循环进行解码直到目标时间。</p>\n<p><strong>视频不保存为jpeg文件转化为Java的Bitmap</strong>：只需要对最终获取的 <code>AVFrame</code>做不一样的操作进行了，获取到对应的buffer，再利用jni调用构造 Java 的 bitmap 对象。</p>\n<p>可以做的还有很多……</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>提取视频图片这个功能只是 FFmpeg 强大功能的九牛一毛，需要探究的还有很多很多……</p>\n<p>如果能跑起来 FFmpeg 最简单的例子，已经迈出了很大一步了，但如果要理解其中的原理，还需要更多的基础知识，以及像<code>AVPacket</code>、<code>AVFrame</code>、 <code>AVCodec</code> ……每一个类的数据结构，以及实现都需要仔细研究。</p>\n<p>自己在网上找到的 FFmpeg 相关的教程，以及自己想要去实现的功能的资源太少，很多东西都需要自己去摸索。有时候我总在怀疑：<strong>为什么这么基础且很实用的功能没有现成的轮子？</strong> 这可能也是现在音视频相关开发的现状吧，成熟可用的轮子相对而言较少，以及相关技术的分享可能不太好做。既然没有，那就靠自己一点点积累吧。</p>\n<p>学习之路，任重而道远呐。</p>\n","categories":[{"name":"技术文章","slug":"technology","api":"api/categories/technology.json"}],"tags":[{"name":"FFmpeg","slug":"FFmpeg","api":"api/tags/FFmpeg.json"}],"api":"api/posts/2021/11/14/音视频-初识FFmpeg.json"},{"title":"Android 逆向-反编译","slug":"Android-逆向-反编译","date":"2021-05-14T06:45:00.000Z","updated":"2025-05-20T11:46:57.000Z","comments":true,"url":"2021/05/14/Android-逆向-反编译/","excerpt":"<p>最近由于机缘巧合接触到了 Android 逆向相关的事情，经过一番探索，对其有了更深刻地认识，过程中遇到了了一些坑，或者一些有用的经验，分享并记录分析一下。在整个过程中使用的工具有：</p>\n<p><strong>反编译</strong>：dex2jar、CFR、jd-gui、</p>\n<p><strong>脱壳</strong>：VirtualApp、Xposed installer、FDex2</p>\n<p><strong>其他</strong>：IDA、VSCode、Total commander</p>\n<p>接下来咱们以两个具体情景，讲解整个逆向（静态代码分析）的流程，去分析两个 Apk 中相关页面的加密算法。</p>\n<p>在开发安卓应用的过程中，我们平时写得最多的代码就是 Java(以及Kotlin)，我们的逻辑也都在这一块，如果我们需要对应 apk 中代码逻辑，能直接看到这样的代码当然是最好不过的。要对相关 apk 中的代码逻辑进行分析，那么第一步便是需要对 apk 进行反编译，从而得到可以进行阅读理解的代码。</p>\n<h1 id=\"Apk的打包流程\"><a href=\"#Apk的打包流程\" class=\"headerlink\" title=\"Apk的打包流程\"></a>Apk的打包流程</h1><p>我们先对 安卓的打包流程进行一个简单的了解，从而明白.java文件 是一步步\b成为 apk中的一部分的，在生成 apk 的过程中主要包含以下流程，括号中代表使用的工具：</p>\n<p>1、打包资源文件，生成R.java文件 (aapt)</p>\n<p>2、处理aidl文件，生成相应的.java文件 (aidl)</p>\n<p>3、编译项目源代码，生成class文件 (javac)</p>\n<p>4、转换所有的class文件，生成classes.dex文件 (dx)</p>\n<p>5、编译过的资源和.dex文件都会被apkbuilder工具打包到最终的.apk文件中。 (apkbuilder)</p>\n<p>6、对APK文件进行签名 (jarsigner)</p>\n<p>7、对签名后的APK文件进行对齐处理 (zipalign)</p>\n<p>主要流程参考这张图：<br><img src=\"https://developer.android.com/images/tools/studio/build-process_2x.png\" alt=\"build-process_2x\"></p>\n<h1 id=\"反编译流程\"><a href=\"#反编译流程\" class=\"headerlink\" title=\"反编译流程\"></a>反编译流程</h1><p>在 apk的打包流程的步骤为：*(资源&#x2F;aidl等)-&gt; .java-&gt;.calss-&gt;.dex-&gt;.apk，反编译只需要对每个步骤反向进行。</p>\n<h2 id=\"apk-dex\"><a href=\"#apk-dex\" class=\"headerlink\" title=\".apk-&gt;.dex\"></a>.apk-&gt;.dex</h2><p>安卓安装包本质上是一个压缩文件，只需要对齐进行解压即可(Mac默认解压apk是)<br>解压获得以下文件：</p>\n<figure class=\"highlight text\"><table><tr><td class=\"code\"><pre><span class=\"line\">├── AndroidManifest.xml</span><br><span class=\"line\">├── META-INF</span><br><span class=\"line\">├── assets</span><br><span class=\"line\">├── classes.dex </span><br><span class=\"line\">├── classes2.dex</span><br><span class=\"line\">├── lib</span><br><span class=\"line\">├── okhttp3</span><br><span class=\"line\">├── org</span><br><span class=\"line\">├── r</span><br><span class=\"line\">└── resources.arsc</span><br></pre></td></tr></table></figure>\n\n<p>从目录结构得到两个.dex文件，这是由于在单个dex文件引用的方法总数不能超过65536（为什么？因为dex文件中的方法个数采用原生类型short来索引，而short是4个字节，4个字节最大数据存储量是65536），多数 app 超过了这一限制。</p>\n<h2 id=\"dex-class\"><a href=\"#dex-class\" class=\"headerlink\" title=\".dex-&gt;.class\"></a>.dex-&gt;.class</h2><p>这里我们需要利用工具 dex2jar</p>\n<blockquote>\n<p>d2j-dex2jar: Convert .dex file to .class files (zipped as jar)</p>\n</blockquote>\n<p>执行：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">sh /XXX/dex2jar-2.0/d2j-dex2jar.sh classes.dex </span><br></pre></td></tr></table></figure>\n\n<p>生成 classes-dex2jar.jar, 这个 jar 就是从classes.dex反编译出来的 .class集合。得到了这份 .jar我们已经可以开始使用 jd-gui进行查看了，这里吐槽一下jd-gui的搜索功能，搜索功能有限，纯字符串搜索是有问题的（或许是我版本不对），可以在 File&#x2F;Save all sources 将所有反编译好的文件进行保存，然后利用其他工具（例如VsCode）进行搜索。</p>\n<img src=\"https://cdn.julis.wang/blog/img/up-6ddc9f6e11b1cffd9cc5a2d8a5634d650f9.png\">\n\n<p>再看上面的代码，有一部分是 字节码，工具未能将它正常反编译，为什么呢？相关解释在<br><a href=\"https://www.zhihu.com/question/50140866\">https://www.zhihu.com/question/50140866</a> </p>\n<p>这里推荐使用 CFR,执行：</p>\n<figure class=\"highlight text\"><table><tr><td class=\"code\"><pre><span class=\"line\">java -jar /xxx/cfr-0.151.jar /xxx/classes-dex2jar.jar --outputdir /xxx/java</span><br></pre></td></tr></table></figure>\n\n<img src=\"https://cdn.julis.wang/blog/img/up-b876618b177cd018b2125221c34d0e94907.png\">\n<p>CFR对于 jd-gui 有更好的支持，那还要 jd-gui 干什么呢？在我看来 jd-gui 有一个最大的好处就是能像IDE那样可以点进进入方法内部，所以推荐两则结合起来使用。</p>\n<h2 id=\"so-反编译\"><a href=\"#so-反编译\" class=\"headerlink\" title=\".so 反编译\"></a>.so 反编译</h2><p>在追溯逻辑的过程中，可能会遇到有 native 方法，如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">native</span> <span class=\"type\">int</span> <span class=\"title function_\">dataFromNative</span><span class=\"params\">(<span class=\"type\">byte</span>[] param, <span class=\"type\">int</span> paramInt1, <span class=\"type\">int</span> paramInt2)</span>;</span><br></pre></td></tr></table></figure>\n\n<p>相关逻辑写在 c&#x2F;c++文件中，最终把打在.so库中，这时候就需要宇宙第一反汇编分析工具 IDA了，我们在 apk 解压后的 lib 中找到对应的 .so 文件（这里可能需要一点耐心，lib中大多是第三方的，可以很好通过 so 文件名找到开发者的 so文件）,利用 IDA F5 插件查看 汇编代码的伪代码。以字节某 SDK中的某段代码为例：</p>\n<img src=\"https://cdn.julis.wang/blog/img/up-a94ff19122e8fd51ac625f6888620e46ece.png\">\n<p>可以看到对应的逻辑，这时候就考验水平的时候了……<br>当然，IDA 是一个强大的工具，关于IDA的使用绝对不是通过查看一两篇博文就能熟练使用的，可以去查看<br><a href=\"https://www.amazon.com/IDA-Pro-Book-Unofficial-Disassembler/dp/1593272898\">《IDA Pro权威指南》</a></p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>1、当然上述流程只针对”正常App”，但在实际的 App 不会这样轻易的被反编译，App 可能还进行了加固，那我需要对其进行脱壳才能实现正确的反编译，这一内容放在另一章节再进行讲解。<br>2、反编译整个流程，如果没有加固，一般操作是：解压-&gt;class2jar 进行转jar-&gt;CFR&#x2F;jx-gui 反编译class，如果对逆向还有更多的操作还可以使用 apk_tool。相关流程已经在github 有开源的脚本了<a href=\"https://github.com/tp7309/TTDeDroid\">TTDeDroid</a>，有兴趣的同学可以去看看，但是我感觉有些复杂，我自己也写了一个脚本<a href=\"https://github.com/VomPom/Hack/tree/master/apk_reverse\">apk2dex2jar2class2java.sh</a></p>\n","cover":null,"images":["https://developer.android.com/images/tools/studio/build-process_2x.png","https://cdn.julis.wang/blog/img/up-6ddc9f6e11b1cffd9cc5a2d8a5634d650f9.png","https://cdn.julis.wang/blog/img/up-b876618b177cd018b2125221c34d0e94907.png","https://cdn.julis.wang/blog/img/up-a94ff19122e8fd51ac625f6888620e46ece.png"],"content":"<p>最近由于机缘巧合接触到了 Android 逆向相关的事情，经过一番探索，对其有了更深刻地认识，过程中遇到了了一些坑，或者一些有用的经验，分享并记录分析一下。在整个过程中使用的工具有：</p>\n<p><strong>反编译</strong>：dex2jar、CFR、jd-gui、</p>\n<p><strong>脱壳</strong>：VirtualApp、Xposed installer、FDex2</p>\n<p><strong>其他</strong>：IDA、VSCode、Total commander</p>\n<p>接下来咱们以两个具体情景，讲解整个逆向（静态代码分析）的流程，去分析两个 Apk 中相关页面的加密算法。</p>\n<p>在开发安卓应用的过程中，我们平时写得最多的代码就是 Java(以及Kotlin)，我们的逻辑也都在这一块，如果我们需要对应 apk 中代码逻辑，能直接看到这样的代码当然是最好不过的。要对相关 apk 中的代码逻辑进行分析，那么第一步便是需要对 apk 进行反编译，从而得到可以进行阅读理解的代码。</p>\n<h1 id=\"Apk的打包流程\"><a href=\"#Apk的打包流程\" class=\"headerlink\" title=\"Apk的打包流程\"></a>Apk的打包流程</h1><p>我们先对 安卓的打包流程进行一个简单的了解，从而明白.java文件 是一步步\b成为 apk中的一部分的，在生成 apk 的过程中主要包含以下流程，括号中代表使用的工具：</p>\n<p>1、打包资源文件，生成R.java文件 (aapt)</p>\n<p>2、处理aidl文件，生成相应的.java文件 (aidl)</p>\n<p>3、编译项目源代码，生成class文件 (javac)</p>\n<p>4、转换所有的class文件，生成classes.dex文件 (dx)</p>\n<p>5、编译过的资源和.dex文件都会被apkbuilder工具打包到最终的.apk文件中。 (apkbuilder)</p>\n<p>6、对APK文件进行签名 (jarsigner)</p>\n<p>7、对签名后的APK文件进行对齐处理 (zipalign)</p>\n<p>主要流程参考这张图：<br><img src=\"https://developer.android.com/images/tools/studio/build-process_2x.png\" alt=\"build-process_2x\"></p>\n<h1 id=\"反编译流程\"><a href=\"#反编译流程\" class=\"headerlink\" title=\"反编译流程\"></a>反编译流程</h1><p>在 apk的打包流程的步骤为：*(资源&#x2F;aidl等)-&gt; .java-&gt;.calss-&gt;.dex-&gt;.apk，反编译只需要对每个步骤反向进行。</p>\n<h2 id=\"apk-dex\"><a href=\"#apk-dex\" class=\"headerlink\" title=\".apk-&gt;.dex\"></a>.apk-&gt;.dex</h2><p>安卓安装包本质上是一个压缩文件，只需要对齐进行解压即可(Mac默认解压apk是)<br>解压获得以下文件：</p>\n<figure class=\"highlight text\"><table><tr><td class=\"code\"><pre><span class=\"line\">├── AndroidManifest.xml</span><br><span class=\"line\">├── META-INF</span><br><span class=\"line\">├── assets</span><br><span class=\"line\">├── classes.dex </span><br><span class=\"line\">├── classes2.dex</span><br><span class=\"line\">├── lib</span><br><span class=\"line\">├── okhttp3</span><br><span class=\"line\">├── org</span><br><span class=\"line\">├── r</span><br><span class=\"line\">└── resources.arsc</span><br></pre></td></tr></table></figure>\n\n<p>从目录结构得到两个.dex文件，这是由于在单个dex文件引用的方法总数不能超过65536（为什么？因为dex文件中的方法个数采用原生类型short来索引，而short是4个字节，4个字节最大数据存储量是65536），多数 app 超过了这一限制。</p>\n<h2 id=\"dex-class\"><a href=\"#dex-class\" class=\"headerlink\" title=\".dex-&gt;.class\"></a>.dex-&gt;.class</h2><p>这里我们需要利用工具 dex2jar</p>\n<blockquote>\n<p>d2j-dex2jar: Convert .dex file to .class files (zipped as jar)</p>\n</blockquote>\n<p>执行：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">sh /XXX/dex2jar-2.0/d2j-dex2jar.sh classes.dex </span><br></pre></td></tr></table></figure>\n\n<p>生成 classes-dex2jar.jar, 这个 jar 就是从classes.dex反编译出来的 .class集合。得到了这份 .jar我们已经可以开始使用 jd-gui进行查看了，这里吐槽一下jd-gui的搜索功能，搜索功能有限，纯字符串搜索是有问题的（或许是我版本不对），可以在 File&#x2F;Save all sources 将所有反编译好的文件进行保存，然后利用其他工具（例如VsCode）进行搜索。</p>\n<img src=\"https://cdn.julis.wang/blog/img/up-6ddc9f6e11b1cffd9cc5a2d8a5634d650f9.png\">\n\n<p>再看上面的代码，有一部分是 字节码，工具未能将它正常反编译，为什么呢？相关解释在<br><a href=\"https://www.zhihu.com/question/50140866\">https://www.zhihu.com/question/50140866</a> </p>\n<p>这里推荐使用 CFR,执行：</p>\n<figure class=\"highlight text\"><table><tr><td class=\"code\"><pre><span class=\"line\">java -jar /xxx/cfr-0.151.jar /xxx/classes-dex2jar.jar --outputdir /xxx/java</span><br></pre></td></tr></table></figure>\n\n<img src=\"https://cdn.julis.wang/blog/img/up-b876618b177cd018b2125221c34d0e94907.png\">\n<p>CFR对于 jd-gui 有更好的支持，那还要 jd-gui 干什么呢？在我看来 jd-gui 有一个最大的好处就是能像IDE那样可以点进进入方法内部，所以推荐两则结合起来使用。</p>\n<h2 id=\"so-反编译\"><a href=\"#so-反编译\" class=\"headerlink\" title=\".so 反编译\"></a>.so 反编译</h2><p>在追溯逻辑的过程中，可能会遇到有 native 方法，如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">native</span> <span class=\"type\">int</span> <span class=\"title function_\">dataFromNative</span><span class=\"params\">(<span class=\"type\">byte</span>[] param, <span class=\"type\">int</span> paramInt1, <span class=\"type\">int</span> paramInt2)</span>;</span><br></pre></td></tr></table></figure>\n\n<p>相关逻辑写在 c&#x2F;c++文件中，最终把打在.so库中，这时候就需要宇宙第一反汇编分析工具 IDA了，我们在 apk 解压后的 lib 中找到对应的 .so 文件（这里可能需要一点耐心，lib中大多是第三方的，可以很好通过 so 文件名找到开发者的 so文件）,利用 IDA F5 插件查看 汇编代码的伪代码。以字节某 SDK中的某段代码为例：</p>\n<img src=\"https://cdn.julis.wang/blog/img/up-a94ff19122e8fd51ac625f6888620e46ece.png\">\n<p>可以看到对应的逻辑，这时候就考验水平的时候了……<br>当然，IDA 是一个强大的工具，关于IDA的使用绝对不是通过查看一两篇博文就能熟练使用的，可以去查看<br><a href=\"https://www.amazon.com/IDA-Pro-Book-Unofficial-Disassembler/dp/1593272898\">《IDA Pro权威指南》</a></p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>1、当然上述流程只针对”正常App”，但在实际的 App 不会这样轻易的被反编译，App 可能还进行了加固，那我需要对其进行脱壳才能实现正确的反编译，这一内容放在另一章节再进行讲解。<br>2、反编译整个流程，如果没有加固，一般操作是：解压-&gt;class2jar 进行转jar-&gt;CFR&#x2F;jx-gui 反编译class，如果对逆向还有更多的操作还可以使用 apk_tool。相关流程已经在github 有开源的脚本了<a href=\"https://github.com/tp7309/TTDeDroid\">TTDeDroid</a>，有兴趣的同学可以去看看，但是我感觉有些复杂，我自己也写了一个脚本<a href=\"https://github.com/VomPom/Hack/tree/master/apk_reverse\">apk2dex2jar2class2java.sh</a></p>\n","categories":[{"name":"技术文章","slug":"technology","api":"api/categories/technology.json"}],"tags":[{"name":"Android","slug":"Android","api":"api/tags/Android.json"},{"name":"逆向","slug":"逆向","api":"api/tags/逆向.json"}],"api":"api/posts/2021/05/14/Android-逆向-反编译.json"},{"title":"Flutter FFI实践","slug":"FlutterFFI实践","date":"2021-04-18T02:34:00.000Z","updated":"2025-05-20T11:46:57.000Z","comments":true,"url":"2021/04/18/FlutterFFI实践/","excerpt":"<p>在 Android的开发中，我们有 <a href=\"https://developer.android.com/training/articles/perf-jni\">JNI</a> 使得 Java可以调用本地应用或库。<br>Flutter 在前不久发布了 <a href=\"https://developers.googleblog.com/2021/03/announcing-flutter-2.html\">Flutter2</a>，更新了 <a href=\"https://dart.dev/guides/libraries/c-interop\">FFI</a> (我们是否可以把它叫做DNI呢？)进入了稳定状态,开发者可以更安心的使用其功能。<br>但是相关的文档依然很欠缺，导致使用起来有诸多的疑问，以及相关原理性的介绍比较少，所以整理记录一下。</p>\n<h2 id=\"一、Dart-同步调用-Native-方法\"><a href=\"#一、Dart-同步调用-Native-方法\" class=\"headerlink\" title=\"一、Dart 同步调用 Native 方法\"></a>一、Dart 同步调用 Native 方法</h2><p>我们以最简单的demo为例,请求一个有参无返回值的C方法<br>在 C&#x2F;C++中有如下函数：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">extern</span> <span class=\"string\">&quot;C&quot;</span> __attribute__((visibility(<span class=\"string\">&quot;default&quot;</span>))) __attribute__((used))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">c_with_out_return_value</span><span class=\"params\">(<span class=\"type\">int</span> value)</span> &#123;</span><br><span class=\"line\">    LOG_D(<span class=\"string\">&quot;Got invoke value: %d&quot;</span>, value);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>Dart:</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">final</span> DynamicLibrary ffiLib = Platform.isAndroid ? DynamicLibrary.open(<span class=\"string\">&#x27;lib_invoke.so&#x27;</span>) : DynamicLibrary.process();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">final</span> cMethod = ffiLib.lookupFunction&lt;Void <span class=\"built_in\">Function</span>(Int32 value), <span class=\"keyword\">void</span> <span class=\"built_in\">Function</span>(<span class=\"built_in\">int</span> value)&gt;(<span class=\"string\">&#x27;c_with_out_return_value&#x27;</span>);</span><br><span class=\"line\">cMethod(<span class=\"number\">123</span>);  </span><br></pre></td></tr></table></figure>\n\n<p>这样一次调用就完成了一次调用，传递了123到Native并执行了一次打印，同理相关有参有返回值的请求也都是这样做到的，那 Dart 和 Native内部具体怎样实现的呢？</p>\n<p><code>DynamicLibrary.open()</code> 最终执行的逻辑如下, 源码位于<a href=\"https://github.com/dart-lang/sdk/blob/master/runtime/lib/ffi_dynamic_library.cc\">ffi_dynamic_library.cc</a>：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">void</span>* <span class=\"title function_\">LoadExtensionLibrary</span><span class=\"params\">(<span class=\"type\">const</span> <span class=\"type\">char</span>* library_file)</span> &#123;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">if</span> defined(HOST_OS_LINUX) || defined(HOST_OS_MACOS) ||                        \\</span></span><br><span class=\"line\"><span class=\"meta\">    defined(HOST_OS_ANDROID) || defined(HOST_OS_FUCHSIA)</span></span><br><span class=\"line\">  <span class=\"type\">void</span>* handle = dlopen(library_file, RTLD_LAZY);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (handle == nullptr) &#123;</span><br><span class=\"line\">    <span class=\"type\">char</span>* error = dlerror();</span><br><span class=\"line\">    <span class=\"type\">const</span> String&amp; msg = String::Handle(</span><br><span class=\"line\">        String::NewFormatted(<span class=\"string\">&quot;Failed to load dynamic library (%s)&quot;</span>, error));</span><br><span class=\"line\">    Exceptions::ThrowArgumentError(msg);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> handle;</span><br><span class=\"line\">  ……</span><br></pre></td></tr></table></figure>\n\n<p>可以看到最终使用 <a href=\"https://pubs.opengroup.org/onlinepubs/009696699/functions/dlopen.html\">dlopen</a> 加载动态链接库，并返回句柄。</p>\n<p>拿到对应的动态链接库的句柄之后，就能使用相关方法进行操作了。<br>句柄主要包含以下两个方法：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//在内存中查找对应符号名的地址，与dlsym()功能相同</span></span><br><span class=\"line\"><span class=\"keyword\">external</span> Pointer&lt;T&gt; lookup&lt;T <span class=\"keyword\">extends</span> NativeType&gt;(<span class=\"built_in\">String</span> symbolName);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//1、去动态库中查找对应名称的函数 </span></span><br><span class=\"line\"><span class=\"comment\">//2、将 Native 类型的 C/C++ 函数转化为 Dart 的 Function 类型</span></span><br><span class=\"line\"><span class=\"keyword\">external</span> F lookupFunction&lt;T <span class=\"keyword\">extends</span> <span class=\"built_in\">Function</span>, F <span class=\"keyword\">extends</span> <span class=\"built_in\">Function</span>&gt;(<span class=\"built_in\">String</span> symbolName);</span><br></pre></td></tr></table></figure>\n\n<p>其中lookup()的最终实现主要使用了 <a href=\"https://pubs.opengroup.org/onlinepubs/009695399/functions/dlsym.html\">dlsym</a></p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">void</span>* <span class=\"title function_\">ResolveSymbol</span><span class=\"params\">(<span class=\"type\">void</span>* handle, <span class=\"type\">const</span> <span class=\"type\">char</span>* symbol)</span> &#123;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">if</span> defined(HOST_OS_LINUX) || defined(HOST_OS_MACOS) ||                       </span></span><br><span class=\"line\">    defined(HOST_OS_ANDROID) || defined(HOST_OS_FUCHSIA)</span><br><span class=\"line\">  dlerror();  <span class=\"comment\">// Clear any errors.</span></span><br><span class=\"line\">  <span class=\"type\">void</span>* pointer = dlsym(handle, symbol);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (pointer == nullptr) &#123;</span><br><span class=\"line\">    <span class=\"type\">char</span>* error = dlerror();</span><br><span class=\"line\">    <span class=\"type\">const</span> String&amp; msg = String::Handle(</span><br><span class=\"line\">        String::NewFormatted(<span class=\"string\">&quot;Failed to lookup symbol (%s)&quot;</span>, error));</span><br><span class=\"line\">    Exceptions::ThrowArgumentError(msg);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> pointer;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"二、Dart-异步调用-Native-方法\"><a href=\"#二、Dart-异步调用-Native-方法\" class=\"headerlink\" title=\"二、Dart 异步调用 Native 方法\"></a>二、Dart 异步调用 Native 方法</h2><p>在很多场景我们不能像上述同步方法那样，dart 进行一次请求之后立马得到结果，可能会有一些耗时操作，为了不让 Flutter 的UI线程卡住，我们进行异步请求。那如何实现异步请求呢？<br>对于异步实现，官方并没有很明确的文档，都得靠自己琢磨，在官方的讨论中 <a href=\"https://github.com/dart-lang/sdk/issues/37022\">https://github.com/dart-lang/sdk/issues/37022</a> 以及 <a href=\"https://github.com/flutter/flutter/issues/63255\">https://github.com/flutter/flutter/issues/63255</a> 提到一些解决方案:</p>\n<blockquote>\n<p>1.In your C++ code include include&#x2F;dart_api_dl.h and include&#x2F;dart_api_dl.cc from here <a href=\"https://github.com/dart-lang/sdk/blob/master/runtime/include/\">https://github.com/dart-lang/sdk/blob/master/runtime/include/</a> (they also depend on include&#x2F;internal&#x2F;*).</p>\n<p>2.From Dart call Dart_InitializeApiDL passing NativeApi.initializeApiDLData as an argument.</p>\n<p>3.On Dart side create a ReceivePort and pass port number of the corresponding SendPort to the native side (port.sendPort.nativePort).</p>\n<p>4.Now on C++ side you can use Dart_PostCObject_DL to send messages back to Dart side from any thread.</p>\n</blockquote>\n<p>按上述的操作进行实现，接下来具体分析一些里面的逻辑原理。<br>1、导入include&#x2F;dart_api_dl.h include&#x2F;dart_api_dl.cc 相关的文件并在 CMakeList.txt进行相关配置<br>2、从dart中 调用Native中 Dart_InitializeApiDL</p>\n<p>Dart:</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> main() &#123;</span><br><span class=\"line\">  initializeApi(NativeApi.initializeApiDLData);</span><br><span class=\"line\">  runApp(MyApp());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>C++:</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Initialize `dart_api_dl.h`</span></span><br><span class=\"line\">DART_EXPORT <span class=\"type\">intptr_t</span> <span class=\"title function_\">InitDartApiDL</span><span class=\"params\">(<span class=\"type\">void</span> *data)</span> &#123;</span><br><span class=\"line\">    LOG_D(<span class=\"string\">&quot;InitDartApiDL&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> Dart_InitializeApiDL(data);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>在 initializeApi(NativeApi.initializeApiDLData) 中 initializeApi 向 Native请求 <code>DART_EXPORT intptr_t InitDartApiDL(void *data)</code>方法，传入的参数就是在 <a href=\"https://github.com/dart-lang/sdk/blob/master/runtime/include/dart_api_dl.h\">dart_api_dl.h</a><br> DART_NATIVE_API_DL_SYMBOLS 以及 DART_API_DL_SYMBOLS 中的方法。</p>\n<p>NativeApi.initializeApiDLData 逻辑：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">const</span> DartApiEntry dart_api_entries[] = &#123;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> ENTRY(name, R, A)                                                      \\</span></span><br><span class=\"line\"><span class=\"meta\">  DartApiEntry&#123;#name, reinterpret_cast<span class=\"string\">&lt;void (*)()&gt;</span>(name)&#125;,</span></span><br><span class=\"line\">    DART_API_ALL_DL_SYMBOLS(ENTRY)</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">undef</span> ENTRY</span></span><br><span class=\"line\">        DartApiEntry&#123;nullptr, nullptr&#125;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">const</span> DartApi dart_api_data = &#123;</span><br><span class=\"line\">    DART_API_DL_MAJOR_VERSION, DART_API_DL_MINOR_VERSION, dart_api_entries&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">DEFINE_NATIVE_ENTRY(DartApiDLInitializeData, <span class=\"number\">0</span>, <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> Integer::New(reinterpret_cast&lt;<span class=\"type\">intptr_t</span>&gt;(&amp;dart_api_data));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>dart_api_dl中定义的方法：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> DART_NATIVE_API_DL_SYMBOLS(F)                                          \\</span></span><br><span class=\"line\"><span class=\"meta\">  <span class=\"comment\">/***** dart_native_api.h *****/</span>                                              \\</span></span><br><span class=\"line\"><span class=\"meta\">  <span class=\"comment\">/* Dart_Port */</span>                                                              \\</span></span><br><span class=\"line\"><span class=\"meta\">  F(Dart_PostCObject, bool, (Dart_Port_DL port_id, Dart_CObject * message))    \\</span></span><br><span class=\"line\"><span class=\"meta\">  F(Dart_PostInteger, bool, (Dart_Port_DL port_id, int64_t message))           \\</span></span><br><span class=\"line\"><span class=\"meta\">  .....</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// dart_api.h symbols can only be called on Dart threads.</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> DART_API_DL_SYMBOLS(F)                                                 \\</span></span><br><span class=\"line\"><span class=\"meta\">  <span class=\"comment\">/***** dart_api.h *****/</span>                                                     \\</span></span><br><span class=\"line\"><span class=\"meta\">  <span class=\"comment\">/* Errors */</span>                                                                 \\</span></span><br><span class=\"line\"><span class=\"meta\">  F(Dart_IsError, bool, (Dart_Handle handle))                                  \\</span></span><br><span class=\"line\"><span class=\"meta\">  F(Dart_IsApiError, bool, (Dart_Handle handle))                               \\</span></span><br><span class=\"line\"><span class=\"meta\">  .....</span></span><br></pre></td></tr></table></figure>\n\n<p>其实这上面的逻辑很简单，主要是为了让业务中的代码能够进行动态链接，从而调用到 Flutter SDK 中相关方法。</p>\n<p>3、第三步添加 ReceivePort 监听</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Work</span> <span class=\"keyword\">extends</span> <span class=\"title\">Opaque</span> </span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">void</span> requestExecuteCallback(<span class=\"built_in\">dynamic</span> message) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">final</span> <span class=\"built_in\">int</span> workAddress = message <span class=\"keyword\">as</span> <span class=\"built_in\">int</span>;</span><br><span class=\"line\">  <span class=\"keyword\">final</span> Pointer&lt;Work&gt; work = Pointer&lt;Work&gt;.fromAddress(workAddress);</span><br><span class=\"line\">  executeCallback(work);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">final</span> ReceivePort interactiveCppRequests = ReceivePort()..listen(requestExecuteCallback);</span><br></pre></td></tr></table></figure>\n\n<p>向 Native 发送带有 interactiveCppRequests.sendPort.nativePort 的数据，为native异步回调做准备。</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">Future&lt;<span class=\"built_in\">int</span>&gt; platformAsync(<span class=\"built_in\">int</span> value1, <span class=\"built_in\">int</span> value2) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">final</span> Completer&lt;<span class=\"built_in\">int</span>&gt; completer = Completer&lt;<span class=\"built_in\">int</span>&gt;();</span><br><span class=\"line\">  <span class=\"keyword\">final</span> <span class=\"built_in\">String</span> cid = uuid.v1();</span><br><span class=\"line\">  <span class=\"keyword\">final</span> Pointer&lt;Utf8&gt; cidPtr = cid.toNativeUtf8();</span><br><span class=\"line\">  completerMapping[cid] = completer;</span><br><span class=\"line\">  <span class=\"comment\">//生成一个nativePort，为native异步回调做准备</span></span><br><span class=\"line\">  <span class=\"keyword\">final</span> <span class=\"built_in\">int</span> nativePort = interactiveCppRequests.sendPort.nativePort; </span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">final</span> cMethod = ffiLib.lookupFunction&lt;</span><br><span class=\"line\">      Int32 <span class=\"built_in\">Function</span>(Pointer&lt;Utf8&gt; cId, Int64 sendPort, Int32 value1, Int32 value2,</span><br><span class=\"line\">          Pointer&lt;NativeFunction&lt;callback_type&gt;&gt; callbackBlock),</span><br><span class=\"line\">      <span class=\"built_in\">int</span> <span class=\"built_in\">Function</span>(Pointer&lt;Utf8&gt; cId, <span class=\"built_in\">int</span> sendPort, <span class=\"built_in\">int</span> value1, <span class=\"built_in\">int</span> value2,</span><br><span class=\"line\">          Pointer&lt;NativeFunction&lt;callback_type&gt;&gt; callbackBlock)&gt;(<span class=\"string\">&#x27;platform_async&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  cMethod(cidPtr, nativePort, value1, value2, Pointer.fromFunction&lt;callback_type&gt;(_callbackBlocking));</span><br><span class=\"line\">  <span class=\"keyword\">return</span> completer.future;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>4、当异步执行完成之后，在 Native 执行 Dart_PostCObject_DL 通知 Dart 已经得到结果<br>对于代码如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">response</span><span class=\"params\">(jint result)</span> </span>&#123;</span><br><span class=\"line\">    Work work = [_callback,result] &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (_callback != <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">            _callback( result);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"built_in\">LOG_E</span>(<span class=\"string\">&quot;_callback == null&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    <span class=\"comment\">// Copy to heap to make it outlive the function scope.</span></span><br><span class=\"line\">    <span class=\"type\">const</span> Work *work_ptr = <span class=\"keyword\">new</span> <span class=\"built_in\">Work</span>(work);</span><br><span class=\"line\">    <span class=\"built_in\">NotifyDart</span>(send_port, work_ptr);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">NotifyDart</span><span class=\"params\">(Dart_Port send_port, <span class=\"type\">const</span> Work *work)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"type\">const</span> <span class=\"keyword\">auto</span> work_address = <span class=\"built_in\">reinterpret_cast</span>&lt;<span class=\"type\">intptr_t</span>&gt;(work);</span><br><span class=\"line\">    Dart_CObject dart_object;</span><br><span class=\"line\">    dart_object.type = Dart_CObject_kInt64;</span><br><span class=\"line\">    dart_object.value.as_int64 = work_address;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">const</span> <span class=\"type\">bool</span> result = <span class=\"built_in\">Dart_PostCObject_DL</span>(send_port, &amp;dart_object);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!result) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">LOG_D</span>(<span class=\"string\">&quot;FFI C  :  Posting message to port failed.&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面的代码最核心的就是<code>Dart_PostCObject_DL()</code>这里真正调用的还是，<code>Dart_PostCObject()</code>，加_DL()表示动态链接的方法，为了防止与原先符号冲突。</p>\n<blockquote>\n<p>All symbols are postfixed with _DL to indicate that they are dynamically</p>\n<p>linked and to prevent conflicts with the original symbol.</p>\n</blockquote>\n<p>我们继续看看  <code>Dart_PostCObject()</code>真正做了什么，Dart_PostCObject()最终调用的方法如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">bool</span> <span class=\"title function_\">PostCObjectHelper</span><span class=\"params\">(Dart_Port port_id, Dart_CObject* message)</span> &#123;</span><br><span class=\"line\">  ApiMessageWriter writer;</span><br><span class=\"line\">  <span class=\"built_in\">std</span>::<span class=\"built_in\">unique_ptr</span>&lt;Message&gt; msg =</span><br><span class=\"line\">      writer.WriteCMessage(message, port_id, Message::kNormalPriority);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (msg == nullptr) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Post the message at the given port.</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> PortMap::PostMessage(<span class=\"built_in\">std</span>::move(msg));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里在向 Service Isolate发送事件,最终 Dart 成功接受到异步消息的回调。<br>关于 Isolate 这一块的处理可以参考：<a href=\"https://medium.com/@codinghive.dev/async-coding-with-dart-isolates-b09c5ec00f8b\">Async Coding With Dart: Isolates</a></p>\n<h2 id=\"三、Native-调用-Dart方法\"><a href=\"#三、Native-调用-Dart方法\" class=\"headerlink\" title=\"三、Native 调用 Dart方法 ?\"></a>三、Native 调用 Dart方法 ?</h2><p>对于 JNI 里面，我们需要调用 Java的方法，利用Java反射机制调用即可，如下所示：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">_env-&gt;CallStaticVoidMethod(j_class, j_method, arg1, arg2);</span><br></pre></td></tr></table></figure>\n\n<p>如果 Native 想要调用 Dart代码有类似的代码可以用么？翻遍了 Flutter相关的文档，都没有找到对应的方法可以直接去调用 Dart的方法，Dart Engine内部有 <a href=\"https://github.com/dart-lang/sdk/blob/master/runtime/include/dart_api.h\">dart_api.h</a>提供了<code>Dart_invoke()</code>方法，但单纯的导入 .h文件在项目中是无法链接到对应的方法的，这也就是为什么需要导入<a href=\"https://github.com/dart-lang/sdk/tree/master/runtime/include\">ffi_runtime_lib</a>相关的文件并执行 <code>Dart_InitializeApiDL()</code>，通过动态链接使得代码能够去调用 Dart 封装的相关方法。</p>\n<p>所以参考 Dart中 <code>InitDartApiDL</code>的方法，我们先对 Dart 中的函数进行注册，传递对应方法的指针，然后在 Native 中即可调用，理论上可行，后续会补上相关  demo。<br>当然这只是一种骚操作，如果有更好的方法能够用 Native 调用 Dart 欢迎讨论。</p>\n<h2 id=\"四、总结\"><a href=\"#四、总结\" class=\"headerlink\" title=\"四、总结\"></a>四、总结</h2><p>文章记录了 Dart 同步和异步调用 Native 相关的使用，异步具体的使用比上述的代码复杂，因为需要一个中介记录异步相关的回调方法，当得到真正的结果之后，利用id查找到对应的方法再执行回调方法。FFI 在 Native中执行 dart 方法，暂时没有比较好的解决方案<br>FFI 调用可查看 <a href=\"https://github.com/VomPom/flutter_ffi_tutorial\">Demo flutter_ffi_tutorial</a></p>\n","cover":null,"images":[],"content":"<p>在 Android的开发中，我们有 <a href=\"https://developer.android.com/training/articles/perf-jni\">JNI</a> 使得 Java可以调用本地应用或库。<br>Flutter 在前不久发布了 <a href=\"https://developers.googleblog.com/2021/03/announcing-flutter-2.html\">Flutter2</a>，更新了 <a href=\"https://dart.dev/guides/libraries/c-interop\">FFI</a> (我们是否可以把它叫做DNI呢？)进入了稳定状态,开发者可以更安心的使用其功能。<br>但是相关的文档依然很欠缺，导致使用起来有诸多的疑问，以及相关原理性的介绍比较少，所以整理记录一下。</p>\n<h2 id=\"一、Dart-同步调用-Native-方法\"><a href=\"#一、Dart-同步调用-Native-方法\" class=\"headerlink\" title=\"一、Dart 同步调用 Native 方法\"></a>一、Dart 同步调用 Native 方法</h2><p>我们以最简单的demo为例,请求一个有参无返回值的C方法<br>在 C&#x2F;C++中有如下函数：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">extern</span> <span class=\"string\">&quot;C&quot;</span> __attribute__((visibility(<span class=\"string\">&quot;default&quot;</span>))) __attribute__((used))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">c_with_out_return_value</span><span class=\"params\">(<span class=\"type\">int</span> value)</span> &#123;</span><br><span class=\"line\">    LOG_D(<span class=\"string\">&quot;Got invoke value: %d&quot;</span>, value);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>Dart:</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">final</span> DynamicLibrary ffiLib = Platform.isAndroid ? DynamicLibrary.open(<span class=\"string\">&#x27;lib_invoke.so&#x27;</span>) : DynamicLibrary.process();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">final</span> cMethod = ffiLib.lookupFunction&lt;Void <span class=\"built_in\">Function</span>(Int32 value), <span class=\"keyword\">void</span> <span class=\"built_in\">Function</span>(<span class=\"built_in\">int</span> value)&gt;(<span class=\"string\">&#x27;c_with_out_return_value&#x27;</span>);</span><br><span class=\"line\">cMethod(<span class=\"number\">123</span>);  </span><br></pre></td></tr></table></figure>\n\n<p>这样一次调用就完成了一次调用，传递了123到Native并执行了一次打印，同理相关有参有返回值的请求也都是这样做到的，那 Dart 和 Native内部具体怎样实现的呢？</p>\n<p><code>DynamicLibrary.open()</code> 最终执行的逻辑如下, 源码位于<a href=\"https://github.com/dart-lang/sdk/blob/master/runtime/lib/ffi_dynamic_library.cc\">ffi_dynamic_library.cc</a>：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">void</span>* <span class=\"title function_\">LoadExtensionLibrary</span><span class=\"params\">(<span class=\"type\">const</span> <span class=\"type\">char</span>* library_file)</span> &#123;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">if</span> defined(HOST_OS_LINUX) || defined(HOST_OS_MACOS) ||                        \\</span></span><br><span class=\"line\"><span class=\"meta\">    defined(HOST_OS_ANDROID) || defined(HOST_OS_FUCHSIA)</span></span><br><span class=\"line\">  <span class=\"type\">void</span>* handle = dlopen(library_file, RTLD_LAZY);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (handle == nullptr) &#123;</span><br><span class=\"line\">    <span class=\"type\">char</span>* error = dlerror();</span><br><span class=\"line\">    <span class=\"type\">const</span> String&amp; msg = String::Handle(</span><br><span class=\"line\">        String::NewFormatted(<span class=\"string\">&quot;Failed to load dynamic library (%s)&quot;</span>, error));</span><br><span class=\"line\">    Exceptions::ThrowArgumentError(msg);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> handle;</span><br><span class=\"line\">  ……</span><br></pre></td></tr></table></figure>\n\n<p>可以看到最终使用 <a href=\"https://pubs.opengroup.org/onlinepubs/009696699/functions/dlopen.html\">dlopen</a> 加载动态链接库，并返回句柄。</p>\n<p>拿到对应的动态链接库的句柄之后，就能使用相关方法进行操作了。<br>句柄主要包含以下两个方法：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//在内存中查找对应符号名的地址，与dlsym()功能相同</span></span><br><span class=\"line\"><span class=\"keyword\">external</span> Pointer&lt;T&gt; lookup&lt;T <span class=\"keyword\">extends</span> NativeType&gt;(<span class=\"built_in\">String</span> symbolName);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//1、去动态库中查找对应名称的函数 </span></span><br><span class=\"line\"><span class=\"comment\">//2、将 Native 类型的 C/C++ 函数转化为 Dart 的 Function 类型</span></span><br><span class=\"line\"><span class=\"keyword\">external</span> F lookupFunction&lt;T <span class=\"keyword\">extends</span> <span class=\"built_in\">Function</span>, F <span class=\"keyword\">extends</span> <span class=\"built_in\">Function</span>&gt;(<span class=\"built_in\">String</span> symbolName);</span><br></pre></td></tr></table></figure>\n\n<p>其中lookup()的最终实现主要使用了 <a href=\"https://pubs.opengroup.org/onlinepubs/009695399/functions/dlsym.html\">dlsym</a></p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">void</span>* <span class=\"title function_\">ResolveSymbol</span><span class=\"params\">(<span class=\"type\">void</span>* handle, <span class=\"type\">const</span> <span class=\"type\">char</span>* symbol)</span> &#123;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">if</span> defined(HOST_OS_LINUX) || defined(HOST_OS_MACOS) ||                       </span></span><br><span class=\"line\">    defined(HOST_OS_ANDROID) || defined(HOST_OS_FUCHSIA)</span><br><span class=\"line\">  dlerror();  <span class=\"comment\">// Clear any errors.</span></span><br><span class=\"line\">  <span class=\"type\">void</span>* pointer = dlsym(handle, symbol);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (pointer == nullptr) &#123;</span><br><span class=\"line\">    <span class=\"type\">char</span>* error = dlerror();</span><br><span class=\"line\">    <span class=\"type\">const</span> String&amp; msg = String::Handle(</span><br><span class=\"line\">        String::NewFormatted(<span class=\"string\">&quot;Failed to lookup symbol (%s)&quot;</span>, error));</span><br><span class=\"line\">    Exceptions::ThrowArgumentError(msg);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> pointer;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"二、Dart-异步调用-Native-方法\"><a href=\"#二、Dart-异步调用-Native-方法\" class=\"headerlink\" title=\"二、Dart 异步调用 Native 方法\"></a>二、Dart 异步调用 Native 方法</h2><p>在很多场景我们不能像上述同步方法那样，dart 进行一次请求之后立马得到结果，可能会有一些耗时操作，为了不让 Flutter 的UI线程卡住，我们进行异步请求。那如何实现异步请求呢？<br>对于异步实现，官方并没有很明确的文档，都得靠自己琢磨，在官方的讨论中 <a href=\"https://github.com/dart-lang/sdk/issues/37022\">https://github.com/dart-lang/sdk/issues/37022</a> 以及 <a href=\"https://github.com/flutter/flutter/issues/63255\">https://github.com/flutter/flutter/issues/63255</a> 提到一些解决方案:</p>\n<blockquote>\n<p>1.In your C++ code include include&#x2F;dart_api_dl.h and include&#x2F;dart_api_dl.cc from here <a href=\"https://github.com/dart-lang/sdk/blob/master/runtime/include/\">https://github.com/dart-lang/sdk/blob/master/runtime/include/</a> (they also depend on include&#x2F;internal&#x2F;*).</p>\n<p>2.From Dart call Dart_InitializeApiDL passing NativeApi.initializeApiDLData as an argument.</p>\n<p>3.On Dart side create a ReceivePort and pass port number of the corresponding SendPort to the native side (port.sendPort.nativePort).</p>\n<p>4.Now on C++ side you can use Dart_PostCObject_DL to send messages back to Dart side from any thread.</p>\n</blockquote>\n<p>按上述的操作进行实现，接下来具体分析一些里面的逻辑原理。<br>1、导入include&#x2F;dart_api_dl.h include&#x2F;dart_api_dl.cc 相关的文件并在 CMakeList.txt进行相关配置<br>2、从dart中 调用Native中 Dart_InitializeApiDL</p>\n<p>Dart:</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> main() &#123;</span><br><span class=\"line\">  initializeApi(NativeApi.initializeApiDLData);</span><br><span class=\"line\">  runApp(MyApp());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>C++:</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Initialize `dart_api_dl.h`</span></span><br><span class=\"line\">DART_EXPORT <span class=\"type\">intptr_t</span> <span class=\"title function_\">InitDartApiDL</span><span class=\"params\">(<span class=\"type\">void</span> *data)</span> &#123;</span><br><span class=\"line\">    LOG_D(<span class=\"string\">&quot;InitDartApiDL&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> Dart_InitializeApiDL(data);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>在 initializeApi(NativeApi.initializeApiDLData) 中 initializeApi 向 Native请求 <code>DART_EXPORT intptr_t InitDartApiDL(void *data)</code>方法，传入的参数就是在 <a href=\"https://github.com/dart-lang/sdk/blob/master/runtime/include/dart_api_dl.h\">dart_api_dl.h</a><br> DART_NATIVE_API_DL_SYMBOLS 以及 DART_API_DL_SYMBOLS 中的方法。</p>\n<p>NativeApi.initializeApiDLData 逻辑：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">const</span> DartApiEntry dart_api_entries[] = &#123;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> ENTRY(name, R, A)                                                      \\</span></span><br><span class=\"line\"><span class=\"meta\">  DartApiEntry&#123;#name, reinterpret_cast<span class=\"string\">&lt;void (*)()&gt;</span>(name)&#125;,</span></span><br><span class=\"line\">    DART_API_ALL_DL_SYMBOLS(ENTRY)</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">undef</span> ENTRY</span></span><br><span class=\"line\">        DartApiEntry&#123;nullptr, nullptr&#125;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">const</span> DartApi dart_api_data = &#123;</span><br><span class=\"line\">    DART_API_DL_MAJOR_VERSION, DART_API_DL_MINOR_VERSION, dart_api_entries&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">DEFINE_NATIVE_ENTRY(DartApiDLInitializeData, <span class=\"number\">0</span>, <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> Integer::New(reinterpret_cast&lt;<span class=\"type\">intptr_t</span>&gt;(&amp;dart_api_data));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>dart_api_dl中定义的方法：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> DART_NATIVE_API_DL_SYMBOLS(F)                                          \\</span></span><br><span class=\"line\"><span class=\"meta\">  <span class=\"comment\">/***** dart_native_api.h *****/</span>                                              \\</span></span><br><span class=\"line\"><span class=\"meta\">  <span class=\"comment\">/* Dart_Port */</span>                                                              \\</span></span><br><span class=\"line\"><span class=\"meta\">  F(Dart_PostCObject, bool, (Dart_Port_DL port_id, Dart_CObject * message))    \\</span></span><br><span class=\"line\"><span class=\"meta\">  F(Dart_PostInteger, bool, (Dart_Port_DL port_id, int64_t message))           \\</span></span><br><span class=\"line\"><span class=\"meta\">  .....</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// dart_api.h symbols can only be called on Dart threads.</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> DART_API_DL_SYMBOLS(F)                                                 \\</span></span><br><span class=\"line\"><span class=\"meta\">  <span class=\"comment\">/***** dart_api.h *****/</span>                                                     \\</span></span><br><span class=\"line\"><span class=\"meta\">  <span class=\"comment\">/* Errors */</span>                                                                 \\</span></span><br><span class=\"line\"><span class=\"meta\">  F(Dart_IsError, bool, (Dart_Handle handle))                                  \\</span></span><br><span class=\"line\"><span class=\"meta\">  F(Dart_IsApiError, bool, (Dart_Handle handle))                               \\</span></span><br><span class=\"line\"><span class=\"meta\">  .....</span></span><br></pre></td></tr></table></figure>\n\n<p>其实这上面的逻辑很简单，主要是为了让业务中的代码能够进行动态链接，从而调用到 Flutter SDK 中相关方法。</p>\n<p>3、第三步添加 ReceivePort 监听</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Work</span> <span class=\"keyword\">extends</span> <span class=\"title\">Opaque</span> </span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">void</span> requestExecuteCallback(<span class=\"built_in\">dynamic</span> message) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">final</span> <span class=\"built_in\">int</span> workAddress = message <span class=\"keyword\">as</span> <span class=\"built_in\">int</span>;</span><br><span class=\"line\">  <span class=\"keyword\">final</span> Pointer&lt;Work&gt; work = Pointer&lt;Work&gt;.fromAddress(workAddress);</span><br><span class=\"line\">  executeCallback(work);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">final</span> ReceivePort interactiveCppRequests = ReceivePort()..listen(requestExecuteCallback);</span><br></pre></td></tr></table></figure>\n\n<p>向 Native 发送带有 interactiveCppRequests.sendPort.nativePort 的数据，为native异步回调做准备。</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">Future&lt;<span class=\"built_in\">int</span>&gt; platformAsync(<span class=\"built_in\">int</span> value1, <span class=\"built_in\">int</span> value2) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">final</span> Completer&lt;<span class=\"built_in\">int</span>&gt; completer = Completer&lt;<span class=\"built_in\">int</span>&gt;();</span><br><span class=\"line\">  <span class=\"keyword\">final</span> <span class=\"built_in\">String</span> cid = uuid.v1();</span><br><span class=\"line\">  <span class=\"keyword\">final</span> Pointer&lt;Utf8&gt; cidPtr = cid.toNativeUtf8();</span><br><span class=\"line\">  completerMapping[cid] = completer;</span><br><span class=\"line\">  <span class=\"comment\">//生成一个nativePort，为native异步回调做准备</span></span><br><span class=\"line\">  <span class=\"keyword\">final</span> <span class=\"built_in\">int</span> nativePort = interactiveCppRequests.sendPort.nativePort; </span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">final</span> cMethod = ffiLib.lookupFunction&lt;</span><br><span class=\"line\">      Int32 <span class=\"built_in\">Function</span>(Pointer&lt;Utf8&gt; cId, Int64 sendPort, Int32 value1, Int32 value2,</span><br><span class=\"line\">          Pointer&lt;NativeFunction&lt;callback_type&gt;&gt; callbackBlock),</span><br><span class=\"line\">      <span class=\"built_in\">int</span> <span class=\"built_in\">Function</span>(Pointer&lt;Utf8&gt; cId, <span class=\"built_in\">int</span> sendPort, <span class=\"built_in\">int</span> value1, <span class=\"built_in\">int</span> value2,</span><br><span class=\"line\">          Pointer&lt;NativeFunction&lt;callback_type&gt;&gt; callbackBlock)&gt;(<span class=\"string\">&#x27;platform_async&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  cMethod(cidPtr, nativePort, value1, value2, Pointer.fromFunction&lt;callback_type&gt;(_callbackBlocking));</span><br><span class=\"line\">  <span class=\"keyword\">return</span> completer.future;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>4、当异步执行完成之后，在 Native 执行 Dart_PostCObject_DL 通知 Dart 已经得到结果<br>对于代码如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">response</span><span class=\"params\">(jint result)</span> </span>&#123;</span><br><span class=\"line\">    Work work = [_callback,result] &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (_callback != <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">            _callback( result);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"built_in\">LOG_E</span>(<span class=\"string\">&quot;_callback == null&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    <span class=\"comment\">// Copy to heap to make it outlive the function scope.</span></span><br><span class=\"line\">    <span class=\"type\">const</span> Work *work_ptr = <span class=\"keyword\">new</span> <span class=\"built_in\">Work</span>(work);</span><br><span class=\"line\">    <span class=\"built_in\">NotifyDart</span>(send_port, work_ptr);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">NotifyDart</span><span class=\"params\">(Dart_Port send_port, <span class=\"type\">const</span> Work *work)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"type\">const</span> <span class=\"keyword\">auto</span> work_address = <span class=\"built_in\">reinterpret_cast</span>&lt;<span class=\"type\">intptr_t</span>&gt;(work);</span><br><span class=\"line\">    Dart_CObject dart_object;</span><br><span class=\"line\">    dart_object.type = Dart_CObject_kInt64;</span><br><span class=\"line\">    dart_object.value.as_int64 = work_address;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">const</span> <span class=\"type\">bool</span> result = <span class=\"built_in\">Dart_PostCObject_DL</span>(send_port, &amp;dart_object);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!result) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">LOG_D</span>(<span class=\"string\">&quot;FFI C  :  Posting message to port failed.&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面的代码最核心的就是<code>Dart_PostCObject_DL()</code>这里真正调用的还是，<code>Dart_PostCObject()</code>，加_DL()表示动态链接的方法，为了防止与原先符号冲突。</p>\n<blockquote>\n<p>All symbols are postfixed with _DL to indicate that they are dynamically</p>\n<p>linked and to prevent conflicts with the original symbol.</p>\n</blockquote>\n<p>我们继续看看  <code>Dart_PostCObject()</code>真正做了什么，Dart_PostCObject()最终调用的方法如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">bool</span> <span class=\"title function_\">PostCObjectHelper</span><span class=\"params\">(Dart_Port port_id, Dart_CObject* message)</span> &#123;</span><br><span class=\"line\">  ApiMessageWriter writer;</span><br><span class=\"line\">  <span class=\"built_in\">std</span>::<span class=\"built_in\">unique_ptr</span>&lt;Message&gt; msg =</span><br><span class=\"line\">      writer.WriteCMessage(message, port_id, Message::kNormalPriority);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (msg == nullptr) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Post the message at the given port.</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> PortMap::PostMessage(<span class=\"built_in\">std</span>::move(msg));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里在向 Service Isolate发送事件,最终 Dart 成功接受到异步消息的回调。<br>关于 Isolate 这一块的处理可以参考：<a href=\"https://medium.com/@codinghive.dev/async-coding-with-dart-isolates-b09c5ec00f8b\">Async Coding With Dart: Isolates</a></p>\n<h2 id=\"三、Native-调用-Dart方法\"><a href=\"#三、Native-调用-Dart方法\" class=\"headerlink\" title=\"三、Native 调用 Dart方法 ?\"></a>三、Native 调用 Dart方法 ?</h2><p>对于 JNI 里面，我们需要调用 Java的方法，利用Java反射机制调用即可，如下所示：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">_env-&gt;CallStaticVoidMethod(j_class, j_method, arg1, arg2);</span><br></pre></td></tr></table></figure>\n\n<p>如果 Native 想要调用 Dart代码有类似的代码可以用么？翻遍了 Flutter相关的文档，都没有找到对应的方法可以直接去调用 Dart的方法，Dart Engine内部有 <a href=\"https://github.com/dart-lang/sdk/blob/master/runtime/include/dart_api.h\">dart_api.h</a>提供了<code>Dart_invoke()</code>方法，但单纯的导入 .h文件在项目中是无法链接到对应的方法的，这也就是为什么需要导入<a href=\"https://github.com/dart-lang/sdk/tree/master/runtime/include\">ffi_runtime_lib</a>相关的文件并执行 <code>Dart_InitializeApiDL()</code>，通过动态链接使得代码能够去调用 Dart 封装的相关方法。</p>\n<p>所以参考 Dart中 <code>InitDartApiDL</code>的方法，我们先对 Dart 中的函数进行注册，传递对应方法的指针，然后在 Native 中即可调用，理论上可行，后续会补上相关  demo。<br>当然这只是一种骚操作，如果有更好的方法能够用 Native 调用 Dart 欢迎讨论。</p>\n<h2 id=\"四、总结\"><a href=\"#四、总结\" class=\"headerlink\" title=\"四、总结\"></a>四、总结</h2><p>文章记录了 Dart 同步和异步调用 Native 相关的使用，异步具体的使用比上述的代码复杂，因为需要一个中介记录异步相关的回调方法，当得到真正的结果之后，利用id查找到对应的方法再执行回调方法。FFI 在 Native中执行 dart 方法，暂时没有比较好的解决方案<br>FFI 调用可查看 <a href=\"https://github.com/VomPom/flutter_ffi_tutorial\">Demo flutter_ffi_tutorial</a></p>\n","categories":[{"name":"技术文章","slug":"technology","api":"api/categories/technology.json"}],"tags":[{"name":"Flutter","slug":"Flutter","api":"api/tags/Flutter.json"}],"api":"api/posts/2021/04/18/FlutterFFI实践.json"},{"title":"（转）JNI内存管理及优化","slug":"JNI内存管理及优化","date":"2021-03-10T12:08:00.000Z","updated":"2025-05-20T11:46:57.000Z","comments":true,"url":"2021/03/10/JNI内存管理及优化/","excerpt":"<p>最近接触JNI相关的项目遇到一些与内存相关到问题，JNI或者说是C&#x2F;C++开发与平时的Java开发相比，总会给人更多的“惊喜”，因为不熟悉native开发，所以有很多知识都不太清楚，一点一点地记录。<br>在掘金相关搜索到下面这篇，个人感觉还不错。<br>以下内容转载自：</p>\n<p><a href=\"https://juejin.cn/post/6844903743352209422\">https://juejin.cn/post/6844903743352209422</a></p>\n<img width=\"60%\" src=\"https://cdn.julis.wang/blog/img/167c522c1dfb148f.png\">\n<p>上面这张图大家都应该很熟了，下面只讲下和JNI有关的部分</p>\n<h4 id=\"程序计数器\"><a href=\"#程序计数器\" class=\"headerlink\" title=\"程序计数器\"></a>程序计数器</h4><p>记录正在执行的虚拟机字节码指令的地址（如果正在执行的是本地方法则为空）。</p>\n<h4 id=\"本地方法栈\"><a href=\"#本地方法栈\" class=\"headerlink\" title=\"本地方法栈\"></a>本地方法栈</h4><p>本地方法栈与 Java 虚拟机栈类似，它们之间的区别只不过是本地方法栈为本地方法服务。 本地方法一般是用其它语言（C、C++ 或汇编语言等）编写的，并且被编译为基于本机硬件和操作系统的程序，对待这些方法需要特别处理。</p>\n<h4 id=\"堆-Java-Heap\"><a href=\"#堆-Java-Heap\" class=\"headerlink\" title=\"堆(Java-Heap)\"></a>堆(Java-Heap)</h4><p>所有对象都在这里分配内存，是垃圾收集的主要区域（”GC 堆”）。 堆不需要连续内存，并且可以动态增加其内存，增加失败会抛出 OutOfMemoryError 异常。</p>\n<p>可以通过 -Xms 和 -Xmx 两个虚拟机参数来指定一个程序的堆内存大小，第一个参数设置初始值，第二个参数设置最大值。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">java -Xmx1024m -Xms1024m</span><br><span class=\"line\">//-Xmx1024m：设置JVM最大可用内存为1024M。</span><br><span class=\"line\">//-Xms1024m：设置JVM初始内存为1024m。此值可与-Xmx相同，以避免每次垃圾回收完成后JVM重新分配内存。</span><br></pre></td></tr></table></figure>\n\n<p>在Android系统对于每个应用都有内存使用的限制，机器的内存限制，在&#x2F;system&#x2F;build.prop文件中配置的。可以在manifest文件application节点加入 <code>android:largeHeap=&quot;true&quot;</code>来让Dalvik&#x2F;ART虚拟机分配更大的堆内存空间</p>\n<h4 id=\"直接内存（native堆）\"><a href=\"#直接内存（native堆）\" class=\"headerlink\" title=\"直接内存（native堆）\"></a>直接内存（native堆）</h4><p>也称为C-Heap，供Java Runtime进程使用的，没有相应的参数来控制其大小，其大小依赖于操作系统进程的最大值。  Java应用程序都是在Java Runtime Environment（JRE）中运行，而Runtime本身就是由Native语言（如：C&#x2F;C++）编写程序。Native Memory就是操作系统分配给Runtime进程的可用内存，它与Heap Memory不同，Java Heap 是Java应用程序的内存。。Native Memory的主要作用如下：</p>\n<ul>\n<li>管理java heap的状态数据（用于GC）;</li>\n<li>JNI调用，也就是Native Stack；</li>\n<li>JIT（即使编译器）编译时使用Native Memory，并且JIT的输入（Java字节码）和输出（可执行代码）也都是保存在Native Memory；</li>\n<li>NIO direct buffer；</li>\n<li>Threads；</li>\n<li>类加载器和类信息都是保存在Native Memory中的。</li>\n</ul>\n<h3 id=\"JNI内存\"><a href=\"#JNI内存\" class=\"headerlink\" title=\"JNI内存\"></a>JNI内存</h3><p>在Java代码中，Java对象被存放在JVM的Java Heap，由垃圾回收器（Garbage Collector，即GC）自动回收就可以。</p>\n<p> 在Native代码中，内存是从Native Memory中分配的，需要根据Native编程规范去操作内存。如：C&#x2F;C++使用malloc()&#x2F;new分配内存，需要手动使用free()&#x2F;delete回收内存。</p>\n<p> 然而，JNI和上面两者又有些区别。 JNI提供了与Java相对应的引用类型（如：jobject、jstring、jclass、jarray、jintArray等），以便Native代码可以通过JNI函数访问到Java对象。引用所指向的Java对象通常就是存放在Java Heap，而Native代码持有的引用是存放在Native Memory中。</p>\n<p>举个例子，如下代码：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\">jstring jstr = env-&gt;<span class=\"built_in\">NewStringUTF</span>(<span class=\"string\">&quot;Hello World!&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>jstring类型是JNI提供的，对应于Java的String类型</li>\n<li>JNI函数<code>NewStringUTF()</code>用于构造一个String对象，该对象存放在Java Heap中，同时返回了一个jstring类型的引用。</li>\n<li>String对象的引用保存在jstr中，jstr是Native的一个局部变量，存放在Native Memory中。</li>\n</ul>\n<p>开发人员都应该遇到过OOM（Out of Memory）异常，在JNI开发中，该异常可能发生在Java Heap中，也可能发生在Native Memory中。</p>\n<ul>\n<li>string类型是JNI提供的，对应于Java的String类型</li>\n<li>JNI函数<code>NewStringUTF()</code>用于构造一个String对象，该对象存放在Java Heap中，同时返回了一个jstring类型的引用。</li>\n<li>String对象的引用保存在jstr中，jstr是Native的一个局部变量，存放在Native Memory中。</li>\n</ul>\n<p>开发人员都应该遇到过OOM（Out of Memory）异常，在JNI开发中，该异常可能发生在Java Heap中，也可能发生在Native Memory中。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">java.lang.OutOfMemoryError: Java heap space</span><br><span class=\"line\">java.lang.OutOfMemoryError: native memory exhausted</span><br></pre></td></tr></table></figure>\n\n<p><strong>Java Heap 中出现 Out of Memory异常的原因有两种：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">1）程序过于庞大，致使过多 Java 对象的同时存在；</span><br><span class=\"line\">2）程序编写的错误导致 Java Heap 内存泄漏。</span><br></pre></td></tr></table></figure>\n\n<p><strong>Native Memory中出现 Out of Memory异常的原因：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">1）程序申请过多资源，系统未能满足，比如说大量线程资源；</span><br><span class=\"line\">2）程序编写的错误导致Native Memory内存泄漏。</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"JNI引用\"><a href=\"#JNI引用\" class=\"headerlink\" title=\"JNI引用\"></a>JNI引用</h3><p>JNI引用有三种：<code>Local Reference</code>、<code>Global Reference</code>、<code>Weak Global Reference</code>。下面分别来介绍一下这三种引用内存分配和管理。</p>\n<p><strong>Local Reference</strong></p>\n<p>只在Native Method执行时存在，只在创建它的线程有效，不能跨线程使用。它的生命期是在Native Method的执行期开始创建（从Java代码切换到Native代码环境时，或者在Native Method执行时调用JNI函数时），在Native Method执行完毕切换回Java代码时，所有Local Reference被删除（GC会回收其内存），生命期结束（调用<code>DeleteLocalRef()</code>可以提前回收内存，结束其生命期）。</p>\n<p> 实际上，每当线程从Java环境切换到Native代码环境时，JVM 会分配一块内存用于创建一个<code>Local Reference Table</code>，这个Table用来存放本次Native Method 执行中创建的所有<code>Local Reference</code>。每当在 Native代码中引用到一个Java对象时，JVM 就会在这个Table中创建一个<code>Local Reference</code>。比如，我们调用 NewStringUTF() 在 Java Heap 中创建一个 String 对象后，在 <code>Local Reference Table</code> 中就会相应新增一个 <code>Local Reference</code>。</p>\n<p>Local Reference 表、Local Reference 和 Java 对象的关系</p>\n<img src=\"https://cdn.julis.wang/blog/img/167c56e72c22fbe7.png\">\n<p>接下来举个简单例子说明一下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">jstring jstr = env-&gt;NewStringUTF(&quot;Hello World!&quot;);</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>jstr存放在Native Method Stack中，是一个局部变量</li>\n<li>对于开发者来说，Local Reference Table是不可见的</li>\n<li><code>Local Reference Table</code>的内存不大，所能存放<code>的Local Reference</code>数量也是有限的（在Android中默认最大容量是512个），使用不当就会引起溢出异常</li>\n<li><code>Local Reference</code>并不是Native里面的局部变量，局部变量存放在堆栈中，其引用存放在<code>Local Reference Table</code>中。</li>\n</ul>\n<p>在Native Method结束时，JVM会自动释放Local Reference，但<code>Local Reference Table</code>是有大小限制的，在开发中应该及时使用DeleteLocalRef()删除不必要的Local Reference，不然可能会出现溢出错误：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">JNI ERROR (app bug): local reference table overflow (max=512)</span><br></pre></td></tr></table></figure>\n\n<p>在C&#x2F;C++中实例化的JNI对象，如果不返回java，必须用release掉或delete，否则内存泄露。包括NewStringUTF，NewObject。对于一般的基本数据类型（如：jint，jdouble等），是没必要调用该函数删除掉的。如果返回java不必delete，java会自己回收。</p>\n<p><strong>Global Reference</strong></p>\n<p>Local Reference是在Native Method执行的时候出现的，而<code>Global Reference</code>是通过JNI函数<code>NewGlobalRef()</code>和<code>DeleteGlobalRef()</code>来创建和删除的。 <code>Global Reference</code>具有全局性，可以在多个Native Method调用过程和多线程中使用，在主动调用DeleteGlobalRef之前，它是一直有效的（GC不会回收其内存）。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 创建obj参数所引用对象的新全局引用。obj参数既可以是全局引用，也可以是局部引用。全局引用通过调用DeleteGlobalRef()来显式撤消。</span></span><br><span class=\"line\"><span class=\"comment\"> * @param obj 全局或局部引用。</span></span><br><span class=\"line\"><span class=\"comment\"> * @return 返回全局引用。如果系统内存不足则返回 NULL。</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\">jobject <span class=\"title function_\">NewGlobalRef</span><span class=\"params\">(jobject obj)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 删除globalRef所指向的全局引用</span></span><br><span class=\"line\"><span class=\"comment\"> * @param globalRef 全局引用</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">DeleteGlobalRef</span><span class=\"params\">(jobject globalRef)</span>;</span><br></pre></td></tr></table></figure>\n\n<p>使用 <code>Global reference</code>时，当 native code 不再需要访问<code>Global reference</code> 时，应当调用 JNI 函数 <code>DeleteGlobalRef()</code> 删除 <code>Global reference</code>和它引用的 Java 对象。否则<code>Global Reference</code>引用的 Java 对象将永远停留在 Java Heap 中，从而导致 Java Heap 的内存泄漏。</p>\n<p><strong>Weak Global Reference</strong></p>\n<p>用<code>NewWeakGlobalRef()</code>和<code>DeleteWeakGlobalRef()</code>进行创建和删除，它与<code>Global Reference</code>的区别在于该类型的引用随时都可能被GC回收。</p>\n<p>对<code>于Weak Global Reference</code>而言，可以通过<code>isSameObject()</code>将其与NULL比较，看看是否已经被回收了。如果返回JNI_TRUE，则表示已经被回收了，需要重新初始化弱全局引用。<code>Weak Global Reference</code>的回收时机是不确定的，有可能在前一行代码判断它是可用的，后一行代码就被GC回收掉了。为了避免这事事情发生，JNI官方给出了正确的做法，通过NewLocalRef()获取<code>Weak Global Reference</code>，避免被GC回收。</p>\n<h3 id=\"注意点\"><a href=\"#注意点\" class=\"headerlink\" title=\"注意点\"></a>注意点</h3><h4 id=\"Local-Reference-不是-native-code-的局部变量\"><a href=\"#Local-Reference-不是-native-code-的局部变量\" class=\"headerlink\" title=\"Local Reference 不是 native code 的局部变量\"></a>Local Reference 不是 native code 的局部变量</h4><p>很多人会误将 JNI 中的 Local Reference 理解为 Native Code 的局部变量。这是错误的。</p>\n<p>Native Code 的局部变量和 Local Reference 是完全不同的，区别可以总结为：</p>\n<p>⑴局部变量存储在线程堆栈中，而 Local Reference 存储在 Local Ref 表中。</p>\n<p>⑵局部变量在函数退栈后被删除，而 Local Reference 在调用 DeleteLocalRef() 后才会从 Local Ref 表中删除，并且失效，或者在整个 Native Method 执行结束后被删除。</p>\n<p>⑶可以在代码中直接访问局部变量，而 Local Reference 的内容无法在代码中直接访问，必须通过 JNI function 间接访问。JNI function 实现了对 Local Reference 的间接访问，JNI function 的内部实现依赖于具体 JVM。</p>\n<h4 id=\"注意释放所有对jobject的引用：\"><a href=\"#注意释放所有对jobject的引用：\" class=\"headerlink\" title=\"注意释放所有对jobject的引用：\"></a>注意释放所有对jobject的引用：</h4><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">extern</span> <span class=\"string\">&quot;C&quot;</span></span><br><span class=\"line\">JNIEXPORT jstring JNICALL</span><br><span class=\"line\"><span class=\"title function_\">Java_com_test_application_MainActivity_init</span><span class=\"params\">(JNIEnv *env, jobject instance, jstring data,</span></span><br><span class=\"line\"><span class=\"params\">                                      jbyteArray <span class=\"built_in\">array</span>)</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">int</span> len = env-&gt;GetArrayLength(<span class=\"built_in\">array</span>);</span><br><span class=\"line\">    <span class=\"type\">const</span> <span class=\"type\">char</span> *utfChars = env-&gt;GetStringUTFChars(data, <span class=\"number\">0</span>);</span><br><span class=\"line\">    jbyte *arrayElements = env-&gt;GetByteArrayElements(<span class=\"built_in\">array</span>, <span class=\"literal\">NULL</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    jstring pJstring = env-&gt;NewStringUTF(utfChars); </span><br><span class=\"line\"></span><br><span class=\"line\">    jbyteArray jpicArray = env-&gt;NewByteArray(len);</span><br><span class=\"line\">    env-&gt;SetByteArrayRegion(jpicArray, <span class=\"number\">0</span>, len, arrayElements);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// TODO</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    env-&gt;DeleteLocalRef(pJstring);</span><br><span class=\"line\">    env-&gt;DeleteLocalRef(jpicArray);</span><br><span class=\"line\"></span><br><span class=\"line\">    env-&gt;ReleaseStringUTFChars(data, utfChars);</span><br><span class=\"line\">    env-&gt;ReleaseByteArrayElements(<span class=\"built_in\">array</span>, arrayElements, <span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> hello = <span class=\"string\">&quot;Hello from C++&quot;</span>;</span><br><span class=\"line\">    jstring result = env-&gt;NewStringUTF(hello.c_str());</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>其它的还有：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">jclass ref= (env)-&gt;FindClass(&quot;java/lang/String&quot;);</span><br><span class=\"line\"> </span><br><span class=\"line\">env-&gt;DeleteLocalRef(ref);</span><br><span class=\"line\">复制代码</span><br></pre></td></tr></table></figure>\n\n<p>因为根据<code>jni.h</code>里的定义：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> jobject         jclass;</span><br></pre></td></tr></table></figure>\n\n<p>jclass也是jobject。而<code>jmethodID</code>&#x2F;<code>jfielID</code>和jobject没有继承关系，它们不是object,只是个整数，不存在被释放与否的问题。</p>\n<h4 id=\"局部引用和全局引用的转换\"><a href=\"#局部引用和全局引用的转换\" class=\"headerlink\" title=\"局部引用和全局引用的转换\"></a>局部引用和全局引用的转换</h4><p>注意Local Reference的生命周期，如果在Native中需要长时间持有一个Java对象，就不能使用将jobject存储在Native，否则在下次使用的时候，即使同一个线程调用，也将会无法使用。下面是错误的做法：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\">jstring global;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">extern</span> <span class=\"string\">&quot;C&quot;</span> JNIEXPORT jstring JNICALL</span><br><span class=\"line\"><span class=\"title function_\">Java_org_hik_libyuv_MainActivity_stringFromJNI</span><span class=\"params\">(</span></span><br><span class=\"line\"><span class=\"params\">        JNIEnv *env,</span></span><br><span class=\"line\"><span class=\"params\">        jobject <span class=\"comment\">/* this */</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> hello = <span class=\"string\">&quot;Hello from C++&quot;</span>;</span><br><span class=\"line\">    jstring local = env-&gt;NewStringUTF(hello.c_str());</span><br><span class=\"line\">    global = local;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> local;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>正确的做法是使用Global Reference，如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\">jstring global;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">extern</span> <span class=\"string\">&quot;C&quot;</span> JNIEXPORT jstring JNICALL</span><br><span class=\"line\"><span class=\"title function_\">Java_org_hik_libyuv_MainActivity_stringFromJNI</span><span class=\"params\">(</span></span><br><span class=\"line\"><span class=\"params\">        JNIEnv *env,</span></span><br><span class=\"line\"><span class=\"params\">        jobject <span class=\"comment\">/* this */</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> hello = <span class=\"string\">&quot;Hello from C++&quot;</span>;</span><br><span class=\"line\">    jstring local = env-&gt;NewStringUTF(hello.c_str());</span><br><span class=\"line\">    global = static_cast&lt;jstring&gt;(env-&gt;NewGlobalRef(global));</span><br><span class=\"line\">    <span class=\"keyword\">return</span> local;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"多线程\"><a href=\"#多线程\" class=\"headerlink\" title=\"多线程\"></a>多线程</h4><p>JNIEnv和jobject对象都不能跨线程使用。 对于jobject，解决办法是</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\">a、m_obj = env-&gt;NewGlobalRef(obj);<span class=\"comment\">//创建一个全局变量  </span></span><br><span class=\"line\"></span><br><span class=\"line\">b、jobject obj = env-&gt;AllocObject(m_cls);<span class=\"comment\">//在每个线程中都生成一个对象</span></span><br></pre></td></tr></table></figure>\n\n<p>对于JNIEnv，解决办法是在每个线程中都重新生成一个env</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\">JavaVM *gJavaVM;<span class=\"comment\">//声明全局变量</span></span><br><span class=\"line\">(*env)-&gt;GetJavaVM(env, &amp;gJavaVM);<span class=\"comment\">//在JNI方法的中赋值</span></span><br><span class=\"line\"></span><br><span class=\"line\">JNIEnv *env;<span class=\"comment\">//在其它线程中获取当前线程的env  </span></span><br><span class=\"line\">m_jvm-&gt;AttachCurrentThread((<span class=\"type\">void</span> **)&amp;env, <span class=\"literal\">NULL</span>);  </span><br></pre></td></tr></table></figure>\n\n<p>当在一个线程里面调用AttachCurrentThr</p>\n","cover":null,"images":["https://cdn.julis.wang/blog/img/167c522c1dfb148f.png","https://cdn.julis.wang/blog/img/167c56e72c22fbe7.png"],"content":"<p>最近接触JNI相关的项目遇到一些与内存相关到问题，JNI或者说是C&#x2F;C++开发与平时的Java开发相比，总会给人更多的“惊喜”，因为不熟悉native开发，所以有很多知识都不太清楚，一点一点地记录。<br>在掘金相关搜索到下面这篇，个人感觉还不错。<br>以下内容转载自：</p>\n<p><a href=\"https://juejin.cn/post/6844903743352209422\">https://juejin.cn/post/6844903743352209422</a></p>\n<img width=\"60%\" src=\"https://cdn.julis.wang/blog/img/167c522c1dfb148f.png\">\n<p>上面这张图大家都应该很熟了，下面只讲下和JNI有关的部分</p>\n<h4 id=\"程序计数器\"><a href=\"#程序计数器\" class=\"headerlink\" title=\"程序计数器\"></a>程序计数器</h4><p>记录正在执行的虚拟机字节码指令的地址（如果正在执行的是本地方法则为空）。</p>\n<h4 id=\"本地方法栈\"><a href=\"#本地方法栈\" class=\"headerlink\" title=\"本地方法栈\"></a>本地方法栈</h4><p>本地方法栈与 Java 虚拟机栈类似，它们之间的区别只不过是本地方法栈为本地方法服务。 本地方法一般是用其它语言（C、C++ 或汇编语言等）编写的，并且被编译为基于本机硬件和操作系统的程序，对待这些方法需要特别处理。</p>\n<h4 id=\"堆-Java-Heap\"><a href=\"#堆-Java-Heap\" class=\"headerlink\" title=\"堆(Java-Heap)\"></a>堆(Java-Heap)</h4><p>所有对象都在这里分配内存，是垃圾收集的主要区域（”GC 堆”）。 堆不需要连续内存，并且可以动态增加其内存，增加失败会抛出 OutOfMemoryError 异常。</p>\n<p>可以通过 -Xms 和 -Xmx 两个虚拟机参数来指定一个程序的堆内存大小，第一个参数设置初始值，第二个参数设置最大值。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">java -Xmx1024m -Xms1024m</span><br><span class=\"line\">//-Xmx1024m：设置JVM最大可用内存为1024M。</span><br><span class=\"line\">//-Xms1024m：设置JVM初始内存为1024m。此值可与-Xmx相同，以避免每次垃圾回收完成后JVM重新分配内存。</span><br></pre></td></tr></table></figure>\n\n<p>在Android系统对于每个应用都有内存使用的限制，机器的内存限制，在&#x2F;system&#x2F;build.prop文件中配置的。可以在manifest文件application节点加入 <code>android:largeHeap=&quot;true&quot;</code>来让Dalvik&#x2F;ART虚拟机分配更大的堆内存空间</p>\n<h4 id=\"直接内存（native堆）\"><a href=\"#直接内存（native堆）\" class=\"headerlink\" title=\"直接内存（native堆）\"></a>直接内存（native堆）</h4><p>也称为C-Heap，供Java Runtime进程使用的，没有相应的参数来控制其大小，其大小依赖于操作系统进程的最大值。  Java应用程序都是在Java Runtime Environment（JRE）中运行，而Runtime本身就是由Native语言（如：C&#x2F;C++）编写程序。Native Memory就是操作系统分配给Runtime进程的可用内存，它与Heap Memory不同，Java Heap 是Java应用程序的内存。。Native Memory的主要作用如下：</p>\n<ul>\n<li>管理java heap的状态数据（用于GC）;</li>\n<li>JNI调用，也就是Native Stack；</li>\n<li>JIT（即使编译器）编译时使用Native Memory，并且JIT的输入（Java字节码）和输出（可执行代码）也都是保存在Native Memory；</li>\n<li>NIO direct buffer；</li>\n<li>Threads；</li>\n<li>类加载器和类信息都是保存在Native Memory中的。</li>\n</ul>\n<h3 id=\"JNI内存\"><a href=\"#JNI内存\" class=\"headerlink\" title=\"JNI内存\"></a>JNI内存</h3><p>在Java代码中，Java对象被存放在JVM的Java Heap，由垃圾回收器（Garbage Collector，即GC）自动回收就可以。</p>\n<p> 在Native代码中，内存是从Native Memory中分配的，需要根据Native编程规范去操作内存。如：C&#x2F;C++使用malloc()&#x2F;new分配内存，需要手动使用free()&#x2F;delete回收内存。</p>\n<p> 然而，JNI和上面两者又有些区别。 JNI提供了与Java相对应的引用类型（如：jobject、jstring、jclass、jarray、jintArray等），以便Native代码可以通过JNI函数访问到Java对象。引用所指向的Java对象通常就是存放在Java Heap，而Native代码持有的引用是存放在Native Memory中。</p>\n<p>举个例子，如下代码：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\">jstring jstr = env-&gt;<span class=\"built_in\">NewStringUTF</span>(<span class=\"string\">&quot;Hello World!&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>jstring类型是JNI提供的，对应于Java的String类型</li>\n<li>JNI函数<code>NewStringUTF()</code>用于构造一个String对象，该对象存放在Java Heap中，同时返回了一个jstring类型的引用。</li>\n<li>String对象的引用保存在jstr中，jstr是Native的一个局部变量，存放在Native Memory中。</li>\n</ul>\n<p>开发人员都应该遇到过OOM（Out of Memory）异常，在JNI开发中，该异常可能发生在Java Heap中，也可能发生在Native Memory中。</p>\n<ul>\n<li>string类型是JNI提供的，对应于Java的String类型</li>\n<li>JNI函数<code>NewStringUTF()</code>用于构造一个String对象，该对象存放在Java Heap中，同时返回了一个jstring类型的引用。</li>\n<li>String对象的引用保存在jstr中，jstr是Native的一个局部变量，存放在Native Memory中。</li>\n</ul>\n<p>开发人员都应该遇到过OOM（Out of Memory）异常，在JNI开发中，该异常可能发生在Java Heap中，也可能发生在Native Memory中。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">java.lang.OutOfMemoryError: Java heap space</span><br><span class=\"line\">java.lang.OutOfMemoryError: native memory exhausted</span><br></pre></td></tr></table></figure>\n\n<p><strong>Java Heap 中出现 Out of Memory异常的原因有两种：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">1）程序过于庞大，致使过多 Java 对象的同时存在；</span><br><span class=\"line\">2）程序编写的错误导致 Java Heap 内存泄漏。</span><br></pre></td></tr></table></figure>\n\n<p><strong>Native Memory中出现 Out of Memory异常的原因：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">1）程序申请过多资源，系统未能满足，比如说大量线程资源；</span><br><span class=\"line\">2）程序编写的错误导致Native Memory内存泄漏。</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"JNI引用\"><a href=\"#JNI引用\" class=\"headerlink\" title=\"JNI引用\"></a>JNI引用</h3><p>JNI引用有三种：<code>Local Reference</code>、<code>Global Reference</code>、<code>Weak Global Reference</code>。下面分别来介绍一下这三种引用内存分配和管理。</p>\n<p><strong>Local Reference</strong></p>\n<p>只在Native Method执行时存在，只在创建它的线程有效，不能跨线程使用。它的生命期是在Native Method的执行期开始创建（从Java代码切换到Native代码环境时，或者在Native Method执行时调用JNI函数时），在Native Method执行完毕切换回Java代码时，所有Local Reference被删除（GC会回收其内存），生命期结束（调用<code>DeleteLocalRef()</code>可以提前回收内存，结束其生命期）。</p>\n<p> 实际上，每当线程从Java环境切换到Native代码环境时，JVM 会分配一块内存用于创建一个<code>Local Reference Table</code>，这个Table用来存放本次Native Method 执行中创建的所有<code>Local Reference</code>。每当在 Native代码中引用到一个Java对象时，JVM 就会在这个Table中创建一个<code>Local Reference</code>。比如，我们调用 NewStringUTF() 在 Java Heap 中创建一个 String 对象后，在 <code>Local Reference Table</code> 中就会相应新增一个 <code>Local Reference</code>。</p>\n<p>Local Reference 表、Local Reference 和 Java 对象的关系</p>\n<img src=\"https://cdn.julis.wang/blog/img/167c56e72c22fbe7.png\">\n<p>接下来举个简单例子说明一下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">jstring jstr = env-&gt;NewStringUTF(&quot;Hello World!&quot;);</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>jstr存放在Native Method Stack中，是一个局部变量</li>\n<li>对于开发者来说，Local Reference Table是不可见的</li>\n<li><code>Local Reference Table</code>的内存不大，所能存放<code>的Local Reference</code>数量也是有限的（在Android中默认最大容量是512个），使用不当就会引起溢出异常</li>\n<li><code>Local Reference</code>并不是Native里面的局部变量，局部变量存放在堆栈中，其引用存放在<code>Local Reference Table</code>中。</li>\n</ul>\n<p>在Native Method结束时，JVM会自动释放Local Reference，但<code>Local Reference Table</code>是有大小限制的，在开发中应该及时使用DeleteLocalRef()删除不必要的Local Reference，不然可能会出现溢出错误：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">JNI ERROR (app bug): local reference table overflow (max=512)</span><br></pre></td></tr></table></figure>\n\n<p>在C&#x2F;C++中实例化的JNI对象，如果不返回java，必须用release掉或delete，否则内存泄露。包括NewStringUTF，NewObject。对于一般的基本数据类型（如：jint，jdouble等），是没必要调用该函数删除掉的。如果返回java不必delete，java会自己回收。</p>\n<p><strong>Global Reference</strong></p>\n<p>Local Reference是在Native Method执行的时候出现的，而<code>Global Reference</code>是通过JNI函数<code>NewGlobalRef()</code>和<code>DeleteGlobalRef()</code>来创建和删除的。 <code>Global Reference</code>具有全局性，可以在多个Native Method调用过程和多线程中使用，在主动调用DeleteGlobalRef之前，它是一直有效的（GC不会回收其内存）。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 创建obj参数所引用对象的新全局引用。obj参数既可以是全局引用，也可以是局部引用。全局引用通过调用DeleteGlobalRef()来显式撤消。</span></span><br><span class=\"line\"><span class=\"comment\"> * @param obj 全局或局部引用。</span></span><br><span class=\"line\"><span class=\"comment\"> * @return 返回全局引用。如果系统内存不足则返回 NULL。</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\">jobject <span class=\"title function_\">NewGlobalRef</span><span class=\"params\">(jobject obj)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 删除globalRef所指向的全局引用</span></span><br><span class=\"line\"><span class=\"comment\"> * @param globalRef 全局引用</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">DeleteGlobalRef</span><span class=\"params\">(jobject globalRef)</span>;</span><br></pre></td></tr></table></figure>\n\n<p>使用 <code>Global reference</code>时，当 native code 不再需要访问<code>Global reference</code> 时，应当调用 JNI 函数 <code>DeleteGlobalRef()</code> 删除 <code>Global reference</code>和它引用的 Java 对象。否则<code>Global Reference</code>引用的 Java 对象将永远停留在 Java Heap 中，从而导致 Java Heap 的内存泄漏。</p>\n<p><strong>Weak Global Reference</strong></p>\n<p>用<code>NewWeakGlobalRef()</code>和<code>DeleteWeakGlobalRef()</code>进行创建和删除，它与<code>Global Reference</code>的区别在于该类型的引用随时都可能被GC回收。</p>\n<p>对<code>于Weak Global Reference</code>而言，可以通过<code>isSameObject()</code>将其与NULL比较，看看是否已经被回收了。如果返回JNI_TRUE，则表示已经被回收了，需要重新初始化弱全局引用。<code>Weak Global Reference</code>的回收时机是不确定的，有可能在前一行代码判断它是可用的，后一行代码就被GC回收掉了。为了避免这事事情发生，JNI官方给出了正确的做法，通过NewLocalRef()获取<code>Weak Global Reference</code>，避免被GC回收。</p>\n<h3 id=\"注意点\"><a href=\"#注意点\" class=\"headerlink\" title=\"注意点\"></a>注意点</h3><h4 id=\"Local-Reference-不是-native-code-的局部变量\"><a href=\"#Local-Reference-不是-native-code-的局部变量\" class=\"headerlink\" title=\"Local Reference 不是 native code 的局部变量\"></a>Local Reference 不是 native code 的局部变量</h4><p>很多人会误将 JNI 中的 Local Reference 理解为 Native Code 的局部变量。这是错误的。</p>\n<p>Native Code 的局部变量和 Local Reference 是完全不同的，区别可以总结为：</p>\n<p>⑴局部变量存储在线程堆栈中，而 Local Reference 存储在 Local Ref 表中。</p>\n<p>⑵局部变量在函数退栈后被删除，而 Local Reference 在调用 DeleteLocalRef() 后才会从 Local Ref 表中删除，并且失效，或者在整个 Native Method 执行结束后被删除。</p>\n<p>⑶可以在代码中直接访问局部变量，而 Local Reference 的内容无法在代码中直接访问，必须通过 JNI function 间接访问。JNI function 实现了对 Local Reference 的间接访问，JNI function 的内部实现依赖于具体 JVM。</p>\n<h4 id=\"注意释放所有对jobject的引用：\"><a href=\"#注意释放所有对jobject的引用：\" class=\"headerlink\" title=\"注意释放所有对jobject的引用：\"></a>注意释放所有对jobject的引用：</h4><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">extern</span> <span class=\"string\">&quot;C&quot;</span></span><br><span class=\"line\">JNIEXPORT jstring JNICALL</span><br><span class=\"line\"><span class=\"title function_\">Java_com_test_application_MainActivity_init</span><span class=\"params\">(JNIEnv *env, jobject instance, jstring data,</span></span><br><span class=\"line\"><span class=\"params\">                                      jbyteArray <span class=\"built_in\">array</span>)</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">int</span> len = env-&gt;GetArrayLength(<span class=\"built_in\">array</span>);</span><br><span class=\"line\">    <span class=\"type\">const</span> <span class=\"type\">char</span> *utfChars = env-&gt;GetStringUTFChars(data, <span class=\"number\">0</span>);</span><br><span class=\"line\">    jbyte *arrayElements = env-&gt;GetByteArrayElements(<span class=\"built_in\">array</span>, <span class=\"literal\">NULL</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    jstring pJstring = env-&gt;NewStringUTF(utfChars); </span><br><span class=\"line\"></span><br><span class=\"line\">    jbyteArray jpicArray = env-&gt;NewByteArray(len);</span><br><span class=\"line\">    env-&gt;SetByteArrayRegion(jpicArray, <span class=\"number\">0</span>, len, arrayElements);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// TODO</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    env-&gt;DeleteLocalRef(pJstring);</span><br><span class=\"line\">    env-&gt;DeleteLocalRef(jpicArray);</span><br><span class=\"line\"></span><br><span class=\"line\">    env-&gt;ReleaseStringUTFChars(data, utfChars);</span><br><span class=\"line\">    env-&gt;ReleaseByteArrayElements(<span class=\"built_in\">array</span>, arrayElements, <span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> hello = <span class=\"string\">&quot;Hello from C++&quot;</span>;</span><br><span class=\"line\">    jstring result = env-&gt;NewStringUTF(hello.c_str());</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>其它的还有：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">jclass ref= (env)-&gt;FindClass(&quot;java/lang/String&quot;);</span><br><span class=\"line\"> </span><br><span class=\"line\">env-&gt;DeleteLocalRef(ref);</span><br><span class=\"line\">复制代码</span><br></pre></td></tr></table></figure>\n\n<p>因为根据<code>jni.h</code>里的定义：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> jobject         jclass;</span><br></pre></td></tr></table></figure>\n\n<p>jclass也是jobject。而<code>jmethodID</code>&#x2F;<code>jfielID</code>和jobject没有继承关系，它们不是object,只是个整数，不存在被释放与否的问题。</p>\n<h4 id=\"局部引用和全局引用的转换\"><a href=\"#局部引用和全局引用的转换\" class=\"headerlink\" title=\"局部引用和全局引用的转换\"></a>局部引用和全局引用的转换</h4><p>注意Local Reference的生命周期，如果在Native中需要长时间持有一个Java对象，就不能使用将jobject存储在Native，否则在下次使用的时候，即使同一个线程调用，也将会无法使用。下面是错误的做法：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\">jstring global;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">extern</span> <span class=\"string\">&quot;C&quot;</span> JNIEXPORT jstring JNICALL</span><br><span class=\"line\"><span class=\"title function_\">Java_org_hik_libyuv_MainActivity_stringFromJNI</span><span class=\"params\">(</span></span><br><span class=\"line\"><span class=\"params\">        JNIEnv *env,</span></span><br><span class=\"line\"><span class=\"params\">        jobject <span class=\"comment\">/* this */</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> hello = <span class=\"string\">&quot;Hello from C++&quot;</span>;</span><br><span class=\"line\">    jstring local = env-&gt;NewStringUTF(hello.c_str());</span><br><span class=\"line\">    global = local;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> local;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>正确的做法是使用Global Reference，如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\">jstring global;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">extern</span> <span class=\"string\">&quot;C&quot;</span> JNIEXPORT jstring JNICALL</span><br><span class=\"line\"><span class=\"title function_\">Java_org_hik_libyuv_MainActivity_stringFromJNI</span><span class=\"params\">(</span></span><br><span class=\"line\"><span class=\"params\">        JNIEnv *env,</span></span><br><span class=\"line\"><span class=\"params\">        jobject <span class=\"comment\">/* this */</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> hello = <span class=\"string\">&quot;Hello from C++&quot;</span>;</span><br><span class=\"line\">    jstring local = env-&gt;NewStringUTF(hello.c_str());</span><br><span class=\"line\">    global = static_cast&lt;jstring&gt;(env-&gt;NewGlobalRef(global));</span><br><span class=\"line\">    <span class=\"keyword\">return</span> local;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"多线程\"><a href=\"#多线程\" class=\"headerlink\" title=\"多线程\"></a>多线程</h4><p>JNIEnv和jobject对象都不能跨线程使用。 对于jobject，解决办法是</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\">a、m_obj = env-&gt;NewGlobalRef(obj);<span class=\"comment\">//创建一个全局变量  </span></span><br><span class=\"line\"></span><br><span class=\"line\">b、jobject obj = env-&gt;AllocObject(m_cls);<span class=\"comment\">//在每个线程中都生成一个对象</span></span><br></pre></td></tr></table></figure>\n\n<p>对于JNIEnv，解决办法是在每个线程中都重新生成一个env</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\">JavaVM *gJavaVM;<span class=\"comment\">//声明全局变量</span></span><br><span class=\"line\">(*env)-&gt;GetJavaVM(env, &amp;gJavaVM);<span class=\"comment\">//在JNI方法的中赋值</span></span><br><span class=\"line\"></span><br><span class=\"line\">JNIEnv *env;<span class=\"comment\">//在其它线程中获取当前线程的env  </span></span><br><span class=\"line\">m_jvm-&gt;AttachCurrentThread((<span class=\"type\">void</span> **)&amp;env, <span class=\"literal\">NULL</span>);  </span><br></pre></td></tr></table></figure>\n\n<p>当在一个线程里面调用AttachCurrentThr</p>\n","categories":[{"name":"技术文章","slug":"technology","api":"api/categories/technology.json"}],"tags":[{"name":"Android","slug":"Android","api":"api/tags/Android.json"},{"name":"JNI","slug":"JNI","api":"api/tags/JNI.json"}],"api":"api/posts/2021/03/10/JNI内存管理及优化.json"},{"title":"{已开源} 阅文 Flutter 混合开发利器 MixStack","slug":"MixStack","date":"2021-02-26T12:56:00.000Z","updated":"2025-05-20T11:46:57.000Z","comments":true,"url":"2021/02/26/MixStack/","excerpt":"<p>原文发表于 阅文技术公众号 <a href=\"https://mp.weixin.qq.com/s?__biz=MzIxMzgxMjQ1Mw==&mid=2247483918&idx=1&sn=1a09f803ed543b11a3d4255fb28ee854&chksm=97b05784a0c7de9265fd6c5690e46f5f8cd68ffd1f9d85c0263c3b28d06936f08fc6034ab3c8&mpshare=1&scene=1&srcid=0310R2s6SjdCsrAvUwXNBoo3&sharer_sharetime=1615366421433&sharer_shareid=f9805455f7ec45f0ab87cd8190bfce47&version=3.1.1.6192&platform=mac#rd\">《{已开源} 阅文 Flutter 混合开发利器 MixStack》</a></p>\n<p>Github开源地址：<a href=\"https://github.com/yuewen/mix_stack\">MixStack</a></p>\n<p>MixStack混合栈是我当时刚进入公司不久参与的该项目，对于混合栈的开发说起来很简单，但踩了无数的坑，经常被各种神奇的bug和场景折腾得睡不好觉。还好，最终都挺过来了，项目从启动到开源最后再到文章，不知道被老大哥喷了多少遍，可以说这是我工作生涯中，灰暗而又有收获，非常有意义的一段时间，遂记录该文章于博客。</p>\n<h2 id=\"一、前言\"><a href=\"#一、前言\" class=\"headerlink\" title=\"一、前言\"></a><strong>一、前言</strong></h2><p>Flutter 是一款谷歌的移动 UI 框架，可以快速在 iOS 和 Android 上构建高质量的原生用户界面。Flutter 可以与现有的代码一起工作，相比于其他跨平台的框架，如 React Native、Weex 等，Flutter 具有如下的优势：跨平台表现一致 谷歌直接在 iOS&#x2F;Android 等平台直接建立了独立的渲染引擎，保证了界面渲染的高效且多端有接近原生性能的表现。快速开发 开发过程中提供了高效的热重载，开发便捷。已有工具链已经比较强大。</p>\n<h2 id=\"二、随之而来的问题\"><a href=\"#二、随之而来的问题\" class=\"headerlink\" title=\"二、随之而来的问题\"></a><strong>二、随之而来的问题</strong></h2><p>当我们尝试将 Flutter 集成到项目中的时候，却发现现实比想象骨感许多，这里我们以 Android 平台的探索为例进行说明。</p>\n<p>对于 Android 平台，官方封装了 FlutterAcitivity 以及 FlutterFragment 两种 Flutter 原生容器，当我们直接使用时，能正常打开 Flutter 页面，但是表现却并不如我们所期待。</p>\n<p>其中最明显的就是，官方会为每个  FlutterAcitivity 和 FlutterFragment 生成一个新的 FlutterEngine 实例。每个 FlutterEngine 拥有不同的 Isolate，也就是说不同的 Dart 运行环境完全独立，其内存状态不进行共享。对于大多数 App 来说，多数页面有一些全局状态（例如登录态）。如果基于 Flutter 默认的设计，两个不同容器里的 Flutter 页面通信将变得异常复杂。另外每个 FlutterEngine 实例的内存开销本身就非常大，例如同一张图片由于内存状态不共享，在 n 个 Engine 中会存在 n 份，这显然是不可接受的。</p>\n<p>这就是当我们想把 Flutter 与现有业务代码混合使用时会遇到的 </p>\n<p><strong>问题1：多 FlutterEngine 实例间内存状态不共享</strong></p>\n<p>对于多 FlutterEngine 实例带来的问题远不止这些，官方提供给了我们一种解决方案：共享 FlutterEngine，全局只有一个 FlutterEngine 实例，将其放入缓存管理中。当我们尝试使用这种方案连续打开两个 FlutterActivity，页面却会冻住，停止渲染.</p>\n<p><strong>问题2：Flutter 原生容器在共享 FlutterEngine 情况下渲染生命周期错误</strong></p>\n<img width=\"50%\" src=\"https://cdn.julis.wang/blog/img/uZyfcSvc6dDWlHKEDdDRlXUp6.gif\">\n<p>另外，在业务场景中，常有类似这样的页面跳转情况：Native Activity-&gt;Flutter Activity-&gt;Native Activity-&gt;Flutter Activity-&gt;Native Activity ，其中 Flutter Activity 中拥有几个不同的 Flutter Page，如下图所示：</p>\n<img src=\"https://cdn.julis.wang/blog/img/up-d9cffa0f953425a54c3c7e27a61b543e4c4.png\">\n\n<p>对于 FlutteActivity 或者 FlutterFragment 中的 Flutter 页面来说我们需要将其与原生页面对齐，页面栈变成下图会更容理解：</p>\n<img src=\"https://cdn.julis.wang/blog/img/a89a79a943946376e40b2c8905631f55cae.png\">\n<p>当我们处于 FlutterActivity A 中页面时，对于一些业务场景有顶部 NavigationBar、Back 按键以及手势返回的时候，用户基于常见的栈“先进后出”的原则，对于 FlutterActivity A 中的页面，期望的是先关闭掉其最上层的 Flutter 页面，再依次关闭f3、f2、f1。最终关闭掉该 FlutterActivity 展示 Natvie Activity A。然而实际的情况是：如果不修改相关逻辑，会直接 finish 掉整个 Activity，那么f1、f2、f3……会被同时关闭。</p>\n<p><strong>问题3：Flutter 原生容器中 Flutter 页面栈管理与预期不符</strong></p>\n<img src=\"https://cdn.julis.wang/blog/img/ib5o50a83cSUkvFIDkI7qVb.gif\">\n<p>在每个 FlutterActivity 中存在一个 FlutterView，FlutterView 承载了不同的 Flutter 页面也就是不同的 FlutterWidget，其Flutter 内部不同的 Widget 可以通过Navigator控制，我们需要将其做到与原生对齐，形成一套用户无感，开发者较浅感知的页面栈管理方案。</p>\n<p>随着深入了解会发现更多的问题，页面切换闪屏、App 启动白屏、Flutter Dialog 展示底部白屏、状态栏高度颜色不正确等等等等。</p>\n<h2 id=\"三、解决方案\"><a href=\"#三、解决方案\" class=\"headerlink\" title=\"三、解决方案\"></a><strong>三、解决方案</strong></h2><p>业内 Flutter 混合栈的研究已经开始很久了，但仍没有一款真正的完美解决方案，我们希望这次推出的 MixStack 是这样的方案。经过一系列的探索，我们解决了上述问题，并在实际上线的 App 红袖中进行了验证，取得了较好的效果。</p>\n<p>接下来具体讲解MixStack的实现</p>\n<p><strong>1.共享FlutterEngine</strong></p>\n<p>为了解决问题1：多 FlutterEngine 实例间内存状态不共享，我们选择对 FlutterEngine 进行共享，保持全局只有一个 FlutterEngine。</p>\n<p>这样使得所有相关操作都在同一个Isolate，对于之前所说的全局状态（例如登录态）以及类似同一份图片缓存存在多份的问题也就迎刃而解了。</p>\n<p><strong>2.正确的渲染生命周期</strong></p>\n<p>关于问题2：Flutter 原生容器在共享    FlutterEngine 情况下渲染生命周期错误。默认的 FlutterActivity 和 FlutterFragment 对于共享 FlutterEngine 的支持不太好，我们对其进行了相关修改。基于任何时候只能看到一个  Flutter 原生容器的假设，且 FlutterEngine 同一时刻也只能渲染一个 FlutterView，因此我们约定：对每一个 FlutterView 在可见的时候对其进行渲染相关的准备，在即将不可见的时候使其从渲染上脱离。那该如何实现 Flutter 原生容器顺畅交互呢？我们先看两个容器间切换的生命周期，通常情况下 Activity A 启动   Activity B 生命周期如下图所示：</p>\n<ul>\n<li><img width=\"60%\" src=\"https://cdn.julis.wang/blog/img/up-2347df7b78fcbf33c262fa93247c802ea3c.png\"> FlutterEngine 在原生层面定义了LifecycleChannel，主要作用是向 Flutter 发送渲染生命周期相关的事件。LifecycleChannel主要发送了四种状态事件：\n</li>\n<li><ol>\n<li>AppLifecycleState.resumed、</li>\n</ol>\n</li>\n<li><ol start=\"2\">\n<li>AppLifecycleState.inactive、</li>\n</ol>\n</li>\n<li><ol start=\"3\">\n<li>AppLifecycleState.paused、</li>\n</ol>\n</li>\n<li><ol start=\"4\">\n<li>AppLifecycleState.detached。</li>\n</ol>\n</li>\n<li><p>阅读源码后可知，FlutterEngine 在   AppLifecycleState.resumed 执行了启动渲染的操作。</p>\n</li>\n<li><p>而 AppLifecycleState.paused、    AppLifecycleState.detached停止了渲染操作，也就是说处于这两个生命周期中，页面内的内容不会被重绘。</p>\n</li>\n<li><p>那么我们可知要使 FlutterEngine 渲染交互正常需要满足以下要求：</p>\n</li>\n<li><p><strong>(1) FlutterEngine 生命周期处于  AppLifecycleState.resumed</strong></p>\n</li>\n<li><p><strong>(2) FlutterEngine attach 在当前可见的  FlutterView</strong></p>\n</li>\n<li><p>那么对于 FlutterActivity，只需在   FlutterActivity onResume() 的时候执行以上操作，使得 FlutterEngine 能够渲染当前页面。当 FlutterActivity 需要启动另一个    FlutterActivity 时，FlutterEngine 需要将其从当前 FlutterView detach 并停止渲染。整个流程如下图所示：</p>\n</li>\n<li><img src=\"https://cdn.julis.wang/blog/img/0a28bd5cc8b4b01c57e9388bccca6212306.png\">\n</li>\n<li><p>同理，FlutterActivity 打开原生的 Activity 的时候，我们依然需要在 onPause() 的时候，对 FlutterView 进行 detach 操作，保证在新打开原生 Activity 之后，如有再打开的其他的  FlutterActivity 也能够维护正常生命周期。</p>\n</li>\n<li><p>在多数 App 中都有 Tab 类的界面，一般都是：NavigationBar 加 Fragment 的组合，那当这种场景中混合了多个 FlutterFragment，我们又该如何做呢，Fragment组合如下图所示：</p>\n</li>\n<li><img src=\"https://cdn.julis.wang/blog/img/8ee758f66c0a7e6944d250ecf29703e44bf.png\">\n</li>\n<li><p>我们同样基于之前的假设，在    FlutterFragment onResume() 的时候，attach 到FlutterEngine，使得 FlutterEngine 能够渲染当前页面，onPause 的时候 detach。</p>\n</li>\n<li><p>对于多个 Tab 之间 FlutterFragment 的切换，只多了一步操作，在 onHiddenChanged() 的时候，对 FlutterEngine 进行相应的操作，需要留意的是，在 onPause() 或者  onResume() 操作的时候需要添加  isHidden() 判断，保证当前渲染的是可见的那个 FlutterFragment。</p>\n</li>\n<li><p>FlutterFragment 的渲染流程如下图所示：</p>\n</li>\n</ul>\n <img src=\"https://cdn.julis.wang/blog/img/4e211bbd06e222dc3e8849e884973905292.png\">\n\n<ul>\n<li><p>至此我们成功地解决了问题2：原生 Flutter 容器在共享 FlutterEngine 情况下渲染生命周期错误</p>\n</li>\n<li><p><strong>(3) Flutter 页面相关的约定</strong></p>\n</li>\n<li><p>前面两点的实现，使我们能够成功让 Flutter 原生容器如正常原生页面一般使用，但依然有问题3：原生 Flutter 容器中 Flutter 页面栈管理与预期不符 未解决。为了解决问题3, 我们需要额外增加一些约定，将每一个原生栈中的 Flutter 原生容器映射为 Flutter 中的一个容器，我们称为 PageContainer。</p>\n</li>\n<li><p>如下图所示：</p>\n</li>\n</ul>\n<img src=\"https://cdn.julis.wang/blog/img/20210310195300378.png\">\n\n<p>每个 PageContainer 有以下特性：</p>\n<p>1、包含独立 Navigator，PageContainer 间互不影响</p>\n<p>2、有一个根页面，通过根路径（rootRoute）形式传入</p>\n<p>在每个 Flutter 原生容器实现接口传入 rootRoute 属性，在页面可见的时候，MixStack 会向 Flutter 通信，告知即将显示的页面。</p>\n<p>3、默认对于原生环境的 Inset 无感，通过额外 API 传入（降低性能开销）</p>\n<p>Flutter 对于渲染画布的尺寸变化非常敏感，某些情况下会导致 Widget 状态异常，例如 Tab 滑动位置丢失等等问题，所以 MixStack 默认为 Flutter View 尺寸不变化，推荐将影响 View 内 Flutter 组件排版的 inset 变化通过 API 传入。</p>\n<p>MixStack 基于 Channel 通信告知 Flutter 当前所有页面信息 (pages) 及当前需要显示 Flutter 页面 (currentPage)，Flutter 基于信息更新 Widget。每个 PageContainer 与 Flutter 原生容器的 hashCode 有唯一映射关系，从而保证页面状态持久化。</p>\n<p>另外我们在 iOS 和 Android 上接管了返回指令，并与 Flutter 端进行同步，满足返回预期。</p>\n<p>最后的效果就如我们所期望的：</p>\n<img width=\"50%\" src=\"https://cdn.julis.wang/blog/img/dDRlXUp6dKDoS4NRN5typNux5sz2rvzz0fX.gif\">\n\n<h2 id=\"四、总结\"><a href=\"#四、总结\" class=\"headerlink\" title=\"四、总结\"></a><strong>四、总结</strong></h2><p>至此我们解决了上述三大问题，构建出了一套能够正确维护原生⻚面与 Flutter ⻚面交互的完整解决方案。</p>\n<p>当然关于项目中集成使用 Flutter 所带来的麻烦并不局限于上述问题，Flutter 本身也存在一些 Bug，MixStack 已经将相关的问题在库内解决或者提交官方补丁。经过线上 App 的实际验证，对首⻚多FlutterFragment 、 Flutter 各种弹窗 、各种 Flutter 容器与原生之间的切换等情况均表现正常。</p>\n<p>目前 MixStack 已经全量在阅文旗下红袖 App 上使用，他们在极短时间内借助 MixStack 能力平滑移除了对 RN 的依赖，同时仍正常交付日常功能需求。</p>\n<p>一款成熟的 App 将现有的⻚面完全转化为 Flutter ⻚面，改造的成本太大，周期太⻓，或者有一些业务场景⻚面需要 Native 的能力，需要一个能方便管理原生与 Flutter 混合⻚面的管理工具，那么 MixStack 将是一个非常好的选择。</p>\n","cover":null,"images":["https://cdn.julis.wang/blog/img/uZyfcSvc6dDWlHKEDdDRlXUp6.gif","https://cdn.julis.wang/blog/img/up-d9cffa0f953425a54c3c7e27a61b543e4c4.png","https://cdn.julis.wang/blog/img/a89a79a943946376e40b2c8905631f55cae.png","https://cdn.julis.wang/blog/img/ib5o50a83cSUkvFIDkI7qVb.gif","https://cdn.julis.wang/blog/img/up-2347df7b78fcbf33c262fa93247c802ea3c.png","https://cdn.julis.wang/blog/img/0a28bd5cc8b4b01c57e9388bccca6212306.png","https://cdn.julis.wang/blog/img/8ee758f66c0a7e6944d250ecf29703e44bf.png","https://cdn.julis.wang/blog/img/4e211bbd06e222dc3e8849e884973905292.png","https://cdn.julis.wang/blog/img/20210310195300378.png","https://cdn.julis.wang/blog/img/dDRlXUp6dKDoS4NRN5typNux5sz2rvzz0fX.gif"],"content":"<p>原文发表于 阅文技术公众号 <a href=\"https://mp.weixin.qq.com/s?__biz=MzIxMzgxMjQ1Mw==&mid=2247483918&idx=1&sn=1a09f803ed543b11a3d4255fb28ee854&chksm=97b05784a0c7de9265fd6c5690e46f5f8cd68ffd1f9d85c0263c3b28d06936f08fc6034ab3c8&mpshare=1&scene=1&srcid=0310R2s6SjdCsrAvUwXNBoo3&sharer_sharetime=1615366421433&sharer_shareid=f9805455f7ec45f0ab87cd8190bfce47&version=3.1.1.6192&platform=mac#rd\">《{已开源} 阅文 Flutter 混合开发利器 MixStack》</a></p>\n<p>Github开源地址：<a href=\"https://github.com/yuewen/mix_stack\">MixStack</a></p>\n<p>MixStack混合栈是我当时刚进入公司不久参与的该项目，对于混合栈的开发说起来很简单，但踩了无数的坑，经常被各种神奇的bug和场景折腾得睡不好觉。还好，最终都挺过来了，项目从启动到开源最后再到文章，不知道被老大哥喷了多少遍，可以说这是我工作生涯中，灰暗而又有收获，非常有意义的一段时间，遂记录该文章于博客。</p>\n<h2 id=\"一、前言\"><a href=\"#一、前言\" class=\"headerlink\" title=\"一、前言\"></a><strong>一、前言</strong></h2><p>Flutter 是一款谷歌的移动 UI 框架，可以快速在 iOS 和 Android 上构建高质量的原生用户界面。Flutter 可以与现有的代码一起工作，相比于其他跨平台的框架，如 React Native、Weex 等，Flutter 具有如下的优势：跨平台表现一致 谷歌直接在 iOS&#x2F;Android 等平台直接建立了独立的渲染引擎，保证了界面渲染的高效且多端有接近原生性能的表现。快速开发 开发过程中提供了高效的热重载，开发便捷。已有工具链已经比较强大。</p>\n<h2 id=\"二、随之而来的问题\"><a href=\"#二、随之而来的问题\" class=\"headerlink\" title=\"二、随之而来的问题\"></a><strong>二、随之而来的问题</strong></h2><p>当我们尝试将 Flutter 集成到项目中的时候，却发现现实比想象骨感许多，这里我们以 Android 平台的探索为例进行说明。</p>\n<p>对于 Android 平台，官方封装了 FlutterAcitivity 以及 FlutterFragment 两种 Flutter 原生容器，当我们直接使用时，能正常打开 Flutter 页面，但是表现却并不如我们所期待。</p>\n<p>其中最明显的就是，官方会为每个  FlutterAcitivity 和 FlutterFragment 生成一个新的 FlutterEngine 实例。每个 FlutterEngine 拥有不同的 Isolate，也就是说不同的 Dart 运行环境完全独立，其内存状态不进行共享。对于大多数 App 来说，多数页面有一些全局状态（例如登录态）。如果基于 Flutter 默认的设计，两个不同容器里的 Flutter 页面通信将变得异常复杂。另外每个 FlutterEngine 实例的内存开销本身就非常大，例如同一张图片由于内存状态不共享，在 n 个 Engine 中会存在 n 份，这显然是不可接受的。</p>\n<p>这就是当我们想把 Flutter 与现有业务代码混合使用时会遇到的 </p>\n<p><strong>问题1：多 FlutterEngine 实例间内存状态不共享</strong></p>\n<p>对于多 FlutterEngine 实例带来的问题远不止这些，官方提供给了我们一种解决方案：共享 FlutterEngine，全局只有一个 FlutterEngine 实例，将其放入缓存管理中。当我们尝试使用这种方案连续打开两个 FlutterActivity，页面却会冻住，停止渲染.</p>\n<p><strong>问题2：Flutter 原生容器在共享 FlutterEngine 情况下渲染生命周期错误</strong></p>\n<img width=\"50%\" src=\"https://cdn.julis.wang/blog/img/uZyfcSvc6dDWlHKEDdDRlXUp6.gif\">\n<p>另外，在业务场景中，常有类似这样的页面跳转情况：Native Activity-&gt;Flutter Activity-&gt;Native Activity-&gt;Flutter Activity-&gt;Native Activity ，其中 Flutter Activity 中拥有几个不同的 Flutter Page，如下图所示：</p>\n<img src=\"https://cdn.julis.wang/blog/img/up-d9cffa0f953425a54c3c7e27a61b543e4c4.png\">\n\n<p>对于 FlutteActivity 或者 FlutterFragment 中的 Flutter 页面来说我们需要将其与原生页面对齐，页面栈变成下图会更容理解：</p>\n<img src=\"https://cdn.julis.wang/blog/img/a89a79a943946376e40b2c8905631f55cae.png\">\n<p>当我们处于 FlutterActivity A 中页面时，对于一些业务场景有顶部 NavigationBar、Back 按键以及手势返回的时候，用户基于常见的栈“先进后出”的原则，对于 FlutterActivity A 中的页面，期望的是先关闭掉其最上层的 Flutter 页面，再依次关闭f3、f2、f1。最终关闭掉该 FlutterActivity 展示 Natvie Activity A。然而实际的情况是：如果不修改相关逻辑，会直接 finish 掉整个 Activity，那么f1、f2、f3……会被同时关闭。</p>\n<p><strong>问题3：Flutter 原生容器中 Flutter 页面栈管理与预期不符</strong></p>\n<img src=\"https://cdn.julis.wang/blog/img/ib5o50a83cSUkvFIDkI7qVb.gif\">\n<p>在每个 FlutterActivity 中存在一个 FlutterView，FlutterView 承载了不同的 Flutter 页面也就是不同的 FlutterWidget，其Flutter 内部不同的 Widget 可以通过Navigator控制，我们需要将其做到与原生对齐，形成一套用户无感，开发者较浅感知的页面栈管理方案。</p>\n<p>随着深入了解会发现更多的问题，页面切换闪屏、App 启动白屏、Flutter Dialog 展示底部白屏、状态栏高度颜色不正确等等等等。</p>\n<h2 id=\"三、解决方案\"><a href=\"#三、解决方案\" class=\"headerlink\" title=\"三、解决方案\"></a><strong>三、解决方案</strong></h2><p>业内 Flutter 混合栈的研究已经开始很久了，但仍没有一款真正的完美解决方案，我们希望这次推出的 MixStack 是这样的方案。经过一系列的探索，我们解决了上述问题，并在实际上线的 App 红袖中进行了验证，取得了较好的效果。</p>\n<p>接下来具体讲解MixStack的实现</p>\n<p><strong>1.共享FlutterEngine</strong></p>\n<p>为了解决问题1：多 FlutterEngine 实例间内存状态不共享，我们选择对 FlutterEngine 进行共享，保持全局只有一个 FlutterEngine。</p>\n<p>这样使得所有相关操作都在同一个Isolate，对于之前所说的全局状态（例如登录态）以及类似同一份图片缓存存在多份的问题也就迎刃而解了。</p>\n<p><strong>2.正确的渲染生命周期</strong></p>\n<p>关于问题2：Flutter 原生容器在共享    FlutterEngine 情况下渲染生命周期错误。默认的 FlutterActivity 和 FlutterFragment 对于共享 FlutterEngine 的支持不太好，我们对其进行了相关修改。基于任何时候只能看到一个  Flutter 原生容器的假设，且 FlutterEngine 同一时刻也只能渲染一个 FlutterView，因此我们约定：对每一个 FlutterView 在可见的时候对其进行渲染相关的准备，在即将不可见的时候使其从渲染上脱离。那该如何实现 Flutter 原生容器顺畅交互呢？我们先看两个容器间切换的生命周期，通常情况下 Activity A 启动   Activity B 生命周期如下图所示：</p>\n<ul>\n<li><img width=\"60%\" src=\"https://cdn.julis.wang/blog/img/up-2347df7b78fcbf33c262fa93247c802ea3c.png\"> FlutterEngine 在原生层面定义了LifecycleChannel，主要作用是向 Flutter 发送渲染生命周期相关的事件。LifecycleChannel主要发送了四种状态事件：\n</li>\n<li><ol>\n<li>AppLifecycleState.resumed、</li>\n</ol>\n</li>\n<li><ol start=\"2\">\n<li>AppLifecycleState.inactive、</li>\n</ol>\n</li>\n<li><ol start=\"3\">\n<li>AppLifecycleState.paused、</li>\n</ol>\n</li>\n<li><ol start=\"4\">\n<li>AppLifecycleState.detached。</li>\n</ol>\n</li>\n<li><p>阅读源码后可知，FlutterEngine 在   AppLifecycleState.resumed 执行了启动渲染的操作。</p>\n</li>\n<li><p>而 AppLifecycleState.paused、    AppLifecycleState.detached停止了渲染操作，也就是说处于这两个生命周期中，页面内的内容不会被重绘。</p>\n</li>\n<li><p>那么我们可知要使 FlutterEngine 渲染交互正常需要满足以下要求：</p>\n</li>\n<li><p><strong>(1) FlutterEngine 生命周期处于  AppLifecycleState.resumed</strong></p>\n</li>\n<li><p><strong>(2) FlutterEngine attach 在当前可见的  FlutterView</strong></p>\n</li>\n<li><p>那么对于 FlutterActivity，只需在   FlutterActivity onResume() 的时候执行以上操作，使得 FlutterEngine 能够渲染当前页面。当 FlutterActivity 需要启动另一个    FlutterActivity 时，FlutterEngine 需要将其从当前 FlutterView detach 并停止渲染。整个流程如下图所示：</p>\n</li>\n<li><img src=\"https://cdn.julis.wang/blog/img/0a28bd5cc8b4b01c57e9388bccca6212306.png\">\n</li>\n<li><p>同理，FlutterActivity 打开原生的 Activity 的时候，我们依然需要在 onPause() 的时候，对 FlutterView 进行 detach 操作，保证在新打开原生 Activity 之后，如有再打开的其他的  FlutterActivity 也能够维护正常生命周期。</p>\n</li>\n<li><p>在多数 App 中都有 Tab 类的界面，一般都是：NavigationBar 加 Fragment 的组合，那当这种场景中混合了多个 FlutterFragment，我们又该如何做呢，Fragment组合如下图所示：</p>\n</li>\n<li><img src=\"https://cdn.julis.wang/blog/img/8ee758f66c0a7e6944d250ecf29703e44bf.png\">\n</li>\n<li><p>我们同样基于之前的假设，在    FlutterFragment onResume() 的时候，attach 到FlutterEngine，使得 FlutterEngine 能够渲染当前页面，onPause 的时候 detach。</p>\n</li>\n<li><p>对于多个 Tab 之间 FlutterFragment 的切换，只多了一步操作，在 onHiddenChanged() 的时候，对 FlutterEngine 进行相应的操作，需要留意的是，在 onPause() 或者  onResume() 操作的时候需要添加  isHidden() 判断，保证当前渲染的是可见的那个 FlutterFragment。</p>\n</li>\n<li><p>FlutterFragment 的渲染流程如下图所示：</p>\n</li>\n</ul>\n <img src=\"https://cdn.julis.wang/blog/img/4e211bbd06e222dc3e8849e884973905292.png\">\n\n<ul>\n<li><p>至此我们成功地解决了问题2：原生 Flutter 容器在共享 FlutterEngine 情况下渲染生命周期错误</p>\n</li>\n<li><p><strong>(3) Flutter 页面相关的约定</strong></p>\n</li>\n<li><p>前面两点的实现，使我们能够成功让 Flutter 原生容器如正常原生页面一般使用，但依然有问题3：原生 Flutter 容器中 Flutter 页面栈管理与预期不符 未解决。为了解决问题3, 我们需要额外增加一些约定，将每一个原生栈中的 Flutter 原生容器映射为 Flutter 中的一个容器，我们称为 PageContainer。</p>\n</li>\n<li><p>如下图所示：</p>\n</li>\n</ul>\n<img src=\"https://cdn.julis.wang/blog/img/20210310195300378.png\">\n\n<p>每个 PageContainer 有以下特性：</p>\n<p>1、包含独立 Navigator，PageContainer 间互不影响</p>\n<p>2、有一个根页面，通过根路径（rootRoute）形式传入</p>\n<p>在每个 Flutter 原生容器实现接口传入 rootRoute 属性，在页面可见的时候，MixStack 会向 Flutter 通信，告知即将显示的页面。</p>\n<p>3、默认对于原生环境的 Inset 无感，通过额外 API 传入（降低性能开销）</p>\n<p>Flutter 对于渲染画布的尺寸变化非常敏感，某些情况下会导致 Widget 状态异常，例如 Tab 滑动位置丢失等等问题，所以 MixStack 默认为 Flutter View 尺寸不变化，推荐将影响 View 内 Flutter 组件排版的 inset 变化通过 API 传入。</p>\n<p>MixStack 基于 Channel 通信告知 Flutter 当前所有页面信息 (pages) 及当前需要显示 Flutter 页面 (currentPage)，Flutter 基于信息更新 Widget。每个 PageContainer 与 Flutter 原生容器的 hashCode 有唯一映射关系，从而保证页面状态持久化。</p>\n<p>另外我们在 iOS 和 Android 上接管了返回指令，并与 Flutter 端进行同步，满足返回预期。</p>\n<p>最后的效果就如我们所期望的：</p>\n<img width=\"50%\" src=\"https://cdn.julis.wang/blog/img/dDRlXUp6dKDoS4NRN5typNux5sz2rvzz0fX.gif\">\n\n<h2 id=\"四、总结\"><a href=\"#四、总结\" class=\"headerlink\" title=\"四、总结\"></a><strong>四、总结</strong></h2><p>至此我们解决了上述三大问题，构建出了一套能够正确维护原生⻚面与 Flutter ⻚面交互的完整解决方案。</p>\n<p>当然关于项目中集成使用 Flutter 所带来的麻烦并不局限于上述问题，Flutter 本身也存在一些 Bug，MixStack 已经将相关的问题在库内解决或者提交官方补丁。经过线上 App 的实际验证，对首⻚多FlutterFragment 、 Flutter 各种弹窗 、各种 Flutter 容器与原生之间的切换等情况均表现正常。</p>\n<p>目前 MixStack 已经全量在阅文旗下红袖 App 上使用，他们在极短时间内借助 MixStack 能力平滑移除了对 RN 的依赖，同时仍正常交付日常功能需求。</p>\n<p>一款成熟的 App 将现有的⻚面完全转化为 Flutter ⻚面，改造的成本太大，周期太⻓，或者有一些业务场景⻚面需要 Native 的能力，需要一个能方便管理原生与 Flutter 混合⻚面的管理工具，那么 MixStack 将是一个非常好的选择。</p>\n","categories":[{"name":"技术文章","slug":"technology","api":"api/categories/technology.json"}],"tags":[{"name":"Flutter","slug":"Flutter","api":"api/tags/Flutter.json"}],"api":"api/posts/2021/02/26/MixStack.json"},{"title":"Flutter坑之FlutterFragment中SafeArea失效的问题","slug":"Flutter坑之FlutterFragment中SafeArea失效的问题","date":"2020-10-31T06:40:00.000Z","updated":"2025-05-20T11:46:57.000Z","comments":true,"url":"2020/10/31/Flutter坑之FlutterFragment中SafeArea失效的问题/","excerpt":"<p>最近有在做关于Android底部多tab下，对应多个Flutter Fragment的操作。又遇到一个比较坑的问题:FlutterFragment中的flutter页面的SafeArea失效（关于safeArea具体介绍参考官方<a href=\"https://api.flutter.dev/flutter/widgets/SafeArea-class.html\">SafeArea class</a>），简单举例说一下SafeArea的作用：如果你有一刘海屏的手机，如果你的flutter内容为全屏，假如你的内容在全屏最顶部，那么所谓的刘海将会盖住你所想要的内容，如下图所示：</p>\n<img width=\"50%\" src=\"https://cdn.julis.wang/blog/img/2020110113363517.png\">\n<p>这当然不是我们想要的，于是Flutter官方推出：SafeArea这个属性，在dart语言中只需要在你的widget最外层包裹SafeArea就好了。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@override</span></span><br><span class=\"line\">Widget <span class=\"title function_\">build</span><span class=\"params\">(BuildContext context)</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> Scaffold(</span><br><span class=\"line\">    body: SafeArea(</span><br><span class=\"line\">      child: TabBarView(</span><br><span class=\"line\">        controller: mController,</span><br><span class=\"line\">        children: &lt;Widget&gt;[]</span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>于是得到了正确的展示效果，如下图所示：</p>\n<img width=\"50%\" src=\"https://cdn.julis.wang/blog/img/20201101134229321.png\">\n<p>你以为这样就完了么？在多个Flutter Fragment中SafeArea的作用失效，尽管我在flutter中设置了SafeArea，但依然存在刘海盖住flutter content的情况。</p>\n<h1 id=\"原因分析：\"><a href=\"#原因分析：\" class=\"headerlink\" title=\"原因分析：\"></a>原因分析：</h1><p>这真的是一件很头疼的事情，对应的Flutter page在Flutter Activity中能够正常work，但是偏偏在Fluttter Fragment中就出问题了呢？于是又去看FlutterView源码，果然有收获！发现一个方法：<code>onApplyWindowInsets()</code>这里面有一大堆逻辑，很多都是关于处理 statusBar以及navigationBar，更惊喜地还发现了处理<a href=\"https://developer.android.google.cn/reference/android/view/DisplayCutout?hl=zh-cn\">DisplayCutout</a>的逻辑，这不就是刘海屏相关的类么！以下是部分代码逻辑：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> WindowInsets <span class=\"title function_\">onApplyWindowInsets</span><span class=\"params\">(WindowInsets insets)</span> &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">   <span class=\"keyword\">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.R) &#123;</span><br><span class=\"line\">     <span class=\"type\">int</span> <span class=\"variable\">mask</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">     <span class=\"keyword\">if</span> (navigationBarVisible) &#123;</span><br><span class=\"line\">       mask = mask | android.view.WindowInsets.Type.navigationBars();</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">     <span class=\"keyword\">if</span> (statusBarVisible) &#123;</span><br><span class=\"line\">       mask = mask | android.view.WindowInsets.Type.statusBars();</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">     <span class=\"comment\">// TODO(garyq): Expose the full rects of the display cutout.</span></span><br><span class=\"line\">     <span class=\"comment\">// Take the max of the display cutout insets and existing padding to merge them</span></span><br><span class=\"line\">     <span class=\"type\">DisplayCutout</span> <span class=\"variable\">cutout</span> <span class=\"operator\">=</span> insets.getDisplayCutout();</span><br><span class=\"line\">     <span class=\"keyword\">if</span> (cutout != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">       <span class=\"type\">Insets</span> <span class=\"variable\">waterfallInsets</span> <span class=\"operator\">=</span> cutout.getWaterfallInsets();</span><br><span class=\"line\">       mMetrics.physicalPaddingTop =</span><br><span class=\"line\">           Math.max(</span><br><span class=\"line\">               Math.max(mMetrics.physicalPaddingTop, waterfallInsets.top),</span><br><span class=\"line\">               cutout.getSafeInsetTop());</span><br><span class=\"line\">      ...</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">   &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">     <span class=\"comment\">// Status bar (top) and left/right system insets should partially obscure the content</span></span><br><span class=\"line\">     <span class=\"comment\">// (padding).</span></span><br><span class=\"line\">   ...</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   updateViewportMetrics();</span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"built_in\">super</span>.onApplyWindowInsets(insets);</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n<p>很明显这一块逻辑是处理刘海屏以及StatusBar相关的逻辑，于是进行相关的断点调试，发现FlutterFragment中的FlutterView的确是没有执行这个方法，对比同样在FlutterActivity中的FlutterView正常work并执行了这一串代码。</p>\n<p>！那这不就神奇了么？这一下子又让人头秃了，这一定又是跟Fragment的相关机制导致的，自己对Fragment的具体处理逻辑不太熟，于是各种Google，找到两篇有点类似的答案：<br><a href=\"https://stackoverflow.com/questions/31190612/fitssystemwindows-effect-gone-for-fragments-added-via-fragmenttransaction\">1、fitsSystemWindows effect gone for fragments added via FragmentTransaction</a><br><a href=\"https://blog.csdn.net/qq_35054800/article/details/82107053?utm_source=copy\">2、一个Activity中添加多个Fragment导致fitsSystemWindows无效的问题</a></p>\n<p>引入上面的解释说：</p>\n<blockquote>\n<p>当第一个Fragment添加到Activity中的时候，Activity寻找出有fitsSystemWindows的子布局为其预留出状态栏的空间，其实就是设置一个padding，而其他Fragment添加到Activity中的时候，因为状态栏空间的适配已经被消费过一次了，Activity并不会再次去添加这个padding</p>\n</blockquote>\n<p>虽然这里在进行fitsSystemWindows的操作，但是我们明确了一件事情：添加多个Fragment的时候，Activity对于padding相关操作只在第一个Fragment进行了相关处理逻辑。那么对应我们的FlutterFragment是否是同样的问题呢？？</p>\n<p>于是我进行了尝试，将Flutter Fragment放在Acitvity第一个需要展示的Fragment，经过尝试发现第一个FlutterFragment能正常work了！但之后的Flutter Fragment问题依然存在，那么我们可以肯定也就是说：<br><strong>在多FlutterFragment中的FlutterView，只有在作为Acitivty添加为第一个Fragment的情况下才会去调用 <code> onApplyWindowInsets(WindowInsets insets)</code> 方法去处理一些statusBar相关的操作逻辑。</strong><br>的确事实如此，经过尝试之后发现的确只会调用一次，那么如何解决呢？</p>\n<h1 id=\"解决方案：\"><a href=\"#解决方案：\" class=\"headerlink\" title=\"解决方案：\"></a>解决方案：</h1><p>参照上面的解决方案，可以写一个WindowInsetsFrameLayout继承FrameLayout，并<code>setOnHierarchyChangeListener()</code>监听Fragment的添加操作，在添加的时候执行 view的requestApplyInsets();</p>\n<p>当然对于我们的问题并没有这么麻烦，我们在自己的FlutterFragment中手动去执行flutterView.requestApplyInsets();只需要执行时机保证在flutter渲染之前执行（Safe Area通过获去Native端onApplyWindowInsets()中传过去的params来执行相关渲染）</p>\n<p>但还有一个问题：<code>flutterView.requestApplyInsets();</code>只能在Api大于20中使用，那么低于20呢？与其说低于20，不如直接说，19中怎么处理（Android 4.4 api 19引入的透明状态栏 、沉浸式相关），我们可以看到，在onApplyWindowInsets() 中最终是发送一个事件到flutter端，如下代码所示。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">sendViewportMetricsToFlutter</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!isAttachedToFlutterEngine()) &#123;</span><br><span class=\"line\">    Log.w(</span><br><span class=\"line\">        TAG,</span><br><span class=\"line\">        <span class=\"string\">&quot;Tried to send viewport metrics from Android to Flutter but this &quot;</span></span><br><span class=\"line\">            + <span class=\"string\">&quot;FlutterView was not attached to a FlutterEngine.&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  viewportMetrics.devicePixelRatio = getResources().getDisplayMetrics().density;</span><br><span class=\"line\">  flutterEngine.getRenderer().setViewportMetrics(viewportMetrics);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>那么对于Api 19就可以对相关数据进行反射调用，之后再讲数据发送到flutter端即可，那么大致逻辑如下所示：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">onViewCreated</span><span class=\"params\">(<span class=\"meta\">@NonNull</span> View view, <span class=\"meta\">@Nullable</span> Bundle savedInstanceState)</span> &#123;</span><br><span class=\"line\">     <span class=\"built_in\">super</span>.onViewCreated(view, savedInstanceState);</span><br><span class=\"line\">     <span class=\"keyword\">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.KITKAT_WATCH) &#123;</span><br><span class=\"line\">         flutterView.requestApplyInsets();</span><br><span class=\"line\">     &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">         adapterStatusBarBelowApi20();</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"总结：\"><a href=\"#总结：\" class=\"headerlink\" title=\"总结：\"></a>总结：</h1><p>1、这个问题在官方的FlutterFragment中也存在，但不知道为什么没有修复，可能他们真的不太重视混合开发吧，一心在纯flutter开发中。<br>2、关于为什么Fragment 相关操作逻辑只在第一个被Fragment被添加，这里涉及到了太多底层的东西，这里没有赘述，打算深入研究，写一篇新到blog中去介绍。<br>3、Flutter坑实在是太多了，很多问题都与Android原生机制相关，这不得不让人对原生系统机制进行深入学习。</p>\n","cover":null,"images":["https://cdn.julis.wang/blog/img/2020110113363517.png","https://cdn.julis.wang/blog/img/20201101134229321.png"],"content":"<p>最近有在做关于Android底部多tab下，对应多个Flutter Fragment的操作。又遇到一个比较坑的问题:FlutterFragment中的flutter页面的SafeArea失效（关于safeArea具体介绍参考官方<a href=\"https://api.flutter.dev/flutter/widgets/SafeArea-class.html\">SafeArea class</a>），简单举例说一下SafeArea的作用：如果你有一刘海屏的手机，如果你的flutter内容为全屏，假如你的内容在全屏最顶部，那么所谓的刘海将会盖住你所想要的内容，如下图所示：</p>\n<img width=\"50%\" src=\"https://cdn.julis.wang/blog/img/2020110113363517.png\">\n<p>这当然不是我们想要的，于是Flutter官方推出：SafeArea这个属性，在dart语言中只需要在你的widget最外层包裹SafeArea就好了。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@override</span></span><br><span class=\"line\">Widget <span class=\"title function_\">build</span><span class=\"params\">(BuildContext context)</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> Scaffold(</span><br><span class=\"line\">    body: SafeArea(</span><br><span class=\"line\">      child: TabBarView(</span><br><span class=\"line\">        controller: mController,</span><br><span class=\"line\">        children: &lt;Widget&gt;[]</span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>于是得到了正确的展示效果，如下图所示：</p>\n<img width=\"50%\" src=\"https://cdn.julis.wang/blog/img/20201101134229321.png\">\n<p>你以为这样就完了么？在多个Flutter Fragment中SafeArea的作用失效，尽管我在flutter中设置了SafeArea，但依然存在刘海盖住flutter content的情况。</p>\n<h1 id=\"原因分析：\"><a href=\"#原因分析：\" class=\"headerlink\" title=\"原因分析：\"></a>原因分析：</h1><p>这真的是一件很头疼的事情，对应的Flutter page在Flutter Activity中能够正常work，但是偏偏在Fluttter Fragment中就出问题了呢？于是又去看FlutterView源码，果然有收获！发现一个方法：<code>onApplyWindowInsets()</code>这里面有一大堆逻辑，很多都是关于处理 statusBar以及navigationBar，更惊喜地还发现了处理<a href=\"https://developer.android.google.cn/reference/android/view/DisplayCutout?hl=zh-cn\">DisplayCutout</a>的逻辑，这不就是刘海屏相关的类么！以下是部分代码逻辑：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> WindowInsets <span class=\"title function_\">onApplyWindowInsets</span><span class=\"params\">(WindowInsets insets)</span> &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">   <span class=\"keyword\">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.R) &#123;</span><br><span class=\"line\">     <span class=\"type\">int</span> <span class=\"variable\">mask</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">     <span class=\"keyword\">if</span> (navigationBarVisible) &#123;</span><br><span class=\"line\">       mask = mask | android.view.WindowInsets.Type.navigationBars();</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">     <span class=\"keyword\">if</span> (statusBarVisible) &#123;</span><br><span class=\"line\">       mask = mask | android.view.WindowInsets.Type.statusBars();</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">     <span class=\"comment\">// TODO(garyq): Expose the full rects of the display cutout.</span></span><br><span class=\"line\">     <span class=\"comment\">// Take the max of the display cutout insets and existing padding to merge them</span></span><br><span class=\"line\">     <span class=\"type\">DisplayCutout</span> <span class=\"variable\">cutout</span> <span class=\"operator\">=</span> insets.getDisplayCutout();</span><br><span class=\"line\">     <span class=\"keyword\">if</span> (cutout != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">       <span class=\"type\">Insets</span> <span class=\"variable\">waterfallInsets</span> <span class=\"operator\">=</span> cutout.getWaterfallInsets();</span><br><span class=\"line\">       mMetrics.physicalPaddingTop =</span><br><span class=\"line\">           Math.max(</span><br><span class=\"line\">               Math.max(mMetrics.physicalPaddingTop, waterfallInsets.top),</span><br><span class=\"line\">               cutout.getSafeInsetTop());</span><br><span class=\"line\">      ...</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">   &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">     <span class=\"comment\">// Status bar (top) and left/right system insets should partially obscure the content</span></span><br><span class=\"line\">     <span class=\"comment\">// (padding).</span></span><br><span class=\"line\">   ...</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   updateViewportMetrics();</span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"built_in\">super</span>.onApplyWindowInsets(insets);</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n<p>很明显这一块逻辑是处理刘海屏以及StatusBar相关的逻辑，于是进行相关的断点调试，发现FlutterFragment中的FlutterView的确是没有执行这个方法，对比同样在FlutterActivity中的FlutterView正常work并执行了这一串代码。</p>\n<p>！那这不就神奇了么？这一下子又让人头秃了，这一定又是跟Fragment的相关机制导致的，自己对Fragment的具体处理逻辑不太熟，于是各种Google，找到两篇有点类似的答案：<br><a href=\"https://stackoverflow.com/questions/31190612/fitssystemwindows-effect-gone-for-fragments-added-via-fragmenttransaction\">1、fitsSystemWindows effect gone for fragments added via FragmentTransaction</a><br><a href=\"https://blog.csdn.net/qq_35054800/article/details/82107053?utm_source=copy\">2、一个Activity中添加多个Fragment导致fitsSystemWindows无效的问题</a></p>\n<p>引入上面的解释说：</p>\n<blockquote>\n<p>当第一个Fragment添加到Activity中的时候，Activity寻找出有fitsSystemWindows的子布局为其预留出状态栏的空间，其实就是设置一个padding，而其他Fragment添加到Activity中的时候，因为状态栏空间的适配已经被消费过一次了，Activity并不会再次去添加这个padding</p>\n</blockquote>\n<p>虽然这里在进行fitsSystemWindows的操作，但是我们明确了一件事情：添加多个Fragment的时候，Activity对于padding相关操作只在第一个Fragment进行了相关处理逻辑。那么对应我们的FlutterFragment是否是同样的问题呢？？</p>\n<p>于是我进行了尝试，将Flutter Fragment放在Acitvity第一个需要展示的Fragment，经过尝试发现第一个FlutterFragment能正常work了！但之后的Flutter Fragment问题依然存在，那么我们可以肯定也就是说：<br><strong>在多FlutterFragment中的FlutterView，只有在作为Acitivty添加为第一个Fragment的情况下才会去调用 <code> onApplyWindowInsets(WindowInsets insets)</code> 方法去处理一些statusBar相关的操作逻辑。</strong><br>的确事实如此，经过尝试之后发现的确只会调用一次，那么如何解决呢？</p>\n<h1 id=\"解决方案：\"><a href=\"#解决方案：\" class=\"headerlink\" title=\"解决方案：\"></a>解决方案：</h1><p>参照上面的解决方案，可以写一个WindowInsetsFrameLayout继承FrameLayout，并<code>setOnHierarchyChangeListener()</code>监听Fragment的添加操作，在添加的时候执行 view的requestApplyInsets();</p>\n<p>当然对于我们的问题并没有这么麻烦，我们在自己的FlutterFragment中手动去执行flutterView.requestApplyInsets();只需要执行时机保证在flutter渲染之前执行（Safe Area通过获去Native端onApplyWindowInsets()中传过去的params来执行相关渲染）</p>\n<p>但还有一个问题：<code>flutterView.requestApplyInsets();</code>只能在Api大于20中使用，那么低于20呢？与其说低于20，不如直接说，19中怎么处理（Android 4.4 api 19引入的透明状态栏 、沉浸式相关），我们可以看到，在onApplyWindowInsets() 中最终是发送一个事件到flutter端，如下代码所示。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">sendViewportMetricsToFlutter</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!isAttachedToFlutterEngine()) &#123;</span><br><span class=\"line\">    Log.w(</span><br><span class=\"line\">        TAG,</span><br><span class=\"line\">        <span class=\"string\">&quot;Tried to send viewport metrics from Android to Flutter but this &quot;</span></span><br><span class=\"line\">            + <span class=\"string\">&quot;FlutterView was not attached to a FlutterEngine.&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  viewportMetrics.devicePixelRatio = getResources().getDisplayMetrics().density;</span><br><span class=\"line\">  flutterEngine.getRenderer().setViewportMetrics(viewportMetrics);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>那么对于Api 19就可以对相关数据进行反射调用，之后再讲数据发送到flutter端即可，那么大致逻辑如下所示：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">onViewCreated</span><span class=\"params\">(<span class=\"meta\">@NonNull</span> View view, <span class=\"meta\">@Nullable</span> Bundle savedInstanceState)</span> &#123;</span><br><span class=\"line\">     <span class=\"built_in\">super</span>.onViewCreated(view, savedInstanceState);</span><br><span class=\"line\">     <span class=\"keyword\">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.KITKAT_WATCH) &#123;</span><br><span class=\"line\">         flutterView.requestApplyInsets();</span><br><span class=\"line\">     &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">         adapterStatusBarBelowApi20();</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"总结：\"><a href=\"#总结：\" class=\"headerlink\" title=\"总结：\"></a>总结：</h1><p>1、这个问题在官方的FlutterFragment中也存在，但不知道为什么没有修复，可能他们真的不太重视混合开发吧，一心在纯flutter开发中。<br>2、关于为什么Fragment 相关操作逻辑只在第一个被Fragment被添加，这里涉及到了太多底层的东西，这里没有赘述，打算深入研究，写一篇新到blog中去介绍。<br>3、Flutter坑实在是太多了，很多问题都与Android原生机制相关，这不得不让人对原生系统机制进行深入学习。</p>\n","categories":[{"name":"技术文章","slug":"technology","api":"api/categories/technology.json"}],"tags":[{"name":"Flutter","slug":"Flutter","api":"api/tags/Flutter.json"}],"api":"api/posts/2020/10/31/Flutter坑之FlutterFragment中SafeArea失效的问题.json"},{"title":"Flutter坑之共享FlutterEngine页面切换无法点击","slug":"Flutter坑之共享FlutterEngine页面切换无法点击","date":"2020-09-21T11:22:00.000Z","updated":"2025-05-20T11:46:57.000Z","comments":true,"url":"2020/09/21/Flutter坑之共享FlutterEngine页面切换无法点击/","excerpt":"<p>最近在研究做Flutter一块相关的内容，方案上采用的是单FlutterEngine，全局Flutter元素共用一个FlutterEngine，对于使用单Engine遇到一个很大的坑，页面切换之后无法点击，页面就像卡死了一样，以下三种情况都会发生：</p>\n<p>第一种：两个FlutterFragment在tab中进行切换，假如AB代表两个FlutterFragment，当A切换到B，再从B切换到A的时候，页面就无法点击。</p>\n<p>第二种：在FlutterActivity中打开新的FlutterActivity，新的FlutterActivity页面跟上述的情况一样，也是无法点击。</p>\n<p>第三种：在Tab中打开FlutterFragment之后再打开FlutterActivity，情况一样，依然无法点击。</p>\n<p>如下动图所示：</p>\n<img src=\"https://cdn.julis.wang/blog/img/20200921223629331.gif\">\n<p>（来自issue <a href=\"https://github.com/flutter/flutter/issues/49950%EF%BC%89\">https://github.com/flutter/flutter/issues/49950）</a></p>\n<p>但他们有一个共同的特点：当页面卡死的时候，手动进入后台（打开任务管理或者home键退出）再回到前台，页面就会“刷新”，一切又变得正常了。那么推测：多半与跟页面Fragment和Activity的生命周期有关。我尝试了在进入页面后,再手动模拟“页面退出再回来的周期”，也就是先调用一次<code>onPause()</code>再调用一次<code>onResume()</code>，然而并没有什么卵用……</p>\n<img src=\"https://cdn.julis.wang/blog/img/20200921223648282.gif\">\n<p>可这是为什么呢？？太坑了……踏遍了千山万水也没有找到有人有解决方案，很多人都说别用共享引擎，但是想到 闲鱼Flutter_boost 和HelloBike的thrio框架也都是用的共享引擎啊，他们为什么没有问题？找了很久的解决方法，两天，甚至晚上做梦都梦在关于这个问题。真的是……难受。加了各种各样的群，也没有人能解答这个问题。终于……我去打印了两个Activity的生命周期，才发现事情的端倪。</p>\n<h3 id=\"关于Activity与Fragment的切换的生命周期\"><a href=\"#关于Activity与Fragment的切换的生命周期\" class=\"headerlink\" title=\"关于Activity与Fragment的切换的生命周期\"></a><strong>关于Activity与Fragment的切换的生命周期</strong></h3><p>这里向大家在简单介绍一下Activity和Fragment切换生命周期，相信大家都有被面试问过：现在有两个Activity A和B，在A打开B这一段时间Activity的生命周期变化情况：</p>\n<h6 id=\"A-onPause-B-onCreate-B-onStart-B-onResume-A-onStop\"><a href=\"#A-onPause-B-onCreate-B-onStart-B-onResume-A-onStop\" class=\"headerlink\" title=\"A.onPause() -&gt;B.onCreate()-&gt; B.onStart() -&gt;B.onResume() -&gt;A.onStop()\"></a>A.onPause() -&gt;B.onCreate()-&gt; B.onStart() -&gt;B.onResume() -&gt;A.onStop()</h6><p>A的onStop() 的调用情况分为两种：当设置Activity A的主题windowIsTranslucent属性为true，A Activity并不会调用onStop方法，只会调用onPause()方法。</p>\n<p>ok说完了Activity再说说Fragment，对于我们的问题：Fragment生命周期考虑tab间切换（也就是两个FlutterFragment之间的切换），两个Fragment的切换，并不会导致Fragment的onPause()和onStop()调用，只会调用<code>onHiddenChanged(boolean hidden)</code>，hiden为true表示该Fragment被隐藏了，false表示当前Fragment可见。</p>\n<h3 id=\"关于Flutter单Engine方案\"><a href=\"#关于Flutter单Engine方案\" class=\"headerlink\" title=\"关于Flutter单Engine方案\"></a><strong>关于Flutter单Engine方案</strong></h3><p>现在关于讲解Flutter单Engine方案也比较多，推荐去看这篇–&gt; <a href=\"https://zhuanlan.zhihu.com/p/38026271\">为追求高性能，我必须告诉你Flutter引擎线程的事实…</a> 关于对单Engine的讲解，单Engine方案，我们可以简单理解为：**所有应用中的FlutterView都是由同一个FlutterEngine来渲染的。**当然这看起来是废话，但这就是问题的关键，那么对于所有的FlutterView都是用的同一个FlutterEngine渲染，那么FlutterEngine是怎么去控制的呢？如果让你去设计，你会怎么设计呢？</p>\n<p>这篇博客–&gt;<a href=\"https://cloud.tencent.com/developer/article/1568737\">flutter单引擎方案</a>讲解了一种单Engine的实现方案，可以参考，不过其中也需要对Engine进行多次new，不过这并不是最重要的，我们需要明白的是：<strong>当FlutterEngine去渲染FlutterView B的时候，它需要attach再在B上，从FlutterView A detach掉，再返回FlutterView A的时候，它需要从FlutterView B上detach掉，再attach到A上。</strong></p>\n<h3 id=\"Flutter坑！\"><a href=\"#Flutter坑！\" class=\"headerlink\" title=\"Flutter坑！\"></a><strong>Flutter坑！</strong></h3><p>现在我们明白了生命周期的变化，我们接下来去看FlutterActivity中响应生命周期中的源码。对于FlutterActivity A打开FlutterActivity B，他们依次会调用：</p>\n<h6 id=\"A-onPause-B-onCreate-B-onStart-B-onResume-A-onStop-1\"><a href=\"#A-onPause-B-onCreate-B-onStart-B-onResume-A-onStop-1\" class=\"headerlink\" title=\"A.onPause() -&gt;B.onCreate()-&gt; B.onStart() -&gt;B.onResume() -&gt;A.onStop()\"></a>A.onPause() -&gt;B.onCreate()-&gt; B.onStart() -&gt;B.onResume() -&gt;A.onStop()</h6><p>我们来看看FlutterActivity在对应的生命周期里面做了什么,</p>\n<p>对于<strong>A.onPause()</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title function_\">onPause</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">super</span>.onPause();</span><br><span class=\"line\">  delegate.onPause();</span><br><span class=\"line\">  lifecycle.handleLifecycleEvent(Lifecycle.Event.ON_PAUSE);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们知道：FlutterActivity和Fragment主要由FlutterActivityAndFragmentDelegate来进行管理，这里我们主要关注delegate里面的内容</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> <span class=\"title function_\">onPause</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">  Log.v(TAG, <span class=\"string\">&quot;onPause()&quot;</span>);</span><br><span class=\"line\">  ensureAlive();</span><br><span class=\"line\">  flutterEngine.getLifecycleChannel().appIsInactive();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里是关键我们看到了flutterEngine与生命周期相关的代码，接下来我们看其他几个生命周期里面对于flutterEngine的Lifecycle管理情况</p>\n<p>对于**B.onCreate()**只进行了相关的view创建工作.</p>\n<p>对于**B.onStart()**中有执行<code>doInitialFlutterViewRun();</code>，其中比较关键的一句就是：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">if (host.getInitialRoute() != null) &#123;</span><br><span class=\"line\">  flutterEngine.getNavigationChannel().setInitialRoute(host.getInitialRoute());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>对于<strong>B.onResume()</strong> </p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> <span class=\"title function_\">onResume</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">  Log.v(TAG, <span class=\"string\">&quot;onResume()&quot;</span>);</span><br><span class=\"line\">  ensureAlive();</span><br><span class=\"line\">  flutterEngine.getLifecycleChannel().appIsResumed();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>最后是<strong>A.onStop()</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> <span class=\"title function_\">onStop</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">  Log.v(TAG, <span class=\"string\">&quot;onStop()&quot;</span>);</span><br><span class=\"line\">  ensureAlive();</span><br><span class=\"line\">  flutterEngine.getLifecycleChannel().appIsPaused();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>看到了A.onStop()，聪明的人应该都看出来问题了，我们重新整理一下从Activity A启动到B，flutterEngine相关的生命周期主要执行了以下流程：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">A.onPause() -&gt; flutterEngine.getLifecycleChannel().appIsInactive()</span><br><span class=\"line\"></span><br><span class=\"line\">B.onCreate()-&gt;  nothing.</span><br><span class=\"line\"></span><br><span class=\"line\">B.onStart() -&gt; flutterEngine.getNavigationChannel().setInitialRoute(host.getInitialRoute());</span><br><span class=\"line\"></span><br><span class=\"line\">B.onResume() -&gt; flutterEngine.getLifecycleChannel().appIsResumed();</span><br><span class=\"line\"></span><br><span class=\"line\">A.onStop()-&gt; flutterEngine.getLifecycleChannel().appIsPaused();</span><br></pre></td></tr></table></figure>\n\n<p>其实问题已经出来了：<strong>由于我们使用的是单FlutterEngine方案，那么上面生命周期中的flutterEngine为同一实例！</strong>，由于Activity的生命周期机制，前一个Activity的生命周期的onStop是在最后调用的，也就是这时候告诉了FlutterEngine: 这时候appIsPaused，你不用在渲染了，那么这时页面就会成一种“卡死”的状态！正常的生命周期这时候FlutterEngine应该是appIsResumed()。这也就能解释为什么退出到后台（调用了onPause()）再回来（调用onResume()）最终的FlutterEngine是调用了.appIsResumed();显示正常。</p>\n<p>于是找到问题了，那么如何解决呢？这还不简单，当然是去绕过不用去调用A.onStop()呀！怎么可能不用调用A.onStop() 呢？错了，不用去调用其中的delegate中的flutterEngine.getLifecycleChannel().appIsPaused();就好了，我这边的方案与Flutter_boost的方案一样，也对FlutterActivty的代码进行了重写，所以能比较灵活的去改动FlutterActivityAndFragmentDelegate。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> <span class=\"title function_\">onStop</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">  Log.v(TAG, <span class=\"string\">&quot;onStop()&quot;</span>);</span><br><span class=\"line\">  ensureAlive();</span><br><span class=\"line\">  <span class=\"comment\">// flutterEngine.getLifecycleChannel().appIsPaused();</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>对于Fragment的切换也是同样一个思路，就留着大家想一下吧。</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a><strong>总结</strong></h3><p>1、Activity A切换到B的生命周期（A不透明的情况下）：A.onPause() -&gt;B.onCreate()-&gt; B.onStart() -&gt;B.onResume() -&gt;A.onStop()</p>\n<p>2、至于flutterEngine.getLifecycleChannel().appIsPaused();内部具体做了什么事，还得具体去研究一下，字面上理解就是。</p>\n<p>3、Flutter混合原生做开发坑实在是太多了，官方也没有做相应的解决方案，有什么问题，一定要大胆的想，大胆的去尝试！</p>\n","cover":null,"images":["https://cdn.julis.wang/blog/img/20200921223629331.gif","https://cdn.julis.wang/blog/img/20200921223648282.gif"],"content":"<p>最近在研究做Flutter一块相关的内容，方案上采用的是单FlutterEngine，全局Flutter元素共用一个FlutterEngine，对于使用单Engine遇到一个很大的坑，页面切换之后无法点击，页面就像卡死了一样，以下三种情况都会发生：</p>\n<p>第一种：两个FlutterFragment在tab中进行切换，假如AB代表两个FlutterFragment，当A切换到B，再从B切换到A的时候，页面就无法点击。</p>\n<p>第二种：在FlutterActivity中打开新的FlutterActivity，新的FlutterActivity页面跟上述的情况一样，也是无法点击。</p>\n<p>第三种：在Tab中打开FlutterFragment之后再打开FlutterActivity，情况一样，依然无法点击。</p>\n<p>如下动图所示：</p>\n<img src=\"https://cdn.julis.wang/blog/img/20200921223629331.gif\">\n<p>（来自issue <a href=\"https://github.com/flutter/flutter/issues/49950%EF%BC%89\">https://github.com/flutter/flutter/issues/49950）</a></p>\n<p>但他们有一个共同的特点：当页面卡死的时候，手动进入后台（打开任务管理或者home键退出）再回到前台，页面就会“刷新”，一切又变得正常了。那么推测：多半与跟页面Fragment和Activity的生命周期有关。我尝试了在进入页面后,再手动模拟“页面退出再回来的周期”，也就是先调用一次<code>onPause()</code>再调用一次<code>onResume()</code>，然而并没有什么卵用……</p>\n<img src=\"https://cdn.julis.wang/blog/img/20200921223648282.gif\">\n<p>可这是为什么呢？？太坑了……踏遍了千山万水也没有找到有人有解决方案，很多人都说别用共享引擎，但是想到 闲鱼Flutter_boost 和HelloBike的thrio框架也都是用的共享引擎啊，他们为什么没有问题？找了很久的解决方法，两天，甚至晚上做梦都梦在关于这个问题。真的是……难受。加了各种各样的群，也没有人能解答这个问题。终于……我去打印了两个Activity的生命周期，才发现事情的端倪。</p>\n<h3 id=\"关于Activity与Fragment的切换的生命周期\"><a href=\"#关于Activity与Fragment的切换的生命周期\" class=\"headerlink\" title=\"关于Activity与Fragment的切换的生命周期\"></a><strong>关于Activity与Fragment的切换的生命周期</strong></h3><p>这里向大家在简单介绍一下Activity和Fragment切换生命周期，相信大家都有被面试问过：现在有两个Activity A和B，在A打开B这一段时间Activity的生命周期变化情况：</p>\n<h6 id=\"A-onPause-B-onCreate-B-onStart-B-onResume-A-onStop\"><a href=\"#A-onPause-B-onCreate-B-onStart-B-onResume-A-onStop\" class=\"headerlink\" title=\"A.onPause() -&gt;B.onCreate()-&gt; B.onStart() -&gt;B.onResume() -&gt;A.onStop()\"></a>A.onPause() -&gt;B.onCreate()-&gt; B.onStart() -&gt;B.onResume() -&gt;A.onStop()</h6><p>A的onStop() 的调用情况分为两种：当设置Activity A的主题windowIsTranslucent属性为true，A Activity并不会调用onStop方法，只会调用onPause()方法。</p>\n<p>ok说完了Activity再说说Fragment，对于我们的问题：Fragment生命周期考虑tab间切换（也就是两个FlutterFragment之间的切换），两个Fragment的切换，并不会导致Fragment的onPause()和onStop()调用，只会调用<code>onHiddenChanged(boolean hidden)</code>，hiden为true表示该Fragment被隐藏了，false表示当前Fragment可见。</p>\n<h3 id=\"关于Flutter单Engine方案\"><a href=\"#关于Flutter单Engine方案\" class=\"headerlink\" title=\"关于Flutter单Engine方案\"></a><strong>关于Flutter单Engine方案</strong></h3><p>现在关于讲解Flutter单Engine方案也比较多，推荐去看这篇–&gt; <a href=\"https://zhuanlan.zhihu.com/p/38026271\">为追求高性能，我必须告诉你Flutter引擎线程的事实…</a> 关于对单Engine的讲解，单Engine方案，我们可以简单理解为：**所有应用中的FlutterView都是由同一个FlutterEngine来渲染的。**当然这看起来是废话，但这就是问题的关键，那么对于所有的FlutterView都是用的同一个FlutterEngine渲染，那么FlutterEngine是怎么去控制的呢？如果让你去设计，你会怎么设计呢？</p>\n<p>这篇博客–&gt;<a href=\"https://cloud.tencent.com/developer/article/1568737\">flutter单引擎方案</a>讲解了一种单Engine的实现方案，可以参考，不过其中也需要对Engine进行多次new，不过这并不是最重要的，我们需要明白的是：<strong>当FlutterEngine去渲染FlutterView B的时候，它需要attach再在B上，从FlutterView A detach掉，再返回FlutterView A的时候，它需要从FlutterView B上detach掉，再attach到A上。</strong></p>\n<h3 id=\"Flutter坑！\"><a href=\"#Flutter坑！\" class=\"headerlink\" title=\"Flutter坑！\"></a><strong>Flutter坑！</strong></h3><p>现在我们明白了生命周期的变化，我们接下来去看FlutterActivity中响应生命周期中的源码。对于FlutterActivity A打开FlutterActivity B，他们依次会调用：</p>\n<h6 id=\"A-onPause-B-onCreate-B-onStart-B-onResume-A-onStop-1\"><a href=\"#A-onPause-B-onCreate-B-onStart-B-onResume-A-onStop-1\" class=\"headerlink\" title=\"A.onPause() -&gt;B.onCreate()-&gt; B.onStart() -&gt;B.onResume() -&gt;A.onStop()\"></a>A.onPause() -&gt;B.onCreate()-&gt; B.onStart() -&gt;B.onResume() -&gt;A.onStop()</h6><p>我们来看看FlutterActivity在对应的生命周期里面做了什么,</p>\n<p>对于<strong>A.onPause()</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title function_\">onPause</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">super</span>.onPause();</span><br><span class=\"line\">  delegate.onPause();</span><br><span class=\"line\">  lifecycle.handleLifecycleEvent(Lifecycle.Event.ON_PAUSE);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们知道：FlutterActivity和Fragment主要由FlutterActivityAndFragmentDelegate来进行管理，这里我们主要关注delegate里面的内容</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> <span class=\"title function_\">onPause</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">  Log.v(TAG, <span class=\"string\">&quot;onPause()&quot;</span>);</span><br><span class=\"line\">  ensureAlive();</span><br><span class=\"line\">  flutterEngine.getLifecycleChannel().appIsInactive();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里是关键我们看到了flutterEngine与生命周期相关的代码，接下来我们看其他几个生命周期里面对于flutterEngine的Lifecycle管理情况</p>\n<p>对于**B.onCreate()**只进行了相关的view创建工作.</p>\n<p>对于**B.onStart()**中有执行<code>doInitialFlutterViewRun();</code>，其中比较关键的一句就是：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">if (host.getInitialRoute() != null) &#123;</span><br><span class=\"line\">  flutterEngine.getNavigationChannel().setInitialRoute(host.getInitialRoute());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>对于<strong>B.onResume()</strong> </p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> <span class=\"title function_\">onResume</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">  Log.v(TAG, <span class=\"string\">&quot;onResume()&quot;</span>);</span><br><span class=\"line\">  ensureAlive();</span><br><span class=\"line\">  flutterEngine.getLifecycleChannel().appIsResumed();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>最后是<strong>A.onStop()</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> <span class=\"title function_\">onStop</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">  Log.v(TAG, <span class=\"string\">&quot;onStop()&quot;</span>);</span><br><span class=\"line\">  ensureAlive();</span><br><span class=\"line\">  flutterEngine.getLifecycleChannel().appIsPaused();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>看到了A.onStop()，聪明的人应该都看出来问题了，我们重新整理一下从Activity A启动到B，flutterEngine相关的生命周期主要执行了以下流程：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">A.onPause() -&gt; flutterEngine.getLifecycleChannel().appIsInactive()</span><br><span class=\"line\"></span><br><span class=\"line\">B.onCreate()-&gt;  nothing.</span><br><span class=\"line\"></span><br><span class=\"line\">B.onStart() -&gt; flutterEngine.getNavigationChannel().setInitialRoute(host.getInitialRoute());</span><br><span class=\"line\"></span><br><span class=\"line\">B.onResume() -&gt; flutterEngine.getLifecycleChannel().appIsResumed();</span><br><span class=\"line\"></span><br><span class=\"line\">A.onStop()-&gt; flutterEngine.getLifecycleChannel().appIsPaused();</span><br></pre></td></tr></table></figure>\n\n<p>其实问题已经出来了：<strong>由于我们使用的是单FlutterEngine方案，那么上面生命周期中的flutterEngine为同一实例！</strong>，由于Activity的生命周期机制，前一个Activity的生命周期的onStop是在最后调用的，也就是这时候告诉了FlutterEngine: 这时候appIsPaused，你不用在渲染了，那么这时页面就会成一种“卡死”的状态！正常的生命周期这时候FlutterEngine应该是appIsResumed()。这也就能解释为什么退出到后台（调用了onPause()）再回来（调用onResume()）最终的FlutterEngine是调用了.appIsResumed();显示正常。</p>\n<p>于是找到问题了，那么如何解决呢？这还不简单，当然是去绕过不用去调用A.onStop()呀！怎么可能不用调用A.onStop() 呢？错了，不用去调用其中的delegate中的flutterEngine.getLifecycleChannel().appIsPaused();就好了，我这边的方案与Flutter_boost的方案一样，也对FlutterActivty的代码进行了重写，所以能比较灵活的去改动FlutterActivityAndFragmentDelegate。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> <span class=\"title function_\">onStop</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">  Log.v(TAG, <span class=\"string\">&quot;onStop()&quot;</span>);</span><br><span class=\"line\">  ensureAlive();</span><br><span class=\"line\">  <span class=\"comment\">// flutterEngine.getLifecycleChannel().appIsPaused();</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>对于Fragment的切换也是同样一个思路，就留着大家想一下吧。</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a><strong>总结</strong></h3><p>1、Activity A切换到B的生命周期（A不透明的情况下）：A.onPause() -&gt;B.onCreate()-&gt; B.onStart() -&gt;B.onResume() -&gt;A.onStop()</p>\n<p>2、至于flutterEngine.getLifecycleChannel().appIsPaused();内部具体做了什么事，还得具体去研究一下，字面上理解就是。</p>\n<p>3、Flutter混合原生做开发坑实在是太多了，官方也没有做相应的解决方案，有什么问题，一定要大胆的想，大胆的去尝试！</p>\n","categories":[{"name":"技术文章","slug":"technology","api":"api/categories/technology.json"}],"tags":[{"name":"Flutter","slug":"Flutter","api":"api/tags/Flutter.json"}],"api":"api/posts/2020/09/21/Flutter坑之共享FlutterEngine页面切换无法点击.json"},{"title":"从Android返回键退出和直接杀死进程退出说起","slug":"从Android返回键退出和直接杀死进程退出说起","date":"2020-09-09T01:31:00.000Z","updated":"2025-05-20T11:46:57.000Z","comments":true,"url":"2020/09/09/从Android返回键退出和直接杀死进程退出说起/","excerpt":"<p>最近开发的时候，使用了一个单例模式，当我返回键退出App，再重新启动，发现App的确是从首页启动，但还没有执行为单例类设置数值的位置。可是！断点调试的时候发现这时候已经有了一个数据，并且是上一次运行留下的数据，当时觉得很神奇，明明根Activity已经执行了OnDestroy()，而且再启动的确是从首页过来的，讲道理应该是“everything will be new”，但是单例里面的数据仍然存在，这可是为什么呢？</p>\n<p>Google搜了一下，噢！恍然大悟，看到这一块的知识很久没有用就忘掉了，或者说对运行机制相关还不太熟悉吧，所以在此重新整理总结一份。</p>\n<h4 id=\"返回键退出和直接杀死进程退出的区别？\"><a href=\"#返回键退出和直接杀死进程退出的区别？\" class=\"headerlink\" title=\"返回键退出和直接杀死进程退出的区别？\"></a>返回键退出和直接杀死进程退出的区别？</h4><p><strong>直接杀死退出</strong>：所有的内存都会被回收，重新启动应用程序时，会重新调用Application的<code>OnCreate()</code>方法，会调用onSaveInstanceState方法。</p>\n<p><strong>返回键退出程序</strong>：退出程序后，一些加载过的静态变量并没有被回收，重新启动也不需要调用Application的OnCreate()方法。</p>\n<p>于是我们就知道，静态变量并没有被回收，而我们的单例模式实例就是静态变量，没有被回收，于是我们就知道为什么单例模式数据还存在了，于是在响应的位置对其数据进行释放。可是 why？这两者的差异究竟是什么导致的？我们要知其然，也要知其所以然。</p>\n<h4 id=\"关于直接杀死进程\"><a href=\"#关于直接杀死进程\" class=\"headerlink\" title=\"关于直接杀死进程\"></a>关于直接杀死进程</h4><p>这里我们应该很好去理解，Android中的每一个App都是运行在自己VM实例之中(沙盒)。每一个VM实例在linux中又是一个单独的进程，通过任务管理杀掉一个进程，那么对应进程里面的数据全部被回收掉。</p>\n<h4 id=\"关于返回键退出\"><a href=\"#关于返回键退出\" class=\"headerlink\" title=\"关于返回键退出\"></a>关于返回键退出</h4><p>通过对源码的追溯，如果不对onBackPressed()做特殊的处理，无论是AppCompatActivity还是android.app.Activity，发现都会通过执行onBackPressed(),最后到Activity的finish()方法，也就是说当App退出到根的时候，最终只是执行的是当前App根Activity的finish()方法，整个App“依然在运行”，只是看不到界面了，那么也就是说，如果在App中运行的Service之类的后台任务并没结束，仍然在运行。</p>\n<p>那为什么单例模里面的静态变量没有回收呢？如果问你的话，你怎么答？emmmmm……因为……它没有被销毁嘛，所以它还在。当然不能这么回答了，需要用理论依据来解释。</p>\n<h4 id=\"关于方法区与静态变量\"><a href=\"#关于方法区与静态变量\" class=\"headerlink\" title=\"关于方法区与静态变量\"></a>关于方法区与静态变量</h4><p>我们知道静态变量存在与JVM的方法区中，静态变量在类被加载的时候分配内存，Java虚拟机规范中说过可以不要求虚拟机在方法区实现垃圾收集，如下图所示：</p>\n<img src=\"https://cdn.julis.wang/blog/img/20200908231258604.png\">\n<p>那么我们是不是可以理解为方法区中不会进行垃圾回收？查到来自《深入理解Java虚拟机》中的解释：</p>\n<blockquote>\n<p>很多人以为方法区（或者HotSopt 虚拟机中的永久代）是没有垃圾收集的，Java虚拟机规范中确实说过可以不要求虚拟机在方法区实现垃圾收集，而且性价比一般较低，在对的新生代生一般能回收70%~95%的空间，而永久代远低于此。</p>\n<p>永久代的垃圾手机主要回收两部分内容：<strong>废弃常量</strong>和<strong>无用的类</strong>。 回收废弃常量与回收Java堆中的对象非常相似。以常量池中字面量的回收为例，若字符串“abc”已经进入常量池中，但当前系统没有任何String对象引用常量池中的“abc”常量，也没有其他地方引用该字面量，若发生内存回收，且必要的话，该“abc”就会被系统清理出常量池。常量池中其他的类（接口）、方法、字段的符号引用与此类似。</p>\n<p>无用的类需要满足3个条件：</p>\n<p>（1）该类所有的实例都已经被回收，即Java堆中不存在该类的任何实例；<br>（2）加载该类的ClassLoader已经被回收；<br>（3）该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</p>\n</blockquote>\n<p>那么对于我们的静态变量来说，如果不是我们手动处理的话设置实例为null的话，或其他操作的话，那么就不会满足上面的条件。那么静态变量会在什么时候被销毁呢？答案很简单了就：**静态变量在类被卸载的时候销毁，类在什么时候被卸载？在进程结束的时候。**那么这也自然能解释我最开始遇到的情况了，返回键返回结束App后进程并没有结束，当下一次再启动App的时候，进程并没有销毁而，因是同一个进程，所以单例中的数据依然存在。</p>\n","cover":null,"images":["https://cdn.julis.wang/blog/img/20200908231258604.png"],"content":"<p>最近开发的时候，使用了一个单例模式，当我返回键退出App，再重新启动，发现App的确是从首页启动，但还没有执行为单例类设置数值的位置。可是！断点调试的时候发现这时候已经有了一个数据，并且是上一次运行留下的数据，当时觉得很神奇，明明根Activity已经执行了OnDestroy()，而且再启动的确是从首页过来的，讲道理应该是“everything will be new”，但是单例里面的数据仍然存在，这可是为什么呢？</p>\n<p>Google搜了一下，噢！恍然大悟，看到这一块的知识很久没有用就忘掉了，或者说对运行机制相关还不太熟悉吧，所以在此重新整理总结一份。</p>\n<h4 id=\"返回键退出和直接杀死进程退出的区别？\"><a href=\"#返回键退出和直接杀死进程退出的区别？\" class=\"headerlink\" title=\"返回键退出和直接杀死进程退出的区别？\"></a>返回键退出和直接杀死进程退出的区别？</h4><p><strong>直接杀死退出</strong>：所有的内存都会被回收，重新启动应用程序时，会重新调用Application的<code>OnCreate()</code>方法，会调用onSaveInstanceState方法。</p>\n<p><strong>返回键退出程序</strong>：退出程序后，一些加载过的静态变量并没有被回收，重新启动也不需要调用Application的OnCreate()方法。</p>\n<p>于是我们就知道，静态变量并没有被回收，而我们的单例模式实例就是静态变量，没有被回收，于是我们就知道为什么单例模式数据还存在了，于是在响应的位置对其数据进行释放。可是 why？这两者的差异究竟是什么导致的？我们要知其然，也要知其所以然。</p>\n<h4 id=\"关于直接杀死进程\"><a href=\"#关于直接杀死进程\" class=\"headerlink\" title=\"关于直接杀死进程\"></a>关于直接杀死进程</h4><p>这里我们应该很好去理解，Android中的每一个App都是运行在自己VM实例之中(沙盒)。每一个VM实例在linux中又是一个单独的进程，通过任务管理杀掉一个进程，那么对应进程里面的数据全部被回收掉。</p>\n<h4 id=\"关于返回键退出\"><a href=\"#关于返回键退出\" class=\"headerlink\" title=\"关于返回键退出\"></a>关于返回键退出</h4><p>通过对源码的追溯，如果不对onBackPressed()做特殊的处理，无论是AppCompatActivity还是android.app.Activity，发现都会通过执行onBackPressed(),最后到Activity的finish()方法，也就是说当App退出到根的时候，最终只是执行的是当前App根Activity的finish()方法，整个App“依然在运行”，只是看不到界面了，那么也就是说，如果在App中运行的Service之类的后台任务并没结束，仍然在运行。</p>\n<p>那为什么单例模里面的静态变量没有回收呢？如果问你的话，你怎么答？emmmmm……因为……它没有被销毁嘛，所以它还在。当然不能这么回答了，需要用理论依据来解释。</p>\n<h4 id=\"关于方法区与静态变量\"><a href=\"#关于方法区与静态变量\" class=\"headerlink\" title=\"关于方法区与静态变量\"></a>关于方法区与静态变量</h4><p>我们知道静态变量存在与JVM的方法区中，静态变量在类被加载的时候分配内存，Java虚拟机规范中说过可以不要求虚拟机在方法区实现垃圾收集，如下图所示：</p>\n<img src=\"https://cdn.julis.wang/blog/img/20200908231258604.png\">\n<p>那么我们是不是可以理解为方法区中不会进行垃圾回收？查到来自《深入理解Java虚拟机》中的解释：</p>\n<blockquote>\n<p>很多人以为方法区（或者HotSopt 虚拟机中的永久代）是没有垃圾收集的，Java虚拟机规范中确实说过可以不要求虚拟机在方法区实现垃圾收集，而且性价比一般较低，在对的新生代生一般能回收70%~95%的空间，而永久代远低于此。</p>\n<p>永久代的垃圾手机主要回收两部分内容：<strong>废弃常量</strong>和<strong>无用的类</strong>。 回收废弃常量与回收Java堆中的对象非常相似。以常量池中字面量的回收为例，若字符串“abc”已经进入常量池中，但当前系统没有任何String对象引用常量池中的“abc”常量，也没有其他地方引用该字面量，若发生内存回收，且必要的话，该“abc”就会被系统清理出常量池。常量池中其他的类（接口）、方法、字段的符号引用与此类似。</p>\n<p>无用的类需要满足3个条件：</p>\n<p>（1）该类所有的实例都已经被回收，即Java堆中不存在该类的任何实例；<br>（2）加载该类的ClassLoader已经被回收；<br>（3）该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</p>\n</blockquote>\n<p>那么对于我们的静态变量来说，如果不是我们手动处理的话设置实例为null的话，或其他操作的话，那么就不会满足上面的条件。那么静态变量会在什么时候被销毁呢？答案很简单了就：**静态变量在类被卸载的时候销毁，类在什么时候被卸载？在进程结束的时候。**那么这也自然能解释我最开始遇到的情况了，返回键返回结束App后进程并没有结束，当下一次再启动App的时候，进程并没有销毁而，因是同一个进程，所以单例中的数据依然存在。</p>\n","categories":[{"name":"技术文章","slug":"technology","api":"api/categories/technology.json"}],"tags":[{"name":"安卓","slug":"Android","api":"api/tags/Android.json"}],"api":"api/posts/2020/09/09/从Android返回键退出和直接杀死进程退出说起.json"},{"title":"基于AndroidVideoCache的预加载","slug":"基于AndroidVideoCache的预加载","date":"2020-07-06T11:09:00.000Z","updated":"2025-05-20T11:46:57.000Z","comments":true,"url":"2020/07/06/基于AndroidVideoCache的预加载/","excerpt":"<p>最近有做需求关于视频缓存，了解到相关的开源库<a href=\"https://www.jianshu.com/p/dfc18278b053\">AndroidVideoCache</a>，\b一款市面上相对比较流行的视频缓存框架，而我想利用该框架进行视频缓存的处理，并且希望能够支持预加载。然而该框架作者在18年就已经停止了维护，所以留下了无限的编程空间给其他程序员，对于视频预加载，只搜到一篇<a href=\"https://www.jianshu.com/p/dfc18278b053\">《AndroidVideoCache源码详解以及改造系列-源码篇》</a>，然而点进该作者的博客列表，说好的预加载呢？？？后面也没有了下文，搜遍全网好像没有做AndroidVideoCache的预加载相关的事情，那么这样子的话……自己干吧。</p>\n<p>首先需要明白AndroidVideoCache的实现原理，推荐查看<a href=\"https://www.jianshu.com/p/4745de02dcdc\">《AndroidVideoCache-视频边播放边缓存的代理策略》</a>这里不再赘述。</p>\n<p>其实预加载的思路很简单，在进行一个播放视频后，再返回接下来需要预加载的视频url，启用后台线程去请求下载数据，不过中间涉及的细节逻辑比较多。</p>\n<h2 id=\"一、实现方案\"><a href=\"#一、实现方案\" class=\"headerlink\" title=\"一、实现方案\"></a>一、实现方案</h2><p>主要逻辑为：</p>\n<p>1、后台开启一个线程去请求并预加载一部分的数据</p>\n<p>2、可能需要预加载的数据大于&gt;1，利用队列先进入的先进行加载，加上前面的条件 使用HandlerThread再适合不过了。</p>\n<p>我们首先定义好需要去处理的任务情况：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">preload</span><span class=\"params\">( String method，Call call)</span> &#123;</span><br><span class=\"line\">       <span class=\"keyword\">switch</span> (method) &#123;</span><br><span class=\"line\">           <span class=\"keyword\">case</span> <span class=\"string\">&quot;addPreloadURL&quot;</span>:</span><br><span class=\"line\">               addPreloadURL(call); <span class=\"comment\">//添加url到预加载队列</span></span><br><span class=\"line\">               <span class=\"keyword\">break</span>;</span><br><span class=\"line\">           <span class=\"keyword\">case</span> <span class=\"string\">&quot;cancelPreloadURLIfNeeded&quot;</span>:</span><br><span class=\"line\">               cancelPreloadURLIfNeeded(call); <span class=\"comment\">//取消对应的url预加载（因为可能是立马需要播放这个视频，那么就不需要预加载了）</span></span><br><span class=\"line\">               <span class=\"keyword\">break</span>;</span><br><span class=\"line\">           <span class=\"keyword\">case</span> <span class=\"string\">&quot;cancelAnyPreloads&quot;</span>: </span><br><span class=\"line\">               cancelAnyPreLoads();<span class=\"comment\">//取消所有的预加载，主要是方便管理任务</span></span><br><span class=\"line\">               <span class=\"keyword\">break</span>;</span><br><span class=\"line\">           <span class=\"keyword\">default</span>:</span><br><span class=\"line\">           </span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n\n<p>那么对于每次的预加载逻辑基本上是这样的方法执行顺序：</p>\n<p> cancelPreloadURLIfNeeded()-&gt;addPreloadURL();   &#x2F;&#x2F;取消对应url加载的任务，因为有可能该url不需要再进行预加载了（参考抖音，当用户瞬间下滑几个视频，那么很多视频就需要跳过了不需要再进行预加载）</p>\n<p> cancelAnyPreLoads()-&gt;addPreloadURL();   &#x2F;&#x2F;取消对应url加载的任务（这时候需要立马播放最新的视频，那么就应该让出网速给该视频），之后再添加新一轮的预加载url。</p>\n<p>接下来具体的处理逻辑VideoPreLoader类，我直接放上所有的代码逻辑吧,为方便观察删除了一部分不太重要的逻辑，其实总体流程也比较简单。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">VideoPreLoader</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> Handler handler;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> HandlerThread handlerThread;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> List&lt;String&gt; cancelList = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"title function_\">VideoPreLoader</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    handlerThread = <span class=\"keyword\">new</span> <span class=\"title class_\">HandlerThread</span>(<span class=\"string\">&quot;VideoPreLoaderThread&quot;</span>);</span><br><span class=\"line\">    handlerThread.start();</span><br><span class=\"line\">    handler = <span class=\"keyword\">new</span> <span class=\"title class_\">Handler</span>(handlerThread.getLooper()) &#123;</span><br><span class=\"line\">      <span class=\"meta\">@Override</span></span><br><span class=\"line\">      <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">handleMessage</span><span class=\"params\">(Message msg)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">super</span>.handleMessage(msg);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">void</span> <span class=\"title function_\">addPreloadURL</span><span class=\"params\">(<span class=\"keyword\">final</span> VideoPreLoadModel data)</span> &#123;</span><br><span class=\"line\">    handler.post(<span class=\"keyword\">new</span> <span class=\"title class_\">Runnable</span>() &#123;</span><br><span class=\"line\">      <span class=\"meta\">@Override</span></span><br><span class=\"line\">      <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        realPreload(data);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">void</span> <span class=\"title function_\">cancelPreloadURLIfNeeded</span><span class=\"params\">(String url)</span> &#123;</span><br><span class=\"line\">    cancelList.add(url);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">void</span> <span class=\"title function_\">cancelAnyPreLoads</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    handler.removeCallbacksAndMessages(<span class=\"literal\">null</span>);</span><br><span class=\"line\">    cancelList.clear();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">realPreload</span><span class=\"params\">(VideoPreLoadModel data)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (data == <span class=\"literal\">null</span> || isCancel(data.originalUrl)) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"type\">HttpURLConnection</span> <span class=\"variable\">conn</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">      <span class=\"type\">URL</span> <span class=\"variable\">myURL</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">URL</span>(data.proxyUrl);</span><br><span class=\"line\">      conn = (HttpURLConnection) myURL.openConnection();</span><br><span class=\"line\">      conn.connect();</span><br><span class=\"line\">      <span class=\"type\">InputStream</span> <span class=\"variable\">is</span> <span class=\"operator\">=</span> conn.getInputStream();</span><br><span class=\"line\">      <span class=\"type\">byte</span>[] buf = <span class=\"keyword\">new</span> <span class=\"title class_\">byte</span>[<span class=\"number\">1024</span>];</span><br><span class=\"line\">      <span class=\"type\">int</span> <span class=\"variable\">downLoadedSize</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">      <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">numRead</span> <span class=\"operator\">=</span> is.read(buf);</span><br><span class=\"line\">        downLoadedSize += numRead;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (downLoadedSize &gt;= data.preLoadBytes || numRead == -<span class=\"number\">1</span>) &#123; <span class=\"comment\">//Reached  preload range or end of Input stream.</span></span><br><span class=\"line\">          <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125; <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>);</span><br><span class=\"line\">      is.close();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ....</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"type\">boolean</span> <span class=\"title function_\">isCancel</span><span class=\"params\">(String url)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (TextUtils.isEmpty(url)) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (String cancelUrl : cancelList) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (cancelUrl.equals(url)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>对于这段代码中其实有“两个”队列，一个是HandlerThread中的队列，熟悉消息机制的同学应该都能明白，内部是一个looper在不断地循环获取消息，当一个消息处理完毕之后才会处理下一个消息。我还定义了一个就是取消队列，因为HandlerThread中的任务我们不太好控制取消具体的任务，所以设置了一个取消队列，当之后的消息再需要执行的时候会首先判断是否是在取消队列里面，这样子就能做到对预加载队列逻辑的控制。</p>\n<h2 id=\"二、关于一些细节问题\"><a href=\"#二、关于一些细节问题\" class=\"headerlink\" title=\"二、关于一些细节问题\"></a>二、关于一些细节问题</h2><p>这样子我们在播放一个视频的时候，只需要传给我们接下来将会播放的视频的URL，我们就能对其预加载并缓存下来，但是会存在其他条件：</p>\n<h5 id=\"预加载的长度？\"><a href=\"#预加载的长度？\" class=\"headerlink\" title=\"预加载的长度？\"></a>预加载的长度？</h5><p>对于视频加载长度，我们很容易想到在视频url请求加入Range在header上面，比如</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">conn.addRequestProperty(<span class=\"string\">&quot;Range&quot;</span>, <span class=\"string\">&quot;0-102400&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n<p>我们只获取前102400 bytes，不用将整个视频全部进行预加载，我有进行这样的尝试，但是实际发现是有坑的。我做了很多尝试，发现不论怎么请求，拿到的 responseCode 虽然是206，但是 还是把数据给全部下载完了，这就有点不科学了！！</p>\n<p>最终去源码中才发现：源码有对range做正则匹配</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">Pattern</span> <span class=\"variable\">RANGE_HEADER_PATTERN</span> <span class=\"operator\">=</span> Pattern.compile(<span class=\"string\">&quot;[R,r]ange:[ ]?bytes=(\\\\d*)-&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"type\">long</span> <span class=\"title function_\">findRangeOffset</span><span class=\"params\">(String request)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">Matcher</span> <span class=\"variable\">matcher</span> <span class=\"operator\">=</span> RANGE_HEADER_PATTERN.matcher(request);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (matcher.find()) &#123;</span><br><span class=\"line\">            <span class=\"type\">String</span> <span class=\"variable\">rangeValue</span> <span class=\"operator\">=</span> matcher.group(<span class=\"number\">1</span>);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> Long.parseLong(rangeValue);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>看清楚了 <strong><em>“[R,r]ange:[ ]?bytes&#x3D;(\\d</em>)-“</strong>* 它只去匹配了前面的的，也就是说 我传入了 0-102400 它最终只当作是：Range：0- 来处理，导致addRequestProperty设置的range实现。坑！不过能理解作者为什么这么做，后面总结会讲到。没有办法只有使用最原始的方法进行判断了：在每次获取inputStream的时候进行判断是否达到预加载的大小，虽然有一定的性能开销，但是不去改源码的话也没有 办法了。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">      <span class=\"type\">int</span> <span class=\"variable\">numRead</span> <span class=\"operator\">=</span> is.read(buf);</span><br><span class=\"line\">      downLoadedSize += numRead;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (downLoadedSize &gt;= data.preLoadBytes || numRead == -<span class=\"number\">1</span>) &#123; <span class=\"comment\">//Reached  preload range or end of Input stream.</span></span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>);</span><br><span class=\"line\">    is.close();</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"三、总结\"><a href=\"#三、总结\" class=\"headerlink\" title=\"三、总结\"></a>三、总结</h2><p>本文主要讲了基于AndroidVideoCache的预加载具体实现原理，以及其中遇到的坑</p>\n<p>1、预加载主要通过HandlerThread去实现后台网络的访问以及缓存的处理逻辑</p>\n<p>2、加入取消队列去控制对应需要取消的任务</p>\n<p>3、对于预加载的size只能通过读取的时候进行判断，没有办法使用range去判断。其实很容易理解作者为什么正则要这样写，因为它只是一个视频缓存框架，主要是用来做“边播边存”，所以每次去进行请求的时候应该都是在原有的缓存之上去进行缓存数据处理，而缓存最终需要处理完的就是 content-size，不需要再去管Range中的结束范围了。</p>\n","cover":null,"images":[],"content":"<p>最近有做需求关于视频缓存，了解到相关的开源库<a href=\"https://www.jianshu.com/p/dfc18278b053\">AndroidVideoCache</a>，\b一款市面上相对比较流行的视频缓存框架，而我想利用该框架进行视频缓存的处理，并且希望能够支持预加载。然而该框架作者在18年就已经停止了维护，所以留下了无限的编程空间给其他程序员，对于视频预加载，只搜到一篇<a href=\"https://www.jianshu.com/p/dfc18278b053\">《AndroidVideoCache源码详解以及改造系列-源码篇》</a>，然而点进该作者的博客列表，说好的预加载呢？？？后面也没有了下文，搜遍全网好像没有做AndroidVideoCache的预加载相关的事情，那么这样子的话……自己干吧。</p>\n<p>首先需要明白AndroidVideoCache的实现原理，推荐查看<a href=\"https://www.jianshu.com/p/4745de02dcdc\">《AndroidVideoCache-视频边播放边缓存的代理策略》</a>这里不再赘述。</p>\n<p>其实预加载的思路很简单，在进行一个播放视频后，再返回接下来需要预加载的视频url，启用后台线程去请求下载数据，不过中间涉及的细节逻辑比较多。</p>\n<h2 id=\"一、实现方案\"><a href=\"#一、实现方案\" class=\"headerlink\" title=\"一、实现方案\"></a>一、实现方案</h2><p>主要逻辑为：</p>\n<p>1、后台开启一个线程去请求并预加载一部分的数据</p>\n<p>2、可能需要预加载的数据大于&gt;1，利用队列先进入的先进行加载，加上前面的条件 使用HandlerThread再适合不过了。</p>\n<p>我们首先定义好需要去处理的任务情况：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">preload</span><span class=\"params\">( String method，Call call)</span> &#123;</span><br><span class=\"line\">       <span class=\"keyword\">switch</span> (method) &#123;</span><br><span class=\"line\">           <span class=\"keyword\">case</span> <span class=\"string\">&quot;addPreloadURL&quot;</span>:</span><br><span class=\"line\">               addPreloadURL(call); <span class=\"comment\">//添加url到预加载队列</span></span><br><span class=\"line\">               <span class=\"keyword\">break</span>;</span><br><span class=\"line\">           <span class=\"keyword\">case</span> <span class=\"string\">&quot;cancelPreloadURLIfNeeded&quot;</span>:</span><br><span class=\"line\">               cancelPreloadURLIfNeeded(call); <span class=\"comment\">//取消对应的url预加载（因为可能是立马需要播放这个视频，那么就不需要预加载了）</span></span><br><span class=\"line\">               <span class=\"keyword\">break</span>;</span><br><span class=\"line\">           <span class=\"keyword\">case</span> <span class=\"string\">&quot;cancelAnyPreloads&quot;</span>: </span><br><span class=\"line\">               cancelAnyPreLoads();<span class=\"comment\">//取消所有的预加载，主要是方便管理任务</span></span><br><span class=\"line\">               <span class=\"keyword\">break</span>;</span><br><span class=\"line\">           <span class=\"keyword\">default</span>:</span><br><span class=\"line\">           </span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n\n<p>那么对于每次的预加载逻辑基本上是这样的方法执行顺序：</p>\n<p> cancelPreloadURLIfNeeded()-&gt;addPreloadURL();   &#x2F;&#x2F;取消对应url加载的任务，因为有可能该url不需要再进行预加载了（参考抖音，当用户瞬间下滑几个视频，那么很多视频就需要跳过了不需要再进行预加载）</p>\n<p> cancelAnyPreLoads()-&gt;addPreloadURL();   &#x2F;&#x2F;取消对应url加载的任务（这时候需要立马播放最新的视频，那么就应该让出网速给该视频），之后再添加新一轮的预加载url。</p>\n<p>接下来具体的处理逻辑VideoPreLoader类，我直接放上所有的代码逻辑吧,为方便观察删除了一部分不太重要的逻辑，其实总体流程也比较简单。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">VideoPreLoader</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> Handler handler;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> HandlerThread handlerThread;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> List&lt;String&gt; cancelList = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"title function_\">VideoPreLoader</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    handlerThread = <span class=\"keyword\">new</span> <span class=\"title class_\">HandlerThread</span>(<span class=\"string\">&quot;VideoPreLoaderThread&quot;</span>);</span><br><span class=\"line\">    handlerThread.start();</span><br><span class=\"line\">    handler = <span class=\"keyword\">new</span> <span class=\"title class_\">Handler</span>(handlerThread.getLooper()) &#123;</span><br><span class=\"line\">      <span class=\"meta\">@Override</span></span><br><span class=\"line\">      <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">handleMessage</span><span class=\"params\">(Message msg)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">super</span>.handleMessage(msg);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">void</span> <span class=\"title function_\">addPreloadURL</span><span class=\"params\">(<span class=\"keyword\">final</span> VideoPreLoadModel data)</span> &#123;</span><br><span class=\"line\">    handler.post(<span class=\"keyword\">new</span> <span class=\"title class_\">Runnable</span>() &#123;</span><br><span class=\"line\">      <span class=\"meta\">@Override</span></span><br><span class=\"line\">      <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        realPreload(data);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">void</span> <span class=\"title function_\">cancelPreloadURLIfNeeded</span><span class=\"params\">(String url)</span> &#123;</span><br><span class=\"line\">    cancelList.add(url);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">void</span> <span class=\"title function_\">cancelAnyPreLoads</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    handler.removeCallbacksAndMessages(<span class=\"literal\">null</span>);</span><br><span class=\"line\">    cancelList.clear();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">realPreload</span><span class=\"params\">(VideoPreLoadModel data)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (data == <span class=\"literal\">null</span> || isCancel(data.originalUrl)) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"type\">HttpURLConnection</span> <span class=\"variable\">conn</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">      <span class=\"type\">URL</span> <span class=\"variable\">myURL</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">URL</span>(data.proxyUrl);</span><br><span class=\"line\">      conn = (HttpURLConnection) myURL.openConnection();</span><br><span class=\"line\">      conn.connect();</span><br><span class=\"line\">      <span class=\"type\">InputStream</span> <span class=\"variable\">is</span> <span class=\"operator\">=</span> conn.getInputStream();</span><br><span class=\"line\">      <span class=\"type\">byte</span>[] buf = <span class=\"keyword\">new</span> <span class=\"title class_\">byte</span>[<span class=\"number\">1024</span>];</span><br><span class=\"line\">      <span class=\"type\">int</span> <span class=\"variable\">downLoadedSize</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">      <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">numRead</span> <span class=\"operator\">=</span> is.read(buf);</span><br><span class=\"line\">        downLoadedSize += numRead;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (downLoadedSize &gt;= data.preLoadBytes || numRead == -<span class=\"number\">1</span>) &#123; <span class=\"comment\">//Reached  preload range or end of Input stream.</span></span><br><span class=\"line\">          <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125; <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>);</span><br><span class=\"line\">      is.close();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ....</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"type\">boolean</span> <span class=\"title function_\">isCancel</span><span class=\"params\">(String url)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (TextUtils.isEmpty(url)) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (String cancelUrl : cancelList) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (cancelUrl.equals(url)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>对于这段代码中其实有“两个”队列，一个是HandlerThread中的队列，熟悉消息机制的同学应该都能明白，内部是一个looper在不断地循环获取消息，当一个消息处理完毕之后才会处理下一个消息。我还定义了一个就是取消队列，因为HandlerThread中的任务我们不太好控制取消具体的任务，所以设置了一个取消队列，当之后的消息再需要执行的时候会首先判断是否是在取消队列里面，这样子就能做到对预加载队列逻辑的控制。</p>\n<h2 id=\"二、关于一些细节问题\"><a href=\"#二、关于一些细节问题\" class=\"headerlink\" title=\"二、关于一些细节问题\"></a>二、关于一些细节问题</h2><p>这样子我们在播放一个视频的时候，只需要传给我们接下来将会播放的视频的URL，我们就能对其预加载并缓存下来，但是会存在其他条件：</p>\n<h5 id=\"预加载的长度？\"><a href=\"#预加载的长度？\" class=\"headerlink\" title=\"预加载的长度？\"></a>预加载的长度？</h5><p>对于视频加载长度，我们很容易想到在视频url请求加入Range在header上面，比如</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">conn.addRequestProperty(<span class=\"string\">&quot;Range&quot;</span>, <span class=\"string\">&quot;0-102400&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n<p>我们只获取前102400 bytes，不用将整个视频全部进行预加载，我有进行这样的尝试，但是实际发现是有坑的。我做了很多尝试，发现不论怎么请求，拿到的 responseCode 虽然是206，但是 还是把数据给全部下载完了，这就有点不科学了！！</p>\n<p>最终去源码中才发现：源码有对range做正则匹配</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">Pattern</span> <span class=\"variable\">RANGE_HEADER_PATTERN</span> <span class=\"operator\">=</span> Pattern.compile(<span class=\"string\">&quot;[R,r]ange:[ ]?bytes=(\\\\d*)-&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"type\">long</span> <span class=\"title function_\">findRangeOffset</span><span class=\"params\">(String request)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">Matcher</span> <span class=\"variable\">matcher</span> <span class=\"operator\">=</span> RANGE_HEADER_PATTERN.matcher(request);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (matcher.find()) &#123;</span><br><span class=\"line\">            <span class=\"type\">String</span> <span class=\"variable\">rangeValue</span> <span class=\"operator\">=</span> matcher.group(<span class=\"number\">1</span>);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> Long.parseLong(rangeValue);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>看清楚了 <strong><em>“[R,r]ange:[ ]?bytes&#x3D;(\\d</em>)-“</strong>* 它只去匹配了前面的的，也就是说 我传入了 0-102400 它最终只当作是：Range：0- 来处理，导致addRequestProperty设置的range实现。坑！不过能理解作者为什么这么做，后面总结会讲到。没有办法只有使用最原始的方法进行判断了：在每次获取inputStream的时候进行判断是否达到预加载的大小，虽然有一定的性能开销，但是不去改源码的话也没有 办法了。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">      <span class=\"type\">int</span> <span class=\"variable\">numRead</span> <span class=\"operator\">=</span> is.read(buf);</span><br><span class=\"line\">      downLoadedSize += numRead;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (downLoadedSize &gt;= data.preLoadBytes || numRead == -<span class=\"number\">1</span>) &#123; <span class=\"comment\">//Reached  preload range or end of Input stream.</span></span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>);</span><br><span class=\"line\">    is.close();</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"三、总结\"><a href=\"#三、总结\" class=\"headerlink\" title=\"三、总结\"></a>三、总结</h2><p>本文主要讲了基于AndroidVideoCache的预加载具体实现原理，以及其中遇到的坑</p>\n<p>1、预加载主要通过HandlerThread去实现后台网络的访问以及缓存的处理逻辑</p>\n<p>2、加入取消队列去控制对应需要取消的任务</p>\n<p>3、对于预加载的size只能通过读取的时候进行判断，没有办法使用range去判断。其实很容易理解作者为什么正则要这样写，因为它只是一个视频缓存框架，主要是用来做“边播边存”，所以每次去进行请求的时候应该都是在原有的缓存之上去进行缓存数据处理，而缓存最终需要处理完的就是 content-size，不需要再去管Range中的结束范围了。</p>\n","categories":[{"name":"技术文章","slug":"technology","api":"api/categories/technology.json"}],"tags":[{"name":"视频","slug":"视频","api":"api/tags/视频.json"}],"api":"api/posts/2020/07/06/基于AndroidVideoCache的预加载.json"},{"title":"WeakHashMap与Java引用相关","slug":"WeakHashMap与Java引用相关","date":"2020-06-22T03:19:00.000Z","updated":"2025-05-20T11:46:57.000Z","comments":true,"url":"2020/06/22/WeakHashMap与Java引用相关/","excerpt":"<p>记得在很久之前有写过一篇<a href=\"https://blog.csdn.net/u010107153/article/details/102821282\">《Java中的Reference解析》</a>，主要讲的是Java中的四种引用方式与引用队列，不过这些都是基础的理论知识，最近开发项目中有使用到WeakHashMap，对于Java的引用以及引用队列有了更深的了解，在此做个相关总结。</p>\n<h2 id=\"一、WeakHashMap的实现方式\"><a href=\"#一、WeakHashMap的实现方式\" class=\"headerlink\" title=\"一、WeakHashMap的实现方式\"></a>一、WeakHashMap的实现方式</h2><p>总体来说，WeakHashMap的底层数据结构与HashMap的实现差不多，都是用“拉链法”来实现，主要区别在于WeakHashMap的Entry 继承于WeakReference，并维护一个ReferenceQueue，使其具有了“弱引用的特性”，其构造方法可以看出：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">Entry(Object key, V value,ReferenceQueue&lt;Object&gt; queue,<span class=\"type\">int</span> hash, Entry&lt;K,V&gt; next) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">super</span>(key, queue); <span class=\"comment\">//这里比较关键</span></span><br><span class=\"line\">            ……</span><br><span class=\"line\">        &#125;</span><br></pre></td></tr></table></figure>\n<p>其中的super父类的代码实现为：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"title function_\">WeakReference</span><span class=\"params\">(T referent, ReferenceQueue&lt;? <span class=\"built_in\">super</span> T&gt; q)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">super</span>(referent, q);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>通过对父类的构造方法可以知道，WeakMap的key值为弱引用类型，回顾一下弱引用的特点：<strong>垃圾收集器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。</strong> 于是WeakHashMap的作用就凸显出来了：**对于数据中Key-value，key因为使用的弱引用会被回收，而value也会得到对应的释放。**以我这次的需求为例：key为Webview页面或者Flutter&#x2F;RN页面，value为调用native方法相关存储的对象。当页面需要关闭调webivew的时候，Webview应该要被释放，要不然会产生内存泄漏，当其被释放之后，对应的value也没有意义了，所以也需要被释放掉。</p>\n<p> 那么WeakHashMap是如何让value释放的呢？</p>\n<h2 id=\"二、WeakHashMap如何释放无用的Value\"><a href=\"#二、WeakHashMap如何释放无用的Value\" class=\"headerlink\" title=\"二、WeakHashMap如何释放无用的Value\"></a>二、WeakHashMap如何释放无用的Value</h2><p>要回收无用的Value，那么引用队列（ReferenceQueue）就派上用场了，回顾一下引用队列的作用：<strong>当一个引用（软引用、弱引用）关联到了一个引用队列后，当这个引用所引用的对象要被垃圾回收时，就会将它加入到所关联的引用队列中。</strong><br>所以判断一个引用对象是否已经被回收的一个现象就是，这个对象的引用是否被加入到了它所关联的引用队列。<br>那么对于WeakHashMap也是利用这一点特性，在其代码中put\\get等方法都有执行对应等检查</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> V <span class=\"title function_\">put</span><span class=\"params\">(K key, V value)</span> &#123;</span><br><span class=\"line\">       <span class=\"type\">Object</span> <span class=\"variable\">k</span> <span class=\"operator\">=</span> maskNull(key);</span><br><span class=\"line\">       <span class=\"type\">int</span> <span class=\"variable\">h</span> <span class=\"operator\">=</span> hash(k);</span><br><span class=\"line\">       Entry&lt;K,V&gt;[] tab = getTable(); <span class=\"comment\">//具体实现在getTable执行的expungeStaleEntries里面</span></span><br><span class=\"line\">       ……</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> V <span class=\"title function_\">get</span><span class=\"params\">(Object key)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">Object</span> <span class=\"variable\">k</span> <span class=\"operator\">=</span> maskNull(key);</span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">h</span> <span class=\"operator\">=</span> hash(k);</span><br><span class=\"line\">    Entry&lt;K,V&gt;[] tab = getTable();</span><br><span class=\"line\">    ……</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Expunges stale entries from the table.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">expungeStaleEntries</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (Object x; (x = queue.poll()) != <span class=\"literal\">null</span>; ) &#123; <span class=\"comment\">//这里的queue就是引用队列</span></span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span> (queue) &#123; </span><br><span class=\"line\">            <span class=\"meta\">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class=\"line\">                Entry&lt;K,V&gt; e = (Entry&lt;K,V&gt;) x;</span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> indexFor(e.hash, table.length);</span><br><span class=\"line\"></span><br><span class=\"line\">            Entry&lt;K,V&gt; prev = table[i];</span><br><span class=\"line\">            Entry&lt;K,V&gt; p = prev;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (p != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">                Entry&lt;K,V&gt; next = p.next;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (p == e) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (prev == e)</span><br><span class=\"line\">                        table[i] = next;</span><br><span class=\"line\">                    <span class=\"keyword\">else</span></span><br><span class=\"line\">                        prev.next = next;</span><br><span class=\"line\">                    <span class=\"comment\">// Must not null out e.next;</span></span><br><span class=\"line\">                    <span class=\"comment\">// stale entries may be in use by a HashIterator</span></span><br><span class=\"line\">                    e.value = <span class=\"literal\">null</span>; <span class=\"comment\">// Help GC</span></span><br><span class=\"line\">                    size--;</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                prev = p;</span><br><span class=\"line\">                p = next;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>从上面的代码逻辑可以很清楚的知道：WeakHashMap通过对引用队列的数据进行检查，对key被回收对象的对应Value进行了回收。</p>\n<h2 id=\"三、总结\"><a href=\"#三、总结\" class=\"headerlink\" title=\"三、总结\"></a>三、总结</h2><p>1、WeakHashMap的Entry 继承于WeakReference，并维护一个ReferenceQueue<br>2、在执行get\\put等相关数据操作的时候 会对数据进行相关处理，主要是清除掉无用对象对</p>\n","cover":null,"images":[],"content":"<p>记得在很久之前有写过一篇<a href=\"https://blog.csdn.net/u010107153/article/details/102821282\">《Java中的Reference解析》</a>，主要讲的是Java中的四种引用方式与引用队列，不过这些都是基础的理论知识，最近开发项目中有使用到WeakHashMap，对于Java的引用以及引用队列有了更深的了解，在此做个相关总结。</p>\n<h2 id=\"一、WeakHashMap的实现方式\"><a href=\"#一、WeakHashMap的实现方式\" class=\"headerlink\" title=\"一、WeakHashMap的实现方式\"></a>一、WeakHashMap的实现方式</h2><p>总体来说，WeakHashMap的底层数据结构与HashMap的实现差不多，都是用“拉链法”来实现，主要区别在于WeakHashMap的Entry 继承于WeakReference，并维护一个ReferenceQueue，使其具有了“弱引用的特性”，其构造方法可以看出：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">Entry(Object key, V value,ReferenceQueue&lt;Object&gt; queue,<span class=\"type\">int</span> hash, Entry&lt;K,V&gt; next) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">super</span>(key, queue); <span class=\"comment\">//这里比较关键</span></span><br><span class=\"line\">            ……</span><br><span class=\"line\">        &#125;</span><br></pre></td></tr></table></figure>\n<p>其中的super父类的代码实现为：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"title function_\">WeakReference</span><span class=\"params\">(T referent, ReferenceQueue&lt;? <span class=\"built_in\">super</span> T&gt; q)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">super</span>(referent, q);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>通过对父类的构造方法可以知道，WeakMap的key值为弱引用类型，回顾一下弱引用的特点：<strong>垃圾收集器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。</strong> 于是WeakHashMap的作用就凸显出来了：**对于数据中Key-value，key因为使用的弱引用会被回收，而value也会得到对应的释放。**以我这次的需求为例：key为Webview页面或者Flutter&#x2F;RN页面，value为调用native方法相关存储的对象。当页面需要关闭调webivew的时候，Webview应该要被释放，要不然会产生内存泄漏，当其被释放之后，对应的value也没有意义了，所以也需要被释放掉。</p>\n<p> 那么WeakHashMap是如何让value释放的呢？</p>\n<h2 id=\"二、WeakHashMap如何释放无用的Value\"><a href=\"#二、WeakHashMap如何释放无用的Value\" class=\"headerlink\" title=\"二、WeakHashMap如何释放无用的Value\"></a>二、WeakHashMap如何释放无用的Value</h2><p>要回收无用的Value，那么引用队列（ReferenceQueue）就派上用场了，回顾一下引用队列的作用：<strong>当一个引用（软引用、弱引用）关联到了一个引用队列后，当这个引用所引用的对象要被垃圾回收时，就会将它加入到所关联的引用队列中。</strong><br>所以判断一个引用对象是否已经被回收的一个现象就是，这个对象的引用是否被加入到了它所关联的引用队列。<br>那么对于WeakHashMap也是利用这一点特性，在其代码中put\\get等方法都有执行对应等检查</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> V <span class=\"title function_\">put</span><span class=\"params\">(K key, V value)</span> &#123;</span><br><span class=\"line\">       <span class=\"type\">Object</span> <span class=\"variable\">k</span> <span class=\"operator\">=</span> maskNull(key);</span><br><span class=\"line\">       <span class=\"type\">int</span> <span class=\"variable\">h</span> <span class=\"operator\">=</span> hash(k);</span><br><span class=\"line\">       Entry&lt;K,V&gt;[] tab = getTable(); <span class=\"comment\">//具体实现在getTable执行的expungeStaleEntries里面</span></span><br><span class=\"line\">       ……</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> V <span class=\"title function_\">get</span><span class=\"params\">(Object key)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">Object</span> <span class=\"variable\">k</span> <span class=\"operator\">=</span> maskNull(key);</span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">h</span> <span class=\"operator\">=</span> hash(k);</span><br><span class=\"line\">    Entry&lt;K,V&gt;[] tab = getTable();</span><br><span class=\"line\">    ……</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Expunges stale entries from the table.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">expungeStaleEntries</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (Object x; (x = queue.poll()) != <span class=\"literal\">null</span>; ) &#123; <span class=\"comment\">//这里的queue就是引用队列</span></span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span> (queue) &#123; </span><br><span class=\"line\">            <span class=\"meta\">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class=\"line\">                Entry&lt;K,V&gt; e = (Entry&lt;K,V&gt;) x;</span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> indexFor(e.hash, table.length);</span><br><span class=\"line\"></span><br><span class=\"line\">            Entry&lt;K,V&gt; prev = table[i];</span><br><span class=\"line\">            Entry&lt;K,V&gt; p = prev;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (p != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">                Entry&lt;K,V&gt; next = p.next;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (p == e) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (prev == e)</span><br><span class=\"line\">                        table[i] = next;</span><br><span class=\"line\">                    <span class=\"keyword\">else</span></span><br><span class=\"line\">                        prev.next = next;</span><br><span class=\"line\">                    <span class=\"comment\">// Must not null out e.next;</span></span><br><span class=\"line\">                    <span class=\"comment\">// stale entries may be in use by a HashIterator</span></span><br><span class=\"line\">                    e.value = <span class=\"literal\">null</span>; <span class=\"comment\">// Help GC</span></span><br><span class=\"line\">                    size--;</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                prev = p;</span><br><span class=\"line\">                p = next;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>从上面的代码逻辑可以很清楚的知道：WeakHashMap通过对引用队列的数据进行检查，对key被回收对象的对应Value进行了回收。</p>\n<h2 id=\"三、总结\"><a href=\"#三、总结\" class=\"headerlink\" title=\"三、总结\"></a>三、总结</h2><p>1、WeakHashMap的Entry 继承于WeakReference，并维护一个ReferenceQueue<br>2、在执行get\\put等相关数据操作的时候 会对数据进行相关处理，主要是清除掉无用对象对</p>\n","categories":[{"name":"技术文章","slug":"technology","api":"api/categories/technology.json"}],"tags":[{"name":"Java","slug":"java","api":"api/tags/java.json"}],"api":"api/posts/2020/06/22/WeakHashMap与Java引用相关.json"}],"info":{"type":"category","name":"技术文章","slug":"technology"}},"api":"api/categories/technology/page.2.json"}