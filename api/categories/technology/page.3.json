{"data":{"index":3,"total":4,"posts":[{"title":"WeakHashMap与Java引用相关","slug":"WeakHashMap与Java引用相关","date":"2020-06-22T03:19:00.000Z","updated":"2025-05-20T11:46:57.000Z","comments":true,"url":"2020/06/22/WeakHashMap与Java引用相关/","excerpt":"<p>记得在很久之前有写过一篇<a href=\"https://blog.csdn.net/u010107153/article/details/102821282\">《Java中的Reference解析》</a>，主要讲的是Java中的四种引用方式与引用队列，不过这些都是基础的理论知识，最近开发项目中有使用到WeakHashMap，对于Java的引用以及引用队列有了更深的了解，在此做个相关总结。</p>\n<h2 id=\"一、WeakHashMap的实现方式\"><a href=\"#一、WeakHashMap的实现方式\" class=\"headerlink\" title=\"一、WeakHashMap的实现方式\"></a>一、WeakHashMap的实现方式</h2><p>总体来说，WeakHashMap的底层数据结构与HashMap的实现差不多，都是用“拉链法”来实现，主要区别在于WeakHashMap的Entry 继承于WeakReference，并维护一个ReferenceQueue，使其具有了“弱引用的特性”，其构造方法可以看出：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">Entry(Object key, V value,ReferenceQueue&lt;Object&gt; queue,<span class=\"type\">int</span> hash, Entry&lt;K,V&gt; next) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">super</span>(key, queue); <span class=\"comment\">//这里比较关键</span></span><br><span class=\"line\">            ……</span><br><span class=\"line\">        &#125;</span><br></pre></td></tr></table></figure>\n<p>其中的super父类的代码实现为：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"title function_\">WeakReference</span><span class=\"params\">(T referent, ReferenceQueue&lt;? <span class=\"built_in\">super</span> T&gt; q)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">super</span>(referent, q);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>通过对父类的构造方法可以知道，WeakMap的key值为弱引用类型，回顾一下弱引用的特点：<strong>垃圾收集器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。</strong> 于是WeakHashMap的作用就凸显出来了：**对于数据中Key-value，key因为使用的弱引用会被回收，而value也会得到对应的释放。**以我这次的需求为例：key为Webview页面或者Flutter&#x2F;RN页面，value为调用native方法相关存储的对象。当页面需要关闭调webivew的时候，Webview应该要被释放，要不然会产生内存泄漏，当其被释放之后，对应的value也没有意义了，所以也需要被释放掉。</p>\n<p> 那么WeakHashMap是如何让value释放的呢？</p>\n<h2 id=\"二、WeakHashMap如何释放无用的Value\"><a href=\"#二、WeakHashMap如何释放无用的Value\" class=\"headerlink\" title=\"二、WeakHashMap如何释放无用的Value\"></a>二、WeakHashMap如何释放无用的Value</h2><p>要回收无用的Value，那么引用队列（ReferenceQueue）就派上用场了，回顾一下引用队列的作用：<strong>当一个引用（软引用、弱引用）关联到了一个引用队列后，当这个引用所引用的对象要被垃圾回收时，就会将它加入到所关联的引用队列中。</strong><br>所以判断一个引用对象是否已经被回收的一个现象就是，这个对象的引用是否被加入到了它所关联的引用队列。<br>那么对于WeakHashMap也是利用这一点特性，在其代码中put\\get等方法都有执行对应等检查</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> V <span class=\"title function_\">put</span><span class=\"params\">(K key, V value)</span> &#123;</span><br><span class=\"line\">       <span class=\"type\">Object</span> <span class=\"variable\">k</span> <span class=\"operator\">=</span> maskNull(key);</span><br><span class=\"line\">       <span class=\"type\">int</span> <span class=\"variable\">h</span> <span class=\"operator\">=</span> hash(k);</span><br><span class=\"line\">       Entry&lt;K,V&gt;[] tab = getTable(); <span class=\"comment\">//具体实现在getTable执行的expungeStaleEntries里面</span></span><br><span class=\"line\">       ……</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> V <span class=\"title function_\">get</span><span class=\"params\">(Object key)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">Object</span> <span class=\"variable\">k</span> <span class=\"operator\">=</span> maskNull(key);</span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">h</span> <span class=\"operator\">=</span> hash(k);</span><br><span class=\"line\">    Entry&lt;K,V&gt;[] tab = getTable();</span><br><span class=\"line\">    ……</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Expunges stale entries from the table.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">expungeStaleEntries</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (Object x; (x = queue.poll()) != <span class=\"literal\">null</span>; ) &#123; <span class=\"comment\">//这里的queue就是引用队列</span></span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span> (queue) &#123; </span><br><span class=\"line\">            <span class=\"meta\">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class=\"line\">                Entry&lt;K,V&gt; e = (Entry&lt;K,V&gt;) x;</span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> indexFor(e.hash, table.length);</span><br><span class=\"line\"></span><br><span class=\"line\">            Entry&lt;K,V&gt; prev = table[i];</span><br><span class=\"line\">            Entry&lt;K,V&gt; p = prev;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (p != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">                Entry&lt;K,V&gt; next = p.next;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (p == e) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (prev == e)</span><br><span class=\"line\">                        table[i] = next;</span><br><span class=\"line\">                    <span class=\"keyword\">else</span></span><br><span class=\"line\">                        prev.next = next;</span><br><span class=\"line\">                    <span class=\"comment\">// Must not null out e.next;</span></span><br><span class=\"line\">                    <span class=\"comment\">// stale entries may be in use by a HashIterator</span></span><br><span class=\"line\">                    e.value = <span class=\"literal\">null</span>; <span class=\"comment\">// Help GC</span></span><br><span class=\"line\">                    size--;</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                prev = p;</span><br><span class=\"line\">                p = next;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>从上面的代码逻辑可以很清楚的知道：WeakHashMap通过对引用队列的数据进行检查，对key被回收对象的对应Value进行了回收。</p>\n<h2 id=\"三、总结\"><a href=\"#三、总结\" class=\"headerlink\" title=\"三、总结\"></a>三、总结</h2><p>1、WeakHashMap的Entry 继承于WeakReference，并维护一个ReferenceQueue<br>2、在执行get\\put等相关数据操作的时候 会对数据进行相关处理，主要是清除掉无用对象对</p>\n","cover":null,"images":[],"content":"<p>记得在很久之前有写过一篇<a href=\"https://blog.csdn.net/u010107153/article/details/102821282\">《Java中的Reference解析》</a>，主要讲的是Java中的四种引用方式与引用队列，不过这些都是基础的理论知识，最近开发项目中有使用到WeakHashMap，对于Java的引用以及引用队列有了更深的了解，在此做个相关总结。</p>\n<h2 id=\"一、WeakHashMap的实现方式\"><a href=\"#一、WeakHashMap的实现方式\" class=\"headerlink\" title=\"一、WeakHashMap的实现方式\"></a>一、WeakHashMap的实现方式</h2><p>总体来说，WeakHashMap的底层数据结构与HashMap的实现差不多，都是用“拉链法”来实现，主要区别在于WeakHashMap的Entry 继承于WeakReference，并维护一个ReferenceQueue，使其具有了“弱引用的特性”，其构造方法可以看出：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">Entry(Object key, V value,ReferenceQueue&lt;Object&gt; queue,<span class=\"type\">int</span> hash, Entry&lt;K,V&gt; next) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">super</span>(key, queue); <span class=\"comment\">//这里比较关键</span></span><br><span class=\"line\">            ……</span><br><span class=\"line\">        &#125;</span><br></pre></td></tr></table></figure>\n<p>其中的super父类的代码实现为：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"title function_\">WeakReference</span><span class=\"params\">(T referent, ReferenceQueue&lt;? <span class=\"built_in\">super</span> T&gt; q)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">super</span>(referent, q);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>通过对父类的构造方法可以知道，WeakMap的key值为弱引用类型，回顾一下弱引用的特点：<strong>垃圾收集器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。</strong> 于是WeakHashMap的作用就凸显出来了：**对于数据中Key-value，key因为使用的弱引用会被回收，而value也会得到对应的释放。**以我这次的需求为例：key为Webview页面或者Flutter&#x2F;RN页面，value为调用native方法相关存储的对象。当页面需要关闭调webivew的时候，Webview应该要被释放，要不然会产生内存泄漏，当其被释放之后，对应的value也没有意义了，所以也需要被释放掉。</p>\n<p> 那么WeakHashMap是如何让value释放的呢？</p>\n<h2 id=\"二、WeakHashMap如何释放无用的Value\"><a href=\"#二、WeakHashMap如何释放无用的Value\" class=\"headerlink\" title=\"二、WeakHashMap如何释放无用的Value\"></a>二、WeakHashMap如何释放无用的Value</h2><p>要回收无用的Value，那么引用队列（ReferenceQueue）就派上用场了，回顾一下引用队列的作用：<strong>当一个引用（软引用、弱引用）关联到了一个引用队列后，当这个引用所引用的对象要被垃圾回收时，就会将它加入到所关联的引用队列中。</strong><br>所以判断一个引用对象是否已经被回收的一个现象就是，这个对象的引用是否被加入到了它所关联的引用队列。<br>那么对于WeakHashMap也是利用这一点特性，在其代码中put\\get等方法都有执行对应等检查</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> V <span class=\"title function_\">put</span><span class=\"params\">(K key, V value)</span> &#123;</span><br><span class=\"line\">       <span class=\"type\">Object</span> <span class=\"variable\">k</span> <span class=\"operator\">=</span> maskNull(key);</span><br><span class=\"line\">       <span class=\"type\">int</span> <span class=\"variable\">h</span> <span class=\"operator\">=</span> hash(k);</span><br><span class=\"line\">       Entry&lt;K,V&gt;[] tab = getTable(); <span class=\"comment\">//具体实现在getTable执行的expungeStaleEntries里面</span></span><br><span class=\"line\">       ……</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> V <span class=\"title function_\">get</span><span class=\"params\">(Object key)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">Object</span> <span class=\"variable\">k</span> <span class=\"operator\">=</span> maskNull(key);</span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">h</span> <span class=\"operator\">=</span> hash(k);</span><br><span class=\"line\">    Entry&lt;K,V&gt;[] tab = getTable();</span><br><span class=\"line\">    ……</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Expunges stale entries from the table.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">expungeStaleEntries</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (Object x; (x = queue.poll()) != <span class=\"literal\">null</span>; ) &#123; <span class=\"comment\">//这里的queue就是引用队列</span></span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span> (queue) &#123; </span><br><span class=\"line\">            <span class=\"meta\">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class=\"line\">                Entry&lt;K,V&gt; e = (Entry&lt;K,V&gt;) x;</span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> indexFor(e.hash, table.length);</span><br><span class=\"line\"></span><br><span class=\"line\">            Entry&lt;K,V&gt; prev = table[i];</span><br><span class=\"line\">            Entry&lt;K,V&gt; p = prev;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (p != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">                Entry&lt;K,V&gt; next = p.next;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (p == e) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (prev == e)</span><br><span class=\"line\">                        table[i] = next;</span><br><span class=\"line\">                    <span class=\"keyword\">else</span></span><br><span class=\"line\">                        prev.next = next;</span><br><span class=\"line\">                    <span class=\"comment\">// Must not null out e.next;</span></span><br><span class=\"line\">                    <span class=\"comment\">// stale entries may be in use by a HashIterator</span></span><br><span class=\"line\">                    e.value = <span class=\"literal\">null</span>; <span class=\"comment\">// Help GC</span></span><br><span class=\"line\">                    size--;</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                prev = p;</span><br><span class=\"line\">                p = next;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>从上面的代码逻辑可以很清楚的知道：WeakHashMap通过对引用队列的数据进行检查，对key被回收对象的对应Value进行了回收。</p>\n<h2 id=\"三、总结\"><a href=\"#三、总结\" class=\"headerlink\" title=\"三、总结\"></a>三、总结</h2><p>1、WeakHashMap的Entry 继承于WeakReference，并维护一个ReferenceQueue<br>2、在执行get\\put等相关数据操作的时候 会对数据进行相关处理，主要是清除掉无用对象对</p>\n","categories":[{"name":"技术文章","slug":"technology","api":"api/categories/technology.json"}],"tags":[{"name":"Java","slug":"java","api":"api/tags/java.json"}],"api":"api/posts/2020/06/22/WeakHashMap与Java引用相关.json"},{"title":"Http缓存机制","slug":"Http缓存机制","date":"2020-04-20T03:45:00.000Z","updated":"2025-05-20T11:46:57.000Z","comments":true,"url":"2020/04/20/Http缓存机制/","excerpt":"<p>最近有接触到Http缓存机制的问题，自己进行一个总结。</p>\n<p>浏览器加载一个页面的缓存流程如下：1. 浏览器先根据Http Header信息来判断是否命中<strong>强缓存</strong>。如果命中则直接加载本地缓存中的资源，并不会将请求发送到服务器。<br> 2. 如果未命中强缓存，则浏览器会将资源加载请求发送到服务器。服务器来判断浏览器本地缓存是否失效。若可以使用，则服务器并不会返回资源信息，浏览器继续从缓存加载资源，虽然与强缓存加载的是“同一份缓存”，但是由于流程与性质不一样，我们把它叫做<strong>协商缓存</strong>。<br> 3. 如果未命中<strong>协商缓存</strong>，则服务器会将完整的资源返回给浏览器，浏览器加载新资源，并更新缓存。</p>\n<p><strong>强缓存</strong>：不会向服务器发送请求,直接从本地缓存中读取资源返回<strong>200</strong>的状态码。</p>\n<p>from memory cache一般脚本、字体、图片会存在内存当中 </p>\n<p>from disk cache一般非脚本会存在磁盘当中，如css等 </p>\n<p><strong>协商缓存</strong>：向服务器发送请求,服务器根据请求中的Header的字段判断是否命中协商缓存,如果命中,则返回<strong>304</strong>状态码并带上新的响应头通知浏览器从缓存中读取资源</p>\n<p>与之相关的字段为：<br>强缓存：<strong>cache-control、expires</strong><br>协商缓存：<strong>Last-Modified&#x2F;if-Modified-Since、Etag&#x2F;if-None-Match.</strong></p>\n<p>其实整个缓存机制也就是围绕着这几个字段所展开</p>\n<h2 id=\"二、强缓存流程\"><a href=\"#二、强缓存流程\" class=\"headerlink\" title=\"二、强缓存流程\"></a>二、强缓存流程</h2><p>强缓存是由Http的Response Header中的<strong>Expires</strong>或者<strong>Cache-Control</strong>两个字段来控制的，用来表示资源的缓存时间。如果Cache-control与expires同时存在的话，Cache-control的优先级高于expires。</p>\n<h4 id=\"Expires\"><a href=\"#Expires\" class=\"headerlink\" title=\"Expires\"></a>Expires</h4><p>是一个http1.0提出的概念，它描述的是一个绝对时间，由服务端返回</p>\n<blockquote>\n<p><code>expires: Mon, 11 Jun 2029 08:34:12 GMT</code></p>\n</blockquote>\n<h4 id=\"Cache-Control\"><a href=\"#Cache-Control\" class=\"headerlink\" title=\"Cache-Control\"></a>Cache-Control</h4><p>Catche-control是http1.1提出的概念，优先级高于expires，描述的是一个相对时间</p>\n<blockquote>\n<p><code>cache-control: max-age=315360000</code></p>\n</blockquote>\n<p>除了max-age外，cache-control还有其他几个参数：<br><strong>-no-cache</strong>：不使用本地缓存。需要使用缓存协商，先与服务器确认返回的响应是否被更改，如果之前的响应中存在ETag，那么请求的时候会与服务端验证，如果资源未被更改，则可以避免重新下载。<br><strong>-no-store</strong>：直接禁止浏览器缓存数据，每次用户请求该资源，都会向服务器发送一个请求，每次都会下载完整的资源。<br><strong>-public</strong>：可以被所有的用户缓存，包括终端用户和CDN等中间代理服务器。<br><strong>-private</strong>：只能被终端用户的浏览器缓存，不允许CDN等中继缓存服务器对其缓存。</p>\n<p>如过Cache-Control和Expires条件都不满足，也就是说：像cache-control的字段为-no-cache和-no-store以及max-age不满足条件或者当前时间大于Expires的时间的时候，那么强缓存是没有被命中的，接下来要继续进行协商缓存的流程。</p>\n<h2 id=\"三、协商缓存流程\"><a href=\"#三、协商缓存流程\" class=\"headerlink\" title=\"三、协商缓存流程\"></a>三、协商缓存流程</h2><p>协商缓存相对于强缓存流程就复杂一点了，主要通过：<strong>Last-Modified&#x2F;If-Modified-Since</strong>和<strong>ETag&#x2F;If-None-Match</strong>来控制。Etag是服务器自动生成或者由开发者生成的对应资源在服务器端的唯一标识符，能够更加准确的控制缓存。Last-Modified与ETag是可以一起使用的，服务器会优先验证ETag，一致的情况下，才会继续比对Last-Modified，最后才决定是否返回<strong>304</strong>。</p>\n<h4 id=\"Last-Modified-If-Modified-Since\"><a href=\"#Last-Modified-If-Modified-Since\" class=\"headerlink\" title=\"Last-Modified&#x2F;If-Modified-Since\"></a>Last-Modified&#x2F;If-Modified-Since</h4><p>Last-Modified 表示本地文件最后修改日期，浏览器会在Request Header加上If-Modified-Since（上次返回的Last-Modified的值），询问服务器在该日期后资源是否有更新，有更新的话就会将新的资源发送回来。</p>\n<p>但是单纯使用Last-Modified 会有以下问题：</p>\n<ol>\n<li><p>Last-Modified标注的最后修改只能精确到秒级，如果某些文件在1秒钟以内，被修改多次的话，它将不能准确标注文件的修改时间</p>\n</li>\n<li><p>如果某些文件会被定期生成，当有时内容并没有任何变化，但Last-Modified却改变了，导致文件没法使用缓存</p>\n</li>\n<li><p>有可能存在服务器没有准确获取文件修改时间，或者与代理服务器时间不一致等情形</p>\n</li>\n</ol>\n<p>所以在HTTP&#x2F;1.1的时候加入了ETag&#x2F;If-None-Match来解决这些问题，因而ETag的优先级高于Last-Modified。</p>\n<h4 id=\"ETag-If-None-Match\"><a href=\"#ETag-If-None-Match\" class=\"headerlink\" title=\"ETag&#x2F;If-None-Match\"></a>ETag&#x2F;If-None-Match</h4><p>ETag可以保证每一个资源是唯一的，资源变化都会导致ETag变化。ETag值的变更则说明资源状态已经被修改。服务器根据浏览器上发送的If-None-Match值来判断是否命中缓存。</p>\n<p>If-None-Match的header会将上次返回的Etag发送给服务器，询问该资源的Etag是否有更新，有变动就会发送新的资源回来.</p>\n<p>Etag是服务器自动生成或者由开发者生成的对应资源在服务器端的唯一标识符，能够更加准确的控制缓存。<strong>Last-Modified与ETag是可以一起使用的，服务器会优先验证ETag，一致的情况下，才会继续比对Last-Modified，最后才决定是否返回304。</strong></p>\n<h2 id=\"四、总结\"><a href=\"#四、总结\" class=\"headerlink\" title=\"四、总结\"></a>四、总结</h2><p>一、由于HTTP一直在发展，所以对于HTTP的缓存字段也变得越来越复杂，其实我们很清晰的可以知道Expires与Last-Modified&#x2F;If-Modified-Since是Http&#x2F;1.0时代的产物。 Cache-Control与ETag&#x2F;If-None-Match是HTTP&#x2F;1.1为解决HTTP&#x2F;1.0新增出来的字段，这样对比去记忆理解起来，其实缓存机制也就变得很好理解了。</p>\n<p>二、对于第一次请求（肯定是没有任何缓存的），那么直接向服务器请求资源并将下载好的资源进行缓存，为下一次请求做缓存准备。</p>\n<p>三、对于第二次之后的请求，那么本地是有缓存的，那么先通过cache-control的规则判断（对于Http1.0还是Expires）来判断本地缓存是否过期，如果没过期，那么直接使用。如果过期了，就再判断Etag（具体流程可以参考：<a href=\"https://blog.csdn.net/kikikind/article/details/6266101\">Etag与HTTP缓存机制</a>），通过发送If-None-Match（也就是上次存入的Tag的值），服务器进行一个决策判断返回200还是304。之前有说到，Last-Modified与ETag是可以一起使用的，服务器会优先验证ETag，也就是Etag不存在或者其他情况那么会使用Last-Modified来进行判断，通过向服务器发送If-Modified-Since，然后服务器进行一次决策。</p>\n<p>看流程图可能一下子就明白了：</p>\n<p><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWFnZXMyMDE4LmNuYmxvZ3MuY29tL2Jsb2cvOTQwODg0LzIwMTgwNC85NDA4ODQtMjAxODA0MjMxNDE5NTE3MzUtOTEyNjk5MjEzLnBuZw?x-oss-process=image/format,png\"></p>\n<p>参考：</p>\n<p><a href=\"https://www.jianshu.com/p/19c2e397e22a\">https://www.cnblogs.com/ranyonsue/p/8918908.html</a><br><a href=\"https://www.jianshu.com/p/19c2e397e22a\">https://www.jianshu.com/p/19c2e397e22a</a></p>\n","cover":null,"images":["https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWFnZXMyMDE4LmNuYmxvZ3MuY29tL2Jsb2cvOTQwODg0LzIwMTgwNC85NDA4ODQtMjAxODA0MjMxNDE5NTE3MzUtOTEyNjk5MjEzLnBuZw?x-oss-process=image/format,png"],"content":"<p>最近有接触到Http缓存机制的问题，自己进行一个总结。</p>\n<p>浏览器加载一个页面的缓存流程如下：1. 浏览器先根据Http Header信息来判断是否命中<strong>强缓存</strong>。如果命中则直接加载本地缓存中的资源，并不会将请求发送到服务器。<br> 2. 如果未命中强缓存，则浏览器会将资源加载请求发送到服务器。服务器来判断浏览器本地缓存是否失效。若可以使用，则服务器并不会返回资源信息，浏览器继续从缓存加载资源，虽然与强缓存加载的是“同一份缓存”，但是由于流程与性质不一样，我们把它叫做<strong>协商缓存</strong>。<br> 3. 如果未命中<strong>协商缓存</strong>，则服务器会将完整的资源返回给浏览器，浏览器加载新资源，并更新缓存。</p>\n<p><strong>强缓存</strong>：不会向服务器发送请求,直接从本地缓存中读取资源返回<strong>200</strong>的状态码。</p>\n<p>from memory cache一般脚本、字体、图片会存在内存当中 </p>\n<p>from disk cache一般非脚本会存在磁盘当中，如css等 </p>\n<p><strong>协商缓存</strong>：向服务器发送请求,服务器根据请求中的Header的字段判断是否命中协商缓存,如果命中,则返回<strong>304</strong>状态码并带上新的响应头通知浏览器从缓存中读取资源</p>\n<p>与之相关的字段为：<br>强缓存：<strong>cache-control、expires</strong><br>协商缓存：<strong>Last-Modified&#x2F;if-Modified-Since、Etag&#x2F;if-None-Match.</strong></p>\n<p>其实整个缓存机制也就是围绕着这几个字段所展开</p>\n<h2 id=\"二、强缓存流程\"><a href=\"#二、强缓存流程\" class=\"headerlink\" title=\"二、强缓存流程\"></a>二、强缓存流程</h2><p>强缓存是由Http的Response Header中的<strong>Expires</strong>或者<strong>Cache-Control</strong>两个字段来控制的，用来表示资源的缓存时间。如果Cache-control与expires同时存在的话，Cache-control的优先级高于expires。</p>\n<h4 id=\"Expires\"><a href=\"#Expires\" class=\"headerlink\" title=\"Expires\"></a>Expires</h4><p>是一个http1.0提出的概念，它描述的是一个绝对时间，由服务端返回</p>\n<blockquote>\n<p><code>expires: Mon, 11 Jun 2029 08:34:12 GMT</code></p>\n</blockquote>\n<h4 id=\"Cache-Control\"><a href=\"#Cache-Control\" class=\"headerlink\" title=\"Cache-Control\"></a>Cache-Control</h4><p>Catche-control是http1.1提出的概念，优先级高于expires，描述的是一个相对时间</p>\n<blockquote>\n<p><code>cache-control: max-age=315360000</code></p>\n</blockquote>\n<p>除了max-age外，cache-control还有其他几个参数：<br><strong>-no-cache</strong>：不使用本地缓存。需要使用缓存协商，先与服务器确认返回的响应是否被更改，如果之前的响应中存在ETag，那么请求的时候会与服务端验证，如果资源未被更改，则可以避免重新下载。<br><strong>-no-store</strong>：直接禁止浏览器缓存数据，每次用户请求该资源，都会向服务器发送一个请求，每次都会下载完整的资源。<br><strong>-public</strong>：可以被所有的用户缓存，包括终端用户和CDN等中间代理服务器。<br><strong>-private</strong>：只能被终端用户的浏览器缓存，不允许CDN等中继缓存服务器对其缓存。</p>\n<p>如过Cache-Control和Expires条件都不满足，也就是说：像cache-control的字段为-no-cache和-no-store以及max-age不满足条件或者当前时间大于Expires的时间的时候，那么强缓存是没有被命中的，接下来要继续进行协商缓存的流程。</p>\n<h2 id=\"三、协商缓存流程\"><a href=\"#三、协商缓存流程\" class=\"headerlink\" title=\"三、协商缓存流程\"></a>三、协商缓存流程</h2><p>协商缓存相对于强缓存流程就复杂一点了，主要通过：<strong>Last-Modified&#x2F;If-Modified-Since</strong>和<strong>ETag&#x2F;If-None-Match</strong>来控制。Etag是服务器自动生成或者由开发者生成的对应资源在服务器端的唯一标识符，能够更加准确的控制缓存。Last-Modified与ETag是可以一起使用的，服务器会优先验证ETag，一致的情况下，才会继续比对Last-Modified，最后才决定是否返回<strong>304</strong>。</p>\n<h4 id=\"Last-Modified-If-Modified-Since\"><a href=\"#Last-Modified-If-Modified-Since\" class=\"headerlink\" title=\"Last-Modified&#x2F;If-Modified-Since\"></a>Last-Modified&#x2F;If-Modified-Since</h4><p>Last-Modified 表示本地文件最后修改日期，浏览器会在Request Header加上If-Modified-Since（上次返回的Last-Modified的值），询问服务器在该日期后资源是否有更新，有更新的话就会将新的资源发送回来。</p>\n<p>但是单纯使用Last-Modified 会有以下问题：</p>\n<ol>\n<li><p>Last-Modified标注的最后修改只能精确到秒级，如果某些文件在1秒钟以内，被修改多次的话，它将不能准确标注文件的修改时间</p>\n</li>\n<li><p>如果某些文件会被定期生成，当有时内容并没有任何变化，但Last-Modified却改变了，导致文件没法使用缓存</p>\n</li>\n<li><p>有可能存在服务器没有准确获取文件修改时间，或者与代理服务器时间不一致等情形</p>\n</li>\n</ol>\n<p>所以在HTTP&#x2F;1.1的时候加入了ETag&#x2F;If-None-Match来解决这些问题，因而ETag的优先级高于Last-Modified。</p>\n<h4 id=\"ETag-If-None-Match\"><a href=\"#ETag-If-None-Match\" class=\"headerlink\" title=\"ETag&#x2F;If-None-Match\"></a>ETag&#x2F;If-None-Match</h4><p>ETag可以保证每一个资源是唯一的，资源变化都会导致ETag变化。ETag值的变更则说明资源状态已经被修改。服务器根据浏览器上发送的If-None-Match值来判断是否命中缓存。</p>\n<p>If-None-Match的header会将上次返回的Etag发送给服务器，询问该资源的Etag是否有更新，有变动就会发送新的资源回来.</p>\n<p>Etag是服务器自动生成或者由开发者生成的对应资源在服务器端的唯一标识符，能够更加准确的控制缓存。<strong>Last-Modified与ETag是可以一起使用的，服务器会优先验证ETag，一致的情况下，才会继续比对Last-Modified，最后才决定是否返回304。</strong></p>\n<h2 id=\"四、总结\"><a href=\"#四、总结\" class=\"headerlink\" title=\"四、总结\"></a>四、总结</h2><p>一、由于HTTP一直在发展，所以对于HTTP的缓存字段也变得越来越复杂，其实我们很清晰的可以知道Expires与Last-Modified&#x2F;If-Modified-Since是Http&#x2F;1.0时代的产物。 Cache-Control与ETag&#x2F;If-None-Match是HTTP&#x2F;1.1为解决HTTP&#x2F;1.0新增出来的字段，这样对比去记忆理解起来，其实缓存机制也就变得很好理解了。</p>\n<p>二、对于第一次请求（肯定是没有任何缓存的），那么直接向服务器请求资源并将下载好的资源进行缓存，为下一次请求做缓存准备。</p>\n<p>三、对于第二次之后的请求，那么本地是有缓存的，那么先通过cache-control的规则判断（对于Http1.0还是Expires）来判断本地缓存是否过期，如果没过期，那么直接使用。如果过期了，就再判断Etag（具体流程可以参考：<a href=\"https://blog.csdn.net/kikikind/article/details/6266101\">Etag与HTTP缓存机制</a>），通过发送If-None-Match（也就是上次存入的Tag的值），服务器进行一个决策判断返回200还是304。之前有说到，Last-Modified与ETag是可以一起使用的，服务器会优先验证ETag，也就是Etag不存在或者其他情况那么会使用Last-Modified来进行判断，通过向服务器发送If-Modified-Since，然后服务器进行一次决策。</p>\n<p>看流程图可能一下子就明白了：</p>\n<p><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWFnZXMyMDE4LmNuYmxvZ3MuY29tL2Jsb2cvOTQwODg0LzIwMTgwNC85NDA4ODQtMjAxODA0MjMxNDE5NTE3MzUtOTEyNjk5MjEzLnBuZw?x-oss-process=image/format,png\"></p>\n<p>参考：</p>\n<p><a href=\"https://www.jianshu.com/p/19c2e397e22a\">https://www.cnblogs.com/ranyonsue/p/8918908.html</a><br><a href=\"https://www.jianshu.com/p/19c2e397e22a\">https://www.jianshu.com/p/19c2e397e22a</a></p>\n","categories":[{"name":"技术文章","slug":"technology","api":"api/categories/technology.json"}],"tags":[{"name":"Http","slug":"Http","api":"api/tags/Http.json"}],"api":"api/posts/2020/04/20/Http缓存机制.json"},{"title":"想统计自己总共提交了多少行代码？","slug":"想统计自己总共提交了多少行代码？","date":"2020-03-02T03:01:00.000Z","updated":"2025-05-20T11:46:57.000Z","comments":true,"url":"2020/03/02/想统计自己总共提交了多少行代码？/","excerpt":"<p>作为一名程序员，我们很想知道自己到底提交了多少行代码到远程仓库，有没有什么工具能够帮我们统计自己写过的代码行数呢？答案是有的。</p>\n<p>这是本次实现的最终效果:</p>\n<img width=\"60%\" src=\"https://cdn.julis.wang/blog/img/20200301170230101.png\">\n\n<h2 id=\"统计代码行数的方式\"><a href=\"#统计代码行数的方式\" class=\"headerlink\" title=\"统计代码行数的方式\"></a>统计代码行数的方式</h2><p>对于代码提交行数统计，通过git 的系统命令就能做到，如下代码所示</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">git <span class=\"built_in\">log</span> --author=<span class=\"string\">&#x27;username&#x27;</span> --pretty=tformat: --numstat | awk <span class=\"string\">&#x27;</span></span><br><span class=\"line\"><span class=\"string\">    &#123;add += $1; subs += $2; loc += $1 - $2 &#125; END &#123; printf &quot;添加了%s,删除了%s,合计%s\\n&quot;, add, subs, loc &#125;&#x27;</span> -</span><br><span class=\"line\">\t</span><br></pre></td></tr></table></figure>\n\n<p>只需要在如下命令输入自己的username就行了，效果如图所示·</p>\n<img src=\"https://cdn.julis.wang/blog/img/20200301170616289.png\">\n\n<p>但是有的人由于环境原因，为了区分一些环境，比如办公司叫：username.office 在家的电脑上叫做: user.home 诸如此类，难道得手动一个一个统计么？当然不行了。</p>\n<p>众所周知，由于工程项目变得更越来越大，拆库也说见不鲜，于是自己的代码分布不同的项目工程，我们想要利用git的统计命令的话就有点吃力了，需要一个一个地进入相应目录进行命令输入？当然不行了。</p>\n<p>今天自己写了一份脚本主要用于统计分布在某个文件夹下所有的代码提交行数，git开源地址：<a href=\"https://github.com/VomPom/ForFun\">https://github.com/VomPom/ForFun</a>源码如下</p>\n<p>如何使用？</p>\n<p>0、将自己需要统计的项目文件目录整理到一个文件夹</p>\n<p>1、讲users_name换成自己的的用户名</p>\n<p>2、由于文件夹下可能有一些例外的不需要统计，添加该文件夹名</p>\n<p>3、讲该shell脚本移动到某个名录下</p>\n<p>4、最后利用 sh codeLine.sh 执行命令</p>\n<img width=\"60%\" src=\"https://cdn.julis.wang/blog/img/20200301171856190.png\">\n<img width=\"60%\" src=\"https://cdn.julis.wang/blog/img/20200301172119336.png\">\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">########################################################</span></span><br><span class=\"line\"><span class=\"comment\">#</span></span><br><span class=\"line\"><span class=\"comment\"># Created by https://julis.wang on 2020/02/28</span></span><br><span class=\"line\"><span class=\"comment\">#</span></span><br><span class=\"line\"><span class=\"comment\"># Description : 统计代码提交行数</span></span><br><span class=\"line\"><span class=\"comment\">#</span></span><br><span class=\"line\"><span class=\"comment\">########################################################</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#!/bin/bash</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#这里添加你的git常用用户名。考虑到每个人的账号可能有很多个，所以定义成数组</span></span><br><span class=\"line\">users_name=(<span class=\"string\">&quot;julis&quot;</span> <span class=\"string\">&quot;julis.wang&quot;</span> <span class=\"string\">&quot;julis.wang.hp&quot;</span>)      </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#过滤一些不需要去遍历的文件夹</span></span><br><span class=\"line\">filter_path=(<span class=\"string\">&quot;Backend&quot;</span> <span class=\"string\">&quot;test&quot;</span> <span class=\"string\">&quot;sdk&quot;</span> <span class=\"string\">&quot;fork&quot;</span> <span class=\"string\">&quot;ArProject&quot;</span>)     </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">########################################################</span></span><br><span class=\"line\"><span class=\"comment\"># 以下代码不需动                       </span></span><br><span class=\"line\"><span class=\"comment\">########################################################</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">export</span> index=0             \t\t\t<span class=\"comment\">#记录当前的位置</span></span><br><span class=\"line\"><span class=\"built_in\">export</span> add_line_count=0             <span class=\"comment\">#添加的line总行数</span></span><br><span class=\"line\"><span class=\"built_in\">export</span> remove_line_count=0          <span class=\"comment\">#删除的总行数</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">export</span> array_git_repositories=()    <span class=\"comment\">#用于记录仓库名</span></span><br><span class=\"line\"><span class=\"built_in\">export</span> add_code=()                  <span class=\"comment\">#记录所有用户对某个库的添加的行数</span></span><br><span class=\"line\"><span class=\"built_in\">export</span> remove_code=()               <span class=\"comment\">#记录所有用户对某个库的删除的行数</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#判断是否需要过滤该目录</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"function\"><span class=\"title\">is_fileter_dir</span></span>() &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"string\">&quot;<span class=\"variable\">$&#123;!filter_path[@]&#125;</span>&quot;</span>; <span class=\"keyword\">do</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> [ <span class=\"variable\">$1</span> == <span class=\"string\">&quot;<span class=\"variable\">$&#123;filter_path[$i]&#125;</span>&quot;</span> ]; <span class=\"keyword\">then</span></span><br><span class=\"line\">\t\t\t<span class=\"built_in\">return</span> 1</span><br><span class=\"line\">\t\t<span class=\"keyword\">fi</span></span><br><span class=\"line\">\t<span class=\"keyword\">done</span></span><br><span class=\"line\">\t<span class=\"built_in\">return</span> 0</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">#对命令执行的返回值进行数据切割</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"function\"><span class=\"title\">get_add_remove_count</span></span>() &#123;</span><br><span class=\"line\">\tstring=<span class=\"variable\">$1</span></span><br><span class=\"line\">\tarray=(<span class=\"variable\">$&#123;string//,/ &#125;</span>)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> [ ! <span class=\"variable\">$&#123;array[0]&#125;</span> ]; <span class=\"keyword\">then</span></span><br><span class=\"line\">  \t\tadd_line=0</span><br><span class=\"line\">\t<span class=\"keyword\">else</span></span><br><span class=\"line\">  \t\tadd_line=<span class=\"variable\">$&#123;array[0]&#125;</span></span><br><span class=\"line\">\t<span class=\"keyword\">fi</span></span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> [ ! <span class=\"variable\">$&#123;array[1]&#125;</span> ]; <span class=\"keyword\">then</span></span><br><span class=\"line\">  \t\tremove_line=0</span><br><span class=\"line\">\t<span class=\"keyword\">else</span></span><br><span class=\"line\">  \t\tremove_line=<span class=\"variable\">$&#123;array[1]&#125;</span></span><br><span class=\"line\">\t<span class=\"keyword\">fi</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> [ ! <span class=\"variable\">$&#123;add_code[$index]&#125;</span> ]; <span class=\"keyword\">then</span></span><br><span class=\"line\">  \t\tadd_code[<span class=\"variable\">$index</span>]=0</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"keyword\">fi</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> [ ! <span class=\"variable\">$&#123;remove_code[$index]&#125;</span> ]; <span class=\"keyword\">then</span></span><br><span class=\"line\">  \t\tremove_code[<span class=\"variable\">$index</span>]=0</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"keyword\">fi</span></span><br><span class=\"line\">\tremove_code[<span class=\"variable\">$index</span>]=`<span class=\"built_in\">expr</span> <span class=\"variable\">$&#123;remove_code[$index]&#125;</span> + <span class=\"variable\">$remove_line</span>`</span><br><span class=\"line\">\tadd_code[<span class=\"variable\">$index</span>]=`<span class=\"built_in\">expr</span> <span class=\"variable\">$&#123;add_code[$index]&#125;</span> + <span class=\"variable\">$add_line</span>`</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">echo</span> <span class=\"string\">&quot;用户&quot;</span><span class=\"variable\">$2</span><span class=\"string\">&quot;添加了=&quot;</span><span class=\"variable\">$add_line</span><span class=\"string\">&quot;行 删除了&quot;</span><span class=\"variable\">$add_line</span><span class=\"string\">&quot;行&quot;</span></span><br><span class=\"line\">\t</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">#获取该用户在该文件夹下的提交代码数</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"function\"><span class=\"title\">get_user_line</span></span>() &#123;</span><br><span class=\"line\">\t<span class=\"comment\"># output分别去接收 该文件夹下的提交以及删除行数</span></span><br><span class=\"line\">\toutput=$(git <span class=\"built_in\">log</span> --author=<span class=\"variable\">$&#123;1&#125;</span> --pretty=tformat: --numstat | awk <span class=\"string\">&#x27;</span></span><br><span class=\"line\"><span class=\"string\">    &#123;add += $1; subs += $2; loc += $1 - $2 &#125; END &#123; printf &quot;添加了%s,删除了%s,合计%s\\n&quot;, add, subs, loc &#125;&#x27;</span> -)</span><br><span class=\"line\">\tget_add_remove_count <span class=\"variable\">$output</span> <span class=\"variable\">$&#123;1&#125;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#遍历每个用户名</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"function\"><span class=\"title\">trans_every_user</span></span>() &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"string\">&quot;<span class=\"variable\">$&#123;!users_name[@]&#125;</span>&quot;</span>; <span class=\"keyword\">do</span></span><br><span class=\"line\">\t\tget_user_line <span class=\"string\">&quot;<span class=\"variable\">$&#123;users_name[$i]&#125;</span>&quot;</span></span><br><span class=\"line\">\t<span class=\"keyword\">done</span></span><br><span class=\"line\">\t<span class=\"built_in\">cd</span> ..</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 整体流程，从文件夹出发</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> path <span class=\"keyword\">in</span> `<span class=\"built_in\">ls</span> -l $(<span class=\"built_in\">dirname</span> <span class=\"variable\">$0</span>)|awk -F <span class=\"string\">&quot; &quot;</span> <span class=\"string\">&#x27;&#123;print $9&#125;&#x27;</span>`</span><br><span class=\"line\"><span class=\"keyword\">do</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> [ -d <span class=\"variable\">$path</span> ]</span><br><span class=\"line\">    <span class=\"keyword\">then</span></span><br><span class=\"line\">        is_fileter_dir <span class=\"variable\">$path</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> [ $? == 1 ]</span><br><span class=\"line\">        <span class=\"keyword\">then</span></span><br><span class=\"line\">            <span class=\"built_in\">echo</span> <span class=\"string\">&quot;&lt;=========过滤了【&quot;</span><span class=\"variable\">$path</span><span class=\"string\">&quot;】======&gt;&quot;</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">            <span class=\"built_in\">echo</span> <span class=\"string\">&quot;&lt;=========获取【&quot;</span><span class=\"variable\">$path</span><span class=\"string\">&quot;】的Git代码提交数据======&gt;&quot;</span></span><br><span class=\"line\">\t\t\tindex=<span class=\"variable\">$&#123;#array_git_repositories[@]&#125;</span> <span class=\"comment\">#用于记录当前在第几个文件夹下处理</span></span><br><span class=\"line\">            array_git_repositories=(<span class=\"variable\">$&#123;array_git_repositories[@]&#125;</span> <span class=\"variable\">$path</span>)</span><br><span class=\"line\">\t\t\t</span><br><span class=\"line\">            <span class=\"built_in\">cd</span> <span class=\"variable\">$path</span></span><br><span class=\"line\">            trans_every_user</span><br><span class=\"line\">        <span class=\"keyword\">fi</span></span><br><span class=\"line\">    <span class=\"keyword\">fi</span></span><br><span class=\"line\"><span class=\"keyword\">done</span></span><br><span class=\"line\">all_add_line=0</span><br><span class=\"line\">all_remove_line=0</span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&#x27;===============================================================================&#x27;</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&quot;                  本次共统计了【&quot;</span><span class=\"variable\">$&#123;#array_git_repositories[@]&#125;</span><span class=\"string\">&quot;】个仓库   by julis.wang      &quot;</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&#x27;===============================================================================&#x27;</span></span><br><span class=\"line\"><span class=\"built_in\">printf</span> <span class=\"string\">&quot;%-30s %10s %10s %10s\\n&quot;</span> <span class=\"string\">&quot;Folder&quot;</span> <span class=\"string\">&quot;Add&quot;</span> <span class=\"string\">&quot;Remove&quot;</span> <span class=\"string\">&quot;All&quot;</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&#x27;-------------------------------------------------------------------------------&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> ((i=<span class=\"number\">0</span>;i&lt;<span class=\"variable\">$&#123;#array_git_repositories[@]&#125;</span>;i++))</span><br><span class=\"line\"><span class=\"keyword\">do</span></span><br><span class=\"line\">\tall_add_line=`<span class=\"built_in\">expr</span> <span class=\"variable\">$all_add_line</span> + <span class=\"variable\">$&#123;add_code[$i]&#125;</span>`</span><br><span class=\"line\">\tall_remove_line=`<span class=\"built_in\">expr</span> <span class=\"variable\">$all_remove_line</span> + <span class=\"variable\">$&#123;remove_code[$i]&#125;</span>`</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span> <span class=\"string\">&quot;%-30s %10s %10s %10s\\n&quot;</span> <span class=\"variable\">$&#123;array_git_repositories[$i]&#125;</span> <span class=\"variable\">$&#123;add_code[$i]&#125;</span> <span class=\"variable\">$&#123;remove_code[$i]&#125;</span> `<span class=\"built_in\">expr</span> <span class=\"variable\">$&#123;add_code[$i]&#125;</span> - <span class=\"variable\">$&#123;remove_code[$i]&#125;</span>`</span><br><span class=\"line\"><span class=\"keyword\">done</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&#x27;-------------------------------------------------------------------------------&#x27;</span></span><br><span class=\"line\"><span class=\"built_in\">printf</span> <span class=\"string\">&quot;%-30s %10s %10s %10s\\n&quot;</span> <span class=\"string\">&quot;Total&quot;</span> <span class=\"variable\">$all_add_line</span> <span class=\"variable\">$all_remove_line</span> `<span class=\"built_in\">expr</span> <span class=\"variable\">$all_add_line</span> - <span class=\"variable\">$all_remove_line</span>`</span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&#x27;===============================================================================&#x27;</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>写在最后：<br>由于本人不太擅长编写shell脚本，所有其中的代码实现方式可能比较粗糙，望理解。</p>\n","cover":null,"images":["https://cdn.julis.wang/blog/img/20200301170230101.png","https://cdn.julis.wang/blog/img/20200301170616289.png","https://cdn.julis.wang/blog/img/20200301171856190.png","https://cdn.julis.wang/blog/img/20200301172119336.png"],"content":"<p>作为一名程序员，我们很想知道自己到底提交了多少行代码到远程仓库，有没有什么工具能够帮我们统计自己写过的代码行数呢？答案是有的。</p>\n<p>这是本次实现的最终效果:</p>\n<img width=\"60%\" src=\"https://cdn.julis.wang/blog/img/20200301170230101.png\">\n\n<h2 id=\"统计代码行数的方式\"><a href=\"#统计代码行数的方式\" class=\"headerlink\" title=\"统计代码行数的方式\"></a>统计代码行数的方式</h2><p>对于代码提交行数统计，通过git 的系统命令就能做到，如下代码所示</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">git <span class=\"built_in\">log</span> --author=<span class=\"string\">&#x27;username&#x27;</span> --pretty=tformat: --numstat | awk <span class=\"string\">&#x27;</span></span><br><span class=\"line\"><span class=\"string\">    &#123;add += $1; subs += $2; loc += $1 - $2 &#125; END &#123; printf &quot;添加了%s,删除了%s,合计%s\\n&quot;, add, subs, loc &#125;&#x27;</span> -</span><br><span class=\"line\">\t</span><br></pre></td></tr></table></figure>\n\n<p>只需要在如下命令输入自己的username就行了，效果如图所示·</p>\n<img src=\"https://cdn.julis.wang/blog/img/20200301170616289.png\">\n\n<p>但是有的人由于环境原因，为了区分一些环境，比如办公司叫：username.office 在家的电脑上叫做: user.home 诸如此类，难道得手动一个一个统计么？当然不行了。</p>\n<p>众所周知，由于工程项目变得更越来越大，拆库也说见不鲜，于是自己的代码分布不同的项目工程，我们想要利用git的统计命令的话就有点吃力了，需要一个一个地进入相应目录进行命令输入？当然不行了。</p>\n<p>今天自己写了一份脚本主要用于统计分布在某个文件夹下所有的代码提交行数，git开源地址：<a href=\"https://github.com/VomPom/ForFun\">https://github.com/VomPom/ForFun</a>源码如下</p>\n<p>如何使用？</p>\n<p>0、将自己需要统计的项目文件目录整理到一个文件夹</p>\n<p>1、讲users_name换成自己的的用户名</p>\n<p>2、由于文件夹下可能有一些例外的不需要统计，添加该文件夹名</p>\n<p>3、讲该shell脚本移动到某个名录下</p>\n<p>4、最后利用 sh codeLine.sh 执行命令</p>\n<img width=\"60%\" src=\"https://cdn.julis.wang/blog/img/20200301171856190.png\">\n<img width=\"60%\" src=\"https://cdn.julis.wang/blog/img/20200301172119336.png\">\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">########################################################</span></span><br><span class=\"line\"><span class=\"comment\">#</span></span><br><span class=\"line\"><span class=\"comment\"># Created by https://julis.wang on 2020/02/28</span></span><br><span class=\"line\"><span class=\"comment\">#</span></span><br><span class=\"line\"><span class=\"comment\"># Description : 统计代码提交行数</span></span><br><span class=\"line\"><span class=\"comment\">#</span></span><br><span class=\"line\"><span class=\"comment\">########################################################</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#!/bin/bash</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#这里添加你的git常用用户名。考虑到每个人的账号可能有很多个，所以定义成数组</span></span><br><span class=\"line\">users_name=(<span class=\"string\">&quot;julis&quot;</span> <span class=\"string\">&quot;julis.wang&quot;</span> <span class=\"string\">&quot;julis.wang.hp&quot;</span>)      </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#过滤一些不需要去遍历的文件夹</span></span><br><span class=\"line\">filter_path=(<span class=\"string\">&quot;Backend&quot;</span> <span class=\"string\">&quot;test&quot;</span> <span class=\"string\">&quot;sdk&quot;</span> <span class=\"string\">&quot;fork&quot;</span> <span class=\"string\">&quot;ArProject&quot;</span>)     </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">########################################################</span></span><br><span class=\"line\"><span class=\"comment\"># 以下代码不需动                       </span></span><br><span class=\"line\"><span class=\"comment\">########################################################</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">export</span> index=0             \t\t\t<span class=\"comment\">#记录当前的位置</span></span><br><span class=\"line\"><span class=\"built_in\">export</span> add_line_count=0             <span class=\"comment\">#添加的line总行数</span></span><br><span class=\"line\"><span class=\"built_in\">export</span> remove_line_count=0          <span class=\"comment\">#删除的总行数</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">export</span> array_git_repositories=()    <span class=\"comment\">#用于记录仓库名</span></span><br><span class=\"line\"><span class=\"built_in\">export</span> add_code=()                  <span class=\"comment\">#记录所有用户对某个库的添加的行数</span></span><br><span class=\"line\"><span class=\"built_in\">export</span> remove_code=()               <span class=\"comment\">#记录所有用户对某个库的删除的行数</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#判断是否需要过滤该目录</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"function\"><span class=\"title\">is_fileter_dir</span></span>() &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"string\">&quot;<span class=\"variable\">$&#123;!filter_path[@]&#125;</span>&quot;</span>; <span class=\"keyword\">do</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> [ <span class=\"variable\">$1</span> == <span class=\"string\">&quot;<span class=\"variable\">$&#123;filter_path[$i]&#125;</span>&quot;</span> ]; <span class=\"keyword\">then</span></span><br><span class=\"line\">\t\t\t<span class=\"built_in\">return</span> 1</span><br><span class=\"line\">\t\t<span class=\"keyword\">fi</span></span><br><span class=\"line\">\t<span class=\"keyword\">done</span></span><br><span class=\"line\">\t<span class=\"built_in\">return</span> 0</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">#对命令执行的返回值进行数据切割</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"function\"><span class=\"title\">get_add_remove_count</span></span>() &#123;</span><br><span class=\"line\">\tstring=<span class=\"variable\">$1</span></span><br><span class=\"line\">\tarray=(<span class=\"variable\">$&#123;string//,/ &#125;</span>)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> [ ! <span class=\"variable\">$&#123;array[0]&#125;</span> ]; <span class=\"keyword\">then</span></span><br><span class=\"line\">  \t\tadd_line=0</span><br><span class=\"line\">\t<span class=\"keyword\">else</span></span><br><span class=\"line\">  \t\tadd_line=<span class=\"variable\">$&#123;array[0]&#125;</span></span><br><span class=\"line\">\t<span class=\"keyword\">fi</span></span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> [ ! <span class=\"variable\">$&#123;array[1]&#125;</span> ]; <span class=\"keyword\">then</span></span><br><span class=\"line\">  \t\tremove_line=0</span><br><span class=\"line\">\t<span class=\"keyword\">else</span></span><br><span class=\"line\">  \t\tremove_line=<span class=\"variable\">$&#123;array[1]&#125;</span></span><br><span class=\"line\">\t<span class=\"keyword\">fi</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> [ ! <span class=\"variable\">$&#123;add_code[$index]&#125;</span> ]; <span class=\"keyword\">then</span></span><br><span class=\"line\">  \t\tadd_code[<span class=\"variable\">$index</span>]=0</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"keyword\">fi</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> [ ! <span class=\"variable\">$&#123;remove_code[$index]&#125;</span> ]; <span class=\"keyword\">then</span></span><br><span class=\"line\">  \t\tremove_code[<span class=\"variable\">$index</span>]=0</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"keyword\">fi</span></span><br><span class=\"line\">\tremove_code[<span class=\"variable\">$index</span>]=`<span class=\"built_in\">expr</span> <span class=\"variable\">$&#123;remove_code[$index]&#125;</span> + <span class=\"variable\">$remove_line</span>`</span><br><span class=\"line\">\tadd_code[<span class=\"variable\">$index</span>]=`<span class=\"built_in\">expr</span> <span class=\"variable\">$&#123;add_code[$index]&#125;</span> + <span class=\"variable\">$add_line</span>`</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">echo</span> <span class=\"string\">&quot;用户&quot;</span><span class=\"variable\">$2</span><span class=\"string\">&quot;添加了=&quot;</span><span class=\"variable\">$add_line</span><span class=\"string\">&quot;行 删除了&quot;</span><span class=\"variable\">$add_line</span><span class=\"string\">&quot;行&quot;</span></span><br><span class=\"line\">\t</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">#获取该用户在该文件夹下的提交代码数</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"function\"><span class=\"title\">get_user_line</span></span>() &#123;</span><br><span class=\"line\">\t<span class=\"comment\"># output分别去接收 该文件夹下的提交以及删除行数</span></span><br><span class=\"line\">\toutput=$(git <span class=\"built_in\">log</span> --author=<span class=\"variable\">$&#123;1&#125;</span> --pretty=tformat: --numstat | awk <span class=\"string\">&#x27;</span></span><br><span class=\"line\"><span class=\"string\">    &#123;add += $1; subs += $2; loc += $1 - $2 &#125; END &#123; printf &quot;添加了%s,删除了%s,合计%s\\n&quot;, add, subs, loc &#125;&#x27;</span> -)</span><br><span class=\"line\">\tget_add_remove_count <span class=\"variable\">$output</span> <span class=\"variable\">$&#123;1&#125;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#遍历每个用户名</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"function\"><span class=\"title\">trans_every_user</span></span>() &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"string\">&quot;<span class=\"variable\">$&#123;!users_name[@]&#125;</span>&quot;</span>; <span class=\"keyword\">do</span></span><br><span class=\"line\">\t\tget_user_line <span class=\"string\">&quot;<span class=\"variable\">$&#123;users_name[$i]&#125;</span>&quot;</span></span><br><span class=\"line\">\t<span class=\"keyword\">done</span></span><br><span class=\"line\">\t<span class=\"built_in\">cd</span> ..</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 整体流程，从文件夹出发</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> path <span class=\"keyword\">in</span> `<span class=\"built_in\">ls</span> -l $(<span class=\"built_in\">dirname</span> <span class=\"variable\">$0</span>)|awk -F <span class=\"string\">&quot; &quot;</span> <span class=\"string\">&#x27;&#123;print $9&#125;&#x27;</span>`</span><br><span class=\"line\"><span class=\"keyword\">do</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> [ -d <span class=\"variable\">$path</span> ]</span><br><span class=\"line\">    <span class=\"keyword\">then</span></span><br><span class=\"line\">        is_fileter_dir <span class=\"variable\">$path</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> [ $? == 1 ]</span><br><span class=\"line\">        <span class=\"keyword\">then</span></span><br><span class=\"line\">            <span class=\"built_in\">echo</span> <span class=\"string\">&quot;&lt;=========过滤了【&quot;</span><span class=\"variable\">$path</span><span class=\"string\">&quot;】======&gt;&quot;</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">            <span class=\"built_in\">echo</span> <span class=\"string\">&quot;&lt;=========获取【&quot;</span><span class=\"variable\">$path</span><span class=\"string\">&quot;】的Git代码提交数据======&gt;&quot;</span></span><br><span class=\"line\">\t\t\tindex=<span class=\"variable\">$&#123;#array_git_repositories[@]&#125;</span> <span class=\"comment\">#用于记录当前在第几个文件夹下处理</span></span><br><span class=\"line\">            array_git_repositories=(<span class=\"variable\">$&#123;array_git_repositories[@]&#125;</span> <span class=\"variable\">$path</span>)</span><br><span class=\"line\">\t\t\t</span><br><span class=\"line\">            <span class=\"built_in\">cd</span> <span class=\"variable\">$path</span></span><br><span class=\"line\">            trans_every_user</span><br><span class=\"line\">        <span class=\"keyword\">fi</span></span><br><span class=\"line\">    <span class=\"keyword\">fi</span></span><br><span class=\"line\"><span class=\"keyword\">done</span></span><br><span class=\"line\">all_add_line=0</span><br><span class=\"line\">all_remove_line=0</span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&#x27;===============================================================================&#x27;</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&quot;                  本次共统计了【&quot;</span><span class=\"variable\">$&#123;#array_git_repositories[@]&#125;</span><span class=\"string\">&quot;】个仓库   by julis.wang      &quot;</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&#x27;===============================================================================&#x27;</span></span><br><span class=\"line\"><span class=\"built_in\">printf</span> <span class=\"string\">&quot;%-30s %10s %10s %10s\\n&quot;</span> <span class=\"string\">&quot;Folder&quot;</span> <span class=\"string\">&quot;Add&quot;</span> <span class=\"string\">&quot;Remove&quot;</span> <span class=\"string\">&quot;All&quot;</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&#x27;-------------------------------------------------------------------------------&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> ((i=<span class=\"number\">0</span>;i&lt;<span class=\"variable\">$&#123;#array_git_repositories[@]&#125;</span>;i++))</span><br><span class=\"line\"><span class=\"keyword\">do</span></span><br><span class=\"line\">\tall_add_line=`<span class=\"built_in\">expr</span> <span class=\"variable\">$all_add_line</span> + <span class=\"variable\">$&#123;add_code[$i]&#125;</span>`</span><br><span class=\"line\">\tall_remove_line=`<span class=\"built_in\">expr</span> <span class=\"variable\">$all_remove_line</span> + <span class=\"variable\">$&#123;remove_code[$i]&#125;</span>`</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span> <span class=\"string\">&quot;%-30s %10s %10s %10s\\n&quot;</span> <span class=\"variable\">$&#123;array_git_repositories[$i]&#125;</span> <span class=\"variable\">$&#123;add_code[$i]&#125;</span> <span class=\"variable\">$&#123;remove_code[$i]&#125;</span> `<span class=\"built_in\">expr</span> <span class=\"variable\">$&#123;add_code[$i]&#125;</span> - <span class=\"variable\">$&#123;remove_code[$i]&#125;</span>`</span><br><span class=\"line\"><span class=\"keyword\">done</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&#x27;-------------------------------------------------------------------------------&#x27;</span></span><br><span class=\"line\"><span class=\"built_in\">printf</span> <span class=\"string\">&quot;%-30s %10s %10s %10s\\n&quot;</span> <span class=\"string\">&quot;Total&quot;</span> <span class=\"variable\">$all_add_line</span> <span class=\"variable\">$all_remove_line</span> `<span class=\"built_in\">expr</span> <span class=\"variable\">$all_add_line</span> - <span class=\"variable\">$all_remove_line</span>`</span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&#x27;===============================================================================&#x27;</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>写在最后：<br>由于本人不太擅长编写shell脚本，所有其中的代码实现方式可能比较粗糙，望理解。</p>\n","categories":[{"name":"技术文章","slug":"technology","api":"api/categories/technology.json"}],"tags":[{"name":"Shell","slug":"Shell","api":"api/tags/Shell.json"}],"api":"api/posts/2020/03/02/想统计自己总共提交了多少行代码？.json"},{"title":"从奶酪夹心饼干生产中来学习Android 中的gradle构建","slug":"从奶酪夹心饼干生产中来学习Android-中的gradle","date":"2019-12-18T11:48:00.000Z","updated":"2025-05-20T11:46:57.000Z","comments":true,"url":"2019/12/18/从奶酪夹心饼干生产中来学习Android-中的gradle/","excerpt":"<p>最近终于有机会做一些关于Android plugin相关的东西，之前虽然有学习过<code>《Android 权威指南》</code>一书，但是并没有进行一个实战操作，都是一些理论相关的学习。最近做了一个plugin主要是为了提取class文件里面的注解信息然后讲起搜集并上传。在实践中回过头发现很多知识都已经遗忘，所以本文对相关一些比较核心的知识进行一个回顾与梳理。</p>\n<h2 id=\"一、Gradle概述\"><a href=\"#一、Gradle概述\" class=\"headerlink\" title=\"一、Gradle概述\"></a>一、Gradle概述</h2><img src=\"https://cdn.julis.wang/blog/img/20191218190829347.png\">\n\n<p>在Android开发中，Gradle是每个开发者都会接触的，Gradle 是一个非常优秀的项目构建工具。这是大家都知道的，但是又有啥用呢？</p>\n<p>最开始的时候很难理解gradle到底是干什么的，相关知识都比较离散，所以很多东西没有串起来，从而导致理解起来比较困难。</p>\n<p>我自己总结就是：<strong>Gradle是一个构建工具，它存在的目的是产生一套“流水线”，对于安卓开发而言这个流水线就是从本地的编写代码以及资源整合到最终生成的产品过程。</strong></p>\n<p>用一个很形象的例子举例，我们现在要生产一包奶酪夹心饼干，于是我们得定义一个生产顺序：先让有的地方去生成饼干，有的地方生成出来奶酪，之后再让两块饼干夹着一块奶酪，最后再将它们装进一个小包装袋里面。</p>\n<p>另一种情况：如果我想在奶酪中加一点果酱，那么我们不需要重新建立一套生产线，只需要在两块饼干与奶酪结合的过程中修改一下加入果酱的流程。</p>\n<p>再另一种情况：如果我生产出来的奶酪夹心饼干不需要包装，那只需要在最后一个步骤让它另外走一条线路，毕竟没有包装的又不是不能吃，对吧？</p>\n<img src=\"https://cdn.julis.wang/blog/img/20191218143302953.png\">\n<p>如上图所示，我们定义了三种流程，每种流程最后的产出物是不一样的，因为流程的“<strong>初始化</strong>”的东西是不一样的以及过程中的“<strong>配置</strong>”，所以“<strong>执行</strong>”的时候就不一样。</p>\n<p>对比我们安卓开发：本地的Java文件以及资源文件就是对应的饼干以及奶酪，最终生成的面向用户的apk文件就是包装好的奶酪夹心饼干。</p>\n<p>如果我们想打Debug包，那么就像是一个散装的饼干，我们能自己用用，但是还不能面向用户，如果想打Release包那么就是最终的产品形态能直接面向用户。</p>\n<p>上面的例子讲得比较长，其实主要想让更多人能够更好地去理解gradle的用处。</p>\n<p>当我们每次点击Android Studio的 run运行按钮之后，会看到控制台输出一大堆相关日志，例如下图所示：</p>\n<img width=\"60%\" src=\"https://cdn.julis.wang/blog/img/20191218110343253.png\">\n\n<p>其实这些都是系统为我们封装好的一些task<br>点击 run 按钮，就相当于执行了一次 Gradle Task，一般来说，是Task <code>assembleDebug</code>或者Task <code>assembleRelease</code></p>\n<p>Gradle是目前Android主流的构建工具，无论通过命令行还是通过AndroidStudio来build，最终都是通过Gradle来实现的。以及Android领域的探索已经越来越深，不少技术领域如插件化、热修复、构建系统等都对Gradle有相关的需要。</p>\n<h2 id=\"二、Groovy\"><a href=\"#二、Groovy\" class=\"headerlink\" title=\"二、Groovy\"></a>二、Groovy</h2><p>知道了Gradle的用处之后，我们很形象的知道Gradle是为了去产生一个流水线。那这个流水线是利用什么做到的呢？对于奶酪饼干生产的工厂他们是不同的车间机械工具直接的逻辑组装。而对于Gradle则是利用<code>groovy</code>语言编写出来的相关脚本从而来进行一个编译相关的配置。这里不再具体描述groovy语言的具体用法，这里我列举出来几个自己认为比较重要的几个技术点。</p>\n<p><strong>1、Closure（闭包）</strong><br><code>闭包</code>是的groovy语言具有，而Java语言不具有的特性，有人说Lambda表达式就是闭包，但是两则还是有一定的差异的，有兴趣的同学可以去看看这篇<a href=\"https://editor.csdn.net/md/?articleId=102466814\">Java中Lambda表达式解析</a></p>\n<p>定义闭的语意 ：</p>\n<blockquote>\n<p><strong>{ [closureParameters -&gt; ] statements }</strong></p>\n</blockquote>\n<p>其中<code>[closureParameters-&gt;]</code>代表参数，多参数用逗号分割，用<code>-&gt;</code>隔开参数与内容，没有参数可以不写<code>-&gt;</code>例如我们精彩在.gradle文件里面看到这样的内容：</p>\n<img src=\"https://cdn.julis.wang/blog/img/20191218150133412.png\">\n\n<p>其中<code>projcet</code>就是<code>[closureParameters-&gt;]</code>，<code>-&gt;</code>之后的<code>respositories</code>就是statements，对于这段代码而言，statements里面又是一个闭包，如果改写成Java的样子就更形象了：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> <span class=\"title function_\">subprojercts</span><span class=\"params\">(Project projct)</span> &#123;</span><br><span class=\"line\">\tdoSomething....</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<p><strong>2、方法的输入参数优化</strong><br>groovy中定义的函数，如果至少有一个参数，在调用的时候可以省略括号。比如这样</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">def <span class=\"title function_\">func</span><span class=\"params\">(String a)</span>&#123;</span><br><span class=\"line\">  println(a)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">func &#x27;hello&#x27;</span><br></pre></td></tr></table></figure>\n<p>在gradle有大量省略括号调用函数的例子，比如</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">defaultConfig &#123;</span><br><span class=\"line\">        minSdkVersion rootProject.ext.minSdkVersion</span><br><span class=\"line\">        targetSdkVersion rootProject.targetSdkVersion</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>比如这里minSdkVersion 和 targetSdkVersion 其实就是调用了两个函数,传入了不同的参数，在AndroidStudio里面可以点进去查看函数实现</p>\n<p>当然如果某个函数没有参数，那就不能省略括号，否则会当成一个变量使用</p>\n<p><strong>3、类的Property</strong></p>\n<p>如果类的成员变量没有加任何权限访问，则称为<code>Property</code>, 否则是<code>Field</code>，filed和Java中的成员变量相同，但是<code>Property</code>的话，它是一个private field和getter setter的集合，也就是说groovy会自动生成getter setter方法，因此在类外面的代码，都是会透明的调用getter和setter方法。</p>\n<p><strong>4、Trait</strong></p>\n<p>特性使用关键字 trait 声明，可以拥有普通成员和抽象成员。例如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">trait MessageHandler &#123;</span><br><span class=\"line\">    <span class=\"comment\">//  属性</span></span><br><span class=\"line\">    <span class=\"type\">int</span> minLenght</span><br><span class=\"line\">    <span class=\"comment\">//  方法</span></span><br><span class=\"line\">    <span class=\"comment\">//  普通方法</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span> <span class=\"title function_\">echo</span><span class=\"params\">(String msg)</span> &#123;</span><br><span class=\"line\">        println(msg)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//  抽象方法</span></span><br><span class=\"line\">    <span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title function_\">show</span><span class=\"params\">(String msg)</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">trait AnotherMessageHandler &#123;</span><br><span class=\"line\">    <span class=\"comment\">//  抽象方法</span></span><br><span class=\"line\">    <span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title function_\">show</span><span class=\"params\">(String msg)</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Message</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">AnotherMessageHandler</span>, MessageHandler &#123;</span><br><span class=\"line\">.......</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Groovy 中特质本质上是运行时对接口的实现，所以其方法的访问控制符只支持 public 和 private。从代码的书写可以看出来<code>trait</code>又像java中的<code>abstract</code>类又像<code>interface</code>。<br>说他像<code>interface</code>是因为从编写上看就是使用了<code>implements</code>关键字，但是接口又不能使用普通方法。说他像抽象类，因为其内部使用了<code>abstract</code>定义抽象方法。但是它又能<code>implements</code>多个，而达到“多继承”的特性。因此它不是接口，也不是抽象类，它是 <code>trait</code>。</p>\n<h2 id=\"三、Gradle的依赖\"><a href=\"#三、Gradle的依赖\" class=\"headerlink\" title=\"三、Gradle的依赖\"></a>三、Gradle的依赖</h2><p>我们继续回到上面奶酪夹心饼干的生产上面，在产出奶酪夹心饼干之前，我们需要分别生产好单独的饼干与奶酪。假如我们的饼干原料有很多种，姑且我们叫他饼干v1，饼干v2……饼干vn ，奶酪也有很多种，我们叫它奶酪v1，奶酪v2……奶酪vn。那这么多种具体生产起来就应该有相关的选择，在Android开发中各种库都被单独抽了出来，只需要单独声明出来需要用哪个库即可。</p>\n<p>我们平时看的的<code>dependencies</code>如下所示</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">dependencies &#123;</span><br><span class=\"line\">    implementation <span class=\"title function_\">fileTree</span><span class=\"params\">(dir: <span class=\"string\">&#x27;libs&#x27;</span>, include: [<span class=\"string\">&#x27;*.jar&#x27;</span>])</span></span><br><span class=\"line\">    implementation <span class=\"string\">&#x27;com.android.support:appcompat-v7:28.0.0&#x27;</span></span><br><span class=\"line\">    implementation <span class=\"string\">&#x27;com.victor:lib:1.0.4&#x27;</span></span><br><span class=\"line\">    api <span class=\"string\">&#x27;com.android.support:recyclerview-v7:28.0.0&#x27;</span></span><br><span class=\"line\">    implementation <span class=\"string\">&#x27;com.google.code.gson:gson:2.8.6&#x27;</span></span><br><span class=\"line\">    implementation(<span class=\"string\">&#x27;com.wanjian:sak:0.1.0&#x27;</span>) &#123;</span><br><span class=\"line\">        exclude group: <span class=\"string\">&#x27;com.android.support&#x27;</span>, <span class=\"keyword\">module</span>: <span class=\"string\">&#x27;appcompat-v7&#x27;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>1、依赖配置</strong><br>Gradle依赖的配置中主要使用以下关键字，摘自<a href=\"https://developer.android.com/studio/build/dependencies?hl=zh-cn\">谷歌官方Gradle文档-&gt;添加编译依赖项</a></p>\n<p><strong>implementation</strong><br>Gradle 会将依赖项添加到编译类路径，并将依赖项打包到编译输出。不过，当您的模块配置 implementation 依赖项时，会让 Gradle 了解您不希望该模块在编译时将该依赖项泄露给其他模块。也就是说，其他模块只有在运行时才能使用该依赖项。</p>\n<p><strong>api</strong><br>Gradle 会将依赖项添加到编译类路径和编译输出。当一个模块包含 api 依赖项时，会让 Gradle 了解该模块要以传递方式将该依赖项导出到其他模块，以便这些模块在运行时和编译时都可以使用该依赖项</p>\n<p><strong>annotationProcessor</strong><br>要添加对作为注解处理器的库的依赖关系，您必须使用 annotationProcessor 配置将其添加到注解处理器类路径。这是因为，使用此配置可以将编译类路径与注解处理器类路径分开，从而提高编译性能。如果 Gradle 在编译类路径上找到注解处理器，则会禁用避免编译功能，这样会对编译时间产生负面影响（Gradle 5.0 及更高版本会忽略在编译类路径上找到的注解处理器）。</p>\n<p><strong>2、依赖的传递与冲突</strong><br>\t在Maven仓库中，构件通过POM（一种XML文件）来描述相关信息以及传递性依赖。Gradle 可以通过分析该文件获取获取所以依赖以及依赖的依赖和依赖的依赖的依赖，为了更加直观的表述，可以通过下面的输出结果了解。\n\t</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">+--- com.github.hotchemi:permissionsdispatcher:<span class=\"number\">2.2</span><span class=\"number\">.0</span></span><br><span class=\"line\">|    \\--- com.android.support:support-v4:<span class=\"number\">23.1</span><span class=\"number\">.1</span> -&gt; <span class=\"number\">28.0</span><span class=\"number\">.0</span></span><br><span class=\"line\">|         +--- com.android.support:support-compat:<span class=\"number\">28.0</span><span class=\"number\">.0</span></span><br><span class=\"line\">|         |    +--- com.android.support:support-annotations:<span class=\"number\">28.0</span><span class=\"number\">.0</span></span><br><span class=\"line\">|         |    +--- com.android.support:collections:<span class=\"number\">28.0</span><span class=\"number\">.0</span></span><br><span class=\"line\">|         |    |    \\--- com.android.support:support-annotations:<span class=\"number\">28.0</span><span class=\"number\">.0</span></span><br><span class=\"line\">|         |    +--- android.arch.lifecycle:runtime:<span class=\"number\">1.1</span><span class=\"number\">.1</span></span><br><span class=\"line\">|         |    |    +--- android.arch.lifecycle:common:<span class=\"number\">1.1</span><span class=\"number\">.1</span></span><br><span class=\"line\">|         |    |    |    \\--- com.android.support:support-annotations:<span class=\"number\">26.1</span><span class=\"number\">.0</span> -&gt; <span class=\"number\">28.0</span><span class=\"number\">.0</span></span><br><span class=\"line\">|         |    |    +--- android.arch.core:common:<span class=\"number\">1.1</span><span class=\"number\">.1</span></span><br><span class=\"line\">|         |    |    |    \\--- com.android.support:support-annotations:<span class=\"number\">26.1</span><span class=\"number\">.0</span> -&gt; <span class=\"number\">28.0</span><span class=\"number\">.0</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>我依赖hotchemi:permissionsdispatcher这个库，而它内部又陆陆续续地依赖了后面的一大堆。借助Gradle的传递性依赖特性，你无需再你的脚本中把这些依赖都声明一遍，你只需要简单的一行，Gradle便会帮你将传递性依赖一起下载下来。</p>\n<p>然而问题来了这里面依赖了：<code>android.arch.core:common:1.1.1</code>  而我本地其他地方又使用了<code>android.arch.core:common:1.0.0</code>老版本。那我该如何去做这件事呢？</p>\n<p>于是便有了如下关键词：<br><strong>exclude<br>force<br>transitive</strong></p>\n<p>具体作用如下代码所示</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">implementation (<span class=\"string\">&#x27;com.google.code.gson:gson:2.8.6&#x27;</span>) &#123;</span><br><span class=\"line\">    force = <span class=\"literal\">true</span> <span class=\"comment\">//强制使用这个版本的库</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">implementation (<span class=\"string\">&#x27;de.hdodenhof:circleimageview:3.0.1&#x27;</span>) &#123;</span><br><span class=\"line\">    transitive = <span class=\"literal\">true</span> <span class=\"comment\">//防止向外暴露</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">implementation(<span class=\"string\">&#x27;com.wanjian:sak:0.1.0&#x27;</span>) &#123;</span><br><span class=\"line\">    exclude group: <span class=\"string\">&#x27;com.android.support&#x27;</span>, <span class=\"keyword\">module</span>: <span class=\"string\">&#x27;appcompat-v7&#x27;</span> <span class=\"comment\">//排除里面不需要的库</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"四、Gradle的Task构建与执行\"><a href=\"#四、Gradle的Task构建与执行\" class=\"headerlink\" title=\"四、Gradle的Task构建与执行\"></a>四、Gradle的Task构建与执行</h2><p>再回到生产饼干的例子上面来，最开始我们定义了一些流程，然后再让机器以该流程去执行。</p>\n<p>比如先准备两块饼干再与奶酪进行加工生成夹心饼干，最后再加入包装。这是一条正确的流水，我们不可能让加入包装在加工生成夹心饼干之前。于是我们得定义一些约束，让其有正确的执行顺序。或者我们像加入果酱，那么就应该对原始的流程进行一些添加。</p>\n<p>对于Gradle中，我们以Task为单位，类比生产奶酪饼干，生成饼干是一个专门的Task，生成奶酪也是一个专门的Task，加工成夹心也是一个Task……对于Android开发，将java文件编译为class，再到最后的dex生成都是Task</p>\n<p>在Task的构建与执行中主要分为三个流程：</p>\n<p><strong>初始化（Initialization）</strong><br>settings.gradle确定参与构建的module<br>为每个module创建Project对象实例</p>\n<p><strong>配置（Configuration ）</strong><br>build.gradle脚本执行，配置对应project实例<br>创建有向无环图<br>通过finalizedBy指定后续<br>通过must&#x2F;shouldRunAfter约束执行顺序</p>\n<p><strong>执行（Execution ）</strong><br>根据关系图执行task<br>监听器</p>\n<p>主要流程如图所示（图片摘自<a href=\"https://www.jianshu.com/p/0acdb31eef2d\">https://www.jianshu.com/p/0acdb31eef2d</a>）：</p>\n<img src=\"https://cdn.julis.wang/blog/img/20191218190105218.png\">\n\n<h2 id=\"五、Gradle插件\"><a href=\"#五、Gradle插件\" class=\"headerlink\" title=\"五、Gradle插件\"></a>五、Gradle插件</h2><p>继续奶酪夹心饼干的故事，如果夹心饼干模样规规矩矩没有花纹，岂不是很low？于是工厂专门研发了一款能让饼干产生纹路的机器，并在加工成夹心饼干之前将纹路印到饼干上面去，假如这台机器我们把它叫做“印花纹机”，是一个能从整个生产流程中独立的出来的机器，这台“印花纹机”也能用在生产其他的饼干上。</p>\n<p>对应在我们的Android开发中，在构建流程中我们抽离出来一些功能，将其独立开来，这就是plugin，这里不再讲解plugin的编写相关操作，可以参考<a href=\"https://juejin.im/post/5cc5929bf265da036706b350\">Gradle 自定义 plugin</a></p>\n<p><strong>1、插件分类</strong></p>\n<p><strong>脚本插件</strong><br>顾名思义，如下图所示我们将对应的插件脚本中加入相关插件的逻辑，如下图所示，“other.gradle”便是一个插件</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">apply from: <span class=\"string\">&#x27;other.gradle&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>二进制插件</strong><br>二进制插件就是实现了 org.gradle.api.Plugin 接口的插件，每个 Java Gradle 插件都有一个 plugin id，可以通过如下方式使用一个 Java 插件：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">apply plugin : <span class=\"string\">&#x27;maven&#x27;</span></span><br></pre></td></tr></table></figure>\n<p>通过上述代码就将 Java 插件应用到我们的项目中了，其中 <code>maven</code> 是 Java 插件的 plugin id，对于 Gradle 自带的核心插件都有唯一的 plugin id</p>\n<p><strong>2、打包方式</strong><br>\t\t\t<br><strong>build script</strong><br>在插件分类中我们提到有<code>apply from: &#39;other.gradle&#39;</code> 其中<code>other.gradle</code>就是一个打包好的build script</p>\n<p><strong>buildSrc</strong><br>将插件写在工程根目录下的buildSrc目录下，这样可以在多个模块之间复用该插件。<br>buildSrc是Gradle在项目中配置自定义插件的默认目录，但它并不是标准的Android工程目录，所以使用这种方式需要我们事先手动创建一个buildSrc目录</p>\n<img width=\"60%\" src=\"https://cdn.julis.wang/blog/img/20191218194223783.png\">\n\n<p><strong>独立项目</strong>\t<br>创建独立的插件项目具有更强的灵活性，能让更多的工程使用这个插件，但流程也会相对复杂一点.这里不再具体讲解，可以参考<a href=\"https://juejin.im/post/5cc5929bf265da036706b350\">Gradle 自定义 plugin</a></p>\n<p>参考资料：</p>\n<p><a href=\"https://www.jianshu.com/p/6dc2074480b8\">https://www.jianshu.com/p/6dc2074480b8</a><br><a href=\"https://www.jianshu.com/p/bcaf9a269d96\">https://www.jianshu.com/p/bcaf9a269d96</a><br><a href=\"https://juejin.im/entry/59918304518825489151732d\">https://juejin.im/entry/59918304518825489151732d</a><br><a href=\"https://www.jianshu.com/p/0acdb31eef2d\">https://www.jianshu.com/p/0acdb31eef2d</a><br><a href=\"https://juejin.im/post/5cc5929bf265da036706b350\">https://juejin.im/post/5cc5929bf265da036706b350</a><br><a href=\"https://doc.yonyoucloud.com/doc/wiki/project/GradleUserGuide-Wiki/gradle_plugins/binary_plugins.html\">https://doc.yonyoucloud.com/doc/wiki/project/GradleUserGuide-Wiki/gradle_plugins/binary_plugins.html</a></p>\n","cover":null,"images":["https://cdn.julis.wang/blog/img/20191218190829347.png","https://cdn.julis.wang/blog/img/20191218143302953.png","https://cdn.julis.wang/blog/img/20191218110343253.png","https://cdn.julis.wang/blog/img/20191218150133412.png","https://cdn.julis.wang/blog/img/20191218190105218.png","https://cdn.julis.wang/blog/img/20191218194223783.png"],"content":"<p>最近终于有机会做一些关于Android plugin相关的东西，之前虽然有学习过<code>《Android 权威指南》</code>一书，但是并没有进行一个实战操作，都是一些理论相关的学习。最近做了一个plugin主要是为了提取class文件里面的注解信息然后讲起搜集并上传。在实践中回过头发现很多知识都已经遗忘，所以本文对相关一些比较核心的知识进行一个回顾与梳理。</p>\n<h2 id=\"一、Gradle概述\"><a href=\"#一、Gradle概述\" class=\"headerlink\" title=\"一、Gradle概述\"></a>一、Gradle概述</h2><img src=\"https://cdn.julis.wang/blog/img/20191218190829347.png\">\n\n<p>在Android开发中，Gradle是每个开发者都会接触的，Gradle 是一个非常优秀的项目构建工具。这是大家都知道的，但是又有啥用呢？</p>\n<p>最开始的时候很难理解gradle到底是干什么的，相关知识都比较离散，所以很多东西没有串起来，从而导致理解起来比较困难。</p>\n<p>我自己总结就是：<strong>Gradle是一个构建工具，它存在的目的是产生一套“流水线”，对于安卓开发而言这个流水线就是从本地的编写代码以及资源整合到最终生成的产品过程。</strong></p>\n<p>用一个很形象的例子举例，我们现在要生产一包奶酪夹心饼干，于是我们得定义一个生产顺序：先让有的地方去生成饼干，有的地方生成出来奶酪，之后再让两块饼干夹着一块奶酪，最后再将它们装进一个小包装袋里面。</p>\n<p>另一种情况：如果我想在奶酪中加一点果酱，那么我们不需要重新建立一套生产线，只需要在两块饼干与奶酪结合的过程中修改一下加入果酱的流程。</p>\n<p>再另一种情况：如果我生产出来的奶酪夹心饼干不需要包装，那只需要在最后一个步骤让它另外走一条线路，毕竟没有包装的又不是不能吃，对吧？</p>\n<img src=\"https://cdn.julis.wang/blog/img/20191218143302953.png\">\n<p>如上图所示，我们定义了三种流程，每种流程最后的产出物是不一样的，因为流程的“<strong>初始化</strong>”的东西是不一样的以及过程中的“<strong>配置</strong>”，所以“<strong>执行</strong>”的时候就不一样。</p>\n<p>对比我们安卓开发：本地的Java文件以及资源文件就是对应的饼干以及奶酪，最终生成的面向用户的apk文件就是包装好的奶酪夹心饼干。</p>\n<p>如果我们想打Debug包，那么就像是一个散装的饼干，我们能自己用用，但是还不能面向用户，如果想打Release包那么就是最终的产品形态能直接面向用户。</p>\n<p>上面的例子讲得比较长，其实主要想让更多人能够更好地去理解gradle的用处。</p>\n<p>当我们每次点击Android Studio的 run运行按钮之后，会看到控制台输出一大堆相关日志，例如下图所示：</p>\n<img width=\"60%\" src=\"https://cdn.julis.wang/blog/img/20191218110343253.png\">\n\n<p>其实这些都是系统为我们封装好的一些task<br>点击 run 按钮，就相当于执行了一次 Gradle Task，一般来说，是Task <code>assembleDebug</code>或者Task <code>assembleRelease</code></p>\n<p>Gradle是目前Android主流的构建工具，无论通过命令行还是通过AndroidStudio来build，最终都是通过Gradle来实现的。以及Android领域的探索已经越来越深，不少技术领域如插件化、热修复、构建系统等都对Gradle有相关的需要。</p>\n<h2 id=\"二、Groovy\"><a href=\"#二、Groovy\" class=\"headerlink\" title=\"二、Groovy\"></a>二、Groovy</h2><p>知道了Gradle的用处之后，我们很形象的知道Gradle是为了去产生一个流水线。那这个流水线是利用什么做到的呢？对于奶酪饼干生产的工厂他们是不同的车间机械工具直接的逻辑组装。而对于Gradle则是利用<code>groovy</code>语言编写出来的相关脚本从而来进行一个编译相关的配置。这里不再具体描述groovy语言的具体用法，这里我列举出来几个自己认为比较重要的几个技术点。</p>\n<p><strong>1、Closure（闭包）</strong><br><code>闭包</code>是的groovy语言具有，而Java语言不具有的特性，有人说Lambda表达式就是闭包，但是两则还是有一定的差异的，有兴趣的同学可以去看看这篇<a href=\"https://editor.csdn.net/md/?articleId=102466814\">Java中Lambda表达式解析</a></p>\n<p>定义闭的语意 ：</p>\n<blockquote>\n<p><strong>{ [closureParameters -&gt; ] statements }</strong></p>\n</blockquote>\n<p>其中<code>[closureParameters-&gt;]</code>代表参数，多参数用逗号分割，用<code>-&gt;</code>隔开参数与内容，没有参数可以不写<code>-&gt;</code>例如我们精彩在.gradle文件里面看到这样的内容：</p>\n<img src=\"https://cdn.julis.wang/blog/img/20191218150133412.png\">\n\n<p>其中<code>projcet</code>就是<code>[closureParameters-&gt;]</code>，<code>-&gt;</code>之后的<code>respositories</code>就是statements，对于这段代码而言，statements里面又是一个闭包，如果改写成Java的样子就更形象了：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> <span class=\"title function_\">subprojercts</span><span class=\"params\">(Project projct)</span> &#123;</span><br><span class=\"line\">\tdoSomething....</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<p><strong>2、方法的输入参数优化</strong><br>groovy中定义的函数，如果至少有一个参数，在调用的时候可以省略括号。比如这样</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">def <span class=\"title function_\">func</span><span class=\"params\">(String a)</span>&#123;</span><br><span class=\"line\">  println(a)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">func &#x27;hello&#x27;</span><br></pre></td></tr></table></figure>\n<p>在gradle有大量省略括号调用函数的例子，比如</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">defaultConfig &#123;</span><br><span class=\"line\">        minSdkVersion rootProject.ext.minSdkVersion</span><br><span class=\"line\">        targetSdkVersion rootProject.targetSdkVersion</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>比如这里minSdkVersion 和 targetSdkVersion 其实就是调用了两个函数,传入了不同的参数，在AndroidStudio里面可以点进去查看函数实现</p>\n<p>当然如果某个函数没有参数，那就不能省略括号，否则会当成一个变量使用</p>\n<p><strong>3、类的Property</strong></p>\n<p>如果类的成员变量没有加任何权限访问，则称为<code>Property</code>, 否则是<code>Field</code>，filed和Java中的成员变量相同，但是<code>Property</code>的话，它是一个private field和getter setter的集合，也就是说groovy会自动生成getter setter方法，因此在类外面的代码，都是会透明的调用getter和setter方法。</p>\n<p><strong>4、Trait</strong></p>\n<p>特性使用关键字 trait 声明，可以拥有普通成员和抽象成员。例如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">trait MessageHandler &#123;</span><br><span class=\"line\">    <span class=\"comment\">//  属性</span></span><br><span class=\"line\">    <span class=\"type\">int</span> minLenght</span><br><span class=\"line\">    <span class=\"comment\">//  方法</span></span><br><span class=\"line\">    <span class=\"comment\">//  普通方法</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span> <span class=\"title function_\">echo</span><span class=\"params\">(String msg)</span> &#123;</span><br><span class=\"line\">        println(msg)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//  抽象方法</span></span><br><span class=\"line\">    <span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title function_\">show</span><span class=\"params\">(String msg)</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">trait AnotherMessageHandler &#123;</span><br><span class=\"line\">    <span class=\"comment\">//  抽象方法</span></span><br><span class=\"line\">    <span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title function_\">show</span><span class=\"params\">(String msg)</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Message</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">AnotherMessageHandler</span>, MessageHandler &#123;</span><br><span class=\"line\">.......</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Groovy 中特质本质上是运行时对接口的实现，所以其方法的访问控制符只支持 public 和 private。从代码的书写可以看出来<code>trait</code>又像java中的<code>abstract</code>类又像<code>interface</code>。<br>说他像<code>interface</code>是因为从编写上看就是使用了<code>implements</code>关键字，但是接口又不能使用普通方法。说他像抽象类，因为其内部使用了<code>abstract</code>定义抽象方法。但是它又能<code>implements</code>多个，而达到“多继承”的特性。因此它不是接口，也不是抽象类，它是 <code>trait</code>。</p>\n<h2 id=\"三、Gradle的依赖\"><a href=\"#三、Gradle的依赖\" class=\"headerlink\" title=\"三、Gradle的依赖\"></a>三、Gradle的依赖</h2><p>我们继续回到上面奶酪夹心饼干的生产上面，在产出奶酪夹心饼干之前，我们需要分别生产好单独的饼干与奶酪。假如我们的饼干原料有很多种，姑且我们叫他饼干v1，饼干v2……饼干vn ，奶酪也有很多种，我们叫它奶酪v1，奶酪v2……奶酪vn。那这么多种具体生产起来就应该有相关的选择，在Android开发中各种库都被单独抽了出来，只需要单独声明出来需要用哪个库即可。</p>\n<p>我们平时看的的<code>dependencies</code>如下所示</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">dependencies &#123;</span><br><span class=\"line\">    implementation <span class=\"title function_\">fileTree</span><span class=\"params\">(dir: <span class=\"string\">&#x27;libs&#x27;</span>, include: [<span class=\"string\">&#x27;*.jar&#x27;</span>])</span></span><br><span class=\"line\">    implementation <span class=\"string\">&#x27;com.android.support:appcompat-v7:28.0.0&#x27;</span></span><br><span class=\"line\">    implementation <span class=\"string\">&#x27;com.victor:lib:1.0.4&#x27;</span></span><br><span class=\"line\">    api <span class=\"string\">&#x27;com.android.support:recyclerview-v7:28.0.0&#x27;</span></span><br><span class=\"line\">    implementation <span class=\"string\">&#x27;com.google.code.gson:gson:2.8.6&#x27;</span></span><br><span class=\"line\">    implementation(<span class=\"string\">&#x27;com.wanjian:sak:0.1.0&#x27;</span>) &#123;</span><br><span class=\"line\">        exclude group: <span class=\"string\">&#x27;com.android.support&#x27;</span>, <span class=\"keyword\">module</span>: <span class=\"string\">&#x27;appcompat-v7&#x27;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>1、依赖配置</strong><br>Gradle依赖的配置中主要使用以下关键字，摘自<a href=\"https://developer.android.com/studio/build/dependencies?hl=zh-cn\">谷歌官方Gradle文档-&gt;添加编译依赖项</a></p>\n<p><strong>implementation</strong><br>Gradle 会将依赖项添加到编译类路径，并将依赖项打包到编译输出。不过，当您的模块配置 implementation 依赖项时，会让 Gradle 了解您不希望该模块在编译时将该依赖项泄露给其他模块。也就是说，其他模块只有在运行时才能使用该依赖项。</p>\n<p><strong>api</strong><br>Gradle 会将依赖项添加到编译类路径和编译输出。当一个模块包含 api 依赖项时，会让 Gradle 了解该模块要以传递方式将该依赖项导出到其他模块，以便这些模块在运行时和编译时都可以使用该依赖项</p>\n<p><strong>annotationProcessor</strong><br>要添加对作为注解处理器的库的依赖关系，您必须使用 annotationProcessor 配置将其添加到注解处理器类路径。这是因为，使用此配置可以将编译类路径与注解处理器类路径分开，从而提高编译性能。如果 Gradle 在编译类路径上找到注解处理器，则会禁用避免编译功能，这样会对编译时间产生负面影响（Gradle 5.0 及更高版本会忽略在编译类路径上找到的注解处理器）。</p>\n<p><strong>2、依赖的传递与冲突</strong><br>\t在Maven仓库中，构件通过POM（一种XML文件）来描述相关信息以及传递性依赖。Gradle 可以通过分析该文件获取获取所以依赖以及依赖的依赖和依赖的依赖的依赖，为了更加直观的表述，可以通过下面的输出结果了解。\n\t</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">+--- com.github.hotchemi:permissionsdispatcher:<span class=\"number\">2.2</span><span class=\"number\">.0</span></span><br><span class=\"line\">|    \\--- com.android.support:support-v4:<span class=\"number\">23.1</span><span class=\"number\">.1</span> -&gt; <span class=\"number\">28.0</span><span class=\"number\">.0</span></span><br><span class=\"line\">|         +--- com.android.support:support-compat:<span class=\"number\">28.0</span><span class=\"number\">.0</span></span><br><span class=\"line\">|         |    +--- com.android.support:support-annotations:<span class=\"number\">28.0</span><span class=\"number\">.0</span></span><br><span class=\"line\">|         |    +--- com.android.support:collections:<span class=\"number\">28.0</span><span class=\"number\">.0</span></span><br><span class=\"line\">|         |    |    \\--- com.android.support:support-annotations:<span class=\"number\">28.0</span><span class=\"number\">.0</span></span><br><span class=\"line\">|         |    +--- android.arch.lifecycle:runtime:<span class=\"number\">1.1</span><span class=\"number\">.1</span></span><br><span class=\"line\">|         |    |    +--- android.arch.lifecycle:common:<span class=\"number\">1.1</span><span class=\"number\">.1</span></span><br><span class=\"line\">|         |    |    |    \\--- com.android.support:support-annotations:<span class=\"number\">26.1</span><span class=\"number\">.0</span> -&gt; <span class=\"number\">28.0</span><span class=\"number\">.0</span></span><br><span class=\"line\">|         |    |    +--- android.arch.core:common:<span class=\"number\">1.1</span><span class=\"number\">.1</span></span><br><span class=\"line\">|         |    |    |    \\--- com.android.support:support-annotations:<span class=\"number\">26.1</span><span class=\"number\">.0</span> -&gt; <span class=\"number\">28.0</span><span class=\"number\">.0</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>我依赖hotchemi:permissionsdispatcher这个库，而它内部又陆陆续续地依赖了后面的一大堆。借助Gradle的传递性依赖特性，你无需再你的脚本中把这些依赖都声明一遍，你只需要简单的一行，Gradle便会帮你将传递性依赖一起下载下来。</p>\n<p>然而问题来了这里面依赖了：<code>android.arch.core:common:1.1.1</code>  而我本地其他地方又使用了<code>android.arch.core:common:1.0.0</code>老版本。那我该如何去做这件事呢？</p>\n<p>于是便有了如下关键词：<br><strong>exclude<br>force<br>transitive</strong></p>\n<p>具体作用如下代码所示</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">implementation (<span class=\"string\">&#x27;com.google.code.gson:gson:2.8.6&#x27;</span>) &#123;</span><br><span class=\"line\">    force = <span class=\"literal\">true</span> <span class=\"comment\">//强制使用这个版本的库</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">implementation (<span class=\"string\">&#x27;de.hdodenhof:circleimageview:3.0.1&#x27;</span>) &#123;</span><br><span class=\"line\">    transitive = <span class=\"literal\">true</span> <span class=\"comment\">//防止向外暴露</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">implementation(<span class=\"string\">&#x27;com.wanjian:sak:0.1.0&#x27;</span>) &#123;</span><br><span class=\"line\">    exclude group: <span class=\"string\">&#x27;com.android.support&#x27;</span>, <span class=\"keyword\">module</span>: <span class=\"string\">&#x27;appcompat-v7&#x27;</span> <span class=\"comment\">//排除里面不需要的库</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"四、Gradle的Task构建与执行\"><a href=\"#四、Gradle的Task构建与执行\" class=\"headerlink\" title=\"四、Gradle的Task构建与执行\"></a>四、Gradle的Task构建与执行</h2><p>再回到生产饼干的例子上面来，最开始我们定义了一些流程，然后再让机器以该流程去执行。</p>\n<p>比如先准备两块饼干再与奶酪进行加工生成夹心饼干，最后再加入包装。这是一条正确的流水，我们不可能让加入包装在加工生成夹心饼干之前。于是我们得定义一些约束，让其有正确的执行顺序。或者我们像加入果酱，那么就应该对原始的流程进行一些添加。</p>\n<p>对于Gradle中，我们以Task为单位，类比生产奶酪饼干，生成饼干是一个专门的Task，生成奶酪也是一个专门的Task，加工成夹心也是一个Task……对于Android开发，将java文件编译为class，再到最后的dex生成都是Task</p>\n<p>在Task的构建与执行中主要分为三个流程：</p>\n<p><strong>初始化（Initialization）</strong><br>settings.gradle确定参与构建的module<br>为每个module创建Project对象实例</p>\n<p><strong>配置（Configuration ）</strong><br>build.gradle脚本执行，配置对应project实例<br>创建有向无环图<br>通过finalizedBy指定后续<br>通过must&#x2F;shouldRunAfter约束执行顺序</p>\n<p><strong>执行（Execution ）</strong><br>根据关系图执行task<br>监听器</p>\n<p>主要流程如图所示（图片摘自<a href=\"https://www.jianshu.com/p/0acdb31eef2d\">https://www.jianshu.com/p/0acdb31eef2d</a>）：</p>\n<img src=\"https://cdn.julis.wang/blog/img/20191218190105218.png\">\n\n<h2 id=\"五、Gradle插件\"><a href=\"#五、Gradle插件\" class=\"headerlink\" title=\"五、Gradle插件\"></a>五、Gradle插件</h2><p>继续奶酪夹心饼干的故事，如果夹心饼干模样规规矩矩没有花纹，岂不是很low？于是工厂专门研发了一款能让饼干产生纹路的机器，并在加工成夹心饼干之前将纹路印到饼干上面去，假如这台机器我们把它叫做“印花纹机”，是一个能从整个生产流程中独立的出来的机器，这台“印花纹机”也能用在生产其他的饼干上。</p>\n<p>对应在我们的Android开发中，在构建流程中我们抽离出来一些功能，将其独立开来，这就是plugin，这里不再讲解plugin的编写相关操作，可以参考<a href=\"https://juejin.im/post/5cc5929bf265da036706b350\">Gradle 自定义 plugin</a></p>\n<p><strong>1、插件分类</strong></p>\n<p><strong>脚本插件</strong><br>顾名思义，如下图所示我们将对应的插件脚本中加入相关插件的逻辑，如下图所示，“other.gradle”便是一个插件</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">apply from: <span class=\"string\">&#x27;other.gradle&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>二进制插件</strong><br>二进制插件就是实现了 org.gradle.api.Plugin 接口的插件，每个 Java Gradle 插件都有一个 plugin id，可以通过如下方式使用一个 Java 插件：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">apply plugin : <span class=\"string\">&#x27;maven&#x27;</span></span><br></pre></td></tr></table></figure>\n<p>通过上述代码就将 Java 插件应用到我们的项目中了，其中 <code>maven</code> 是 Java 插件的 plugin id，对于 Gradle 自带的核心插件都有唯一的 plugin id</p>\n<p><strong>2、打包方式</strong><br>\t\t\t<br><strong>build script</strong><br>在插件分类中我们提到有<code>apply from: &#39;other.gradle&#39;</code> 其中<code>other.gradle</code>就是一个打包好的build script</p>\n<p><strong>buildSrc</strong><br>将插件写在工程根目录下的buildSrc目录下，这样可以在多个模块之间复用该插件。<br>buildSrc是Gradle在项目中配置自定义插件的默认目录，但它并不是标准的Android工程目录，所以使用这种方式需要我们事先手动创建一个buildSrc目录</p>\n<img width=\"60%\" src=\"https://cdn.julis.wang/blog/img/20191218194223783.png\">\n\n<p><strong>独立项目</strong>\t<br>创建独立的插件项目具有更强的灵活性，能让更多的工程使用这个插件，但流程也会相对复杂一点.这里不再具体讲解，可以参考<a href=\"https://juejin.im/post/5cc5929bf265da036706b350\">Gradle 自定义 plugin</a></p>\n<p>参考资料：</p>\n<p><a href=\"https://www.jianshu.com/p/6dc2074480b8\">https://www.jianshu.com/p/6dc2074480b8</a><br><a href=\"https://www.jianshu.com/p/bcaf9a269d96\">https://www.jianshu.com/p/bcaf9a269d96</a><br><a href=\"https://juejin.im/entry/59918304518825489151732d\">https://juejin.im/entry/59918304518825489151732d</a><br><a href=\"https://www.jianshu.com/p/0acdb31eef2d\">https://www.jianshu.com/p/0acdb31eef2d</a><br><a href=\"https://juejin.im/post/5cc5929bf265da036706b350\">https://juejin.im/post/5cc5929bf265da036706b350</a><br><a href=\"https://doc.yonyoucloud.com/doc/wiki/project/GradleUserGuide-Wiki/gradle_plugins/binary_plugins.html\">https://doc.yonyoucloud.com/doc/wiki/project/GradleUserGuide-Wiki/gradle_plugins/binary_plugins.html</a></p>\n","categories":[{"name":"技术文章","slug":"technology","api":"api/categories/technology.json"}],"tags":[{"name":"Android","slug":"Android","api":"api/tags/Android.json"}],"api":"api/posts/2019/12/18/从奶酪夹心饼干生产中来学习Android-中的gradle.json"},{"title":"一款快速生成安卓shape的插件--NoCodeShape","slug":"一款快速生成Android-shape的插件-NoCodeShape","date":"2019-11-27T08:06:00.000Z","updated":"2025-05-20T11:46:57.000Z","comments":true,"url":"2019/11/27/一款快速生成Android-shape的插件-NoCodeShape/","excerpt":"<p>NoCodeShape 是一个能可视化界面操作生成Android中Shape.xml的Android Studio插件。对于新手能更好的去接受Android中相对应的属性，对于资深程序员则能简化操作，快速生成shape.xml。项目已经开源 <a href=\"https://github.com/VomPom/NoCodeShape\">NoCodeShape</a></p>\n<h1 id=\"二、NoCodeShape使用方法\"><a href=\"#二、NoCodeShape使用方法\" class=\"headerlink\" title=\"二、NoCodeShape使用方法\"></a>二、NoCodeShape使用方法</h1><h2 id=\"1-下载和安装\"><a href=\"#1-下载和安装\" class=\"headerlink\" title=\"1. 下载和安装\"></a>1. 下载和安装</h2><p>同一般的Android Studio插件下载一样，可以直接<code>Preferences-&gt;Plugins</code> 搜索 <code>NoCodeShape</code>搜索出来结果直接安装再重启即可。</p>\n<img width=\"60%\" src=\"https://cdn.julis.wang/blog/img/20191126190001658.png\">\n<p>也可以去jetbrains插件管理的官网下载各个版本的插件<br><a href=\"https://plugins.jetbrains.com/plugin/13325-nocodeshape/versions\">https://plugins.jetbrains.com/plugin/13325-nocodeshape/versions</a><br>然后<code>Preferences-&gt;Plugins</code> 再Install plugins from disk从本地安装</p>\n<h2 id=\"2-如何使用\"><a href=\"#2-如何使用\" class=\"headerlink\" title=\"2. 如何使用\"></a>2. 如何使用</h2><p>在新建一个shape.xml文件后，右键选择NoCodeShape或者直接按快捷键Common+U</p>\n<img src=\"https://cdn.julis.wang/blog/img/20191126192542676.png\">\n<p>然后选择自己想要的属性，随着点击事件的进行会生成相关xml代码，并在Android Studio右边有对应的shape形状的展示。如果对应shape.xml有相关属性，NoCodeShape也会生成对应shape.xml属性的操作界面，非常方便。<br>示例：</p>\n<img src=\"https://cdn.julis.wang/blog/img/20191126192336117.gif\">\n<h1 id=\"三、实现原理\"><a href=\"#三、实现原理\" class=\"headerlink\" title=\"三、实现原理\"></a>三、实现原理</h1><p>实现原理总体来说并不复杂，主要是界面相关操作逻辑比较繁琐。</p>\n<p>对于新生成的一个shape.xml来说只需要弹出一个新的操作界面，用户只需要点击对应模块的属性即可。项目使用了<code>单例模式+Bulider建造者模式</code>去管理各个Shape属性，分别生成 <code>Shape、Solid、Corners、Stroke、Gradient</code>的单例，其内部拥有一个Builder用来去承各类型的具体属性。</p>\n<p>  通过界面的操作，对其内部的<code>Builder</code>进行数据的填充，最后在完成各类操作后，将各类型中的Builder中的所有属性提取出并生成一份完整的xml字符串并将其粘贴到Android Studio的操作界面上。</p>\n<p>实现主要分为两大类：</p>\n<h2 id=\"1-拼接生成xml字符串\"><a href=\"#1-拼接生成xml字符串\" class=\"headerlink\" title=\"1. 拼接生成xml字符串\"></a>1. 拼接生成xml字符串</h2><p>字符串拼接算是其中最复杂的部分，一是各shape的类型拥有较多数据，其中一些属性有逻辑存在性，二是生成最终Android Studio的xml字符串的时候格式存在比较多的处理。对于各类属性都继承于<code>BaseXml</code>，其内部拥有一个静态内部<code>Builder</code>类，以相对简单的Solid类来举例，如下所示：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Solid</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">BaseXml</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Builder builder;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"type\">Solid</span> <span class=\"variable\">instance</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Solid <span class=\"title function_\">getInstance</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (instance == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            builder = <span class=\"keyword\">new</span> <span class=\"title class_\">Builder</span>();</span><br><span class=\"line\">            instance = <span class=\"keyword\">new</span> <span class=\"title class_\">Solid</span>();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\"> <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Builder</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">BaseBuilder</span> &#123;</span><br><span class=\"line\">        String color;</span><br><span class=\"line\">        String colorValue;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">setColor</span><span class=\"params\">(String color)</span> &#123;</span><br><span class=\"line\">            <span class=\"built_in\">this</span>.colorValue = color;</span><br><span class=\"line\">            <span class=\"built_in\">this</span>.color = getAttrWithOutUnitStr(<span class=\"string\">&quot;color&quot;</span>, color);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"keyword\">public</span> String <span class=\"title function_\">getBuilderString</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> StringUtils.getString(color);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">clearData</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">            StringUtils.clearObjectData(<span class=\"built_in\">this</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">analysisAttribute</span><span class=\"params\">(Attributes attributes)</span> &#123;</span><br><span class=\"line\">            Solid.getInstance().setChecked(<span class=\"literal\">true</span>);</span><br><span class=\"line\">            setColor(attributes.getValue(<span class=\"string\">&quot;android:color&quot;</span>));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>其类继承于抽象类BaseXml，代码如下所示：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">class</span> <span class=\"title class_\">BaseXml</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">boolean</span> <span class=\"variable\">isChecked</span> <span class=\"operator\">=</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">getCloser</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot; /&gt;&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">getStartTag</span><span class=\"params\">()</span> &#123; </span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">generateXmlString</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">protected</span> String <span class=\"title function_\">getLineFeedString</span><span class=\"params\">()</span> &#123; </span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;\\n&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">isChecked</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> isChecked;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> BaseXml <span class=\"title function_\">setChecked</span><span class=\"params\">(<span class=\"type\">boolean</span> checked)</span> &#123;</span><br><span class=\"line\">        isChecked = checked;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>抽象类提取出来在字符串拼接阶段，各类型常用的基本操作，例如：返回“&lt;solid”这类的开始标签，” &#x2F;&gt;”结束标签等</p>\n<p>其内部<code>BaseXml</code>拥有对应类拥有的所有属性的常用操作，其继承与抽象类<code>BaseBuilder</code>，代码如下所示</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">class</span> <span class=\"title class_\">BaseBuilder</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> String <span class=\"title function_\">getBuilderString</span><span class=\"params\">()</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title function_\">clearData</span><span class=\"params\">()</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title function_\">analysisAttribute</span><span class=\"params\">(Attributes attributes)</span>;</span><br><span class=\"line\">    <span class=\"keyword\">protected</span> <span class=\"keyword\">final</span> String <span class=\"title function_\">getAttrWithUnitStr</span><span class=\"params\">(String attributeType, String value)</span> &#123;</span><br><span class=\"line\">        String unit;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (TextUtils.isEmpty(value)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"string\">&quot;&quot;</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (value.contains(<span class=\"string\">&quot;px&quot;</span>) || value.contains(<span class=\"string\">&quot;dp&quot;</span>)) &#123;</span><br><span class=\"line\">            unit = <span class=\"string\">&quot;&quot;</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            unit = DefaultData.UNIT;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;android:&quot;</span> + attributeType + <span class=\"string\">&quot;=\\&quot;&quot;</span> + value + unit + <span class=\"string\">&quot;\\&quot;&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">protected</span> <span class=\"keyword\">final</span> String <span class=\"title function_\">getAttrWithOutUnitStr</span><span class=\"params\">(String attributeType, String value)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (TextUtils.isEmpty(value)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"string\">&quot;&quot;</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;android:&quot;</span> + attributeType + <span class=\"string\">&quot;=\\&quot;&quot;</span> + value + <span class=\"string\">&quot;\\&quot;&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">protected</span> <span class=\"keyword\">final</span> String <span class=\"title function_\">getValueOutUnit</span><span class=\"params\">(String value)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (TextUtils.isEmpty(value)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> value;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> value.replace(<span class=\"string\">&quot;dp&quot;</span>, <span class=\"string\">&quot;&quot;</span>).replace(<span class=\"string\">&quot;px&quot;</span>, <span class=\"string\">&quot;&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>BaseBuilder内部封装了一些属性的常用操作，例如生成：<code>android:color=&quot;#FFFFFF&quot;</code>这样的字符串，获取是否带有单位的字串等。<br>并提供三个抽象方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> String <span class=\"title function_\">getBuilderString</span><span class=\"params\">()</span>; <span class=\"comment\">//获取Builder中所有属性拼接好的字符串</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title function_\">clearData</span><span class=\"params\">()</span>; <span class=\"comment\">//清空Builder内部属性值</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title function_\">analysisAttribute</span><span class=\"params\">(Attributes attributes)</span>; <span class=\"comment\">//分析xml数据中的值，这个在第二大点“将原有shape.xml字符串转化为对应操作界面”中将会讲到</span></span><br></pre></td></tr></table></figure>\n\n<p>以上是基本数据的构造，在最后在控件交互的地方会调用<code>CommonAction</code>类的<code>refreshAndWriteData</code>：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">abstract</span> <span class=\"keyword\">class</span> <span class=\"title class_\">CommonAction</span> &#123;</span><br><span class=\"line\">    JComponent component;</span><br><span class=\"line\">    NoShapeDialog noShapeDialog;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">void</span> <span class=\"title function_\">refreshAndWriteData</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        NoCodeShapeAction.callWriteData();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>最后会调用基本的Action中的<code>writeData()</code>方法，其具体逻辑为</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">    * 数据写入xml文件</span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">   <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">writeData</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">       <span class=\"keyword\">final</span> <span class=\"type\">Document</span> <span class=\"variable\">document</span> <span class=\"operator\">=</span> FileDocumentManager.getInstance().getDocument(file);</span><br><span class=\"line\">       <span class=\"keyword\">if</span> (document == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">           <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">               <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Exception</span>(<span class=\"string\">&quot;Document对象为空&quot;</span>);</span><br><span class=\"line\">           &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">               e.printStackTrace();</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">           <span class=\"keyword\">return</span>;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       <span class=\"keyword\">new</span> <span class=\"title class_\">WriteCommandAction</span>.Simple(project) &#123;</span><br><span class=\"line\">           <span class=\"meta\">@Override</span></span><br><span class=\"line\">           <span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">               document.setText(XMLString.getInstance().generateXmlString());</span><br><span class=\"line\">               <span class=\"comment\">//formatCode();</span></span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">       &#125;.execute();</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>利用<code>XMLString.getInstance().generateXmlString()</code>获取各操作类型的所有属性将其拼接为一份完整的shape.xml文件的字段，最后调用插件系统的相关命令将字符串粘贴在系统对应的输入框中。</p>\n<h2 id=\"2-将原有shape-xml字符串转化为对应操作界面\"><a href=\"#2-将原有shape-xml字符串转化为对应操作界面\" class=\"headerlink\" title=\"2. 将原有shape.xml字符串转化为对应操作界面\"></a>2. 将原有shape.xml字符串转化为对应操作界面</h2><p>上面已经讲述类如何拼接生成xml字符串并将其粘贴到Android Studio界面上，此外NoCodeShape不仅支持新生成的shape.xml，同样也支持对旧shape.xml进行修改的能力。与第一步相比较主要多了一步读取Android Studio xml文档并将其转化为对应操作界面的过程。其主要是在操作界面初始化之前执行了如下方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">initSax</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">       <span class=\"type\">String</span> <span class=\"variable\">text</span> <span class=\"operator\">=</span> FileDocumentManager.getInstance().getDocument(file).getText();</span><br><span class=\"line\">       <span class=\"type\">ShapeSaxHandler</span> <span class=\"variable\">handler</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ShapeSaxHandler</span>();</span><br><span class=\"line\">       <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">           handler.createViewList(text);</span><br><span class=\"line\">       &#125; <span class=\"keyword\">catch</span> (ParserConfigurationException e) &#123;</span><br><span class=\"line\">           e.printStackTrace();</span><br><span class=\"line\">       &#125; <span class=\"keyword\">catch</span> (SAXException e) &#123;</span><br><span class=\"line\">           e.printStackTrace();</span><br><span class=\"line\">       &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">           e.printStackTrace();</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n<p>利用ShapeSaxHandler去解析xml里面的元素，参考了<a href=\"https://github.com/laobie/FindViewByMe\">FindViewByMe</a>的解析原理。</p>\n<p>具体操作逻辑如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">createViewList</span><span class=\"params\">(String string)</span> <span class=\"keyword\">throws</span> ParserConfigurationException, SAXException, IOException &#123;</span><br><span class=\"line\">      <span class=\"type\">InputStream</span> <span class=\"variable\">xmlStream</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ByteArrayInputStream</span>(string.getBytes(<span class=\"string\">&quot;UTF-8&quot;</span>));</span><br><span class=\"line\">      <span class=\"type\">SAXParserFactory</span> <span class=\"variable\">factory</span> <span class=\"operator\">=</span> SAXParserFactory.newInstance();</span><br><span class=\"line\">      <span class=\"type\">SAXParser</span> <span class=\"variable\">parser</span> <span class=\"operator\">=</span> factory.newSAXParser();</span><br><span class=\"line\">      parser.parse(xmlStream, <span class=\"built_in\">this</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">startDocument</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> SAXException &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (shapePartList == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">          shapePartList = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;ShapePart&gt;();</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">startElement</span><span class=\"params\">(String uri, String localName, String qName, Attributes attributes)</span> <span class=\"keyword\">throws</span> SAXException &#123;</span><br><span class=\"line\">      <span class=\"keyword\">switch</span> (qName) &#123;</span><br><span class=\"line\">          <span class=\"keyword\">case</span> <span class=\"string\">&quot;shape&quot;</span>:</span><br><span class=\"line\">              Shape.getInstance().getBuilder().analysisAttribute(attributes);</span><br><span class=\"line\">              <span class=\"keyword\">break</span>;</span><br><span class=\"line\">          <span class=\"keyword\">case</span> <span class=\"string\">&quot;stroke&quot;</span>:</span><br><span class=\"line\">              Stroke.getInstance().getBuilder().analysisAttribute(attributes);</span><br><span class=\"line\">              <span class=\"keyword\">break</span>;</span><br><span class=\"line\">          <span class=\"keyword\">case</span> <span class=\"string\">&quot;solid&quot;</span>:</span><br><span class=\"line\">             Solid.getInstance().getBuilder().analysisAttribute(attributes);</span><br><span class=\"line\">              <span class=\"keyword\">break</span>;</span><br><span class=\"line\">          <span class=\"keyword\">case</span> <span class=\"string\">&quot;gradient&quot;</span>:</span><br><span class=\"line\">              Gradient.getInstance().getBuilder().analysisAttribute(attributes);</span><br><span class=\"line\">              <span class=\"keyword\">break</span>;</span><br><span class=\"line\">          <span class=\"keyword\">case</span> <span class=\"string\">&quot;corners&quot;</span>:</span><br><span class=\"line\">              Corners.getInstance().getBuilder().analysisAttribute(attributes);</span><br><span class=\"line\">              <span class=\"keyword\">break</span>;</span><br><span class=\"line\">          <span class=\"keyword\">default</span>:</span><br><span class=\"line\">              <span class=\"keyword\">break</span>;</span><br><span class=\"line\">      &#125;</span><br></pre></td></tr></table></figure>\n<p>逻辑其实很清楚，主要对startTag的判断，然后通过调用 <code>public abstract void analysisAttribute(Attributes attributes);</code>的方法对相应的 类型的Buidler进行一个赋值操作。</p>\n<p>以Stroke为例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">analysisAttribute</span><span class=\"params\">(Attributes attributes)</span> &#123;</span><br><span class=\"line\">            Stroke.getInstance().setChecked(<span class=\"literal\">true</span>);</span><br><span class=\"line\">            setColor(attributes.getValue(<span class=\"string\">&quot;android:color&quot;</span>));</span><br><span class=\"line\">            setDashGap(attributes.getValue(<span class=\"string\">&quot;android:dashGap&quot;</span>));</span><br><span class=\"line\">            setWidth(attributes.getValue(<span class=\"string\">&quot;android:width&quot;</span>));</span><br><span class=\"line\">            setDashWidth(attributes.getValue(<span class=\"string\">&quot;android:dashWidth&quot;</span>));</span><br><span class=\"line\">        &#125;</span><br></pre></td></tr></table></figure>\n<p>主要是获取到其中的属性，并对初始化的界面进行一些操作(例如选中或者赋值相关操作)。</p>\n<h1 id=\"四、总结\"><a href=\"#四、总结\" class=\"headerlink\" title=\"四、总结\"></a>四、总结</h1><p>这个插件算是自己第一次做一个相对较实用的插件，都是利用工作的空闲事件进行编写，前前后后进行了将近一个月，其中收获颇多，但也踩过了各种各样的坑。在开发过程中由于相关文档较少，通过阅读官方文档还是有点小吃力，不过一步步还是走了下来，自己也得到了成长。其中坑也都添平了，但由于一些基础技术的欠缺，比如对Java GUI界面编程不太熟悉，导致开发过程中有很大一段时间都在跟界面作对，因此后面有机会将去深入了解Java的界面编程，争取能够将页面交互能够做到更好。</p>\n<p>另外由于自身开发精力的原因，不能将插件做到完美，目前插件中还有如下几个问题：</p>\n<p>1、Gradient中对应相关逻辑还需要再优化<br>2、还未支持Size跟Pading（从自身所处环境考虑用得较少，所以暂未支持）<br>3、对于颜色选择器默认打开后不支持对本地颜色字符串处理<br>4、存在大量的界面操作逻辑代码，需要优化</p>\n<p>最后，希望大家能在使用过程中提出相关的意见或建议，也欢迎能一起加入到开发中，从而能将该插件做得更加完美。</p>\n<p>项目地址：</p>\n<p><a href=\"https://github.com/VomPom/NoCodeShape\">https://github.com/VomPom/NoCodeShape</a></p>\n","cover":null,"images":["https://cdn.julis.wang/blog/img/20191126190001658.png","https://cdn.julis.wang/blog/img/20191126192542676.png","https://cdn.julis.wang/blog/img/20191126192336117.gif"],"content":"<p>NoCodeShape 是一个能可视化界面操作生成Android中Shape.xml的Android Studio插件。对于新手能更好的去接受Android中相对应的属性，对于资深程序员则能简化操作，快速生成shape.xml。项目已经开源 <a href=\"https://github.com/VomPom/NoCodeShape\">NoCodeShape</a></p>\n<h1 id=\"二、NoCodeShape使用方法\"><a href=\"#二、NoCodeShape使用方法\" class=\"headerlink\" title=\"二、NoCodeShape使用方法\"></a>二、NoCodeShape使用方法</h1><h2 id=\"1-下载和安装\"><a href=\"#1-下载和安装\" class=\"headerlink\" title=\"1. 下载和安装\"></a>1. 下载和安装</h2><p>同一般的Android Studio插件下载一样，可以直接<code>Preferences-&gt;Plugins</code> 搜索 <code>NoCodeShape</code>搜索出来结果直接安装再重启即可。</p>\n<img width=\"60%\" src=\"https://cdn.julis.wang/blog/img/20191126190001658.png\">\n<p>也可以去jetbrains插件管理的官网下载各个版本的插件<br><a href=\"https://plugins.jetbrains.com/plugin/13325-nocodeshape/versions\">https://plugins.jetbrains.com/plugin/13325-nocodeshape/versions</a><br>然后<code>Preferences-&gt;Plugins</code> 再Install plugins from disk从本地安装</p>\n<h2 id=\"2-如何使用\"><a href=\"#2-如何使用\" class=\"headerlink\" title=\"2. 如何使用\"></a>2. 如何使用</h2><p>在新建一个shape.xml文件后，右键选择NoCodeShape或者直接按快捷键Common+U</p>\n<img src=\"https://cdn.julis.wang/blog/img/20191126192542676.png\">\n<p>然后选择自己想要的属性，随着点击事件的进行会生成相关xml代码，并在Android Studio右边有对应的shape形状的展示。如果对应shape.xml有相关属性，NoCodeShape也会生成对应shape.xml属性的操作界面，非常方便。<br>示例：</p>\n<img src=\"https://cdn.julis.wang/blog/img/20191126192336117.gif\">\n<h1 id=\"三、实现原理\"><a href=\"#三、实现原理\" class=\"headerlink\" title=\"三、实现原理\"></a>三、实现原理</h1><p>实现原理总体来说并不复杂，主要是界面相关操作逻辑比较繁琐。</p>\n<p>对于新生成的一个shape.xml来说只需要弹出一个新的操作界面，用户只需要点击对应模块的属性即可。项目使用了<code>单例模式+Bulider建造者模式</code>去管理各个Shape属性，分别生成 <code>Shape、Solid、Corners、Stroke、Gradient</code>的单例，其内部拥有一个Builder用来去承各类型的具体属性。</p>\n<p>  通过界面的操作，对其内部的<code>Builder</code>进行数据的填充，最后在完成各类操作后，将各类型中的Builder中的所有属性提取出并生成一份完整的xml字符串并将其粘贴到Android Studio的操作界面上。</p>\n<p>实现主要分为两大类：</p>\n<h2 id=\"1-拼接生成xml字符串\"><a href=\"#1-拼接生成xml字符串\" class=\"headerlink\" title=\"1. 拼接生成xml字符串\"></a>1. 拼接生成xml字符串</h2><p>字符串拼接算是其中最复杂的部分，一是各shape的类型拥有较多数据，其中一些属性有逻辑存在性，二是生成最终Android Studio的xml字符串的时候格式存在比较多的处理。对于各类属性都继承于<code>BaseXml</code>，其内部拥有一个静态内部<code>Builder</code>类，以相对简单的Solid类来举例，如下所示：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Solid</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">BaseXml</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Builder builder;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"type\">Solid</span> <span class=\"variable\">instance</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Solid <span class=\"title function_\">getInstance</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (instance == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            builder = <span class=\"keyword\">new</span> <span class=\"title class_\">Builder</span>();</span><br><span class=\"line\">            instance = <span class=\"keyword\">new</span> <span class=\"title class_\">Solid</span>();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\"> <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Builder</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">BaseBuilder</span> &#123;</span><br><span class=\"line\">        String color;</span><br><span class=\"line\">        String colorValue;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">setColor</span><span class=\"params\">(String color)</span> &#123;</span><br><span class=\"line\">            <span class=\"built_in\">this</span>.colorValue = color;</span><br><span class=\"line\">            <span class=\"built_in\">this</span>.color = getAttrWithOutUnitStr(<span class=\"string\">&quot;color&quot;</span>, color);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"keyword\">public</span> String <span class=\"title function_\">getBuilderString</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> StringUtils.getString(color);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">clearData</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">            StringUtils.clearObjectData(<span class=\"built_in\">this</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">analysisAttribute</span><span class=\"params\">(Attributes attributes)</span> &#123;</span><br><span class=\"line\">            Solid.getInstance().setChecked(<span class=\"literal\">true</span>);</span><br><span class=\"line\">            setColor(attributes.getValue(<span class=\"string\">&quot;android:color&quot;</span>));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>其类继承于抽象类BaseXml，代码如下所示：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">class</span> <span class=\"title class_\">BaseXml</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">boolean</span> <span class=\"variable\">isChecked</span> <span class=\"operator\">=</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">getCloser</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot; /&gt;&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">getStartTag</span><span class=\"params\">()</span> &#123; </span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">generateXmlString</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">protected</span> String <span class=\"title function_\">getLineFeedString</span><span class=\"params\">()</span> &#123; </span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;\\n&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">isChecked</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> isChecked;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> BaseXml <span class=\"title function_\">setChecked</span><span class=\"params\">(<span class=\"type\">boolean</span> checked)</span> &#123;</span><br><span class=\"line\">        isChecked = checked;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>抽象类提取出来在字符串拼接阶段，各类型常用的基本操作，例如：返回“&lt;solid”这类的开始标签，” &#x2F;&gt;”结束标签等</p>\n<p>其内部<code>BaseXml</code>拥有对应类拥有的所有属性的常用操作，其继承与抽象类<code>BaseBuilder</code>，代码如下所示</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">class</span> <span class=\"title class_\">BaseBuilder</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> String <span class=\"title function_\">getBuilderString</span><span class=\"params\">()</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title function_\">clearData</span><span class=\"params\">()</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title function_\">analysisAttribute</span><span class=\"params\">(Attributes attributes)</span>;</span><br><span class=\"line\">    <span class=\"keyword\">protected</span> <span class=\"keyword\">final</span> String <span class=\"title function_\">getAttrWithUnitStr</span><span class=\"params\">(String attributeType, String value)</span> &#123;</span><br><span class=\"line\">        String unit;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (TextUtils.isEmpty(value)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"string\">&quot;&quot;</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (value.contains(<span class=\"string\">&quot;px&quot;</span>) || value.contains(<span class=\"string\">&quot;dp&quot;</span>)) &#123;</span><br><span class=\"line\">            unit = <span class=\"string\">&quot;&quot;</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            unit = DefaultData.UNIT;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;android:&quot;</span> + attributeType + <span class=\"string\">&quot;=\\&quot;&quot;</span> + value + unit + <span class=\"string\">&quot;\\&quot;&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">protected</span> <span class=\"keyword\">final</span> String <span class=\"title function_\">getAttrWithOutUnitStr</span><span class=\"params\">(String attributeType, String value)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (TextUtils.isEmpty(value)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"string\">&quot;&quot;</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;android:&quot;</span> + attributeType + <span class=\"string\">&quot;=\\&quot;&quot;</span> + value + <span class=\"string\">&quot;\\&quot;&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">protected</span> <span class=\"keyword\">final</span> String <span class=\"title function_\">getValueOutUnit</span><span class=\"params\">(String value)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (TextUtils.isEmpty(value)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> value;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> value.replace(<span class=\"string\">&quot;dp&quot;</span>, <span class=\"string\">&quot;&quot;</span>).replace(<span class=\"string\">&quot;px&quot;</span>, <span class=\"string\">&quot;&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>BaseBuilder内部封装了一些属性的常用操作，例如生成：<code>android:color=&quot;#FFFFFF&quot;</code>这样的字符串，获取是否带有单位的字串等。<br>并提供三个抽象方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> String <span class=\"title function_\">getBuilderString</span><span class=\"params\">()</span>; <span class=\"comment\">//获取Builder中所有属性拼接好的字符串</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title function_\">clearData</span><span class=\"params\">()</span>; <span class=\"comment\">//清空Builder内部属性值</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title function_\">analysisAttribute</span><span class=\"params\">(Attributes attributes)</span>; <span class=\"comment\">//分析xml数据中的值，这个在第二大点“将原有shape.xml字符串转化为对应操作界面”中将会讲到</span></span><br></pre></td></tr></table></figure>\n\n<p>以上是基本数据的构造，在最后在控件交互的地方会调用<code>CommonAction</code>类的<code>refreshAndWriteData</code>：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">abstract</span> <span class=\"keyword\">class</span> <span class=\"title class_\">CommonAction</span> &#123;</span><br><span class=\"line\">    JComponent component;</span><br><span class=\"line\">    NoShapeDialog noShapeDialog;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">void</span> <span class=\"title function_\">refreshAndWriteData</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        NoCodeShapeAction.callWriteData();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>最后会调用基本的Action中的<code>writeData()</code>方法，其具体逻辑为</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">    * 数据写入xml文件</span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">   <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">writeData</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">       <span class=\"keyword\">final</span> <span class=\"type\">Document</span> <span class=\"variable\">document</span> <span class=\"operator\">=</span> FileDocumentManager.getInstance().getDocument(file);</span><br><span class=\"line\">       <span class=\"keyword\">if</span> (document == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">           <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">               <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Exception</span>(<span class=\"string\">&quot;Document对象为空&quot;</span>);</span><br><span class=\"line\">           &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">               e.printStackTrace();</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">           <span class=\"keyword\">return</span>;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       <span class=\"keyword\">new</span> <span class=\"title class_\">WriteCommandAction</span>.Simple(project) &#123;</span><br><span class=\"line\">           <span class=\"meta\">@Override</span></span><br><span class=\"line\">           <span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">               document.setText(XMLString.getInstance().generateXmlString());</span><br><span class=\"line\">               <span class=\"comment\">//formatCode();</span></span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">       &#125;.execute();</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>利用<code>XMLString.getInstance().generateXmlString()</code>获取各操作类型的所有属性将其拼接为一份完整的shape.xml文件的字段，最后调用插件系统的相关命令将字符串粘贴在系统对应的输入框中。</p>\n<h2 id=\"2-将原有shape-xml字符串转化为对应操作界面\"><a href=\"#2-将原有shape-xml字符串转化为对应操作界面\" class=\"headerlink\" title=\"2. 将原有shape.xml字符串转化为对应操作界面\"></a>2. 将原有shape.xml字符串转化为对应操作界面</h2><p>上面已经讲述类如何拼接生成xml字符串并将其粘贴到Android Studio界面上，此外NoCodeShape不仅支持新生成的shape.xml，同样也支持对旧shape.xml进行修改的能力。与第一步相比较主要多了一步读取Android Studio xml文档并将其转化为对应操作界面的过程。其主要是在操作界面初始化之前执行了如下方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">initSax</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">       <span class=\"type\">String</span> <span class=\"variable\">text</span> <span class=\"operator\">=</span> FileDocumentManager.getInstance().getDocument(file).getText();</span><br><span class=\"line\">       <span class=\"type\">ShapeSaxHandler</span> <span class=\"variable\">handler</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ShapeSaxHandler</span>();</span><br><span class=\"line\">       <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">           handler.createViewList(text);</span><br><span class=\"line\">       &#125; <span class=\"keyword\">catch</span> (ParserConfigurationException e) &#123;</span><br><span class=\"line\">           e.printStackTrace();</span><br><span class=\"line\">       &#125; <span class=\"keyword\">catch</span> (SAXException e) &#123;</span><br><span class=\"line\">           e.printStackTrace();</span><br><span class=\"line\">       &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">           e.printStackTrace();</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n<p>利用ShapeSaxHandler去解析xml里面的元素，参考了<a href=\"https://github.com/laobie/FindViewByMe\">FindViewByMe</a>的解析原理。</p>\n<p>具体操作逻辑如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">createViewList</span><span class=\"params\">(String string)</span> <span class=\"keyword\">throws</span> ParserConfigurationException, SAXException, IOException &#123;</span><br><span class=\"line\">      <span class=\"type\">InputStream</span> <span class=\"variable\">xmlStream</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ByteArrayInputStream</span>(string.getBytes(<span class=\"string\">&quot;UTF-8&quot;</span>));</span><br><span class=\"line\">      <span class=\"type\">SAXParserFactory</span> <span class=\"variable\">factory</span> <span class=\"operator\">=</span> SAXParserFactory.newInstance();</span><br><span class=\"line\">      <span class=\"type\">SAXParser</span> <span class=\"variable\">parser</span> <span class=\"operator\">=</span> factory.newSAXParser();</span><br><span class=\"line\">      parser.parse(xmlStream, <span class=\"built_in\">this</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">startDocument</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> SAXException &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (shapePartList == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">          shapePartList = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;ShapePart&gt;();</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">startElement</span><span class=\"params\">(String uri, String localName, String qName, Attributes attributes)</span> <span class=\"keyword\">throws</span> SAXException &#123;</span><br><span class=\"line\">      <span class=\"keyword\">switch</span> (qName) &#123;</span><br><span class=\"line\">          <span class=\"keyword\">case</span> <span class=\"string\">&quot;shape&quot;</span>:</span><br><span class=\"line\">              Shape.getInstance().getBuilder().analysisAttribute(attributes);</span><br><span class=\"line\">              <span class=\"keyword\">break</span>;</span><br><span class=\"line\">          <span class=\"keyword\">case</span> <span class=\"string\">&quot;stroke&quot;</span>:</span><br><span class=\"line\">              Stroke.getInstance().getBuilder().analysisAttribute(attributes);</span><br><span class=\"line\">              <span class=\"keyword\">break</span>;</span><br><span class=\"line\">          <span class=\"keyword\">case</span> <span class=\"string\">&quot;solid&quot;</span>:</span><br><span class=\"line\">             Solid.getInstance().getBuilder().analysisAttribute(attributes);</span><br><span class=\"line\">              <span class=\"keyword\">break</span>;</span><br><span class=\"line\">          <span class=\"keyword\">case</span> <span class=\"string\">&quot;gradient&quot;</span>:</span><br><span class=\"line\">              Gradient.getInstance().getBuilder().analysisAttribute(attributes);</span><br><span class=\"line\">              <span class=\"keyword\">break</span>;</span><br><span class=\"line\">          <span class=\"keyword\">case</span> <span class=\"string\">&quot;corners&quot;</span>:</span><br><span class=\"line\">              Corners.getInstance().getBuilder().analysisAttribute(attributes);</span><br><span class=\"line\">              <span class=\"keyword\">break</span>;</span><br><span class=\"line\">          <span class=\"keyword\">default</span>:</span><br><span class=\"line\">              <span class=\"keyword\">break</span>;</span><br><span class=\"line\">      &#125;</span><br></pre></td></tr></table></figure>\n<p>逻辑其实很清楚，主要对startTag的判断，然后通过调用 <code>public abstract void analysisAttribute(Attributes attributes);</code>的方法对相应的 类型的Buidler进行一个赋值操作。</p>\n<p>以Stroke为例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">analysisAttribute</span><span class=\"params\">(Attributes attributes)</span> &#123;</span><br><span class=\"line\">            Stroke.getInstance().setChecked(<span class=\"literal\">true</span>);</span><br><span class=\"line\">            setColor(attributes.getValue(<span class=\"string\">&quot;android:color&quot;</span>));</span><br><span class=\"line\">            setDashGap(attributes.getValue(<span class=\"string\">&quot;android:dashGap&quot;</span>));</span><br><span class=\"line\">            setWidth(attributes.getValue(<span class=\"string\">&quot;android:width&quot;</span>));</span><br><span class=\"line\">            setDashWidth(attributes.getValue(<span class=\"string\">&quot;android:dashWidth&quot;</span>));</span><br><span class=\"line\">        &#125;</span><br></pre></td></tr></table></figure>\n<p>主要是获取到其中的属性，并对初始化的界面进行一些操作(例如选中或者赋值相关操作)。</p>\n<h1 id=\"四、总结\"><a href=\"#四、总结\" class=\"headerlink\" title=\"四、总结\"></a>四、总结</h1><p>这个插件算是自己第一次做一个相对较实用的插件，都是利用工作的空闲事件进行编写，前前后后进行了将近一个月，其中收获颇多，但也踩过了各种各样的坑。在开发过程中由于相关文档较少，通过阅读官方文档还是有点小吃力，不过一步步还是走了下来，自己也得到了成长。其中坑也都添平了，但由于一些基础技术的欠缺，比如对Java GUI界面编程不太熟悉，导致开发过程中有很大一段时间都在跟界面作对，因此后面有机会将去深入了解Java的界面编程，争取能够将页面交互能够做到更好。</p>\n<p>另外由于自身开发精力的原因，不能将插件做到完美，目前插件中还有如下几个问题：</p>\n<p>1、Gradient中对应相关逻辑还需要再优化<br>2、还未支持Size跟Pading（从自身所处环境考虑用得较少，所以暂未支持）<br>3、对于颜色选择器默认打开后不支持对本地颜色字符串处理<br>4、存在大量的界面操作逻辑代码，需要优化</p>\n<p>最后，希望大家能在使用过程中提出相关的意见或建议，也欢迎能一起加入到开发中，从而能将该插件做得更加完美。</p>\n<p>项目地址：</p>\n<p><a href=\"https://github.com/VomPom/NoCodeShape\">https://github.com/VomPom/NoCodeShape</a></p>\n","categories":[{"name":"技术文章","slug":"technology","api":"api/categories/technology.json"}],"tags":[{"name":"插件","slug":"插件","api":"api/tags/插件.json"}],"api":"api/posts/2019/11/27/一款快速生成Android-shape的插件-NoCodeShape.json"},{"title":"Java中的Reference解析","slug":"Java四种引用","date":"2019-10-30T11:45:00.000Z","updated":"2025-05-20T11:46:57.000Z","comments":true,"url":"2019/10/30/Java四种引用/","excerpt":"<p>Java执行GC判断对象是否存活有两种方式其中一种是<strong>引用计数</strong>。</p>\n<p><strong>引用计数</strong>：Java堆中每一个对象都有一个引用计数属性，引用每新增1次计数加1，引用每释放1次计数减1。</p>\n<p>在JDK 1.2以前的版本中，若一个对象不被任何变量引用，那么程序就无法再使用这个对象。也就是说，只有对象处于(reachable)可达状态，程序才能使用它。</p>\n<p>从JDK 1.2版本开始，对象的引用被划分为4种级别，从而使程序能更加灵活地控制对象的生命周期。这4种级别由高到低依次为：<code>强引用、软引用、弱引用和虚引用</code>，本文主要讲解各个引用的用途以及引用队列的作用。</p>\n<h2 id=\"1、强引用（StrongReference）\"><a href=\"#1、强引用（StrongReference）\" class=\"headerlink\" title=\"1、强引用（StrongReference）\"></a>1、强引用（StrongReference）</h2><p>强引用指的是程序代码中普遍存在的，类似如下代码</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">Object</span> <span class=\"variable\">object</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Object</span>();</span><br></pre></td></tr></table></figure>\n<p><em><strong>当内存空间不足时，只要强引用还在，Java虚拟机会抛出OutOfMemoryError错误，使程序异常终止，也不会靠回收强引用的对象来解决内存不足的问题。</strong></em></p>\n<p>如果强引用对象不使用时，需要弱化从而使GC能够回收，如下所示：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">object = <span class=\"literal\">null</span>;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2、软引用（SoftReference）\"><a href=\"#2、软引用（SoftReference）\" class=\"headerlink\" title=\"2、软引用（SoftReference）\"></a>2、软引用（SoftReference）</h2><p><em><strong>软引用是用来描述一些有用但并不是必需的对象。对于软引用关联着的对象，在系统将要发生内存溢出异常之前，将会把这些对象列进回首范围之中进行第二次回收。如果这次回收还没有足够的内存，才会抛出内存溢出异常。</strong></em></p>\n<p>这一点可以很好地用来解决OOM的问题，并且这个特性很适合用来实现缓存：比如网页缓存、图片缓存等，软引用可用来实现内存敏感的高速缓存。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 强引用</span></span><br><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">strongReference</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">String</span>(<span class=\"string\">&quot;abc&quot;</span>);</span><br><span class=\"line\"><span class=\"comment\">// 软引用</span></span><br><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">str</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">String</span>(<span class=\"string\">&quot;abc&quot;</span>);</span><br><span class=\"line\">SoftReference&lt;String&gt; softReference = <span class=\"keyword\">new</span> <span class=\"title class_\">SoftReference</span>&lt;String&gt;(str);</span><br></pre></td></tr></table></figure>\n\n<p>软引用可以和一个引用队列(ReferenceQueue)联合使用。如果软引用所引用对象被垃圾回收，JAVA虚拟机就会把这个软引用加入到与之关联的引用队列中。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">ReferenceQueue&lt;String&gt; referenceQueue = <span class=\"keyword\">new</span> <span class=\"title class_\">ReferenceQueue</span>&lt;&gt;();</span><br><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">str</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">String</span>(<span class=\"string\">&quot;abc&quot;</span>);</span><br><span class=\"line\">SoftReference&lt;String&gt; softReference = <span class=\"keyword\">new</span> <span class=\"title class_\">SoftReference</span>&lt;&gt;(str, referenceQueue);</span><br><span class=\"line\">str = <span class=\"literal\">null</span>;</span><br><span class=\"line\"><span class=\"comment\">// Notify GC</span></span><br><span class=\"line\">System.gc();</span><br><span class=\"line\">System.out.println(softReference.get()); <span class=\"comment\">// abc</span></span><br><span class=\"line\">Reference&lt;? <span class=\"keyword\">extends</span> <span class=\"title class_\">String</span>&gt; reference = referenceQueue.poll();</span><br><span class=\"line\">System.out.println(reference); <span class=\"comment\">//null</span></span><br></pre></td></tr></table></figure>\n\n<p>注意：软引用对象是在jvm内存不够的时候才会被回收，我们调用System.gc()方法只是起通知作用，JVM什么时候扫描回收对象是JVM自己的状态决定的。就算扫描到软引用对象也不一定会回收它，只有内存不够的时候才会回收。</p>\n<p>当内存不足时，JVM首先将软引用中的对象引用置为<code>null</code>，然后通知垃圾回收器进行回收：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span>(JVM内存不足) &#123;</span><br><span class=\"line\">     <span class=\"comment\">// 将软引用中的对象引用置为null</span></span><br><span class=\"line\">     str = <span class=\"literal\">null</span>;</span><br><span class=\"line\">     <span class=\"comment\">// 通知垃圾回收器进行回收</span></span><br><span class=\"line\">     System.gc();</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n<p>也就是说，垃圾收集线程会在虚拟机抛出<code>OutOfMemoryError</code>之前回收软引用对象，而且虚拟机会尽可能优先回收长时间闲置不用的软引用对象。对那些刚构建的或刚使用过的较新的软对象会被虚拟机尽可能保留，这就是引入引用队列ReferenceQueue的原因，后面会具体讲解。</p>\n<h2 id=\"3、弱引用（WeakReference）\"><a href=\"#3、弱引用（WeakReference）\" class=\"headerlink\" title=\"3、弱引用（WeakReference）\"></a>3、弱引用（WeakReference）</h2><p><em><strong>弱引用也是用来描述非必需对象的，但是它的强度比软引用更弱一些，被弱引用关联的<br>对象只能生存到下一次垃圾收集发生之前。当垃圾收集器工作时，无论当前内存是否足够，<br>都会回收掉只被弱引用关联的对象。</strong></em></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">str</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">String</span>(<span class=\"string\">&quot;abc&quot;</span>);</span><br><span class=\"line\">WeakReference&lt;String&gt; weakReference = <span class=\"keyword\">new</span> <span class=\"title class_\">WeakReference</span>&lt;&gt;(str);</span><br><span class=\"line\">str = <span class=\"literal\">null</span>;</span><br></pre></td></tr></table></figure>\n<p>复制代码JVM首先将软引用中的对象引用置为null，然后通知垃圾回收器进行回收：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">str = <span class=\"literal\">null</span>;</span><br><span class=\"line\">System.gc();</span><br></pre></td></tr></table></figure>\n\n<p>注意：如果一个对象是偶尔(很少)的使用，并且希望在使用时随时就能获取到，但又不想影响此对象的垃圾收集，那么你应该用Weak Reference来记住此对象。</p>\n<p>下面的代码会让一个弱引用再次变为一个强引用：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">str</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">String</span>(<span class=\"string\">&quot;abc&quot;</span>);</span><br><span class=\"line\">WeakReference&lt;String&gt; weakReference = <span class=\"keyword\">new</span> <span class=\"title class_\">WeakReference</span>&lt;&gt;(str);</span><br><span class=\"line\"><span class=\"comment\">// 弱引用转强引用</span></span><br><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">strongReference</span> <span class=\"operator\">=</span> weakReference.get();</span><br></pre></td></tr></table></figure>\n\n<p>同样，弱引用可以和一个引用队列(ReferenceQueue)联合使用，如果弱引用所引用的对象被垃圾回收，Java虚拟机就会把这个弱引用加入到与之关联的引用队列中。</p>\n<h2 id=\"4、虚引用（PhantomReference）\"><a href=\"#4、虚引用（PhantomReference）\" class=\"headerlink\" title=\"4、虚引用（PhantomReference）\"></a>4、虚引用（PhantomReference）</h2><p><em><strong>虚引用也称为幽灵引用或者幻影引用，它是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生命周期构成影响，也无法通过虚引用获得一个对象实例。</strong></em></p>\n<p>虚引用主要用来<strong>跟踪对象被垃圾回收器回收的活动</strong>，虚引用与软引用和弱引用的一个区别在于：</p>\n<blockquote>\n<p>虚引用必须和引用队列(ReferenceQueue)联合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">str</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">String</span>(<span class=\"string\">&quot;abc&quot;</span>);</span><br><span class=\"line\"><span class=\"type\">ReferenceQueue</span> <span class=\"variable\">queue</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ReferenceQueue</span>();</span><br><span class=\"line\"><span class=\"comment\">// 创建虚引用，要求必须与一个引用队列关联</span></span><br><span class=\"line\"><span class=\"type\">PhantomReference</span> <span class=\"variable\">pr</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">PhantomReference</span>(str, queue);</span><br></pre></td></tr></table></figure>\n<p>程序可以通过判断引用队列中是否已经加入了虚引用，来了解被引用的对象是否将要进行垃圾回收。如果程序发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动。</p>\n<h2 id=\"5、引用队列（ReferenceQueue）\"><a href=\"#5、引用队列（ReferenceQueue）\" class=\"headerlink\" title=\"5、引用队列（ReferenceQueue）\"></a>5、引用队列（ReferenceQueue）</h2><p>在前面软引用、弱引用和虚引用都有讲到引用队列，那引用队列具体是做什么的呢？<br>官方对于引用队列类的注释是：</p>\n<blockquote>\n<p> Reference queues, to which registered reference objects are appended by the garbage collector after the appropriate reachability changes are detected.<br> 译为：引用队列是将垃圾收集器在监测到适当的可达性更改后将已注册的引用对象添加到该队列。</p>\n</blockquote>\n<p>对于软引用和弱引用和虚引用，我们希望当一个对象被gc掉的时候通知用户线程，进行额外的处理时，就需要使用引用队列了。<code>ReferenceQueue</code>即这样的一个对象，当一个obj被gc掉之后，其相应的包装类，即ref对象会被放入queue中。我们可以从queue中获取到相应的对象信息，同时进行额外的处理。比如反向操作，数据清理等。</p>\n<p>查看源码发现ReferenceQueue的代码结构并不复杂，从源码上看，实际上ReferenceQueue只是名义上的引用队列，它只保存了Reference链表的头(head)节点，并且提供了队列出队入队删除操作，而Reference实际上本身提供单向链表的功能，也就是说Reference通过成员属性next构建单向链表，而链表的操作是委托给ReferenceQueue完成。详细参考：<a href=\"https://www.throwable.club/2019/02/16/java-reference/#ReferenceQueue\">深入理解JDK中的Reference原理和源码实现</a></p>\n<img src=\"https://cdn.julis.wang/blog/img/20191030191550407.png\">\n<h2 id=\"6、总结\"><a href=\"#6、总结\" class=\"headerlink\" title=\"6、总结\"></a>6、总结</h2><p>1、Java中四种引用的级别和强度由高到低依次为：<code>强引用 -&gt; 软引用 -&gt; 弱引用 -&gt; 虚引用</code></p>\n<p>2、ReferenceQueue引用队列用来记录被回收的引用为用户线程做额外操作作铺垫</p>\n<p>3、对各种引用回收时间、用途、生成时间作总结：</p>\n<img src=\"https://cdn.julis.wang/blog/img/78afb9b4d86f5feef01ac947f96baee331c.jpg\">\n<p>参考：</p>\n<p>1、《深入理解Java虚拟机》</p>\n<p>2、<a href=\"https://www.throwable.club/2019/02/16/java-reference/#ReferenceQueue\">深入理解JDK中的Reference原理和源码实现</a></p>\n<p>3、<a href=\"https://juejin.im/post/5b82c02df265da436152f5ad\">理解Java的强引用、软引用、弱引用和虚引用</a></p>\n","cover":null,"images":["https://cdn.julis.wang/blog/img/20191030191550407.png","https://cdn.julis.wang/blog/img/78afb9b4d86f5feef01ac947f96baee331c.jpg"],"content":"<p>Java执行GC判断对象是否存活有两种方式其中一种是<strong>引用计数</strong>。</p>\n<p><strong>引用计数</strong>：Java堆中每一个对象都有一个引用计数属性，引用每新增1次计数加1，引用每释放1次计数减1。</p>\n<p>在JDK 1.2以前的版本中，若一个对象不被任何变量引用，那么程序就无法再使用这个对象。也就是说，只有对象处于(reachable)可达状态，程序才能使用它。</p>\n<p>从JDK 1.2版本开始，对象的引用被划分为4种级别，从而使程序能更加灵活地控制对象的生命周期。这4种级别由高到低依次为：<code>强引用、软引用、弱引用和虚引用</code>，本文主要讲解各个引用的用途以及引用队列的作用。</p>\n<h2 id=\"1、强引用（StrongReference）\"><a href=\"#1、强引用（StrongReference）\" class=\"headerlink\" title=\"1、强引用（StrongReference）\"></a>1、强引用（StrongReference）</h2><p>强引用指的是程序代码中普遍存在的，类似如下代码</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">Object</span> <span class=\"variable\">object</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Object</span>();</span><br></pre></td></tr></table></figure>\n<p><em><strong>当内存空间不足时，只要强引用还在，Java虚拟机会抛出OutOfMemoryError错误，使程序异常终止，也不会靠回收强引用的对象来解决内存不足的问题。</strong></em></p>\n<p>如果强引用对象不使用时，需要弱化从而使GC能够回收，如下所示：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">object = <span class=\"literal\">null</span>;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2、软引用（SoftReference）\"><a href=\"#2、软引用（SoftReference）\" class=\"headerlink\" title=\"2、软引用（SoftReference）\"></a>2、软引用（SoftReference）</h2><p><em><strong>软引用是用来描述一些有用但并不是必需的对象。对于软引用关联着的对象，在系统将要发生内存溢出异常之前，将会把这些对象列进回首范围之中进行第二次回收。如果这次回收还没有足够的内存，才会抛出内存溢出异常。</strong></em></p>\n<p>这一点可以很好地用来解决OOM的问题，并且这个特性很适合用来实现缓存：比如网页缓存、图片缓存等，软引用可用来实现内存敏感的高速缓存。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 强引用</span></span><br><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">strongReference</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">String</span>(<span class=\"string\">&quot;abc&quot;</span>);</span><br><span class=\"line\"><span class=\"comment\">// 软引用</span></span><br><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">str</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">String</span>(<span class=\"string\">&quot;abc&quot;</span>);</span><br><span class=\"line\">SoftReference&lt;String&gt; softReference = <span class=\"keyword\">new</span> <span class=\"title class_\">SoftReference</span>&lt;String&gt;(str);</span><br></pre></td></tr></table></figure>\n\n<p>软引用可以和一个引用队列(ReferenceQueue)联合使用。如果软引用所引用对象被垃圾回收，JAVA虚拟机就会把这个软引用加入到与之关联的引用队列中。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">ReferenceQueue&lt;String&gt; referenceQueue = <span class=\"keyword\">new</span> <span class=\"title class_\">ReferenceQueue</span>&lt;&gt;();</span><br><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">str</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">String</span>(<span class=\"string\">&quot;abc&quot;</span>);</span><br><span class=\"line\">SoftReference&lt;String&gt; softReference = <span class=\"keyword\">new</span> <span class=\"title class_\">SoftReference</span>&lt;&gt;(str, referenceQueue);</span><br><span class=\"line\">str = <span class=\"literal\">null</span>;</span><br><span class=\"line\"><span class=\"comment\">// Notify GC</span></span><br><span class=\"line\">System.gc();</span><br><span class=\"line\">System.out.println(softReference.get()); <span class=\"comment\">// abc</span></span><br><span class=\"line\">Reference&lt;? <span class=\"keyword\">extends</span> <span class=\"title class_\">String</span>&gt; reference = referenceQueue.poll();</span><br><span class=\"line\">System.out.println(reference); <span class=\"comment\">//null</span></span><br></pre></td></tr></table></figure>\n\n<p>注意：软引用对象是在jvm内存不够的时候才会被回收，我们调用System.gc()方法只是起通知作用，JVM什么时候扫描回收对象是JVM自己的状态决定的。就算扫描到软引用对象也不一定会回收它，只有内存不够的时候才会回收。</p>\n<p>当内存不足时，JVM首先将软引用中的对象引用置为<code>null</code>，然后通知垃圾回收器进行回收：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span>(JVM内存不足) &#123;</span><br><span class=\"line\">     <span class=\"comment\">// 将软引用中的对象引用置为null</span></span><br><span class=\"line\">     str = <span class=\"literal\">null</span>;</span><br><span class=\"line\">     <span class=\"comment\">// 通知垃圾回收器进行回收</span></span><br><span class=\"line\">     System.gc();</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n<p>也就是说，垃圾收集线程会在虚拟机抛出<code>OutOfMemoryError</code>之前回收软引用对象，而且虚拟机会尽可能优先回收长时间闲置不用的软引用对象。对那些刚构建的或刚使用过的较新的软对象会被虚拟机尽可能保留，这就是引入引用队列ReferenceQueue的原因，后面会具体讲解。</p>\n<h2 id=\"3、弱引用（WeakReference）\"><a href=\"#3、弱引用（WeakReference）\" class=\"headerlink\" title=\"3、弱引用（WeakReference）\"></a>3、弱引用（WeakReference）</h2><p><em><strong>弱引用也是用来描述非必需对象的，但是它的强度比软引用更弱一些，被弱引用关联的<br>对象只能生存到下一次垃圾收集发生之前。当垃圾收集器工作时，无论当前内存是否足够，<br>都会回收掉只被弱引用关联的对象。</strong></em></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">str</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">String</span>(<span class=\"string\">&quot;abc&quot;</span>);</span><br><span class=\"line\">WeakReference&lt;String&gt; weakReference = <span class=\"keyword\">new</span> <span class=\"title class_\">WeakReference</span>&lt;&gt;(str);</span><br><span class=\"line\">str = <span class=\"literal\">null</span>;</span><br></pre></td></tr></table></figure>\n<p>复制代码JVM首先将软引用中的对象引用置为null，然后通知垃圾回收器进行回收：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">str = <span class=\"literal\">null</span>;</span><br><span class=\"line\">System.gc();</span><br></pre></td></tr></table></figure>\n\n<p>注意：如果一个对象是偶尔(很少)的使用，并且希望在使用时随时就能获取到，但又不想影响此对象的垃圾收集，那么你应该用Weak Reference来记住此对象。</p>\n<p>下面的代码会让一个弱引用再次变为一个强引用：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">str</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">String</span>(<span class=\"string\">&quot;abc&quot;</span>);</span><br><span class=\"line\">WeakReference&lt;String&gt; weakReference = <span class=\"keyword\">new</span> <span class=\"title class_\">WeakReference</span>&lt;&gt;(str);</span><br><span class=\"line\"><span class=\"comment\">// 弱引用转强引用</span></span><br><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">strongReference</span> <span class=\"operator\">=</span> weakReference.get();</span><br></pre></td></tr></table></figure>\n\n<p>同样，弱引用可以和一个引用队列(ReferenceQueue)联合使用，如果弱引用所引用的对象被垃圾回收，Java虚拟机就会把这个弱引用加入到与之关联的引用队列中。</p>\n<h2 id=\"4、虚引用（PhantomReference）\"><a href=\"#4、虚引用（PhantomReference）\" class=\"headerlink\" title=\"4、虚引用（PhantomReference）\"></a>4、虚引用（PhantomReference）</h2><p><em><strong>虚引用也称为幽灵引用或者幻影引用，它是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生命周期构成影响，也无法通过虚引用获得一个对象实例。</strong></em></p>\n<p>虚引用主要用来<strong>跟踪对象被垃圾回收器回收的活动</strong>，虚引用与软引用和弱引用的一个区别在于：</p>\n<blockquote>\n<p>虚引用必须和引用队列(ReferenceQueue)联合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">str</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">String</span>(<span class=\"string\">&quot;abc&quot;</span>);</span><br><span class=\"line\"><span class=\"type\">ReferenceQueue</span> <span class=\"variable\">queue</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ReferenceQueue</span>();</span><br><span class=\"line\"><span class=\"comment\">// 创建虚引用，要求必须与一个引用队列关联</span></span><br><span class=\"line\"><span class=\"type\">PhantomReference</span> <span class=\"variable\">pr</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">PhantomReference</span>(str, queue);</span><br></pre></td></tr></table></figure>\n<p>程序可以通过判断引用队列中是否已经加入了虚引用，来了解被引用的对象是否将要进行垃圾回收。如果程序发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动。</p>\n<h2 id=\"5、引用队列（ReferenceQueue）\"><a href=\"#5、引用队列（ReferenceQueue）\" class=\"headerlink\" title=\"5、引用队列（ReferenceQueue）\"></a>5、引用队列（ReferenceQueue）</h2><p>在前面软引用、弱引用和虚引用都有讲到引用队列，那引用队列具体是做什么的呢？<br>官方对于引用队列类的注释是：</p>\n<blockquote>\n<p> Reference queues, to which registered reference objects are appended by the garbage collector after the appropriate reachability changes are detected.<br> 译为：引用队列是将垃圾收集器在监测到适当的可达性更改后将已注册的引用对象添加到该队列。</p>\n</blockquote>\n<p>对于软引用和弱引用和虚引用，我们希望当一个对象被gc掉的时候通知用户线程，进行额外的处理时，就需要使用引用队列了。<code>ReferenceQueue</code>即这样的一个对象，当一个obj被gc掉之后，其相应的包装类，即ref对象会被放入queue中。我们可以从queue中获取到相应的对象信息，同时进行额外的处理。比如反向操作，数据清理等。</p>\n<p>查看源码发现ReferenceQueue的代码结构并不复杂，从源码上看，实际上ReferenceQueue只是名义上的引用队列，它只保存了Reference链表的头(head)节点，并且提供了队列出队入队删除操作，而Reference实际上本身提供单向链表的功能，也就是说Reference通过成员属性next构建单向链表，而链表的操作是委托给ReferenceQueue完成。详细参考：<a href=\"https://www.throwable.club/2019/02/16/java-reference/#ReferenceQueue\">深入理解JDK中的Reference原理和源码实现</a></p>\n<img src=\"https://cdn.julis.wang/blog/img/20191030191550407.png\">\n<h2 id=\"6、总结\"><a href=\"#6、总结\" class=\"headerlink\" title=\"6、总结\"></a>6、总结</h2><p>1、Java中四种引用的级别和强度由高到低依次为：<code>强引用 -&gt; 软引用 -&gt; 弱引用 -&gt; 虚引用</code></p>\n<p>2、ReferenceQueue引用队列用来记录被回收的引用为用户线程做额外操作作铺垫</p>\n<p>3、对各种引用回收时间、用途、生成时间作总结：</p>\n<img src=\"https://cdn.julis.wang/blog/img/78afb9b4d86f5feef01ac947f96baee331c.jpg\">\n<p>参考：</p>\n<p>1、《深入理解Java虚拟机》</p>\n<p>2、<a href=\"https://www.throwable.club/2019/02/16/java-reference/#ReferenceQueue\">深入理解JDK中的Reference原理和源码实现</a></p>\n<p>3、<a href=\"https://juejin.im/post/5b82c02df265da436152f5ad\">理解Java的强引用、软引用、弱引用和虚引用</a></p>\n","categories":[{"name":"技术文章","slug":"technology","api":"api/categories/technology.json"}],"tags":[{"name":"Java","slug":"java","api":"api/tags/java.json"}],"api":"api/posts/2019/10/30/Java四种引用.json"},{"title":"Java中Lambda表达式解析","slug":"Java中Lambda表达式解析","date":"2019-10-09T10:55:00.000Z","updated":"2025-05-20T11:46:57.000Z","comments":true,"url":"2019/10/09/Java中Lambda表达式解析/","excerpt":"<p>在大部分开发者看来，Lambda 表达式只是一种语法糖，简化了书写匿名内部类的写法。实际上Lambda表达式并不仅仅是匿名内部类的语法糖，JVM内部是通过invokedynamic指令来实现Lambda表达式的，与内部类的实现有很大的差异。本文主要记录lambda的实现原理。</p>\n<h2 id=\"一、函数式接口\"><a href=\"#一、函数式接口\" class=\"headerlink\" title=\"一、函数式接口\"></a><strong>一、函数式接口</strong></h2><p>众所周知Javascript具有一个强大的特性：<strong>闭包</strong>。Java中最接近闭包概念的东西就是lambda表达式了，而Lambda为Java添加了缺失函数式编程的特点。所以什么是函数是接口呢？</p>\n<p>函数式接口需满足以下两个条件：</p>\n<ol>\n<li>它是接口</li>\n<li>这个接口<strong>有且仅有一个抽象方法</strong></li>\n</ol>\n<p>例如我们常用的：Runnable、View.OnClickListener、Comparable等都是函数式接口，因为它们都只有一个方法，而且都是抽象的。虽然只有一个抽象方法，是不是就意味着只能有一个方法呢？实际并不是，虽然有且仅有一个抽象方法，但是可以有多个非抽象方法的接口。</p>\n<p>嗯？！Java接口中难道还可以定义非抽象方法么？平时我们的接口大概长这样：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">IdiomSubmitListener</span> &#123;</span><br><span class=\"line\">   \t<span class=\"keyword\">void</span> <span class=\"title function_\">verifyResult</span><span class=\"params\">(String result)</span>;</span><br><span class=\"line\">   \t<span class=\"keyword\">void</span> <span class=\"title function_\">onSuceess</span><span class=\"params\">()</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>那接口的非抽象方法是啥？原来在JDK 1.8 对于接口而言具有以下新特性：<br><strong>接口可以定义非抽象方法，但必须使用default或者staic关键字来修饰</strong><br>具体细节点可以参考 <a href=\"https://blog.csdn.net/austral/article/details/53402476\">JAVA 8新特性 允许接口定义非抽象方法 快速入门案例</a></p>\n<p>如果一个接口符合函数式接口的定义，那么我们就可以在该接口上面声明FunctionalInterface注解，用来表示该接口是一个函数式接口，并按照函数式接口的规范在编译的时候对该接口进行检查。</p>\n<p>当然如果某个接口只有一个抽象方法，但我们并没有给该接口声明FunctionalInterface注解，那么编译器依旧会将该接口看做是函数式接口。</p>\n<p>那Lambda表达式跟函数式接口又有什么关联呢？<br>在JDK 1.8中，Lambda表达式是对象，而不是函数，它们必须依附于一类特别的对象类型–函数式接口。</p>\n<p>因此可以说 在JDK 1.8中，Lambda表达式就是一个函数式接口的实例。<br><strong>所以如果一个实例是函数式接口的实例，那么该对象就可以用Lambda表达式来表示</strong></p>\n<h2 id=\"二、Lambda表达式与匿名内部类\"><a href=\"#二、Lambda表达式与匿名内部类\" class=\"headerlink\" title=\"二、Lambda表达式与匿名内部类\"></a><strong>二、Lambda表达式与匿名内部类</strong></h2><p>我们知道代码IDE如果是在JDK1.8的环境下，使用匿名内部类作为一个参数传入到方法中，编译器会提示我们：<code>Anonymous new Runnable() can be replaced with lambda</code>，匿名内部类XXX可以替换为lambda表达式。</p>\n<p>如下所示，匿名内部类 Runnable是一个函数式接口的实例，所以我们可以用lambda表达式来将之替换，从而将代码变得更加简洁。<br><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly9vc2NpbWcub3NjaGluYS5uZXQvb3NjbmV0Lzc4YzgxZWMyZjkzMmE5MDhmOTcxM2NiZGM5ODRkOGFhMWI2LmpwZw?x-oss-process=image/format,png\"></p>\n<img src=\"https://cdn.julis.wang/blog/img/20191009170329915.png\">\n<p>那么我们是否就认为：Lambda表达式只是为匿名内部类中提供的一种语法糖，他们有什么区别呢？底层原理是完全一样的呢？</p>\n<p>他们主要区别如下：</p>\n<p>1、关键字this。匿名内部类的this指向匿名类，而Lambda表达式的this指向被Lambda包围的外部类</p>\n<p>2、编译方式。Java编译器将Lambda表达式编译成类的私有方法，使用Java7的invokedynamic字节码动态绑定这个方法。而匿名内部类将编译成<strong>外部类$数字编号</strong>的新类。这也造成第1点关键字this指向不同地方的原因。</p>\n<h2 id=\"三、Lambda实现原理\"><a href=\"#三、Lambda实现原理\" class=\"headerlink\" title=\"三、Lambda实现原理\"></a><strong>三、Lambda实现原理</strong></h2><p>我们知道如果使用匿名内部类，编译期间会生成一个外部类$数字编号的类，如图所示：</p>\n<img src=\"https://cdn.julis.wang/blog/img/20191009172403269.png\">\n\n<p>而如果使用Lambda表达式进行编译后并没有生成新类。</p>\n<img src=\"https://cdn.julis.wang/blog/img/20191009172455212.png\">\n<p>我们对Lambda表达式生成的class文件使用：javap -p -v Test.class 进行反编译生成如下内容，为便于观察，删除了一些无用内容</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">wang</span>.julis.jwbase.basecompact.Test</span><br><span class=\"line\"></span><br><span class=\"line\">Constant pool:</span><br><span class=\"line\">   #<span class=\"number\">1</span> = Methodref          #<span class=\"number\">9.</span>#<span class=\"number\">18</span>         <span class=\"comment\">// java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> wang.julis.jwbase.basecompact.Test();</span><br><span class=\"line\">    descriptor: ()V</span><br><span class=\"line\">    flags: (<span class=\"number\">0x0001</span>) ACC_PUBLIC</span><br><span class=\"line\">    Code:</span><br><span class=\"line\">      stack=<span class=\"number\">1</span>, locals=<span class=\"number\">1</span>, args_size=<span class=\"number\">1</span></span><br><span class=\"line\">         <span class=\"number\">0</span>: aload_0</span><br><span class=\"line\">         <span class=\"number\">1</span>: invokespecial #<span class=\"number\">1</span>                  <span class=\"comment\">// Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class=\"line\">         <span class=\"number\">4</span>: <span class=\"keyword\">return</span></span><br><span class=\"line\">      LineNumberTable:</span><br><span class=\"line\">        line <span class=\"number\">12</span>: <span class=\"number\">0</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">testLambda</span><span class=\"params\">()</span>;</span><br><span class=\"line\">    descriptor: ()V</span><br><span class=\"line\">    flags: (<span class=\"number\">0x0002</span>) ACC_PRIVATE</span><br><span class=\"line\">    Code:</span><br><span class=\"line\">      stack=<span class=\"number\">3</span>, locals=<span class=\"number\">1</span>, args_size=<span class=\"number\">1</span></span><br><span class=\"line\">         <span class=\"number\">0</span>: <span class=\"keyword\">new</span>           #<span class=\"number\">2</span>                  <span class=\"comment\">// class java/lang/Thread</span></span><br><span class=\"line\">         <span class=\"number\">3</span>: dup</span><br><span class=\"line\">         <span class=\"number\">4</span>: invokedynamic #<span class=\"number\">3</span>,  <span class=\"number\">0</span>              <span class=\"comment\">// InvokeDynamic #0:run:()Ljava/lang/Runnable;</span></span><br><span class=\"line\">         <span class=\"number\">9</span>: invokespecial #<span class=\"number\">4</span>                  <span class=\"comment\">// Method java/lang/Thread.&quot;&lt;init&gt;&quot;:(Ljava/lang/Runnable;)V</span></span><br><span class=\"line\">        <span class=\"number\">12</span>: pop</span><br><span class=\"line\">        <span class=\"number\">13</span>: <span class=\"keyword\">return</span></span><br><span class=\"line\">      LineNumberTable:</span><br><span class=\"line\">        line <span class=\"number\">14</span>: <span class=\"number\">0</span></span><br><span class=\"line\">        line <span class=\"number\">18</span>: <span class=\"number\">13</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> lambda$testLambda$<span class=\"number\">0</span>();</span><br><span class=\"line\">    descriptor: ()V</span><br><span class=\"line\">    flags: (<span class=\"number\">0x100a</span>) ACC_PRIVATE, ACC_STATIC, ACC_SYNTHETIC</span><br><span class=\"line\">    Code:</span><br><span class=\"line\">      stack=<span class=\"number\">2</span>, locals=<span class=\"number\">0</span>, args_size=<span class=\"number\">0</span></span><br><span class=\"line\">         <span class=\"number\">0</span>: getstatic     #<span class=\"number\">5</span>                  <span class=\"comment\">// Field java/lang/System.out:Ljava/io/PrintStream;</span></span><br><span class=\"line\">         <span class=\"number\">3</span>: ldc           #<span class=\"number\">6</span>                  <span class=\"comment\">// String lambda</span></span><br><span class=\"line\">         <span class=\"number\">5</span>: invokevirtual #<span class=\"number\">7</span>                  <span class=\"comment\">// Method java/io/PrintStream.println:(Ljava/lang/String;)V</span></span><br><span class=\"line\">         <span class=\"number\">8</span>: <span class=\"keyword\">return</span></span><br><span class=\"line\">      LineNumberTable:</span><br><span class=\"line\">        line <span class=\"number\">15</span>: <span class=\"number\">0</span></span><br><span class=\"line\">        line <span class=\"number\">16</span>: <span class=\"number\">8</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">SourceFile: <span class=\"string\">&quot;Test.java&quot;</span></span><br><span class=\"line\">InnerClasses:</span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> #<span class=\"number\">50</span>= #<span class=\"number\">49</span> of #<span class=\"number\">53</span>;    <span class=\"comment\">// Lookup=class java/lang/invoke/MethodHandles$Lookup of class java/lang/invoke/MethodHandles</span></span><br><span class=\"line\">BootstrapMethods:</span><br><span class=\"line\">  <span class=\"number\">0</span>: #<span class=\"number\">21</span> REF_invokeStatic java/lang/invoke/LambdaMetafactory.metafactory:(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite;</span><br><span class=\"line\">    Method arguments:</span><br><span class=\"line\">      #<span class=\"number\">22</span> ()V</span><br><span class=\"line\">      #<span class=\"number\">23</span> REF_invokeStatic wang/julis/jwbase/basecompact/Test.lambda$testLambda$<span class=\"number\">0</span>:()V</span><br><span class=\"line\">      #<span class=\"number\">22</span> ()V</span><br></pre></td></tr></table></figure>\n<p>从反编译的结果我们可以看到：</p>\n<p>1、编译期间自动生成私有静态类<code>lambda$testLambda$0</code>而这里面就就是lambda的具体实现逻辑</p>\n<p>2、使用invokedynamic去执行lambda表达式 关于invokedynamic命令具体细节可以参考： <a href=\"https://time.geekbang.org/column/article/12564\">08 | JVM是怎么实现invokedynamic的？（上）</a></p>\n<p>3、lambda表达式编译后并没有生成外部类$数字编号的类</p>\n<h2 id=\"总结：\"><a href=\"#总结：\" class=\"headerlink\" title=\"总结：\"></a>总结：</h2><p>1、函数式接口：有且仅有一个抽象方法，可以用非抽象方法1.8后支持</p>\n<p>2、匿名内部类的this指向匿名类，而Lambda表达式的this指向被Lambda包围的外部类</p>\n<p>3、lambda表达式编译后不会生成外部类$数字编号的类</p>\n<p>4、Java编译器将Lambda表达式编译成类的私有方法，使用Java7的invokedynamic字节码动态绑定这个方法。</p>\n<p>参考：<br>1、《深入探索Android热修复技术原理》2.3.8章节<br>2、<a href=\"https://blog.csdn.net/zw19910924/article/details/75907348\">Java8 lambda表达式、函数式接口、方法引用</a></p>\n","cover":null,"images":["https://imgconvert.csdnimg.cn/aHR0cHM6Ly9vc2NpbWcub3NjaGluYS5uZXQvb3NjbmV0Lzc4YzgxZWMyZjkzMmE5MDhmOTcxM2NiZGM5ODRkOGFhMWI2LmpwZw?x-oss-process=image/format,png","https://cdn.julis.wang/blog/img/20191009170329915.png","https://cdn.julis.wang/blog/img/20191009172403269.png","https://cdn.julis.wang/blog/img/20191009172455212.png"],"content":"<p>在大部分开发者看来，Lambda 表达式只是一种语法糖，简化了书写匿名内部类的写法。实际上Lambda表达式并不仅仅是匿名内部类的语法糖，JVM内部是通过invokedynamic指令来实现Lambda表达式的，与内部类的实现有很大的差异。本文主要记录lambda的实现原理。</p>\n<h2 id=\"一、函数式接口\"><a href=\"#一、函数式接口\" class=\"headerlink\" title=\"一、函数式接口\"></a><strong>一、函数式接口</strong></h2><p>众所周知Javascript具有一个强大的特性：<strong>闭包</strong>。Java中最接近闭包概念的东西就是lambda表达式了，而Lambda为Java添加了缺失函数式编程的特点。所以什么是函数是接口呢？</p>\n<p>函数式接口需满足以下两个条件：</p>\n<ol>\n<li>它是接口</li>\n<li>这个接口<strong>有且仅有一个抽象方法</strong></li>\n</ol>\n<p>例如我们常用的：Runnable、View.OnClickListener、Comparable等都是函数式接口，因为它们都只有一个方法，而且都是抽象的。虽然只有一个抽象方法，是不是就意味着只能有一个方法呢？实际并不是，虽然有且仅有一个抽象方法，但是可以有多个非抽象方法的接口。</p>\n<p>嗯？！Java接口中难道还可以定义非抽象方法么？平时我们的接口大概长这样：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">IdiomSubmitListener</span> &#123;</span><br><span class=\"line\">   \t<span class=\"keyword\">void</span> <span class=\"title function_\">verifyResult</span><span class=\"params\">(String result)</span>;</span><br><span class=\"line\">   \t<span class=\"keyword\">void</span> <span class=\"title function_\">onSuceess</span><span class=\"params\">()</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>那接口的非抽象方法是啥？原来在JDK 1.8 对于接口而言具有以下新特性：<br><strong>接口可以定义非抽象方法，但必须使用default或者staic关键字来修饰</strong><br>具体细节点可以参考 <a href=\"https://blog.csdn.net/austral/article/details/53402476\">JAVA 8新特性 允许接口定义非抽象方法 快速入门案例</a></p>\n<p>如果一个接口符合函数式接口的定义，那么我们就可以在该接口上面声明FunctionalInterface注解，用来表示该接口是一个函数式接口，并按照函数式接口的规范在编译的时候对该接口进行检查。</p>\n<p>当然如果某个接口只有一个抽象方法，但我们并没有给该接口声明FunctionalInterface注解，那么编译器依旧会将该接口看做是函数式接口。</p>\n<p>那Lambda表达式跟函数式接口又有什么关联呢？<br>在JDK 1.8中，Lambda表达式是对象，而不是函数，它们必须依附于一类特别的对象类型–函数式接口。</p>\n<p>因此可以说 在JDK 1.8中，Lambda表达式就是一个函数式接口的实例。<br><strong>所以如果一个实例是函数式接口的实例，那么该对象就可以用Lambda表达式来表示</strong></p>\n<h2 id=\"二、Lambda表达式与匿名内部类\"><a href=\"#二、Lambda表达式与匿名内部类\" class=\"headerlink\" title=\"二、Lambda表达式与匿名内部类\"></a><strong>二、Lambda表达式与匿名内部类</strong></h2><p>我们知道代码IDE如果是在JDK1.8的环境下，使用匿名内部类作为一个参数传入到方法中，编译器会提示我们：<code>Anonymous new Runnable() can be replaced with lambda</code>，匿名内部类XXX可以替换为lambda表达式。</p>\n<p>如下所示，匿名内部类 Runnable是一个函数式接口的实例，所以我们可以用lambda表达式来将之替换，从而将代码变得更加简洁。<br><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly9vc2NpbWcub3NjaGluYS5uZXQvb3NjbmV0Lzc4YzgxZWMyZjkzMmE5MDhmOTcxM2NiZGM5ODRkOGFhMWI2LmpwZw?x-oss-process=image/format,png\"></p>\n<img src=\"https://cdn.julis.wang/blog/img/20191009170329915.png\">\n<p>那么我们是否就认为：Lambda表达式只是为匿名内部类中提供的一种语法糖，他们有什么区别呢？底层原理是完全一样的呢？</p>\n<p>他们主要区别如下：</p>\n<p>1、关键字this。匿名内部类的this指向匿名类，而Lambda表达式的this指向被Lambda包围的外部类</p>\n<p>2、编译方式。Java编译器将Lambda表达式编译成类的私有方法，使用Java7的invokedynamic字节码动态绑定这个方法。而匿名内部类将编译成<strong>外部类$数字编号</strong>的新类。这也造成第1点关键字this指向不同地方的原因。</p>\n<h2 id=\"三、Lambda实现原理\"><a href=\"#三、Lambda实现原理\" class=\"headerlink\" title=\"三、Lambda实现原理\"></a><strong>三、Lambda实现原理</strong></h2><p>我们知道如果使用匿名内部类，编译期间会生成一个外部类$数字编号的类，如图所示：</p>\n<img src=\"https://cdn.julis.wang/blog/img/20191009172403269.png\">\n\n<p>而如果使用Lambda表达式进行编译后并没有生成新类。</p>\n<img src=\"https://cdn.julis.wang/blog/img/20191009172455212.png\">\n<p>我们对Lambda表达式生成的class文件使用：javap -p -v Test.class 进行反编译生成如下内容，为便于观察，删除了一些无用内容</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">wang</span>.julis.jwbase.basecompact.Test</span><br><span class=\"line\"></span><br><span class=\"line\">Constant pool:</span><br><span class=\"line\">   #<span class=\"number\">1</span> = Methodref          #<span class=\"number\">9.</span>#<span class=\"number\">18</span>         <span class=\"comment\">// java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> wang.julis.jwbase.basecompact.Test();</span><br><span class=\"line\">    descriptor: ()V</span><br><span class=\"line\">    flags: (<span class=\"number\">0x0001</span>) ACC_PUBLIC</span><br><span class=\"line\">    Code:</span><br><span class=\"line\">      stack=<span class=\"number\">1</span>, locals=<span class=\"number\">1</span>, args_size=<span class=\"number\">1</span></span><br><span class=\"line\">         <span class=\"number\">0</span>: aload_0</span><br><span class=\"line\">         <span class=\"number\">1</span>: invokespecial #<span class=\"number\">1</span>                  <span class=\"comment\">// Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class=\"line\">         <span class=\"number\">4</span>: <span class=\"keyword\">return</span></span><br><span class=\"line\">      LineNumberTable:</span><br><span class=\"line\">        line <span class=\"number\">12</span>: <span class=\"number\">0</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">testLambda</span><span class=\"params\">()</span>;</span><br><span class=\"line\">    descriptor: ()V</span><br><span class=\"line\">    flags: (<span class=\"number\">0x0002</span>) ACC_PRIVATE</span><br><span class=\"line\">    Code:</span><br><span class=\"line\">      stack=<span class=\"number\">3</span>, locals=<span class=\"number\">1</span>, args_size=<span class=\"number\">1</span></span><br><span class=\"line\">         <span class=\"number\">0</span>: <span class=\"keyword\">new</span>           #<span class=\"number\">2</span>                  <span class=\"comment\">// class java/lang/Thread</span></span><br><span class=\"line\">         <span class=\"number\">3</span>: dup</span><br><span class=\"line\">         <span class=\"number\">4</span>: invokedynamic #<span class=\"number\">3</span>,  <span class=\"number\">0</span>              <span class=\"comment\">// InvokeDynamic #0:run:()Ljava/lang/Runnable;</span></span><br><span class=\"line\">         <span class=\"number\">9</span>: invokespecial #<span class=\"number\">4</span>                  <span class=\"comment\">// Method java/lang/Thread.&quot;&lt;init&gt;&quot;:(Ljava/lang/Runnable;)V</span></span><br><span class=\"line\">        <span class=\"number\">12</span>: pop</span><br><span class=\"line\">        <span class=\"number\">13</span>: <span class=\"keyword\">return</span></span><br><span class=\"line\">      LineNumberTable:</span><br><span class=\"line\">        line <span class=\"number\">14</span>: <span class=\"number\">0</span></span><br><span class=\"line\">        line <span class=\"number\">18</span>: <span class=\"number\">13</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> lambda$testLambda$<span class=\"number\">0</span>();</span><br><span class=\"line\">    descriptor: ()V</span><br><span class=\"line\">    flags: (<span class=\"number\">0x100a</span>) ACC_PRIVATE, ACC_STATIC, ACC_SYNTHETIC</span><br><span class=\"line\">    Code:</span><br><span class=\"line\">      stack=<span class=\"number\">2</span>, locals=<span class=\"number\">0</span>, args_size=<span class=\"number\">0</span></span><br><span class=\"line\">         <span class=\"number\">0</span>: getstatic     #<span class=\"number\">5</span>                  <span class=\"comment\">// Field java/lang/System.out:Ljava/io/PrintStream;</span></span><br><span class=\"line\">         <span class=\"number\">3</span>: ldc           #<span class=\"number\">6</span>                  <span class=\"comment\">// String lambda</span></span><br><span class=\"line\">         <span class=\"number\">5</span>: invokevirtual #<span class=\"number\">7</span>                  <span class=\"comment\">// Method java/io/PrintStream.println:(Ljava/lang/String;)V</span></span><br><span class=\"line\">         <span class=\"number\">8</span>: <span class=\"keyword\">return</span></span><br><span class=\"line\">      LineNumberTable:</span><br><span class=\"line\">        line <span class=\"number\">15</span>: <span class=\"number\">0</span></span><br><span class=\"line\">        line <span class=\"number\">16</span>: <span class=\"number\">8</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">SourceFile: <span class=\"string\">&quot;Test.java&quot;</span></span><br><span class=\"line\">InnerClasses:</span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> #<span class=\"number\">50</span>= #<span class=\"number\">49</span> of #<span class=\"number\">53</span>;    <span class=\"comment\">// Lookup=class java/lang/invoke/MethodHandles$Lookup of class java/lang/invoke/MethodHandles</span></span><br><span class=\"line\">BootstrapMethods:</span><br><span class=\"line\">  <span class=\"number\">0</span>: #<span class=\"number\">21</span> REF_invokeStatic java/lang/invoke/LambdaMetafactory.metafactory:(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite;</span><br><span class=\"line\">    Method arguments:</span><br><span class=\"line\">      #<span class=\"number\">22</span> ()V</span><br><span class=\"line\">      #<span class=\"number\">23</span> REF_invokeStatic wang/julis/jwbase/basecompact/Test.lambda$testLambda$<span class=\"number\">0</span>:()V</span><br><span class=\"line\">      #<span class=\"number\">22</span> ()V</span><br></pre></td></tr></table></figure>\n<p>从反编译的结果我们可以看到：</p>\n<p>1、编译期间自动生成私有静态类<code>lambda$testLambda$0</code>而这里面就就是lambda的具体实现逻辑</p>\n<p>2、使用invokedynamic去执行lambda表达式 关于invokedynamic命令具体细节可以参考： <a href=\"https://time.geekbang.org/column/article/12564\">08 | JVM是怎么实现invokedynamic的？（上）</a></p>\n<p>3、lambda表达式编译后并没有生成外部类$数字编号的类</p>\n<h2 id=\"总结：\"><a href=\"#总结：\" class=\"headerlink\" title=\"总结：\"></a>总结：</h2><p>1、函数式接口：有且仅有一个抽象方法，可以用非抽象方法1.8后支持</p>\n<p>2、匿名内部类的this指向匿名类，而Lambda表达式的this指向被Lambda包围的外部类</p>\n<p>3、lambda表达式编译后不会生成外部类$数字编号的类</p>\n<p>4、Java编译器将Lambda表达式编译成类的私有方法，使用Java7的invokedynamic字节码动态绑定这个方法。</p>\n<p>参考：<br>1、《深入探索Android热修复技术原理》2.3.8章节<br>2、<a href=\"https://blog.csdn.net/zw19910924/article/details/75907348\">Java8 lambda表达式、函数式接口、方法引用</a></p>\n","categories":[{"name":"技术文章","slug":"technology","api":"api/categories/technology.json"}],"tags":[{"name":"Java","slug":"java","api":"api/tags/java.json"}],"api":"api/posts/2019/10/09/Java中Lambda表达式解析.json"},{"title":"Android骨架屏效果的实现与原理解析","slug":"Android骨架屏效果的实现与原理解析","date":"2019-09-04T09:50:00.000Z","updated":"2025-05-20T11:46:57.000Z","comments":true,"url":"2019/09/04/Android骨架屏效果的实现与原理解析/","excerpt":"<p>大家在使用淘宝的时候，如下图所示有遇到这样的效果，其会只展示一部分骨架大致图，等数据加载完毕之后再展示真正的页面数据。与菊花图相比起来，这样的实现能更好的提升用户的体验，这种效果称做：Skeleton Screen Loading，中文叫做<strong>骨架屏</strong>，本文主要记录其实现过程。</p>\n<h2 id=\"1、骨架屏的实现方式\"><a href=\"#1、骨架屏的实现方式\" class=\"headerlink\" title=\"1、骨架屏的实现方式\"></a>1、骨架屏的实现方式</h2><img src=\"https://cdn.julis.wang/blog/img/b911cd8e3eba7fdc4bea89ad6cb07bf4a7d.png\">\n<p>在现在主流的骨架屏实现效果中有两种方式：</p>\n<ul>\n<li><p>通过View或者Adapter的替换来实现骨架屏效果。可以参考<a href=\"https://github.com/sharish/ShimmerRecyclerView\">ShimmerRecyclerView</a>、<a href=\"https://github.com/ethanhua/Skeleton\">Skeleton</a>及<a href=\"https://github.com/willowtreeapps/spruce-android\">spruce-android</a>。</p>\n</li>\n<li><p>自定义一个View来对布局中的View进行一层包裹，当加载数据时则根据View来绘制骨架，否则显示正常UI，参考<a href=\"https://github.com/rasoulmiri/Skeleton\">Skeleton Android</a>。</p>\n</li>\n</ul>\n<p>这些开源库中，自己比较喜欢今天<strong>Skeleton</strong>这个开源库，总结了有如下一些优缺点：</p>\n<p><strong>优点：</strong></p>\n<ol>\n<li>代码方案实现及使用方式简单，通过替换View和Adapter实现效果，使用Builder设计模式来构造。</li>\n<li>代码耦合程度不高。没有复杂的设计模式，使得代码结构清晰明了。</li>\n<li>骨架屏的效果使用相对于较灵活，可以对整个布局实现骨架屏效果，也可以对单一View实现骨架屏效果。</li>\n</ol>\n<p><strong>缺点：</strong></p>\n<ol>\n<li>需要对每个骨架屏效果单独写一套xml布局。</li>\n<li>使用的removeView和addView对 原有布局的view进行替换，存在一定的风险性</li>\n<li>必须清晰的知道所bind的View类型，存在一定的类型转化问题。</li>\n<li>依赖了shimmerlayout第三方库</li>\n</ol>\n<h2 id=\"2、Skeleton解读\"><a href=\"#2、Skeleton解读\" class=\"headerlink\" title=\"2、Skeleton解读\"></a>2、Skeleton解读</h2><p><strong>一、Skeleton的使用方式</strong></p>\n<p>展示骨架屏效果：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">View</span> <span class=\"variable\">rootView</span> <span class=\"operator\">=</span> findViewById(R.id.rootView);</span><br><span class=\"line\">skeletonScreen = Skeleton.bind(rootView)</span><br><span class=\"line\">           .load(R.layout.activity_view_skeleton)<span class=\"comment\">//骨架屏UI</span></span><br><span class=\"line\">           .duration(<span class=\"number\">1000</span>)<span class=\"comment\">//动画时间，以毫秒为单位</span></span><br><span class=\"line\">           .shimmer(<span class=\"literal\">true</span>)<span class=\"comment\">//是否开启动画</span></span><br><span class=\"line\">           .color(R.color.shimmer_color)<span class=\"comment\">//shimmer的颜色</span></span><br><span class=\"line\">           .angle(<span class=\"number\">30</span>)<span class=\"comment\">//shimmer的倾斜角度</span></span><br><span class=\"line\">           .show();</span><br></pre></td></tr></table></figure>\n<p>关闭骨架屏效果并展示原有View：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">skeletonScreen.hide()</span><br></pre></td></tr></table></figure>\n\n<p><strong>流程：</strong></p>\n<p> <strong>1. 选择需要替换的目标view<br> 2. 将骨架效果xml与目标view进行绑定<br> 3. 添加一些效果属性，比如：动画时间、是否开启展示动画、动画颜色等<br> 4. 在合适的实际关闭骨架屏效果</strong></p>\n<p><strong>二、Skeleton源码实现</strong></p>\n<p>Skeleton提供两个绑定方法，分别绑定普通View与RecyclerView，分别返回对应的Builder</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Skeleton</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> RecyclerViewSkeletonScreen.Builder <span class=\"title function_\">bind</span><span class=\"params\">(RecyclerView recyclerView)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">RecyclerViewSkeletonScreen</span>.Builder(recyclerView);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> ViewSkeletonScreen.Builder <span class=\"title function_\">bind</span><span class=\"params\">(View view)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ViewSkeletonScreen</span>.Builder(view);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们首先来看看如何实现与普通View绑定，构造方法中传入目标View，并对shimmer动画效果设置默认的颜色，在Builder里面我们可以看到各种相关参数的设定。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"title function_\">Builder</span><span class=\"params\">(View view)</span> &#123;</span><br><span class=\"line\">\t<span class=\"built_in\">this</span>.mView = view;</span><br><span class=\"line\">\t<span class=\"built_in\">this</span>.mShimmerColor = ContextCompat.getColor(mView.getContext(), R.color.shimmer_color);</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<p>接下来再到show的步骤，主要实现还是由ViewSkeletonScreen来实现</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> ViewSkeletonScreen <span class=\"title function_\">show</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">ViewSkeletonScreen</span> <span class=\"variable\">skeletonScreen</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ViewSkeletonScreen</span>(<span class=\"built_in\">this</span>);</span><br><span class=\"line\">    skeletonScreen.show();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> skeletonScreen;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>其中ViewSkeletonScreen与绑定的RecyclerViewSkeletonScreen都实现了SkeletonScreen接口，SkeletonScreen有两个接口方法分别是   </p>\n<pre><code>void show();\nvoid hide();\n</code></pre>\n<p>对于ViewSkeletonScreen.show()进入源码，这里出现一个比较重要的类<code>ViewReplacer</code>，等下再进行解析，通过show的源码清楚的知道逻辑：<br><strong>1、生成骨架效果View<br>2、利用生成的View替换目标View。</strong><br>其中生成骨架效果View阶段主要还是通过LayoutInflater去加载传入mSkeletonResID</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">show</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">       <span class=\"type\">View</span> <span class=\"variable\">skeletonLoadingView</span> <span class=\"operator\">=</span> generateSkeletonLoadingView();</span><br><span class=\"line\">       <span class=\"keyword\">if</span> (skeletonLoadingView != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">           mViewReplacer.replace(skeletonLoadingView);</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n<p>接下来主要讲解ViewReplacer类，其构造方法传入目标View</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"title function_\">ViewReplacer</span><span class=\"params\">(View sourceView)</span> &#123;</span><br><span class=\"line\">     mSourceView = sourceView;</span><br><span class=\"line\">     mSourceViewLayoutParams = mSourceView.getLayoutParams();</span><br><span class=\"line\">     mCurrentView = mSourceView;</span><br><span class=\"line\">     mSourceViewId = mSourceView.getId();</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n<p>其比较重要的方法有两个：<code>replace()</code> 和 <code>restore()</code> 这两个方法分别为SkeletonScreen 的show()和hide()的最终实现，首先看<code>replace()</code>方法，有两个方法重载，分别传入<code>targetViewResID</code>或者<code>targetView</code>，最终还是会走到<code>replace(View targetView)</code>中。<br>其主要逻辑为：</p>\n<p> <strong>1. 判断所替换的View和骨架屏效果View是否为同一个View<br> 2. remove掉在父布局中的目标View<br> 3. 将骨架屏效果View添加到目标View的父布局中</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">replace</span><span class=\"params\">(<span class=\"type\">int</span> targetViewResID)</span> &#123;</span><br><span class=\"line\">       <span class=\"keyword\">if</span> (mTargetViewResID == targetViewResID) &#123;</span><br><span class=\"line\">           <span class=\"keyword\">return</span>;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       <span class=\"keyword\">if</span> (init()) &#123;</span><br><span class=\"line\">           mTargetViewResID = targetViewResID;</span><br><span class=\"line\">           replace(LayoutInflater.from(mSourceView.getContext()).inflate(mTargetViewResID, mSourceParentView, <span class=\"literal\">false</span>));</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">replace</span><span class=\"params\">(View targetView)</span> &#123;</span><br><span class=\"line\">       <span class=\"keyword\">if</span> (mCurrentView == targetView) &#123;</span><br><span class=\"line\">           <span class=\"keyword\">return</span>;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       <span class=\"keyword\">if</span> (targetView.getParent() != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">           ((ViewGroup) targetView.getParent()).removeView(targetView);</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       <span class=\"keyword\">if</span> (init()) &#123;</span><br><span class=\"line\">           mTargetView = targetView;</span><br><span class=\"line\">           mSourceParentView.removeView(mCurrentView);</span><br><span class=\"line\">           mTargetView.setId(mSourceViewId);</span><br><span class=\"line\">           mSourceParentView.addView(mTargetView, mSourceViewIndexInParent, mSourceViewLayoutParams);</span><br><span class=\"line\">           mCurrentView = mTargetView;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n\n<p>在执行添加到目标View的父布局中，有执行一个init方法，主要做两件事：</p>\n<p> <strong>1. 获取目标View的父View<br> 2. 找到目标View在父View 中的位置索引，为之后添加骨架屏View到父View中做铺垫</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"type\">boolean</span> <span class=\"title function_\">init</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">     <span class=\"keyword\">if</span> (mSourceParentView == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">         mSourceParentView = (ViewGroup) mSourceView.getParent();</span><br><span class=\"line\">         <span class=\"keyword\">if</span> (mSourceParentView == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">             Log.e(TAG, <span class=\"string\">&quot;the source view have not attach to any view&quot;</span>);</span><br><span class=\"line\">             <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">         <span class=\"type\">int</span> <span class=\"variable\">count</span> <span class=\"operator\">=</span> mSourceParentView.getChildCount();</span><br><span class=\"line\">         <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">index</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; index &lt; count; index++) &#123;</span><br><span class=\"line\">             <span class=\"keyword\">if</span> (mSourceView == mSourceParentView.getChildAt(index)) &#123;</span><br><span class=\"line\">                 mSourceViewIndexInParent = index;</span><br><span class=\"line\">                 <span class=\"keyword\">break</span>;</span><br><span class=\"line\">             &#125;</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">     <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n<p>至此对普通View的骨架屏效果实现流程已经完全梳理完成，那对于<code>RecyclerView</code>呢？其实两者实现逻辑差不多，主要有两个差异：</p>\n<ol>\n<li>在<code>RecyclerViewSkeletonScreen</code>的Builder中，相比ViewSkeletonScreen多了一个adapter()方法，传入目标<code>RecyclerView</code>的<code>Adapter</code></li>\n<li>在show的时候对目标<code>RecyclerView</code>的adapter进行替换，使用骨架屏效果的adapter。hide的时候恢复为原先的Adapter</li>\n</ol>\n<h2 id=\"3、总结\"><a href=\"#3、总结\" class=\"headerlink\" title=\"3、总结\"></a>3、总结</h2><ol>\n<li>Skeleton的原理主要是通过替换目标View和RecyclerView的Adapter</li>\n<li>在Skeleton的使用过程中最需要关心的两个问题是：show()和hide()的时机</li>\n<li>对于整个页面的骨架屏效果实现，个人推荐在布局中添加一个全屏的空View盖在原先内容上</li>\n<li>注意一些异常情况下的hide()，要不然整个页面就“假死”状态了。</li>\n</ol>\n<p>参考：<br><a href=\"https://juejin.im/post/5c789a4ce51d457c042d3b31\">https://juejin.im/post/5c789a4ce51d457c042d3b31</a></p>\n","cover":null,"images":["https://cdn.julis.wang/blog/img/b911cd8e3eba7fdc4bea89ad6cb07bf4a7d.png"],"content":"<p>大家在使用淘宝的时候，如下图所示有遇到这样的效果，其会只展示一部分骨架大致图，等数据加载完毕之后再展示真正的页面数据。与菊花图相比起来，这样的实现能更好的提升用户的体验，这种效果称做：Skeleton Screen Loading，中文叫做<strong>骨架屏</strong>，本文主要记录其实现过程。</p>\n<h2 id=\"1、骨架屏的实现方式\"><a href=\"#1、骨架屏的实现方式\" class=\"headerlink\" title=\"1、骨架屏的实现方式\"></a>1、骨架屏的实现方式</h2><img src=\"https://cdn.julis.wang/blog/img/b911cd8e3eba7fdc4bea89ad6cb07bf4a7d.png\">\n<p>在现在主流的骨架屏实现效果中有两种方式：</p>\n<ul>\n<li><p>通过View或者Adapter的替换来实现骨架屏效果。可以参考<a href=\"https://github.com/sharish/ShimmerRecyclerView\">ShimmerRecyclerView</a>、<a href=\"https://github.com/ethanhua/Skeleton\">Skeleton</a>及<a href=\"https://github.com/willowtreeapps/spruce-android\">spruce-android</a>。</p>\n</li>\n<li><p>自定义一个View来对布局中的View进行一层包裹，当加载数据时则根据View来绘制骨架，否则显示正常UI，参考<a href=\"https://github.com/rasoulmiri/Skeleton\">Skeleton Android</a>。</p>\n</li>\n</ul>\n<p>这些开源库中，自己比较喜欢今天<strong>Skeleton</strong>这个开源库，总结了有如下一些优缺点：</p>\n<p><strong>优点：</strong></p>\n<ol>\n<li>代码方案实现及使用方式简单，通过替换View和Adapter实现效果，使用Builder设计模式来构造。</li>\n<li>代码耦合程度不高。没有复杂的设计模式，使得代码结构清晰明了。</li>\n<li>骨架屏的效果使用相对于较灵活，可以对整个布局实现骨架屏效果，也可以对单一View实现骨架屏效果。</li>\n</ol>\n<p><strong>缺点：</strong></p>\n<ol>\n<li>需要对每个骨架屏效果单独写一套xml布局。</li>\n<li>使用的removeView和addView对 原有布局的view进行替换，存在一定的风险性</li>\n<li>必须清晰的知道所bind的View类型，存在一定的类型转化问题。</li>\n<li>依赖了shimmerlayout第三方库</li>\n</ol>\n<h2 id=\"2、Skeleton解读\"><a href=\"#2、Skeleton解读\" class=\"headerlink\" title=\"2、Skeleton解读\"></a>2、Skeleton解读</h2><p><strong>一、Skeleton的使用方式</strong></p>\n<p>展示骨架屏效果：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">View</span> <span class=\"variable\">rootView</span> <span class=\"operator\">=</span> findViewById(R.id.rootView);</span><br><span class=\"line\">skeletonScreen = Skeleton.bind(rootView)</span><br><span class=\"line\">           .load(R.layout.activity_view_skeleton)<span class=\"comment\">//骨架屏UI</span></span><br><span class=\"line\">           .duration(<span class=\"number\">1000</span>)<span class=\"comment\">//动画时间，以毫秒为单位</span></span><br><span class=\"line\">           .shimmer(<span class=\"literal\">true</span>)<span class=\"comment\">//是否开启动画</span></span><br><span class=\"line\">           .color(R.color.shimmer_color)<span class=\"comment\">//shimmer的颜色</span></span><br><span class=\"line\">           .angle(<span class=\"number\">30</span>)<span class=\"comment\">//shimmer的倾斜角度</span></span><br><span class=\"line\">           .show();</span><br></pre></td></tr></table></figure>\n<p>关闭骨架屏效果并展示原有View：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">skeletonScreen.hide()</span><br></pre></td></tr></table></figure>\n\n<p><strong>流程：</strong></p>\n<p> <strong>1. 选择需要替换的目标view<br> 2. 将骨架效果xml与目标view进行绑定<br> 3. 添加一些效果属性，比如：动画时间、是否开启展示动画、动画颜色等<br> 4. 在合适的实际关闭骨架屏效果</strong></p>\n<p><strong>二、Skeleton源码实现</strong></p>\n<p>Skeleton提供两个绑定方法，分别绑定普通View与RecyclerView，分别返回对应的Builder</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Skeleton</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> RecyclerViewSkeletonScreen.Builder <span class=\"title function_\">bind</span><span class=\"params\">(RecyclerView recyclerView)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">RecyclerViewSkeletonScreen</span>.Builder(recyclerView);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> ViewSkeletonScreen.Builder <span class=\"title function_\">bind</span><span class=\"params\">(View view)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ViewSkeletonScreen</span>.Builder(view);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们首先来看看如何实现与普通View绑定，构造方法中传入目标View，并对shimmer动画效果设置默认的颜色，在Builder里面我们可以看到各种相关参数的设定。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"title function_\">Builder</span><span class=\"params\">(View view)</span> &#123;</span><br><span class=\"line\">\t<span class=\"built_in\">this</span>.mView = view;</span><br><span class=\"line\">\t<span class=\"built_in\">this</span>.mShimmerColor = ContextCompat.getColor(mView.getContext(), R.color.shimmer_color);</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<p>接下来再到show的步骤，主要实现还是由ViewSkeletonScreen来实现</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> ViewSkeletonScreen <span class=\"title function_\">show</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">ViewSkeletonScreen</span> <span class=\"variable\">skeletonScreen</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ViewSkeletonScreen</span>(<span class=\"built_in\">this</span>);</span><br><span class=\"line\">    skeletonScreen.show();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> skeletonScreen;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>其中ViewSkeletonScreen与绑定的RecyclerViewSkeletonScreen都实现了SkeletonScreen接口，SkeletonScreen有两个接口方法分别是   </p>\n<pre><code>void show();\nvoid hide();\n</code></pre>\n<p>对于ViewSkeletonScreen.show()进入源码，这里出现一个比较重要的类<code>ViewReplacer</code>，等下再进行解析，通过show的源码清楚的知道逻辑：<br><strong>1、生成骨架效果View<br>2、利用生成的View替换目标View。</strong><br>其中生成骨架效果View阶段主要还是通过LayoutInflater去加载传入mSkeletonResID</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">show</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">       <span class=\"type\">View</span> <span class=\"variable\">skeletonLoadingView</span> <span class=\"operator\">=</span> generateSkeletonLoadingView();</span><br><span class=\"line\">       <span class=\"keyword\">if</span> (skeletonLoadingView != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">           mViewReplacer.replace(skeletonLoadingView);</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n<p>接下来主要讲解ViewReplacer类，其构造方法传入目标View</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"title function_\">ViewReplacer</span><span class=\"params\">(View sourceView)</span> &#123;</span><br><span class=\"line\">     mSourceView = sourceView;</span><br><span class=\"line\">     mSourceViewLayoutParams = mSourceView.getLayoutParams();</span><br><span class=\"line\">     mCurrentView = mSourceView;</span><br><span class=\"line\">     mSourceViewId = mSourceView.getId();</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n<p>其比较重要的方法有两个：<code>replace()</code> 和 <code>restore()</code> 这两个方法分别为SkeletonScreen 的show()和hide()的最终实现，首先看<code>replace()</code>方法，有两个方法重载，分别传入<code>targetViewResID</code>或者<code>targetView</code>，最终还是会走到<code>replace(View targetView)</code>中。<br>其主要逻辑为：</p>\n<p> <strong>1. 判断所替换的View和骨架屏效果View是否为同一个View<br> 2. remove掉在父布局中的目标View<br> 3. 将骨架屏效果View添加到目标View的父布局中</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">replace</span><span class=\"params\">(<span class=\"type\">int</span> targetViewResID)</span> &#123;</span><br><span class=\"line\">       <span class=\"keyword\">if</span> (mTargetViewResID == targetViewResID) &#123;</span><br><span class=\"line\">           <span class=\"keyword\">return</span>;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       <span class=\"keyword\">if</span> (init()) &#123;</span><br><span class=\"line\">           mTargetViewResID = targetViewResID;</span><br><span class=\"line\">           replace(LayoutInflater.from(mSourceView.getContext()).inflate(mTargetViewResID, mSourceParentView, <span class=\"literal\">false</span>));</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">replace</span><span class=\"params\">(View targetView)</span> &#123;</span><br><span class=\"line\">       <span class=\"keyword\">if</span> (mCurrentView == targetView) &#123;</span><br><span class=\"line\">           <span class=\"keyword\">return</span>;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       <span class=\"keyword\">if</span> (targetView.getParent() != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">           ((ViewGroup) targetView.getParent()).removeView(targetView);</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       <span class=\"keyword\">if</span> (init()) &#123;</span><br><span class=\"line\">           mTargetView = targetView;</span><br><span class=\"line\">           mSourceParentView.removeView(mCurrentView);</span><br><span class=\"line\">           mTargetView.setId(mSourceViewId);</span><br><span class=\"line\">           mSourceParentView.addView(mTargetView, mSourceViewIndexInParent, mSourceViewLayoutParams);</span><br><span class=\"line\">           mCurrentView = mTargetView;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n\n<p>在执行添加到目标View的父布局中，有执行一个init方法，主要做两件事：</p>\n<p> <strong>1. 获取目标View的父View<br> 2. 找到目标View在父View 中的位置索引，为之后添加骨架屏View到父View中做铺垫</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"type\">boolean</span> <span class=\"title function_\">init</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">     <span class=\"keyword\">if</span> (mSourceParentView == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">         mSourceParentView = (ViewGroup) mSourceView.getParent();</span><br><span class=\"line\">         <span class=\"keyword\">if</span> (mSourceParentView == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">             Log.e(TAG, <span class=\"string\">&quot;the source view have not attach to any view&quot;</span>);</span><br><span class=\"line\">             <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">         <span class=\"type\">int</span> <span class=\"variable\">count</span> <span class=\"operator\">=</span> mSourceParentView.getChildCount();</span><br><span class=\"line\">         <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">index</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; index &lt; count; index++) &#123;</span><br><span class=\"line\">             <span class=\"keyword\">if</span> (mSourceView == mSourceParentView.getChildAt(index)) &#123;</span><br><span class=\"line\">                 mSourceViewIndexInParent = index;</span><br><span class=\"line\">                 <span class=\"keyword\">break</span>;</span><br><span class=\"line\">             &#125;</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">     <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n<p>至此对普通View的骨架屏效果实现流程已经完全梳理完成，那对于<code>RecyclerView</code>呢？其实两者实现逻辑差不多，主要有两个差异：</p>\n<ol>\n<li>在<code>RecyclerViewSkeletonScreen</code>的Builder中，相比ViewSkeletonScreen多了一个adapter()方法，传入目标<code>RecyclerView</code>的<code>Adapter</code></li>\n<li>在show的时候对目标<code>RecyclerView</code>的adapter进行替换，使用骨架屏效果的adapter。hide的时候恢复为原先的Adapter</li>\n</ol>\n<h2 id=\"3、总结\"><a href=\"#3、总结\" class=\"headerlink\" title=\"3、总结\"></a>3、总结</h2><ol>\n<li>Skeleton的原理主要是通过替换目标View和RecyclerView的Adapter</li>\n<li>在Skeleton的使用过程中最需要关心的两个问题是：show()和hide()的时机</li>\n<li>对于整个页面的骨架屏效果实现，个人推荐在布局中添加一个全屏的空View盖在原先内容上</li>\n<li>注意一些异常情况下的hide()，要不然整个页面就“假死”状态了。</li>\n</ol>\n<p>参考：<br><a href=\"https://juejin.im/post/5c789a4ce51d457c042d3b31\">https://juejin.im/post/5c789a4ce51d457c042d3b31</a></p>\n","categories":[{"name":"技术文章","slug":"technology","api":"api/categories/technology.json"}],"tags":[{"name":"Android","slug":"Android","api":"api/tags/Android.json"}],"api":"api/posts/2019/09/04/Android骨架屏效果的实现与原理解析.json"},{"title":"Android 插件化之ClassLoader","slug":"Android-插件化之ClassLoader","date":"2019-08-26T08:47:00.000Z","updated":"2025-05-20T11:46:57.000Z","comments":true,"url":"2019/08/26/Android-插件化之ClassLoader/","excerpt":"<p><strong>插件化要解决的三个核心问题：类加载、资源加载、组件生命周期管理。</strong></p>\n<p>在Android插件化中其原理实际是 Java ClassLoader的原理，此博文主要对Android插件化中类加载中的DexClassLoader做总结，便于之后对Android插件化的理解学习。</p>\n<p>Android的Dalvik虚拟机和Java虚拟机的运行原理相同都是将对应的java类加载在内存中运行。而Java虚拟机是加载class文件，也可以将一段二进制流通过defineClass方法生产Class进行加载。Dalvik虚拟机加载的dex文件。dex文件是Android对与Class文件做的优化，以便于提高手机的性能。可以想象dex为class文件的一个压缩文件。dex在Android中的加载和class在jvm中的相同都是基于双亲委派模型，都是调用ClassLoader的loadClass方法加载类。</p>\n<h2 id=\"1、DexClassLoader和PathClassLoader区别\"><a href=\"#1、DexClassLoader和PathClassLoader区别\" class=\"headerlink\" title=\"1、DexClassLoader和PathClassLoader区别\"></a><strong>1、DexClassLoader和PathClassLoader区别</strong></h2><p>Android 也有自己的 ClassLoader，分为 <code>DexClassLoader</code>和<code>PathClassLoader</code>，这两者有什么区别和关联呢？</p>\n<p>阅读源码可以看到两者的构造方法分别为：</p>\n<pre><code>public class PathClassLoader extends BaseDexClassLoader &#123;\n    public PathClassLoader(String dexPath, ClassLoader parent) &#123;\n        super(dexPath, null, null, parent);\n    &#125;\n    public PathClassLoader(String dexPath, String libraryPath,\n            ClassLoader parent) &#123;\n        super(dexPath, null, libraryPath, parent);\n    &#125;\n&#125;\n\npublic class DexClassLoader extends BaseDexClassLoader &#123;\n    public DexClassLoader(String dexPath, String optimizedDirectory,\n            String libraryPath, ClassLoader parent) &#123;\n        super(dexPath, new File(optimizedDirectory), libraryPath, parent);\n    &#125;\n&#125;\n</code></pre>\n<p>可以发现<code>DexClassLoader</code> 比 <code>PathClassLoader</code> 多一个参数<code>String optimizedDirectory</code>，那这个参数具体做什么的呢？继续查看源码我们可以知道<code>optimizedDirectory</code>是用来缓存我们需要加载的dex文件的，并创建一个<code>DexFile</code>对象，如果它为null，那么会直接使用dex文件原有的路径来创建DexFile 对象，其具体体现在如下代码区域：</p>\n<pre><code>private static DexFile loadDexFile(File file, File optimizedDirectory)\n        throws IOException &#123;\n    if (optimizedDirectory == null) &#123;\n        return new DexFile(file);\n    &#125; else &#123;\n        String optimizedPath = optimizedPathFor(file, optimizedDirectory);\n        return DexFile.loadDex(file.getPath(), optimizedPath, 0);\n    &#125;\n&#125;\n</code></pre>\n<p>因此两者区别在于 <code>PathClassLoader</code> 不能直接从 zip 包中得到 dex，因此只支持直接操作 dex 文件或者已经安装过的 apk。而 <code>DexClassLoader</code> 可以加载外部的 apk、jar 或 dex文件，并且会在指定的 outpath 路径存放其 dex 文件。所以在插件化中我们使用<code>DexClassLoader</code>来加载class的，接下来讲解<code>DexClassLoader</code>的用法。</p>\n<h2 id=\"2、DexClassLoader用法\"><a href=\"#2、DexClassLoader用法\" class=\"headerlink\" title=\"2、DexClassLoader用法\"></a><strong>2、DexClassLoader用法</strong></h2><p>其构造方法为：</p>\n<pre><code>DexClassLoader(\n\tString dexPath, \n\t\tString optimizedDirectory, \n\tString librarySearchPath,\n \tClassLoader parent)\n</code></pre>\n<p><code>dexPath</code>:被解压的apk路径，不能为空。<br><code>optimizedDirectory</code>：解压后的.dex文件的存储路径，不能为空。这个路径强烈建议使用应用程序的私有路径，不要放到sdcard上，否则代码容易被注入攻击。<br><code>libraryPath</code>：os库的存放路径，可以为空，若有os库，必须填写。<br><code>parent</code>：父亲加载器，一般为context.getClassLoader(),使用当前上下文的类加载器。</p>\n<p>接下来讲解具体使用流程：</p>\n<p>1、新建一个名为plugin的project，其中新建一个<code>Bean</code>类，只有一个方法<code>getName()</code>返回一个字符串“My App”，然后对plugin这个工程打包为apk，将apk放在主工程的asser目录中。</p>\n<img src=\"https://cdn.julis.wang/blog/img/20190827104738557.png\">\n<p>2、构造Classloader</p>\n<pre><code>  File extractFile = getFileStreamPath(&quot;app-debug.apk&quot;);\n  String dexPath = extractFile.getPath();\n  File fileRelease = getDir(&quot;dex&quot;, 0);\n  ClassLoader classLoader = new DexClassLoader(dexPath, fileRelease.getAbsolutePath(), null, getClassLoader());\n</code></pre>\n<p>3、利用构造好的Classloader反射调用插件类中的方法</p>\n<pre><code>  Class mLoadClassBean;\n  try &#123;\n        mLoadClassBean = classLoader.loadClass(&quot;com.example.plugin.Bean&quot;);\n        Object beanObject = mLoadClassBean.newInstance();\n        Method getNameMethod = mLoadClassBean.getMethod(&quot;getName&quot;);\n        getNameMethod.setAccessible(true);\n        String name = (String) getNameMethod.invoke(beanObject);\n        Log.e(&quot;julis&quot;, name);\n    &#125; catch(Exception e) &#123;\n        e.printStackTrace();\n    &#125;\n    \n</code></pre>\n<p>成功打印出结果：</p>\n<img src=\"https://cdn.julis.wang/blog/img/20190827143354781.png\">\n<p>参考：</p>\n<p><a href=\"https://www.jianshu.com/p/4b4f1fa6633c\">https://www.jianshu.com/p/4b4f1fa6633c</a></p>\n<p><a href=\"https://www.jianshu.com/p/53aa2de20cf8\">https://www.jianshu.com/p/53aa2de20cf8</a></p>\n<p><a href=\"https://cloud.tencent.com/developer/article/1071815\">https://cloud.tencent.com/developer/article/1071815</a></p>\n","cover":null,"images":["https://cdn.julis.wang/blog/img/20190827104738557.png","https://cdn.julis.wang/blog/img/20190827143354781.png"],"content":"<p><strong>插件化要解决的三个核心问题：类加载、资源加载、组件生命周期管理。</strong></p>\n<p>在Android插件化中其原理实际是 Java ClassLoader的原理，此博文主要对Android插件化中类加载中的DexClassLoader做总结，便于之后对Android插件化的理解学习。</p>\n<p>Android的Dalvik虚拟机和Java虚拟机的运行原理相同都是将对应的java类加载在内存中运行。而Java虚拟机是加载class文件，也可以将一段二进制流通过defineClass方法生产Class进行加载。Dalvik虚拟机加载的dex文件。dex文件是Android对与Class文件做的优化，以便于提高手机的性能。可以想象dex为class文件的一个压缩文件。dex在Android中的加载和class在jvm中的相同都是基于双亲委派模型，都是调用ClassLoader的loadClass方法加载类。</p>\n<h2 id=\"1、DexClassLoader和PathClassLoader区别\"><a href=\"#1、DexClassLoader和PathClassLoader区别\" class=\"headerlink\" title=\"1、DexClassLoader和PathClassLoader区别\"></a><strong>1、DexClassLoader和PathClassLoader区别</strong></h2><p>Android 也有自己的 ClassLoader，分为 <code>DexClassLoader</code>和<code>PathClassLoader</code>，这两者有什么区别和关联呢？</p>\n<p>阅读源码可以看到两者的构造方法分别为：</p>\n<pre><code>public class PathClassLoader extends BaseDexClassLoader &#123;\n    public PathClassLoader(String dexPath, ClassLoader parent) &#123;\n        super(dexPath, null, null, parent);\n    &#125;\n    public PathClassLoader(String dexPath, String libraryPath,\n            ClassLoader parent) &#123;\n        super(dexPath, null, libraryPath, parent);\n    &#125;\n&#125;\n\npublic class DexClassLoader extends BaseDexClassLoader &#123;\n    public DexClassLoader(String dexPath, String optimizedDirectory,\n            String libraryPath, ClassLoader parent) &#123;\n        super(dexPath, new File(optimizedDirectory), libraryPath, parent);\n    &#125;\n&#125;\n</code></pre>\n<p>可以发现<code>DexClassLoader</code> 比 <code>PathClassLoader</code> 多一个参数<code>String optimizedDirectory</code>，那这个参数具体做什么的呢？继续查看源码我们可以知道<code>optimizedDirectory</code>是用来缓存我们需要加载的dex文件的，并创建一个<code>DexFile</code>对象，如果它为null，那么会直接使用dex文件原有的路径来创建DexFile 对象，其具体体现在如下代码区域：</p>\n<pre><code>private static DexFile loadDexFile(File file, File optimizedDirectory)\n        throws IOException &#123;\n    if (optimizedDirectory == null) &#123;\n        return new DexFile(file);\n    &#125; else &#123;\n        String optimizedPath = optimizedPathFor(file, optimizedDirectory);\n        return DexFile.loadDex(file.getPath(), optimizedPath, 0);\n    &#125;\n&#125;\n</code></pre>\n<p>因此两者区别在于 <code>PathClassLoader</code> 不能直接从 zip 包中得到 dex，因此只支持直接操作 dex 文件或者已经安装过的 apk。而 <code>DexClassLoader</code> 可以加载外部的 apk、jar 或 dex文件，并且会在指定的 outpath 路径存放其 dex 文件。所以在插件化中我们使用<code>DexClassLoader</code>来加载class的，接下来讲解<code>DexClassLoader</code>的用法。</p>\n<h2 id=\"2、DexClassLoader用法\"><a href=\"#2、DexClassLoader用法\" class=\"headerlink\" title=\"2、DexClassLoader用法\"></a><strong>2、DexClassLoader用法</strong></h2><p>其构造方法为：</p>\n<pre><code>DexClassLoader(\n\tString dexPath, \n\t\tString optimizedDirectory, \n\tString librarySearchPath,\n \tClassLoader parent)\n</code></pre>\n<p><code>dexPath</code>:被解压的apk路径，不能为空。<br><code>optimizedDirectory</code>：解压后的.dex文件的存储路径，不能为空。这个路径强烈建议使用应用程序的私有路径，不要放到sdcard上，否则代码容易被注入攻击。<br><code>libraryPath</code>：os库的存放路径，可以为空，若有os库，必须填写。<br><code>parent</code>：父亲加载器，一般为context.getClassLoader(),使用当前上下文的类加载器。</p>\n<p>接下来讲解具体使用流程：</p>\n<p>1、新建一个名为plugin的project，其中新建一个<code>Bean</code>类，只有一个方法<code>getName()</code>返回一个字符串“My App”，然后对plugin这个工程打包为apk，将apk放在主工程的asser目录中。</p>\n<img src=\"https://cdn.julis.wang/blog/img/20190827104738557.png\">\n<p>2、构造Classloader</p>\n<pre><code>  File extractFile = getFileStreamPath(&quot;app-debug.apk&quot;);\n  String dexPath = extractFile.getPath();\n  File fileRelease = getDir(&quot;dex&quot;, 0);\n  ClassLoader classLoader = new DexClassLoader(dexPath, fileRelease.getAbsolutePath(), null, getClassLoader());\n</code></pre>\n<p>3、利用构造好的Classloader反射调用插件类中的方法</p>\n<pre><code>  Class mLoadClassBean;\n  try &#123;\n        mLoadClassBean = classLoader.loadClass(&quot;com.example.plugin.Bean&quot;);\n        Object beanObject = mLoadClassBean.newInstance();\n        Method getNameMethod = mLoadClassBean.getMethod(&quot;getName&quot;);\n        getNameMethod.setAccessible(true);\n        String name = (String) getNameMethod.invoke(beanObject);\n        Log.e(&quot;julis&quot;, name);\n    &#125; catch(Exception e) &#123;\n        e.printStackTrace();\n    &#125;\n    \n</code></pre>\n<p>成功打印出结果：</p>\n<img src=\"https://cdn.julis.wang/blog/img/20190827143354781.png\">\n<p>参考：</p>\n<p><a href=\"https://www.jianshu.com/p/4b4f1fa6633c\">https://www.jianshu.com/p/4b4f1fa6633c</a></p>\n<p><a href=\"https://www.jianshu.com/p/53aa2de20cf8\">https://www.jianshu.com/p/53aa2de20cf8</a></p>\n<p><a href=\"https://cloud.tencent.com/developer/article/1071815\">https://cloud.tencent.com/developer/article/1071815</a></p>\n","categories":[{"name":"技术文章","slug":"technology","api":"api/categories/technology.json"}],"tags":[{"name":"插件化","slug":"plugins","api":"api/tags/plugins.json"}],"api":"api/posts/2019/08/26/Android-插件化之ClassLoader.json"},{"title":"单例模式的设计","slug":"单例模式的设计","date":"2019-07-09T01:56:00.000Z","updated":"2025-05-20T11:46:57.000Z","comments":true,"url":"2019/07/09/单例模式的设计/","excerpt":"<p>原文回答于知乎(<a href=\"https://www.zhihu.com/question/277243683/answer/392772061\">如何把一段简单的代码变复杂？ - 落叶挽歌的回答</a>)</p>\n<p>我们都知道单例模式很简单，大概是这样：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//单线程单例模式实现</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Singleton</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Singleton instance=<span class=\"literal\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Singleton <span class=\"title function_\">getInstance</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(<span class=\"literal\">null</span>==instance)&#123;</span><br><span class=\"line\">            instance = <span class=\"keyword\">new</span> <span class=\"title class_\">Singleton</span>();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>但是呢，在多线程条件下getInstance()并不是一个原子操作。由于代码没有使用任何同步机制，因此该线程可能会出现线程交错的情形：在instance还是null的时候，如果两个线程同时执行到 if(null&#x3D;&#x3D;instance)那么会创建两个实例，从而违背了初衷。于是通过简单加锁来解决这种问题：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//简单加锁实现单例模式</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Singleton</span>  &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Singleton instance=<span class=\"literal\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Singleton <span class=\"title function_\">getInstance</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span> (Singleton.class)&#123;<span class=\"comment\">//加入synchronized同步</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(<span class=\"literal\">null</span>==instance)&#123;</span><br><span class=\"line\">                instance = <span class=\"keyword\">new</span> <span class=\"title class_\">Singleton</span>();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这种方式实现单例模式固然安全，但意味着每次调用 getInstance()都会申请锁，为了避免开销，我们想到了另一种办法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//基于双重检查锁定的错误单例模式实现</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Singleton</span>  &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Singleton instance=<span class=\"literal\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Singleton <span class=\"title function_\">getInstance</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(<span class=\"literal\">null</span>==instance)&#123;<span class=\"comment\">//先检查是否为null，再执行之上的代码</span></span><br><span class=\"line\">            <span class=\"keyword\">synchronized</span> (Singleton.class)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(<span class=\"literal\">null</span>==instance)&#123;</span><br><span class=\"line\">                    instance = <span class=\"keyword\">new</span> <span class=\"title class_\">Singleton</span>();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>通过这种方法，虽然第一次检查对变量instance的访问没有加锁从而使竞态仍然可能存在，它似乎避免了锁的开销又保障了线程的安全。然后对 instance &#x3D; new Singleton();进行伪代码独立子操作：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">obj=allocate(Singleton.class);<span class=\"comment\">//1、分配对象所需的存储空间</span></span><br><span class=\"line\">invokeConstructor(obj);<span class=\"comment\">//2、初始化obj的引用对象</span></span><br><span class=\"line\">instance=obj;<span class=\"comment\">//3、将对象引用写入共享变量</span></span><br></pre></td></tr></table></figure>\n<p>由于重排序的规则，临界区内的操作可以再临界区内重排序，因此JIT编译器可能将上述子操作重排序为：1-&gt;3-&gt;2，即在初始化对象之前将对象引用写入实例变量instace。由于锁对有序性的保障是有条件的，而操作1读取intance变量的时候并没有加锁，因此重排序是对1操作是有影响的：该线程可能看到一个未初始化（或者为初始化完毕）的实例，即intance不为null。于是该线程直接就直接返回这个instance变量所引用的实例，而实例可能是未初始化完毕的，这就是可能导致程序出错。明白问题的原因之后，解决方法也不难想到了：<strong>只需将instance变量加入volatile修饰则可</strong>。于是代码变成：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//基于双重检查锁定的正确单例模式实现</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Singleton</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">volatile</span> Singleton instance=<span class=\"literal\">null</span>;<span class=\"comment\">//加入volatile修饰</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Singleton <span class=\"title function_\">getInstance</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(<span class=\"literal\">null</span>==instance)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">synchronized</span> (Singleton.class)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(<span class=\"literal\">null</span>==instance)&#123;</span><br><span class=\"line\">                    instance = <span class=\"keyword\">new</span> <span class=\"title class_\">Singleton</span>();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>到此为止，才正确实现安全的“单例模式”。</p>\n<p>参考：《黄文海-Java多线程编程实战指南（核心篇）》</p>\n","cover":null,"images":[],"content":"<p>原文回答于知乎(<a href=\"https://www.zhihu.com/question/277243683/answer/392772061\">如何把一段简单的代码变复杂？ - 落叶挽歌的回答</a>)</p>\n<p>我们都知道单例模式很简单，大概是这样：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//单线程单例模式实现</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Singleton</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Singleton instance=<span class=\"literal\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Singleton <span class=\"title function_\">getInstance</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(<span class=\"literal\">null</span>==instance)&#123;</span><br><span class=\"line\">            instance = <span class=\"keyword\">new</span> <span class=\"title class_\">Singleton</span>();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>但是呢，在多线程条件下getInstance()并不是一个原子操作。由于代码没有使用任何同步机制，因此该线程可能会出现线程交错的情形：在instance还是null的时候，如果两个线程同时执行到 if(null&#x3D;&#x3D;instance)那么会创建两个实例，从而违背了初衷。于是通过简单加锁来解决这种问题：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//简单加锁实现单例模式</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Singleton</span>  &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Singleton instance=<span class=\"literal\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Singleton <span class=\"title function_\">getInstance</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span> (Singleton.class)&#123;<span class=\"comment\">//加入synchronized同步</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(<span class=\"literal\">null</span>==instance)&#123;</span><br><span class=\"line\">                instance = <span class=\"keyword\">new</span> <span class=\"title class_\">Singleton</span>();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这种方式实现单例模式固然安全，但意味着每次调用 getInstance()都会申请锁，为了避免开销，我们想到了另一种办法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//基于双重检查锁定的错误单例模式实现</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Singleton</span>  &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Singleton instance=<span class=\"literal\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Singleton <span class=\"title function_\">getInstance</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(<span class=\"literal\">null</span>==instance)&#123;<span class=\"comment\">//先检查是否为null，再执行之上的代码</span></span><br><span class=\"line\">            <span class=\"keyword\">synchronized</span> (Singleton.class)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(<span class=\"literal\">null</span>==instance)&#123;</span><br><span class=\"line\">                    instance = <span class=\"keyword\">new</span> <span class=\"title class_\">Singleton</span>();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>通过这种方法，虽然第一次检查对变量instance的访问没有加锁从而使竞态仍然可能存在，它似乎避免了锁的开销又保障了线程的安全。然后对 instance &#x3D; new Singleton();进行伪代码独立子操作：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">obj=allocate(Singleton.class);<span class=\"comment\">//1、分配对象所需的存储空间</span></span><br><span class=\"line\">invokeConstructor(obj);<span class=\"comment\">//2、初始化obj的引用对象</span></span><br><span class=\"line\">instance=obj;<span class=\"comment\">//3、将对象引用写入共享变量</span></span><br></pre></td></tr></table></figure>\n<p>由于重排序的规则，临界区内的操作可以再临界区内重排序，因此JIT编译器可能将上述子操作重排序为：1-&gt;3-&gt;2，即在初始化对象之前将对象引用写入实例变量instace。由于锁对有序性的保障是有条件的，而操作1读取intance变量的时候并没有加锁，因此重排序是对1操作是有影响的：该线程可能看到一个未初始化（或者为初始化完毕）的实例，即intance不为null。于是该线程直接就直接返回这个instance变量所引用的实例，而实例可能是未初始化完毕的，这就是可能导致程序出错。明白问题的原因之后，解决方法也不难想到了：<strong>只需将instance变量加入volatile修饰则可</strong>。于是代码变成：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//基于双重检查锁定的正确单例模式实现</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Singleton</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">volatile</span> Singleton instance=<span class=\"literal\">null</span>;<span class=\"comment\">//加入volatile修饰</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Singleton <span class=\"title function_\">getInstance</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(<span class=\"literal\">null</span>==instance)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">synchronized</span> (Singleton.class)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(<span class=\"literal\">null</span>==instance)&#123;</span><br><span class=\"line\">                    instance = <span class=\"keyword\">new</span> <span class=\"title class_\">Singleton</span>();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>到此为止，才正确实现安全的“单例模式”。</p>\n<p>参考：《黄文海-Java多线程编程实战指南（核心篇）》</p>\n","categories":[{"name":"技术文章","slug":"technology","api":"api/categories/technology.json"}],"tags":[{"name":"设计模式","slug":"design","api":"api/tags/design.json"}],"api":"api/posts/2019/07/09/单例模式的设计.json"}],"info":{"type":"category","name":"技术文章","slug":"technology"}},"api":"api/categories/technology/page.3.json"}