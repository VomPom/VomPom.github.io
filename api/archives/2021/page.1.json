{"data":{"index":1,"total":1,"posts":[{"title":"Android音视频-初识FFmpeg","slug":"音视频-初识FFmpeg","date":"2021-11-14T01:49:00.000Z","updated":"2025-09-15T13:07:56.100Z","comments":true,"url":"2021/11/14/音视频-初识FFmpeg/","excerpt":"<p>已经很久没有写过技术博客了，这段时间加入了新公司，主要时间花在熟悉新业务的技术上。而新的业务主要跟音视频相关，关于音视频的尝试在加入新公司之前，自己有做相关demo的尝试与学习，可以参看<a href=\"https://github.com/VomPom/JProject/tree/master/app/src/main/java/wang/julis/jproject/example/media\">音视频相关学习demo</a>。当然，那都是自己“想当然”学习的一些东西，虽然实际工作中并没有派上太大的用处，但让我对音视频相关的基础知识有了一定的概念，对后面的技术尝试做了铺垫。第一个技术挑战比较大的就是进行：<strong>视频抽帧</strong>，关于视频抽帧网上有很多很多文章进行讲解，但……我始终没有找到一个效率很高的解决方案。直到我遇见了 ffmpeg，仿佛打开了新世界的大门……</p>\n<h2 id=\"关于FFmpeg\"><a href=\"#关于FFmpeg\" class=\"headerlink\" title=\"关于FFmpeg\"></a>关于FFmpeg</h2><p>刚接触 ffmpeg 时，我一脸懵逼，完全不知道该怎么做，也不知道在哪里开始进行学习，后来在<a href=\"https://blog.csdn.net/leixiaohua1020\">雷霄骅大神的博客</a>中渐渐找到了感觉，膜拜！不过雷神的博客代码是基于老版本的 ffmpeg api，推荐搭配<a href=\"https://github.com/FFmpeg/FFmpeg/tree/master/doc/examples\">官方example</a>，先跑通雷声的博客，再对照官方的例子对进行api相关接口的修改。</p>\n<p>当然，想要使用 ffmpeg编写代码之前，我们首先要做的是对 FFmpeg 进行so库编译，这一步也是难倒了众多的英雄好汉，引用<a href=\"https://juejin.cn/post/6844904039524597773\">FFmpeg so库编译</a>作者的话：</p>\n<blockquote>\n<p>为什么FFmpeg让人觉得很难搞？<br>我想主要是因为迈出第一步就很困难，连so库都编译不出来，后面的都是扯淡了。</p>\n</blockquote>\n<p>参考<a href=\"https://juejin.cn/post/6844904039524597773\">FFmpeg so库编译</a>文章能成功地打包出 ffmpeg.so，接下来就是添加在项目中运行。</p>\n<h2 id=\"踏上-FFmpeg-音视频之路\"><a href=\"#踏上-FFmpeg-音视频之路\" class=\"headerlink\" title=\"踏上 FFmpeg 音视频之路\"></a>踏上 FFmpeg 音视频之路</h2><p>关于音视频等开发，无论是做特效渲染还是做视频播放，那么最重要也是最基本的步骤就是：<strong>音视频解码</strong></p>\n<p>众所周知的是视频是由一帧帧视频帧(图片)/音频帧编码组合而成</p>\n<p>视频解码要做的就是解码出视频文件中的每一帧，我们以:<strong>将视频转化为一帧帧的图片</strong>作为例进行学习。</p>\n<h2 id=\"FFmpeg-提取视频每一帧图像\"><a href=\"#FFmpeg-提取视频每一帧图像\" class=\"headerlink\" title=\"FFmpeg 提取视频每一帧图像\"></a>FFmpeg 提取视频每一帧图像</h2><p>在学习之前，我们思考一个问题：抛开 ffmpeg，如果让你去设计一个提取的代码，n你会怎么设计？</p>\n<p>因为视频是以文件流的形式存在，我相信很多人一上来就能想到这样的结构：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">while</span> (!EOF) &#123; <span class=\"comment\">//当文件流没有结束</span></span><br><span class=\"line\">    <span class=\"type\">Stream</span> <span class=\"variable\">stream</span> <span class=\"operator\">=</span> getStream(); <span class=\"comment\">//获取一定区域的stream</span></span><br><span class=\"line\">    <span class=\"type\">Frame</span> <span class=\"variable\">steam</span> <span class=\"operator\">=</span> getFrame(stream); <span class=\"comment\">//Stream转化为视频帧</span></span><br><span class=\"line\">    <span class=\"type\">Picture</span> <span class=\"variable\">picture</span> <span class=\"operator\">=</span> decodeFrame(steam); <span class=\"comment\">//将视频帧转化为 .jpeg等格式图片</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>的确是这样的，这里是给出一份ffmpeg提取视频帧图片的核心逻辑：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\">AVFrame frame = av_frame_alloc(); </span><br><span class=\"line\"><span class=\"keyword\">while</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (av_read_frame(fmt_ctx, &amp;avpkt) &gt;= <span class=\"number\">0</span>) &#123; <span class=\"comment\">// Return the next frame of a stream.</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (avpkt.stream_index == video_stream_index) &#123; <span class=\"comment\">//标识该AVPacket所属的视频/音频流。</span></span><br><span class=\"line\">            avcodec_send_packet(codeCtx, &amp;avpkt); <span class=\"comment\">//Supply raw packet data as input to a decoder.</span></span><br><span class=\"line\">            <span class=\"keyword\">while</span> (avcodec_receive_frame(codeCtx, frame) == <span class=\"number\">0</span>) &#123; <span class=\"comment\">//Return decoded output data from a decoder.</span></span><br><span class=\"line\">                <span class=\"built_in\">snprintf</span>(buf, <span class=\"keyword\">sizeof</span>(buf), <span class=\"string\">&quot;%s/frame-%d.jpg&quot;</span>, out_filename, frame_count);</span><br><span class=\"line\">                saveJpg(frame, buf);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            frame_count++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        av_packet_unref(&amp;avpkt);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        LOGE(<span class=\"string\">&quot;//Exit&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面的代码块就是 ffmpeg 进行视频解码最核心的逻辑了，主要的注释也贴在了代码上，完整代码请查看<a href=\"https://github.com/VomPom/FFmpegLearn/blob/main/app/src/main/cpp/func/video_to_jpeg.cpp\">video_to_jpeg.cpp</a>，查看完整的代码后，会感觉到很惊讶：为什么这么复杂？特别是前面的初始化操作。放心，ffmpeg就像一套组合拳，有固定不变的套路，写一次就足够了，了解了其中的流程，之后理解起来就会很容易了。</p>\n<p>上面的代码我们还可以做一些其他处理，比如只获取关键帧、查找指定时间戳位置的帧、视频按2s一帧进行抽取、视频不保存为jpeg文件转化为Java的bitmap？</p>\n<p>这些实现需求也都是基于上述核心模块进行修改：</p>\n<p>如果<strong>想只获取关键帧</strong>，可以利用<code>AVFrame</code>对象的属性<code>AVFrame-&gt;key_frame</code>进行判断。</p>\n<p><strong>查找指定时间戳位置的帧</strong>：利用 <code>av_seek_frame</code>查找到指定帧时间最近的关键帧，然后依次进行编码，直到<code>pts</code>与目标时间相近</p>\n<p><strong>视频按2s一帧进行抽取</strong>：简单的操作可以去获取视频fps，比如视频25fps，可以使用一个计数器判断<code>if(frame_count%25==0)</code>,这时候则是刚好1s。当然这样子性能不太好。如果需要追求性能，那么也可以利用<code>av_seek_frame</code>，查找目标时间附近，然后循环进行解码直到目标时间。</p>\n<p><strong>视频不保存为jpeg文件转化为Java的Bitmap</strong>：只需要对最终获取的 <code>AVFrame</code>做不一样的操作进行了，获取到对应的buffer，再利用jni调用构造 Java 的 bitmap 对象。</p>\n<p>可以做的还有很多……</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>提取视频图片这个功能只是 FFmpeg 强大功能的九牛一毛，需要探究的还有很多很多……</p>\n<p>如果能跑起来 FFmpeg 最简单的例子，已经迈出了很大一步了，但如果要理解其中的原理，还需要更多的基础知识，以及像<code>AVPacket</code>、<code>AVFrame</code>、 <code>AVCodec</code> ……每一个类的数据结构，以及实现都需要仔细研究。</p>\n<p>自己在网上找到的 FFmpeg 相关的教程，以及自己想要去实现的功能的资源太少，很多东西都需要自己去摸索。有时候我总在怀疑：<strong>为什么这么基础且很实用的功能没有现成的轮子？</strong> 这可能也是现在音视频相关开发的现状吧，成熟可用的轮子相对而言较少，以及相关技术的分享可能不太好做。既然没有，那就靠自己一点点积累吧。</p>\n<p>学习之路，任重而道远呐。</p>\n","cover":null,"images":[],"content":"<p>已经很久没有写过技术博客了，这段时间加入了新公司，主要时间花在熟悉新业务的技术上。而新的业务主要跟音视频相关，关于音视频的尝试在加入新公司之前，自己有做相关demo的尝试与学习，可以参看<a href=\"https://github.com/VomPom/JProject/tree/master/app/src/main/java/wang/julis/jproject/example/media\">音视频相关学习demo</a>。当然，那都是自己“想当然”学习的一些东西，虽然实际工作中并没有派上太大的用处，但让我对音视频相关的基础知识有了一定的概念，对后面的技术尝试做了铺垫。第一个技术挑战比较大的就是进行：<strong>视频抽帧</strong>，关于视频抽帧网上有很多很多文章进行讲解，但……我始终没有找到一个效率很高的解决方案。直到我遇见了 ffmpeg，仿佛打开了新世界的大门……</p>\n<h2 id=\"关于FFmpeg\"><a href=\"#关于FFmpeg\" class=\"headerlink\" title=\"关于FFmpeg\"></a>关于FFmpeg</h2><p>刚接触 ffmpeg 时，我一脸懵逼，完全不知道该怎么做，也不知道在哪里开始进行学习，后来在<a href=\"https://blog.csdn.net/leixiaohua1020\">雷霄骅大神的博客</a>中渐渐找到了感觉，膜拜！不过雷神的博客代码是基于老版本的 ffmpeg api，推荐搭配<a href=\"https://github.com/FFmpeg/FFmpeg/tree/master/doc/examples\">官方example</a>，先跑通雷声的博客，再对照官方的例子对进行api相关接口的修改。</p>\n<p>当然，想要使用 ffmpeg编写代码之前，我们首先要做的是对 FFmpeg 进行so库编译，这一步也是难倒了众多的英雄好汉，引用<a href=\"https://juejin.cn/post/6844904039524597773\">FFmpeg so库编译</a>作者的话：</p>\n<blockquote>\n<p>为什么FFmpeg让人觉得很难搞？<br>我想主要是因为迈出第一步就很困难，连so库都编译不出来，后面的都是扯淡了。</p>\n</blockquote>\n<p>参考<a href=\"https://juejin.cn/post/6844904039524597773\">FFmpeg so库编译</a>文章能成功地打包出 ffmpeg.so，接下来就是添加在项目中运行。</p>\n<h2 id=\"踏上-FFmpeg-音视频之路\"><a href=\"#踏上-FFmpeg-音视频之路\" class=\"headerlink\" title=\"踏上 FFmpeg 音视频之路\"></a>踏上 FFmpeg 音视频之路</h2><p>关于音视频等开发，无论是做特效渲染还是做视频播放，那么最重要也是最基本的步骤就是：<strong>音视频解码</strong></p>\n<p>众所周知的是视频是由一帧帧视频帧(图片)/音频帧编码组合而成</p>\n<p>视频解码要做的就是解码出视频文件中的每一帧，我们以:<strong>将视频转化为一帧帧的图片</strong>作为例进行学习。</p>\n<h2 id=\"FFmpeg-提取视频每一帧图像\"><a href=\"#FFmpeg-提取视频每一帧图像\" class=\"headerlink\" title=\"FFmpeg 提取视频每一帧图像\"></a>FFmpeg 提取视频每一帧图像</h2><p>在学习之前，我们思考一个问题：抛开 ffmpeg，如果让你去设计一个提取的代码，n你会怎么设计？</p>\n<p>因为视频是以文件流的形式存在，我相信很多人一上来就能想到这样的结构：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">while</span> (!EOF) &#123; <span class=\"comment\">//当文件流没有结束</span></span><br><span class=\"line\">    <span class=\"type\">Stream</span> <span class=\"variable\">stream</span> <span class=\"operator\">=</span> getStream(); <span class=\"comment\">//获取一定区域的stream</span></span><br><span class=\"line\">    <span class=\"type\">Frame</span> <span class=\"variable\">steam</span> <span class=\"operator\">=</span> getFrame(stream); <span class=\"comment\">//Stream转化为视频帧</span></span><br><span class=\"line\">    <span class=\"type\">Picture</span> <span class=\"variable\">picture</span> <span class=\"operator\">=</span> decodeFrame(steam); <span class=\"comment\">//将视频帧转化为 .jpeg等格式图片</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>的确是这样的，这里是给出一份ffmpeg提取视频帧图片的核心逻辑：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\">AVFrame frame = av_frame_alloc(); </span><br><span class=\"line\"><span class=\"keyword\">while</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (av_read_frame(fmt_ctx, &amp;avpkt) &gt;= <span class=\"number\">0</span>) &#123; <span class=\"comment\">// Return the next frame of a stream.</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (avpkt.stream_index == video_stream_index) &#123; <span class=\"comment\">//标识该AVPacket所属的视频/音频流。</span></span><br><span class=\"line\">            avcodec_send_packet(codeCtx, &amp;avpkt); <span class=\"comment\">//Supply raw packet data as input to a decoder.</span></span><br><span class=\"line\">            <span class=\"keyword\">while</span> (avcodec_receive_frame(codeCtx, frame) == <span class=\"number\">0</span>) &#123; <span class=\"comment\">//Return decoded output data from a decoder.</span></span><br><span class=\"line\">                <span class=\"built_in\">snprintf</span>(buf, <span class=\"keyword\">sizeof</span>(buf), <span class=\"string\">&quot;%s/frame-%d.jpg&quot;</span>, out_filename, frame_count);</span><br><span class=\"line\">                saveJpg(frame, buf);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            frame_count++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        av_packet_unref(&amp;avpkt);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        LOGE(<span class=\"string\">&quot;//Exit&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面的代码块就是 ffmpeg 进行视频解码最核心的逻辑了，主要的注释也贴在了代码上，完整代码请查看<a href=\"https://github.com/VomPom/FFmpegLearn/blob/main/app/src/main/cpp/func/video_to_jpeg.cpp\">video_to_jpeg.cpp</a>，查看完整的代码后，会感觉到很惊讶：为什么这么复杂？特别是前面的初始化操作。放心，ffmpeg就像一套组合拳，有固定不变的套路，写一次就足够了，了解了其中的流程，之后理解起来就会很容易了。</p>\n<p>上面的代码我们还可以做一些其他处理，比如只获取关键帧、查找指定时间戳位置的帧、视频按2s一帧进行抽取、视频不保存为jpeg文件转化为Java的bitmap？</p>\n<p>这些实现需求也都是基于上述核心模块进行修改：</p>\n<p>如果<strong>想只获取关键帧</strong>，可以利用<code>AVFrame</code>对象的属性<code>AVFrame-&gt;key_frame</code>进行判断。</p>\n<p><strong>查找指定时间戳位置的帧</strong>：利用 <code>av_seek_frame</code>查找到指定帧时间最近的关键帧，然后依次进行编码，直到<code>pts</code>与目标时间相近</p>\n<p><strong>视频按2s一帧进行抽取</strong>：简单的操作可以去获取视频fps，比如视频25fps，可以使用一个计数器判断<code>if(frame_count%25==0)</code>,这时候则是刚好1s。当然这样子性能不太好。如果需要追求性能，那么也可以利用<code>av_seek_frame</code>，查找目标时间附近，然后循环进行解码直到目标时间。</p>\n<p><strong>视频不保存为jpeg文件转化为Java的Bitmap</strong>：只需要对最终获取的 <code>AVFrame</code>做不一样的操作进行了，获取到对应的buffer，再利用jni调用构造 Java 的 bitmap 对象。</p>\n<p>可以做的还有很多……</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>提取视频图片这个功能只是 FFmpeg 强大功能的九牛一毛，需要探究的还有很多很多……</p>\n<p>如果能跑起来 FFmpeg 最简单的例子，已经迈出了很大一步了，但如果要理解其中的原理，还需要更多的基础知识，以及像<code>AVPacket</code>、<code>AVFrame</code>、 <code>AVCodec</code> ……每一个类的数据结构，以及实现都需要仔细研究。</p>\n<p>自己在网上找到的 FFmpeg 相关的教程，以及自己想要去实现的功能的资源太少，很多东西都需要自己去摸索。有时候我总在怀疑：<strong>为什么这么基础且很实用的功能没有现成的轮子？</strong> 这可能也是现在音视频相关开发的现状吧，成熟可用的轮子相对而言较少，以及相关技术的分享可能不太好做。既然没有，那就靠自己一点点积累吧。</p>\n<p>学习之路，任重而道远呐。</p>\n","categories":[{"name":"技术文章","slug":"technology","api":"api/categories/technology.json"}],"tags":[{"name":"FFmpeg","slug":"FFmpeg","api":"api/tags/FFmpeg.json"},{"name":"音视频","slug":"音视频","api":"api/tags/音视频.json"}],"api":"api/posts/2021/11/14/音视频-初识FFmpeg.json"},{"title":"记一段 Android 面试时光","slug":"记一段-Android-面试时光","date":"2021-07-06T14:56:00.000Z","updated":"2025-05-20T11:46:57.000Z","comments":true,"url":"2021/07/06/记一段-Android-面试时光/","excerpt":"<p>今晚已到下班时间，我又如往常一样，背着自己的包来到了楼下的会议室。不过与前些天的日子不太一样，今天我已经放下了诸多包袱，剩下的是一个轻松的自己，历经一个月的面试时光，终于可以在这会议室惬然地写下一些东西。</p>\n<p>准备面试以及参加面试都是一个高度紧张的过程，为了面试，我放弃了一些时间，也让自己每天变得很疲惫，因而有更少的精力去干一些其他事情。在六月，我还未完成一本书的阅读，时间忙碌所占去，或者那个疲惫的身体没有能静得下心来阅读一本书籍，我好希望能够有一个轻轻松松的时间，能够做自己想做的事\b。但在诸多现实面前，不得不低下头吧，好在现在收获的Offer也能对得起自己的付出，遂想记录一下这一个月来自己的面试经历。</p>\n<p>在五月初便有想跳槽的想法，原因也很简单：现在的日子太舒服，想找到一个更大的平台来提升自己。在五月下旬开始行动了起来，自己当然有想要去的厂，也通过一些相关的流程约到了面试的时间。那么接下来就是准备吧，准备的过程包括：<strong>算法(视公司而定)、基础知识(常见面试问题等)、项目(项目本身以及相关的深度知识)</strong>。当然还包括了面试经验，在面之前需要找一些中型公司来锻炼锻炼自己的表达能力，以及对问到的一些知识盲区进行一些补缺，于是面试之路开始了。</p>\n<p>记得第一家面的某快递公司，很久没有面试过了，发现面试的感觉还是有点差，被问了一些 Android 相关的基础知识，我知道那件事，但是我回忆不起来了，也讲不太出来了。理所应当挂了，不过无所谓吧，问题不大，回去之后把他问了的一些基础点再准备了看看。</p>\n<p>大概也就是第二天吧，是某买菜公司的面试，这次面试让我哭笑不得。我也本着找面经的态度来面试的，我希望他能多问点有深度的知识，然后我能知道我该去准备些什么。结果他一直不停地问我所做的项目，全程没有技术问题。大概问了我20分钟项目经历，他说：我问完了，你有什么要问的么？我一脸懵逼？？？？我（你特么）都不问点技术问题？他：我……感觉你好强啊（还有点支支吾吾的感觉）……不太敢问，怕暴露了……  不过登了很久也没有见他们约二面（难道是怕我太强了？？哈哈哈😂）。</p>\n<p>第三次面试是杭州某中厂，在经过两次面试的时间之后，我觉得我的基础知识准备还行，这一次的面试，全程问得还是比较轻松，技术深度也不是特别大，很轻松的过去了。后面相互交流时间，我问了一些他们在做什么东西，面试官倒是很热情地给我讲了一大堆，但我并不是很感兴趣，出于礼貌，还是耐心地听了下去。他问我现在的工资是怎样，我如实回答后他说：我们可能还要低些。后面又讲了他们的业务(企图用爱来发电)，不过我依然没有表现出多大的兴趣，后面也没有再约面试了吧。</p>\n<p>第四次面试我投了某能便宜买东西电商公司，这个公司算是我拿到的第一个Offer的公司，记得清楚是5.30号，因为当天下午面完，赶去苏州看国足世界杯预选赛的比赛了。一面的小哥还是很nice的，问的问题比较有深度，答得还行吧，在后面跟我讨论了起来 Flutter 的发展，聊得还是比较惬意，最后又是一道算法题（记不太清是什么题了，应该是easy难度），然后约我去现场进行下一面，也就是5.30号。去现场跟HR聊了好一会儿，才来一个看着很资深的大佬，问了我一些也不算事太难的问题，甚至感觉他没有仔细看我简历，一直看我简历，看一会儿问一会儿，最后又是一道算法题：求两个View的最近公共View，叫我直接在纸上写，那桌子太低，弯着个腰，写着太难受了，那字也写得跟个啥一样，不过他还是看懂了，后面也没有问个啥，然后就直接HRBP面了，问我期望工资，我说了一个期望，她当然会砍价，因为这时候没有其他 Offer ，她给我给得很低，然后 pua 我了一下，说什么你前两年浪费了呀，你要来的话，得赶紧过来之类的……然后没过几天就让我提交工资流水了。</p>\n<p>在后面是某手机大厂，这个厂流程也真的是一个之复杂。简历通过后，一上来就有个在线笔试，三道算法题，三个小时，三个题我应该都做出来了，难度中等吧，不过他的测试用例不知道怎么设计的，我的测试用例通过率每道题都没有超过百分之五十，可是我实在是找不到可以再加的逻辑了，忐忑的心情提交了上去。结果第二天跟我说通过了，刚好过。然后又给我发了一份职业问卷测评的链接，好嘛，点开一个看，woc 几百道题……也真的是做着累，问题也就是一些不痛不痒的问题。在做做之前，HR有给我发一份“高分教程”，大概总结一下就是你得选一些符合他们公司价值观的选项，总体的感觉就是：他们喜欢加班的人、能吃苦耐劳不计较报酬、不能有自己的个性……行吧……有的选项真的有点打击我三观，不过我还是坚持地做完了。</p>\n<p>第二天HR跟我说通过了，不过“XX值”有点偏高，到时候可能需要跟leader解释一下，我…… 然后到了第一面技术面，一上来又是一道算法题，还行吧，这道理大概完成了，后面去leetcode上面看了一下，也是个medium。不过面试官是真的很强的感觉，把我问得不要不要的，对于系统底层的问题问了很多，我甚至很佩服该厂的技术人员，怎么可以这么强？中间我有好几个问题没有答上来，但是大佬还是很耐心的给我讲解了一下，这次面试的收获也是蛮大的。</p>\n<p>后来居然先是HR面试，很神奇哟。不过这次HR面试让我很不爽很不爽，体验极差。跟HR聊着，真的是“痛不欲生”，她搁这里戴个有线耳机，只挂了一个在耳朵上（记不太清了，应该是挂的没有话筒的那一边）导致交流起来我能听到她的声音很不清楚，我得很仔细听她讲话。然而反过来呢？我在讲话的时候，她一边玩着自己的手指甲，中间时不时还有几个哈欠出来……后面聊到薪资一块，问了我期望薪资，我说了一个数（在我现在拿到了其他公司的offer之后，再看的话，真的算是一个比较低的数字了），她跟我说：你去看其他厂，除了某厂，其他不可能给你这么多的（现在看就呵呵了），然后还特别的高傲的把我pua了一顿……总之体验不太好。又过了一段时间跟我说要二轮技术面，我拒绝了。</p>\n<p>第二个Offer是曾经的XYZ的X，一面技术面居然是个姐姐，问的问题还算可以，不难，但是有一些个“坑”，我跳进去过几次，给我贴了好几段代码，让我找哪里有问题，不得不说这一波面试让我学到了很多知识点，让我对 Android 的 HandlerThread 有了更多了解。二面去的现场，去现场我还是挺感慨，这么大一块园区都是他们公司的，整个logo放大楼前面，真的是气派！在前台等了一会儿有面试官下来接待，天呐！又是一个姐姐！娘子军大作战？单独找了个会议室，跟这个面试官聊起来，感觉压力还是蛮大的，各种问我“架构设计”方面的事儿，让我画项目架构图在黑板上之类的。以及被诸多的技术灵魂拷问，总体聊了一个半小时，压力还是蛮大。后来是要他们主管过来面，我看这主管样子就是大佬样，应该有四十多岁了，有一种职场气质的技术主管。问我也是一些通用型的问题，架构、思维、方法论等，压力更多来自于他给我一种资历压迫感（我感觉我说的东西都太幼稚在他看来），因为我跟他说了我等会儿要赶飞机，所以跟他只聊了半个小时，后面的HR面也只聊了十几分钟，我就匆匆跑路了，然后第二周叫提交薪资流水。</p>\n<p>前面的面试还算是比较顺利，没有怎么失败过，我以为我能以“全胜出线”，结果现实并不是这样。再后来面了某视频网站和XYZ的Y。这两次失败是连在一起的，Y已经是最后一面的技术面，大佬面，应该问题不大了，可是，意外总是会出现。事情是这样子的，当天晚上七点约了视频网站的二面，八点是Y公司的最后一轮技术面了（只要没有什么幺蛾子事情发生，后续应该就是HR了）。当时前者公司正视频面试着，又是个女面试官，全程问了我一些问题莫名奇妙，我一开始还以为她是HR，问了我好几个非技术问题，以及一些有的得没得问题（比如：我们为什么招你？害～ 你能为我们带来什么？害～），但在七点四十多的时候收到了Y公司的电话，想立马面试，我跟他解释现在有事，并推迟到了八点之后。结果就是因为这一推，给大佬造成了不好的影响……据后来内推的同事说，很大的一部分原因就是这个。然后在面试过程中还接电话，结果两边都没有个好结果，害～ 这事儿整得，让我明白了：<strong>面试时间安排太紧凑比较危险。</strong></p>\n<p>最后拿到的两个offer，也是我最终纠结选择取哪里的offer，两个公司都比较好吧。一个在上海，一个在杭州，原本想拒绝上海这个公司的，因为杭州的公司有我诸多前同事，以及杭州相比上海而言有更好的生活舒适度，所以选择了杭州的公司，但是拒绝真的很难。上海的公司算事行业的佼佼者了，为了能更好的拒绝，我甚至写了一份“千字长文拒绝信”给对应HR，来表达我不能去其公司歉意（那内容我作为旁观者，看着都要给感动哭了），但HR也并没有回我什么（可能是见惯了这种场景），没过多久我收到了其公司的同事的关怀，但我还是对他表示拒绝的想法。又过了不久，我收到电话，貌似是之前去公司面试的时候，“我的直属leader”打过来的，向我阐述了大平台的重要，以及杭州公司的业务发展没有这边好。后来又被拉群，加入到了含有部门总监的群，他加了我微信，表示晚上要跟我谈一谈，并附言几句，大概意思翻译就是：你去杭州的不是一个明智之举，来我们这里才是最正确的选择。一下午就因为这些事“舌战群儒”，不过我很强烈地感受到了他们对人才的追求和肯定，让我感觉到：我何德何能？能让这么多陌生的人来劝我回去，让我很感动， 这或许就是大公司每个人都以人才来看待吧。</p>\n<p>此时我开始陷入了更深的纠结与迷茫：到底该怎么选？对于上海的公司体量是N个杭州公司那么大的，工作室是在做一些比较前沿的东西(视频特效渲染、移动端深度学习、音视频合成等)，很多东西我都没有接触过，要重新开始学习，会比较肝。对于杭州公司，在那里有我诸多的前同事，包括 leader 都是我之前公司的，公司位于滨江河畔，离钱塘江也不远，钱塘夜景让我久久不能忘怀。加之杭州的物价与房价都低于上海，不得不说杭州更适合生活。但做的东西比较与业务相关，需要与产品-测试等相关人员对接，相对而言所接触到的知识点没有上海这边深入。所以，我是否要去选择在上海再拼一拼呢？有那么些纠结，到底要选择相对轻松舒适的杭州，还是更有拼搏感的上海公司？最终吧，还是选择了上海，最近在读<strong>《草莓人生》</strong>，有一句话让我又更坚定了这个选择：<strong>“其实没有一种工作是轻松的，正因为不轻松，所以才叫工作啊”</strong>，学吧，学吧，肝吧肝吧，在上海再干几年，祝我有朝一日成大佬😂<br>昨日，已点击“接受本Offer”<br>至此，结束一段面试时光。</p>\n","cover":null,"images":[],"content":"<p>今晚已到下班时间，我又如往常一样，背着自己的包来到了楼下的会议室。不过与前些天的日子不太一样，今天我已经放下了诸多包袱，剩下的是一个轻松的自己，历经一个月的面试时光，终于可以在这会议室惬然地写下一些东西。</p>\n<p>准备面试以及参加面试都是一个高度紧张的过程，为了面试，我放弃了一些时间，也让自己每天变得很疲惫，因而有更少的精力去干一些其他事情。在六月，我还未完成一本书的阅读，时间忙碌所占去，或者那个疲惫的身体没有能静得下心来阅读一本书籍，我好希望能够有一个轻轻松松的时间，能够做自己想做的事\b。但在诸多现实面前，不得不低下头吧，好在现在收获的Offer也能对得起自己的付出，遂想记录一下这一个月来自己的面试经历。</p>\n<p>在五月初便有想跳槽的想法，原因也很简单：现在的日子太舒服，想找到一个更大的平台来提升自己。在五月下旬开始行动了起来，自己当然有想要去的厂，也通过一些相关的流程约到了面试的时间。那么接下来就是准备吧，准备的过程包括：<strong>算法(视公司而定)、基础知识(常见面试问题等)、项目(项目本身以及相关的深度知识)</strong>。当然还包括了面试经验，在面之前需要找一些中型公司来锻炼锻炼自己的表达能力，以及对问到的一些知识盲区进行一些补缺，于是面试之路开始了。</p>\n<p>记得第一家面的某快递公司，很久没有面试过了，发现面试的感觉还是有点差，被问了一些 Android 相关的基础知识，我知道那件事，但是我回忆不起来了，也讲不太出来了。理所应当挂了，不过无所谓吧，问题不大，回去之后把他问了的一些基础点再准备了看看。</p>\n<p>大概也就是第二天吧，是某买菜公司的面试，这次面试让我哭笑不得。我也本着找面经的态度来面试的，我希望他能多问点有深度的知识，然后我能知道我该去准备些什么。结果他一直不停地问我所做的项目，全程没有技术问题。大概问了我20分钟项目经历，他说：我问完了，你有什么要问的么？我一脸懵逼？？？？我（你特么）都不问点技术问题？他：我……感觉你好强啊（还有点支支吾吾的感觉）……不太敢问，怕暴露了……  不过登了很久也没有见他们约二面（难道是怕我太强了？？哈哈哈😂）。</p>\n<p>第三次面试是杭州某中厂，在经过两次面试的时间之后，我觉得我的基础知识准备还行，这一次的面试，全程问得还是比较轻松，技术深度也不是特别大，很轻松的过去了。后面相互交流时间，我问了一些他们在做什么东西，面试官倒是很热情地给我讲了一大堆，但我并不是很感兴趣，出于礼貌，还是耐心地听了下去。他问我现在的工资是怎样，我如实回答后他说：我们可能还要低些。后面又讲了他们的业务(企图用爱来发电)，不过我依然没有表现出多大的兴趣，后面也没有再约面试了吧。</p>\n<p>第四次面试我投了某能便宜买东西电商公司，这个公司算是我拿到的第一个Offer的公司，记得清楚是5.30号，因为当天下午面完，赶去苏州看国足世界杯预选赛的比赛了。一面的小哥还是很nice的，问的问题比较有深度，答得还行吧，在后面跟我讨论了起来 Flutter 的发展，聊得还是比较惬意，最后又是一道算法题（记不太清是什么题了，应该是easy难度），然后约我去现场进行下一面，也就是5.30号。去现场跟HR聊了好一会儿，才来一个看着很资深的大佬，问了我一些也不算事太难的问题，甚至感觉他没有仔细看我简历，一直看我简历，看一会儿问一会儿，最后又是一道算法题：求两个View的最近公共View，叫我直接在纸上写，那桌子太低，弯着个腰，写着太难受了，那字也写得跟个啥一样，不过他还是看懂了，后面也没有问个啥，然后就直接HRBP面了，问我期望工资，我说了一个期望，她当然会砍价，因为这时候没有其他 Offer ，她给我给得很低，然后 pua 我了一下，说什么你前两年浪费了呀，你要来的话，得赶紧过来之类的……然后没过几天就让我提交工资流水了。</p>\n<p>在后面是某手机大厂，这个厂流程也真的是一个之复杂。简历通过后，一上来就有个在线笔试，三道算法题，三个小时，三个题我应该都做出来了，难度中等吧，不过他的测试用例不知道怎么设计的，我的测试用例通过率每道题都没有超过百分之五十，可是我实在是找不到可以再加的逻辑了，忐忑的心情提交了上去。结果第二天跟我说通过了，刚好过。然后又给我发了一份职业问卷测评的链接，好嘛，点开一个看，woc 几百道题……也真的是做着累，问题也就是一些不痛不痒的问题。在做做之前，HR有给我发一份“高分教程”，大概总结一下就是你得选一些符合他们公司价值观的选项，总体的感觉就是：他们喜欢加班的人、能吃苦耐劳不计较报酬、不能有自己的个性……行吧……有的选项真的有点打击我三观，不过我还是坚持地做完了。</p>\n<p>第二天HR跟我说通过了，不过“XX值”有点偏高，到时候可能需要跟leader解释一下，我…… 然后到了第一面技术面，一上来又是一道算法题，还行吧，这道理大概完成了，后面去leetcode上面看了一下，也是个medium。不过面试官是真的很强的感觉，把我问得不要不要的，对于系统底层的问题问了很多，我甚至很佩服该厂的技术人员，怎么可以这么强？中间我有好几个问题没有答上来，但是大佬还是很耐心的给我讲解了一下，这次面试的收获也是蛮大的。</p>\n<p>后来居然先是HR面试，很神奇哟。不过这次HR面试让我很不爽很不爽，体验极差。跟HR聊着，真的是“痛不欲生”，她搁这里戴个有线耳机，只挂了一个在耳朵上（记不太清了，应该是挂的没有话筒的那一边）导致交流起来我能听到她的声音很不清楚，我得很仔细听她讲话。然而反过来呢？我在讲话的时候，她一边玩着自己的手指甲，中间时不时还有几个哈欠出来……后面聊到薪资一块，问了我期望薪资，我说了一个数（在我现在拿到了其他公司的offer之后，再看的话，真的算是一个比较低的数字了），她跟我说：你去看其他厂，除了某厂，其他不可能给你这么多的（现在看就呵呵了），然后还特别的高傲的把我pua了一顿……总之体验不太好。又过了一段时间跟我说要二轮技术面，我拒绝了。</p>\n<p>第二个Offer是曾经的XYZ的X，一面技术面居然是个姐姐，问的问题还算可以，不难，但是有一些个“坑”，我跳进去过几次，给我贴了好几段代码，让我找哪里有问题，不得不说这一波面试让我学到了很多知识点，让我对 Android 的 HandlerThread 有了更多了解。二面去的现场，去现场我还是挺感慨，这么大一块园区都是他们公司的，整个logo放大楼前面，真的是气派！在前台等了一会儿有面试官下来接待，天呐！又是一个姐姐！娘子军大作战？单独找了个会议室，跟这个面试官聊起来，感觉压力还是蛮大的，各种问我“架构设计”方面的事儿，让我画项目架构图在黑板上之类的。以及被诸多的技术灵魂拷问，总体聊了一个半小时，压力还是蛮大。后来是要他们主管过来面，我看这主管样子就是大佬样，应该有四十多岁了，有一种职场气质的技术主管。问我也是一些通用型的问题，架构、思维、方法论等，压力更多来自于他给我一种资历压迫感（我感觉我说的东西都太幼稚在他看来），因为我跟他说了我等会儿要赶飞机，所以跟他只聊了半个小时，后面的HR面也只聊了十几分钟，我就匆匆跑路了，然后第二周叫提交薪资流水。</p>\n<p>前面的面试还算是比较顺利，没有怎么失败过，我以为我能以“全胜出线”，结果现实并不是这样。再后来面了某视频网站和XYZ的Y。这两次失败是连在一起的，Y已经是最后一面的技术面，大佬面，应该问题不大了，可是，意外总是会出现。事情是这样子的，当天晚上七点约了视频网站的二面，八点是Y公司的最后一轮技术面了（只要没有什么幺蛾子事情发生，后续应该就是HR了）。当时前者公司正视频面试着，又是个女面试官，全程问了我一些问题莫名奇妙，我一开始还以为她是HR，问了我好几个非技术问题，以及一些有的得没得问题（比如：我们为什么招你？害～ 你能为我们带来什么？害～），但在七点四十多的时候收到了Y公司的电话，想立马面试，我跟他解释现在有事，并推迟到了八点之后。结果就是因为这一推，给大佬造成了不好的影响……据后来内推的同事说，很大的一部分原因就是这个。然后在面试过程中还接电话，结果两边都没有个好结果，害～ 这事儿整得，让我明白了：<strong>面试时间安排太紧凑比较危险。</strong></p>\n<p>最后拿到的两个offer，也是我最终纠结选择取哪里的offer，两个公司都比较好吧。一个在上海，一个在杭州，原本想拒绝上海这个公司的，因为杭州的公司有我诸多前同事，以及杭州相比上海而言有更好的生活舒适度，所以选择了杭州的公司，但是拒绝真的很难。上海的公司算事行业的佼佼者了，为了能更好的拒绝，我甚至写了一份“千字长文拒绝信”给对应HR，来表达我不能去其公司歉意（那内容我作为旁观者，看着都要给感动哭了），但HR也并没有回我什么（可能是见惯了这种场景），没过多久我收到了其公司的同事的关怀，但我还是对他表示拒绝的想法。又过了不久，我收到电话，貌似是之前去公司面试的时候，“我的直属leader”打过来的，向我阐述了大平台的重要，以及杭州公司的业务发展没有这边好。后来又被拉群，加入到了含有部门总监的群，他加了我微信，表示晚上要跟我谈一谈，并附言几句，大概意思翻译就是：你去杭州的不是一个明智之举，来我们这里才是最正确的选择。一下午就因为这些事“舌战群儒”，不过我很强烈地感受到了他们对人才的追求和肯定，让我感觉到：我何德何能？能让这么多陌生的人来劝我回去，让我很感动， 这或许就是大公司每个人都以人才来看待吧。</p>\n<p>此时我开始陷入了更深的纠结与迷茫：到底该怎么选？对于上海的公司体量是N个杭州公司那么大的，工作室是在做一些比较前沿的东西(视频特效渲染、移动端深度学习、音视频合成等)，很多东西我都没有接触过，要重新开始学习，会比较肝。对于杭州公司，在那里有我诸多的前同事，包括 leader 都是我之前公司的，公司位于滨江河畔，离钱塘江也不远，钱塘夜景让我久久不能忘怀。加之杭州的物价与房价都低于上海，不得不说杭州更适合生活。但做的东西比较与业务相关，需要与产品-测试等相关人员对接，相对而言所接触到的知识点没有上海这边深入。所以，我是否要去选择在上海再拼一拼呢？有那么些纠结，到底要选择相对轻松舒适的杭州，还是更有拼搏感的上海公司？最终吧，还是选择了上海，最近在读<strong>《草莓人生》</strong>，有一句话让我又更坚定了这个选择：<strong>“其实没有一种工作是轻松的，正因为不轻松，所以才叫工作啊”</strong>，学吧，学吧，肝吧肝吧，在上海再干几年，祝我有朝一日成大佬😂<br>昨日，已点击“接受本Offer”<br>至此，结束一段面试时光。</p>\n","categories":[{"name":"思考总结","slug":"thinking","api":"api/categories/thinking.json"}],"tags":[{"name":"面试","slug":"面试","api":"api/tags/面试.json"}],"api":"api/posts/2021/07/06/记一段-Android-面试时光.json"},{"title":"逆向相关经验总结","slug":"逆向相关经验总结","date":"2021-07-06T06:47:00.000Z","updated":"2025-12-22T03:23:22.456Z","comments":true,"url":"2021/07/06/逆向相关经验总结/","excerpt":"<p>在离开 YW 之前很长的一段时间都在做逆向相关，从最初只需要反编译 .apk 文件就能“摸清”应用内部相关逻辑，到后来需要对App文件进行脱壳，到需要动态调试。花了很大的精力，这中间也走了很多弯路。在换了工作之后，不知还会不会再有接触逆向相关的开发，但过去的探索也是我技术的宝贵经验吧，遂将此前的学习的一些经验进行整理。</p>\n<h2 id=\"逆向相关原理与流程参考资料\"><a href=\"#逆向相关原理与流程参考资料\" class=\"headerlink\" title=\"逆向相关原理与流程参考资料\"></a>逆向相关原理与流程参考资料</h2><p><a href=\"https://www.jianshu.com/p/d22f52a6a6fb\">安卓打包流程</a></p>\n<p><a href=\"https://julis.wang/2021/05/14/Android-%E9%80%86%E5%90%91-%E5%8F%8D%E7%BC%96%E8%AF%91/\">反编译流程</a></p>\n<p><a href=\"https://www.jianshu.com/p/4ff48b761ff6\">加固原理</a></p>\n<p><a href=\"https://zhuanlan.zhihu.com/p/70894166\">脱壳教程</a></p>\n<p><a href=\"https://blog.csdn.net/weixin_36001685/article/details/102997126\">不root怎么将FDex2反编译的dex文件拷出来</a></p>\n<p><a href=\"https://blog.csdn.net/qq_22000459/article/details/90314255\">Xposed之Hook方法</a></p>\n<p><a href=\"https://juejin.cn/post/6844903762771853326\">Xposed Hook混淆且加固后的APP</a></p>\n<p><a href=\"https://github.com/CodingGay/BlackDex\">最方便快捷的脱壳软件（不需要Root、也不需要Xposed</a></p>\n<p>关于脱壳、破解逆向等资源工具最好的网站是—-&gt;  <a href=\"http://www.52pojie.cn\">www.52pojie.cn</a></p>\n<p>整理一份相关破解工具集：<a href=\"https://github.com/VomPom/Hack/tree/master/apk_reverse\">https://github.com/VomPom/Hack/tree/master/apk_reverse</a></p>\n<h2 id=\"个人一些经验总结：\"><a href=\"#个人一些经验总结：\" class=\"headerlink\" title=\"个人一些经验总结：\"></a>个人一些经验总结：</h2><p>1、 App抓包尽量使用Android 低版本（Android 7以下）7之后有些新版本系统的安全限制</p>\n<p>2、 能进行静态代码就直接进行静态代码分析，在万不得已的时候再利用 hook以及动态调试（相关收益率以及成功率比较低）</p>\n<p>3、 利用BlackDex之类的软件脱壳之后，从手机复制过来到一个文件夹，利用apk2dex2jar2class2java.sh 执行 sh apk2dex2jar2class2java.sh /xx/xx (对应的脱壳后的dex文件夹) 得到jar/java文件夹可方便进行静态代码分析</p>\n<p>4、 如何找到请求接口加解密的地方？这个只有靠个人经验，对于很多普通加密利用了标准加密库，可以尝试搜索“Cipher.getInstance”之类的标准代码（注意第三方相关sdk也会使用），或者搜搜“Response”相关的字段，或者 请求过程中相关的具体字段或者域名等，不过这部分代码一般都是被混淆的，需要耐心慢慢摸索。</p>\n<p>5、 有时候代码会有找不到相关的类的情况，这是由于脱壳相关机制导致的，需要对其进行修复，或者尝试使用其他脱壳软件进行脱壳。</p>\n","cover":null,"images":[],"content":"<p>在离开 YW 之前很长的一段时间都在做逆向相关，从最初只需要反编译 .apk 文件就能“摸清”应用内部相关逻辑，到后来需要对App文件进行脱壳，到需要动态调试。花了很大的精力，这中间也走了很多弯路。在换了工作之后，不知还会不会再有接触逆向相关的开发，但过去的探索也是我技术的宝贵经验吧，遂将此前的学习的一些经验进行整理。</p>\n<h2 id=\"逆向相关原理与流程参考资料\"><a href=\"#逆向相关原理与流程参考资料\" class=\"headerlink\" title=\"逆向相关原理与流程参考资料\"></a>逆向相关原理与流程参考资料</h2><p><a href=\"https://www.jianshu.com/p/d22f52a6a6fb\">安卓打包流程</a></p>\n<p><a href=\"https://julis.wang/2021/05/14/Android-%E9%80%86%E5%90%91-%E5%8F%8D%E7%BC%96%E8%AF%91/\">反编译流程</a></p>\n<p><a href=\"https://www.jianshu.com/p/4ff48b761ff6\">加固原理</a></p>\n<p><a href=\"https://zhuanlan.zhihu.com/p/70894166\">脱壳教程</a></p>\n<p><a href=\"https://blog.csdn.net/weixin_36001685/article/details/102997126\">不root怎么将FDex2反编译的dex文件拷出来</a></p>\n<p><a href=\"https://blog.csdn.net/qq_22000459/article/details/90314255\">Xposed之Hook方法</a></p>\n<p><a href=\"https://juejin.cn/post/6844903762771853326\">Xposed Hook混淆且加固后的APP</a></p>\n<p><a href=\"https://github.com/CodingGay/BlackDex\">最方便快捷的脱壳软件（不需要Root、也不需要Xposed</a></p>\n<p>关于脱壳、破解逆向等资源工具最好的网站是—-&gt;  <a href=\"http://www.52pojie.cn\">www.52pojie.cn</a></p>\n<p>整理一份相关破解工具集：<a href=\"https://github.com/VomPom/Hack/tree/master/apk_reverse\">https://github.com/VomPom/Hack/tree/master/apk_reverse</a></p>\n<h2 id=\"个人一些经验总结：\"><a href=\"#个人一些经验总结：\" class=\"headerlink\" title=\"个人一些经验总结：\"></a>个人一些经验总结：</h2><p>1、 App抓包尽量使用Android 低版本（Android 7以下）7之后有些新版本系统的安全限制</p>\n<p>2、 能进行静态代码就直接进行静态代码分析，在万不得已的时候再利用 hook以及动态调试（相关收益率以及成功率比较低）</p>\n<p>3、 利用BlackDex之类的软件脱壳之后，从手机复制过来到一个文件夹，利用apk2dex2jar2class2java.sh 执行 sh apk2dex2jar2class2java.sh /xx/xx (对应的脱壳后的dex文件夹) 得到jar/java文件夹可方便进行静态代码分析</p>\n<p>4、 如何找到请求接口加解密的地方？这个只有靠个人经验，对于很多普通加密利用了标准加密库，可以尝试搜索“Cipher.getInstance”之类的标准代码（注意第三方相关sdk也会使用），或者搜搜“Response”相关的字段，或者 请求过程中相关的具体字段或者域名等，不过这部分代码一般都是被混淆的，需要耐心慢慢摸索。</p>\n<p>5、 有时候代码会有找不到相关的类的情况，这是由于脱壳相关机制导致的，需要对其进行修复，或者尝试使用其他脱壳软件进行脱壳。</p>\n","categories":[],"tags":[],"api":"api/posts/2021/07/06/逆向相关经验总结.json"},{"title":"Android 逆向-反编译","slug":"Android-逆向-反编译","date":"2021-05-14T06:45:00.000Z","updated":"2025-12-22T03:27:00.920Z","comments":true,"url":"2021/05/14/Android-逆向-反编译/","excerpt":"<p>最近由于机缘巧合接触到了 Android 逆向相关的事情，经过一番探索，对其有了更深刻地认识，过程中遇到了了一些坑，或者一些有用的经验，分享并记录分析一下。在整个过程中使用的工具有：</p>\n<p><strong>反编译</strong>：dex2jar、CFR、jd-gui、</p>\n<p><strong>脱壳</strong>：VirtualApp、Xposed installer、FDex2</p>\n<p><strong>其他</strong>：IDA、VSCode、Total commander</p>\n<p>接下来咱们以两个具体情景，讲解整个逆向（静态代码分析）的流程，去分析两个 Apk 中相关页面的加密算法。</p>\n<p>在开发安卓应用的过程中，我们平时写得最多的代码就是 Java(以及Kotlin)，我们的逻辑也都在这一块，如果我们需要对应 apk 中代码逻辑，能直接看到这样的代码当然是最好不过的。要对相关 apk 中的代码逻辑进行分析，那么第一步便是需要对 apk 进行反编译，从而得到可以进行阅读理解的代码。</p>\n<h1 id=\"Apk的打包流程\"><a href=\"#Apk的打包流程\" class=\"headerlink\" title=\"Apk的打包流程\"></a>Apk的打包流程</h1><p>我们先对 安卓的打包流程进行一个简单的了解，从而明白.java文件 是一步步\b成为 apk中的一部分的，在生成 apk 的过程中主要包含以下流程，括号中代表使用的工具：</p>\n<p>1、打包资源文件，生成R.java文件 (aapt)</p>\n<p>2、处理aidl文件，生成相应的.java文件 (aidl)</p>\n<p>3、编译项目源代码，生成class文件 (javac)</p>\n<p>4、转换所有的class文件，生成classes.dex文件 (dx)</p>\n<p>5、编译过的资源和.dex文件都会被apkbuilder工具打包到最终的.apk文件中。 (apkbuilder)</p>\n<p>6、对APK文件进行签名 (jarsigner)</p>\n<p>7、对签名后的APK文件进行对齐处理 (zipalign)</p>\n<p>主要流程参考这张图：<br><img src=\"https://developer.android.com/images/tools/studio/build-process_2x.png\" alt=\"build-process_2x\"></p>\n<h1 id=\"反编译流程\"><a href=\"#反编译流程\" class=\"headerlink\" title=\"反编译流程\"></a>反编译流程</h1><p>在 apk的打包流程的步骤为：*(资源/aidl等)-&gt; .java-&gt;.calss-&gt;.dex-&gt;.apk，反编译只需要对每个步骤反向进行。</p>\n<h2 id=\"apk-gt-dex\"><a href=\"#apk-gt-dex\" class=\"headerlink\" title=\".apk-&gt;.dex\"></a>.apk-&gt;.dex</h2><p>安卓安装包本质上是一个压缩文件，只需要对齐进行解压即可(Mac上直接将后缀apk，改成 zip 再使用自带解压软件即可)<br>解压获得以下文件：</p>\n<figure class=\"highlight text\"><table><tr><td class=\"code\"><pre><span class=\"line\">├── AndroidManifest.xml</span><br><span class=\"line\">├── META-INF</span><br><span class=\"line\">├── assets</span><br><span class=\"line\">├── classes.dex </span><br><span class=\"line\">├── classes2.dex</span><br><span class=\"line\">├── lib</span><br><span class=\"line\">├── okhttp3</span><br><span class=\"line\">├── org</span><br><span class=\"line\">├── r</span><br><span class=\"line\">└── resources.arsc</span><br></pre></td></tr></table></figure>\n<p>从目录结构得到两个.dex文件，这是由于在单个dex文件引用的方法总数不能超过65536（为什么？因为dex文件中的方法个数采用原生类型short来索引，而short是4个字节，4个字节最大数据存储量是65536），多数 app 超过了这一限制。</p>\n<h2 id=\"dex-gt-class\"><a href=\"#dex-gt-class\" class=\"headerlink\" title=\".dex-&gt;.class\"></a>.dex-&gt;.class</h2><p>这里我们需要利用工具 dex2jar</p>\n<blockquote>\n<p>d2j-dex2jar: Convert .dex file to .class files (zipped as jar)</p>\n</blockquote>\n<p>执行：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">sh /XXX/dex2jar-2.0/d2j-dex2jar.sh classes.dex </span><br></pre></td></tr></table></figure>\n<p>生成 classes-dex2jar.jar, 这个 jar 就是从classes.dex反编译出来的 .class集合。得到了这份 .jar我们已经可以开始使用 jd-gui进行查看了，这里吐槽一下jd-gui的搜索功能，搜索功能有限，纯字符串搜索是有问题的（或许是我版本不对），可以在 File/Save all sources 将所有反编译好的文件进行保存，然后利用其他工具（例如VsCode）进行搜索。</p>\n<img src=\"https://cdn.julis.wang/blog/img/up-6ddc9f6e11b1cffd9cc5a2d8a5634d650f9.png\">\n<p>再看上面的代码，有一部分是 字节码，工具未能将它正常反编译，为什么呢？相关解释在<br><a href=\"https://www.zhihu.com/question/50140866\">https://www.zhihu.com/question/50140866</a> </p>\n<p>这里推荐使用 CFR,执行：</p>\n<figure class=\"highlight text\"><table><tr><td class=\"code\"><pre><span class=\"line\">java -jar /xxx/cfr-0.151.jar /xxx/classes-dex2jar.jar --outputdir /xxx/java</span><br></pre></td></tr></table></figure>\n<img src=\"https://cdn.julis.wang/blog/img/up-b876618b177cd018b2125221c34d0e94907.png\">\n<p>CFR对于 jd-gui 有更好的支持，那还要 jd-gui 干什么呢？在我看来 jd-gui 有一个最大的好处就是能像IDE那样可以点进进入方法内部，所以推荐两则结合起来使用。</p>\n<h2 id=\"so-反编译\"><a href=\"#so-反编译\" class=\"headerlink\" title=\".so 反编译\"></a>.so 反编译</h2><p>在追溯逻辑的过程中，可能会遇到有 native 方法，如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">native</span> <span class=\"type\">int</span> <span class=\"title function_\">dataFromNative</span><span class=\"params\">(<span class=\"type\">byte</span>[] param, <span class=\"type\">int</span> paramInt1, <span class=\"type\">int</span> paramInt2)</span>;</span><br></pre></td></tr></table></figure>\n<p>相关逻辑写在 c/c++文件中，最终把打在.so库中，这时候就需要宇宙第一反汇编分析工具 IDA了，我们在 apk 解压后的 lib 中找到对应的 .so 文件（这里可能需要一点耐心，lib中大多是第三方的，可以很好通过 so 文件名找到开发者的 so文件）,利用 IDA F5 插件查看 汇编代码的伪代码。以字节某 SDK中的某段代码为例：</p>\n<img src=\"https://cdn.julis.wang/blog/img/up-a94ff19122e8fd51ac625f6888620e46ece.png\">\n<p>可以看到对应的逻辑，这时候就考验水平的时候了……<br>当然，IDA 是一个强大的工具，关于IDA的使用绝对不是通过查看一两篇博文就能熟练使用的，可以去查看<br><a href=\"https://www.amazon.com/IDA-Pro-Book-Unofficial-Disassembler/dp/1593272898\">《IDA Pro权威指南》</a></p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>1、当然上述流程只针对”正常App”，但在实际的 App 不会这样轻易的被反编译，App 可能还进行了加固，那我需要对其进行脱壳才能实现正确的反编译，这一内容放在另一章节再进行讲解。<br>2、反编译整个流程，如果没有加固，一般操作是：解压-&gt;class2jar 进行转jar-&gt;CFR/jx-gui 反编译class，如果对逆向还有更多的操作还可以使用 apk_tool。相关流程已经在github 有开源的脚本了<a href=\"https://github.com/tp7309/TTDeDroid\">TTDeDroid</a>，有兴趣的同学可以去看看，但是我感觉有些复杂，我自己也写了一个脚本<a href=\"https://github.com/VomPom/Hack/tree/master/apk_reverse\">apk2dex2jar2class2java.sh</a></p>\n","cover":null,"images":["https://developer.android.com/images/tools/studio/build-process_2x.png","https://cdn.julis.wang/blog/img/up-6ddc9f6e11b1cffd9cc5a2d8a5634d650f9.png","https://cdn.julis.wang/blog/img/up-b876618b177cd018b2125221c34d0e94907.png","https://cdn.julis.wang/blog/img/up-a94ff19122e8fd51ac625f6888620e46ece.png"],"content":"<p>最近由于机缘巧合接触到了 Android 逆向相关的事情，经过一番探索，对其有了更深刻地认识，过程中遇到了了一些坑，或者一些有用的经验，分享并记录分析一下。在整个过程中使用的工具有：</p>\n<p><strong>反编译</strong>：dex2jar、CFR、jd-gui、</p>\n<p><strong>脱壳</strong>：VirtualApp、Xposed installer、FDex2</p>\n<p><strong>其他</strong>：IDA、VSCode、Total commander</p>\n<p>接下来咱们以两个具体情景，讲解整个逆向（静态代码分析）的流程，去分析两个 Apk 中相关页面的加密算法。</p>\n<p>在开发安卓应用的过程中，我们平时写得最多的代码就是 Java(以及Kotlin)，我们的逻辑也都在这一块，如果我们需要对应 apk 中代码逻辑，能直接看到这样的代码当然是最好不过的。要对相关 apk 中的代码逻辑进行分析，那么第一步便是需要对 apk 进行反编译，从而得到可以进行阅读理解的代码。</p>\n<h1 id=\"Apk的打包流程\"><a href=\"#Apk的打包流程\" class=\"headerlink\" title=\"Apk的打包流程\"></a>Apk的打包流程</h1><p>我们先对 安卓的打包流程进行一个简单的了解，从而明白.java文件 是一步步\b成为 apk中的一部分的，在生成 apk 的过程中主要包含以下流程，括号中代表使用的工具：</p>\n<p>1、打包资源文件，生成R.java文件 (aapt)</p>\n<p>2、处理aidl文件，生成相应的.java文件 (aidl)</p>\n<p>3、编译项目源代码，生成class文件 (javac)</p>\n<p>4、转换所有的class文件，生成classes.dex文件 (dx)</p>\n<p>5、编译过的资源和.dex文件都会被apkbuilder工具打包到最终的.apk文件中。 (apkbuilder)</p>\n<p>6、对APK文件进行签名 (jarsigner)</p>\n<p>7、对签名后的APK文件进行对齐处理 (zipalign)</p>\n<p>主要流程参考这张图：<br><img src=\"https://developer.android.com/images/tools/studio/build-process_2x.png\" alt=\"build-process_2x\"></p>\n<h1 id=\"反编译流程\"><a href=\"#反编译流程\" class=\"headerlink\" title=\"反编译流程\"></a>反编译流程</h1><p>在 apk的打包流程的步骤为：*(资源/aidl等)-&gt; .java-&gt;.calss-&gt;.dex-&gt;.apk，反编译只需要对每个步骤反向进行。</p>\n<h2 id=\"apk-gt-dex\"><a href=\"#apk-gt-dex\" class=\"headerlink\" title=\".apk-&gt;.dex\"></a>.apk-&gt;.dex</h2><p>安卓安装包本质上是一个压缩文件，只需要对齐进行解压即可(Mac上直接将后缀apk，改成 zip 再使用自带解压软件即可)<br>解压获得以下文件：</p>\n<figure class=\"highlight text\"><table><tr><td class=\"code\"><pre><span class=\"line\">├── AndroidManifest.xml</span><br><span class=\"line\">├── META-INF</span><br><span class=\"line\">├── assets</span><br><span class=\"line\">├── classes.dex </span><br><span class=\"line\">├── classes2.dex</span><br><span class=\"line\">├── lib</span><br><span class=\"line\">├── okhttp3</span><br><span class=\"line\">├── org</span><br><span class=\"line\">├── r</span><br><span class=\"line\">└── resources.arsc</span><br></pre></td></tr></table></figure>\n<p>从目录结构得到两个.dex文件，这是由于在单个dex文件引用的方法总数不能超过65536（为什么？因为dex文件中的方法个数采用原生类型short来索引，而short是4个字节，4个字节最大数据存储量是65536），多数 app 超过了这一限制。</p>\n<h2 id=\"dex-gt-class\"><a href=\"#dex-gt-class\" class=\"headerlink\" title=\".dex-&gt;.class\"></a>.dex-&gt;.class</h2><p>这里我们需要利用工具 dex2jar</p>\n<blockquote>\n<p>d2j-dex2jar: Convert .dex file to .class files (zipped as jar)</p>\n</blockquote>\n<p>执行：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">sh /XXX/dex2jar-2.0/d2j-dex2jar.sh classes.dex </span><br></pre></td></tr></table></figure>\n<p>生成 classes-dex2jar.jar, 这个 jar 就是从classes.dex反编译出来的 .class集合。得到了这份 .jar我们已经可以开始使用 jd-gui进行查看了，这里吐槽一下jd-gui的搜索功能，搜索功能有限，纯字符串搜索是有问题的（或许是我版本不对），可以在 File/Save all sources 将所有反编译好的文件进行保存，然后利用其他工具（例如VsCode）进行搜索。</p>\n<img src=\"https://cdn.julis.wang/blog/img/up-6ddc9f6e11b1cffd9cc5a2d8a5634d650f9.png\">\n<p>再看上面的代码，有一部分是 字节码，工具未能将它正常反编译，为什么呢？相关解释在<br><a href=\"https://www.zhihu.com/question/50140866\">https://www.zhihu.com/question/50140866</a> </p>\n<p>这里推荐使用 CFR,执行：</p>\n<figure class=\"highlight text\"><table><tr><td class=\"code\"><pre><span class=\"line\">java -jar /xxx/cfr-0.151.jar /xxx/classes-dex2jar.jar --outputdir /xxx/java</span><br></pre></td></tr></table></figure>\n<img src=\"https://cdn.julis.wang/blog/img/up-b876618b177cd018b2125221c34d0e94907.png\">\n<p>CFR对于 jd-gui 有更好的支持，那还要 jd-gui 干什么呢？在我看来 jd-gui 有一个最大的好处就是能像IDE那样可以点进进入方法内部，所以推荐两则结合起来使用。</p>\n<h2 id=\"so-反编译\"><a href=\"#so-反编译\" class=\"headerlink\" title=\".so 反编译\"></a>.so 反编译</h2><p>在追溯逻辑的过程中，可能会遇到有 native 方法，如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">native</span> <span class=\"type\">int</span> <span class=\"title function_\">dataFromNative</span><span class=\"params\">(<span class=\"type\">byte</span>[] param, <span class=\"type\">int</span> paramInt1, <span class=\"type\">int</span> paramInt2)</span>;</span><br></pre></td></tr></table></figure>\n<p>相关逻辑写在 c/c++文件中，最终把打在.so库中，这时候就需要宇宙第一反汇编分析工具 IDA了，我们在 apk 解压后的 lib 中找到对应的 .so 文件（这里可能需要一点耐心，lib中大多是第三方的，可以很好通过 so 文件名找到开发者的 so文件）,利用 IDA F5 插件查看 汇编代码的伪代码。以字节某 SDK中的某段代码为例：</p>\n<img src=\"https://cdn.julis.wang/blog/img/up-a94ff19122e8fd51ac625f6888620e46ece.png\">\n<p>可以看到对应的逻辑，这时候就考验水平的时候了……<br>当然，IDA 是一个强大的工具，关于IDA的使用绝对不是通过查看一两篇博文就能熟练使用的，可以去查看<br><a href=\"https://www.amazon.com/IDA-Pro-Book-Unofficial-Disassembler/dp/1593272898\">《IDA Pro权威指南》</a></p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>1、当然上述流程只针对”正常App”，但在实际的 App 不会这样轻易的被反编译，App 可能还进行了加固，那我需要对其进行脱壳才能实现正确的反编译，这一内容放在另一章节再进行讲解。<br>2、反编译整个流程，如果没有加固，一般操作是：解压-&gt;class2jar 进行转jar-&gt;CFR/jx-gui 反编译class，如果对逆向还有更多的操作还可以使用 apk_tool。相关流程已经在github 有开源的脚本了<a href=\"https://github.com/tp7309/TTDeDroid\">TTDeDroid</a>，有兴趣的同学可以去看看，但是我感觉有些复杂，我自己也写了一个脚本<a href=\"https://github.com/VomPom/Hack/tree/master/apk_reverse\">apk2dex2jar2class2java.sh</a></p>\n","categories":[{"name":"技术文章","slug":"technology","api":"api/categories/technology.json"}],"tags":[{"name":"Android","slug":"Android","api":"api/tags/Android.json"},{"name":"逆向","slug":"逆向","api":"api/tags/逆向.json"}],"api":"api/posts/2021/05/14/Android-逆向-反编译.json"},{"title":"Flutter FFI实践","slug":"FlutterFFI实践","date":"2021-04-18T02:34:00.000Z","updated":"2025-05-20T11:46:57.000Z","comments":true,"url":"2021/04/18/FlutterFFI实践/","excerpt":"<p>在 Android的开发中，我们有 <a href=\"https://developer.android.com/training/articles/perf-jni\">JNI</a> 使得 Java可以调用本地应用或库。<br>Flutter 在前不久发布了 <a href=\"https://developers.googleblog.com/2021/03/announcing-flutter-2.html\">Flutter2</a>，更新了 <a href=\"https://dart.dev/guides/libraries/c-interop\">FFI</a> (我们是否可以把它叫做DNI呢？)进入了稳定状态,开发者可以更安心的使用其功能。<br>但是相关的文档依然很欠缺，导致使用起来有诸多的疑问，以及相关原理性的介绍比较少，所以整理记录一下。</p>\n<h2 id=\"一、Dart-同步调用-Native-方法\"><a href=\"#一、Dart-同步调用-Native-方法\" class=\"headerlink\" title=\"一、Dart 同步调用 Native 方法\"></a>一、Dart 同步调用 Native 方法</h2><p>我们以最简单的demo为例,请求一个有参无返回值的C方法<br>在 C/C++中有如下函数：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">extern</span> <span class=\"string\">&quot;C&quot;</span> __attribute__((visibility(<span class=\"string\">&quot;default&quot;</span>))) __attribute__((used))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">c_with_out_return_value</span><span class=\"params\">(<span class=\"type\">int</span> value)</span> &#123;</span><br><span class=\"line\">    LOG_D(<span class=\"string\">&quot;Got invoke value: %d&quot;</span>, value);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Dart:</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">final</span> DynamicLibrary ffiLib = Platform.isAndroid ? DynamicLibrary.open(<span class=\"string\">&#x27;lib_invoke.so&#x27;</span>) : DynamicLibrary.process();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">final</span> cMethod = ffiLib.lookupFunction&lt;Void <span class=\"built_in\">Function</span>(Int32 value), <span class=\"keyword\">void</span> <span class=\"built_in\">Function</span>(<span class=\"built_in\">int</span> value)&gt;(<span class=\"string\">&#x27;c_with_out_return_value&#x27;</span>);</span><br><span class=\"line\">cMethod(<span class=\"number\">123</span>);  </span><br></pre></td></tr></table></figure>\n<p>这样一次调用就完成了一次调用，传递了123到Native并执行了一次打印，同理相关有参有返回值的请求也都是这样做到的，那 Dart 和 Native内部具体怎样实现的呢？</p>\n<p><code>DynamicLibrary.open()</code> 最终执行的逻辑如下, 源码位于<a href=\"https://github.com/dart-lang/sdk/blob/master/runtime/lib/ffi_dynamic_library.cc\">ffi_dynamic_library.cc</a>：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">void</span>* <span class=\"title function_\">LoadExtensionLibrary</span><span class=\"params\">(<span class=\"type\">const</span> <span class=\"type\">char</span>* library_file)</span> &#123;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">if</span> defined(HOST_OS_LINUX) || defined(HOST_OS_MACOS) ||                        \\</span></span><br><span class=\"line\"><span class=\"meta\">    defined(HOST_OS_ANDROID) || defined(HOST_OS_FUCHSIA)</span></span><br><span class=\"line\">  <span class=\"type\">void</span>* handle = dlopen(library_file, RTLD_LAZY);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (handle == nullptr) &#123;</span><br><span class=\"line\">    <span class=\"type\">char</span>* error = dlerror();</span><br><span class=\"line\">    <span class=\"type\">const</span> String&amp; msg = String::Handle(</span><br><span class=\"line\">        String::NewFormatted(<span class=\"string\">&quot;Failed to load dynamic library (%s)&quot;</span>, error));</span><br><span class=\"line\">    Exceptions::ThrowArgumentError(msg);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> handle;</span><br><span class=\"line\">  ……</span><br></pre></td></tr></table></figure>\n<p>可以看到最终使用 <a href=\"https://pubs.opengroup.org/onlinepubs/009696699/functions/dlopen.html\">dlopen</a> 加载动态链接库，并返回句柄。</p>\n<p>拿到对应的动态链接库的句柄之后，就能使用相关方法进行操作了。<br>句柄主要包含以下两个方法：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//在内存中查找对应符号名的地址，与dlsym()功能相同</span></span><br><span class=\"line\"><span class=\"keyword\">external</span> Pointer&lt;T&gt; lookup&lt;T <span class=\"keyword\">extends</span> NativeType&gt;(<span class=\"built_in\">String</span> symbolName);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//1、去动态库中查找对应名称的函数 </span></span><br><span class=\"line\"><span class=\"comment\">//2、将 Native 类型的 C/C++ 函数转化为 Dart 的 Function 类型</span></span><br><span class=\"line\"><span class=\"keyword\">external</span> F lookupFunction&lt;T <span class=\"keyword\">extends</span> <span class=\"built_in\">Function</span>, F <span class=\"keyword\">extends</span> <span class=\"built_in\">Function</span>&gt;(<span class=\"built_in\">String</span> symbolName);</span><br></pre></td></tr></table></figure>\n<p>其中lookup()的最终实现主要使用了 <a href=\"https://pubs.opengroup.org/onlinepubs/009695399/functions/dlsym.html\">dlsym</a></p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">void</span>* <span class=\"title function_\">ResolveSymbol</span><span class=\"params\">(<span class=\"type\">void</span>* handle, <span class=\"type\">const</span> <span class=\"type\">char</span>* symbol)</span> &#123;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">if</span> defined(HOST_OS_LINUX) || defined(HOST_OS_MACOS) ||                       </span></span><br><span class=\"line\">    defined(HOST_OS_ANDROID) || defined(HOST_OS_FUCHSIA)</span><br><span class=\"line\">  dlerror();  <span class=\"comment\">// Clear any errors.</span></span><br><span class=\"line\">  <span class=\"type\">void</span>* pointer = dlsym(handle, symbol);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (pointer == nullptr) &#123;</span><br><span class=\"line\">    <span class=\"type\">char</span>* error = dlerror();</span><br><span class=\"line\">    <span class=\"type\">const</span> String&amp; msg = String::Handle(</span><br><span class=\"line\">        String::NewFormatted(<span class=\"string\">&quot;Failed to lookup symbol (%s)&quot;</span>, error));</span><br><span class=\"line\">    Exceptions::ThrowArgumentError(msg);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> pointer;</span><br></pre></td></tr></table></figure>\n<h2 id=\"二、Dart-异步调用-Native-方法\"><a href=\"#二、Dart-异步调用-Native-方法\" class=\"headerlink\" title=\"二、Dart 异步调用 Native 方法\"></a>二、Dart 异步调用 Native 方法</h2><p>在很多场景我们不能像上述同步方法那样，dart 进行一次请求之后立马得到结果，可能会有一些耗时操作，为了不让 Flutter 的UI线程卡住，我们进行异步请求。那如何实现异步请求呢？<br>对于异步实现，官方并没有很明确的文档，都得靠自己琢磨，在官方的讨论中 <a href=\"https://github.com/dart-lang/sdk/issues/37022\">https://github.com/dart-lang/sdk/issues/37022</a> 以及 <a href=\"https://github.com/flutter/flutter/issues/63255\">https://github.com/flutter/flutter/issues/63255</a> 提到一些解决方案:</p>\n<blockquote>\n<p>1.In your C++ code include include/dart_api_dl.h and include/dart_api_dl.cc from here <a href=\"https://github.com/dart-lang/sdk/blob/master/runtime/include/\">https://github.com/dart-lang/sdk/blob/master/runtime/include/</a> (they also depend on include/internal/*).</p>\n<p>2.From Dart call Dart_InitializeApiDL passing NativeApi.initializeApiDLData as an argument.</p>\n<p>3.On Dart side create a ReceivePort and pass port number of the corresponding SendPort to the native side (port.sendPort.nativePort).</p>\n<p>4.Now on C++ side you can use Dart_PostCObject_DL to send messages back to Dart side from any thread.</p>\n</blockquote>\n<p>按上述的操作进行实现，接下来具体分析一些里面的逻辑原理。<br>1、导入include/dart_api_dl.h include/dart_api_dl.cc 相关的文件并在 CMakeList.txt进行相关配置<br>2、从dart中 调用Native中 Dart_InitializeApiDL</p>\n<p>Dart:</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> main() &#123;</span><br><span class=\"line\">  initializeApi(NativeApi.initializeApiDLData);</span><br><span class=\"line\">  runApp(MyApp());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>C++:</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Initialize `dart_api_dl.h`</span></span><br><span class=\"line\">DART_EXPORT <span class=\"type\">intptr_t</span> <span class=\"title function_\">InitDartApiDL</span><span class=\"params\">(<span class=\"type\">void</span> *data)</span> &#123;</span><br><span class=\"line\">    LOG_D(<span class=\"string\">&quot;InitDartApiDL&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> Dart_InitializeApiDL(data);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>在 initializeApi(NativeApi.initializeApiDLData) 中 initializeApi 向 Native请求 <code>DART_EXPORT intptr_t InitDartApiDL(void *data)</code>方法，传入的参数就是在 <a href=\"https://github.com/dart-lang/sdk/blob/master/runtime/include/dart_api_dl.h\">dart_api_dl.h</a><br> DART_NATIVE_API_DL_SYMBOLS 以及 DART_API_DL_SYMBOLS 中的方法。</p>\n<p>NativeApi.initializeApiDLData 逻辑：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">const</span> DartApiEntry dart_api_entries[] = &#123;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> ENTRY(name, R, A)                                                      \\</span></span><br><span class=\"line\"><span class=\"meta\">  DartApiEntry&#123;#name, reinterpret_cast<span class=\"string\">&lt;void (*)()&gt;</span>(name)&#125;,</span></span><br><span class=\"line\">    DART_API_ALL_DL_SYMBOLS(ENTRY)</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">undef</span> ENTRY</span></span><br><span class=\"line\">        DartApiEntry&#123;nullptr, nullptr&#125;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">const</span> DartApi dart_api_data = &#123;</span><br><span class=\"line\">    DART_API_DL_MAJOR_VERSION, DART_API_DL_MINOR_VERSION, dart_api_entries&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">DEFINE_NATIVE_ENTRY(DartApiDLInitializeData, <span class=\"number\">0</span>, <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> Integer::New(reinterpret_cast&lt;<span class=\"type\">intptr_t</span>&gt;(&amp;dart_api_data));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>dart_api_dl中定义的方法：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> DART_NATIVE_API_DL_SYMBOLS(F)                                          \\</span></span><br><span class=\"line\"><span class=\"meta\">  <span class=\"comment\">/***** dart_native_api.h *****/</span>                                              \\</span></span><br><span class=\"line\"><span class=\"meta\">  <span class=\"comment\">/* Dart_Port */</span>                                                              \\</span></span><br><span class=\"line\"><span class=\"meta\">  F(Dart_PostCObject, bool, (Dart_Port_DL port_id, Dart_CObject * message))    \\</span></span><br><span class=\"line\"><span class=\"meta\">  F(Dart_PostInteger, bool, (Dart_Port_DL port_id, int64_t message))           \\</span></span><br><span class=\"line\"><span class=\"meta\">  .....</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// dart_api.h symbols can only be called on Dart threads.</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> DART_API_DL_SYMBOLS(F)                                                 \\</span></span><br><span class=\"line\"><span class=\"meta\">  <span class=\"comment\">/***** dart_api.h *****/</span>                                                     \\</span></span><br><span class=\"line\"><span class=\"meta\">  <span class=\"comment\">/* Errors */</span>                                                                 \\</span></span><br><span class=\"line\"><span class=\"meta\">  F(Dart_IsError, bool, (Dart_Handle handle))                                  \\</span></span><br><span class=\"line\"><span class=\"meta\">  F(Dart_IsApiError, bool, (Dart_Handle handle))                               \\</span></span><br><span class=\"line\"><span class=\"meta\">  .....</span></span><br></pre></td></tr></table></figure>\n<p>其实这上面的逻辑很简单，主要是为了让业务中的代码能够进行动态链接，从而调用到 Flutter SDK 中相关方法。</p>\n<p>3、第三步添加 ReceivePort 监听</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Work</span> <span class=\"keyword\">extends</span> <span class=\"title\">Opaque</span> </span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">void</span> requestExecuteCallback(<span class=\"built_in\">dynamic</span> message) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">final</span> <span class=\"built_in\">int</span> workAddress = message <span class=\"keyword\">as</span> <span class=\"built_in\">int</span>;</span><br><span class=\"line\">  <span class=\"keyword\">final</span> Pointer&lt;Work&gt; work = Pointer&lt;Work&gt;.fromAddress(workAddress);</span><br><span class=\"line\">  executeCallback(work);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">final</span> ReceivePort interactiveCppRequests = ReceivePort()..listen(requestExecuteCallback);</span><br></pre></td></tr></table></figure>\n<p>向 Native 发送带有 interactiveCppRequests.sendPort.nativePort 的数据，为native异步回调做准备。</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">Future&lt;<span class=\"built_in\">int</span>&gt; platformAsync(<span class=\"built_in\">int</span> value1, <span class=\"built_in\">int</span> value2) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">final</span> Completer&lt;<span class=\"built_in\">int</span>&gt; completer = Completer&lt;<span class=\"built_in\">int</span>&gt;();</span><br><span class=\"line\">  <span class=\"keyword\">final</span> <span class=\"built_in\">String</span> cid = uuid.v1();</span><br><span class=\"line\">  <span class=\"keyword\">final</span> Pointer&lt;Utf8&gt; cidPtr = cid.toNativeUtf8();</span><br><span class=\"line\">  completerMapping[cid] = completer;</span><br><span class=\"line\">  <span class=\"comment\">//生成一个nativePort，为native异步回调做准备</span></span><br><span class=\"line\">  <span class=\"keyword\">final</span> <span class=\"built_in\">int</span> nativePort = interactiveCppRequests.sendPort.nativePort; </span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">final</span> cMethod = ffiLib.lookupFunction&lt;</span><br><span class=\"line\">      Int32 <span class=\"built_in\">Function</span>(Pointer&lt;Utf8&gt; cId, Int64 sendPort, Int32 value1, Int32 value2,</span><br><span class=\"line\">          Pointer&lt;NativeFunction&lt;callback_type&gt;&gt; callbackBlock),</span><br><span class=\"line\">      <span class=\"built_in\">int</span> <span class=\"built_in\">Function</span>(Pointer&lt;Utf8&gt; cId, <span class=\"built_in\">int</span> sendPort, <span class=\"built_in\">int</span> value1, <span class=\"built_in\">int</span> value2,</span><br><span class=\"line\">          Pointer&lt;NativeFunction&lt;callback_type&gt;&gt; callbackBlock)&gt;(<span class=\"string\">&#x27;platform_async&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  cMethod(cidPtr, nativePort, value1, value2, Pointer.fromFunction&lt;callback_type&gt;(_callbackBlocking));</span><br><span class=\"line\">  <span class=\"keyword\">return</span> completer.future;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>4、当异步执行完成之后，在 Native 执行 Dart_PostCObject_DL 通知 Dart 已经得到结果<br>对于代码如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">response</span><span class=\"params\">(jint result)</span> </span>&#123;</span><br><span class=\"line\">    Work work = [_callback,result] &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (_callback != <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">            _callback( result);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"built_in\">LOG_E</span>(<span class=\"string\">&quot;_callback == null&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    <span class=\"comment\">// Copy to heap to make it outlive the function scope.</span></span><br><span class=\"line\">    <span class=\"type\">const</span> Work *work_ptr = <span class=\"keyword\">new</span> <span class=\"built_in\">Work</span>(work);</span><br><span class=\"line\">    <span class=\"built_in\">NotifyDart</span>(send_port, work_ptr);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">NotifyDart</span><span class=\"params\">(Dart_Port send_port, <span class=\"type\">const</span> Work *work)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"type\">const</span> <span class=\"keyword\">auto</span> work_address = <span class=\"built_in\">reinterpret_cast</span>&lt;<span class=\"type\">intptr_t</span>&gt;(work);</span><br><span class=\"line\">    Dart_CObject dart_object;</span><br><span class=\"line\">    dart_object.type = Dart_CObject_kInt64;</span><br><span class=\"line\">    dart_object.value.as_int64 = work_address;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">const</span> <span class=\"type\">bool</span> result = <span class=\"built_in\">Dart_PostCObject_DL</span>(send_port, &amp;dart_object);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!result) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">LOG_D</span>(<span class=\"string\">&quot;FFI C  :  Posting message to port failed.&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面的代码最核心的就是<code>Dart_PostCObject_DL()</code>这里真正调用的还是，<code>Dart_PostCObject()</code>，加_DL()表示动态链接的方法，为了防止与原先符号冲突。</p>\n<blockquote>\n<p>All symbols are postfixed with _DL to indicate that they are dynamically</p>\n<p>linked and to prevent conflicts with the original symbol.</p>\n</blockquote>\n<p>我们继续看看  <code>Dart_PostCObject()</code>真正做了什么，Dart_PostCObject()最终调用的方法如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">bool</span> <span class=\"title function_\">PostCObjectHelper</span><span class=\"params\">(Dart_Port port_id, Dart_CObject* message)</span> &#123;</span><br><span class=\"line\">  ApiMessageWriter writer;</span><br><span class=\"line\">  <span class=\"built_in\">std</span>::<span class=\"built_in\">unique_ptr</span>&lt;Message&gt; msg =</span><br><span class=\"line\">      writer.WriteCMessage(message, port_id, Message::kNormalPriority);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (msg == nullptr) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Post the message at the given port.</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> PortMap::PostMessage(<span class=\"built_in\">std</span>::move(msg));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里在向 Service Isolate发送事件,最终 Dart 成功接受到异步消息的回调。<br>关于 Isolate 这一块的处理可以参考：<a href=\"https://medium.com/@codinghive.dev/async-coding-with-dart-isolates-b09c5ec00f8b\">Async Coding With Dart: Isolates</a></p>\n<h2 id=\"三、Native-调用-Dart方法\"><a href=\"#三、Native-调用-Dart方法\" class=\"headerlink\" title=\"三、Native 调用 Dart方法 ?\"></a>三、Native 调用 Dart方法 ?</h2><p>对于 JNI 里面，我们需要调用 Java的方法，利用Java反射机制调用即可，如下所示：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">_env-&gt;CallStaticVoidMethod(j_class, j_method, arg1, arg2);</span><br></pre></td></tr></table></figure>\n<p>如果 Native 想要调用 Dart代码有类似的代码可以用么？翻遍了 Flutter相关的文档，都没有找到对应的方法可以直接去调用 Dart的方法，Dart Engine内部有 <a href=\"https://github.com/dart-lang/sdk/blob/master/runtime/include/dart_api.h\">dart_api.h</a>提供了<code>Dart_invoke()</code>方法，但单纯的导入 .h文件在项目中是无法链接到对应的方法的，这也就是为什么需要导入<a href=\"https://github.com/dart-lang/sdk/tree/master/runtime/include\">ffi_runtime_lib</a>相关的文件并执行 <code>Dart_InitializeApiDL()</code>，通过动态链接使得代码能够去调用 Dart 封装的相关方法。</p>\n<p>所以参考 Dart中 <code>InitDartApiDL</code>的方法，我们先对 Dart 中的函数进行注册，传递对应方法的指针，然后在 Native 中即可调用，理论上可行，后续会补上相关  demo。<br>当然这只是一种骚操作，如果有更好的方法能够用 Native 调用 Dart 欢迎讨论。</p>\n<h2 id=\"四、总结\"><a href=\"#四、总结\" class=\"headerlink\" title=\"四、总结\"></a>四、总结</h2><p>文章记录了 Dart 同步和异步调用 Native 相关的使用，异步具体的使用比上述的代码复杂，因为需要一个中介记录异步相关的回调方法，当得到真正的结果之后，利用id查找到对应的方法再执行回调方法。FFI 在 Native中执行 dart 方法，暂时没有比较好的解决方案<br>FFI 调用可查看 <a href=\"https://github.com/VomPom/flutter_ffi_tutorial\">Demo flutter_ffi_tutorial</a></p>\n","cover":null,"images":[],"content":"<p>在 Android的开发中，我们有 <a href=\"https://developer.android.com/training/articles/perf-jni\">JNI</a> 使得 Java可以调用本地应用或库。<br>Flutter 在前不久发布了 <a href=\"https://developers.googleblog.com/2021/03/announcing-flutter-2.html\">Flutter2</a>，更新了 <a href=\"https://dart.dev/guides/libraries/c-interop\">FFI</a> (我们是否可以把它叫做DNI呢？)进入了稳定状态,开发者可以更安心的使用其功能。<br>但是相关的文档依然很欠缺，导致使用起来有诸多的疑问，以及相关原理性的介绍比较少，所以整理记录一下。</p>\n<h2 id=\"一、Dart-同步调用-Native-方法\"><a href=\"#一、Dart-同步调用-Native-方法\" class=\"headerlink\" title=\"一、Dart 同步调用 Native 方法\"></a>一、Dart 同步调用 Native 方法</h2><p>我们以最简单的demo为例,请求一个有参无返回值的C方法<br>在 C/C++中有如下函数：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">extern</span> <span class=\"string\">&quot;C&quot;</span> __attribute__((visibility(<span class=\"string\">&quot;default&quot;</span>))) __attribute__((used))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">c_with_out_return_value</span><span class=\"params\">(<span class=\"type\">int</span> value)</span> &#123;</span><br><span class=\"line\">    LOG_D(<span class=\"string\">&quot;Got invoke value: %d&quot;</span>, value);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Dart:</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">final</span> DynamicLibrary ffiLib = Platform.isAndroid ? DynamicLibrary.open(<span class=\"string\">&#x27;lib_invoke.so&#x27;</span>) : DynamicLibrary.process();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">final</span> cMethod = ffiLib.lookupFunction&lt;Void <span class=\"built_in\">Function</span>(Int32 value), <span class=\"keyword\">void</span> <span class=\"built_in\">Function</span>(<span class=\"built_in\">int</span> value)&gt;(<span class=\"string\">&#x27;c_with_out_return_value&#x27;</span>);</span><br><span class=\"line\">cMethod(<span class=\"number\">123</span>);  </span><br></pre></td></tr></table></figure>\n<p>这样一次调用就完成了一次调用，传递了123到Native并执行了一次打印，同理相关有参有返回值的请求也都是这样做到的，那 Dart 和 Native内部具体怎样实现的呢？</p>\n<p><code>DynamicLibrary.open()</code> 最终执行的逻辑如下, 源码位于<a href=\"https://github.com/dart-lang/sdk/blob/master/runtime/lib/ffi_dynamic_library.cc\">ffi_dynamic_library.cc</a>：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">void</span>* <span class=\"title function_\">LoadExtensionLibrary</span><span class=\"params\">(<span class=\"type\">const</span> <span class=\"type\">char</span>* library_file)</span> &#123;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">if</span> defined(HOST_OS_LINUX) || defined(HOST_OS_MACOS) ||                        \\</span></span><br><span class=\"line\"><span class=\"meta\">    defined(HOST_OS_ANDROID) || defined(HOST_OS_FUCHSIA)</span></span><br><span class=\"line\">  <span class=\"type\">void</span>* handle = dlopen(library_file, RTLD_LAZY);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (handle == nullptr) &#123;</span><br><span class=\"line\">    <span class=\"type\">char</span>* error = dlerror();</span><br><span class=\"line\">    <span class=\"type\">const</span> String&amp; msg = String::Handle(</span><br><span class=\"line\">        String::NewFormatted(<span class=\"string\">&quot;Failed to load dynamic library (%s)&quot;</span>, error));</span><br><span class=\"line\">    Exceptions::ThrowArgumentError(msg);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> handle;</span><br><span class=\"line\">  ……</span><br></pre></td></tr></table></figure>\n<p>可以看到最终使用 <a href=\"https://pubs.opengroup.org/onlinepubs/009696699/functions/dlopen.html\">dlopen</a> 加载动态链接库，并返回句柄。</p>\n<p>拿到对应的动态链接库的句柄之后，就能使用相关方法进行操作了。<br>句柄主要包含以下两个方法：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//在内存中查找对应符号名的地址，与dlsym()功能相同</span></span><br><span class=\"line\"><span class=\"keyword\">external</span> Pointer&lt;T&gt; lookup&lt;T <span class=\"keyword\">extends</span> NativeType&gt;(<span class=\"built_in\">String</span> symbolName);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//1、去动态库中查找对应名称的函数 </span></span><br><span class=\"line\"><span class=\"comment\">//2、将 Native 类型的 C/C++ 函数转化为 Dart 的 Function 类型</span></span><br><span class=\"line\"><span class=\"keyword\">external</span> F lookupFunction&lt;T <span class=\"keyword\">extends</span> <span class=\"built_in\">Function</span>, F <span class=\"keyword\">extends</span> <span class=\"built_in\">Function</span>&gt;(<span class=\"built_in\">String</span> symbolName);</span><br></pre></td></tr></table></figure>\n<p>其中lookup()的最终实现主要使用了 <a href=\"https://pubs.opengroup.org/onlinepubs/009695399/functions/dlsym.html\">dlsym</a></p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">void</span>* <span class=\"title function_\">ResolveSymbol</span><span class=\"params\">(<span class=\"type\">void</span>* handle, <span class=\"type\">const</span> <span class=\"type\">char</span>* symbol)</span> &#123;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">if</span> defined(HOST_OS_LINUX) || defined(HOST_OS_MACOS) ||                       </span></span><br><span class=\"line\">    defined(HOST_OS_ANDROID) || defined(HOST_OS_FUCHSIA)</span><br><span class=\"line\">  dlerror();  <span class=\"comment\">// Clear any errors.</span></span><br><span class=\"line\">  <span class=\"type\">void</span>* pointer = dlsym(handle, symbol);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (pointer == nullptr) &#123;</span><br><span class=\"line\">    <span class=\"type\">char</span>* error = dlerror();</span><br><span class=\"line\">    <span class=\"type\">const</span> String&amp; msg = String::Handle(</span><br><span class=\"line\">        String::NewFormatted(<span class=\"string\">&quot;Failed to lookup symbol (%s)&quot;</span>, error));</span><br><span class=\"line\">    Exceptions::ThrowArgumentError(msg);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> pointer;</span><br></pre></td></tr></table></figure>\n<h2 id=\"二、Dart-异步调用-Native-方法\"><a href=\"#二、Dart-异步调用-Native-方法\" class=\"headerlink\" title=\"二、Dart 异步调用 Native 方法\"></a>二、Dart 异步调用 Native 方法</h2><p>在很多场景我们不能像上述同步方法那样，dart 进行一次请求之后立马得到结果，可能会有一些耗时操作，为了不让 Flutter 的UI线程卡住，我们进行异步请求。那如何实现异步请求呢？<br>对于异步实现，官方并没有很明确的文档，都得靠自己琢磨，在官方的讨论中 <a href=\"https://github.com/dart-lang/sdk/issues/37022\">https://github.com/dart-lang/sdk/issues/37022</a> 以及 <a href=\"https://github.com/flutter/flutter/issues/63255\">https://github.com/flutter/flutter/issues/63255</a> 提到一些解决方案:</p>\n<blockquote>\n<p>1.In your C++ code include include/dart_api_dl.h and include/dart_api_dl.cc from here <a href=\"https://github.com/dart-lang/sdk/blob/master/runtime/include/\">https://github.com/dart-lang/sdk/blob/master/runtime/include/</a> (they also depend on include/internal/*).</p>\n<p>2.From Dart call Dart_InitializeApiDL passing NativeApi.initializeApiDLData as an argument.</p>\n<p>3.On Dart side create a ReceivePort and pass port number of the corresponding SendPort to the native side (port.sendPort.nativePort).</p>\n<p>4.Now on C++ side you can use Dart_PostCObject_DL to send messages back to Dart side from any thread.</p>\n</blockquote>\n<p>按上述的操作进行实现，接下来具体分析一些里面的逻辑原理。<br>1、导入include/dart_api_dl.h include/dart_api_dl.cc 相关的文件并在 CMakeList.txt进行相关配置<br>2、从dart中 调用Native中 Dart_InitializeApiDL</p>\n<p>Dart:</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> main() &#123;</span><br><span class=\"line\">  initializeApi(NativeApi.initializeApiDLData);</span><br><span class=\"line\">  runApp(MyApp());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>C++:</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Initialize `dart_api_dl.h`</span></span><br><span class=\"line\">DART_EXPORT <span class=\"type\">intptr_t</span> <span class=\"title function_\">InitDartApiDL</span><span class=\"params\">(<span class=\"type\">void</span> *data)</span> &#123;</span><br><span class=\"line\">    LOG_D(<span class=\"string\">&quot;InitDartApiDL&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> Dart_InitializeApiDL(data);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>在 initializeApi(NativeApi.initializeApiDLData) 中 initializeApi 向 Native请求 <code>DART_EXPORT intptr_t InitDartApiDL(void *data)</code>方法，传入的参数就是在 <a href=\"https://github.com/dart-lang/sdk/blob/master/runtime/include/dart_api_dl.h\">dart_api_dl.h</a><br> DART_NATIVE_API_DL_SYMBOLS 以及 DART_API_DL_SYMBOLS 中的方法。</p>\n<p>NativeApi.initializeApiDLData 逻辑：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">const</span> DartApiEntry dart_api_entries[] = &#123;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> ENTRY(name, R, A)                                                      \\</span></span><br><span class=\"line\"><span class=\"meta\">  DartApiEntry&#123;#name, reinterpret_cast<span class=\"string\">&lt;void (*)()&gt;</span>(name)&#125;,</span></span><br><span class=\"line\">    DART_API_ALL_DL_SYMBOLS(ENTRY)</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">undef</span> ENTRY</span></span><br><span class=\"line\">        DartApiEntry&#123;nullptr, nullptr&#125;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">const</span> DartApi dart_api_data = &#123;</span><br><span class=\"line\">    DART_API_DL_MAJOR_VERSION, DART_API_DL_MINOR_VERSION, dart_api_entries&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">DEFINE_NATIVE_ENTRY(DartApiDLInitializeData, <span class=\"number\">0</span>, <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> Integer::New(reinterpret_cast&lt;<span class=\"type\">intptr_t</span>&gt;(&amp;dart_api_data));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>dart_api_dl中定义的方法：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> DART_NATIVE_API_DL_SYMBOLS(F)                                          \\</span></span><br><span class=\"line\"><span class=\"meta\">  <span class=\"comment\">/***** dart_native_api.h *****/</span>                                              \\</span></span><br><span class=\"line\"><span class=\"meta\">  <span class=\"comment\">/* Dart_Port */</span>                                                              \\</span></span><br><span class=\"line\"><span class=\"meta\">  F(Dart_PostCObject, bool, (Dart_Port_DL port_id, Dart_CObject * message))    \\</span></span><br><span class=\"line\"><span class=\"meta\">  F(Dart_PostInteger, bool, (Dart_Port_DL port_id, int64_t message))           \\</span></span><br><span class=\"line\"><span class=\"meta\">  .....</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// dart_api.h symbols can only be called on Dart threads.</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> DART_API_DL_SYMBOLS(F)                                                 \\</span></span><br><span class=\"line\"><span class=\"meta\">  <span class=\"comment\">/***** dart_api.h *****/</span>                                                     \\</span></span><br><span class=\"line\"><span class=\"meta\">  <span class=\"comment\">/* Errors */</span>                                                                 \\</span></span><br><span class=\"line\"><span class=\"meta\">  F(Dart_IsError, bool, (Dart_Handle handle))                                  \\</span></span><br><span class=\"line\"><span class=\"meta\">  F(Dart_IsApiError, bool, (Dart_Handle handle))                               \\</span></span><br><span class=\"line\"><span class=\"meta\">  .....</span></span><br></pre></td></tr></table></figure>\n<p>其实这上面的逻辑很简单，主要是为了让业务中的代码能够进行动态链接，从而调用到 Flutter SDK 中相关方法。</p>\n<p>3、第三步添加 ReceivePort 监听</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Work</span> <span class=\"keyword\">extends</span> <span class=\"title\">Opaque</span> </span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">void</span> requestExecuteCallback(<span class=\"built_in\">dynamic</span> message) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">final</span> <span class=\"built_in\">int</span> workAddress = message <span class=\"keyword\">as</span> <span class=\"built_in\">int</span>;</span><br><span class=\"line\">  <span class=\"keyword\">final</span> Pointer&lt;Work&gt; work = Pointer&lt;Work&gt;.fromAddress(workAddress);</span><br><span class=\"line\">  executeCallback(work);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">final</span> ReceivePort interactiveCppRequests = ReceivePort()..listen(requestExecuteCallback);</span><br></pre></td></tr></table></figure>\n<p>向 Native 发送带有 interactiveCppRequests.sendPort.nativePort 的数据，为native异步回调做准备。</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">Future&lt;<span class=\"built_in\">int</span>&gt; platformAsync(<span class=\"built_in\">int</span> value1, <span class=\"built_in\">int</span> value2) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">final</span> Completer&lt;<span class=\"built_in\">int</span>&gt; completer = Completer&lt;<span class=\"built_in\">int</span>&gt;();</span><br><span class=\"line\">  <span class=\"keyword\">final</span> <span class=\"built_in\">String</span> cid = uuid.v1();</span><br><span class=\"line\">  <span class=\"keyword\">final</span> Pointer&lt;Utf8&gt; cidPtr = cid.toNativeUtf8();</span><br><span class=\"line\">  completerMapping[cid] = completer;</span><br><span class=\"line\">  <span class=\"comment\">//生成一个nativePort，为native异步回调做准备</span></span><br><span class=\"line\">  <span class=\"keyword\">final</span> <span class=\"built_in\">int</span> nativePort = interactiveCppRequests.sendPort.nativePort; </span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">final</span> cMethod = ffiLib.lookupFunction&lt;</span><br><span class=\"line\">      Int32 <span class=\"built_in\">Function</span>(Pointer&lt;Utf8&gt; cId, Int64 sendPort, Int32 value1, Int32 value2,</span><br><span class=\"line\">          Pointer&lt;NativeFunction&lt;callback_type&gt;&gt; callbackBlock),</span><br><span class=\"line\">      <span class=\"built_in\">int</span> <span class=\"built_in\">Function</span>(Pointer&lt;Utf8&gt; cId, <span class=\"built_in\">int</span> sendPort, <span class=\"built_in\">int</span> value1, <span class=\"built_in\">int</span> value2,</span><br><span class=\"line\">          Pointer&lt;NativeFunction&lt;callback_type&gt;&gt; callbackBlock)&gt;(<span class=\"string\">&#x27;platform_async&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  cMethod(cidPtr, nativePort, value1, value2, Pointer.fromFunction&lt;callback_type&gt;(_callbackBlocking));</span><br><span class=\"line\">  <span class=\"keyword\">return</span> completer.future;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>4、当异步执行完成之后，在 Native 执行 Dart_PostCObject_DL 通知 Dart 已经得到结果<br>对于代码如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">response</span><span class=\"params\">(jint result)</span> </span>&#123;</span><br><span class=\"line\">    Work work = [_callback,result] &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (_callback != <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">            _callback( result);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"built_in\">LOG_E</span>(<span class=\"string\">&quot;_callback == null&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    <span class=\"comment\">// Copy to heap to make it outlive the function scope.</span></span><br><span class=\"line\">    <span class=\"type\">const</span> Work *work_ptr = <span class=\"keyword\">new</span> <span class=\"built_in\">Work</span>(work);</span><br><span class=\"line\">    <span class=\"built_in\">NotifyDart</span>(send_port, work_ptr);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">NotifyDart</span><span class=\"params\">(Dart_Port send_port, <span class=\"type\">const</span> Work *work)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"type\">const</span> <span class=\"keyword\">auto</span> work_address = <span class=\"built_in\">reinterpret_cast</span>&lt;<span class=\"type\">intptr_t</span>&gt;(work);</span><br><span class=\"line\">    Dart_CObject dart_object;</span><br><span class=\"line\">    dart_object.type = Dart_CObject_kInt64;</span><br><span class=\"line\">    dart_object.value.as_int64 = work_address;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">const</span> <span class=\"type\">bool</span> result = <span class=\"built_in\">Dart_PostCObject_DL</span>(send_port, &amp;dart_object);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!result) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">LOG_D</span>(<span class=\"string\">&quot;FFI C  :  Posting message to port failed.&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面的代码最核心的就是<code>Dart_PostCObject_DL()</code>这里真正调用的还是，<code>Dart_PostCObject()</code>，加_DL()表示动态链接的方法，为了防止与原先符号冲突。</p>\n<blockquote>\n<p>All symbols are postfixed with _DL to indicate that they are dynamically</p>\n<p>linked and to prevent conflicts with the original symbol.</p>\n</blockquote>\n<p>我们继续看看  <code>Dart_PostCObject()</code>真正做了什么，Dart_PostCObject()最终调用的方法如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">bool</span> <span class=\"title function_\">PostCObjectHelper</span><span class=\"params\">(Dart_Port port_id, Dart_CObject* message)</span> &#123;</span><br><span class=\"line\">  ApiMessageWriter writer;</span><br><span class=\"line\">  <span class=\"built_in\">std</span>::<span class=\"built_in\">unique_ptr</span>&lt;Message&gt; msg =</span><br><span class=\"line\">      writer.WriteCMessage(message, port_id, Message::kNormalPriority);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (msg == nullptr) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Post the message at the given port.</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> PortMap::PostMessage(<span class=\"built_in\">std</span>::move(msg));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里在向 Service Isolate发送事件,最终 Dart 成功接受到异步消息的回调。<br>关于 Isolate 这一块的处理可以参考：<a href=\"https://medium.com/@codinghive.dev/async-coding-with-dart-isolates-b09c5ec00f8b\">Async Coding With Dart: Isolates</a></p>\n<h2 id=\"三、Native-调用-Dart方法\"><a href=\"#三、Native-调用-Dart方法\" class=\"headerlink\" title=\"三、Native 调用 Dart方法 ?\"></a>三、Native 调用 Dart方法 ?</h2><p>对于 JNI 里面，我们需要调用 Java的方法，利用Java反射机制调用即可，如下所示：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">_env-&gt;CallStaticVoidMethod(j_class, j_method, arg1, arg2);</span><br></pre></td></tr></table></figure>\n<p>如果 Native 想要调用 Dart代码有类似的代码可以用么？翻遍了 Flutter相关的文档，都没有找到对应的方法可以直接去调用 Dart的方法，Dart Engine内部有 <a href=\"https://github.com/dart-lang/sdk/blob/master/runtime/include/dart_api.h\">dart_api.h</a>提供了<code>Dart_invoke()</code>方法，但单纯的导入 .h文件在项目中是无法链接到对应的方法的，这也就是为什么需要导入<a href=\"https://github.com/dart-lang/sdk/tree/master/runtime/include\">ffi_runtime_lib</a>相关的文件并执行 <code>Dart_InitializeApiDL()</code>，通过动态链接使得代码能够去调用 Dart 封装的相关方法。</p>\n<p>所以参考 Dart中 <code>InitDartApiDL</code>的方法，我们先对 Dart 中的函数进行注册，传递对应方法的指针，然后在 Native 中即可调用，理论上可行，后续会补上相关  demo。<br>当然这只是一种骚操作，如果有更好的方法能够用 Native 调用 Dart 欢迎讨论。</p>\n<h2 id=\"四、总结\"><a href=\"#四、总结\" class=\"headerlink\" title=\"四、总结\"></a>四、总结</h2><p>文章记录了 Dart 同步和异步调用 Native 相关的使用，异步具体的使用比上述的代码复杂，因为需要一个中介记录异步相关的回调方法，当得到真正的结果之后，利用id查找到对应的方法再执行回调方法。FFI 在 Native中执行 dart 方法，暂时没有比较好的解决方案<br>FFI 调用可查看 <a href=\"https://github.com/VomPom/flutter_ffi_tutorial\">Demo flutter_ffi_tutorial</a></p>\n","categories":[{"name":"技术文章","slug":"technology","api":"api/categories/technology.json"}],"tags":[{"name":"Flutter","slug":"Flutter","api":"api/tags/Flutter.json"}],"api":"api/posts/2021/04/18/FlutterFFI实践.json"},{"title":"（转）JNI内存管理及优化","slug":"JNI内存管理及优化","date":"2021-03-10T12:08:00.000Z","updated":"2025-05-20T11:46:57.000Z","comments":true,"url":"2021/03/10/JNI内存管理及优化/","excerpt":"<p>最近接触JNI相关的项目遇到一些与内存相关到问题，JNI或者说是C/C++开发与平时的Java开发相比，总会给人更多的“惊喜”，因为不熟悉native开发，所以有很多知识都不太清楚，一点一点地记录。<br>在掘金相关搜索到下面这篇，个人感觉还不错。<br>以下内容转载自：</p>\n<p><a href=\"https://juejin.cn/post/6844903743352209422\">https://juejin.cn/post/6844903743352209422</a></p>\n<img width=\"60%\" src=\"https://cdn.julis.wang/blog/img/167c522c1dfb148f.png\">\n<p>上面这张图大家都应该很熟了，下面只讲下和JNI有关的部分</p>\n<h4 id=\"程序计数器\"><a href=\"#程序计数器\" class=\"headerlink\" title=\"程序计数器\"></a>程序计数器</h4><p>记录正在执行的虚拟机字节码指令的地址（如果正在执行的是本地方法则为空）。</p>\n<h4 id=\"本地方法栈\"><a href=\"#本地方法栈\" class=\"headerlink\" title=\"本地方法栈\"></a>本地方法栈</h4><p>本地方法栈与 Java 虚拟机栈类似，它们之间的区别只不过是本地方法栈为本地方法服务。 本地方法一般是用其它语言（C、C++ 或汇编语言等）编写的，并且被编译为基于本机硬件和操作系统的程序，对待这些方法需要特别处理。</p>\n<h4 id=\"堆-Java-Heap\"><a href=\"#堆-Java-Heap\" class=\"headerlink\" title=\"堆(Java-Heap)\"></a>堆(Java-Heap)</h4><p>所有对象都在这里分配内存，是垃圾收集的主要区域（”GC 堆”）。 堆不需要连续内存，并且可以动态增加其内存，增加失败会抛出 OutOfMemoryError 异常。</p>\n<p>可以通过 -Xms 和 -Xmx 两个虚拟机参数来指定一个程序的堆内存大小，第一个参数设置初始值，第二个参数设置最大值。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">java -Xmx1024m -Xms1024m</span><br><span class=\"line\">//-Xmx1024m：设置JVM最大可用内存为1024M。</span><br><span class=\"line\">//-Xms1024m：设置JVM初始内存为1024m。此值可与-Xmx相同，以避免每次垃圾回收完成后JVM重新分配内存。</span><br></pre></td></tr></table></figure>\n<p>在Android系统对于每个应用都有内存使用的限制，机器的内存限制，在/system/build.prop文件中配置的。可以在manifest文件application节点加入 <code>android:largeHeap=&quot;true&quot;</code>来让Dalvik/ART虚拟机分配更大的堆内存空间</p>\n<h4 id=\"直接内存（native堆）\"><a href=\"#直接内存（native堆）\" class=\"headerlink\" title=\"直接内存（native堆）\"></a>直接内存（native堆）</h4><p>也称为C-Heap，供Java Runtime进程使用的，没有相应的参数来控制其大小，其大小依赖于操作系统进程的最大值。  Java应用程序都是在Java Runtime Environment（JRE）中运行，而Runtime本身就是由Native语言（如：C/C++）编写程序。Native Memory就是操作系统分配给Runtime进程的可用内存，它与Heap Memory不同，Java Heap 是Java应用程序的内存。。Native Memory的主要作用如下：</p>\n<ul>\n<li>管理java heap的状态数据（用于GC）;</li>\n<li>JNI调用，也就是Native Stack；</li>\n<li>JIT（即使编译器）编译时使用Native Memory，并且JIT的输入（Java字节码）和输出（可执行代码）也都是保存在Native Memory；</li>\n<li>NIO direct buffer；</li>\n<li>Threads；</li>\n<li>类加载器和类信息都是保存在Native Memory中的。</li>\n</ul>\n<h3 id=\"JNI内存\"><a href=\"#JNI内存\" class=\"headerlink\" title=\"JNI内存\"></a>JNI内存</h3><p>在Java代码中，Java对象被存放在JVM的Java Heap，由垃圾回收器（Garbage Collector，即GC）自动回收就可以。</p>\n<p> 在Native代码中，内存是从Native Memory中分配的，需要根据Native编程规范去操作内存。如：C/C++使用malloc()/new分配内存，需要手动使用free()/delete回收内存。</p>\n<p> 然而，JNI和上面两者又有些区别。 JNI提供了与Java相对应的引用类型（如：jobject、jstring、jclass、jarray、jintArray等），以便Native代码可以通过JNI函数访问到Java对象。引用所指向的Java对象通常就是存放在Java Heap，而Native代码持有的引用是存放在Native Memory中。</p>\n<p>举个例子，如下代码：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\">jstring jstr = env-&gt;<span class=\"built_in\">NewStringUTF</span>(<span class=\"string\">&quot;Hello World!&quot;</span>);</span><br></pre></td></tr></table></figure>\n<ul>\n<li>jstring类型是JNI提供的，对应于Java的String类型</li>\n<li>JNI函数<code>NewStringUTF()</code>用于构造一个String对象，该对象存放在Java Heap中，同时返回了一个jstring类型的引用。</li>\n<li>String对象的引用保存在jstr中，jstr是Native的一个局部变量，存放在Native Memory中。</li>\n</ul>\n<p>开发人员都应该遇到过OOM（Out of Memory）异常，在JNI开发中，该异常可能发生在Java Heap中，也可能发生在Native Memory中。</p>\n<ul>\n<li>string类型是JNI提供的，对应于Java的String类型</li>\n<li>JNI函数<code>NewStringUTF()</code>用于构造一个String对象，该对象存放在Java Heap中，同时返回了一个jstring类型的引用。</li>\n<li>String对象的引用保存在jstr中，jstr是Native的一个局部变量，存放在Native Memory中。</li>\n</ul>\n<p>开发人员都应该遇到过OOM（Out of Memory）异常，在JNI开发中，该异常可能发生在Java Heap中，也可能发生在Native Memory中。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">java.lang.OutOfMemoryError: Java heap space</span><br><span class=\"line\">java.lang.OutOfMemoryError: native memory exhausted</span><br></pre></td></tr></table></figure>\n<p><strong>Java Heap 中出现 Out of Memory异常的原因有两种：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">1）程序过于庞大，致使过多 Java 对象的同时存在；</span><br><span class=\"line\">2）程序编写的错误导致 Java Heap 内存泄漏。</span><br></pre></td></tr></table></figure>\n<p><strong>Native Memory中出现 Out of Memory异常的原因：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">1）程序申请过多资源，系统未能满足，比如说大量线程资源；</span><br><span class=\"line\">2）程序编写的错误导致Native Memory内存泄漏。</span><br></pre></td></tr></table></figure>\n<h3 id=\"JNI引用\"><a href=\"#JNI引用\" class=\"headerlink\" title=\"JNI引用\"></a>JNI引用</h3><p>JNI引用有三种：<code>Local Reference</code>、<code>Global Reference</code>、<code>Weak Global Reference</code>。下面分别来介绍一下这三种引用内存分配和管理。</p>\n<p><strong>Local Reference</strong></p>\n<p>只在Native Method执行时存在，只在创建它的线程有效，不能跨线程使用。它的生命期是在Native Method的执行期开始创建（从Java代码切换到Native代码环境时，或者在Native Method执行时调用JNI函数时），在Native Method执行完毕切换回Java代码时，所有Local Reference被删除（GC会回收其内存），生命期结束（调用<code>DeleteLocalRef()</code>可以提前回收内存，结束其生命期）。</p>\n<p> 实际上，每当线程从Java环境切换到Native代码环境时，JVM 会分配一块内存用于创建一个<code>Local Reference Table</code>，这个Table用来存放本次Native Method 执行中创建的所有<code>Local Reference</code>。每当在 Native代码中引用到一个Java对象时，JVM 就会在这个Table中创建一个<code>Local Reference</code>。比如，我们调用 NewStringUTF() 在 Java Heap 中创建一个 String 对象后，在 <code>Local Reference Table</code> 中就会相应新增一个 <code>Local Reference</code>。</p>\n<p>Local Reference 表、Local Reference 和 Java 对象的关系</p>\n<img src=\"https://cdn.julis.wang/blog/img/167c56e72c22fbe7.png\">\n<p>接下来举个简单例子说明一下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">jstring jstr = env-&gt;NewStringUTF(&quot;Hello World!&quot;);</span><br></pre></td></tr></table></figure>\n<ul>\n<li>jstr存放在Native Method Stack中，是一个局部变量</li>\n<li>对于开发者来说，Local Reference Table是不可见的</li>\n<li><code>Local Reference Table</code>的内存不大，所能存放<code>的Local Reference</code>数量也是有限的（在Android中默认最大容量是512个），使用不当就会引起溢出异常</li>\n<li><code>Local Reference</code>并不是Native里面的局部变量，局部变量存放在堆栈中，其引用存放在<code>Local Reference Table</code>中。</li>\n</ul>\n<p>在Native Method结束时，JVM会自动释放Local Reference，但<code>Local Reference Table</code>是有大小限制的，在开发中应该及时使用DeleteLocalRef()删除不必要的Local Reference，不然可能会出现溢出错误：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">JNI ERROR (app bug): local reference table overflow (max=512)</span><br></pre></td></tr></table></figure>\n<p>在C/C++中实例化的JNI对象，如果不返回java，必须用release掉或delete，否则内存泄露。包括NewStringUTF，NewObject。对于一般的基本数据类型（如：jint，jdouble等），是没必要调用该函数删除掉的。如果返回java不必delete，java会自己回收。</p>\n<p><strong>Global Reference</strong></p>\n<p>Local Reference是在Native Method执行的时候出现的，而<code>Global Reference</code>是通过JNI函数<code>NewGlobalRef()</code>和<code>DeleteGlobalRef()</code>来创建和删除的。 <code>Global Reference</code>具有全局性，可以在多个Native Method调用过程和多线程中使用，在主动调用DeleteGlobalRef之前，它是一直有效的（GC不会回收其内存）。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 创建obj参数所引用对象的新全局引用。obj参数既可以是全局引用，也可以是局部引用。全局引用通过调用DeleteGlobalRef()来显式撤消。</span></span><br><span class=\"line\"><span class=\"comment\"> * @param obj 全局或局部引用。</span></span><br><span class=\"line\"><span class=\"comment\"> * @return 返回全局引用。如果系统内存不足则返回 NULL。</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\">jobject <span class=\"title function_\">NewGlobalRef</span><span class=\"params\">(jobject obj)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 删除globalRef所指向的全局引用</span></span><br><span class=\"line\"><span class=\"comment\"> * @param globalRef 全局引用</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">DeleteGlobalRef</span><span class=\"params\">(jobject globalRef)</span>;</span><br></pre></td></tr></table></figure>\n<p>使用 <code>Global reference</code>时，当 native code 不再需要访问<code>Global reference</code> 时，应当调用 JNI 函数 <code>DeleteGlobalRef()</code> 删除 <code>Global reference</code>和它引用的 Java 对象。否则<code>Global Reference</code>引用的 Java 对象将永远停留在 Java Heap 中，从而导致 Java Heap 的内存泄漏。</p>\n<p><strong>Weak Global Reference</strong></p>\n<p>用<code>NewWeakGlobalRef()</code>和<code>DeleteWeakGlobalRef()</code>进行创建和删除，它与<code>Global Reference</code>的区别在于该类型的引用随时都可能被GC回收。</p>\n<p>对<code>于Weak Global Reference</code>而言，可以通过<code>isSameObject()</code>将其与NULL比较，看看是否已经被回收了。如果返回JNI_TRUE，则表示已经被回收了，需要重新初始化弱全局引用。<code>Weak Global Reference</code>的回收时机是不确定的，有可能在前一行代码判断它是可用的，后一行代码就被GC回收掉了。为了避免这事事情发生，JNI官方给出了正确的做法，通过NewLocalRef()获取<code>Weak Global Reference</code>，避免被GC回收。</p>\n<h3 id=\"注意点\"><a href=\"#注意点\" class=\"headerlink\" title=\"注意点\"></a>注意点</h3><h4 id=\"Local-Reference-不是-native-code-的局部变量\"><a href=\"#Local-Reference-不是-native-code-的局部变量\" class=\"headerlink\" title=\"Local Reference 不是 native code 的局部变量\"></a>Local Reference 不是 native code 的局部变量</h4><p>很多人会误将 JNI 中的 Local Reference 理解为 Native Code 的局部变量。这是错误的。</p>\n<p>Native Code 的局部变量和 Local Reference 是完全不同的，区别可以总结为：</p>\n<p>⑴局部变量存储在线程堆栈中，而 Local Reference 存储在 Local Ref 表中。</p>\n<p>⑵局部变量在函数退栈后被删除，而 Local Reference 在调用 DeleteLocalRef() 后才会从 Local Ref 表中删除，并且失效，或者在整个 Native Method 执行结束后被删除。</p>\n<p>⑶可以在代码中直接访问局部变量，而 Local Reference 的内容无法在代码中直接访问，必须通过 JNI function 间接访问。JNI function 实现了对 Local Reference 的间接访问，JNI function 的内部实现依赖于具体 JVM。</p>\n<h4 id=\"注意释放所有对jobject的引用：\"><a href=\"#注意释放所有对jobject的引用：\" class=\"headerlink\" title=\"注意释放所有对jobject的引用：\"></a>注意释放所有对jobject的引用：</h4><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">extern</span> <span class=\"string\">&quot;C&quot;</span></span><br><span class=\"line\">JNIEXPORT jstring JNICALL</span><br><span class=\"line\"><span class=\"title function_\">Java_com_test_application_MainActivity_init</span><span class=\"params\">(JNIEnv *env, jobject instance, jstring data,</span></span><br><span class=\"line\"><span class=\"params\">                                      jbyteArray <span class=\"built_in\">array</span>)</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">int</span> len = env-&gt;GetArrayLength(<span class=\"built_in\">array</span>);</span><br><span class=\"line\">    <span class=\"type\">const</span> <span class=\"type\">char</span> *utfChars = env-&gt;GetStringUTFChars(data, <span class=\"number\">0</span>);</span><br><span class=\"line\">    jbyte *arrayElements = env-&gt;GetByteArrayElements(<span class=\"built_in\">array</span>, <span class=\"literal\">NULL</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    jstring pJstring = env-&gt;NewStringUTF(utfChars); </span><br><span class=\"line\"></span><br><span class=\"line\">    jbyteArray jpicArray = env-&gt;NewByteArray(len);</span><br><span class=\"line\">    env-&gt;SetByteArrayRegion(jpicArray, <span class=\"number\">0</span>, len, arrayElements);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// TODO</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    env-&gt;DeleteLocalRef(pJstring);</span><br><span class=\"line\">    env-&gt;DeleteLocalRef(jpicArray);</span><br><span class=\"line\"></span><br><span class=\"line\">    env-&gt;ReleaseStringUTFChars(data, utfChars);</span><br><span class=\"line\">    env-&gt;ReleaseByteArrayElements(<span class=\"built_in\">array</span>, arrayElements, <span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> hello = <span class=\"string\">&quot;Hello from C++&quot;</span>;</span><br><span class=\"line\">    jstring result = env-&gt;NewStringUTF(hello.c_str());</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>其它的还有：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">jclass ref= (env)-&gt;FindClass(&quot;java/lang/String&quot;);</span><br><span class=\"line\"> </span><br><span class=\"line\">env-&gt;DeleteLocalRef(ref);</span><br><span class=\"line\">复制代码</span><br></pre></td></tr></table></figure>\n<p>因为根据<code>jni.h</code>里的定义：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> jobject         jclass;</span><br></pre></td></tr></table></figure>\n<p>jclass也是jobject。而<code>jmethodID</code>/<code>jfielID</code>和jobject没有继承关系，它们不是object,只是个整数，不存在被释放与否的问题。</p>\n<h4 id=\"局部引用和全局引用的转换\"><a href=\"#局部引用和全局引用的转换\" class=\"headerlink\" title=\"局部引用和全局引用的转换\"></a>局部引用和全局引用的转换</h4><p>注意Local Reference的生命周期，如果在Native中需要长时间持有一个Java对象，就不能使用将jobject存储在Native，否则在下次使用的时候，即使同一个线程调用，也将会无法使用。下面是错误的做法：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\">jstring global;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">extern</span> <span class=\"string\">&quot;C&quot;</span> JNIEXPORT jstring JNICALL</span><br><span class=\"line\"><span class=\"title function_\">Java_org_hik_libyuv_MainActivity_stringFromJNI</span><span class=\"params\">(</span></span><br><span class=\"line\"><span class=\"params\">        JNIEnv *env,</span></span><br><span class=\"line\"><span class=\"params\">        jobject <span class=\"comment\">/* this */</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> hello = <span class=\"string\">&quot;Hello from C++&quot;</span>;</span><br><span class=\"line\">    jstring local = env-&gt;NewStringUTF(hello.c_str());</span><br><span class=\"line\">    global = local;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> local;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>正确的做法是使用Global Reference，如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\">jstring global;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">extern</span> <span class=\"string\">&quot;C&quot;</span> JNIEXPORT jstring JNICALL</span><br><span class=\"line\"><span class=\"title function_\">Java_org_hik_libyuv_MainActivity_stringFromJNI</span><span class=\"params\">(</span></span><br><span class=\"line\"><span class=\"params\">        JNIEnv *env,</span></span><br><span class=\"line\"><span class=\"params\">        jobject <span class=\"comment\">/* this */</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> hello = <span class=\"string\">&quot;Hello from C++&quot;</span>;</span><br><span class=\"line\">    jstring local = env-&gt;NewStringUTF(hello.c_str());</span><br><span class=\"line\">    global = static_cast&lt;jstring&gt;(env-&gt;NewGlobalRef(global));</span><br><span class=\"line\">    <span class=\"keyword\">return</span> local;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"多线程\"><a href=\"#多线程\" class=\"headerlink\" title=\"多线程\"></a>多线程</h4><p>JNIEnv和jobject对象都不能跨线程使用。 对于jobject，解决办法是</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\">a、m_obj = env-&gt;NewGlobalRef(obj);<span class=\"comment\">//创建一个全局变量  </span></span><br><span class=\"line\"></span><br><span class=\"line\">b、jobject obj = env-&gt;AllocObject(m_cls);<span class=\"comment\">//在每个线程中都生成一个对象</span></span><br></pre></td></tr></table></figure>\n<p>对于JNIEnv，解决办法是在每个线程中都重新生成一个env</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\">JavaVM *gJavaVM;<span class=\"comment\">//声明全局变量</span></span><br><span class=\"line\">(*env)-&gt;GetJavaVM(env, &amp;gJavaVM);<span class=\"comment\">//在JNI方法的中赋值</span></span><br><span class=\"line\"></span><br><span class=\"line\">JNIEnv *env;<span class=\"comment\">//在其它线程中获取当前线程的env  </span></span><br><span class=\"line\">m_jvm-&gt;AttachCurrentThread((<span class=\"type\">void</span> **)&amp;env, <span class=\"literal\">NULL</span>);  </span><br></pre></td></tr></table></figure>\n<p>当在一个线程里面调用AttachCurrentThr</p>\n","cover":null,"images":["https://cdn.julis.wang/blog/img/167c522c1dfb148f.png","https://cdn.julis.wang/blog/img/167c56e72c22fbe7.png"],"content":"<p>最近接触JNI相关的项目遇到一些与内存相关到问题，JNI或者说是C/C++开发与平时的Java开发相比，总会给人更多的“惊喜”，因为不熟悉native开发，所以有很多知识都不太清楚，一点一点地记录。<br>在掘金相关搜索到下面这篇，个人感觉还不错。<br>以下内容转载自：</p>\n<p><a href=\"https://juejin.cn/post/6844903743352209422\">https://juejin.cn/post/6844903743352209422</a></p>\n<img width=\"60%\" src=\"https://cdn.julis.wang/blog/img/167c522c1dfb148f.png\">\n<p>上面这张图大家都应该很熟了，下面只讲下和JNI有关的部分</p>\n<h4 id=\"程序计数器\"><a href=\"#程序计数器\" class=\"headerlink\" title=\"程序计数器\"></a>程序计数器</h4><p>记录正在执行的虚拟机字节码指令的地址（如果正在执行的是本地方法则为空）。</p>\n<h4 id=\"本地方法栈\"><a href=\"#本地方法栈\" class=\"headerlink\" title=\"本地方法栈\"></a>本地方法栈</h4><p>本地方法栈与 Java 虚拟机栈类似，它们之间的区别只不过是本地方法栈为本地方法服务。 本地方法一般是用其它语言（C、C++ 或汇编语言等）编写的，并且被编译为基于本机硬件和操作系统的程序，对待这些方法需要特别处理。</p>\n<h4 id=\"堆-Java-Heap\"><a href=\"#堆-Java-Heap\" class=\"headerlink\" title=\"堆(Java-Heap)\"></a>堆(Java-Heap)</h4><p>所有对象都在这里分配内存，是垃圾收集的主要区域（”GC 堆”）。 堆不需要连续内存，并且可以动态增加其内存，增加失败会抛出 OutOfMemoryError 异常。</p>\n<p>可以通过 -Xms 和 -Xmx 两个虚拟机参数来指定一个程序的堆内存大小，第一个参数设置初始值，第二个参数设置最大值。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">java -Xmx1024m -Xms1024m</span><br><span class=\"line\">//-Xmx1024m：设置JVM最大可用内存为1024M。</span><br><span class=\"line\">//-Xms1024m：设置JVM初始内存为1024m。此值可与-Xmx相同，以避免每次垃圾回收完成后JVM重新分配内存。</span><br></pre></td></tr></table></figure>\n<p>在Android系统对于每个应用都有内存使用的限制，机器的内存限制，在/system/build.prop文件中配置的。可以在manifest文件application节点加入 <code>android:largeHeap=&quot;true&quot;</code>来让Dalvik/ART虚拟机分配更大的堆内存空间</p>\n<h4 id=\"直接内存（native堆）\"><a href=\"#直接内存（native堆）\" class=\"headerlink\" title=\"直接内存（native堆）\"></a>直接内存（native堆）</h4><p>也称为C-Heap，供Java Runtime进程使用的，没有相应的参数来控制其大小，其大小依赖于操作系统进程的最大值。  Java应用程序都是在Java Runtime Environment（JRE）中运行，而Runtime本身就是由Native语言（如：C/C++）编写程序。Native Memory就是操作系统分配给Runtime进程的可用内存，它与Heap Memory不同，Java Heap 是Java应用程序的内存。。Native Memory的主要作用如下：</p>\n<ul>\n<li>管理java heap的状态数据（用于GC）;</li>\n<li>JNI调用，也就是Native Stack；</li>\n<li>JIT（即使编译器）编译时使用Native Memory，并且JIT的输入（Java字节码）和输出（可执行代码）也都是保存在Native Memory；</li>\n<li>NIO direct buffer；</li>\n<li>Threads；</li>\n<li>类加载器和类信息都是保存在Native Memory中的。</li>\n</ul>\n<h3 id=\"JNI内存\"><a href=\"#JNI内存\" class=\"headerlink\" title=\"JNI内存\"></a>JNI内存</h3><p>在Java代码中，Java对象被存放在JVM的Java Heap，由垃圾回收器（Garbage Collector，即GC）自动回收就可以。</p>\n<p> 在Native代码中，内存是从Native Memory中分配的，需要根据Native编程规范去操作内存。如：C/C++使用malloc()/new分配内存，需要手动使用free()/delete回收内存。</p>\n<p> 然而，JNI和上面两者又有些区别。 JNI提供了与Java相对应的引用类型（如：jobject、jstring、jclass、jarray、jintArray等），以便Native代码可以通过JNI函数访问到Java对象。引用所指向的Java对象通常就是存放在Java Heap，而Native代码持有的引用是存放在Native Memory中。</p>\n<p>举个例子，如下代码：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\">jstring jstr = env-&gt;<span class=\"built_in\">NewStringUTF</span>(<span class=\"string\">&quot;Hello World!&quot;</span>);</span><br></pre></td></tr></table></figure>\n<ul>\n<li>jstring类型是JNI提供的，对应于Java的String类型</li>\n<li>JNI函数<code>NewStringUTF()</code>用于构造一个String对象，该对象存放在Java Heap中，同时返回了一个jstring类型的引用。</li>\n<li>String对象的引用保存在jstr中，jstr是Native的一个局部变量，存放在Native Memory中。</li>\n</ul>\n<p>开发人员都应该遇到过OOM（Out of Memory）异常，在JNI开发中，该异常可能发生在Java Heap中，也可能发生在Native Memory中。</p>\n<ul>\n<li>string类型是JNI提供的，对应于Java的String类型</li>\n<li>JNI函数<code>NewStringUTF()</code>用于构造一个String对象，该对象存放在Java Heap中，同时返回了一个jstring类型的引用。</li>\n<li>String对象的引用保存在jstr中，jstr是Native的一个局部变量，存放在Native Memory中。</li>\n</ul>\n<p>开发人员都应该遇到过OOM（Out of Memory）异常，在JNI开发中，该异常可能发生在Java Heap中，也可能发生在Native Memory中。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">java.lang.OutOfMemoryError: Java heap space</span><br><span class=\"line\">java.lang.OutOfMemoryError: native memory exhausted</span><br></pre></td></tr></table></figure>\n<p><strong>Java Heap 中出现 Out of Memory异常的原因有两种：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">1）程序过于庞大，致使过多 Java 对象的同时存在；</span><br><span class=\"line\">2）程序编写的错误导致 Java Heap 内存泄漏。</span><br></pre></td></tr></table></figure>\n<p><strong>Native Memory中出现 Out of Memory异常的原因：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">1）程序申请过多资源，系统未能满足，比如说大量线程资源；</span><br><span class=\"line\">2）程序编写的错误导致Native Memory内存泄漏。</span><br></pre></td></tr></table></figure>\n<h3 id=\"JNI引用\"><a href=\"#JNI引用\" class=\"headerlink\" title=\"JNI引用\"></a>JNI引用</h3><p>JNI引用有三种：<code>Local Reference</code>、<code>Global Reference</code>、<code>Weak Global Reference</code>。下面分别来介绍一下这三种引用内存分配和管理。</p>\n<p><strong>Local Reference</strong></p>\n<p>只在Native Method执行时存在，只在创建它的线程有效，不能跨线程使用。它的生命期是在Native Method的执行期开始创建（从Java代码切换到Native代码环境时，或者在Native Method执行时调用JNI函数时），在Native Method执行完毕切换回Java代码时，所有Local Reference被删除（GC会回收其内存），生命期结束（调用<code>DeleteLocalRef()</code>可以提前回收内存，结束其生命期）。</p>\n<p> 实际上，每当线程从Java环境切换到Native代码环境时，JVM 会分配一块内存用于创建一个<code>Local Reference Table</code>，这个Table用来存放本次Native Method 执行中创建的所有<code>Local Reference</code>。每当在 Native代码中引用到一个Java对象时，JVM 就会在这个Table中创建一个<code>Local Reference</code>。比如，我们调用 NewStringUTF() 在 Java Heap 中创建一个 String 对象后，在 <code>Local Reference Table</code> 中就会相应新增一个 <code>Local Reference</code>。</p>\n<p>Local Reference 表、Local Reference 和 Java 对象的关系</p>\n<img src=\"https://cdn.julis.wang/blog/img/167c56e72c22fbe7.png\">\n<p>接下来举个简单例子说明一下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">jstring jstr = env-&gt;NewStringUTF(&quot;Hello World!&quot;);</span><br></pre></td></tr></table></figure>\n<ul>\n<li>jstr存放在Native Method Stack中，是一个局部变量</li>\n<li>对于开发者来说，Local Reference Table是不可见的</li>\n<li><code>Local Reference Table</code>的内存不大，所能存放<code>的Local Reference</code>数量也是有限的（在Android中默认最大容量是512个），使用不当就会引起溢出异常</li>\n<li><code>Local Reference</code>并不是Native里面的局部变量，局部变量存放在堆栈中，其引用存放在<code>Local Reference Table</code>中。</li>\n</ul>\n<p>在Native Method结束时，JVM会自动释放Local Reference，但<code>Local Reference Table</code>是有大小限制的，在开发中应该及时使用DeleteLocalRef()删除不必要的Local Reference，不然可能会出现溢出错误：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">JNI ERROR (app bug): local reference table overflow (max=512)</span><br></pre></td></tr></table></figure>\n<p>在C/C++中实例化的JNI对象，如果不返回java，必须用release掉或delete，否则内存泄露。包括NewStringUTF，NewObject。对于一般的基本数据类型（如：jint，jdouble等），是没必要调用该函数删除掉的。如果返回java不必delete，java会自己回收。</p>\n<p><strong>Global Reference</strong></p>\n<p>Local Reference是在Native Method执行的时候出现的，而<code>Global Reference</code>是通过JNI函数<code>NewGlobalRef()</code>和<code>DeleteGlobalRef()</code>来创建和删除的。 <code>Global Reference</code>具有全局性，可以在多个Native Method调用过程和多线程中使用，在主动调用DeleteGlobalRef之前，它是一直有效的（GC不会回收其内存）。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 创建obj参数所引用对象的新全局引用。obj参数既可以是全局引用，也可以是局部引用。全局引用通过调用DeleteGlobalRef()来显式撤消。</span></span><br><span class=\"line\"><span class=\"comment\"> * @param obj 全局或局部引用。</span></span><br><span class=\"line\"><span class=\"comment\"> * @return 返回全局引用。如果系统内存不足则返回 NULL。</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\">jobject <span class=\"title function_\">NewGlobalRef</span><span class=\"params\">(jobject obj)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 删除globalRef所指向的全局引用</span></span><br><span class=\"line\"><span class=\"comment\"> * @param globalRef 全局引用</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">DeleteGlobalRef</span><span class=\"params\">(jobject globalRef)</span>;</span><br></pre></td></tr></table></figure>\n<p>使用 <code>Global reference</code>时，当 native code 不再需要访问<code>Global reference</code> 时，应当调用 JNI 函数 <code>DeleteGlobalRef()</code> 删除 <code>Global reference</code>和它引用的 Java 对象。否则<code>Global Reference</code>引用的 Java 对象将永远停留在 Java Heap 中，从而导致 Java Heap 的内存泄漏。</p>\n<p><strong>Weak Global Reference</strong></p>\n<p>用<code>NewWeakGlobalRef()</code>和<code>DeleteWeakGlobalRef()</code>进行创建和删除，它与<code>Global Reference</code>的区别在于该类型的引用随时都可能被GC回收。</p>\n<p>对<code>于Weak Global Reference</code>而言，可以通过<code>isSameObject()</code>将其与NULL比较，看看是否已经被回收了。如果返回JNI_TRUE，则表示已经被回收了，需要重新初始化弱全局引用。<code>Weak Global Reference</code>的回收时机是不确定的，有可能在前一行代码判断它是可用的，后一行代码就被GC回收掉了。为了避免这事事情发生，JNI官方给出了正确的做法，通过NewLocalRef()获取<code>Weak Global Reference</code>，避免被GC回收。</p>\n<h3 id=\"注意点\"><a href=\"#注意点\" class=\"headerlink\" title=\"注意点\"></a>注意点</h3><h4 id=\"Local-Reference-不是-native-code-的局部变量\"><a href=\"#Local-Reference-不是-native-code-的局部变量\" class=\"headerlink\" title=\"Local Reference 不是 native code 的局部变量\"></a>Local Reference 不是 native code 的局部变量</h4><p>很多人会误将 JNI 中的 Local Reference 理解为 Native Code 的局部变量。这是错误的。</p>\n<p>Native Code 的局部变量和 Local Reference 是完全不同的，区别可以总结为：</p>\n<p>⑴局部变量存储在线程堆栈中，而 Local Reference 存储在 Local Ref 表中。</p>\n<p>⑵局部变量在函数退栈后被删除，而 Local Reference 在调用 DeleteLocalRef() 后才会从 Local Ref 表中删除，并且失效，或者在整个 Native Method 执行结束后被删除。</p>\n<p>⑶可以在代码中直接访问局部变量，而 Local Reference 的内容无法在代码中直接访问，必须通过 JNI function 间接访问。JNI function 实现了对 Local Reference 的间接访问，JNI function 的内部实现依赖于具体 JVM。</p>\n<h4 id=\"注意释放所有对jobject的引用：\"><a href=\"#注意释放所有对jobject的引用：\" class=\"headerlink\" title=\"注意释放所有对jobject的引用：\"></a>注意释放所有对jobject的引用：</h4><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">extern</span> <span class=\"string\">&quot;C&quot;</span></span><br><span class=\"line\">JNIEXPORT jstring JNICALL</span><br><span class=\"line\"><span class=\"title function_\">Java_com_test_application_MainActivity_init</span><span class=\"params\">(JNIEnv *env, jobject instance, jstring data,</span></span><br><span class=\"line\"><span class=\"params\">                                      jbyteArray <span class=\"built_in\">array</span>)</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">int</span> len = env-&gt;GetArrayLength(<span class=\"built_in\">array</span>);</span><br><span class=\"line\">    <span class=\"type\">const</span> <span class=\"type\">char</span> *utfChars = env-&gt;GetStringUTFChars(data, <span class=\"number\">0</span>);</span><br><span class=\"line\">    jbyte *arrayElements = env-&gt;GetByteArrayElements(<span class=\"built_in\">array</span>, <span class=\"literal\">NULL</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    jstring pJstring = env-&gt;NewStringUTF(utfChars); </span><br><span class=\"line\"></span><br><span class=\"line\">    jbyteArray jpicArray = env-&gt;NewByteArray(len);</span><br><span class=\"line\">    env-&gt;SetByteArrayRegion(jpicArray, <span class=\"number\">0</span>, len, arrayElements);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// TODO</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    env-&gt;DeleteLocalRef(pJstring);</span><br><span class=\"line\">    env-&gt;DeleteLocalRef(jpicArray);</span><br><span class=\"line\"></span><br><span class=\"line\">    env-&gt;ReleaseStringUTFChars(data, utfChars);</span><br><span class=\"line\">    env-&gt;ReleaseByteArrayElements(<span class=\"built_in\">array</span>, arrayElements, <span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> hello = <span class=\"string\">&quot;Hello from C++&quot;</span>;</span><br><span class=\"line\">    jstring result = env-&gt;NewStringUTF(hello.c_str());</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>其它的还有：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">jclass ref= (env)-&gt;FindClass(&quot;java/lang/String&quot;);</span><br><span class=\"line\"> </span><br><span class=\"line\">env-&gt;DeleteLocalRef(ref);</span><br><span class=\"line\">复制代码</span><br></pre></td></tr></table></figure>\n<p>因为根据<code>jni.h</code>里的定义：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> jobject         jclass;</span><br></pre></td></tr></table></figure>\n<p>jclass也是jobject。而<code>jmethodID</code>/<code>jfielID</code>和jobject没有继承关系，它们不是object,只是个整数，不存在被释放与否的问题。</p>\n<h4 id=\"局部引用和全局引用的转换\"><a href=\"#局部引用和全局引用的转换\" class=\"headerlink\" title=\"局部引用和全局引用的转换\"></a>局部引用和全局引用的转换</h4><p>注意Local Reference的生命周期，如果在Native中需要长时间持有一个Java对象，就不能使用将jobject存储在Native，否则在下次使用的时候，即使同一个线程调用，也将会无法使用。下面是错误的做法：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\">jstring global;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">extern</span> <span class=\"string\">&quot;C&quot;</span> JNIEXPORT jstring JNICALL</span><br><span class=\"line\"><span class=\"title function_\">Java_org_hik_libyuv_MainActivity_stringFromJNI</span><span class=\"params\">(</span></span><br><span class=\"line\"><span class=\"params\">        JNIEnv *env,</span></span><br><span class=\"line\"><span class=\"params\">        jobject <span class=\"comment\">/* this */</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> hello = <span class=\"string\">&quot;Hello from C++&quot;</span>;</span><br><span class=\"line\">    jstring local = env-&gt;NewStringUTF(hello.c_str());</span><br><span class=\"line\">    global = local;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> local;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>正确的做法是使用Global Reference，如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\">jstring global;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">extern</span> <span class=\"string\">&quot;C&quot;</span> JNIEXPORT jstring JNICALL</span><br><span class=\"line\"><span class=\"title function_\">Java_org_hik_libyuv_MainActivity_stringFromJNI</span><span class=\"params\">(</span></span><br><span class=\"line\"><span class=\"params\">        JNIEnv *env,</span></span><br><span class=\"line\"><span class=\"params\">        jobject <span class=\"comment\">/* this */</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> hello = <span class=\"string\">&quot;Hello from C++&quot;</span>;</span><br><span class=\"line\">    jstring local = env-&gt;NewStringUTF(hello.c_str());</span><br><span class=\"line\">    global = static_cast&lt;jstring&gt;(env-&gt;NewGlobalRef(global));</span><br><span class=\"line\">    <span class=\"keyword\">return</span> local;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"多线程\"><a href=\"#多线程\" class=\"headerlink\" title=\"多线程\"></a>多线程</h4><p>JNIEnv和jobject对象都不能跨线程使用。 对于jobject，解决办法是</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\">a、m_obj = env-&gt;NewGlobalRef(obj);<span class=\"comment\">//创建一个全局变量  </span></span><br><span class=\"line\"></span><br><span class=\"line\">b、jobject obj = env-&gt;AllocObject(m_cls);<span class=\"comment\">//在每个线程中都生成一个对象</span></span><br></pre></td></tr></table></figure>\n<p>对于JNIEnv，解决办法是在每个线程中都重新生成一个env</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\">JavaVM *gJavaVM;<span class=\"comment\">//声明全局变量</span></span><br><span class=\"line\">(*env)-&gt;GetJavaVM(env, &amp;gJavaVM);<span class=\"comment\">//在JNI方法的中赋值</span></span><br><span class=\"line\"></span><br><span class=\"line\">JNIEnv *env;<span class=\"comment\">//在其它线程中获取当前线程的env  </span></span><br><span class=\"line\">m_jvm-&gt;AttachCurrentThread((<span class=\"type\">void</span> **)&amp;env, <span class=\"literal\">NULL</span>);  </span><br></pre></td></tr></table></figure>\n<p>当在一个线程里面调用AttachCurrentThr</p>\n","categories":[{"name":"技术文章","slug":"technology","api":"api/categories/technology.json"}],"tags":[{"name":"Android","slug":"Android","api":"api/tags/Android.json"},{"name":"JNI","slug":"JNI","api":"api/tags/JNI.json"}],"api":"api/posts/2021/03/10/JNI内存管理及优化.json"},{"title":"{已开源} 阅文 Flutter 混合开发利器 MixStack","slug":"MixStack","date":"2021-02-26T12:56:00.000Z","updated":"2025-05-20T11:46:57.000Z","comments":true,"url":"2021/02/26/MixStack/","excerpt":"<p>原文发表于 阅文技术公众号 <a href=\"https://mp.weixin.qq.com/s?__biz=MzIxMzgxMjQ1Mw==&amp;mid=2247483918&amp;idx=1&amp;sn=1a09f803ed543b11a3d4255fb28ee854&amp;chksm=97b05784a0c7de9265fd6c5690e46f5f8cd68ffd1f9d85c0263c3b28d06936f08fc6034ab3c8&amp;mpshare=1&amp;scene=1&amp;srcid=0310R2s6SjdCsrAvUwXNBoo3&amp;sharer_sharetime=1615366421433&amp;sharer_shareid=f9805455f7ec45f0ab87cd8190bfce47&amp;version=3.1.1.6192&amp;platform=mac#rd\">《{已开源} 阅文 Flutter 混合开发利器 MixStack》</a></p>\n<p>Github开源地址：<a href=\"https://github.com/yuewen/mix_stack\">MixStack</a></p>\n<p>MixStack混合栈是我当时刚进入公司不久参与的该项目，对于混合栈的开发说起来很简单，但踩了无数的坑，经常被各种神奇的bug和场景折腾得睡不好觉。还好，最终都挺过来了，项目从启动到开源最后再到文章，不知道被老大哥喷了多少遍，可以说这是我工作生涯中，灰暗而又有收获，非常有意义的一段时间，遂记录该文章于博客。</p>\n<h2 id=\"一、前言\"><a href=\"#一、前言\" class=\"headerlink\" title=\"一、前言\"></a><strong>一、前言</strong></h2><p>Flutter 是一款谷歌的移动 UI 框架，可以快速在 iOS 和 Android 上构建高质量的原生用户界面。Flutter 可以与现有的代码一起工作，相比于其他跨平台的框架，如 React Native、Weex 等，Flutter 具有如下的优势：跨平台表现一致 谷歌直接在 iOS/Android 等平台直接建立了独立的渲染引擎，保证了界面渲染的高效且多端有接近原生性能的表现。快速开发 开发过程中提供了高效的热重载，开发便捷。已有工具链已经比较强大。</p>\n<h2 id=\"二、随之而来的问题\"><a href=\"#二、随之而来的问题\" class=\"headerlink\" title=\"二、随之而来的问题\"></a><strong>二、随之而来的问题</strong></h2><p>当我们尝试将 Flutter 集成到项目中的时候，却发现现实比想象骨感许多，这里我们以 Android 平台的探索为例进行说明。</p>\n<p>对于 Android 平台，官方封装了 FlutterAcitivity 以及 FlutterFragment 两种 Flutter 原生容器，当我们直接使用时，能正常打开 Flutter 页面，但是表现却并不如我们所期待。</p>\n<p>其中最明显的就是，官方会为每个  FlutterAcitivity 和 FlutterFragment 生成一个新的 FlutterEngine 实例。每个 FlutterEngine 拥有不同的 Isolate，也就是说不同的 Dart 运行环境完全独立，其内存状态不进行共享。对于大多数 App 来说，多数页面有一些全局状态（例如登录态）。如果基于 Flutter 默认的设计，两个不同容器里的 Flutter 页面通信将变得异常复杂。另外每个 FlutterEngine 实例的内存开销本身就非常大，例如同一张图片由于内存状态不共享，在 n 个 Engine 中会存在 n 份，这显然是不可接受的。</p>\n<p>这就是当我们想把 Flutter 与现有业务代码混合使用时会遇到的 </p>\n<p><strong>问题1：多 FlutterEngine 实例间内存状态不共享</strong></p>\n<p>对于多 FlutterEngine 实例带来的问题远不止这些，官方提供给了我们一种解决方案：共享 FlutterEngine，全局只有一个 FlutterEngine 实例，将其放入缓存管理中。当我们尝试使用这种方案连续打开两个 FlutterActivity，页面却会冻住，停止渲染.</p>\n<p><strong>问题2：Flutter 原生容器在共享 FlutterEngine 情况下渲染生命周期错误</strong></p>\n<img width=\"50%\" src=\"https://cdn.julis.wang/blog/img/uZyfcSvc6dDWlHKEDdDRlXUp6.gif\">\n<p>另外，在业务场景中，常有类似这样的页面跳转情况：Native Activity-&gt;Flutter Activity-&gt;Native Activity-&gt;Flutter Activity-&gt;Native Activity ，其中 Flutter Activity 中拥有几个不同的 Flutter Page，如下图所示：<br><img src=\"https://cdn.julis.wang/blog/img/up-d9cffa0f953425a54c3c7e27a61b543e4c4.png\"></p>\n<p>对于 FlutteActivity 或者 FlutterFragment 中的 Flutter 页面来说我们需要将其与原生页面对齐，页面栈变成下图会更容理解：</p>\n<img src=\"https://cdn.julis.wang/blog/img/a89a79a943946376e40b2c8905631f55cae.png\">\n<p>当我们处于 FlutterActivity A 中页面时，对于一些业务场景有顶部 NavigationBar、Back 按键以及手势返回的时候，用户基于常见的栈“先进后出”的原则，对于 FlutterActivity A 中的页面，期望的是先关闭掉其最上层的 Flutter 页面，再依次关闭f3、f2、f1。最终关闭掉该 FlutterActivity 展示 Natvie Activity A。然而实际的情况是：如果不修改相关逻辑，会直接 finish 掉整个 Activity，那么f1、f2、f3……会被同时关闭。</p>\n<p><strong>问题3：Flutter 原生容器中 Flutter 页面栈管理与预期不符</strong></p>\n<img src=\"https://cdn.julis.wang/blog/img/ib5o50a83cSUkvFIDkI7qVb.gif\">\n<p>在每个 FlutterActivity 中存在一个 FlutterView，FlutterView 承载了不同的 Flutter 页面也就是不同的 FlutterWidget，其Flutter 内部不同的 Widget 可以通过Navigator控制，我们需要将其做到与原生对齐，形成一套用户无感，开发者较浅感知的页面栈管理方案。</p>\n<p>随着深入了解会发现更多的问题，页面切换闪屏、App 启动白屏、Flutter Dialog 展示底部白屏、状态栏高度颜色不正确等等等等。</p>\n<h2 id=\"三、解决方案\"><a href=\"#三、解决方案\" class=\"headerlink\" title=\"三、解决方案\"></a><strong>三、解决方案</strong></h2><p>业内 Flutter 混合栈的研究已经开始很久了，但仍没有一款真正的完美解决方案，我们希望这次推出的 MixStack 是这样的方案。经过一系列的探索，我们解决了上述问题，并在实际上线的 App 红袖中进行了验证，取得了较好的效果。</p>\n<p>接下来具体讲解MixStack的实现</p>\n<p><strong>1.共享FlutterEngine</strong></p>\n<p>为了解决问题1：多 FlutterEngine 实例间内存状态不共享，我们选择对 FlutterEngine 进行共享，保持全局只有一个 FlutterEngine。</p>\n<p>这样使得所有相关操作都在同一个Isolate，对于之前所说的全局状态（例如登录态）以及类似同一份图片缓存存在多份的问题也就迎刃而解了。</p>\n<p><strong>2.正确的渲染生命周期</strong></p>\n<p>关于问题2：Flutter 原生容器在共享    FlutterEngine 情况下渲染生命周期错误。默认的 FlutterActivity 和 FlutterFragment 对于共享 FlutterEngine 的支持不太好，我们对其进行了相关修改。基于任何时候只能看到一个  Flutter 原生容器的假设，且 FlutterEngine 同一时刻也只能渲染一个 FlutterView，因此我们约定：对每一个 FlutterView 在可见的时候对其进行渲染相关的准备，在即将不可见的时候使其从渲染上脱离。那该如何实现 Flutter 原生容器顺畅交互呢？我们先看两个容器间切换的生命周期，通常情况下 Activity A 启动   Activity B 生命周期如下图所示：</p>\n<ul>\n<li><p><img width=\"60%\" src=\"https://cdn.julis.wang/blog/img/up-2347df7b78fcbf33c262fa93247c802ea3c.png\"> FlutterEngine 在原生层面定义了LifecycleChannel，主要作用是向 Flutter 发送渲染生命周期相关的事件。LifecycleChannel主要发送了四种状态事件：</p>\n</li>\n<li><ol>\n<li>AppLifecycleState.resumed、</li>\n</ol>\n</li>\n<li><ol>\n<li>AppLifecycleState.inactive、</li>\n</ol>\n</li>\n<li><ol>\n<li>AppLifecycleState.paused、</li>\n</ol>\n</li>\n<li><ol>\n<li>AppLifecycleState.detached。</li>\n</ol>\n</li>\n<li><p>阅读源码后可知，FlutterEngine 在   AppLifecycleState.resumed 执行了启动渲染的操作。</p>\n</li>\n<li><p>而 AppLifecycleState.paused、    AppLifecycleState.detached停止了渲染操作，也就是说处于这两个生命周期中，页面内的内容不会被重绘。</p>\n</li>\n<li><p>那么我们可知要使 FlutterEngine 渲染交互正常需要满足以下要求：</p>\n</li>\n<li><p><strong>(1) FlutterEngine 生命周期处于  AppLifecycleState.resumed</strong></p>\n</li>\n<li><p><strong>(2) FlutterEngine attach 在当前可见的  FlutterView</strong></p>\n</li>\n<li><p>那么对于 FlutterActivity，只需在   FlutterActivity onResume() 的时候执行以上操作，使得 FlutterEngine 能够渲染当前页面。当 FlutterActivity 需要启动另一个    FlutterActivity 时，FlutterEngine 需要将其从当前 FlutterView detach 并停止渲染。整个流程如下图所示：</p>\n</li>\n<li><img src=\"https://cdn.julis.wang/blog/img/0a28bd5cc8b4b01c57e9388bccca6212306.png\">\n</li>\n<li><p>同理，FlutterActivity 打开原生的 Activity 的时候，我们依然需要在 onPause() 的时候，对 FlutterView 进行 detach 操作，保证在新打开原生 Activity 之后，如有再打开的其他的  FlutterActivity 也能够维护正常生命周期。</p>\n</li>\n<li><p>在多数 App 中都有 Tab 类的界面，一般都是：NavigationBar 加 Fragment 的组合，那当这种场景中混合了多个 FlutterFragment，我们又该如何做呢，Fragment组合如下图所示：</p>\n</li>\n<li><img src=\"https://cdn.julis.wang/blog/img/8ee758f66c0a7e6944d250ecf29703e44bf.png\">\n</li>\n<li><p>我们同样基于之前的假设，在    FlutterFragment onResume() 的时候，attach 到FlutterEngine，使得 FlutterEngine 能够渲染当前页面，onPause 的时候 detach。</p>\n</li>\n<li><p>对于多个 Tab 之间 FlutterFragment 的切换，只多了一步操作，在 onHiddenChanged() 的时候，对 FlutterEngine 进行相应的操作，需要留意的是，在 onPause() 或者  onResume() 操作的时候需要添加  isHidden() 判断，保证当前渲染的是可见的那个 FlutterFragment。</p>\n</li>\n<li><p>FlutterFragment 的渲染流程如下图所示：</p>\n<img src=\"https://cdn.julis.wang/blog/img/4e211bbd06e222dc3e8849e884973905292.png\">\n</li>\n<li><p>至此我们成功地解决了问题2：原生 Flutter 容器在共享 FlutterEngine 情况下渲染生命周期错误</p>\n</li>\n<li><p><strong>(3) Flutter 页面相关的约定</strong></p>\n</li>\n<li><p>前面两点的实现，使我们能够成功让 Flutter 原生容器如正常原生页面一般使用，但依然有问题3：原生 Flutter 容器中 Flutter 页面栈管理与预期不符 未解决。为了解决问题3, 我们需要额外增加一些约定，将每一个原生栈中的 Flutter 原生容器映射为 Flutter 中的一个容器，我们称为 PageContainer。</p>\n</li>\n<li><p>如下图所示：</p>\n</li>\n</ul>\n<img src=\"https://cdn.julis.wang/blog/img/20210310195300378.png\">\n<p>每个 PageContainer 有以下特性：</p>\n<p>1、包含独立 Navigator，PageContainer 间互不影响</p>\n<p>2、有一个根页面，通过根路径（rootRoute）形式传入</p>\n<p>在每个 Flutter 原生容器实现接口传入 rootRoute 属性，在页面可见的时候，MixStack 会向 Flutter 通信，告知即将显示的页面。</p>\n<p>3、默认对于原生环境的 Inset 无感，通过额外 API 传入（降低性能开销）</p>\n<p>Flutter 对于渲染画布的尺寸变化非常敏感，某些情况下会导致 Widget 状态异常，例如 Tab 滑动位置丢失等等问题，所以 MixStack 默认为 Flutter View 尺寸不变化，推荐将影响 View 内 Flutter 组件排版的 inset 变化通过 API 传入。</p>\n<p>MixStack 基于 Channel 通信告知 Flutter 当前所有页面信息 (pages) 及当前需要显示 Flutter 页面 (currentPage)，Flutter 基于信息更新 Widget。每个 PageContainer 与 Flutter 原生容器的 hashCode 有唯一映射关系，从而保证页面状态持久化。</p>\n<p>另外我们在 iOS 和 Android 上接管了返回指令，并与 Flutter 端进行同步，满足返回预期。</p>\n<p>最后的效果就如我们所期望的：</p>\n<img width=\"50%\" src=\"https://cdn.julis.wang/blog/img/dDRlXUp6dKDoS4NRN5typNux5sz2rvzz0fX.gif\">\n<h2 id=\"四、总结\"><a href=\"#四、总结\" class=\"headerlink\" title=\"四、总结\"></a><strong>四、总结</strong></h2><p>至此我们解决了上述三大问题，构建出了一套能够正确维护原生⻚面与 Flutter ⻚面交互的完整解决方案。</p>\n<p>当然关于项目中集成使用 Flutter 所带来的麻烦并不局限于上述问题，Flutter 本身也存在一些 Bug，MixStack 已经将相关的问题在库内解决或者提交官方补丁。经过线上 App 的实际验证，对首⻚多FlutterFragment 、 Flutter 各种弹窗 、各种 Flutter 容器与原生之间的切换等情况均表现正常。</p>\n<p>目前 MixStack 已经全量在阅文旗下红袖 App 上使用，他们在极短时间内借助 MixStack 能力平滑移除了对 RN 的依赖，同时仍正常交付日常功能需求。</p>\n<p>一款成熟的 App 将现有的⻚面完全转化为 Flutter ⻚面，改造的成本太大，周期太⻓，或者有一些业务场景⻚面需要 Native 的能力，需要一个能方便管理原生与 Flutter 混合⻚面的管理工具，那么 MixStack 将是一个非常好的选择。</p>\n","cover":null,"images":["https://cdn.julis.wang/blog/img/uZyfcSvc6dDWlHKEDdDRlXUp6.gif","https://cdn.julis.wang/blog/img/up-d9cffa0f953425a54c3c7e27a61b543e4c4.png","https://cdn.julis.wang/blog/img/a89a79a943946376e40b2c8905631f55cae.png","https://cdn.julis.wang/blog/img/ib5o50a83cSUkvFIDkI7qVb.gif","https://cdn.julis.wang/blog/img/up-2347df7b78fcbf33c262fa93247c802ea3c.png","https://cdn.julis.wang/blog/img/0a28bd5cc8b4b01c57e9388bccca6212306.png","https://cdn.julis.wang/blog/img/8ee758f66c0a7e6944d250ecf29703e44bf.png","https://cdn.julis.wang/blog/img/4e211bbd06e222dc3e8849e884973905292.png","https://cdn.julis.wang/blog/img/20210310195300378.png","https://cdn.julis.wang/blog/img/dDRlXUp6dKDoS4NRN5typNux5sz2rvzz0fX.gif"],"content":"<p>原文发表于 阅文技术公众号 <a href=\"https://mp.weixin.qq.com/s?__biz=MzIxMzgxMjQ1Mw==&amp;mid=2247483918&amp;idx=1&amp;sn=1a09f803ed543b11a3d4255fb28ee854&amp;chksm=97b05784a0c7de9265fd6c5690e46f5f8cd68ffd1f9d85c0263c3b28d06936f08fc6034ab3c8&amp;mpshare=1&amp;scene=1&amp;srcid=0310R2s6SjdCsrAvUwXNBoo3&amp;sharer_sharetime=1615366421433&amp;sharer_shareid=f9805455f7ec45f0ab87cd8190bfce47&amp;version=3.1.1.6192&amp;platform=mac#rd\">《{已开源} 阅文 Flutter 混合开发利器 MixStack》</a></p>\n<p>Github开源地址：<a href=\"https://github.com/yuewen/mix_stack\">MixStack</a></p>\n<p>MixStack混合栈是我当时刚进入公司不久参与的该项目，对于混合栈的开发说起来很简单，但踩了无数的坑，经常被各种神奇的bug和场景折腾得睡不好觉。还好，最终都挺过来了，项目从启动到开源最后再到文章，不知道被老大哥喷了多少遍，可以说这是我工作生涯中，灰暗而又有收获，非常有意义的一段时间，遂记录该文章于博客。</p>\n<h2 id=\"一、前言\"><a href=\"#一、前言\" class=\"headerlink\" title=\"一、前言\"></a><strong>一、前言</strong></h2><p>Flutter 是一款谷歌的移动 UI 框架，可以快速在 iOS 和 Android 上构建高质量的原生用户界面。Flutter 可以与现有的代码一起工作，相比于其他跨平台的框架，如 React Native、Weex 等，Flutter 具有如下的优势：跨平台表现一致 谷歌直接在 iOS/Android 等平台直接建立了独立的渲染引擎，保证了界面渲染的高效且多端有接近原生性能的表现。快速开发 开发过程中提供了高效的热重载，开发便捷。已有工具链已经比较强大。</p>\n<h2 id=\"二、随之而来的问题\"><a href=\"#二、随之而来的问题\" class=\"headerlink\" title=\"二、随之而来的问题\"></a><strong>二、随之而来的问题</strong></h2><p>当我们尝试将 Flutter 集成到项目中的时候，却发现现实比想象骨感许多，这里我们以 Android 平台的探索为例进行说明。</p>\n<p>对于 Android 平台，官方封装了 FlutterAcitivity 以及 FlutterFragment 两种 Flutter 原生容器，当我们直接使用时，能正常打开 Flutter 页面，但是表现却并不如我们所期待。</p>\n<p>其中最明显的就是，官方会为每个  FlutterAcitivity 和 FlutterFragment 生成一个新的 FlutterEngine 实例。每个 FlutterEngine 拥有不同的 Isolate，也就是说不同的 Dart 运行环境完全独立，其内存状态不进行共享。对于大多数 App 来说，多数页面有一些全局状态（例如登录态）。如果基于 Flutter 默认的设计，两个不同容器里的 Flutter 页面通信将变得异常复杂。另外每个 FlutterEngine 实例的内存开销本身就非常大，例如同一张图片由于内存状态不共享，在 n 个 Engine 中会存在 n 份，这显然是不可接受的。</p>\n<p>这就是当我们想把 Flutter 与现有业务代码混合使用时会遇到的 </p>\n<p><strong>问题1：多 FlutterEngine 实例间内存状态不共享</strong></p>\n<p>对于多 FlutterEngine 实例带来的问题远不止这些，官方提供给了我们一种解决方案：共享 FlutterEngine，全局只有一个 FlutterEngine 实例，将其放入缓存管理中。当我们尝试使用这种方案连续打开两个 FlutterActivity，页面却会冻住，停止渲染.</p>\n<p><strong>问题2：Flutter 原生容器在共享 FlutterEngine 情况下渲染生命周期错误</strong></p>\n<img width=\"50%\" src=\"https://cdn.julis.wang/blog/img/uZyfcSvc6dDWlHKEDdDRlXUp6.gif\">\n<p>另外，在业务场景中，常有类似这样的页面跳转情况：Native Activity-&gt;Flutter Activity-&gt;Native Activity-&gt;Flutter Activity-&gt;Native Activity ，其中 Flutter Activity 中拥有几个不同的 Flutter Page，如下图所示：<br><img src=\"https://cdn.julis.wang/blog/img/up-d9cffa0f953425a54c3c7e27a61b543e4c4.png\"></p>\n<p>对于 FlutteActivity 或者 FlutterFragment 中的 Flutter 页面来说我们需要将其与原生页面对齐，页面栈变成下图会更容理解：</p>\n<img src=\"https://cdn.julis.wang/blog/img/a89a79a943946376e40b2c8905631f55cae.png\">\n<p>当我们处于 FlutterActivity A 中页面时，对于一些业务场景有顶部 NavigationBar、Back 按键以及手势返回的时候，用户基于常见的栈“先进后出”的原则，对于 FlutterActivity A 中的页面，期望的是先关闭掉其最上层的 Flutter 页面，再依次关闭f3、f2、f1。最终关闭掉该 FlutterActivity 展示 Natvie Activity A。然而实际的情况是：如果不修改相关逻辑，会直接 finish 掉整个 Activity，那么f1、f2、f3……会被同时关闭。</p>\n<p><strong>问题3：Flutter 原生容器中 Flutter 页面栈管理与预期不符</strong></p>\n<img src=\"https://cdn.julis.wang/blog/img/ib5o50a83cSUkvFIDkI7qVb.gif\">\n<p>在每个 FlutterActivity 中存在一个 FlutterView，FlutterView 承载了不同的 Flutter 页面也就是不同的 FlutterWidget，其Flutter 内部不同的 Widget 可以通过Navigator控制，我们需要将其做到与原生对齐，形成一套用户无感，开发者较浅感知的页面栈管理方案。</p>\n<p>随着深入了解会发现更多的问题，页面切换闪屏、App 启动白屏、Flutter Dialog 展示底部白屏、状态栏高度颜色不正确等等等等。</p>\n<h2 id=\"三、解决方案\"><a href=\"#三、解决方案\" class=\"headerlink\" title=\"三、解决方案\"></a><strong>三、解决方案</strong></h2><p>业内 Flutter 混合栈的研究已经开始很久了，但仍没有一款真正的完美解决方案，我们希望这次推出的 MixStack 是这样的方案。经过一系列的探索，我们解决了上述问题，并在实际上线的 App 红袖中进行了验证，取得了较好的效果。</p>\n<p>接下来具体讲解MixStack的实现</p>\n<p><strong>1.共享FlutterEngine</strong></p>\n<p>为了解决问题1：多 FlutterEngine 实例间内存状态不共享，我们选择对 FlutterEngine 进行共享，保持全局只有一个 FlutterEngine。</p>\n<p>这样使得所有相关操作都在同一个Isolate，对于之前所说的全局状态（例如登录态）以及类似同一份图片缓存存在多份的问题也就迎刃而解了。</p>\n<p><strong>2.正确的渲染生命周期</strong></p>\n<p>关于问题2：Flutter 原生容器在共享    FlutterEngine 情况下渲染生命周期错误。默认的 FlutterActivity 和 FlutterFragment 对于共享 FlutterEngine 的支持不太好，我们对其进行了相关修改。基于任何时候只能看到一个  Flutter 原生容器的假设，且 FlutterEngine 同一时刻也只能渲染一个 FlutterView，因此我们约定：对每一个 FlutterView 在可见的时候对其进行渲染相关的准备，在即将不可见的时候使其从渲染上脱离。那该如何实现 Flutter 原生容器顺畅交互呢？我们先看两个容器间切换的生命周期，通常情况下 Activity A 启动   Activity B 生命周期如下图所示：</p>\n<ul>\n<li><p><img width=\"60%\" src=\"https://cdn.julis.wang/blog/img/up-2347df7b78fcbf33c262fa93247c802ea3c.png\"> FlutterEngine 在原生层面定义了LifecycleChannel，主要作用是向 Flutter 发送渲染生命周期相关的事件。LifecycleChannel主要发送了四种状态事件：</p>\n</li>\n<li><ol>\n<li>AppLifecycleState.resumed、</li>\n</ol>\n</li>\n<li><ol>\n<li>AppLifecycleState.inactive、</li>\n</ol>\n</li>\n<li><ol>\n<li>AppLifecycleState.paused、</li>\n</ol>\n</li>\n<li><ol>\n<li>AppLifecycleState.detached。</li>\n</ol>\n</li>\n<li><p>阅读源码后可知，FlutterEngine 在   AppLifecycleState.resumed 执行了启动渲染的操作。</p>\n</li>\n<li><p>而 AppLifecycleState.paused、    AppLifecycleState.detached停止了渲染操作，也就是说处于这两个生命周期中，页面内的内容不会被重绘。</p>\n</li>\n<li><p>那么我们可知要使 FlutterEngine 渲染交互正常需要满足以下要求：</p>\n</li>\n<li><p><strong>(1) FlutterEngine 生命周期处于  AppLifecycleState.resumed</strong></p>\n</li>\n<li><p><strong>(2) FlutterEngine attach 在当前可见的  FlutterView</strong></p>\n</li>\n<li><p>那么对于 FlutterActivity，只需在   FlutterActivity onResume() 的时候执行以上操作，使得 FlutterEngine 能够渲染当前页面。当 FlutterActivity 需要启动另一个    FlutterActivity 时，FlutterEngine 需要将其从当前 FlutterView detach 并停止渲染。整个流程如下图所示：</p>\n</li>\n<li><img src=\"https://cdn.julis.wang/blog/img/0a28bd5cc8b4b01c57e9388bccca6212306.png\">\n</li>\n<li><p>同理，FlutterActivity 打开原生的 Activity 的时候，我们依然需要在 onPause() 的时候，对 FlutterView 进行 detach 操作，保证在新打开原生 Activity 之后，如有再打开的其他的  FlutterActivity 也能够维护正常生命周期。</p>\n</li>\n<li><p>在多数 App 中都有 Tab 类的界面，一般都是：NavigationBar 加 Fragment 的组合，那当这种场景中混合了多个 FlutterFragment，我们又该如何做呢，Fragment组合如下图所示：</p>\n</li>\n<li><img src=\"https://cdn.julis.wang/blog/img/8ee758f66c0a7e6944d250ecf29703e44bf.png\">\n</li>\n<li><p>我们同样基于之前的假设，在    FlutterFragment onResume() 的时候，attach 到FlutterEngine，使得 FlutterEngine 能够渲染当前页面，onPause 的时候 detach。</p>\n</li>\n<li><p>对于多个 Tab 之间 FlutterFragment 的切换，只多了一步操作，在 onHiddenChanged() 的时候，对 FlutterEngine 进行相应的操作，需要留意的是，在 onPause() 或者  onResume() 操作的时候需要添加  isHidden() 判断，保证当前渲染的是可见的那个 FlutterFragment。</p>\n</li>\n<li><p>FlutterFragment 的渲染流程如下图所示：</p>\n<img src=\"https://cdn.julis.wang/blog/img/4e211bbd06e222dc3e8849e884973905292.png\">\n</li>\n<li><p>至此我们成功地解决了问题2：原生 Flutter 容器在共享 FlutterEngine 情况下渲染生命周期错误</p>\n</li>\n<li><p><strong>(3) Flutter 页面相关的约定</strong></p>\n</li>\n<li><p>前面两点的实现，使我们能够成功让 Flutter 原生容器如正常原生页面一般使用，但依然有问题3：原生 Flutter 容器中 Flutter 页面栈管理与预期不符 未解决。为了解决问题3, 我们需要额外增加一些约定，将每一个原生栈中的 Flutter 原生容器映射为 Flutter 中的一个容器，我们称为 PageContainer。</p>\n</li>\n<li><p>如下图所示：</p>\n</li>\n</ul>\n<img src=\"https://cdn.julis.wang/blog/img/20210310195300378.png\">\n<p>每个 PageContainer 有以下特性：</p>\n<p>1、包含独立 Navigator，PageContainer 间互不影响</p>\n<p>2、有一个根页面，通过根路径（rootRoute）形式传入</p>\n<p>在每个 Flutter 原生容器实现接口传入 rootRoute 属性，在页面可见的时候，MixStack 会向 Flutter 通信，告知即将显示的页面。</p>\n<p>3、默认对于原生环境的 Inset 无感，通过额外 API 传入（降低性能开销）</p>\n<p>Flutter 对于渲染画布的尺寸变化非常敏感，某些情况下会导致 Widget 状态异常，例如 Tab 滑动位置丢失等等问题，所以 MixStack 默认为 Flutter View 尺寸不变化，推荐将影响 View 内 Flutter 组件排版的 inset 变化通过 API 传入。</p>\n<p>MixStack 基于 Channel 通信告知 Flutter 当前所有页面信息 (pages) 及当前需要显示 Flutter 页面 (currentPage)，Flutter 基于信息更新 Widget。每个 PageContainer 与 Flutter 原生容器的 hashCode 有唯一映射关系，从而保证页面状态持久化。</p>\n<p>另外我们在 iOS 和 Android 上接管了返回指令，并与 Flutter 端进行同步，满足返回预期。</p>\n<p>最后的效果就如我们所期望的：</p>\n<img width=\"50%\" src=\"https://cdn.julis.wang/blog/img/dDRlXUp6dKDoS4NRN5typNux5sz2rvzz0fX.gif\">\n<h2 id=\"四、总结\"><a href=\"#四、总结\" class=\"headerlink\" title=\"四、总结\"></a><strong>四、总结</strong></h2><p>至此我们解决了上述三大问题，构建出了一套能够正确维护原生⻚面与 Flutter ⻚面交互的完整解决方案。</p>\n<p>当然关于项目中集成使用 Flutter 所带来的麻烦并不局限于上述问题，Flutter 本身也存在一些 Bug，MixStack 已经将相关的问题在库内解决或者提交官方补丁。经过线上 App 的实际验证，对首⻚多FlutterFragment 、 Flutter 各种弹窗 、各种 Flutter 容器与原生之间的切换等情况均表现正常。</p>\n<p>目前 MixStack 已经全量在阅文旗下红袖 App 上使用，他们在极短时间内借助 MixStack 能力平滑移除了对 RN 的依赖，同时仍正常交付日常功能需求。</p>\n<p>一款成熟的 App 将现有的⻚面完全转化为 Flutter ⻚面，改造的成本太大，周期太⻓，或者有一些业务场景⻚面需要 Native 的能力，需要一个能方便管理原生与 Flutter 混合⻚面的管理工具，那么 MixStack 将是一个非常好的选择。</p>\n","categories":[{"name":"技术文章","slug":"technology","api":"api/categories/technology.json"}],"tags":[{"name":"Flutter","slug":"Flutter","api":"api/tags/Flutter.json"}],"api":"api/posts/2021/02/26/MixStack.json"}],"info":{"type":"archive","year":2021}},"api":"api/archives/2021/page.1.json"}