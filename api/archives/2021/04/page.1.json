{"data":{"index":1,"total":1,"posts":[{"title":"Flutter FFI实践","slug":"FlutterFFI实践","date":"2021-04-18T02:34:00.000Z","updated":"2025-05-20T11:46:57.000Z","comments":true,"url":"2021/04/18/FlutterFFI实践/","excerpt":"<p>在 Android的开发中，我们有 <a href=\"https://developer.android.com/training/articles/perf-jni\">JNI</a> 使得 Java可以调用本地应用或库。<br>Flutter 在前不久发布了 <a href=\"https://developers.googleblog.com/2021/03/announcing-flutter-2.html\">Flutter2</a>，更新了 <a href=\"https://dart.dev/guides/libraries/c-interop\">FFI</a> (我们是否可以把它叫做DNI呢？)进入了稳定状态,开发者可以更安心的使用其功能。<br>但是相关的文档依然很欠缺，导致使用起来有诸多的疑问，以及相关原理性的介绍比较少，所以整理记录一下。</p>\n<h2 id=\"一、Dart-同步调用-Native-方法\"><a href=\"#一、Dart-同步调用-Native-方法\" class=\"headerlink\" title=\"一、Dart 同步调用 Native 方法\"></a>一、Dart 同步调用 Native 方法</h2><p>我们以最简单的demo为例,请求一个有参无返回值的C方法<br>在 C/C++中有如下函数：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">extern</span> <span class=\"string\">&quot;C&quot;</span> __attribute__((visibility(<span class=\"string\">&quot;default&quot;</span>))) __attribute__((used))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">c_with_out_return_value</span><span class=\"params\">(<span class=\"type\">int</span> value)</span> &#123;</span><br><span class=\"line\">    LOG_D(<span class=\"string\">&quot;Got invoke value: %d&quot;</span>, value);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Dart:</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">final</span> DynamicLibrary ffiLib = Platform.isAndroid ? DynamicLibrary.open(<span class=\"string\">&#x27;lib_invoke.so&#x27;</span>) : DynamicLibrary.process();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">final</span> cMethod = ffiLib.lookupFunction&lt;Void <span class=\"built_in\">Function</span>(Int32 value), <span class=\"keyword\">void</span> <span class=\"built_in\">Function</span>(<span class=\"built_in\">int</span> value)&gt;(<span class=\"string\">&#x27;c_with_out_return_value&#x27;</span>);</span><br><span class=\"line\">cMethod(<span class=\"number\">123</span>);  </span><br></pre></td></tr></table></figure>\n<p>这样一次调用就完成了一次调用，传递了123到Native并执行了一次打印，同理相关有参有返回值的请求也都是这样做到的，那 Dart 和 Native内部具体怎样实现的呢？</p>\n<p><code>DynamicLibrary.open()</code> 最终执行的逻辑如下, 源码位于<a href=\"https://github.com/dart-lang/sdk/blob/master/runtime/lib/ffi_dynamic_library.cc\">ffi_dynamic_library.cc</a>：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">void</span>* <span class=\"title function_\">LoadExtensionLibrary</span><span class=\"params\">(<span class=\"type\">const</span> <span class=\"type\">char</span>* library_file)</span> &#123;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">if</span> defined(HOST_OS_LINUX) || defined(HOST_OS_MACOS) ||                        \\</span></span><br><span class=\"line\"><span class=\"meta\">    defined(HOST_OS_ANDROID) || defined(HOST_OS_FUCHSIA)</span></span><br><span class=\"line\">  <span class=\"type\">void</span>* handle = dlopen(library_file, RTLD_LAZY);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (handle == nullptr) &#123;</span><br><span class=\"line\">    <span class=\"type\">char</span>* error = dlerror();</span><br><span class=\"line\">    <span class=\"type\">const</span> String&amp; msg = String::Handle(</span><br><span class=\"line\">        String::NewFormatted(<span class=\"string\">&quot;Failed to load dynamic library (%s)&quot;</span>, error));</span><br><span class=\"line\">    Exceptions::ThrowArgumentError(msg);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> handle;</span><br><span class=\"line\">  ……</span><br></pre></td></tr></table></figure>\n<p>可以看到最终使用 <a href=\"https://pubs.opengroup.org/onlinepubs/009696699/functions/dlopen.html\">dlopen</a> 加载动态链接库，并返回句柄。</p>\n<p>拿到对应的动态链接库的句柄之后，就能使用相关方法进行操作了。<br>句柄主要包含以下两个方法：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//在内存中查找对应符号名的地址，与dlsym()功能相同</span></span><br><span class=\"line\"><span class=\"keyword\">external</span> Pointer&lt;T&gt; lookup&lt;T <span class=\"keyword\">extends</span> NativeType&gt;(<span class=\"built_in\">String</span> symbolName);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//1、去动态库中查找对应名称的函数 </span></span><br><span class=\"line\"><span class=\"comment\">//2、将 Native 类型的 C/C++ 函数转化为 Dart 的 Function 类型</span></span><br><span class=\"line\"><span class=\"keyword\">external</span> F lookupFunction&lt;T <span class=\"keyword\">extends</span> <span class=\"built_in\">Function</span>, F <span class=\"keyword\">extends</span> <span class=\"built_in\">Function</span>&gt;(<span class=\"built_in\">String</span> symbolName);</span><br></pre></td></tr></table></figure>\n<p>其中lookup()的最终实现主要使用了 <a href=\"https://pubs.opengroup.org/onlinepubs/009695399/functions/dlsym.html\">dlsym</a></p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">void</span>* <span class=\"title function_\">ResolveSymbol</span><span class=\"params\">(<span class=\"type\">void</span>* handle, <span class=\"type\">const</span> <span class=\"type\">char</span>* symbol)</span> &#123;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">if</span> defined(HOST_OS_LINUX) || defined(HOST_OS_MACOS) ||                       </span></span><br><span class=\"line\">    defined(HOST_OS_ANDROID) || defined(HOST_OS_FUCHSIA)</span><br><span class=\"line\">  dlerror();  <span class=\"comment\">// Clear any errors.</span></span><br><span class=\"line\">  <span class=\"type\">void</span>* pointer = dlsym(handle, symbol);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (pointer == nullptr) &#123;</span><br><span class=\"line\">    <span class=\"type\">char</span>* error = dlerror();</span><br><span class=\"line\">    <span class=\"type\">const</span> String&amp; msg = String::Handle(</span><br><span class=\"line\">        String::NewFormatted(<span class=\"string\">&quot;Failed to lookup symbol (%s)&quot;</span>, error));</span><br><span class=\"line\">    Exceptions::ThrowArgumentError(msg);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> pointer;</span><br></pre></td></tr></table></figure>\n<h2 id=\"二、Dart-异步调用-Native-方法\"><a href=\"#二、Dart-异步调用-Native-方法\" class=\"headerlink\" title=\"二、Dart 异步调用 Native 方法\"></a>二、Dart 异步调用 Native 方法</h2><p>在很多场景我们不能像上述同步方法那样，dart 进行一次请求之后立马得到结果，可能会有一些耗时操作，为了不让 Flutter 的UI线程卡住，我们进行异步请求。那如何实现异步请求呢？<br>对于异步实现，官方并没有很明确的文档，都得靠自己琢磨，在官方的讨论中 <a href=\"https://github.com/dart-lang/sdk/issues/37022\">https://github.com/dart-lang/sdk/issues/37022</a> 以及 <a href=\"https://github.com/flutter/flutter/issues/63255\">https://github.com/flutter/flutter/issues/63255</a> 提到一些解决方案:</p>\n<blockquote>\n<p>1.In your C++ code include include/dart_api_dl.h and include/dart_api_dl.cc from here <a href=\"https://github.com/dart-lang/sdk/blob/master/runtime/include/\">https://github.com/dart-lang/sdk/blob/master/runtime/include/</a> (they also depend on include/internal/*).</p>\n<p>2.From Dart call Dart_InitializeApiDL passing NativeApi.initializeApiDLData as an argument.</p>\n<p>3.On Dart side create a ReceivePort and pass port number of the corresponding SendPort to the native side (port.sendPort.nativePort).</p>\n<p>4.Now on C++ side you can use Dart_PostCObject_DL to send messages back to Dart side from any thread.</p>\n</blockquote>\n<p>按上述的操作进行实现，接下来具体分析一些里面的逻辑原理。<br>1、导入include/dart_api_dl.h include/dart_api_dl.cc 相关的文件并在 CMakeList.txt进行相关配置<br>2、从dart中 调用Native中 Dart_InitializeApiDL</p>\n<p>Dart:</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> main() &#123;</span><br><span class=\"line\">  initializeApi(NativeApi.initializeApiDLData);</span><br><span class=\"line\">  runApp(MyApp());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>C++:</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Initialize `dart_api_dl.h`</span></span><br><span class=\"line\">DART_EXPORT <span class=\"type\">intptr_t</span> <span class=\"title function_\">InitDartApiDL</span><span class=\"params\">(<span class=\"type\">void</span> *data)</span> &#123;</span><br><span class=\"line\">    LOG_D(<span class=\"string\">&quot;InitDartApiDL&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> Dart_InitializeApiDL(data);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>在 initializeApi(NativeApi.initializeApiDLData) 中 initializeApi 向 Native请求 <code>DART_EXPORT intptr_t InitDartApiDL(void *data)</code>方法，传入的参数就是在 <a href=\"https://github.com/dart-lang/sdk/blob/master/runtime/include/dart_api_dl.h\">dart_api_dl.h</a><br> DART_NATIVE_API_DL_SYMBOLS 以及 DART_API_DL_SYMBOLS 中的方法。</p>\n<p>NativeApi.initializeApiDLData 逻辑：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">const</span> DartApiEntry dart_api_entries[] = &#123;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> ENTRY(name, R, A)                                                      \\</span></span><br><span class=\"line\"><span class=\"meta\">  DartApiEntry&#123;#name, reinterpret_cast<span class=\"string\">&lt;void (*)()&gt;</span>(name)&#125;,</span></span><br><span class=\"line\">    DART_API_ALL_DL_SYMBOLS(ENTRY)</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">undef</span> ENTRY</span></span><br><span class=\"line\">        DartApiEntry&#123;nullptr, nullptr&#125;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">const</span> DartApi dart_api_data = &#123;</span><br><span class=\"line\">    DART_API_DL_MAJOR_VERSION, DART_API_DL_MINOR_VERSION, dart_api_entries&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">DEFINE_NATIVE_ENTRY(DartApiDLInitializeData, <span class=\"number\">0</span>, <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> Integer::New(reinterpret_cast&lt;<span class=\"type\">intptr_t</span>&gt;(&amp;dart_api_data));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>dart_api_dl中定义的方法：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> DART_NATIVE_API_DL_SYMBOLS(F)                                          \\</span></span><br><span class=\"line\"><span class=\"meta\">  <span class=\"comment\">/***** dart_native_api.h *****/</span>                                              \\</span></span><br><span class=\"line\"><span class=\"meta\">  <span class=\"comment\">/* Dart_Port */</span>                                                              \\</span></span><br><span class=\"line\"><span class=\"meta\">  F(Dart_PostCObject, bool, (Dart_Port_DL port_id, Dart_CObject * message))    \\</span></span><br><span class=\"line\"><span class=\"meta\">  F(Dart_PostInteger, bool, (Dart_Port_DL port_id, int64_t message))           \\</span></span><br><span class=\"line\"><span class=\"meta\">  .....</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// dart_api.h symbols can only be called on Dart threads.</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> DART_API_DL_SYMBOLS(F)                                                 \\</span></span><br><span class=\"line\"><span class=\"meta\">  <span class=\"comment\">/***** dart_api.h *****/</span>                                                     \\</span></span><br><span class=\"line\"><span class=\"meta\">  <span class=\"comment\">/* Errors */</span>                                                                 \\</span></span><br><span class=\"line\"><span class=\"meta\">  F(Dart_IsError, bool, (Dart_Handle handle))                                  \\</span></span><br><span class=\"line\"><span class=\"meta\">  F(Dart_IsApiError, bool, (Dart_Handle handle))                               \\</span></span><br><span class=\"line\"><span class=\"meta\">  .....</span></span><br></pre></td></tr></table></figure>\n<p>其实这上面的逻辑很简单，主要是为了让业务中的代码能够进行动态链接，从而调用到 Flutter SDK 中相关方法。</p>\n<p>3、第三步添加 ReceivePort 监听</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Work</span> <span class=\"keyword\">extends</span> <span class=\"title\">Opaque</span> </span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">void</span> requestExecuteCallback(<span class=\"built_in\">dynamic</span> message) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">final</span> <span class=\"built_in\">int</span> workAddress = message <span class=\"keyword\">as</span> <span class=\"built_in\">int</span>;</span><br><span class=\"line\">  <span class=\"keyword\">final</span> Pointer&lt;Work&gt; work = Pointer&lt;Work&gt;.fromAddress(workAddress);</span><br><span class=\"line\">  executeCallback(work);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">final</span> ReceivePort interactiveCppRequests = ReceivePort()..listen(requestExecuteCallback);</span><br></pre></td></tr></table></figure>\n<p>向 Native 发送带有 interactiveCppRequests.sendPort.nativePort 的数据，为native异步回调做准备。</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">Future&lt;<span class=\"built_in\">int</span>&gt; platformAsync(<span class=\"built_in\">int</span> value1, <span class=\"built_in\">int</span> value2) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">final</span> Completer&lt;<span class=\"built_in\">int</span>&gt; completer = Completer&lt;<span class=\"built_in\">int</span>&gt;();</span><br><span class=\"line\">  <span class=\"keyword\">final</span> <span class=\"built_in\">String</span> cid = uuid.v1();</span><br><span class=\"line\">  <span class=\"keyword\">final</span> Pointer&lt;Utf8&gt; cidPtr = cid.toNativeUtf8();</span><br><span class=\"line\">  completerMapping[cid] = completer;</span><br><span class=\"line\">  <span class=\"comment\">//生成一个nativePort，为native异步回调做准备</span></span><br><span class=\"line\">  <span class=\"keyword\">final</span> <span class=\"built_in\">int</span> nativePort = interactiveCppRequests.sendPort.nativePort; </span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">final</span> cMethod = ffiLib.lookupFunction&lt;</span><br><span class=\"line\">      Int32 <span class=\"built_in\">Function</span>(Pointer&lt;Utf8&gt; cId, Int64 sendPort, Int32 value1, Int32 value2,</span><br><span class=\"line\">          Pointer&lt;NativeFunction&lt;callback_type&gt;&gt; callbackBlock),</span><br><span class=\"line\">      <span class=\"built_in\">int</span> <span class=\"built_in\">Function</span>(Pointer&lt;Utf8&gt; cId, <span class=\"built_in\">int</span> sendPort, <span class=\"built_in\">int</span> value1, <span class=\"built_in\">int</span> value2,</span><br><span class=\"line\">          Pointer&lt;NativeFunction&lt;callback_type&gt;&gt; callbackBlock)&gt;(<span class=\"string\">&#x27;platform_async&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  cMethod(cidPtr, nativePort, value1, value2, Pointer.fromFunction&lt;callback_type&gt;(_callbackBlocking));</span><br><span class=\"line\">  <span class=\"keyword\">return</span> completer.future;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>4、当异步执行完成之后，在 Native 执行 Dart_PostCObject_DL 通知 Dart 已经得到结果<br>对于代码如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">response</span><span class=\"params\">(jint result)</span> </span>&#123;</span><br><span class=\"line\">    Work work = [_callback,result] &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (_callback != <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">            _callback( result);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"built_in\">LOG_E</span>(<span class=\"string\">&quot;_callback == null&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    <span class=\"comment\">// Copy to heap to make it outlive the function scope.</span></span><br><span class=\"line\">    <span class=\"type\">const</span> Work *work_ptr = <span class=\"keyword\">new</span> <span class=\"built_in\">Work</span>(work);</span><br><span class=\"line\">    <span class=\"built_in\">NotifyDart</span>(send_port, work_ptr);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">NotifyDart</span><span class=\"params\">(Dart_Port send_port, <span class=\"type\">const</span> Work *work)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"type\">const</span> <span class=\"keyword\">auto</span> work_address = <span class=\"built_in\">reinterpret_cast</span>&lt;<span class=\"type\">intptr_t</span>&gt;(work);</span><br><span class=\"line\">    Dart_CObject dart_object;</span><br><span class=\"line\">    dart_object.type = Dart_CObject_kInt64;</span><br><span class=\"line\">    dart_object.value.as_int64 = work_address;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">const</span> <span class=\"type\">bool</span> result = <span class=\"built_in\">Dart_PostCObject_DL</span>(send_port, &amp;dart_object);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!result) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">LOG_D</span>(<span class=\"string\">&quot;FFI C  :  Posting message to port failed.&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面的代码最核心的就是<code>Dart_PostCObject_DL()</code>这里真正调用的还是，<code>Dart_PostCObject()</code>，加_DL()表示动态链接的方法，为了防止与原先符号冲突。</p>\n<blockquote>\n<p>All symbols are postfixed with _DL to indicate that they are dynamically</p>\n<p>linked and to prevent conflicts with the original symbol.</p>\n</blockquote>\n<p>我们继续看看  <code>Dart_PostCObject()</code>真正做了什么，Dart_PostCObject()最终调用的方法如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">bool</span> <span class=\"title function_\">PostCObjectHelper</span><span class=\"params\">(Dart_Port port_id, Dart_CObject* message)</span> &#123;</span><br><span class=\"line\">  ApiMessageWriter writer;</span><br><span class=\"line\">  <span class=\"built_in\">std</span>::<span class=\"built_in\">unique_ptr</span>&lt;Message&gt; msg =</span><br><span class=\"line\">      writer.WriteCMessage(message, port_id, Message::kNormalPriority);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (msg == nullptr) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Post the message at the given port.</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> PortMap::PostMessage(<span class=\"built_in\">std</span>::move(msg));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里在向 Service Isolate发送事件,最终 Dart 成功接受到异步消息的回调。<br>关于 Isolate 这一块的处理可以参考：<a href=\"https://medium.com/@codinghive.dev/async-coding-with-dart-isolates-b09c5ec00f8b\">Async Coding With Dart: Isolates</a></p>\n<h2 id=\"三、Native-调用-Dart方法\"><a href=\"#三、Native-调用-Dart方法\" class=\"headerlink\" title=\"三、Native 调用 Dart方法 ?\"></a>三、Native 调用 Dart方法 ?</h2><p>对于 JNI 里面，我们需要调用 Java的方法，利用Java反射机制调用即可，如下所示：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">_env-&gt;CallStaticVoidMethod(j_class, j_method, arg1, arg2);</span><br></pre></td></tr></table></figure>\n<p>如果 Native 想要调用 Dart代码有类似的代码可以用么？翻遍了 Flutter相关的文档，都没有找到对应的方法可以直接去调用 Dart的方法，Dart Engine内部有 <a href=\"https://github.com/dart-lang/sdk/blob/master/runtime/include/dart_api.h\">dart_api.h</a>提供了<code>Dart_invoke()</code>方法，但单纯的导入 .h文件在项目中是无法链接到对应的方法的，这也就是为什么需要导入<a href=\"https://github.com/dart-lang/sdk/tree/master/runtime/include\">ffi_runtime_lib</a>相关的文件并执行 <code>Dart_InitializeApiDL()</code>，通过动态链接使得代码能够去调用 Dart 封装的相关方法。</p>\n<p>所以参考 Dart中 <code>InitDartApiDL</code>的方法，我们先对 Dart 中的函数进行注册，传递对应方法的指针，然后在 Native 中即可调用，理论上可行，后续会补上相关  demo。<br>当然这只是一种骚操作，如果有更好的方法能够用 Native 调用 Dart 欢迎讨论。</p>\n<h2 id=\"四、总结\"><a href=\"#四、总结\" class=\"headerlink\" title=\"四、总结\"></a>四、总结</h2><p>文章记录了 Dart 同步和异步调用 Native 相关的使用，异步具体的使用比上述的代码复杂，因为需要一个中介记录异步相关的回调方法，当得到真正的结果之后，利用id查找到对应的方法再执行回调方法。FFI 在 Native中执行 dart 方法，暂时没有比较好的解决方案<br>FFI 调用可查看 <a href=\"https://github.com/VomPom/flutter_ffi_tutorial\">Demo flutter_ffi_tutorial</a></p>\n","cover":null,"images":[],"content":"<p>在 Android的开发中，我们有 <a href=\"https://developer.android.com/training/articles/perf-jni\">JNI</a> 使得 Java可以调用本地应用或库。<br>Flutter 在前不久发布了 <a href=\"https://developers.googleblog.com/2021/03/announcing-flutter-2.html\">Flutter2</a>，更新了 <a href=\"https://dart.dev/guides/libraries/c-interop\">FFI</a> (我们是否可以把它叫做DNI呢？)进入了稳定状态,开发者可以更安心的使用其功能。<br>但是相关的文档依然很欠缺，导致使用起来有诸多的疑问，以及相关原理性的介绍比较少，所以整理记录一下。</p>\n<h2 id=\"一、Dart-同步调用-Native-方法\"><a href=\"#一、Dart-同步调用-Native-方法\" class=\"headerlink\" title=\"一、Dart 同步调用 Native 方法\"></a>一、Dart 同步调用 Native 方法</h2><p>我们以最简单的demo为例,请求一个有参无返回值的C方法<br>在 C/C++中有如下函数：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">extern</span> <span class=\"string\">&quot;C&quot;</span> __attribute__((visibility(<span class=\"string\">&quot;default&quot;</span>))) __attribute__((used))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">c_with_out_return_value</span><span class=\"params\">(<span class=\"type\">int</span> value)</span> &#123;</span><br><span class=\"line\">    LOG_D(<span class=\"string\">&quot;Got invoke value: %d&quot;</span>, value);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Dart:</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">final</span> DynamicLibrary ffiLib = Platform.isAndroid ? DynamicLibrary.open(<span class=\"string\">&#x27;lib_invoke.so&#x27;</span>) : DynamicLibrary.process();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">final</span> cMethod = ffiLib.lookupFunction&lt;Void <span class=\"built_in\">Function</span>(Int32 value), <span class=\"keyword\">void</span> <span class=\"built_in\">Function</span>(<span class=\"built_in\">int</span> value)&gt;(<span class=\"string\">&#x27;c_with_out_return_value&#x27;</span>);</span><br><span class=\"line\">cMethod(<span class=\"number\">123</span>);  </span><br></pre></td></tr></table></figure>\n<p>这样一次调用就完成了一次调用，传递了123到Native并执行了一次打印，同理相关有参有返回值的请求也都是这样做到的，那 Dart 和 Native内部具体怎样实现的呢？</p>\n<p><code>DynamicLibrary.open()</code> 最终执行的逻辑如下, 源码位于<a href=\"https://github.com/dart-lang/sdk/blob/master/runtime/lib/ffi_dynamic_library.cc\">ffi_dynamic_library.cc</a>：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">void</span>* <span class=\"title function_\">LoadExtensionLibrary</span><span class=\"params\">(<span class=\"type\">const</span> <span class=\"type\">char</span>* library_file)</span> &#123;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">if</span> defined(HOST_OS_LINUX) || defined(HOST_OS_MACOS) ||                        \\</span></span><br><span class=\"line\"><span class=\"meta\">    defined(HOST_OS_ANDROID) || defined(HOST_OS_FUCHSIA)</span></span><br><span class=\"line\">  <span class=\"type\">void</span>* handle = dlopen(library_file, RTLD_LAZY);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (handle == nullptr) &#123;</span><br><span class=\"line\">    <span class=\"type\">char</span>* error = dlerror();</span><br><span class=\"line\">    <span class=\"type\">const</span> String&amp; msg = String::Handle(</span><br><span class=\"line\">        String::NewFormatted(<span class=\"string\">&quot;Failed to load dynamic library (%s)&quot;</span>, error));</span><br><span class=\"line\">    Exceptions::ThrowArgumentError(msg);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> handle;</span><br><span class=\"line\">  ……</span><br></pre></td></tr></table></figure>\n<p>可以看到最终使用 <a href=\"https://pubs.opengroup.org/onlinepubs/009696699/functions/dlopen.html\">dlopen</a> 加载动态链接库，并返回句柄。</p>\n<p>拿到对应的动态链接库的句柄之后，就能使用相关方法进行操作了。<br>句柄主要包含以下两个方法：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//在内存中查找对应符号名的地址，与dlsym()功能相同</span></span><br><span class=\"line\"><span class=\"keyword\">external</span> Pointer&lt;T&gt; lookup&lt;T <span class=\"keyword\">extends</span> NativeType&gt;(<span class=\"built_in\">String</span> symbolName);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//1、去动态库中查找对应名称的函数 </span></span><br><span class=\"line\"><span class=\"comment\">//2、将 Native 类型的 C/C++ 函数转化为 Dart 的 Function 类型</span></span><br><span class=\"line\"><span class=\"keyword\">external</span> F lookupFunction&lt;T <span class=\"keyword\">extends</span> <span class=\"built_in\">Function</span>, F <span class=\"keyword\">extends</span> <span class=\"built_in\">Function</span>&gt;(<span class=\"built_in\">String</span> symbolName);</span><br></pre></td></tr></table></figure>\n<p>其中lookup()的最终实现主要使用了 <a href=\"https://pubs.opengroup.org/onlinepubs/009695399/functions/dlsym.html\">dlsym</a></p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">void</span>* <span class=\"title function_\">ResolveSymbol</span><span class=\"params\">(<span class=\"type\">void</span>* handle, <span class=\"type\">const</span> <span class=\"type\">char</span>* symbol)</span> &#123;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">if</span> defined(HOST_OS_LINUX) || defined(HOST_OS_MACOS) ||                       </span></span><br><span class=\"line\">    defined(HOST_OS_ANDROID) || defined(HOST_OS_FUCHSIA)</span><br><span class=\"line\">  dlerror();  <span class=\"comment\">// Clear any errors.</span></span><br><span class=\"line\">  <span class=\"type\">void</span>* pointer = dlsym(handle, symbol);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (pointer == nullptr) &#123;</span><br><span class=\"line\">    <span class=\"type\">char</span>* error = dlerror();</span><br><span class=\"line\">    <span class=\"type\">const</span> String&amp; msg = String::Handle(</span><br><span class=\"line\">        String::NewFormatted(<span class=\"string\">&quot;Failed to lookup symbol (%s)&quot;</span>, error));</span><br><span class=\"line\">    Exceptions::ThrowArgumentError(msg);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> pointer;</span><br></pre></td></tr></table></figure>\n<h2 id=\"二、Dart-异步调用-Native-方法\"><a href=\"#二、Dart-异步调用-Native-方法\" class=\"headerlink\" title=\"二、Dart 异步调用 Native 方法\"></a>二、Dart 异步调用 Native 方法</h2><p>在很多场景我们不能像上述同步方法那样，dart 进行一次请求之后立马得到结果，可能会有一些耗时操作，为了不让 Flutter 的UI线程卡住，我们进行异步请求。那如何实现异步请求呢？<br>对于异步实现，官方并没有很明确的文档，都得靠自己琢磨，在官方的讨论中 <a href=\"https://github.com/dart-lang/sdk/issues/37022\">https://github.com/dart-lang/sdk/issues/37022</a> 以及 <a href=\"https://github.com/flutter/flutter/issues/63255\">https://github.com/flutter/flutter/issues/63255</a> 提到一些解决方案:</p>\n<blockquote>\n<p>1.In your C++ code include include/dart_api_dl.h and include/dart_api_dl.cc from here <a href=\"https://github.com/dart-lang/sdk/blob/master/runtime/include/\">https://github.com/dart-lang/sdk/blob/master/runtime/include/</a> (they also depend on include/internal/*).</p>\n<p>2.From Dart call Dart_InitializeApiDL passing NativeApi.initializeApiDLData as an argument.</p>\n<p>3.On Dart side create a ReceivePort and pass port number of the corresponding SendPort to the native side (port.sendPort.nativePort).</p>\n<p>4.Now on C++ side you can use Dart_PostCObject_DL to send messages back to Dart side from any thread.</p>\n</blockquote>\n<p>按上述的操作进行实现，接下来具体分析一些里面的逻辑原理。<br>1、导入include/dart_api_dl.h include/dart_api_dl.cc 相关的文件并在 CMakeList.txt进行相关配置<br>2、从dart中 调用Native中 Dart_InitializeApiDL</p>\n<p>Dart:</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> main() &#123;</span><br><span class=\"line\">  initializeApi(NativeApi.initializeApiDLData);</span><br><span class=\"line\">  runApp(MyApp());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>C++:</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Initialize `dart_api_dl.h`</span></span><br><span class=\"line\">DART_EXPORT <span class=\"type\">intptr_t</span> <span class=\"title function_\">InitDartApiDL</span><span class=\"params\">(<span class=\"type\">void</span> *data)</span> &#123;</span><br><span class=\"line\">    LOG_D(<span class=\"string\">&quot;InitDartApiDL&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> Dart_InitializeApiDL(data);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>在 initializeApi(NativeApi.initializeApiDLData) 中 initializeApi 向 Native请求 <code>DART_EXPORT intptr_t InitDartApiDL(void *data)</code>方法，传入的参数就是在 <a href=\"https://github.com/dart-lang/sdk/blob/master/runtime/include/dart_api_dl.h\">dart_api_dl.h</a><br> DART_NATIVE_API_DL_SYMBOLS 以及 DART_API_DL_SYMBOLS 中的方法。</p>\n<p>NativeApi.initializeApiDLData 逻辑：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">const</span> DartApiEntry dart_api_entries[] = &#123;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> ENTRY(name, R, A)                                                      \\</span></span><br><span class=\"line\"><span class=\"meta\">  DartApiEntry&#123;#name, reinterpret_cast<span class=\"string\">&lt;void (*)()&gt;</span>(name)&#125;,</span></span><br><span class=\"line\">    DART_API_ALL_DL_SYMBOLS(ENTRY)</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">undef</span> ENTRY</span></span><br><span class=\"line\">        DartApiEntry&#123;nullptr, nullptr&#125;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">const</span> DartApi dart_api_data = &#123;</span><br><span class=\"line\">    DART_API_DL_MAJOR_VERSION, DART_API_DL_MINOR_VERSION, dart_api_entries&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">DEFINE_NATIVE_ENTRY(DartApiDLInitializeData, <span class=\"number\">0</span>, <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> Integer::New(reinterpret_cast&lt;<span class=\"type\">intptr_t</span>&gt;(&amp;dart_api_data));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>dart_api_dl中定义的方法：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> DART_NATIVE_API_DL_SYMBOLS(F)                                          \\</span></span><br><span class=\"line\"><span class=\"meta\">  <span class=\"comment\">/***** dart_native_api.h *****/</span>                                              \\</span></span><br><span class=\"line\"><span class=\"meta\">  <span class=\"comment\">/* Dart_Port */</span>                                                              \\</span></span><br><span class=\"line\"><span class=\"meta\">  F(Dart_PostCObject, bool, (Dart_Port_DL port_id, Dart_CObject * message))    \\</span></span><br><span class=\"line\"><span class=\"meta\">  F(Dart_PostInteger, bool, (Dart_Port_DL port_id, int64_t message))           \\</span></span><br><span class=\"line\"><span class=\"meta\">  .....</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// dart_api.h symbols can only be called on Dart threads.</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> DART_API_DL_SYMBOLS(F)                                                 \\</span></span><br><span class=\"line\"><span class=\"meta\">  <span class=\"comment\">/***** dart_api.h *****/</span>                                                     \\</span></span><br><span class=\"line\"><span class=\"meta\">  <span class=\"comment\">/* Errors */</span>                                                                 \\</span></span><br><span class=\"line\"><span class=\"meta\">  F(Dart_IsError, bool, (Dart_Handle handle))                                  \\</span></span><br><span class=\"line\"><span class=\"meta\">  F(Dart_IsApiError, bool, (Dart_Handle handle))                               \\</span></span><br><span class=\"line\"><span class=\"meta\">  .....</span></span><br></pre></td></tr></table></figure>\n<p>其实这上面的逻辑很简单，主要是为了让业务中的代码能够进行动态链接，从而调用到 Flutter SDK 中相关方法。</p>\n<p>3、第三步添加 ReceivePort 监听</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Work</span> <span class=\"keyword\">extends</span> <span class=\"title\">Opaque</span> </span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">void</span> requestExecuteCallback(<span class=\"built_in\">dynamic</span> message) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">final</span> <span class=\"built_in\">int</span> workAddress = message <span class=\"keyword\">as</span> <span class=\"built_in\">int</span>;</span><br><span class=\"line\">  <span class=\"keyword\">final</span> Pointer&lt;Work&gt; work = Pointer&lt;Work&gt;.fromAddress(workAddress);</span><br><span class=\"line\">  executeCallback(work);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">final</span> ReceivePort interactiveCppRequests = ReceivePort()..listen(requestExecuteCallback);</span><br></pre></td></tr></table></figure>\n<p>向 Native 发送带有 interactiveCppRequests.sendPort.nativePort 的数据，为native异步回调做准备。</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">Future&lt;<span class=\"built_in\">int</span>&gt; platformAsync(<span class=\"built_in\">int</span> value1, <span class=\"built_in\">int</span> value2) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">final</span> Completer&lt;<span class=\"built_in\">int</span>&gt; completer = Completer&lt;<span class=\"built_in\">int</span>&gt;();</span><br><span class=\"line\">  <span class=\"keyword\">final</span> <span class=\"built_in\">String</span> cid = uuid.v1();</span><br><span class=\"line\">  <span class=\"keyword\">final</span> Pointer&lt;Utf8&gt; cidPtr = cid.toNativeUtf8();</span><br><span class=\"line\">  completerMapping[cid] = completer;</span><br><span class=\"line\">  <span class=\"comment\">//生成一个nativePort，为native异步回调做准备</span></span><br><span class=\"line\">  <span class=\"keyword\">final</span> <span class=\"built_in\">int</span> nativePort = interactiveCppRequests.sendPort.nativePort; </span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">final</span> cMethod = ffiLib.lookupFunction&lt;</span><br><span class=\"line\">      Int32 <span class=\"built_in\">Function</span>(Pointer&lt;Utf8&gt; cId, Int64 sendPort, Int32 value1, Int32 value2,</span><br><span class=\"line\">          Pointer&lt;NativeFunction&lt;callback_type&gt;&gt; callbackBlock),</span><br><span class=\"line\">      <span class=\"built_in\">int</span> <span class=\"built_in\">Function</span>(Pointer&lt;Utf8&gt; cId, <span class=\"built_in\">int</span> sendPort, <span class=\"built_in\">int</span> value1, <span class=\"built_in\">int</span> value2,</span><br><span class=\"line\">          Pointer&lt;NativeFunction&lt;callback_type&gt;&gt; callbackBlock)&gt;(<span class=\"string\">&#x27;platform_async&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  cMethod(cidPtr, nativePort, value1, value2, Pointer.fromFunction&lt;callback_type&gt;(_callbackBlocking));</span><br><span class=\"line\">  <span class=\"keyword\">return</span> completer.future;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>4、当异步执行完成之后，在 Native 执行 Dart_PostCObject_DL 通知 Dart 已经得到结果<br>对于代码如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">response</span><span class=\"params\">(jint result)</span> </span>&#123;</span><br><span class=\"line\">    Work work = [_callback,result] &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (_callback != <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">            _callback( result);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"built_in\">LOG_E</span>(<span class=\"string\">&quot;_callback == null&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    <span class=\"comment\">// Copy to heap to make it outlive the function scope.</span></span><br><span class=\"line\">    <span class=\"type\">const</span> Work *work_ptr = <span class=\"keyword\">new</span> <span class=\"built_in\">Work</span>(work);</span><br><span class=\"line\">    <span class=\"built_in\">NotifyDart</span>(send_port, work_ptr);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">NotifyDart</span><span class=\"params\">(Dart_Port send_port, <span class=\"type\">const</span> Work *work)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"type\">const</span> <span class=\"keyword\">auto</span> work_address = <span class=\"built_in\">reinterpret_cast</span>&lt;<span class=\"type\">intptr_t</span>&gt;(work);</span><br><span class=\"line\">    Dart_CObject dart_object;</span><br><span class=\"line\">    dart_object.type = Dart_CObject_kInt64;</span><br><span class=\"line\">    dart_object.value.as_int64 = work_address;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">const</span> <span class=\"type\">bool</span> result = <span class=\"built_in\">Dart_PostCObject_DL</span>(send_port, &amp;dart_object);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!result) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">LOG_D</span>(<span class=\"string\">&quot;FFI C  :  Posting message to port failed.&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面的代码最核心的就是<code>Dart_PostCObject_DL()</code>这里真正调用的还是，<code>Dart_PostCObject()</code>，加_DL()表示动态链接的方法，为了防止与原先符号冲突。</p>\n<blockquote>\n<p>All symbols are postfixed with _DL to indicate that they are dynamically</p>\n<p>linked and to prevent conflicts with the original symbol.</p>\n</blockquote>\n<p>我们继续看看  <code>Dart_PostCObject()</code>真正做了什么，Dart_PostCObject()最终调用的方法如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">bool</span> <span class=\"title function_\">PostCObjectHelper</span><span class=\"params\">(Dart_Port port_id, Dart_CObject* message)</span> &#123;</span><br><span class=\"line\">  ApiMessageWriter writer;</span><br><span class=\"line\">  <span class=\"built_in\">std</span>::<span class=\"built_in\">unique_ptr</span>&lt;Message&gt; msg =</span><br><span class=\"line\">      writer.WriteCMessage(message, port_id, Message::kNormalPriority);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (msg == nullptr) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Post the message at the given port.</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> PortMap::PostMessage(<span class=\"built_in\">std</span>::move(msg));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里在向 Service Isolate发送事件,最终 Dart 成功接受到异步消息的回调。<br>关于 Isolate 这一块的处理可以参考：<a href=\"https://medium.com/@codinghive.dev/async-coding-with-dart-isolates-b09c5ec00f8b\">Async Coding With Dart: Isolates</a></p>\n<h2 id=\"三、Native-调用-Dart方法\"><a href=\"#三、Native-调用-Dart方法\" class=\"headerlink\" title=\"三、Native 调用 Dart方法 ?\"></a>三、Native 调用 Dart方法 ?</h2><p>对于 JNI 里面，我们需要调用 Java的方法，利用Java反射机制调用即可，如下所示：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">_env-&gt;CallStaticVoidMethod(j_class, j_method, arg1, arg2);</span><br></pre></td></tr></table></figure>\n<p>如果 Native 想要调用 Dart代码有类似的代码可以用么？翻遍了 Flutter相关的文档，都没有找到对应的方法可以直接去调用 Dart的方法，Dart Engine内部有 <a href=\"https://github.com/dart-lang/sdk/blob/master/runtime/include/dart_api.h\">dart_api.h</a>提供了<code>Dart_invoke()</code>方法，但单纯的导入 .h文件在项目中是无法链接到对应的方法的，这也就是为什么需要导入<a href=\"https://github.com/dart-lang/sdk/tree/master/runtime/include\">ffi_runtime_lib</a>相关的文件并执行 <code>Dart_InitializeApiDL()</code>，通过动态链接使得代码能够去调用 Dart 封装的相关方法。</p>\n<p>所以参考 Dart中 <code>InitDartApiDL</code>的方法，我们先对 Dart 中的函数进行注册，传递对应方法的指针，然后在 Native 中即可调用，理论上可行，后续会补上相关  demo。<br>当然这只是一种骚操作，如果有更好的方法能够用 Native 调用 Dart 欢迎讨论。</p>\n<h2 id=\"四、总结\"><a href=\"#四、总结\" class=\"headerlink\" title=\"四、总结\"></a>四、总结</h2><p>文章记录了 Dart 同步和异步调用 Native 相关的使用，异步具体的使用比上述的代码复杂，因为需要一个中介记录异步相关的回调方法，当得到真正的结果之后，利用id查找到对应的方法再执行回调方法。FFI 在 Native中执行 dart 方法，暂时没有比较好的解决方案<br>FFI 调用可查看 <a href=\"https://github.com/VomPom/flutter_ffi_tutorial\">Demo flutter_ffi_tutorial</a></p>\n","categories":[{"name":"技术文章","slug":"technology","api":"api/categories/technology.json"}],"tags":[{"name":"Flutter","slug":"Flutter","api":"api/tags/Flutter.json"}],"api":"api/posts/2021/04/18/FlutterFFI实践.json"}],"info":{"type":"archive","year":2021,"month":4}},"api":"api/archives/2021/04/page.1.json"}