{"data":{"index":2,"total":2,"posts":[{"title":"关于朋友","slug":"关于朋友","date":"2020-06-15T08:11:00.000Z","updated":"2025-05-20T11:46:57.000Z","comments":true,"url":"2020/06/15/关于朋友/","excerpt":"<p>2020年6月15日，我最好的初高中朋友ZR（女）和XBC（男）在今天拿到了结婚证了，结束了快十年的爱情长跑。我和他们都是在初中的时候认识的，后来在一个高中，大学便分别了。虽然每年只会在过年的时候才会见面，但是那种友情却不因时间和距离而减。对于他们拿到结婚证，今天也是突然有感于其中。</p>\n<p>我与XBC是初中是最好的朋友了，那时候我们正值青春懵懂时期，我与他干了不少“坏事”，上课调皮捣蛋，晚上就寝与老师斗智斗勇。班主任罚检讨、被挨打、被体罚不知道有多少次，那时候正值青春叛逆时期，懵懂无知，做了很多有趣的事情，现在回想起来都是一串串难忘的记忆。</p>\n<p>还记得初中时候跟他聊的特别多，上课也是聊天，我们总会产生各种鬼主意。我们聊着那时候玩过的游戏DOTA、重装机兵，我们都追着Justin Bieber、Taylor Swift并哼唱着他们的歌，以及追着当时正火的《火影忍者》与《死神》。</p>\n<p>感谢有你，让我初中的三年是过得如此的充实。</p>\n<p>我与ZR直到初三的时候才因为座位离得近，才有更好的认识，渐渐地也了解多了，我发现和她是能比较聊得来的人。直到高中后，我才发现我有这样一个异性朋友是多么的值得。高中时，每一次的情感挫折都向她倾述，我现在已经有点模糊记忆了，高中时不知道跟她讲了多少我的故事给她。</p>\n<p>我清晰地记得高二时，我的爷爷在凌晨两点去世，那时候我感觉全世界都塌了，我发了几条短信给她，我想告诉她我当时真的很难受，后来在她的安慰下，我慢慢地走了出来。她成了我倾述的对象，不开心的时候，跟她聊聊，总会好起来。每年的生日，她总是会记得，也会送我礼物，当然也记得她的生日，我记得曾经做过几个视频给她，是她十七岁的时候，收集她的照片，最终做成了一个MV，现在再回头看看当时的视频，也是蛮有回忆感的。我家里仍然还保留着我十七八岁时她送我的礼物，以及信件。</p>\n<p>感谢有你，让我高中的三年是过得如此的充实。</p>\n<p>ZR与XBC是我十年的老朋友了，十年的朋友，实在是太难得了，我不知道这是一种如何的缘分，你们是我最好的朋友，也是我现在在外漂泊，愿哪天能回到故乡时的动力。你们作为我朋友中的情侣模范，实在是竖立了榜样给我们，让我再一次感受到爱情的存在。<br>感谢有你们，让我生活充满生机。</p>\n<p>此时我打开网易云播放一首张宇的《<a href=\"https://music.163.com/song?id=190499&userid=446412439\">给你们</a>》，在遥远的上海默默地祝福你们，很喜欢一首民国时期的结婚证书上的誓词送给你们：</p>\n<blockquote>\n<p>喜今日两姓联姻，一堂缔约，良缘永结，匹配同称。 看此日桃花灼灼，宜室宜家，卜他年瓜瓞绵绵，尔昌尔炽。<br>谨以白头之约，书向鸿笺，好将红叶之盟，载明鸳谱。</p>\n</blockquote>\n","cover":null,"images":[],"content":"<p>2020年6月15日，我最好的初高中朋友ZR（女）和XBC（男）在今天拿到了结婚证了，结束了快十年的爱情长跑。我和他们都是在初中的时候认识的，后来在一个高中，大学便分别了。虽然每年只会在过年的时候才会见面，但是那种友情却不因时间和距离而减。对于他们拿到结婚证，今天也是突然有感于其中。</p>\n<p>我与XBC是初中是最好的朋友了，那时候我们正值青春懵懂时期，我与他干了不少“坏事”，上课调皮捣蛋，晚上就寝与老师斗智斗勇。班主任罚检讨、被挨打、被体罚不知道有多少次，那时候正值青春叛逆时期，懵懂无知，做了很多有趣的事情，现在回想起来都是一串串难忘的记忆。</p>\n<p>还记得初中时候跟他聊的特别多，上课也是聊天，我们总会产生各种鬼主意。我们聊着那时候玩过的游戏DOTA、重装机兵，我们都追着Justin Bieber、Taylor Swift并哼唱着他们的歌，以及追着当时正火的《火影忍者》与《死神》。</p>\n<p>感谢有你，让我初中的三年是过得如此的充实。</p>\n<p>我与ZR直到初三的时候才因为座位离得近，才有更好的认识，渐渐地也了解多了，我发现和她是能比较聊得来的人。直到高中后，我才发现我有这样一个异性朋友是多么的值得。高中时，每一次的情感挫折都向她倾述，我现在已经有点模糊记忆了，高中时不知道跟她讲了多少我的故事给她。</p>\n<p>我清晰地记得高二时，我的爷爷在凌晨两点去世，那时候我感觉全世界都塌了，我发了几条短信给她，我想告诉她我当时真的很难受，后来在她的安慰下，我慢慢地走了出来。她成了我倾述的对象，不开心的时候，跟她聊聊，总会好起来。每年的生日，她总是会记得，也会送我礼物，当然也记得她的生日，我记得曾经做过几个视频给她，是她十七岁的时候，收集她的照片，最终做成了一个MV，现在再回头看看当时的视频，也是蛮有回忆感的。我家里仍然还保留着我十七八岁时她送我的礼物，以及信件。</p>\n<p>感谢有你，让我高中的三年是过得如此的充实。</p>\n<p>ZR与XBC是我十年的老朋友了，十年的朋友，实在是太难得了，我不知道这是一种如何的缘分，你们是我最好的朋友，也是我现在在外漂泊，愿哪天能回到故乡时的动力。你们作为我朋友中的情侣模范，实在是竖立了榜样给我们，让我再一次感受到爱情的存在。<br>感谢有你们，让我生活充满生机。</p>\n<p>此时我打开网易云播放一首张宇的《<a href=\"https://music.163.com/song?id=190499&userid=446412439\">给你们</a>》，在遥远的上海默默地祝福你们，很喜欢一首民国时期的结婚证书上的誓词送给你们：</p>\n<blockquote>\n<p>喜今日两姓联姻，一堂缔约，良缘永结，匹配同称。 看此日桃花灼灼，宜室宜家，卜他年瓜瓞绵绵，尔昌尔炽。<br>谨以白头之约，书向鸿笺，好将红叶之盟，载明鸳谱。</p>\n</blockquote>\n","categories":[{"name":"生活感想","slug":"life","api":"api/categories/life.json"}],"tags":[{"name":"省","slug":"thinking","api":"api/tags/thinking.json"}],"api":"api/posts/2020/06/15/关于朋友.json"},{"title":"《费马大定理》","slug":"《费马大定理》","date":"2020-06-09T14:32:00.000Z","updated":"2025-05-20T11:46:57.000Z","comments":true,"url":"2020/06/09/《费马大定理》/","excerpt":"<p>大约在1637年左右，法国学者费马在阅读丢番图《算术》拉丁文译本时，曾在第11卷第8命题旁写道：</p>\n<blockquote>\n<p>将一个立方数分成两个立方数之和，或一个四次幂分成两个四次幂之和，或者一般地将一个高于二次的幂分成两个同次幂之和，这是不可能的。关于此，我确信已发现了一种美妙的证法，可惜这里空白的地方太小，写不下。</p>\n</blockquote>\n<p>其中的条件用数学表达语言则：<br>$$<br>当整数n &gt;2时，关于x, y, z的方程 x^n + y^n &#x3D; z^n 没有正整数解。<br>$$</p>\n<p>这个数学理论简单明了，初中生都能看懂的理论，但是没有被得到最终的证明，费马自己提出来，没有得到完全的证明，他只证明了n&#x3D;4的情况，后来欧拉沿着费马“无穷递降法”的思路，再向前迈出小小的一步，将n&#x3D;4延伸到n&#x3D;3的情形。但是大于4的情况呢？</p>\n<p>费马的一段话，让数学界开始了长达300年的数学接力，有高斯、欧拉等诸多著名数学家都有尝试去彻底解决这个问题，但都无果。甚至后来开始推断出这是一个不能被证明的理论，在证明路上数学家们一直因证明失败而被打击，但这并不不能阻碍数学家们对这个问题的证明。最终，358年后，由英国数学家安德鲁.怀尔斯在1994成功完成了证明。看似轻描淡写，但有多少数学家在他证明的路上铺上了砖石呢？从费马提出到欧拉解决了n&#x3D;3的情况，中途诸多数学家的猜想与推论，最后谷山与志村提出的“谷山-志村猜想”，<strong>只要能证明“谷山-志村猜想”就能自动证明费马大定理</strong>。就这样，一个大问题被一点点地解决了，但时间长达300多年。</p>\n<p>《费马大定理》是是一部数学史，整本书以时间为基线，讲从费马提出这个问题开始，到最终怀尔斯完全证明费马大定理的过程。自己虽然对于数学没有很深入的了解，但是整本书看下来也是十分的吸引人，像我们熟知的毕达哥拉斯定理（勾股定理）与费马大定理联系起来（n&#x3D;2的情况是有正数解的），$\\sqrt{2}$ 是无理数的欧几里得证明等，就算对数学不太了解的人，也会为其中的证明技巧所感叹。</p>\n<p>当然本书中所有的数学家的故事都是一个振奋人心的角色，为证明费马大定理前赴后继，铸就了数学史诗，关于他们奋斗的故事，可以去仔细了解。除此之外，这本书给人最大的感触就是：<strong>站在巨人的肩膀上</strong>。</p>\n<p>如果说怀尔斯证明出来费马大定理是他一个人的功劳，那肯定很多人不会服了。如果说怀尔斯是站在了巨人的肩膀上，那么前面那么多的数学家共同组成了这个巨人。对于怀尔斯之前的谷山与志村则站在了“模形式”巨人上。对于怀尔斯证明完成之后，要直接使用费马大定理，那么怀尔斯又与前面那么多的数学家一起组成了更大的巨人。之后的数学学科利用费马大定理做一些更深入的研究后，那么这个巨人便变得更大了。</p>\n<p>为了证明费马大定理，产生了许多数学成果，拓宽了数学的领域，促进了数学的发展，数学家们将数学这个巨人变得越来越大。现代学科研究，利用数学，将物理学科的巨人变大，将计算机学科巨人变大……最终使整个科技巨人变大。而我们只需要站在巨人的肩膀上，只需要鼠标一点，这些巨人便开始奔跑。虽然说积跬步虽也能成千里，但远不如坐上高铁走四方，这便是站在巨人的肩膀上，而巨人是一代代人前赴后继的结果。</p>\n<p>最后补充一个：为什么费马大定理在数学史上的地位如此重要？<br>有人答道</p>\n<blockquote>\n<p>丢番图、毕达哥拉斯、费马、热尔曼、柯西、欧拉、希尔伯特、哥德尔、图灵、伽罗瓦、谷山丰、志村五郎、沃尔夫斯凯尔、怀尔斯……这些数学史上最伟大的名字，在整个「费马定理大戏」上轮番登场。他们有的奠定了数论基础、有的为提出费马定理铺平道路，有的提出问题却不给解答，有的人尝试了却失败，有的人只能证明部分结论，有的人没有想过证明这个定理却因为自己另一个数学理论创新而成为整个解答的关键，而这个解答却一度被学界不能理解而弃如敝履，有的人在攀登数学高峰的途中逝世，也有的人在面对人生失意决心自尽却因死前无聊看到了这个费马定理而心生兴趣尝试解答最后放弃自杀，设立巨额奖金奖励解答者！</p>\n</blockquote>\n<p>这是一部数学史诗，也是人类智慧最伟大的故事之一。</p>\n","cover":null,"images":[],"content":"<p>大约在1637年左右，法国学者费马在阅读丢番图《算术》拉丁文译本时，曾在第11卷第8命题旁写道：</p>\n<blockquote>\n<p>将一个立方数分成两个立方数之和，或一个四次幂分成两个四次幂之和，或者一般地将一个高于二次的幂分成两个同次幂之和，这是不可能的。关于此，我确信已发现了一种美妙的证法，可惜这里空白的地方太小，写不下。</p>\n</blockquote>\n<p>其中的条件用数学表达语言则：<br>$$<br>当整数n &gt;2时，关于x, y, z的方程 x^n + y^n &#x3D; z^n 没有正整数解。<br>$$</p>\n<p>这个数学理论简单明了，初中生都能看懂的理论，但是没有被得到最终的证明，费马自己提出来，没有得到完全的证明，他只证明了n&#x3D;4的情况，后来欧拉沿着费马“无穷递降法”的思路，再向前迈出小小的一步，将n&#x3D;4延伸到n&#x3D;3的情形。但是大于4的情况呢？</p>\n<p>费马的一段话，让数学界开始了长达300年的数学接力，有高斯、欧拉等诸多著名数学家都有尝试去彻底解决这个问题，但都无果。甚至后来开始推断出这是一个不能被证明的理论，在证明路上数学家们一直因证明失败而被打击，但这并不不能阻碍数学家们对这个问题的证明。最终，358年后，由英国数学家安德鲁.怀尔斯在1994成功完成了证明。看似轻描淡写，但有多少数学家在他证明的路上铺上了砖石呢？从费马提出到欧拉解决了n&#x3D;3的情况，中途诸多数学家的猜想与推论，最后谷山与志村提出的“谷山-志村猜想”，<strong>只要能证明“谷山-志村猜想”就能自动证明费马大定理</strong>。就这样，一个大问题被一点点地解决了，但时间长达300多年。</p>\n<p>《费马大定理》是是一部数学史，整本书以时间为基线，讲从费马提出这个问题开始，到最终怀尔斯完全证明费马大定理的过程。自己虽然对于数学没有很深入的了解，但是整本书看下来也是十分的吸引人，像我们熟知的毕达哥拉斯定理（勾股定理）与费马大定理联系起来（n&#x3D;2的情况是有正数解的），$\\sqrt{2}$ 是无理数的欧几里得证明等，就算对数学不太了解的人，也会为其中的证明技巧所感叹。</p>\n<p>当然本书中所有的数学家的故事都是一个振奋人心的角色，为证明费马大定理前赴后继，铸就了数学史诗，关于他们奋斗的故事，可以去仔细了解。除此之外，这本书给人最大的感触就是：<strong>站在巨人的肩膀上</strong>。</p>\n<p>如果说怀尔斯证明出来费马大定理是他一个人的功劳，那肯定很多人不会服了。如果说怀尔斯是站在了巨人的肩膀上，那么前面那么多的数学家共同组成了这个巨人。对于怀尔斯之前的谷山与志村则站在了“模形式”巨人上。对于怀尔斯证明完成之后，要直接使用费马大定理，那么怀尔斯又与前面那么多的数学家一起组成了更大的巨人。之后的数学学科利用费马大定理做一些更深入的研究后，那么这个巨人便变得更大了。</p>\n<p>为了证明费马大定理，产生了许多数学成果，拓宽了数学的领域，促进了数学的发展，数学家们将数学这个巨人变得越来越大。现代学科研究，利用数学，将物理学科的巨人变大，将计算机学科巨人变大……最终使整个科技巨人变大。而我们只需要站在巨人的肩膀上，只需要鼠标一点，这些巨人便开始奔跑。虽然说积跬步虽也能成千里，但远不如坐上高铁走四方，这便是站在巨人的肩膀上，而巨人是一代代人前赴后继的结果。</p>\n<p>最后补充一个：为什么费马大定理在数学史上的地位如此重要？<br>有人答道</p>\n<blockquote>\n<p>丢番图、毕达哥拉斯、费马、热尔曼、柯西、欧拉、希尔伯特、哥德尔、图灵、伽罗瓦、谷山丰、志村五郎、沃尔夫斯凯尔、怀尔斯……这些数学史上最伟大的名字，在整个「费马定理大戏」上轮番登场。他们有的奠定了数论基础、有的为提出费马定理铺平道路，有的提出问题却不给解答，有的人尝试了却失败，有的人只能证明部分结论，有的人没有想过证明这个定理却因为自己另一个数学理论创新而成为整个解答的关键，而这个解答却一度被学界不能理解而弃如敝履，有的人在攀登数学高峰的途中逝世，也有的人在面对人生失意决心自尽却因死前无聊看到了这个费马定理而心生兴趣尝试解答最后放弃自杀，设立巨额奖金奖励解答者！</p>\n</blockquote>\n<p>这是一部数学史诗，也是人类智慧最伟大的故事之一。</p>\n","categories":[{"name":"读书电影","slug":"movie","api":"api/categories/movie.json"}],"tags":[{"name":"数学","slug":"数学","api":"api/tags/数学.json"}],"api":"api/posts/2020/06/09/《费马大定理》.json"},{"title":"Http缓存机制","slug":"Http缓存机制","date":"2020-04-20T03:45:00.000Z","updated":"2025-05-20T11:46:57.000Z","comments":true,"url":"2020/04/20/Http缓存机制/","excerpt":"<p>最近有接触到Http缓存机制的问题，自己进行一个总结。</p>\n<p>浏览器加载一个页面的缓存流程如下：1. 浏览器先根据Http Header信息来判断是否命中<strong>强缓存</strong>。如果命中则直接加载本地缓存中的资源，并不会将请求发送到服务器。<br> 2. 如果未命中强缓存，则浏览器会将资源加载请求发送到服务器。服务器来判断浏览器本地缓存是否失效。若可以使用，则服务器并不会返回资源信息，浏览器继续从缓存加载资源，虽然与强缓存加载的是“同一份缓存”，但是由于流程与性质不一样，我们把它叫做<strong>协商缓存</strong>。<br> 3. 如果未命中<strong>协商缓存</strong>，则服务器会将完整的资源返回给浏览器，浏览器加载新资源，并更新缓存。</p>\n<p><strong>强缓存</strong>：不会向服务器发送请求,直接从本地缓存中读取资源返回<strong>200</strong>的状态码。</p>\n<p>from memory cache一般脚本、字体、图片会存在内存当中 </p>\n<p>from disk cache一般非脚本会存在磁盘当中，如css等 </p>\n<p><strong>协商缓存</strong>：向服务器发送请求,服务器根据请求中的Header的字段判断是否命中协商缓存,如果命中,则返回<strong>304</strong>状态码并带上新的响应头通知浏览器从缓存中读取资源</p>\n<p>与之相关的字段为：<br>强缓存：<strong>cache-control、expires</strong><br>协商缓存：<strong>Last-Modified&#x2F;if-Modified-Since、Etag&#x2F;if-None-Match.</strong></p>\n<p>其实整个缓存机制也就是围绕着这几个字段所展开</p>\n<h2 id=\"二、强缓存流程\"><a href=\"#二、强缓存流程\" class=\"headerlink\" title=\"二、强缓存流程\"></a>二、强缓存流程</h2><p>强缓存是由Http的Response Header中的<strong>Expires</strong>或者<strong>Cache-Control</strong>两个字段来控制的，用来表示资源的缓存时间。如果Cache-control与expires同时存在的话，Cache-control的优先级高于expires。</p>\n<h4 id=\"Expires\"><a href=\"#Expires\" class=\"headerlink\" title=\"Expires\"></a>Expires</h4><p>是一个http1.0提出的概念，它描述的是一个绝对时间，由服务端返回</p>\n<blockquote>\n<p><code>expires: Mon, 11 Jun 2029 08:34:12 GMT</code></p>\n</blockquote>\n<h4 id=\"Cache-Control\"><a href=\"#Cache-Control\" class=\"headerlink\" title=\"Cache-Control\"></a>Cache-Control</h4><p>Catche-control是http1.1提出的概念，优先级高于expires，描述的是一个相对时间</p>\n<blockquote>\n<p><code>cache-control: max-age=315360000</code></p>\n</blockquote>\n<p>除了max-age外，cache-control还有其他几个参数：<br><strong>-no-cache</strong>：不使用本地缓存。需要使用缓存协商，先与服务器确认返回的响应是否被更改，如果之前的响应中存在ETag，那么请求的时候会与服务端验证，如果资源未被更改，则可以避免重新下载。<br><strong>-no-store</strong>：直接禁止浏览器缓存数据，每次用户请求该资源，都会向服务器发送一个请求，每次都会下载完整的资源。<br><strong>-public</strong>：可以被所有的用户缓存，包括终端用户和CDN等中间代理服务器。<br><strong>-private</strong>：只能被终端用户的浏览器缓存，不允许CDN等中继缓存服务器对其缓存。</p>\n<p>如过Cache-Control和Expires条件都不满足，也就是说：像cache-control的字段为-no-cache和-no-store以及max-age不满足条件或者当前时间大于Expires的时间的时候，那么强缓存是没有被命中的，接下来要继续进行协商缓存的流程。</p>\n<h2 id=\"三、协商缓存流程\"><a href=\"#三、协商缓存流程\" class=\"headerlink\" title=\"三、协商缓存流程\"></a>三、协商缓存流程</h2><p>协商缓存相对于强缓存流程就复杂一点了，主要通过：<strong>Last-Modified&#x2F;If-Modified-Since</strong>和<strong>ETag&#x2F;If-None-Match</strong>来控制。Etag是服务器自动生成或者由开发者生成的对应资源在服务器端的唯一标识符，能够更加准确的控制缓存。Last-Modified与ETag是可以一起使用的，服务器会优先验证ETag，一致的情况下，才会继续比对Last-Modified，最后才决定是否返回<strong>304</strong>。</p>\n<h4 id=\"Last-Modified-If-Modified-Since\"><a href=\"#Last-Modified-If-Modified-Since\" class=\"headerlink\" title=\"Last-Modified&#x2F;If-Modified-Since\"></a>Last-Modified&#x2F;If-Modified-Since</h4><p>Last-Modified 表示本地文件最后修改日期，浏览器会在Request Header加上If-Modified-Since（上次返回的Last-Modified的值），询问服务器在该日期后资源是否有更新，有更新的话就会将新的资源发送回来。</p>\n<p>但是单纯使用Last-Modified 会有以下问题：</p>\n<ol>\n<li><p>Last-Modified标注的最后修改只能精确到秒级，如果某些文件在1秒钟以内，被修改多次的话，它将不能准确标注文件的修改时间</p>\n</li>\n<li><p>如果某些文件会被定期生成，当有时内容并没有任何变化，但Last-Modified却改变了，导致文件没法使用缓存</p>\n</li>\n<li><p>有可能存在服务器没有准确获取文件修改时间，或者与代理服务器时间不一致等情形</p>\n</li>\n</ol>\n<p>所以在HTTP&#x2F;1.1的时候加入了ETag&#x2F;If-None-Match来解决这些问题，因而ETag的优先级高于Last-Modified。</p>\n<h4 id=\"ETag-If-None-Match\"><a href=\"#ETag-If-None-Match\" class=\"headerlink\" title=\"ETag&#x2F;If-None-Match\"></a>ETag&#x2F;If-None-Match</h4><p>ETag可以保证每一个资源是唯一的，资源变化都会导致ETag变化。ETag值的变更则说明资源状态已经被修改。服务器根据浏览器上发送的If-None-Match值来判断是否命中缓存。</p>\n<p>If-None-Match的header会将上次返回的Etag发送给服务器，询问该资源的Etag是否有更新，有变动就会发送新的资源回来.</p>\n<p>Etag是服务器自动生成或者由开发者生成的对应资源在服务器端的唯一标识符，能够更加准确的控制缓存。<strong>Last-Modified与ETag是可以一起使用的，服务器会优先验证ETag，一致的情况下，才会继续比对Last-Modified，最后才决定是否返回304。</strong></p>\n<h2 id=\"四、总结\"><a href=\"#四、总结\" class=\"headerlink\" title=\"四、总结\"></a>四、总结</h2><p>一、由于HTTP一直在发展，所以对于HTTP的缓存字段也变得越来越复杂，其实我们很清晰的可以知道Expires与Last-Modified&#x2F;If-Modified-Since是Http&#x2F;1.0时代的产物。 Cache-Control与ETag&#x2F;If-None-Match是HTTP&#x2F;1.1为解决HTTP&#x2F;1.0新增出来的字段，这样对比去记忆理解起来，其实缓存机制也就变得很好理解了。</p>\n<p>二、对于第一次请求（肯定是没有任何缓存的），那么直接向服务器请求资源并将下载好的资源进行缓存，为下一次请求做缓存准备。</p>\n<p>三、对于第二次之后的请求，那么本地是有缓存的，那么先通过cache-control的规则判断（对于Http1.0还是Expires）来判断本地缓存是否过期，如果没过期，那么直接使用。如果过期了，就再判断Etag（具体流程可以参考：<a href=\"https://blog.csdn.net/kikikind/article/details/6266101\">Etag与HTTP缓存机制</a>），通过发送If-None-Match（也就是上次存入的Tag的值），服务器进行一个决策判断返回200还是304。之前有说到，Last-Modified与ETag是可以一起使用的，服务器会优先验证ETag，也就是Etag不存在或者其他情况那么会使用Last-Modified来进行判断，通过向服务器发送If-Modified-Since，然后服务器进行一次决策。</p>\n<p>看流程图可能一下子就明白了：</p>\n<p><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWFnZXMyMDE4LmNuYmxvZ3MuY29tL2Jsb2cvOTQwODg0LzIwMTgwNC85NDA4ODQtMjAxODA0MjMxNDE5NTE3MzUtOTEyNjk5MjEzLnBuZw?x-oss-process=image/format,png\"></p>\n<p>参考：</p>\n<p><a href=\"https://www.jianshu.com/p/19c2e397e22a\">https://www.cnblogs.com/ranyonsue/p/8918908.html</a><br><a href=\"https://www.jianshu.com/p/19c2e397e22a\">https://www.jianshu.com/p/19c2e397e22a</a></p>\n","cover":null,"images":["https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWFnZXMyMDE4LmNuYmxvZ3MuY29tL2Jsb2cvOTQwODg0LzIwMTgwNC85NDA4ODQtMjAxODA0MjMxNDE5NTE3MzUtOTEyNjk5MjEzLnBuZw?x-oss-process=image/format,png"],"content":"<p>最近有接触到Http缓存机制的问题，自己进行一个总结。</p>\n<p>浏览器加载一个页面的缓存流程如下：1. 浏览器先根据Http Header信息来判断是否命中<strong>强缓存</strong>。如果命中则直接加载本地缓存中的资源，并不会将请求发送到服务器。<br> 2. 如果未命中强缓存，则浏览器会将资源加载请求发送到服务器。服务器来判断浏览器本地缓存是否失效。若可以使用，则服务器并不会返回资源信息，浏览器继续从缓存加载资源，虽然与强缓存加载的是“同一份缓存”，但是由于流程与性质不一样，我们把它叫做<strong>协商缓存</strong>。<br> 3. 如果未命中<strong>协商缓存</strong>，则服务器会将完整的资源返回给浏览器，浏览器加载新资源，并更新缓存。</p>\n<p><strong>强缓存</strong>：不会向服务器发送请求,直接从本地缓存中读取资源返回<strong>200</strong>的状态码。</p>\n<p>from memory cache一般脚本、字体、图片会存在内存当中 </p>\n<p>from disk cache一般非脚本会存在磁盘当中，如css等 </p>\n<p><strong>协商缓存</strong>：向服务器发送请求,服务器根据请求中的Header的字段判断是否命中协商缓存,如果命中,则返回<strong>304</strong>状态码并带上新的响应头通知浏览器从缓存中读取资源</p>\n<p>与之相关的字段为：<br>强缓存：<strong>cache-control、expires</strong><br>协商缓存：<strong>Last-Modified&#x2F;if-Modified-Since、Etag&#x2F;if-None-Match.</strong></p>\n<p>其实整个缓存机制也就是围绕着这几个字段所展开</p>\n<h2 id=\"二、强缓存流程\"><a href=\"#二、强缓存流程\" class=\"headerlink\" title=\"二、强缓存流程\"></a>二、强缓存流程</h2><p>强缓存是由Http的Response Header中的<strong>Expires</strong>或者<strong>Cache-Control</strong>两个字段来控制的，用来表示资源的缓存时间。如果Cache-control与expires同时存在的话，Cache-control的优先级高于expires。</p>\n<h4 id=\"Expires\"><a href=\"#Expires\" class=\"headerlink\" title=\"Expires\"></a>Expires</h4><p>是一个http1.0提出的概念，它描述的是一个绝对时间，由服务端返回</p>\n<blockquote>\n<p><code>expires: Mon, 11 Jun 2029 08:34:12 GMT</code></p>\n</blockquote>\n<h4 id=\"Cache-Control\"><a href=\"#Cache-Control\" class=\"headerlink\" title=\"Cache-Control\"></a>Cache-Control</h4><p>Catche-control是http1.1提出的概念，优先级高于expires，描述的是一个相对时间</p>\n<blockquote>\n<p><code>cache-control: max-age=315360000</code></p>\n</blockquote>\n<p>除了max-age外，cache-control还有其他几个参数：<br><strong>-no-cache</strong>：不使用本地缓存。需要使用缓存协商，先与服务器确认返回的响应是否被更改，如果之前的响应中存在ETag，那么请求的时候会与服务端验证，如果资源未被更改，则可以避免重新下载。<br><strong>-no-store</strong>：直接禁止浏览器缓存数据，每次用户请求该资源，都会向服务器发送一个请求，每次都会下载完整的资源。<br><strong>-public</strong>：可以被所有的用户缓存，包括终端用户和CDN等中间代理服务器。<br><strong>-private</strong>：只能被终端用户的浏览器缓存，不允许CDN等中继缓存服务器对其缓存。</p>\n<p>如过Cache-Control和Expires条件都不满足，也就是说：像cache-control的字段为-no-cache和-no-store以及max-age不满足条件或者当前时间大于Expires的时间的时候，那么强缓存是没有被命中的，接下来要继续进行协商缓存的流程。</p>\n<h2 id=\"三、协商缓存流程\"><a href=\"#三、协商缓存流程\" class=\"headerlink\" title=\"三、协商缓存流程\"></a>三、协商缓存流程</h2><p>协商缓存相对于强缓存流程就复杂一点了，主要通过：<strong>Last-Modified&#x2F;If-Modified-Since</strong>和<strong>ETag&#x2F;If-None-Match</strong>来控制。Etag是服务器自动生成或者由开发者生成的对应资源在服务器端的唯一标识符，能够更加准确的控制缓存。Last-Modified与ETag是可以一起使用的，服务器会优先验证ETag，一致的情况下，才会继续比对Last-Modified，最后才决定是否返回<strong>304</strong>。</p>\n<h4 id=\"Last-Modified-If-Modified-Since\"><a href=\"#Last-Modified-If-Modified-Since\" class=\"headerlink\" title=\"Last-Modified&#x2F;If-Modified-Since\"></a>Last-Modified&#x2F;If-Modified-Since</h4><p>Last-Modified 表示本地文件最后修改日期，浏览器会在Request Header加上If-Modified-Since（上次返回的Last-Modified的值），询问服务器在该日期后资源是否有更新，有更新的话就会将新的资源发送回来。</p>\n<p>但是单纯使用Last-Modified 会有以下问题：</p>\n<ol>\n<li><p>Last-Modified标注的最后修改只能精确到秒级，如果某些文件在1秒钟以内，被修改多次的话，它将不能准确标注文件的修改时间</p>\n</li>\n<li><p>如果某些文件会被定期生成，当有时内容并没有任何变化，但Last-Modified却改变了，导致文件没法使用缓存</p>\n</li>\n<li><p>有可能存在服务器没有准确获取文件修改时间，或者与代理服务器时间不一致等情形</p>\n</li>\n</ol>\n<p>所以在HTTP&#x2F;1.1的时候加入了ETag&#x2F;If-None-Match来解决这些问题，因而ETag的优先级高于Last-Modified。</p>\n<h4 id=\"ETag-If-None-Match\"><a href=\"#ETag-If-None-Match\" class=\"headerlink\" title=\"ETag&#x2F;If-None-Match\"></a>ETag&#x2F;If-None-Match</h4><p>ETag可以保证每一个资源是唯一的，资源变化都会导致ETag变化。ETag值的变更则说明资源状态已经被修改。服务器根据浏览器上发送的If-None-Match值来判断是否命中缓存。</p>\n<p>If-None-Match的header会将上次返回的Etag发送给服务器，询问该资源的Etag是否有更新，有变动就会发送新的资源回来.</p>\n<p>Etag是服务器自动生成或者由开发者生成的对应资源在服务器端的唯一标识符，能够更加准确的控制缓存。<strong>Last-Modified与ETag是可以一起使用的，服务器会优先验证ETag，一致的情况下，才会继续比对Last-Modified，最后才决定是否返回304。</strong></p>\n<h2 id=\"四、总结\"><a href=\"#四、总结\" class=\"headerlink\" title=\"四、总结\"></a>四、总结</h2><p>一、由于HTTP一直在发展，所以对于HTTP的缓存字段也变得越来越复杂，其实我们很清晰的可以知道Expires与Last-Modified&#x2F;If-Modified-Since是Http&#x2F;1.0时代的产物。 Cache-Control与ETag&#x2F;If-None-Match是HTTP&#x2F;1.1为解决HTTP&#x2F;1.0新增出来的字段，这样对比去记忆理解起来，其实缓存机制也就变得很好理解了。</p>\n<p>二、对于第一次请求（肯定是没有任何缓存的），那么直接向服务器请求资源并将下载好的资源进行缓存，为下一次请求做缓存准备。</p>\n<p>三、对于第二次之后的请求，那么本地是有缓存的，那么先通过cache-control的规则判断（对于Http1.0还是Expires）来判断本地缓存是否过期，如果没过期，那么直接使用。如果过期了，就再判断Etag（具体流程可以参考：<a href=\"https://blog.csdn.net/kikikind/article/details/6266101\">Etag与HTTP缓存机制</a>），通过发送If-None-Match（也就是上次存入的Tag的值），服务器进行一个决策判断返回200还是304。之前有说到，Last-Modified与ETag是可以一起使用的，服务器会优先验证ETag，也就是Etag不存在或者其他情况那么会使用Last-Modified来进行判断，通过向服务器发送If-Modified-Since，然后服务器进行一次决策。</p>\n<p>看流程图可能一下子就明白了：</p>\n<p><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWFnZXMyMDE4LmNuYmxvZ3MuY29tL2Jsb2cvOTQwODg0LzIwMTgwNC85NDA4ODQtMjAxODA0MjMxNDE5NTE3MzUtOTEyNjk5MjEzLnBuZw?x-oss-process=image/format,png\"></p>\n<p>参考：</p>\n<p><a href=\"https://www.jianshu.com/p/19c2e397e22a\">https://www.cnblogs.com/ranyonsue/p/8918908.html</a><br><a href=\"https://www.jianshu.com/p/19c2e397e22a\">https://www.jianshu.com/p/19c2e397e22a</a></p>\n","categories":[{"name":"技术文章","slug":"technology","api":"api/categories/technology.json"}],"tags":[{"name":"Http","slug":"Http","api":"api/tags/Http.json"}],"api":"api/posts/2020/04/20/Http缓存机制.json"},{"title":"诗歌-《再见》","slug":"诗歌-《再见》","date":"2020-03-29T11:43:00.000Z","updated":"2025-05-20T11:46:57.000Z","comments":true,"url":"2020/03/29/诗歌-《再见》/","excerpt":"<p>再见<br>是离时的伤感<br>静静地来了<br>悄悄地离开<br>伤感的是那<br>来时的晴天白云<br>离时的栉风沐雨</p>\n<p>再见<br>是离时的不舍<br>多少日夜兼程<br>多少风雨无阻<br>不舍的是那<br>专研执著的精神<br>是那昔时的人儿</p>\n<p>再见<br>是对君的怀念<br>念与君时的如沐春风<br>怀与君时的意气风发<br>看烛烬月半沉<br>听蛩噪院已深<br>心悦君兮君可知？</p>\n<p>再见<br>只是为了下次更好的见</p>\n<p>あなたに会えて嬉しい<br>私の名前はジュルリス</p>\n<p>NICE TO MEET U.<br>I AM JU1IS.</p>\n","cover":null,"images":[],"content":"<p>再见<br>是离时的伤感<br>静静地来了<br>悄悄地离开<br>伤感的是那<br>来时的晴天白云<br>离时的栉风沐雨</p>\n<p>再见<br>是离时的不舍<br>多少日夜兼程<br>多少风雨无阻<br>不舍的是那<br>专研执著的精神<br>是那昔时的人儿</p>\n<p>再见<br>是对君的怀念<br>念与君时的如沐春风<br>怀与君时的意气风发<br>看烛烬月半沉<br>听蛩噪院已深<br>心悦君兮君可知？</p>\n<p>再见<br>只是为了下次更好的见</p>\n<p>あなたに会えて嬉しい<br>私の名前はジュルリス</p>\n<p>NICE TO MEET U.<br>I AM JU1IS.</p>\n","categories":[{"name":"生活感想","slug":"life","api":"api/categories/life.json"}],"tags":[{"name":"诗歌","slug":"诗歌","api":"api/tags/诗歌.json"}],"api":"api/posts/2020/03/29/诗歌-《再见》.json"},{"title":"哈夫曼树与编码","slug":"数据结构-哈夫曼Huffman树","date":"2020-03-24T01:38:00.000Z","updated":"2025-05-20T11:46:57.000Z","comments":true,"url":"2020/03/24/数据结构-哈夫曼Huffman树/","excerpt":"<p><strong>哈夫曼树定义：</strong></p>\n<blockquote>\n<p>给定N个权值作为N个叶子结点，构造一棵二叉树，若该树的带权路径长度达到最小，称这样的二叉树为最优二叉树，也称为哈夫曼树(Huffman<br>Tree)。哈夫曼树是带权路径长度最短的树，权值较大的结点离根较近。</p>\n</blockquote>\n<p>例：在数据通信中，需要将传送的文字转换成二进制的字符串，用0，1码的不同排列来表示字符。例如，需传送的报文为“AFTER DATA EAR ARE ART AREA”，这里用到的字符集为“A，E，R，T，F，D”，各字母出现的次数为{8，4，5，3，1，1}。现要求为这些字母设计编码。要区别6个字母，最简单的二进制编码方式是等长编码，固定采用3位二进制，可分别用000、001、010、011、100、101对“A，E，R，T，F，D”进行编码发送，当对方接收报文时再按照三位一分进行译码。显然编码的长度取决报文中不同字符的个数。</p>\n<h2 id=\"哈夫曼树创建方法\"><a href=\"#哈夫曼树创建方法\" class=\"headerlink\" title=\"哈夫曼树创建方法\"></a>哈夫曼树创建方法</h2><p>摘自：<a href=\"https://blog.csdn.net/FX677588/article/details/70767446\">《详细图解哈夫曼Huffman编码树》</a></p>\n<h3 id=\"2-1-初始队列\"><a href=\"#2-1-初始队列\" class=\"headerlink\" title=\"2.1 初始队列\"></a>2.1 初始队列</h3><p>　　我们按出现频率高低将其放入一个优先级队列中，从左到右依次为频率逐渐增加。\n　</p>\n<img src=\"https://cdn.julis.wang/blog/img/20200319094704131.png\">\n<p>　　下面我们需要将这个队列转换成哈夫曼二叉树，哈夫曼二叉树是一颗带权重的二叉树，权重是由队列中每个字符出现的次数所决定的。并且哈夫曼二叉树始终保证权重越大的字符出现在越高的地方。</p>\n<h3 id=\"2-2-第一步合并\"><a href=\"#2-2-第一步合并\" class=\"headerlink\" title=\"2.2 第一步合并\"></a>2.2 第一步合并</h3><p>　　首先我们从左到右进行合并，依次构建二叉树。第一步取前两个字符u和r来构造初始二叉树，第一个字符作为左节点，第二个元素作为右节点，然后两个元素相加作为新空元素，并且两者权重相加作为新元素的权重。\n　　</p>\n<img src=\"https://cdn.julis.wang/blog/img/20200319094810712.png\">\n\n<p>　　同理，新元素可以和字符i再合并，如下：</p>\n<img src=\"https://cdn.julis.wang/blog/img/20200319094824181.png\">\n\n<h3 id=\"2-3-重新调整队列\"><a href=\"#2-3-重新调整队列\" class=\"headerlink\" title=\"2.3 重新调整队列\"></a>2.3 重新调整队列</h3><p>　　上图新元素权重相加后结果是变大了，需要对权重进行重新排序。\n　　</p>\n<img src=\"https://cdn.julis.wang/blog/img/20200319094841561.png\">\n<p>　　然后再依次从左到右合并，每合并一次则进行一次队列重新排序调整。如下：</p>\n<img src=\"https://cdn.julis.wang/blog/img/2020031909485354.png\">\n<p>　　经过多步操作之后，得到以下的哈夫曼二叉树结构，也就是一个带有权重的二叉树：</p>\n<img src=\"https://cdn.julis.wang/blog/img/20200319094902609.png\">\n\n<h3 id=\"2-4-哈夫曼编码\"><a href=\"#2-4-哈夫曼编码\" class=\"headerlink\" title=\"2.4 哈夫曼编码\"></a>2.4 哈夫曼编码</h3><p>　　有了上面带权重的二叉树之后，我们就可以进行编码了。我们把二叉树分支中左边的支路编码为0，右边分支表示为1，如下图：\n　</p>\n<img src=\"https://cdn.julis.wang/blog/img/20200319094918382.png\">\n<p>　　这样依次遍历这颗二叉树就可以获取得到所有字符的编码了。例如：‘ ’的编码为10，‘l’的编码为00，‘u’的编码为11100等等。经过这个编码设置之后我们可以发现，出现频率越高的字符越会在上层，这样它的编码越短；出现频率越低的字符越会在下层，编码越短。经过这样的设计，最终整个文本存储空间才会最大化的缩减。<br>　　最终我们可以得到下面这张编码表：</p>\n<img src=\"https://cdn.julis.wang/blog/img/20200319094927897.png\">\n\n<h3 id=\"2-5-字符串编码\"><a href=\"#2-5-字符串编码\" class=\"headerlink\" title=\"2.5 字符串编码\"></a>2.5 字符串编码</h3><p>　　有了上面的编码表之后，”we will we will r u”这句重新进行编码就可以得到很大的压缩，编码表示为：01 110 10 01 1111 00 00 10 01 110 10 01 1111 00 00 10 11101 10 11100。这样最终我们只需50位内存，比原ASCII码表示节约了2&#x2F;3空间，效果还是很理想的。当然现实中不是简单这样表示的，还需要考虑很多问题。</p>\n<h2 id=\"三、哈夫曼编码的压缩与解压\"><a href=\"#三、哈夫曼编码的压缩与解压\" class=\"headerlink\" title=\"三、哈夫曼编码的压缩与解压\"></a>三、哈夫曼编码的压缩与解压</h2><p>1、使用IO流逐字节读取文档。用一个数组（0~255,下标表示ASCII码）来保存不同字符出现的次数<br>2、建一个节点类，保存节点对象的信息。将数组每一位表示的字符和出现频次存入创建的节点，把所有节点存入一个链表。<br>3、根据节点存储的频次值，对链表进行从小到大排序<br>4、从链表中取出并删除最小的两个节点，创建一个他们的父节点，父节点不存字符，值为那两个节点的和，把那两个节点分别作为其左子节点和右子节点，最后把这个父节点存入链表。再次排序，取出并删除最小的两个节点，生成父节点，再存入…以此类推，最终生成一棵哈夫曼树。<br>5、对哈夫曼树进行遍历，使得叶子结点获得相应编码，同时把字符和它对应的哈夫曼编码存入HashMap</p>\n<h2 id=\"四、疑问\"><a href=\"#四、疑问\" class=\"headerlink\" title=\"四、疑问\"></a>四、疑问</h2><h3 id=\"4-1对于字符频率相等的情况\"><a href=\"#4-1对于字符频率相等的情况\" class=\"headerlink\" title=\"4.1对于字符频率相等的情况\"></a>4.1对于字符频率相等的情况</h3><p>我们在构建哈夫曼树的时候在想，如果我们的字符出现的频率相等的情况，那哈夫曼树岂不是很糟？<br>我们假设原来字符串长度为N，那么对于普通的ASCII编码得到的长度为8N，如果利用哈夫曼编码，对于每一个字符，最大的长度不会超过8层树因为ASCII编码总共只有2^8个字符，也就是说最极端的情况：一个文件中所有字符串中出现256个字符且重复次数是一样的，但这仍然对原来的文本有进行过压缩（毕竟出现次数相等的话，构造的哈夫曼树在8层之前还是有数据的，那些数据的位数&lt;8）最终的编码数一定是会&lt;8N</p>\n<h3 id=\"4-2解码冲突问题\"><a href=\"#4-2解码冲突问题\" class=\"headerlink\" title=\"4.2解码冲突问题\"></a>4.2解码冲突问题</h3><p>我们在解压遍历哈夫曼的时候，最终的编码不会冲突么？举例：上面我们得到得最终的编码是<br>01 110 10 01 1111 00 00 10 01 110 10 01 1111 00 00 10 11101 10 11100但是在实际的压缩中我们不会有分隔符最终的情况将会是：<br>0111010 0111110000100111010011111000010111011011100<br>于是我们怎么知道：前面的01是一个编码，为什那么0111就是一个编码呢？也就是说01是0111的前缀 。其实我们从这张图就能看出来：对于上述的字符串一定不会存在一个叫0111的编码，因为“w”字母代表的01已经没有子节点。其实中也可以看出一些区域是空着的比如：11、111、111、1110 没有数据，其实这都是满足了哈夫曼树的 <strong>左起字串不冲突原则</strong></p>\n<img src=\"https://cdn.julis.wang/blog/img/20200319094918382.png\">\n\n\n\n","cover":null,"images":["https://cdn.julis.wang/blog/img/20200319094704131.png","https://cdn.julis.wang/blog/img/20200319094810712.png","https://cdn.julis.wang/blog/img/20200319094824181.png","https://cdn.julis.wang/blog/img/20200319094841561.png","https://cdn.julis.wang/blog/img/2020031909485354.png","https://cdn.julis.wang/blog/img/20200319094902609.png","https://cdn.julis.wang/blog/img/20200319094918382.png","https://cdn.julis.wang/blog/img/20200319094927897.png"],"content":"<p><strong>哈夫曼树定义：</strong></p>\n<blockquote>\n<p>给定N个权值作为N个叶子结点，构造一棵二叉树，若该树的带权路径长度达到最小，称这样的二叉树为最优二叉树，也称为哈夫曼树(Huffman<br>Tree)。哈夫曼树是带权路径长度最短的树，权值较大的结点离根较近。</p>\n</blockquote>\n<p>例：在数据通信中，需要将传送的文字转换成二进制的字符串，用0，1码的不同排列来表示字符。例如，需传送的报文为“AFTER DATA EAR ARE ART AREA”，这里用到的字符集为“A，E，R，T，F，D”，各字母出现的次数为{8，4，5，3，1，1}。现要求为这些字母设计编码。要区别6个字母，最简单的二进制编码方式是等长编码，固定采用3位二进制，可分别用000、001、010、011、100、101对“A，E，R，T，F，D”进行编码发送，当对方接收报文时再按照三位一分进行译码。显然编码的长度取决报文中不同字符的个数。</p>\n<h2 id=\"哈夫曼树创建方法\"><a href=\"#哈夫曼树创建方法\" class=\"headerlink\" title=\"哈夫曼树创建方法\"></a>哈夫曼树创建方法</h2><p>摘自：<a href=\"https://blog.csdn.net/FX677588/article/details/70767446\">《详细图解哈夫曼Huffman编码树》</a></p>\n<h3 id=\"2-1-初始队列\"><a href=\"#2-1-初始队列\" class=\"headerlink\" title=\"2.1 初始队列\"></a>2.1 初始队列</h3><p>　　我们按出现频率高低将其放入一个优先级队列中，从左到右依次为频率逐渐增加。\n　</p>\n<img src=\"https://cdn.julis.wang/blog/img/20200319094704131.png\">\n<p>　　下面我们需要将这个队列转换成哈夫曼二叉树，哈夫曼二叉树是一颗带权重的二叉树，权重是由队列中每个字符出现的次数所决定的。并且哈夫曼二叉树始终保证权重越大的字符出现在越高的地方。</p>\n<h3 id=\"2-2-第一步合并\"><a href=\"#2-2-第一步合并\" class=\"headerlink\" title=\"2.2 第一步合并\"></a>2.2 第一步合并</h3><p>　　首先我们从左到右进行合并，依次构建二叉树。第一步取前两个字符u和r来构造初始二叉树，第一个字符作为左节点，第二个元素作为右节点，然后两个元素相加作为新空元素，并且两者权重相加作为新元素的权重。\n　　</p>\n<img src=\"https://cdn.julis.wang/blog/img/20200319094810712.png\">\n\n<p>　　同理，新元素可以和字符i再合并，如下：</p>\n<img src=\"https://cdn.julis.wang/blog/img/20200319094824181.png\">\n\n<h3 id=\"2-3-重新调整队列\"><a href=\"#2-3-重新调整队列\" class=\"headerlink\" title=\"2.3 重新调整队列\"></a>2.3 重新调整队列</h3><p>　　上图新元素权重相加后结果是变大了，需要对权重进行重新排序。\n　　</p>\n<img src=\"https://cdn.julis.wang/blog/img/20200319094841561.png\">\n<p>　　然后再依次从左到右合并，每合并一次则进行一次队列重新排序调整。如下：</p>\n<img src=\"https://cdn.julis.wang/blog/img/2020031909485354.png\">\n<p>　　经过多步操作之后，得到以下的哈夫曼二叉树结构，也就是一个带有权重的二叉树：</p>\n<img src=\"https://cdn.julis.wang/blog/img/20200319094902609.png\">\n\n<h3 id=\"2-4-哈夫曼编码\"><a href=\"#2-4-哈夫曼编码\" class=\"headerlink\" title=\"2.4 哈夫曼编码\"></a>2.4 哈夫曼编码</h3><p>　　有了上面带权重的二叉树之后，我们就可以进行编码了。我们把二叉树分支中左边的支路编码为0，右边分支表示为1，如下图：\n　</p>\n<img src=\"https://cdn.julis.wang/blog/img/20200319094918382.png\">\n<p>　　这样依次遍历这颗二叉树就可以获取得到所有字符的编码了。例如：‘ ’的编码为10，‘l’的编码为00，‘u’的编码为11100等等。经过这个编码设置之后我们可以发现，出现频率越高的字符越会在上层，这样它的编码越短；出现频率越低的字符越会在下层，编码越短。经过这样的设计，最终整个文本存储空间才会最大化的缩减。<br>　　最终我们可以得到下面这张编码表：</p>\n<img src=\"https://cdn.julis.wang/blog/img/20200319094927897.png\">\n\n<h3 id=\"2-5-字符串编码\"><a href=\"#2-5-字符串编码\" class=\"headerlink\" title=\"2.5 字符串编码\"></a>2.5 字符串编码</h3><p>　　有了上面的编码表之后，”we will we will r u”这句重新进行编码就可以得到很大的压缩，编码表示为：01 110 10 01 1111 00 00 10 01 110 10 01 1111 00 00 10 11101 10 11100。这样最终我们只需50位内存，比原ASCII码表示节约了2&#x2F;3空间，效果还是很理想的。当然现实中不是简单这样表示的，还需要考虑很多问题。</p>\n<h2 id=\"三、哈夫曼编码的压缩与解压\"><a href=\"#三、哈夫曼编码的压缩与解压\" class=\"headerlink\" title=\"三、哈夫曼编码的压缩与解压\"></a>三、哈夫曼编码的压缩与解压</h2><p>1、使用IO流逐字节读取文档。用一个数组（0~255,下标表示ASCII码）来保存不同字符出现的次数<br>2、建一个节点类，保存节点对象的信息。将数组每一位表示的字符和出现频次存入创建的节点，把所有节点存入一个链表。<br>3、根据节点存储的频次值，对链表进行从小到大排序<br>4、从链表中取出并删除最小的两个节点，创建一个他们的父节点，父节点不存字符，值为那两个节点的和，把那两个节点分别作为其左子节点和右子节点，最后把这个父节点存入链表。再次排序，取出并删除最小的两个节点，生成父节点，再存入…以此类推，最终生成一棵哈夫曼树。<br>5、对哈夫曼树进行遍历，使得叶子结点获得相应编码，同时把字符和它对应的哈夫曼编码存入HashMap</p>\n<h2 id=\"四、疑问\"><a href=\"#四、疑问\" class=\"headerlink\" title=\"四、疑问\"></a>四、疑问</h2><h3 id=\"4-1对于字符频率相等的情况\"><a href=\"#4-1对于字符频率相等的情况\" class=\"headerlink\" title=\"4.1对于字符频率相等的情况\"></a>4.1对于字符频率相等的情况</h3><p>我们在构建哈夫曼树的时候在想，如果我们的字符出现的频率相等的情况，那哈夫曼树岂不是很糟？<br>我们假设原来字符串长度为N，那么对于普通的ASCII编码得到的长度为8N，如果利用哈夫曼编码，对于每一个字符，最大的长度不会超过8层树因为ASCII编码总共只有2^8个字符，也就是说最极端的情况：一个文件中所有字符串中出现256个字符且重复次数是一样的，但这仍然对原来的文本有进行过压缩（毕竟出现次数相等的话，构造的哈夫曼树在8层之前还是有数据的，那些数据的位数&lt;8）最终的编码数一定是会&lt;8N</p>\n<h3 id=\"4-2解码冲突问题\"><a href=\"#4-2解码冲突问题\" class=\"headerlink\" title=\"4.2解码冲突问题\"></a>4.2解码冲突问题</h3><p>我们在解压遍历哈夫曼的时候，最终的编码不会冲突么？举例：上面我们得到得最终的编码是<br>01 110 10 01 1111 00 00 10 01 110 10 01 1111 00 00 10 11101 10 11100但是在实际的压缩中我们不会有分隔符最终的情况将会是：<br>0111010 0111110000100111010011111000010111011011100<br>于是我们怎么知道：前面的01是一个编码，为什那么0111就是一个编码呢？也就是说01是0111的前缀 。其实我们从这张图就能看出来：对于上述的字符串一定不会存在一个叫0111的编码，因为“w”字母代表的01已经没有子节点。其实中也可以看出一些区域是空着的比如：11、111、111、1110 没有数据，其实这都是满足了哈夫曼树的 <strong>左起字串不冲突原则</strong></p>\n<img src=\"https://cdn.julis.wang/blog/img/20200319094918382.png\">\n\n\n\n","categories":[{"name":"算法研究","slug":"算法研究","api":"api/categories/算法研究.json"}],"tags":[{"name":"技术文章","slug":"technology","api":"api/tags/technology.json"}],"api":"api/posts/2020/03/24/数据结构-哈夫曼Huffman树.json"},{"title":"《寄生虫》观后感","slug":"《寄生虫》观后感","date":"2020-03-22T13:22:00.000Z","updated":"2025-05-20T11:46:57.000Z","comments":true,"url":"2020/03/22/《寄生虫》观后感/","excerpt":"<p>这个周末总共看了三部电影：《无人生还》《吹哨人》《寄生虫》，前两部看完之后并没有太多的触动，倒是寄生虫看得人实在是过瘾，整个电影的剧情发展，以及想要表达出来镜头语音都做到了极致，以及让人能够思索很久很久的电影余味，配得上所获得的无数奖项。</p>\n<p>电影最后以欢乐的party变为残忍的凶案为结局，很多电影中过场看得人是瞠目结舌。极力推荐大家去欣赏一下这部电影，剧作节奏，镜头语言，剧本钩子绝对不会让你失望。</p>\n<p>整部电影都围绕着电影名“寄生虫”展开，我们来看一下什么是“寄生虫”。“寄生虫”百科解释道：寄生虫（parasite）指具有致病性的低等真核生物，可作为病原体，也可作为媒介传播疾病。寄生虫特征为在宿主或寄主（host）体内或附着于体外以获取维持其生存、发育或者繁殖所需的营养或者庇护的一切生物。在这一段的解释中:  低等、寄生、生存 是其中的关键词，也是整部电影的关键词。</p>\n<p>电影中何为“低等”？或者说是相对而言的低等，电影中的低等则是活在社会底层的一家人-不大的屋子住在一家四口人，靠着折叠披萨盒子生存，上网需要到脏乱差的厕所最里面去蹭别人家的网。而高等则是富豪社长所在的家庭-著名建筑家设计的别墅里的家庭，专门的司机、保姆等。</p>\n<p>电影中的“寄生”，有两种情况：一是主角家庭利用一系列的欺骗手段，从而“寄生”在富豪家里，他们一家人虽然也生活在别墅里，吃一样的食物，睡一样的床，但是他们就像是房间里的蟑螂，一旦主人回来了，就立马躲起来，但蟑螂并不是每次都能藏得那么好的，一旦被发现后果不堪设想。二是原本看起来一切正常的“前保姆”与丈夫偷偷居住在别墅地下道四年，在主角家庭一家人到来之前，虽然他丈夫住在很阴暗的地下室里，但是他们过得很知足。</p>\n<p>那么生存呢？一切的生物活动都是为了生存和繁衍，这就将上述两个关键词结合在了一起，三者：两者低等寄生，一者高等宿主体。三者的关系则构成了：高等对低等、低等对低等。在影片的高潮部分表现得淋漓尽致：在富有家庭为儿子举办的生日宴上，意外再次发生。后来的低等“寄生”为了斩草除根掉以前的“寄生”，巩固自己一家的“寄生虫”地位，便决心要下到地下室里面斩草除根，但是却因为意外，而将原来的寄生虫家庭的男方放了出来，基宇被自己带的谋杀凶器砸得头破血流，失去理智的男人冲向了草坪，将刀子插进了基婷的胸口，场面再度混乱。而这时候富豪的儿子只是吓晕了过去，而贫穷的父亲的儿子头破血流，女儿已经中刀血流不止，经过一波血拼，都倒下了。富人真正关心的并不是贫穷人子女的生死，只是一味地关注着自己晕倒的儿子，并且表现出对低等的嫌弃，父亲最后一丝自尊心被打破，一刀扎进了富人的身体……</p>\n<p>再回到电影最初看，一家人生活在简简单单地家庭里靠着手工过生活，但是日子过得很开心，一起围坐在桌子旁喝啤酒，他们不用去担心明天，只考虑活在当下。当儿子得到那一份还不错的家教，后来女儿也去家教，都有一部分很不错的收入，有一定的能力开始开始下馆子，渐渐地一家人都想要更“好”的生活，开始依附于富人家里，从而一步步铤而走险，时时提心吊胆，当到最后深陷泥潭的时候，儿子问：我们下一步的计划是什么？父亲答：没有计划的计划是最安全的。或许这时候他们想要过得是安心的生活吧，但已经回不去了，欲望以及使他们沉沦。</p>\n<p>引用评论：欲望本身是没有错误的，适度的欲望甚至可以让你变得积极向上，但是过度的欲望则会将你拖进地狱。天堂和地狱之间，大概也就是一念之隔。寄生虫如果能够安守本分过好自己的“寄生”生活，或许影片就会是另外的结局，但因为欲望，寄生虫往往都想要做主人，但殊不知，寄生虫失去了主人，便也离死亡不远了。</p>\n<p>明天又是新的一周，加油吧！咱们的生活还是很美好的，敲敲代码、喝喝茶、打打麻将还是挺舒服的哈</p>\n","cover":null,"images":[],"content":"<p>这个周末总共看了三部电影：《无人生还》《吹哨人》《寄生虫》，前两部看完之后并没有太多的触动，倒是寄生虫看得人实在是过瘾，整个电影的剧情发展，以及想要表达出来镜头语音都做到了极致，以及让人能够思索很久很久的电影余味，配得上所获得的无数奖项。</p>\n<p>电影最后以欢乐的party变为残忍的凶案为结局，很多电影中过场看得人是瞠目结舌。极力推荐大家去欣赏一下这部电影，剧作节奏，镜头语言，剧本钩子绝对不会让你失望。</p>\n<p>整部电影都围绕着电影名“寄生虫”展开，我们来看一下什么是“寄生虫”。“寄生虫”百科解释道：寄生虫（parasite）指具有致病性的低等真核生物，可作为病原体，也可作为媒介传播疾病。寄生虫特征为在宿主或寄主（host）体内或附着于体外以获取维持其生存、发育或者繁殖所需的营养或者庇护的一切生物。在这一段的解释中:  低等、寄生、生存 是其中的关键词，也是整部电影的关键词。</p>\n<p>电影中何为“低等”？或者说是相对而言的低等，电影中的低等则是活在社会底层的一家人-不大的屋子住在一家四口人，靠着折叠披萨盒子生存，上网需要到脏乱差的厕所最里面去蹭别人家的网。而高等则是富豪社长所在的家庭-著名建筑家设计的别墅里的家庭，专门的司机、保姆等。</p>\n<p>电影中的“寄生”，有两种情况：一是主角家庭利用一系列的欺骗手段，从而“寄生”在富豪家里，他们一家人虽然也生活在别墅里，吃一样的食物，睡一样的床，但是他们就像是房间里的蟑螂，一旦主人回来了，就立马躲起来，但蟑螂并不是每次都能藏得那么好的，一旦被发现后果不堪设想。二是原本看起来一切正常的“前保姆”与丈夫偷偷居住在别墅地下道四年，在主角家庭一家人到来之前，虽然他丈夫住在很阴暗的地下室里，但是他们过得很知足。</p>\n<p>那么生存呢？一切的生物活动都是为了生存和繁衍，这就将上述两个关键词结合在了一起，三者：两者低等寄生，一者高等宿主体。三者的关系则构成了：高等对低等、低等对低等。在影片的高潮部分表现得淋漓尽致：在富有家庭为儿子举办的生日宴上，意外再次发生。后来的低等“寄生”为了斩草除根掉以前的“寄生”，巩固自己一家的“寄生虫”地位，便决心要下到地下室里面斩草除根，但是却因为意外，而将原来的寄生虫家庭的男方放了出来，基宇被自己带的谋杀凶器砸得头破血流，失去理智的男人冲向了草坪，将刀子插进了基婷的胸口，场面再度混乱。而这时候富豪的儿子只是吓晕了过去，而贫穷的父亲的儿子头破血流，女儿已经中刀血流不止，经过一波血拼，都倒下了。富人真正关心的并不是贫穷人子女的生死，只是一味地关注着自己晕倒的儿子，并且表现出对低等的嫌弃，父亲最后一丝自尊心被打破，一刀扎进了富人的身体……</p>\n<p>再回到电影最初看，一家人生活在简简单单地家庭里靠着手工过生活，但是日子过得很开心，一起围坐在桌子旁喝啤酒，他们不用去担心明天，只考虑活在当下。当儿子得到那一份还不错的家教，后来女儿也去家教，都有一部分很不错的收入，有一定的能力开始开始下馆子，渐渐地一家人都想要更“好”的生活，开始依附于富人家里，从而一步步铤而走险，时时提心吊胆，当到最后深陷泥潭的时候，儿子问：我们下一步的计划是什么？父亲答：没有计划的计划是最安全的。或许这时候他们想要过得是安心的生活吧，但已经回不去了，欲望以及使他们沉沦。</p>\n<p>引用评论：欲望本身是没有错误的，适度的欲望甚至可以让你变得积极向上，但是过度的欲望则会将你拖进地狱。天堂和地狱之间，大概也就是一念之隔。寄生虫如果能够安守本分过好自己的“寄生”生活，或许影片就会是另外的结局，但因为欲望，寄生虫往往都想要做主人，但殊不知，寄生虫失去了主人，便也离死亡不远了。</p>\n<p>明天又是新的一周，加油吧！咱们的生活还是很美好的，敲敲代码、喝喝茶、打打麻将还是挺舒服的哈</p>\n","categories":[{"name":"读书电影","slug":"movie","api":"api/categories/movie.json"}],"tags":[{"name":"省","slug":"thinking","api":"api/tags/thinking.json"}],"api":"api/posts/2020/03/22/《寄生虫》观后感.json"},{"title":"（转）Https之HTTPS 的证书","slug":"Https之HTTPS-的证书","date":"2020-03-04T02:44:00.000Z","updated":"2025-05-20T11:46:57.000Z","comments":true,"url":"2020/03/04/Https之HTTPS-的证书/","excerpt":"<p>转自：<a href=\"https://mp.weixin.qq.com/s/ibwNtDc2zd2tdhMN7iROJw\">https://mp.weixin.qq.com/s/ibwNtDc2zd2tdhMN7iROJw</a><br>作者：<a href=\"https://open.youtu.qq.com/#/open\">腾讯优图实验室</a>   来源：<a href=\"https://mp.weixin.qq.com/s/ibwNtDc2zd2tdhMN7iROJw\">腾讯技术工程</a></p>\n<h2 id=\"1、-证书是什么？\"><a href=\"#1、-证书是什么？\" class=\"headerlink\" title=\"1、 证书是什么？\"></a><strong>1、 证书是什么？</strong></h2><p>解释这个问题之前，先看几个关键词：<strong>CA，CA 机构，数字证书，数字签名，（证书）指纹，(CA)证书，HTTPS 证书，SSL&#x2F;TLS 证书</strong>。</p>\n<p>理一理上面这些关键词之间的关系：</p>\n<p><strong>CA，CA 机构</strong>：机构&#x2F;组织概念。</p>\n<p><strong>数字证书，(CA)证书，HTTPS 证书，SSL&#x2F;TLS 证书</strong>：CA 签发的数字证书。</p>\n<p><strong>数字签名，（证书）指纹</strong>：CA 签发的证书的内容之一，一段加密的密文。</p>\n<p>智库百科对数字证书的解释是：</p>\n<blockquote>\n<p>数字证书也称公开密钥证书，是指用于电子信息活动中电子文件行为主体的验证和证明，并可实现电子文件保密性和完整性的电子数据。数字证书是一个经证书认证中心（Certification<br>Authority，简称 CA）发行的文件。</p>\n</blockquote>\n<p>数字证书包含有行为主体信息和证书认证机构的数字签名。数字签名是指以电子形式存在，可依附在电子文件中用于辨识电子文件的签署者及表示对该电子文件内容负责所使用的电子数字标识。</p>\n<p>抓重点：<strong>数字证书用于主体身份验证。</strong></p>\n<p>首先，<strong>数字证书&#x3D;主体信息+数字签名。</strong></p>\n<p>Windows 下，我们可以在 Chrome 浏览器上点击地址栏的“锁”标记后会出现下拉框，接着点击“证书”即可看到通过 HTTPS 访问该服务器时的数字证书。具体操作如下：</p>\n<img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly9zMS41MWN0by5jb20vb3NzLzIwMjAwMi8yNy8zMjUzNjFhMDc1NzFmZDE3N2M4YjBhMzcyM2Y1YzBmMS5wbmc?x-oss-process=image/format,png\" width=\"40%\"/>\n\n\n<ul>\n<li>证书“常规”页面，是关于该证书的一个笼统介绍，包括签发该证书的 CA 机构、该证书绑定的域名（颁发给）、证书有效期。</li>\n<li>证书“详细信息”页面，以键值对形式展示了这张证书的完整内容。（后文将详细介绍证书内容）</li>\n<li>证书的“证书路径”，以层级结构展示了从该证书绑定的域名一直到根证书的路径，这就是证书链。（后文会展开介绍证书链）</li>\n</ul>\n<p><strong>主体的必要信息</strong>：版本(version)、序列号(serialNumber)、签名算法(signatureAlgorithm)、颁发者(issuer)、有效期(validity)、使用者(subject)、公钥信息(subjectPublicKeyInfo)</p>\n<p>主体的扩展信息(extension)：如密钥标识符、证书策略等</p>\n<p>数字签名(signature)，也称指纹</p>\n<p>抽象为下图：<br><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly9zNS41MWN0by5jb20vb3NzLzIwMjAwMi8yNy9jNGIyNzAxMjY5MmMyNWI4NTYxOWEwMTdmMmMxNTE4Zi5qcGctd2hfNjAweC1zXzM3MzQxNzQwMjguanBn?x-oss-process=image/format,png\" width=\"40%\"/></p>\n<h2 id=\"2、-为什么是数字证书呢？\"><a href=\"#2、-为什么是数字证书呢？\" class=\"headerlink\" title=\"2、 为什么是数字证书呢？\"></a><strong>2、 为什么是数字证书呢？</strong></h2><p>HTTPS 已经对通信数据进行了加密，为什么还要验证身份？说好的“人与人之间最基本的信任呢？”</p>\n<p>这还不是因为各路黑客、骇客们总是在制造各种攻击吗？其中一个大名鼎鼎的中间人攻击（Man-In-The-Middle Attack，MITM 攻击），简单的讲，“中间人”在客户端和服务端都不知情的情况下，夹在双方之间窃听甚至篡改通信信息，过程见下图（图引自《HTTPS 中间人攻击实践（原理·实践）》）：</p>\n<p><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly9zMi41MWN0by5jb20vb3NzLzIwMjAwMi8yNy9hZjM2OGQ1NTMxZWVlMGY4YmVkNzZiMzZjMmM3ODM5YS5qcGctd2hfNjAweC1zXzg4NTk5MDkzNy5qcGc?x-oss-process=image/format,png\"><br>在 HTTPS 的握手阶段，一端向对端发送请求，对端返回自己的公钥；而一端未验证对方的身份和公钥，直接协商密钥。“中间人”看到了这个漏洞，夹在中间截获了对端的公钥，替换成了自己的公钥。正是这步“拿错了公钥”或者说“信错了对端”，使得 HTTPS 为加密（密钥协商的非对称加密和通信数据的对称加密）所做的努力全部泡汤。</p>\n<p>可见，在 HTTPS 中，“确保对端身份正确”即“确保拿到的公钥正确”，而在网络通信中所谓的“身份”，一般指的是通信一端的域名、IP 地址甚至是Mac 地址。所以，数字证书同时包含了通信一端的身份信息和公钥信息。</p>\n<p>但是数字证书会在网络中传输（由被要求验证身份的一端通过网络传给另一端），这就意味着证书也可能会被窃取篡改。这个时候权威的 CA 机构就出马了，他想了个办法：<strong>加了一个“防伪标识”— 数字签名</strong>。具体做法如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">signature = RSA(PriKey_CA, Hash(message))</span><br></pre></td></tr></table></figure>\n\n<p>这里啰嗦几句：数字签名生成过程是首先对原文作哈希，把一段不定长的文本映射成固定长度的字符空间，接着再用 CA 机构的私钥对这段定长字符做加密。大大提高了整体的运算效率。</p>\n<h2 id=\"3-证书是怎么工作的？\"><a href=\"#3-证书是怎么工作的？\" class=\"headerlink\" title=\"3 证书是怎么工作的？\"></a><strong>3 证书是怎么工作的？</strong></h2><p>要了解证书是怎么做“身份验证”，即“防冒充”，得从 2 个角度来说明：</p>\n<p><strong>申请证书，即需要被验证身份的一端，需要申请一份能够验证自己身份的证书<br>验证证书，即需要验证对方身份的一端，拿到证书后验证对端的身份</strong></p>\n<p>请注意，这里有一个前提：<strong>这张证书必须是由权威 CA 机构颁发的，且尚在有效期内；或者是一张信任的私人证书。</strong></p>\n<p><strong>申请证书</strong></p>\n<p>CA 机构和证书的分类本文不讨论，推荐阅读《细说 CA 和证书》，这里我们讨论正规权威 CA 机构签发的证书，至于是 DV、OV 还是 EV，只是安全强度问题，工作原理是一样的。</p>\n<p>总结申请证书的过程：用户向 CA 机构提交自己的信息（如域名）和公钥（用户自己生成的非对称加密公钥，用于 TLS 握手阶段和另一端协商密钥用），CA 机构生成数字证书，如下图：</p>\n<p><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly9zNC41MWN0by5jb20vb3NzLzIwMjAwMi8yNy9lZTAwNzljNjc5ZDRiMmFkMzU4OWZkYjFhYTljOTRlOS5qcGctd2hfNjAweC1zXzI4ODM4MTIzNDcuanBn?x-oss-process=image/format,png\"><br><strong>验证证书</strong></p>\n<p>收到对端发过来的证书，执行证书申请的“逆过程”即可，总结如下图：<br><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly9zMy41MWN0by5jb20vb3NzLzIwMjAwMi8yNy83ZGNlNGVmM2M2NTVlNzgxOWUwZjQwNWI3Yzk2OTY4Ny5qcGctd2hfNjAweC1zXzEyNjMwOTQwNDQuanBn?x-oss-process=image/format,png\"></p>\n<p>接受证书的一端先对除数签名的其他部分做一次相同的哈希算法（证书中指明了哈希算法），得到这段文本的哈希映射，记作 H1；获取 CA 机构的公钥对数字签名属性做解码，得到了 CA 机构计算出的哈希映射，记作 H2。对比 H1 和 H2 两个字符串是否严格相等，若是，代表该证书的信息未被篡改，证书有效；否则，证书内容被篡改，证书无效。</p>\n<p>若证书有效，接受端会再进行对端的身份校验（验证域名），若身份验证通过，接收端会拿证书上的公钥（也是对端自己生产的非对称加密公钥）加密接下来整个 TLS 握手阶段的信息之后，发送给对端。</p>\n<p>这个过程中有一个问题：<strong>CA 机构的公钥怎么获取？</strong></p>\n<p>回答：<strong>提前内置</strong>。</p>\n<p>众所周知，操作系统和浏览器在软件安装阶段会在其特定目录下放置一堆的证书。如 Windows 的根证书管理在 certmgr 下：</p>\n<p><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly9zNS41MWN0by5jb20vb3NzLzIwMjAwMi8yNy8xZjNmZDMyNzQ0NTQ5ZjFiYmJmNzhkZDUxOTU0MmZjMC5qcGctd2hfNjAweC1zXzE3MjQwODczOTUuanBn?x-oss-process=image/format,png\"><br>这些证书都有个特点：权威 CA 机构发布的根证书（Root Certificate）。根证书有几个特点：</p>\n<p><strong>没有上层机构再为其本身作数字签名</strong></p>\n<p><strong>证书上的公钥即为 CA 机构发布的公钥</strong></p>\n<p><strong>权威 CA 机构的自签证书</strong></p>\n<p>而这些根证书会跟很多软件，包括操作系统、浏览器一起被安装到用户设备上。即使没有被提前安装好，这些根证书也可以在 CA 机构的官网上获取得到。</p>\n<p>目前全球大型权威 CA 机构有 Symantec、GeoTrust、Comodo 以及 RapidSSL 等，并且这些机构颁发的 SSL 数字证书，在市场的占有率是非常的高。（节选自《SSL 证书颁发机构有哪些》）</p>\n<p>本地被内置了这么多的根证书，那要怎么知道我这份证书应该要用哪一个根证书来验证呢？</p>\n<p>回答：<strong>证书信任链</strong>。</p>\n<p>在信任链上有 3 类证书：<strong>根证书，中介证书和用户证书</strong>。根证书前文已有说明，用户证书就是对端发过来的证书，或者说是用户向权威 CA 机构绑定了自己身份（主要指域名）和自己公钥的证书。中介证书可以理解由权威 CA 机构委派的代理机构签发的数字证书，推荐阅读《What is an intermediate certificate?》。中介证书或者说是中介机构的存在是为了保证根证书的密钥的安全性。</p>\n<p>细心的同学仔细看一看 certmgr 会发现有一个分类是“中间证书颁发机构”，这里存放的就是中介证书。用户证书绝大多数是通过权威的 CA 机构的代理中介机构颁发。</p>\n<p>这么来说，根据对端发来的用户证书寻找对应的根证书岂不是更困难了？</p>\n<p>自问自答：这是一个在树形数据结构中，从叶子节点搜索根节点的过程，直接一个最原始的深搜（DFS）不就可以了嘛？举例说明，如下图（引自Wikipedia-Chain of trust）：<br><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly9zNS41MWN0by5jb20vb3NzLzIwMjAwMi8yNy9lZGI0YjkwZWI0NGQzMjkyNDYwNGJiZDEzNzNiZjViZS5qcGctd2hfNjAweC1zXzM2MzkzNTg1MTkuanBn?x-oss-process=image/format,png\" alt=\"在这里插入图片描述\"></p>\n<p>从用户证书开始。</p>\n<p>记“Issuer”字段的值为 i1，搜索本地证书，寻找由“Subject”为 i1 的证书。</p>\n<p>若没有找到，结束返回证书无效；否则，跳到步骤 4)。</p>\n<p>判断该证书的 Issuer 值是否等于 Subject 值。</p>\n<p>若是，则该证书是根证书，结束返回该证书；否则跳到步骤 6)。</p>\n<p>以该证书开始，跳转 2)（继续搜索）。</p>\n<p>更多关于信任链的知识点，推荐阅读《What is the SSL Certificate Chain?》</p>\n<h2 id=\"4、证书怎么样？\"><a href=\"#4、证书怎么样？\" class=\"headerlink\" title=\"4、证书怎么样？\"></a>4、证书怎么样？</h2><p>相信不少同学或多或少接触过证书文件，比如.pem、.crt、.cer、.key 等，于是问题就来了：</p>\n<p>“为什么有这么多不同后缀名的证书啊？他们有什么联系和区别？”</p>\n<p>回答这个问题要从 3 个层面来分析：</p>\n<p><strong>证书标准</strong></p>\n<p><strong>证书编码格式</strong></p>\n<p><strong>文件扩展名</strong></p>\n<p><strong>证书标准</strong></p>\n<p>数字证书的格式普遍采用的是 X.509 国际标准，维基百科对于 X.509 解释如下：</p>\n<blockquote>\n<p>X.509 是密码学里公钥证书的格式标准。X.509 证书已应用在包括 TLS&#x2F;SSL<br>在内的众多网络协议里，同时它也用在很多非在线应用场景里，比如电子签名服务。X.509<br>证书里含有公钥、身份信息（比如网络主机名，组织的名称或个体名称等）和签名信息（可以是证书签发机构 CA<br>的签名，也可以是自签名）。对于一份经由可信的证书签发机构签名或者可以通过其它方式验证的证书，证书的拥有者就可以用证书及相应的私钥来创建安全的通信，对文档进行数字签名。</p>\n</blockquote>\n<p>X.509 是 ITU-T 标准化部门基于他们之前的 ASN.1 定义的一套证书标准。</p>\n<p><strong>证书的编码格式</strong></p>\n<p>X.509 标准的证书文件具有不同的编码格式：PEM 和 DER。</p>\n<ul>\n<li>PEM</li>\n</ul>\n<p>PEM，全称 Privacy Enhanced Mail，以文本格式存储，以 —–BEGIN<br>XXX—–开头、—–END XXX—–结尾，中间内容是 BASE64 编码数据。其文本内容大概如下：</p>\n<p>html —–BEGIN CERTIFICATE—– Base64编码过的证书数据 —–END CERTIFICATE—–</p>\n<p>通常，PEM 格式可以存储公钥、私钥、证书签名请求等数据。查看 PEM 格式证书的信息一般采用如下命令：</p>\n<p>openssl x509 -in xxx.pem -text -noout<br>Apache 和 Nginx 服务器偏向于使用这种编码格式.</p>\n<ul>\n<li>DER</li>\n</ul>\n<p>DER，全称 Distinguished Encoding Rules，以二进制存储，因此文件结构无法直接预览，只能通过如下命令查看：</p>\n<p>html openssl x509 -in xxx.der -inform der -text -noout</p>\n<p>DER 格式也可以存储公钥、私钥、证书签名请求等数据。Java 和 Windows 应用偏向于使用这种编码格式。</p>\n<p>当然同一 X.509 证书的不同编码之间可以互相转换：</p>\n<ul>\n<li>PEM 转为 DER：</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">openssl x509 -in xxx.pem -outform der -out xxx.der</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>DER 转为 PEM：</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">openssl x509 -in xxx.der -inform der -outform pem -out xxx.pem</span><br></pre></td></tr></table></figure>\n\n<p><strong>文件扩展名</strong></p>\n<p>不同的扩展名可以分为以下几类：</p>\n<ul>\n<li>证书：</li>\n</ul>\n<p>存放数字证书，X.509 标准，格式可能是 PEM 或 DER。.crt、.cer</p>\n<ul>\n<li>密钥：</li>\n</ul>\n<p>用来存放一个 RSA 公钥或私钥，这类文件不是 X.509 标准，但是是 PEM 或 DER 格式。后缀名有.key。</p>\n<ul>\n<li>证书+密钥：</li>\n</ul>\n<p>可同时存放证书和 RSA 公钥&#x2F;.pem、.der、.p12</p>\n<ul>\n<li>证书请求：</li>\n</ul>\n<p>并不是证书，而是证书签名请求。csr</p>\n","cover":null,"images":["https://imgconvert.csdnimg.cn/aHR0cHM6Ly9zMS41MWN0by5jb20vb3NzLzIwMjAwMi8yNy8zMjUzNjFhMDc1NzFmZDE3N2M4YjBhMzcyM2Y1YzBmMS5wbmc?x-oss-process=image/format,png","https://imgconvert.csdnimg.cn/aHR0cHM6Ly9zNS41MWN0by5jb20vb3NzLzIwMjAwMi8yNy9jNGIyNzAxMjY5MmMyNWI4NTYxOWEwMTdmMmMxNTE4Zi5qcGctd2hfNjAweC1zXzM3MzQxNzQwMjguanBn?x-oss-process=image/format,png","https://imgconvert.csdnimg.cn/aHR0cHM6Ly9zMi41MWN0by5jb20vb3NzLzIwMjAwMi8yNy9hZjM2OGQ1NTMxZWVlMGY4YmVkNzZiMzZjMmM3ODM5YS5qcGctd2hfNjAweC1zXzg4NTk5MDkzNy5qcGc?x-oss-process=image/format,png","https://imgconvert.csdnimg.cn/aHR0cHM6Ly9zNC41MWN0by5jb20vb3NzLzIwMjAwMi8yNy9lZTAwNzljNjc5ZDRiMmFkMzU4OWZkYjFhYTljOTRlOS5qcGctd2hfNjAweC1zXzI4ODM4MTIzNDcuanBn?x-oss-process=image/format,png","https://imgconvert.csdnimg.cn/aHR0cHM6Ly9zMy41MWN0by5jb20vb3NzLzIwMjAwMi8yNy83ZGNlNGVmM2M2NTVlNzgxOWUwZjQwNWI3Yzk2OTY4Ny5qcGctd2hfNjAweC1zXzEyNjMwOTQwNDQuanBn?x-oss-process=image/format,png","https://imgconvert.csdnimg.cn/aHR0cHM6Ly9zNS41MWN0by5jb20vb3NzLzIwMjAwMi8yNy8xZjNmZDMyNzQ0NTQ5ZjFiYmJmNzhkZDUxOTU0MmZjMC5qcGctd2hfNjAweC1zXzE3MjQwODczOTUuanBn?x-oss-process=image/format,png","https://imgconvert.csdnimg.cn/aHR0cHM6Ly9zNS41MWN0by5jb20vb3NzLzIwMjAwMi8yNy9lZGI0YjkwZWI0NGQzMjkyNDYwNGJiZDEzNzNiZjViZS5qcGctd2hfNjAweC1zXzM2MzkzNTg1MTkuanBn?x-oss-process=image/format,png"],"content":"<p>转自：<a href=\"https://mp.weixin.qq.com/s/ibwNtDc2zd2tdhMN7iROJw\">https://mp.weixin.qq.com/s/ibwNtDc2zd2tdhMN7iROJw</a><br>作者：<a href=\"https://open.youtu.qq.com/#/open\">腾讯优图实验室</a>   来源：<a href=\"https://mp.weixin.qq.com/s/ibwNtDc2zd2tdhMN7iROJw\">腾讯技术工程</a></p>\n<h2 id=\"1、-证书是什么？\"><a href=\"#1、-证书是什么？\" class=\"headerlink\" title=\"1、 证书是什么？\"></a><strong>1、 证书是什么？</strong></h2><p>解释这个问题之前，先看几个关键词：<strong>CA，CA 机构，数字证书，数字签名，（证书）指纹，(CA)证书，HTTPS 证书，SSL&#x2F;TLS 证书</strong>。</p>\n<p>理一理上面这些关键词之间的关系：</p>\n<p><strong>CA，CA 机构</strong>：机构&#x2F;组织概念。</p>\n<p><strong>数字证书，(CA)证书，HTTPS 证书，SSL&#x2F;TLS 证书</strong>：CA 签发的数字证书。</p>\n<p><strong>数字签名，（证书）指纹</strong>：CA 签发的证书的内容之一，一段加密的密文。</p>\n<p>智库百科对数字证书的解释是：</p>\n<blockquote>\n<p>数字证书也称公开密钥证书，是指用于电子信息活动中电子文件行为主体的验证和证明，并可实现电子文件保密性和完整性的电子数据。数字证书是一个经证书认证中心（Certification<br>Authority，简称 CA）发行的文件。</p>\n</blockquote>\n<p>数字证书包含有行为主体信息和证书认证机构的数字签名。数字签名是指以电子形式存在，可依附在电子文件中用于辨识电子文件的签署者及表示对该电子文件内容负责所使用的电子数字标识。</p>\n<p>抓重点：<strong>数字证书用于主体身份验证。</strong></p>\n<p>首先，<strong>数字证书&#x3D;主体信息+数字签名。</strong></p>\n<p>Windows 下，我们可以在 Chrome 浏览器上点击地址栏的“锁”标记后会出现下拉框，接着点击“证书”即可看到通过 HTTPS 访问该服务器时的数字证书。具体操作如下：</p>\n<img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly9zMS41MWN0by5jb20vb3NzLzIwMjAwMi8yNy8zMjUzNjFhMDc1NzFmZDE3N2M4YjBhMzcyM2Y1YzBmMS5wbmc?x-oss-process=image/format,png\" width=\"40%\"/>\n\n\n<ul>\n<li>证书“常规”页面，是关于该证书的一个笼统介绍，包括签发该证书的 CA 机构、该证书绑定的域名（颁发给）、证书有效期。</li>\n<li>证书“详细信息”页面，以键值对形式展示了这张证书的完整内容。（后文将详细介绍证书内容）</li>\n<li>证书的“证书路径”，以层级结构展示了从该证书绑定的域名一直到根证书的路径，这就是证书链。（后文会展开介绍证书链）</li>\n</ul>\n<p><strong>主体的必要信息</strong>：版本(version)、序列号(serialNumber)、签名算法(signatureAlgorithm)、颁发者(issuer)、有效期(validity)、使用者(subject)、公钥信息(subjectPublicKeyInfo)</p>\n<p>主体的扩展信息(extension)：如密钥标识符、证书策略等</p>\n<p>数字签名(signature)，也称指纹</p>\n<p>抽象为下图：<br><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly9zNS41MWN0by5jb20vb3NzLzIwMjAwMi8yNy9jNGIyNzAxMjY5MmMyNWI4NTYxOWEwMTdmMmMxNTE4Zi5qcGctd2hfNjAweC1zXzM3MzQxNzQwMjguanBn?x-oss-process=image/format,png\" width=\"40%\"/></p>\n<h2 id=\"2、-为什么是数字证书呢？\"><a href=\"#2、-为什么是数字证书呢？\" class=\"headerlink\" title=\"2、 为什么是数字证书呢？\"></a><strong>2、 为什么是数字证书呢？</strong></h2><p>HTTPS 已经对通信数据进行了加密，为什么还要验证身份？说好的“人与人之间最基本的信任呢？”</p>\n<p>这还不是因为各路黑客、骇客们总是在制造各种攻击吗？其中一个大名鼎鼎的中间人攻击（Man-In-The-Middle Attack，MITM 攻击），简单的讲，“中间人”在客户端和服务端都不知情的情况下，夹在双方之间窃听甚至篡改通信信息，过程见下图（图引自《HTTPS 中间人攻击实践（原理·实践）》）：</p>\n<p><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly9zMi41MWN0by5jb20vb3NzLzIwMjAwMi8yNy9hZjM2OGQ1NTMxZWVlMGY4YmVkNzZiMzZjMmM3ODM5YS5qcGctd2hfNjAweC1zXzg4NTk5MDkzNy5qcGc?x-oss-process=image/format,png\"><br>在 HTTPS 的握手阶段，一端向对端发送请求，对端返回自己的公钥；而一端未验证对方的身份和公钥，直接协商密钥。“中间人”看到了这个漏洞，夹在中间截获了对端的公钥，替换成了自己的公钥。正是这步“拿错了公钥”或者说“信错了对端”，使得 HTTPS 为加密（密钥协商的非对称加密和通信数据的对称加密）所做的努力全部泡汤。</p>\n<p>可见，在 HTTPS 中，“确保对端身份正确”即“确保拿到的公钥正确”，而在网络通信中所谓的“身份”，一般指的是通信一端的域名、IP 地址甚至是Mac 地址。所以，数字证书同时包含了通信一端的身份信息和公钥信息。</p>\n<p>但是数字证书会在网络中传输（由被要求验证身份的一端通过网络传给另一端），这就意味着证书也可能会被窃取篡改。这个时候权威的 CA 机构就出马了，他想了个办法：<strong>加了一个“防伪标识”— 数字签名</strong>。具体做法如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">signature = RSA(PriKey_CA, Hash(message))</span><br></pre></td></tr></table></figure>\n\n<p>这里啰嗦几句：数字签名生成过程是首先对原文作哈希，把一段不定长的文本映射成固定长度的字符空间，接着再用 CA 机构的私钥对这段定长字符做加密。大大提高了整体的运算效率。</p>\n<h2 id=\"3-证书是怎么工作的？\"><a href=\"#3-证书是怎么工作的？\" class=\"headerlink\" title=\"3 证书是怎么工作的？\"></a><strong>3 证书是怎么工作的？</strong></h2><p>要了解证书是怎么做“身份验证”，即“防冒充”，得从 2 个角度来说明：</p>\n<p><strong>申请证书，即需要被验证身份的一端，需要申请一份能够验证自己身份的证书<br>验证证书，即需要验证对方身份的一端，拿到证书后验证对端的身份</strong></p>\n<p>请注意，这里有一个前提：<strong>这张证书必须是由权威 CA 机构颁发的，且尚在有效期内；或者是一张信任的私人证书。</strong></p>\n<p><strong>申请证书</strong></p>\n<p>CA 机构和证书的分类本文不讨论，推荐阅读《细说 CA 和证书》，这里我们讨论正规权威 CA 机构签发的证书，至于是 DV、OV 还是 EV，只是安全强度问题，工作原理是一样的。</p>\n<p>总结申请证书的过程：用户向 CA 机构提交自己的信息（如域名）和公钥（用户自己生成的非对称加密公钥，用于 TLS 握手阶段和另一端协商密钥用），CA 机构生成数字证书，如下图：</p>\n<p><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly9zNC41MWN0by5jb20vb3NzLzIwMjAwMi8yNy9lZTAwNzljNjc5ZDRiMmFkMzU4OWZkYjFhYTljOTRlOS5qcGctd2hfNjAweC1zXzI4ODM4MTIzNDcuanBn?x-oss-process=image/format,png\"><br><strong>验证证书</strong></p>\n<p>收到对端发过来的证书，执行证书申请的“逆过程”即可，总结如下图：<br><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly9zMy41MWN0by5jb20vb3NzLzIwMjAwMi8yNy83ZGNlNGVmM2M2NTVlNzgxOWUwZjQwNWI3Yzk2OTY4Ny5qcGctd2hfNjAweC1zXzEyNjMwOTQwNDQuanBn?x-oss-process=image/format,png\"></p>\n<p>接受证书的一端先对除数签名的其他部分做一次相同的哈希算法（证书中指明了哈希算法），得到这段文本的哈希映射，记作 H1；获取 CA 机构的公钥对数字签名属性做解码，得到了 CA 机构计算出的哈希映射，记作 H2。对比 H1 和 H2 两个字符串是否严格相等，若是，代表该证书的信息未被篡改，证书有效；否则，证书内容被篡改，证书无效。</p>\n<p>若证书有效，接受端会再进行对端的身份校验（验证域名），若身份验证通过，接收端会拿证书上的公钥（也是对端自己生产的非对称加密公钥）加密接下来整个 TLS 握手阶段的信息之后，发送给对端。</p>\n<p>这个过程中有一个问题：<strong>CA 机构的公钥怎么获取？</strong></p>\n<p>回答：<strong>提前内置</strong>。</p>\n<p>众所周知，操作系统和浏览器在软件安装阶段会在其特定目录下放置一堆的证书。如 Windows 的根证书管理在 certmgr 下：</p>\n<p><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly9zNS41MWN0by5jb20vb3NzLzIwMjAwMi8yNy8xZjNmZDMyNzQ0NTQ5ZjFiYmJmNzhkZDUxOTU0MmZjMC5qcGctd2hfNjAweC1zXzE3MjQwODczOTUuanBn?x-oss-process=image/format,png\"><br>这些证书都有个特点：权威 CA 机构发布的根证书（Root Certificate）。根证书有几个特点：</p>\n<p><strong>没有上层机构再为其本身作数字签名</strong></p>\n<p><strong>证书上的公钥即为 CA 机构发布的公钥</strong></p>\n<p><strong>权威 CA 机构的自签证书</strong></p>\n<p>而这些根证书会跟很多软件，包括操作系统、浏览器一起被安装到用户设备上。即使没有被提前安装好，这些根证书也可以在 CA 机构的官网上获取得到。</p>\n<p>目前全球大型权威 CA 机构有 Symantec、GeoTrust、Comodo 以及 RapidSSL 等，并且这些机构颁发的 SSL 数字证书，在市场的占有率是非常的高。（节选自《SSL 证书颁发机构有哪些》）</p>\n<p>本地被内置了这么多的根证书，那要怎么知道我这份证书应该要用哪一个根证书来验证呢？</p>\n<p>回答：<strong>证书信任链</strong>。</p>\n<p>在信任链上有 3 类证书：<strong>根证书，中介证书和用户证书</strong>。根证书前文已有说明，用户证书就是对端发过来的证书，或者说是用户向权威 CA 机构绑定了自己身份（主要指域名）和自己公钥的证书。中介证书可以理解由权威 CA 机构委派的代理机构签发的数字证书，推荐阅读《What is an intermediate certificate?》。中介证书或者说是中介机构的存在是为了保证根证书的密钥的安全性。</p>\n<p>细心的同学仔细看一看 certmgr 会发现有一个分类是“中间证书颁发机构”，这里存放的就是中介证书。用户证书绝大多数是通过权威的 CA 机构的代理中介机构颁发。</p>\n<p>这么来说，根据对端发来的用户证书寻找对应的根证书岂不是更困难了？</p>\n<p>自问自答：这是一个在树形数据结构中，从叶子节点搜索根节点的过程，直接一个最原始的深搜（DFS）不就可以了嘛？举例说明，如下图（引自Wikipedia-Chain of trust）：<br><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly9zNS41MWN0by5jb20vb3NzLzIwMjAwMi8yNy9lZGI0YjkwZWI0NGQzMjkyNDYwNGJiZDEzNzNiZjViZS5qcGctd2hfNjAweC1zXzM2MzkzNTg1MTkuanBn?x-oss-process=image/format,png\" alt=\"在这里插入图片描述\"></p>\n<p>从用户证书开始。</p>\n<p>记“Issuer”字段的值为 i1，搜索本地证书，寻找由“Subject”为 i1 的证书。</p>\n<p>若没有找到，结束返回证书无效；否则，跳到步骤 4)。</p>\n<p>判断该证书的 Issuer 值是否等于 Subject 值。</p>\n<p>若是，则该证书是根证书，结束返回该证书；否则跳到步骤 6)。</p>\n<p>以该证书开始，跳转 2)（继续搜索）。</p>\n<p>更多关于信任链的知识点，推荐阅读《What is the SSL Certificate Chain?》</p>\n<h2 id=\"4、证书怎么样？\"><a href=\"#4、证书怎么样？\" class=\"headerlink\" title=\"4、证书怎么样？\"></a>4、证书怎么样？</h2><p>相信不少同学或多或少接触过证书文件，比如.pem、.crt、.cer、.key 等，于是问题就来了：</p>\n<p>“为什么有这么多不同后缀名的证书啊？他们有什么联系和区别？”</p>\n<p>回答这个问题要从 3 个层面来分析：</p>\n<p><strong>证书标准</strong></p>\n<p><strong>证书编码格式</strong></p>\n<p><strong>文件扩展名</strong></p>\n<p><strong>证书标准</strong></p>\n<p>数字证书的格式普遍采用的是 X.509 国际标准，维基百科对于 X.509 解释如下：</p>\n<blockquote>\n<p>X.509 是密码学里公钥证书的格式标准。X.509 证书已应用在包括 TLS&#x2F;SSL<br>在内的众多网络协议里，同时它也用在很多非在线应用场景里，比如电子签名服务。X.509<br>证书里含有公钥、身份信息（比如网络主机名，组织的名称或个体名称等）和签名信息（可以是证书签发机构 CA<br>的签名，也可以是自签名）。对于一份经由可信的证书签发机构签名或者可以通过其它方式验证的证书，证书的拥有者就可以用证书及相应的私钥来创建安全的通信，对文档进行数字签名。</p>\n</blockquote>\n<p>X.509 是 ITU-T 标准化部门基于他们之前的 ASN.1 定义的一套证书标准。</p>\n<p><strong>证书的编码格式</strong></p>\n<p>X.509 标准的证书文件具有不同的编码格式：PEM 和 DER。</p>\n<ul>\n<li>PEM</li>\n</ul>\n<p>PEM，全称 Privacy Enhanced Mail，以文本格式存储，以 —–BEGIN<br>XXX—–开头、—–END XXX—–结尾，中间内容是 BASE64 编码数据。其文本内容大概如下：</p>\n<p>html —–BEGIN CERTIFICATE—– Base64编码过的证书数据 —–END CERTIFICATE—–</p>\n<p>通常，PEM 格式可以存储公钥、私钥、证书签名请求等数据。查看 PEM 格式证书的信息一般采用如下命令：</p>\n<p>openssl x509 -in xxx.pem -text -noout<br>Apache 和 Nginx 服务器偏向于使用这种编码格式.</p>\n<ul>\n<li>DER</li>\n</ul>\n<p>DER，全称 Distinguished Encoding Rules，以二进制存储，因此文件结构无法直接预览，只能通过如下命令查看：</p>\n<p>html openssl x509 -in xxx.der -inform der -text -noout</p>\n<p>DER 格式也可以存储公钥、私钥、证书签名请求等数据。Java 和 Windows 应用偏向于使用这种编码格式。</p>\n<p>当然同一 X.509 证书的不同编码之间可以互相转换：</p>\n<ul>\n<li>PEM 转为 DER：</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">openssl x509 -in xxx.pem -outform der -out xxx.der</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>DER 转为 PEM：</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">openssl x509 -in xxx.der -inform der -outform pem -out xxx.pem</span><br></pre></td></tr></table></figure>\n\n<p><strong>文件扩展名</strong></p>\n<p>不同的扩展名可以分为以下几类：</p>\n<ul>\n<li>证书：</li>\n</ul>\n<p>存放数字证书，X.509 标准，格式可能是 PEM 或 DER。.crt、.cer</p>\n<ul>\n<li>密钥：</li>\n</ul>\n<p>用来存放一个 RSA 公钥或私钥，这类文件不是 X.509 标准，但是是 PEM 或 DER 格式。后缀名有.key。</p>\n<ul>\n<li>证书+密钥：</li>\n</ul>\n<p>可同时存放证书和 RSA 公钥&#x2F;.pem、.der、.p12</p>\n<ul>\n<li>证书请求：</li>\n</ul>\n<p>并不是证书，而是证书签名请求。csr</p>\n","categories":[],"tags":[{"name":"Https","slug":"Https","api":"api/tags/Https.json"}],"api":"api/posts/2020/03/04/Https之HTTPS-的证书.json"},{"title":"想统计自己总共提交了多少行代码？","slug":"想统计自己总共提交了多少行代码？","date":"2020-03-02T03:01:00.000Z","updated":"2025-05-20T11:46:57.000Z","comments":true,"url":"2020/03/02/想统计自己总共提交了多少行代码？/","excerpt":"<p>作为一名程序员，我们很想知道自己到底提交了多少行代码到远程仓库，有没有什么工具能够帮我们统计自己写过的代码行数呢？答案是有的。</p>\n<p>这是本次实现的最终效果:</p>\n<img width=\"60%\" src=\"https://cdn.julis.wang/blog/img/20200301170230101.png\">\n\n<h2 id=\"统计代码行数的方式\"><a href=\"#统计代码行数的方式\" class=\"headerlink\" title=\"统计代码行数的方式\"></a>统计代码行数的方式</h2><p>对于代码提交行数统计，通过git 的系统命令就能做到，如下代码所示</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">git <span class=\"built_in\">log</span> --author=<span class=\"string\">&#x27;username&#x27;</span> --pretty=tformat: --numstat | awk <span class=\"string\">&#x27;</span></span><br><span class=\"line\"><span class=\"string\">    &#123;add += $1; subs += $2; loc += $1 - $2 &#125; END &#123; printf &quot;添加了%s,删除了%s,合计%s\\n&quot;, add, subs, loc &#125;&#x27;</span> -</span><br><span class=\"line\">\t</span><br></pre></td></tr></table></figure>\n\n<p>只需要在如下命令输入自己的username就行了，效果如图所示·</p>\n<img src=\"https://cdn.julis.wang/blog/img/20200301170616289.png\">\n\n<p>但是有的人由于环境原因，为了区分一些环境，比如办公司叫：username.office 在家的电脑上叫做: user.home 诸如此类，难道得手动一个一个统计么？当然不行了。</p>\n<p>众所周知，由于工程项目变得更越来越大，拆库也说见不鲜，于是自己的代码分布不同的项目工程，我们想要利用git的统计命令的话就有点吃力了，需要一个一个地进入相应目录进行命令输入？当然不行了。</p>\n<p>今天自己写了一份脚本主要用于统计分布在某个文件夹下所有的代码提交行数，git开源地址：<a href=\"https://github.com/VomPom/ForFun\">https://github.com/VomPom/ForFun</a>源码如下</p>\n<p>如何使用？</p>\n<p>0、将自己需要统计的项目文件目录整理到一个文件夹</p>\n<p>1、讲users_name换成自己的的用户名</p>\n<p>2、由于文件夹下可能有一些例外的不需要统计，添加该文件夹名</p>\n<p>3、讲该shell脚本移动到某个名录下</p>\n<p>4、最后利用 sh codeLine.sh 执行命令</p>\n<img width=\"60%\" src=\"https://cdn.julis.wang/blog/img/20200301171856190.png\">\n<img width=\"60%\" src=\"https://cdn.julis.wang/blog/img/20200301172119336.png\">\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">########################################################</span></span><br><span class=\"line\"><span class=\"comment\">#</span></span><br><span class=\"line\"><span class=\"comment\"># Created by https://julis.wang on 2020/02/28</span></span><br><span class=\"line\"><span class=\"comment\">#</span></span><br><span class=\"line\"><span class=\"comment\"># Description : 统计代码提交行数</span></span><br><span class=\"line\"><span class=\"comment\">#</span></span><br><span class=\"line\"><span class=\"comment\">########################################################</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#!/bin/bash</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#这里添加你的git常用用户名。考虑到每个人的账号可能有很多个，所以定义成数组</span></span><br><span class=\"line\">users_name=(<span class=\"string\">&quot;julis&quot;</span> <span class=\"string\">&quot;julis.wang&quot;</span> <span class=\"string\">&quot;julis.wang.hp&quot;</span>)      </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#过滤一些不需要去遍历的文件夹</span></span><br><span class=\"line\">filter_path=(<span class=\"string\">&quot;Backend&quot;</span> <span class=\"string\">&quot;test&quot;</span> <span class=\"string\">&quot;sdk&quot;</span> <span class=\"string\">&quot;fork&quot;</span> <span class=\"string\">&quot;ArProject&quot;</span>)     </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">########################################################</span></span><br><span class=\"line\"><span class=\"comment\"># 以下代码不需动                       </span></span><br><span class=\"line\"><span class=\"comment\">########################################################</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">export</span> index=0             \t\t\t<span class=\"comment\">#记录当前的位置</span></span><br><span class=\"line\"><span class=\"built_in\">export</span> add_line_count=0             <span class=\"comment\">#添加的line总行数</span></span><br><span class=\"line\"><span class=\"built_in\">export</span> remove_line_count=0          <span class=\"comment\">#删除的总行数</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">export</span> array_git_repositories=()    <span class=\"comment\">#用于记录仓库名</span></span><br><span class=\"line\"><span class=\"built_in\">export</span> add_code=()                  <span class=\"comment\">#记录所有用户对某个库的添加的行数</span></span><br><span class=\"line\"><span class=\"built_in\">export</span> remove_code=()               <span class=\"comment\">#记录所有用户对某个库的删除的行数</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#判断是否需要过滤该目录</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"function\"><span class=\"title\">is_fileter_dir</span></span>() &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"string\">&quot;<span class=\"variable\">$&#123;!filter_path[@]&#125;</span>&quot;</span>; <span class=\"keyword\">do</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> [ <span class=\"variable\">$1</span> == <span class=\"string\">&quot;<span class=\"variable\">$&#123;filter_path[$i]&#125;</span>&quot;</span> ]; <span class=\"keyword\">then</span></span><br><span class=\"line\">\t\t\t<span class=\"built_in\">return</span> 1</span><br><span class=\"line\">\t\t<span class=\"keyword\">fi</span></span><br><span class=\"line\">\t<span class=\"keyword\">done</span></span><br><span class=\"line\">\t<span class=\"built_in\">return</span> 0</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">#对命令执行的返回值进行数据切割</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"function\"><span class=\"title\">get_add_remove_count</span></span>() &#123;</span><br><span class=\"line\">\tstring=<span class=\"variable\">$1</span></span><br><span class=\"line\">\tarray=(<span class=\"variable\">$&#123;string//,/ &#125;</span>)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> [ ! <span class=\"variable\">$&#123;array[0]&#125;</span> ]; <span class=\"keyword\">then</span></span><br><span class=\"line\">  \t\tadd_line=0</span><br><span class=\"line\">\t<span class=\"keyword\">else</span></span><br><span class=\"line\">  \t\tadd_line=<span class=\"variable\">$&#123;array[0]&#125;</span></span><br><span class=\"line\">\t<span class=\"keyword\">fi</span></span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> [ ! <span class=\"variable\">$&#123;array[1]&#125;</span> ]; <span class=\"keyword\">then</span></span><br><span class=\"line\">  \t\tremove_line=0</span><br><span class=\"line\">\t<span class=\"keyword\">else</span></span><br><span class=\"line\">  \t\tremove_line=<span class=\"variable\">$&#123;array[1]&#125;</span></span><br><span class=\"line\">\t<span class=\"keyword\">fi</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> [ ! <span class=\"variable\">$&#123;add_code[$index]&#125;</span> ]; <span class=\"keyword\">then</span></span><br><span class=\"line\">  \t\tadd_code[<span class=\"variable\">$index</span>]=0</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"keyword\">fi</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> [ ! <span class=\"variable\">$&#123;remove_code[$index]&#125;</span> ]; <span class=\"keyword\">then</span></span><br><span class=\"line\">  \t\tremove_code[<span class=\"variable\">$index</span>]=0</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"keyword\">fi</span></span><br><span class=\"line\">\tremove_code[<span class=\"variable\">$index</span>]=`<span class=\"built_in\">expr</span> <span class=\"variable\">$&#123;remove_code[$index]&#125;</span> + <span class=\"variable\">$remove_line</span>`</span><br><span class=\"line\">\tadd_code[<span class=\"variable\">$index</span>]=`<span class=\"built_in\">expr</span> <span class=\"variable\">$&#123;add_code[$index]&#125;</span> + <span class=\"variable\">$add_line</span>`</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">echo</span> <span class=\"string\">&quot;用户&quot;</span><span class=\"variable\">$2</span><span class=\"string\">&quot;添加了=&quot;</span><span class=\"variable\">$add_line</span><span class=\"string\">&quot;行 删除了&quot;</span><span class=\"variable\">$add_line</span><span class=\"string\">&quot;行&quot;</span></span><br><span class=\"line\">\t</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">#获取该用户在该文件夹下的提交代码数</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"function\"><span class=\"title\">get_user_line</span></span>() &#123;</span><br><span class=\"line\">\t<span class=\"comment\"># output分别去接收 该文件夹下的提交以及删除行数</span></span><br><span class=\"line\">\toutput=$(git <span class=\"built_in\">log</span> --author=<span class=\"variable\">$&#123;1&#125;</span> --pretty=tformat: --numstat | awk <span class=\"string\">&#x27;</span></span><br><span class=\"line\"><span class=\"string\">    &#123;add += $1; subs += $2; loc += $1 - $2 &#125; END &#123; printf &quot;添加了%s,删除了%s,合计%s\\n&quot;, add, subs, loc &#125;&#x27;</span> -)</span><br><span class=\"line\">\tget_add_remove_count <span class=\"variable\">$output</span> <span class=\"variable\">$&#123;1&#125;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#遍历每个用户名</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"function\"><span class=\"title\">trans_every_user</span></span>() &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"string\">&quot;<span class=\"variable\">$&#123;!users_name[@]&#125;</span>&quot;</span>; <span class=\"keyword\">do</span></span><br><span class=\"line\">\t\tget_user_line <span class=\"string\">&quot;<span class=\"variable\">$&#123;users_name[$i]&#125;</span>&quot;</span></span><br><span class=\"line\">\t<span class=\"keyword\">done</span></span><br><span class=\"line\">\t<span class=\"built_in\">cd</span> ..</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 整体流程，从文件夹出发</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> path <span class=\"keyword\">in</span> `<span class=\"built_in\">ls</span> -l $(<span class=\"built_in\">dirname</span> <span class=\"variable\">$0</span>)|awk -F <span class=\"string\">&quot; &quot;</span> <span class=\"string\">&#x27;&#123;print $9&#125;&#x27;</span>`</span><br><span class=\"line\"><span class=\"keyword\">do</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> [ -d <span class=\"variable\">$path</span> ]</span><br><span class=\"line\">    <span class=\"keyword\">then</span></span><br><span class=\"line\">        is_fileter_dir <span class=\"variable\">$path</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> [ $? == 1 ]</span><br><span class=\"line\">        <span class=\"keyword\">then</span></span><br><span class=\"line\">            <span class=\"built_in\">echo</span> <span class=\"string\">&quot;&lt;=========过滤了【&quot;</span><span class=\"variable\">$path</span><span class=\"string\">&quot;】======&gt;&quot;</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">            <span class=\"built_in\">echo</span> <span class=\"string\">&quot;&lt;=========获取【&quot;</span><span class=\"variable\">$path</span><span class=\"string\">&quot;】的Git代码提交数据======&gt;&quot;</span></span><br><span class=\"line\">\t\t\tindex=<span class=\"variable\">$&#123;#array_git_repositories[@]&#125;</span> <span class=\"comment\">#用于记录当前在第几个文件夹下处理</span></span><br><span class=\"line\">            array_git_repositories=(<span class=\"variable\">$&#123;array_git_repositories[@]&#125;</span> <span class=\"variable\">$path</span>)</span><br><span class=\"line\">\t\t\t</span><br><span class=\"line\">            <span class=\"built_in\">cd</span> <span class=\"variable\">$path</span></span><br><span class=\"line\">            trans_every_user</span><br><span class=\"line\">        <span class=\"keyword\">fi</span></span><br><span class=\"line\">    <span class=\"keyword\">fi</span></span><br><span class=\"line\"><span class=\"keyword\">done</span></span><br><span class=\"line\">all_add_line=0</span><br><span class=\"line\">all_remove_line=0</span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&#x27;===============================================================================&#x27;</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&quot;                  本次共统计了【&quot;</span><span class=\"variable\">$&#123;#array_git_repositories[@]&#125;</span><span class=\"string\">&quot;】个仓库   by julis.wang      &quot;</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&#x27;===============================================================================&#x27;</span></span><br><span class=\"line\"><span class=\"built_in\">printf</span> <span class=\"string\">&quot;%-30s %10s %10s %10s\\n&quot;</span> <span class=\"string\">&quot;Folder&quot;</span> <span class=\"string\">&quot;Add&quot;</span> <span class=\"string\">&quot;Remove&quot;</span> <span class=\"string\">&quot;All&quot;</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&#x27;-------------------------------------------------------------------------------&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> ((i=<span class=\"number\">0</span>;i&lt;<span class=\"variable\">$&#123;#array_git_repositories[@]&#125;</span>;i++))</span><br><span class=\"line\"><span class=\"keyword\">do</span></span><br><span class=\"line\">\tall_add_line=`<span class=\"built_in\">expr</span> <span class=\"variable\">$all_add_line</span> + <span class=\"variable\">$&#123;add_code[$i]&#125;</span>`</span><br><span class=\"line\">\tall_remove_line=`<span class=\"built_in\">expr</span> <span class=\"variable\">$all_remove_line</span> + <span class=\"variable\">$&#123;remove_code[$i]&#125;</span>`</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span> <span class=\"string\">&quot;%-30s %10s %10s %10s\\n&quot;</span> <span class=\"variable\">$&#123;array_git_repositories[$i]&#125;</span> <span class=\"variable\">$&#123;add_code[$i]&#125;</span> <span class=\"variable\">$&#123;remove_code[$i]&#125;</span> `<span class=\"built_in\">expr</span> <span class=\"variable\">$&#123;add_code[$i]&#125;</span> - <span class=\"variable\">$&#123;remove_code[$i]&#125;</span>`</span><br><span class=\"line\"><span class=\"keyword\">done</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&#x27;-------------------------------------------------------------------------------&#x27;</span></span><br><span class=\"line\"><span class=\"built_in\">printf</span> <span class=\"string\">&quot;%-30s %10s %10s %10s\\n&quot;</span> <span class=\"string\">&quot;Total&quot;</span> <span class=\"variable\">$all_add_line</span> <span class=\"variable\">$all_remove_line</span> `<span class=\"built_in\">expr</span> <span class=\"variable\">$all_add_line</span> - <span class=\"variable\">$all_remove_line</span>`</span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&#x27;===============================================================================&#x27;</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>写在最后：<br>由于本人不太擅长编写shell脚本，所有其中的代码实现方式可能比较粗糙，望理解。</p>\n","cover":null,"images":["https://cdn.julis.wang/blog/img/20200301170230101.png","https://cdn.julis.wang/blog/img/20200301170616289.png","https://cdn.julis.wang/blog/img/20200301171856190.png","https://cdn.julis.wang/blog/img/20200301172119336.png"],"content":"<p>作为一名程序员，我们很想知道自己到底提交了多少行代码到远程仓库，有没有什么工具能够帮我们统计自己写过的代码行数呢？答案是有的。</p>\n<p>这是本次实现的最终效果:</p>\n<img width=\"60%\" src=\"https://cdn.julis.wang/blog/img/20200301170230101.png\">\n\n<h2 id=\"统计代码行数的方式\"><a href=\"#统计代码行数的方式\" class=\"headerlink\" title=\"统计代码行数的方式\"></a>统计代码行数的方式</h2><p>对于代码提交行数统计，通过git 的系统命令就能做到，如下代码所示</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">git <span class=\"built_in\">log</span> --author=<span class=\"string\">&#x27;username&#x27;</span> --pretty=tformat: --numstat | awk <span class=\"string\">&#x27;</span></span><br><span class=\"line\"><span class=\"string\">    &#123;add += $1; subs += $2; loc += $1 - $2 &#125; END &#123; printf &quot;添加了%s,删除了%s,合计%s\\n&quot;, add, subs, loc &#125;&#x27;</span> -</span><br><span class=\"line\">\t</span><br></pre></td></tr></table></figure>\n\n<p>只需要在如下命令输入自己的username就行了，效果如图所示·</p>\n<img src=\"https://cdn.julis.wang/blog/img/20200301170616289.png\">\n\n<p>但是有的人由于环境原因，为了区分一些环境，比如办公司叫：username.office 在家的电脑上叫做: user.home 诸如此类，难道得手动一个一个统计么？当然不行了。</p>\n<p>众所周知，由于工程项目变得更越来越大，拆库也说见不鲜，于是自己的代码分布不同的项目工程，我们想要利用git的统计命令的话就有点吃力了，需要一个一个地进入相应目录进行命令输入？当然不行了。</p>\n<p>今天自己写了一份脚本主要用于统计分布在某个文件夹下所有的代码提交行数，git开源地址：<a href=\"https://github.com/VomPom/ForFun\">https://github.com/VomPom/ForFun</a>源码如下</p>\n<p>如何使用？</p>\n<p>0、将自己需要统计的项目文件目录整理到一个文件夹</p>\n<p>1、讲users_name换成自己的的用户名</p>\n<p>2、由于文件夹下可能有一些例外的不需要统计，添加该文件夹名</p>\n<p>3、讲该shell脚本移动到某个名录下</p>\n<p>4、最后利用 sh codeLine.sh 执行命令</p>\n<img width=\"60%\" src=\"https://cdn.julis.wang/blog/img/20200301171856190.png\">\n<img width=\"60%\" src=\"https://cdn.julis.wang/blog/img/20200301172119336.png\">\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">########################################################</span></span><br><span class=\"line\"><span class=\"comment\">#</span></span><br><span class=\"line\"><span class=\"comment\"># Created by https://julis.wang on 2020/02/28</span></span><br><span class=\"line\"><span class=\"comment\">#</span></span><br><span class=\"line\"><span class=\"comment\"># Description : 统计代码提交行数</span></span><br><span class=\"line\"><span class=\"comment\">#</span></span><br><span class=\"line\"><span class=\"comment\">########################################################</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#!/bin/bash</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#这里添加你的git常用用户名。考虑到每个人的账号可能有很多个，所以定义成数组</span></span><br><span class=\"line\">users_name=(<span class=\"string\">&quot;julis&quot;</span> <span class=\"string\">&quot;julis.wang&quot;</span> <span class=\"string\">&quot;julis.wang.hp&quot;</span>)      </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#过滤一些不需要去遍历的文件夹</span></span><br><span class=\"line\">filter_path=(<span class=\"string\">&quot;Backend&quot;</span> <span class=\"string\">&quot;test&quot;</span> <span class=\"string\">&quot;sdk&quot;</span> <span class=\"string\">&quot;fork&quot;</span> <span class=\"string\">&quot;ArProject&quot;</span>)     </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">########################################################</span></span><br><span class=\"line\"><span class=\"comment\"># 以下代码不需动                       </span></span><br><span class=\"line\"><span class=\"comment\">########################################################</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">export</span> index=0             \t\t\t<span class=\"comment\">#记录当前的位置</span></span><br><span class=\"line\"><span class=\"built_in\">export</span> add_line_count=0             <span class=\"comment\">#添加的line总行数</span></span><br><span class=\"line\"><span class=\"built_in\">export</span> remove_line_count=0          <span class=\"comment\">#删除的总行数</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">export</span> array_git_repositories=()    <span class=\"comment\">#用于记录仓库名</span></span><br><span class=\"line\"><span class=\"built_in\">export</span> add_code=()                  <span class=\"comment\">#记录所有用户对某个库的添加的行数</span></span><br><span class=\"line\"><span class=\"built_in\">export</span> remove_code=()               <span class=\"comment\">#记录所有用户对某个库的删除的行数</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#判断是否需要过滤该目录</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"function\"><span class=\"title\">is_fileter_dir</span></span>() &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"string\">&quot;<span class=\"variable\">$&#123;!filter_path[@]&#125;</span>&quot;</span>; <span class=\"keyword\">do</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> [ <span class=\"variable\">$1</span> == <span class=\"string\">&quot;<span class=\"variable\">$&#123;filter_path[$i]&#125;</span>&quot;</span> ]; <span class=\"keyword\">then</span></span><br><span class=\"line\">\t\t\t<span class=\"built_in\">return</span> 1</span><br><span class=\"line\">\t\t<span class=\"keyword\">fi</span></span><br><span class=\"line\">\t<span class=\"keyword\">done</span></span><br><span class=\"line\">\t<span class=\"built_in\">return</span> 0</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">#对命令执行的返回值进行数据切割</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"function\"><span class=\"title\">get_add_remove_count</span></span>() &#123;</span><br><span class=\"line\">\tstring=<span class=\"variable\">$1</span></span><br><span class=\"line\">\tarray=(<span class=\"variable\">$&#123;string//,/ &#125;</span>)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> [ ! <span class=\"variable\">$&#123;array[0]&#125;</span> ]; <span class=\"keyword\">then</span></span><br><span class=\"line\">  \t\tadd_line=0</span><br><span class=\"line\">\t<span class=\"keyword\">else</span></span><br><span class=\"line\">  \t\tadd_line=<span class=\"variable\">$&#123;array[0]&#125;</span></span><br><span class=\"line\">\t<span class=\"keyword\">fi</span></span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> [ ! <span class=\"variable\">$&#123;array[1]&#125;</span> ]; <span class=\"keyword\">then</span></span><br><span class=\"line\">  \t\tremove_line=0</span><br><span class=\"line\">\t<span class=\"keyword\">else</span></span><br><span class=\"line\">  \t\tremove_line=<span class=\"variable\">$&#123;array[1]&#125;</span></span><br><span class=\"line\">\t<span class=\"keyword\">fi</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> [ ! <span class=\"variable\">$&#123;add_code[$index]&#125;</span> ]; <span class=\"keyword\">then</span></span><br><span class=\"line\">  \t\tadd_code[<span class=\"variable\">$index</span>]=0</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"keyword\">fi</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> [ ! <span class=\"variable\">$&#123;remove_code[$index]&#125;</span> ]; <span class=\"keyword\">then</span></span><br><span class=\"line\">  \t\tremove_code[<span class=\"variable\">$index</span>]=0</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"keyword\">fi</span></span><br><span class=\"line\">\tremove_code[<span class=\"variable\">$index</span>]=`<span class=\"built_in\">expr</span> <span class=\"variable\">$&#123;remove_code[$index]&#125;</span> + <span class=\"variable\">$remove_line</span>`</span><br><span class=\"line\">\tadd_code[<span class=\"variable\">$index</span>]=`<span class=\"built_in\">expr</span> <span class=\"variable\">$&#123;add_code[$index]&#125;</span> + <span class=\"variable\">$add_line</span>`</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">echo</span> <span class=\"string\">&quot;用户&quot;</span><span class=\"variable\">$2</span><span class=\"string\">&quot;添加了=&quot;</span><span class=\"variable\">$add_line</span><span class=\"string\">&quot;行 删除了&quot;</span><span class=\"variable\">$add_line</span><span class=\"string\">&quot;行&quot;</span></span><br><span class=\"line\">\t</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">#获取该用户在该文件夹下的提交代码数</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"function\"><span class=\"title\">get_user_line</span></span>() &#123;</span><br><span class=\"line\">\t<span class=\"comment\"># output分别去接收 该文件夹下的提交以及删除行数</span></span><br><span class=\"line\">\toutput=$(git <span class=\"built_in\">log</span> --author=<span class=\"variable\">$&#123;1&#125;</span> --pretty=tformat: --numstat | awk <span class=\"string\">&#x27;</span></span><br><span class=\"line\"><span class=\"string\">    &#123;add += $1; subs += $2; loc += $1 - $2 &#125; END &#123; printf &quot;添加了%s,删除了%s,合计%s\\n&quot;, add, subs, loc &#125;&#x27;</span> -)</span><br><span class=\"line\">\tget_add_remove_count <span class=\"variable\">$output</span> <span class=\"variable\">$&#123;1&#125;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#遍历每个用户名</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"function\"><span class=\"title\">trans_every_user</span></span>() &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"string\">&quot;<span class=\"variable\">$&#123;!users_name[@]&#125;</span>&quot;</span>; <span class=\"keyword\">do</span></span><br><span class=\"line\">\t\tget_user_line <span class=\"string\">&quot;<span class=\"variable\">$&#123;users_name[$i]&#125;</span>&quot;</span></span><br><span class=\"line\">\t<span class=\"keyword\">done</span></span><br><span class=\"line\">\t<span class=\"built_in\">cd</span> ..</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 整体流程，从文件夹出发</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> path <span class=\"keyword\">in</span> `<span class=\"built_in\">ls</span> -l $(<span class=\"built_in\">dirname</span> <span class=\"variable\">$0</span>)|awk -F <span class=\"string\">&quot; &quot;</span> <span class=\"string\">&#x27;&#123;print $9&#125;&#x27;</span>`</span><br><span class=\"line\"><span class=\"keyword\">do</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> [ -d <span class=\"variable\">$path</span> ]</span><br><span class=\"line\">    <span class=\"keyword\">then</span></span><br><span class=\"line\">        is_fileter_dir <span class=\"variable\">$path</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> [ $? == 1 ]</span><br><span class=\"line\">        <span class=\"keyword\">then</span></span><br><span class=\"line\">            <span class=\"built_in\">echo</span> <span class=\"string\">&quot;&lt;=========过滤了【&quot;</span><span class=\"variable\">$path</span><span class=\"string\">&quot;】======&gt;&quot;</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">            <span class=\"built_in\">echo</span> <span class=\"string\">&quot;&lt;=========获取【&quot;</span><span class=\"variable\">$path</span><span class=\"string\">&quot;】的Git代码提交数据======&gt;&quot;</span></span><br><span class=\"line\">\t\t\tindex=<span class=\"variable\">$&#123;#array_git_repositories[@]&#125;</span> <span class=\"comment\">#用于记录当前在第几个文件夹下处理</span></span><br><span class=\"line\">            array_git_repositories=(<span class=\"variable\">$&#123;array_git_repositories[@]&#125;</span> <span class=\"variable\">$path</span>)</span><br><span class=\"line\">\t\t\t</span><br><span class=\"line\">            <span class=\"built_in\">cd</span> <span class=\"variable\">$path</span></span><br><span class=\"line\">            trans_every_user</span><br><span class=\"line\">        <span class=\"keyword\">fi</span></span><br><span class=\"line\">    <span class=\"keyword\">fi</span></span><br><span class=\"line\"><span class=\"keyword\">done</span></span><br><span class=\"line\">all_add_line=0</span><br><span class=\"line\">all_remove_line=0</span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&#x27;===============================================================================&#x27;</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&quot;                  本次共统计了【&quot;</span><span class=\"variable\">$&#123;#array_git_repositories[@]&#125;</span><span class=\"string\">&quot;】个仓库   by julis.wang      &quot;</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&#x27;===============================================================================&#x27;</span></span><br><span class=\"line\"><span class=\"built_in\">printf</span> <span class=\"string\">&quot;%-30s %10s %10s %10s\\n&quot;</span> <span class=\"string\">&quot;Folder&quot;</span> <span class=\"string\">&quot;Add&quot;</span> <span class=\"string\">&quot;Remove&quot;</span> <span class=\"string\">&quot;All&quot;</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&#x27;-------------------------------------------------------------------------------&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> ((i=<span class=\"number\">0</span>;i&lt;<span class=\"variable\">$&#123;#array_git_repositories[@]&#125;</span>;i++))</span><br><span class=\"line\"><span class=\"keyword\">do</span></span><br><span class=\"line\">\tall_add_line=`<span class=\"built_in\">expr</span> <span class=\"variable\">$all_add_line</span> + <span class=\"variable\">$&#123;add_code[$i]&#125;</span>`</span><br><span class=\"line\">\tall_remove_line=`<span class=\"built_in\">expr</span> <span class=\"variable\">$all_remove_line</span> + <span class=\"variable\">$&#123;remove_code[$i]&#125;</span>`</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span> <span class=\"string\">&quot;%-30s %10s %10s %10s\\n&quot;</span> <span class=\"variable\">$&#123;array_git_repositories[$i]&#125;</span> <span class=\"variable\">$&#123;add_code[$i]&#125;</span> <span class=\"variable\">$&#123;remove_code[$i]&#125;</span> `<span class=\"built_in\">expr</span> <span class=\"variable\">$&#123;add_code[$i]&#125;</span> - <span class=\"variable\">$&#123;remove_code[$i]&#125;</span>`</span><br><span class=\"line\"><span class=\"keyword\">done</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&#x27;-------------------------------------------------------------------------------&#x27;</span></span><br><span class=\"line\"><span class=\"built_in\">printf</span> <span class=\"string\">&quot;%-30s %10s %10s %10s\\n&quot;</span> <span class=\"string\">&quot;Total&quot;</span> <span class=\"variable\">$all_add_line</span> <span class=\"variable\">$all_remove_line</span> `<span class=\"built_in\">expr</span> <span class=\"variable\">$all_add_line</span> - <span class=\"variable\">$all_remove_line</span>`</span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&#x27;===============================================================================&#x27;</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>写在最后：<br>由于本人不太擅长编写shell脚本，所有其中的代码实现方式可能比较粗糙，望理解。</p>\n","categories":[{"name":"技术文章","slug":"technology","api":"api/categories/technology.json"}],"tags":[{"name":"Shell","slug":"Shell","api":"api/tags/Shell.json"}],"api":"api/posts/2020/03/02/想统计自己总共提交了多少行代码？.json"}],"info":{"type":"archive","year":2020}},"api":"api/archives/2020/page.2.json"}