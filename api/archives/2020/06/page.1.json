{"data":{"index":1,"total":1,"posts":[{"title":"《82年生的金智英》","slug":"《82年生的金智英》","date":"2020-06-26T10:49:00.000Z","updated":"2025-05-20T11:46:57.000Z","comments":true,"url":"2020/06/26/《82年生的金智英》/","excerpt":"<p>今天一口气把《82年生的金智英》书和电影都看完了，电影的节奏是很压抑的，又是韩国一种“生病”的故事套路，因为有看过书，所以整部电影是带着期待感下去的，想去看看电影的结局到底是怎么样，和书中的结局有什么区别（书中其实没有结局，只是平淡地讲整个故事给叙述了一遍）。当第一次看到这书名的时候，以为这是一本以“金智英”为主体的个人成长奋斗故事。然而并没有那么简单……与其这是一部关于“金智英”的小说，倒不如说是一部关于韩国现实女性的纪录片。</p>\n<p>整本书按照时间顺序讲述金智英从一九八二年出生开始到二〇一五，故事按时分为几个章节：小学初中、高中大学、职场、婚后。在人生故事的每一个阶段，都充斥着对女性的不公，每个阶段讲述的故事大抵也是很普通的故事，没有十恶不赦的大恶人，让她受到伤害的是整个社会文化风气，这才是最揪心的。书以二〇一六最新的“治疗”结果结尾，也并没有说明‘病“好了，并叙述了作者自己周围女性的境遇，你我身边都有很多“金智英”。</p>\n<p>为什么主角叫“金智英”？因为在一九八二年出生的女性中，“金智英”是一个很常见的名字，在韩国“金智英”是一个很常见的名字，她代表了一众女性群体。然而书中的金智英在韩国，过得并不是最辛苦的，她有受到过良好的高等教育，她还有支持她的妈妈、赏识她的上司、关心她的老公、理解她的朋友，但她依然在社会中因为是“女性”，而艰难地挣扎着。</p>\n<p>看完整部书和电影，我一直有一种对生活在韩国的女性的遭遇的同情，也为生活在中国的女性而感到幸运。然而细想，真的是这样子么？也许自己不是女性，所以对很多都不太了解，但是自己也能感受到一些。举一个例子，曾在脉脉动态上有看到这样的简历介绍:结婚了，孩子两岁了，不打算要二胎。 简历介绍其实也透露出社会的现状，具体就不再细谈，懂的人自然懂。我们应该感激自己周围的女性，她们真的很不容易，也许是一些固化的思维，我们感受不到其中的细节罢了。</p>\n<p>但可悲的是，这本书被贴上了女性主义的标签，甚至女q主义者拿这本书当做“资本”，借用书中最后的译后记中</p>\n<blockquote>\n<p>艾玛·沃特森在国际妇女节中说的话，她重申自己的核心理念：“争取的是不是女权，而是两性的自由”。本书希望的是能够让更多的那行对于女性的处境有所了解，相互体谅，帮助彼此。希望世界变得更加美好，女生不再成为某些事件的筛选条件；而这需要女人的自觉与男人的换位思考。</p>\n</blockquote>\n","cover":null,"images":[],"content":"<p>今天一口气把《82年生的金智英》书和电影都看完了，电影的节奏是很压抑的，又是韩国一种“生病”的故事套路，因为有看过书，所以整部电影是带着期待感下去的，想去看看电影的结局到底是怎么样，和书中的结局有什么区别（书中其实没有结局，只是平淡地讲整个故事给叙述了一遍）。当第一次看到这书名的时候，以为这是一本以“金智英”为主体的个人成长奋斗故事。然而并没有那么简单……与其这是一部关于“金智英”的小说，倒不如说是一部关于韩国现实女性的纪录片。</p>\n<p>整本书按照时间顺序讲述金智英从一九八二年出生开始到二〇一五，故事按时分为几个章节：小学初中、高中大学、职场、婚后。在人生故事的每一个阶段，都充斥着对女性的不公，每个阶段讲述的故事大抵也是很普通的故事，没有十恶不赦的大恶人，让她受到伤害的是整个社会文化风气，这才是最揪心的。书以二〇一六最新的“治疗”结果结尾，也并没有说明‘病“好了，并叙述了作者自己周围女性的境遇，你我身边都有很多“金智英”。</p>\n<p>为什么主角叫“金智英”？因为在一九八二年出生的女性中，“金智英”是一个很常见的名字，在韩国“金智英”是一个很常见的名字，她代表了一众女性群体。然而书中的金智英在韩国，过得并不是最辛苦的，她有受到过良好的高等教育，她还有支持她的妈妈、赏识她的上司、关心她的老公、理解她的朋友，但她依然在社会中因为是“女性”，而艰难地挣扎着。</p>\n<p>看完整部书和电影，我一直有一种对生活在韩国的女性的遭遇的同情，也为生活在中国的女性而感到幸运。然而细想，真的是这样子么？也许自己不是女性，所以对很多都不太了解，但是自己也能感受到一些。举一个例子，曾在脉脉动态上有看到这样的简历介绍:结婚了，孩子两岁了，不打算要二胎。 简历介绍其实也透露出社会的现状，具体就不再细谈，懂的人自然懂。我们应该感激自己周围的女性，她们真的很不容易，也许是一些固化的思维，我们感受不到其中的细节罢了。</p>\n<p>但可悲的是，这本书被贴上了女性主义的标签，甚至女q主义者拿这本书当做“资本”，借用书中最后的译后记中</p>\n<blockquote>\n<p>艾玛·沃特森在国际妇女节中说的话，她重申自己的核心理念：“争取的是不是女权，而是两性的自由”。本书希望的是能够让更多的那行对于女性的处境有所了解，相互体谅，帮助彼此。希望世界变得更加美好，女生不再成为某些事件的筛选条件；而这需要女人的自觉与男人的换位思考。</p>\n</blockquote>\n","categories":[{"name":"读书电影","slug":"movie","api":"api/categories/movie.json"}],"tags":[{"name":"读书","slug":"读书","api":"api/tags/读书.json"}],"api":"api/posts/2020/06/26/《82年生的金智英》.json"},{"title":"WeakHashMap与Java引用相关","slug":"WeakHashMap与Java引用相关","date":"2020-06-22T03:19:00.000Z","updated":"2025-05-20T11:46:57.000Z","comments":true,"url":"2020/06/22/WeakHashMap与Java引用相关/","excerpt":"<p>记得在很久之前有写过一篇<a href=\"https://blog.csdn.net/u010107153/article/details/102821282\">《Java中的Reference解析》</a>，主要讲的是Java中的四种引用方式与引用队列，不过这些都是基础的理论知识，最近开发项目中有使用到WeakHashMap，对于Java的引用以及引用队列有了更深的了解，在此做个相关总结。</p>\n<h2 id=\"一、WeakHashMap的实现方式\"><a href=\"#一、WeakHashMap的实现方式\" class=\"headerlink\" title=\"一、WeakHashMap的实现方式\"></a>一、WeakHashMap的实现方式</h2><p>总体来说，WeakHashMap的底层数据结构与HashMap的实现差不多，都是用“拉链法”来实现，主要区别在于WeakHashMap的Entry 继承于WeakReference，并维护一个ReferenceQueue，使其具有了“弱引用的特性”，其构造方法可以看出：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">Entry(Object key, V value,ReferenceQueue&lt;Object&gt; queue,<span class=\"type\">int</span> hash, Entry&lt;K,V&gt; next) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">super</span>(key, queue); <span class=\"comment\">//这里比较关键</span></span><br><span class=\"line\">            ……</span><br><span class=\"line\">        &#125;</span><br></pre></td></tr></table></figure>\n<p>其中的super父类的代码实现为：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"title function_\">WeakReference</span><span class=\"params\">(T referent, ReferenceQueue&lt;? <span class=\"built_in\">super</span> T&gt; q)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">super</span>(referent, q);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>通过对父类的构造方法可以知道，WeakMap的key值为弱引用类型，回顾一下弱引用的特点：<strong>垃圾收集器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。</strong> 于是WeakHashMap的作用就凸显出来了：**对于数据中Key-value，key因为使用的弱引用会被回收，而value也会得到对应的释放。**以我这次的需求为例：key为Webview页面或者Flutter&#x2F;RN页面，value为调用native方法相关存储的对象。当页面需要关闭调webivew的时候，Webview应该要被释放，要不然会产生内存泄漏，当其被释放之后，对应的value也没有意义了，所以也需要被释放掉。</p>\n<p> 那么WeakHashMap是如何让value释放的呢？</p>\n<h2 id=\"二、WeakHashMap如何释放无用的Value\"><a href=\"#二、WeakHashMap如何释放无用的Value\" class=\"headerlink\" title=\"二、WeakHashMap如何释放无用的Value\"></a>二、WeakHashMap如何释放无用的Value</h2><p>要回收无用的Value，那么引用队列（ReferenceQueue）就派上用场了，回顾一下引用队列的作用：<strong>当一个引用（软引用、弱引用）关联到了一个引用队列后，当这个引用所引用的对象要被垃圾回收时，就会将它加入到所关联的引用队列中。</strong><br>所以判断一个引用对象是否已经被回收的一个现象就是，这个对象的引用是否被加入到了它所关联的引用队列。<br>那么对于WeakHashMap也是利用这一点特性，在其代码中put\\get等方法都有执行对应等检查</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> V <span class=\"title function_\">put</span><span class=\"params\">(K key, V value)</span> &#123;</span><br><span class=\"line\">       <span class=\"type\">Object</span> <span class=\"variable\">k</span> <span class=\"operator\">=</span> maskNull(key);</span><br><span class=\"line\">       <span class=\"type\">int</span> <span class=\"variable\">h</span> <span class=\"operator\">=</span> hash(k);</span><br><span class=\"line\">       Entry&lt;K,V&gt;[] tab = getTable(); <span class=\"comment\">//具体实现在getTable执行的expungeStaleEntries里面</span></span><br><span class=\"line\">       ……</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> V <span class=\"title function_\">get</span><span class=\"params\">(Object key)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">Object</span> <span class=\"variable\">k</span> <span class=\"operator\">=</span> maskNull(key);</span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">h</span> <span class=\"operator\">=</span> hash(k);</span><br><span class=\"line\">    Entry&lt;K,V&gt;[] tab = getTable();</span><br><span class=\"line\">    ……</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Expunges stale entries from the table.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">expungeStaleEntries</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (Object x; (x = queue.poll()) != <span class=\"literal\">null</span>; ) &#123; <span class=\"comment\">//这里的queue就是引用队列</span></span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span> (queue) &#123; </span><br><span class=\"line\">            <span class=\"meta\">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class=\"line\">                Entry&lt;K,V&gt; e = (Entry&lt;K,V&gt;) x;</span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> indexFor(e.hash, table.length);</span><br><span class=\"line\"></span><br><span class=\"line\">            Entry&lt;K,V&gt; prev = table[i];</span><br><span class=\"line\">            Entry&lt;K,V&gt; p = prev;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (p != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">                Entry&lt;K,V&gt; next = p.next;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (p == e) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (prev == e)</span><br><span class=\"line\">                        table[i] = next;</span><br><span class=\"line\">                    <span class=\"keyword\">else</span></span><br><span class=\"line\">                        prev.next = next;</span><br><span class=\"line\">                    <span class=\"comment\">// Must not null out e.next;</span></span><br><span class=\"line\">                    <span class=\"comment\">// stale entries may be in use by a HashIterator</span></span><br><span class=\"line\">                    e.value = <span class=\"literal\">null</span>; <span class=\"comment\">// Help GC</span></span><br><span class=\"line\">                    size--;</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                prev = p;</span><br><span class=\"line\">                p = next;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>从上面的代码逻辑可以很清楚的知道：WeakHashMap通过对引用队列的数据进行检查，对key被回收对象的对应Value进行了回收。</p>\n<h2 id=\"三、总结\"><a href=\"#三、总结\" class=\"headerlink\" title=\"三、总结\"></a>三、总结</h2><p>1、WeakHashMap的Entry 继承于WeakReference，并维护一个ReferenceQueue<br>2、在执行get\\put等相关数据操作的时候 会对数据进行相关处理，主要是清除掉无用对象对</p>\n","cover":null,"images":[],"content":"<p>记得在很久之前有写过一篇<a href=\"https://blog.csdn.net/u010107153/article/details/102821282\">《Java中的Reference解析》</a>，主要讲的是Java中的四种引用方式与引用队列，不过这些都是基础的理论知识，最近开发项目中有使用到WeakHashMap，对于Java的引用以及引用队列有了更深的了解，在此做个相关总结。</p>\n<h2 id=\"一、WeakHashMap的实现方式\"><a href=\"#一、WeakHashMap的实现方式\" class=\"headerlink\" title=\"一、WeakHashMap的实现方式\"></a>一、WeakHashMap的实现方式</h2><p>总体来说，WeakHashMap的底层数据结构与HashMap的实现差不多，都是用“拉链法”来实现，主要区别在于WeakHashMap的Entry 继承于WeakReference，并维护一个ReferenceQueue，使其具有了“弱引用的特性”，其构造方法可以看出：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">Entry(Object key, V value,ReferenceQueue&lt;Object&gt; queue,<span class=\"type\">int</span> hash, Entry&lt;K,V&gt; next) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">super</span>(key, queue); <span class=\"comment\">//这里比较关键</span></span><br><span class=\"line\">            ……</span><br><span class=\"line\">        &#125;</span><br></pre></td></tr></table></figure>\n<p>其中的super父类的代码实现为：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"title function_\">WeakReference</span><span class=\"params\">(T referent, ReferenceQueue&lt;? <span class=\"built_in\">super</span> T&gt; q)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">super</span>(referent, q);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>通过对父类的构造方法可以知道，WeakMap的key值为弱引用类型，回顾一下弱引用的特点：<strong>垃圾收集器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。</strong> 于是WeakHashMap的作用就凸显出来了：**对于数据中Key-value，key因为使用的弱引用会被回收，而value也会得到对应的释放。**以我这次的需求为例：key为Webview页面或者Flutter&#x2F;RN页面，value为调用native方法相关存储的对象。当页面需要关闭调webivew的时候，Webview应该要被释放，要不然会产生内存泄漏，当其被释放之后，对应的value也没有意义了，所以也需要被释放掉。</p>\n<p> 那么WeakHashMap是如何让value释放的呢？</p>\n<h2 id=\"二、WeakHashMap如何释放无用的Value\"><a href=\"#二、WeakHashMap如何释放无用的Value\" class=\"headerlink\" title=\"二、WeakHashMap如何释放无用的Value\"></a>二、WeakHashMap如何释放无用的Value</h2><p>要回收无用的Value，那么引用队列（ReferenceQueue）就派上用场了，回顾一下引用队列的作用：<strong>当一个引用（软引用、弱引用）关联到了一个引用队列后，当这个引用所引用的对象要被垃圾回收时，就会将它加入到所关联的引用队列中。</strong><br>所以判断一个引用对象是否已经被回收的一个现象就是，这个对象的引用是否被加入到了它所关联的引用队列。<br>那么对于WeakHashMap也是利用这一点特性，在其代码中put\\get等方法都有执行对应等检查</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> V <span class=\"title function_\">put</span><span class=\"params\">(K key, V value)</span> &#123;</span><br><span class=\"line\">       <span class=\"type\">Object</span> <span class=\"variable\">k</span> <span class=\"operator\">=</span> maskNull(key);</span><br><span class=\"line\">       <span class=\"type\">int</span> <span class=\"variable\">h</span> <span class=\"operator\">=</span> hash(k);</span><br><span class=\"line\">       Entry&lt;K,V&gt;[] tab = getTable(); <span class=\"comment\">//具体实现在getTable执行的expungeStaleEntries里面</span></span><br><span class=\"line\">       ……</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> V <span class=\"title function_\">get</span><span class=\"params\">(Object key)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">Object</span> <span class=\"variable\">k</span> <span class=\"operator\">=</span> maskNull(key);</span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">h</span> <span class=\"operator\">=</span> hash(k);</span><br><span class=\"line\">    Entry&lt;K,V&gt;[] tab = getTable();</span><br><span class=\"line\">    ……</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Expunges stale entries from the table.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">expungeStaleEntries</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (Object x; (x = queue.poll()) != <span class=\"literal\">null</span>; ) &#123; <span class=\"comment\">//这里的queue就是引用队列</span></span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span> (queue) &#123; </span><br><span class=\"line\">            <span class=\"meta\">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class=\"line\">                Entry&lt;K,V&gt; e = (Entry&lt;K,V&gt;) x;</span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> indexFor(e.hash, table.length);</span><br><span class=\"line\"></span><br><span class=\"line\">            Entry&lt;K,V&gt; prev = table[i];</span><br><span class=\"line\">            Entry&lt;K,V&gt; p = prev;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (p != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">                Entry&lt;K,V&gt; next = p.next;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (p == e) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (prev == e)</span><br><span class=\"line\">                        table[i] = next;</span><br><span class=\"line\">                    <span class=\"keyword\">else</span></span><br><span class=\"line\">                        prev.next = next;</span><br><span class=\"line\">                    <span class=\"comment\">// Must not null out e.next;</span></span><br><span class=\"line\">                    <span class=\"comment\">// stale entries may be in use by a HashIterator</span></span><br><span class=\"line\">                    e.value = <span class=\"literal\">null</span>; <span class=\"comment\">// Help GC</span></span><br><span class=\"line\">                    size--;</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                prev = p;</span><br><span class=\"line\">                p = next;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>从上面的代码逻辑可以很清楚的知道：WeakHashMap通过对引用队列的数据进行检查，对key被回收对象的对应Value进行了回收。</p>\n<h2 id=\"三、总结\"><a href=\"#三、总结\" class=\"headerlink\" title=\"三、总结\"></a>三、总结</h2><p>1、WeakHashMap的Entry 继承于WeakReference，并维护一个ReferenceQueue<br>2、在执行get\\put等相关数据操作的时候 会对数据进行相关处理，主要是清除掉无用对象对</p>\n","categories":[{"name":"技术文章","slug":"technology","api":"api/categories/technology.json"}],"tags":[{"name":"Java","slug":"java","api":"api/tags/java.json"}],"api":"api/posts/2020/06/22/WeakHashMap与Java引用相关.json"},{"title":"关于朋友","slug":"关于朋友","date":"2020-06-15T08:11:00.000Z","updated":"2025-05-20T11:46:57.000Z","comments":true,"url":"2020/06/15/关于朋友/","excerpt":"<p>2020年6月15日，我最好的初高中朋友ZR（女）和XBC（男）在今天拿到了结婚证了，结束了快十年的爱情长跑。我和他们都是在初中的时候认识的，后来在一个高中，大学便分别了。虽然每年只会在过年的时候才会见面，但是那种友情却不因时间和距离而减。对于他们拿到结婚证，今天也是突然有感于其中。</p>\n<p>我与XBC是初中是最好的朋友了，那时候我们正值青春懵懂时期，我与他干了不少“坏事”，上课调皮捣蛋，晚上就寝与老师斗智斗勇。班主任罚检讨、被挨打、被体罚不知道有多少次，那时候正值青春叛逆时期，懵懂无知，做了很多有趣的事情，现在回想起来都是一串串难忘的记忆。</p>\n<p>还记得初中时候跟他聊的特别多，上课也是聊天，我们总会产生各种鬼主意。我们聊着那时候玩过的游戏DOTA、重装机兵，我们都追着Justin Bieber、Taylor Swift并哼唱着他们的歌，以及追着当时正火的《火影忍者》与《死神》。</p>\n<p>感谢有你，让我初中的三年是过得如此的充实。</p>\n<p>我与ZR直到初三的时候才因为座位离得近，才有更好的认识，渐渐地也了解多了，我发现和她是能比较聊得来的人。直到高中后，我才发现我有这样一个异性朋友是多么的值得。高中时，每一次的情感挫折都向她倾述，我现在已经有点模糊记忆了，高中时不知道跟她讲了多少我的故事给她。</p>\n<p>我清晰地记得高二时，我的爷爷在凌晨两点去世，那时候我感觉全世界都塌了，我发了几条短信给她，我想告诉她我当时真的很难受，后来在她的安慰下，我慢慢地走了出来。她成了我倾述的对象，不开心的时候，跟她聊聊，总会好起来。每年的生日，她总是会记得，也会送我礼物，当然也记得她的生日，我记得曾经做过几个视频给她，是她十七岁的时候，收集她的照片，最终做成了一个MV，现在再回头看看当时的视频，也是蛮有回忆感的。我家里仍然还保留着我十七八岁时她送我的礼物，以及信件。</p>\n<p>感谢有你，让我高中的三年是过得如此的充实。</p>\n<p>ZR与XBC是我十年的老朋友了，十年的朋友，实在是太难得了，我不知道这是一种如何的缘分，你们是我最好的朋友，也是我现在在外漂泊，愿哪天能回到故乡时的动力。你们作为我朋友中的情侣模范，实在是竖立了榜样给我们，让我再一次感受到爱情的存在。<br>感谢有你们，让我生活充满生机。</p>\n<p>此时我打开网易云播放一首张宇的《<a href=\"https://music.163.com/song?id=190499&userid=446412439\">给你们</a>》，在遥远的上海默默地祝福你们，很喜欢一首民国时期的结婚证书上的誓词送给你们：</p>\n<blockquote>\n<p>喜今日两姓联姻，一堂缔约，良缘永结，匹配同称。 看此日桃花灼灼，宜室宜家，卜他年瓜瓞绵绵，尔昌尔炽。<br>谨以白头之约，书向鸿笺，好将红叶之盟，载明鸳谱。</p>\n</blockquote>\n","cover":null,"images":[],"content":"<p>2020年6月15日，我最好的初高中朋友ZR（女）和XBC（男）在今天拿到了结婚证了，结束了快十年的爱情长跑。我和他们都是在初中的时候认识的，后来在一个高中，大学便分别了。虽然每年只会在过年的时候才会见面，但是那种友情却不因时间和距离而减。对于他们拿到结婚证，今天也是突然有感于其中。</p>\n<p>我与XBC是初中是最好的朋友了，那时候我们正值青春懵懂时期，我与他干了不少“坏事”，上课调皮捣蛋，晚上就寝与老师斗智斗勇。班主任罚检讨、被挨打、被体罚不知道有多少次，那时候正值青春叛逆时期，懵懂无知，做了很多有趣的事情，现在回想起来都是一串串难忘的记忆。</p>\n<p>还记得初中时候跟他聊的特别多，上课也是聊天，我们总会产生各种鬼主意。我们聊着那时候玩过的游戏DOTA、重装机兵，我们都追着Justin Bieber、Taylor Swift并哼唱着他们的歌，以及追着当时正火的《火影忍者》与《死神》。</p>\n<p>感谢有你，让我初中的三年是过得如此的充实。</p>\n<p>我与ZR直到初三的时候才因为座位离得近，才有更好的认识，渐渐地也了解多了，我发现和她是能比较聊得来的人。直到高中后，我才发现我有这样一个异性朋友是多么的值得。高中时，每一次的情感挫折都向她倾述，我现在已经有点模糊记忆了，高中时不知道跟她讲了多少我的故事给她。</p>\n<p>我清晰地记得高二时，我的爷爷在凌晨两点去世，那时候我感觉全世界都塌了，我发了几条短信给她，我想告诉她我当时真的很难受，后来在她的安慰下，我慢慢地走了出来。她成了我倾述的对象，不开心的时候，跟她聊聊，总会好起来。每年的生日，她总是会记得，也会送我礼物，当然也记得她的生日，我记得曾经做过几个视频给她，是她十七岁的时候，收集她的照片，最终做成了一个MV，现在再回头看看当时的视频，也是蛮有回忆感的。我家里仍然还保留着我十七八岁时她送我的礼物，以及信件。</p>\n<p>感谢有你，让我高中的三年是过得如此的充实。</p>\n<p>ZR与XBC是我十年的老朋友了，十年的朋友，实在是太难得了，我不知道这是一种如何的缘分，你们是我最好的朋友，也是我现在在外漂泊，愿哪天能回到故乡时的动力。你们作为我朋友中的情侣模范，实在是竖立了榜样给我们，让我再一次感受到爱情的存在。<br>感谢有你们，让我生活充满生机。</p>\n<p>此时我打开网易云播放一首张宇的《<a href=\"https://music.163.com/song?id=190499&userid=446412439\">给你们</a>》，在遥远的上海默默地祝福你们，很喜欢一首民国时期的结婚证书上的誓词送给你们：</p>\n<blockquote>\n<p>喜今日两姓联姻，一堂缔约，良缘永结，匹配同称。 看此日桃花灼灼，宜室宜家，卜他年瓜瓞绵绵，尔昌尔炽。<br>谨以白头之约，书向鸿笺，好将红叶之盟，载明鸳谱。</p>\n</blockquote>\n","categories":[{"name":"生活感想","slug":"life","api":"api/categories/life.json"}],"tags":[{"name":"省","slug":"thinking","api":"api/tags/thinking.json"}],"api":"api/posts/2020/06/15/关于朋友.json"},{"title":"《费马大定理》","slug":"《费马大定理》","date":"2020-06-09T14:32:00.000Z","updated":"2025-05-20T11:46:57.000Z","comments":true,"url":"2020/06/09/《费马大定理》/","excerpt":"<p>大约在1637年左右，法国学者费马在阅读丢番图《算术》拉丁文译本时，曾在第11卷第8命题旁写道：</p>\n<blockquote>\n<p>将一个立方数分成两个立方数之和，或一个四次幂分成两个四次幂之和，或者一般地将一个高于二次的幂分成两个同次幂之和，这是不可能的。关于此，我确信已发现了一种美妙的证法，可惜这里空白的地方太小，写不下。</p>\n</blockquote>\n<p>其中的条件用数学表达语言则：<br>$$<br>当整数n &gt;2时，关于x, y, z的方程 x^n + y^n &#x3D; z^n 没有正整数解。<br>$$</p>\n<p>这个数学理论简单明了，初中生都能看懂的理论，但是没有被得到最终的证明，费马自己提出来，没有得到完全的证明，他只证明了n&#x3D;4的情况，后来欧拉沿着费马“无穷递降法”的思路，再向前迈出小小的一步，将n&#x3D;4延伸到n&#x3D;3的情形。但是大于4的情况呢？</p>\n<p>费马的一段话，让数学界开始了长达300年的数学接力，有高斯、欧拉等诸多著名数学家都有尝试去彻底解决这个问题，但都无果。甚至后来开始推断出这是一个不能被证明的理论，在证明路上数学家们一直因证明失败而被打击，但这并不不能阻碍数学家们对这个问题的证明。最终，358年后，由英国数学家安德鲁.怀尔斯在1994成功完成了证明。看似轻描淡写，但有多少数学家在他证明的路上铺上了砖石呢？从费马提出到欧拉解决了n&#x3D;3的情况，中途诸多数学家的猜想与推论，最后谷山与志村提出的“谷山-志村猜想”，<strong>只要能证明“谷山-志村猜想”就能自动证明费马大定理</strong>。就这样，一个大问题被一点点地解决了，但时间长达300多年。</p>\n<p>《费马大定理》是是一部数学史，整本书以时间为基线，讲从费马提出这个问题开始，到最终怀尔斯完全证明费马大定理的过程。自己虽然对于数学没有很深入的了解，但是整本书看下来也是十分的吸引人，像我们熟知的毕达哥拉斯定理（勾股定理）与费马大定理联系起来（n&#x3D;2的情况是有正数解的），$\\sqrt{2}$ 是无理数的欧几里得证明等，就算对数学不太了解的人，也会为其中的证明技巧所感叹。</p>\n<p>当然本书中所有的数学家的故事都是一个振奋人心的角色，为证明费马大定理前赴后继，铸就了数学史诗，关于他们奋斗的故事，可以去仔细了解。除此之外，这本书给人最大的感触就是：<strong>站在巨人的肩膀上</strong>。</p>\n<p>如果说怀尔斯证明出来费马大定理是他一个人的功劳，那肯定很多人不会服了。如果说怀尔斯是站在了巨人的肩膀上，那么前面那么多的数学家共同组成了这个巨人。对于怀尔斯之前的谷山与志村则站在了“模形式”巨人上。对于怀尔斯证明完成之后，要直接使用费马大定理，那么怀尔斯又与前面那么多的数学家一起组成了更大的巨人。之后的数学学科利用费马大定理做一些更深入的研究后，那么这个巨人便变得更大了。</p>\n<p>为了证明费马大定理，产生了许多数学成果，拓宽了数学的领域，促进了数学的发展，数学家们将数学这个巨人变得越来越大。现代学科研究，利用数学，将物理学科的巨人变大，将计算机学科巨人变大……最终使整个科技巨人变大。而我们只需要站在巨人的肩膀上，只需要鼠标一点，这些巨人便开始奔跑。虽然说积跬步虽也能成千里，但远不如坐上高铁走四方，这便是站在巨人的肩膀上，而巨人是一代代人前赴后继的结果。</p>\n<p>最后补充一个：为什么费马大定理在数学史上的地位如此重要？<br>有人答道</p>\n<blockquote>\n<p>丢番图、毕达哥拉斯、费马、热尔曼、柯西、欧拉、希尔伯特、哥德尔、图灵、伽罗瓦、谷山丰、志村五郎、沃尔夫斯凯尔、怀尔斯……这些数学史上最伟大的名字，在整个「费马定理大戏」上轮番登场。他们有的奠定了数论基础、有的为提出费马定理铺平道路，有的提出问题却不给解答，有的人尝试了却失败，有的人只能证明部分结论，有的人没有想过证明这个定理却因为自己另一个数学理论创新而成为整个解答的关键，而这个解答却一度被学界不能理解而弃如敝履，有的人在攀登数学高峰的途中逝世，也有的人在面对人生失意决心自尽却因死前无聊看到了这个费马定理而心生兴趣尝试解答最后放弃自杀，设立巨额奖金奖励解答者！</p>\n</blockquote>\n<p>这是一部数学史诗，也是人类智慧最伟大的故事之一。</p>\n","cover":null,"images":[],"content":"<p>大约在1637年左右，法国学者费马在阅读丢番图《算术》拉丁文译本时，曾在第11卷第8命题旁写道：</p>\n<blockquote>\n<p>将一个立方数分成两个立方数之和，或一个四次幂分成两个四次幂之和，或者一般地将一个高于二次的幂分成两个同次幂之和，这是不可能的。关于此，我确信已发现了一种美妙的证法，可惜这里空白的地方太小，写不下。</p>\n</blockquote>\n<p>其中的条件用数学表达语言则：<br>$$<br>当整数n &gt;2时，关于x, y, z的方程 x^n + y^n &#x3D; z^n 没有正整数解。<br>$$</p>\n<p>这个数学理论简单明了，初中生都能看懂的理论，但是没有被得到最终的证明，费马自己提出来，没有得到完全的证明，他只证明了n&#x3D;4的情况，后来欧拉沿着费马“无穷递降法”的思路，再向前迈出小小的一步，将n&#x3D;4延伸到n&#x3D;3的情形。但是大于4的情况呢？</p>\n<p>费马的一段话，让数学界开始了长达300年的数学接力，有高斯、欧拉等诸多著名数学家都有尝试去彻底解决这个问题，但都无果。甚至后来开始推断出这是一个不能被证明的理论，在证明路上数学家们一直因证明失败而被打击，但这并不不能阻碍数学家们对这个问题的证明。最终，358年后，由英国数学家安德鲁.怀尔斯在1994成功完成了证明。看似轻描淡写，但有多少数学家在他证明的路上铺上了砖石呢？从费马提出到欧拉解决了n&#x3D;3的情况，中途诸多数学家的猜想与推论，最后谷山与志村提出的“谷山-志村猜想”，<strong>只要能证明“谷山-志村猜想”就能自动证明费马大定理</strong>。就这样，一个大问题被一点点地解决了，但时间长达300多年。</p>\n<p>《费马大定理》是是一部数学史，整本书以时间为基线，讲从费马提出这个问题开始，到最终怀尔斯完全证明费马大定理的过程。自己虽然对于数学没有很深入的了解，但是整本书看下来也是十分的吸引人，像我们熟知的毕达哥拉斯定理（勾股定理）与费马大定理联系起来（n&#x3D;2的情况是有正数解的），$\\sqrt{2}$ 是无理数的欧几里得证明等，就算对数学不太了解的人，也会为其中的证明技巧所感叹。</p>\n<p>当然本书中所有的数学家的故事都是一个振奋人心的角色，为证明费马大定理前赴后继，铸就了数学史诗，关于他们奋斗的故事，可以去仔细了解。除此之外，这本书给人最大的感触就是：<strong>站在巨人的肩膀上</strong>。</p>\n<p>如果说怀尔斯证明出来费马大定理是他一个人的功劳，那肯定很多人不会服了。如果说怀尔斯是站在了巨人的肩膀上，那么前面那么多的数学家共同组成了这个巨人。对于怀尔斯之前的谷山与志村则站在了“模形式”巨人上。对于怀尔斯证明完成之后，要直接使用费马大定理，那么怀尔斯又与前面那么多的数学家一起组成了更大的巨人。之后的数学学科利用费马大定理做一些更深入的研究后，那么这个巨人便变得更大了。</p>\n<p>为了证明费马大定理，产生了许多数学成果，拓宽了数学的领域，促进了数学的发展，数学家们将数学这个巨人变得越来越大。现代学科研究，利用数学，将物理学科的巨人变大，将计算机学科巨人变大……最终使整个科技巨人变大。而我们只需要站在巨人的肩膀上，只需要鼠标一点，这些巨人便开始奔跑。虽然说积跬步虽也能成千里，但远不如坐上高铁走四方，这便是站在巨人的肩膀上，而巨人是一代代人前赴后继的结果。</p>\n<p>最后补充一个：为什么费马大定理在数学史上的地位如此重要？<br>有人答道</p>\n<blockquote>\n<p>丢番图、毕达哥拉斯、费马、热尔曼、柯西、欧拉、希尔伯特、哥德尔、图灵、伽罗瓦、谷山丰、志村五郎、沃尔夫斯凯尔、怀尔斯……这些数学史上最伟大的名字，在整个「费马定理大戏」上轮番登场。他们有的奠定了数论基础、有的为提出费马定理铺平道路，有的提出问题却不给解答，有的人尝试了却失败，有的人只能证明部分结论，有的人没有想过证明这个定理却因为自己另一个数学理论创新而成为整个解答的关键，而这个解答却一度被学界不能理解而弃如敝履，有的人在攀登数学高峰的途中逝世，也有的人在面对人生失意决心自尽却因死前无聊看到了这个费马定理而心生兴趣尝试解答最后放弃自杀，设立巨额奖金奖励解答者！</p>\n</blockquote>\n<p>这是一部数学史诗，也是人类智慧最伟大的故事之一。</p>\n","categories":[{"name":"读书电影","slug":"movie","api":"api/categories/movie.json"}],"tags":[{"name":"数学","slug":"数学","api":"api/tags/数学.json"}],"api":"api/posts/2020/06/09/《费马大定理》.json"}],"info":{"type":"archive","year":2020,"month":6}},"api":"api/archives/2020/06/page.1.json"}