{"data":{"index":1,"total":1,"posts":[{"title":"《美丽的数学》-有趣的数学","slug":"《美丽的数学》-有趣的数学","date":"2020-07-25T15:07:00.000Z","updated":"2025-05-20T11:46:57.000Z","comments":true,"url":"2020/07/25/《美丽的数学》-有趣的数学/","excerpt":"<p>数学有趣而美妙。书名《美丽的数学》，封面设计得非常的棒，简单优美的线条组合组成了这一蜗牛壳形状，让我们还没有翻开书就已经看到了数学的美丽。这本书看的时间不太长，因为有很多内容已经比较熟悉了，比如斐波那契数列、费马、概率相关。不过更很多内容，让人很着迷。</p>\n<h4 id=\"一个奇迹般的等式\"><a href=\"#一个奇迹般的等式\" class=\"headerlink\" title=\"一个奇迹般的等式\"></a>一个奇迹般的等式</h4><p>我们都知道数学中有这样几个数字：<br>$$<br>\\pi  \\ \\ \\ e  \\ \\  i<br>$$<br>但你可知道他们之间也有一个等式关系：<br>$$<br>e^{i\\pi} + 1 &#x3D; 0<br>$$<br>这个方程真的很震撼，有一种得到“统一”的感觉，就像麦克斯韦<a href=\"https://baike.baidu.com/item/%E7%94%B5%E7%A3%81%E7%90%86%E8%AE%BA\">电磁理论</a>建立以后，光学也变成了电磁学的一个分支了，电学、磁学和光学得到了统一。看似没有关联的数字，但他们之间存在着这样的联系，就这一个简单的公式就能把数学中最常用的五个数学符号给统一起来了，不得不服气。</p>\n<h4 id=\"阶乘\"><a href=\"#阶乘\" class=\"headerlink\" title=\"阶乘\"></a>阶乘</h4><p>阶乘我们都很熟悉，也都知道该怎么去计算阶乘，公式很简单：<br>$$<br>N!&#x3D;1×2×3×…×(N-1)×N<br>$$<br>如果我们想计算1000！的阶乘呢？对于程序员来说，总是想到用代码去实习，代码大致这样：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">factorial</span><span class=\"params\">(<span class=\"type\">int</span> n)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">1</span>; i &lt;= n; i++) &#123;</span><br><span class=\"line\">        j *= i;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">   <span class=\"keyword\">return</span> j;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>但是对于1000！这样一个很大数，最终得到的结果是很大的，对于这样的代码的话，int绝对已经满足不了了，哪怕是long,long long int,但是暂且不考虑数据类型的容量。计算机在计算的时候，过程中会进行大量的运算，消耗了大量的性能，但我们最终只是需要一个结果值，而过程中的数据就变得不那么重要了，那么有没有简单的计算方式呢？当然有！又是一个神奇的公式：<br>$$<br>N!\\approx \\sqrt{2\\pi N} ( \\frac N　e)^N<br>$$<br>代码变成：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">ans=(<span class=\"type\">int</span>)(log10((<span class=\"number\">2</span>*PI*n))/<span class=\"number\">2</span>+n*log10((n/e))+<span class=\"number\">1</span>);</span><br></pre></td></tr></table></figure>\n\n<p>这样的代码相对而言计算的性能会小很多，虽然公式只是取到一个近似值，误差值在N越大的时候误差越小，在N&#x3D;1000的时候与真实数据的误差已经小于0.01%了，这对于进行大数据很有帮助。</p>\n<h5 id=\"对于0的阶乘等于1的疑问\"><a href=\"#对于0的阶乘等于1的疑问\" class=\"headerlink\" title=\"对于0的阶乘等于1的疑问\"></a>对于0的阶乘等于1的疑问</h5><p>书中关于0的阶乘的证明有个疑问，通过公式:<br>$$<br>N!&#x3D;N*(N-1)!<br>$$<br>N为自然数大于等于0</p>\n<p>因为1！&#x3D;1，根据公式有:<br>$$<br>1!&#x3D;1*0!<br>$$<br>推出0！&#x3D;1，这样看似乎没有问题</p>\n<p>然而将N&#x3D;0再带入公式:<br>$$<br>0!&#x3D; 0*(-1)!<br>$$<br>左边等于1，右边由于0乘以任何数都为0的情况下那么右边为0,左右则矛盾冲突了，那么利用N!&#x3D;N*(N-1)!来推导0！就有一定的局限性。</p>\n<h4 id=\"非传递性骰子\"><a href=\"#非传递性骰子\" class=\"headerlink\" title=\"非传递性骰子\"></a>非传递性骰子</h4><p>对于上面的内容的话，都是一些比较纯数学公式的，但这一节的内容好像与我们的生活有那么一些关系的，说实话这一节真的有点出人意料的，让我有一种怀疑人生的感觉。现在有三颗骰子A B C，每颗骰子上面的数字并不是 1 2 3 4 5 6，而是一些特定的数字比如我们定义这样三个骰子，有六面，每一面有不同的数字，三个骰子的数字都不一样，如下图</p>\n<table>\n<thead>\n<tr>\n<th>骰子</th>\n<th>一</th>\n<th>二</th>\n<th>三</th>\n<th>四</th>\n<th>五</th>\n<th>六</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>A</td>\n<td>2</td>\n<td>3</td>\n<td>4</td>\n<td>12</td>\n<td>16</td>\n<td>17</td>\n</tr>\n<tr>\n<td>B</td>\n<td>5</td>\n<td>6</td>\n<td>7</td>\n<td>8</td>\n<td>9</td>\n<td>18</td>\n</tr>\n<tr>\n<td>C</td>\n<td>1</td>\n<td>10</td>\n<td>12</td>\n<td>13</td>\n<td>14</td>\n<td>15</td>\n</tr>\n</tbody></table>\n<p>如果让你选这三个骰子中的一个去参与“赌博”，你会选哪一个呢？对于A骰子和B骰子，通过列表格我们可以知道：</p>\n<table>\n<thead>\n<tr>\n<th></th>\n<th>2</th>\n<th>3</th>\n<th>4</th>\n<th>12</th>\n<th>16</th>\n<th>17</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>5</td>\n<td>B</td>\n<td>B</td>\n<td>B</td>\n<td>A</td>\n<td>A</td>\n<td>A</td>\n</tr>\n<tr>\n<td>6</td>\n<td>B</td>\n<td>B</td>\n<td>B</td>\n<td>A</td>\n<td>A</td>\n<td>A</td>\n</tr>\n<tr>\n<td>7</td>\n<td>B</td>\n<td>B</td>\n<td>B</td>\n<td>A</td>\n<td>A</td>\n<td>A</td>\n</tr>\n<tr>\n<td>8</td>\n<td>B</td>\n<td>B</td>\n<td>B</td>\n<td>A</td>\n<td>A</td>\n<td>A</td>\n</tr>\n<tr>\n<td>9</td>\n<td>B</td>\n<td>B</td>\n<td>B</td>\n<td>A</td>\n<td>A</td>\n<td>A</td>\n</tr>\n<tr>\n<td>18</td>\n<td>B</td>\n<td>B</td>\n<td>B</td>\n<td>B</td>\n<td>B</td>\n<td>B</td>\n</tr>\n</tbody></table>\n<p>可以知道A获胜的概率也就是 15&#x2F;36 约等于 42%，B赢的概率会是：58%。 那么你肯定会选择B，因为它赢的概率会大一点。我们用相同的手段处理骰子B和C得到的的数据：B赢的概率是 11&#x2F;36 约等于 31%，C赢的概率是25&#x2F;36约等于 百分之69。那么你肯定会选择骰子C。</p>\n<p>好像在这样的三个骰子里面，A“最差”，C“最好”，然而对于A和C，C赢的概率真的会高一些么？！如果你继续通过上面列表格的方式你会发现，A和C比较的话，A赢的概率是 21&#x2F;36约等于 58%，C赢的概率是15&#x2F;36约等于42%。</p>\n<p>相信你如果不是有对概率论有学习过的话，一上来肯定是不相信的，然而事实就是这样的。这是因为A与B、B与C、A与C相互之间的比较产生的<strong>基本事件空间</strong>是不一样的，比如A和B比较是(2,5)(2,6)等36个基本事件，A和C又是另外36个基本事件，所以这个概率大小也不具有传递性。</p>\n<h5 id=\"最后\"><a href=\"#最后\" class=\"headerlink\" title=\"最后\"></a>最后</h5><p>对于这本书，我本以为会介绍这个的方程：<br>$$<br>r &#x3D;a( 1 - sin θ)<br>$$<br>因为这个方程有一个美丽的图形，而方程背后又有一个美丽的故事，感觉内容太适合这本书了，不知道为什么没有加入进去。</p>\n<p>总之这本书大部分内容都是初等数学相关的知识，看起来并不是特别的费劲，但是很多平常有经常用过的数或者公式都有其深深的内涵所在，当你对其中的原理证明进行了相关的了解之后，你会发出感叹，原来数学是如此的有趣美丽。</p>\n","cover":null,"images":[],"content":"<p>数学有趣而美妙。书名《美丽的数学》，封面设计得非常的棒，简单优美的线条组合组成了这一蜗牛壳形状，让我们还没有翻开书就已经看到了数学的美丽。这本书看的时间不太长，因为有很多内容已经比较熟悉了，比如斐波那契数列、费马、概率相关。不过更很多内容，让人很着迷。</p>\n<h4 id=\"一个奇迹般的等式\"><a href=\"#一个奇迹般的等式\" class=\"headerlink\" title=\"一个奇迹般的等式\"></a>一个奇迹般的等式</h4><p>我们都知道数学中有这样几个数字：<br>$$<br>\\pi  \\ \\ \\ e  \\ \\  i<br>$$<br>但你可知道他们之间也有一个等式关系：<br>$$<br>e^{i\\pi} + 1 &#x3D; 0<br>$$<br>这个方程真的很震撼，有一种得到“统一”的感觉，就像麦克斯韦<a href=\"https://baike.baidu.com/item/%E7%94%B5%E7%A3%81%E7%90%86%E8%AE%BA\">电磁理论</a>建立以后，光学也变成了电磁学的一个分支了，电学、磁学和光学得到了统一。看似没有关联的数字，但他们之间存在着这样的联系，就这一个简单的公式就能把数学中最常用的五个数学符号给统一起来了，不得不服气。</p>\n<h4 id=\"阶乘\"><a href=\"#阶乘\" class=\"headerlink\" title=\"阶乘\"></a>阶乘</h4><p>阶乘我们都很熟悉，也都知道该怎么去计算阶乘，公式很简单：<br>$$<br>N!&#x3D;1×2×3×…×(N-1)×N<br>$$<br>如果我们想计算1000！的阶乘呢？对于程序员来说，总是想到用代码去实习，代码大致这样：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">factorial</span><span class=\"params\">(<span class=\"type\">int</span> n)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">1</span>; i &lt;= n; i++) &#123;</span><br><span class=\"line\">        j *= i;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">   <span class=\"keyword\">return</span> j;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>但是对于1000！这样一个很大数，最终得到的结果是很大的，对于这样的代码的话，int绝对已经满足不了了，哪怕是long,long long int,但是暂且不考虑数据类型的容量。计算机在计算的时候，过程中会进行大量的运算，消耗了大量的性能，但我们最终只是需要一个结果值，而过程中的数据就变得不那么重要了，那么有没有简单的计算方式呢？当然有！又是一个神奇的公式：<br>$$<br>N!\\approx \\sqrt{2\\pi N} ( \\frac N　e)^N<br>$$<br>代码变成：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">ans=(<span class=\"type\">int</span>)(log10((<span class=\"number\">2</span>*PI*n))/<span class=\"number\">2</span>+n*log10((n/e))+<span class=\"number\">1</span>);</span><br></pre></td></tr></table></figure>\n\n<p>这样的代码相对而言计算的性能会小很多，虽然公式只是取到一个近似值，误差值在N越大的时候误差越小，在N&#x3D;1000的时候与真实数据的误差已经小于0.01%了，这对于进行大数据很有帮助。</p>\n<h5 id=\"对于0的阶乘等于1的疑问\"><a href=\"#对于0的阶乘等于1的疑问\" class=\"headerlink\" title=\"对于0的阶乘等于1的疑问\"></a>对于0的阶乘等于1的疑问</h5><p>书中关于0的阶乘的证明有个疑问，通过公式:<br>$$<br>N!&#x3D;N*(N-1)!<br>$$<br>N为自然数大于等于0</p>\n<p>因为1！&#x3D;1，根据公式有:<br>$$<br>1!&#x3D;1*0!<br>$$<br>推出0！&#x3D;1，这样看似乎没有问题</p>\n<p>然而将N&#x3D;0再带入公式:<br>$$<br>0!&#x3D; 0*(-1)!<br>$$<br>左边等于1，右边由于0乘以任何数都为0的情况下那么右边为0,左右则矛盾冲突了，那么利用N!&#x3D;N*(N-1)!来推导0！就有一定的局限性。</p>\n<h4 id=\"非传递性骰子\"><a href=\"#非传递性骰子\" class=\"headerlink\" title=\"非传递性骰子\"></a>非传递性骰子</h4><p>对于上面的内容的话，都是一些比较纯数学公式的，但这一节的内容好像与我们的生活有那么一些关系的，说实话这一节真的有点出人意料的，让我有一种怀疑人生的感觉。现在有三颗骰子A B C，每颗骰子上面的数字并不是 1 2 3 4 5 6，而是一些特定的数字比如我们定义这样三个骰子，有六面，每一面有不同的数字，三个骰子的数字都不一样，如下图</p>\n<table>\n<thead>\n<tr>\n<th>骰子</th>\n<th>一</th>\n<th>二</th>\n<th>三</th>\n<th>四</th>\n<th>五</th>\n<th>六</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>A</td>\n<td>2</td>\n<td>3</td>\n<td>4</td>\n<td>12</td>\n<td>16</td>\n<td>17</td>\n</tr>\n<tr>\n<td>B</td>\n<td>5</td>\n<td>6</td>\n<td>7</td>\n<td>8</td>\n<td>9</td>\n<td>18</td>\n</tr>\n<tr>\n<td>C</td>\n<td>1</td>\n<td>10</td>\n<td>12</td>\n<td>13</td>\n<td>14</td>\n<td>15</td>\n</tr>\n</tbody></table>\n<p>如果让你选这三个骰子中的一个去参与“赌博”，你会选哪一个呢？对于A骰子和B骰子，通过列表格我们可以知道：</p>\n<table>\n<thead>\n<tr>\n<th></th>\n<th>2</th>\n<th>3</th>\n<th>4</th>\n<th>12</th>\n<th>16</th>\n<th>17</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>5</td>\n<td>B</td>\n<td>B</td>\n<td>B</td>\n<td>A</td>\n<td>A</td>\n<td>A</td>\n</tr>\n<tr>\n<td>6</td>\n<td>B</td>\n<td>B</td>\n<td>B</td>\n<td>A</td>\n<td>A</td>\n<td>A</td>\n</tr>\n<tr>\n<td>7</td>\n<td>B</td>\n<td>B</td>\n<td>B</td>\n<td>A</td>\n<td>A</td>\n<td>A</td>\n</tr>\n<tr>\n<td>8</td>\n<td>B</td>\n<td>B</td>\n<td>B</td>\n<td>A</td>\n<td>A</td>\n<td>A</td>\n</tr>\n<tr>\n<td>9</td>\n<td>B</td>\n<td>B</td>\n<td>B</td>\n<td>A</td>\n<td>A</td>\n<td>A</td>\n</tr>\n<tr>\n<td>18</td>\n<td>B</td>\n<td>B</td>\n<td>B</td>\n<td>B</td>\n<td>B</td>\n<td>B</td>\n</tr>\n</tbody></table>\n<p>可以知道A获胜的概率也就是 15&#x2F;36 约等于 42%，B赢的概率会是：58%。 那么你肯定会选择B，因为它赢的概率会大一点。我们用相同的手段处理骰子B和C得到的的数据：B赢的概率是 11&#x2F;36 约等于 31%，C赢的概率是25&#x2F;36约等于 百分之69。那么你肯定会选择骰子C。</p>\n<p>好像在这样的三个骰子里面，A“最差”，C“最好”，然而对于A和C，C赢的概率真的会高一些么？！如果你继续通过上面列表格的方式你会发现，A和C比较的话，A赢的概率是 21&#x2F;36约等于 58%，C赢的概率是15&#x2F;36约等于42%。</p>\n<p>相信你如果不是有对概率论有学习过的话，一上来肯定是不相信的，然而事实就是这样的。这是因为A与B、B与C、A与C相互之间的比较产生的<strong>基本事件空间</strong>是不一样的，比如A和B比较是(2,5)(2,6)等36个基本事件，A和C又是另外36个基本事件，所以这个概率大小也不具有传递性。</p>\n<h5 id=\"最后\"><a href=\"#最后\" class=\"headerlink\" title=\"最后\"></a>最后</h5><p>对于这本书，我本以为会介绍这个的方程：<br>$$<br>r &#x3D;a( 1 - sin θ)<br>$$<br>因为这个方程有一个美丽的图形，而方程背后又有一个美丽的故事，感觉内容太适合这本书了，不知道为什么没有加入进去。</p>\n<p>总之这本书大部分内容都是初等数学相关的知识，看起来并不是特别的费劲，但是很多平常有经常用过的数或者公式都有其深深的内涵所在，当你对其中的原理证明进行了相关的了解之后，你会发出感叹，原来数学是如此的有趣美丽。</p>\n","categories":[{"name":"读书电影","slug":"movie","api":"api/categories/movie.json"}],"tags":[{"name":"数学","slug":"数学","api":"api/tags/数学.json"}],"api":"api/posts/2020/07/25/《美丽的数学》-有趣的数学.json"},{"title":"基于AndroidVideoCache的预加载","slug":"基于AndroidVideoCache的预加载","date":"2020-07-06T11:09:00.000Z","updated":"2025-09-15T13:07:12.918Z","comments":true,"url":"2020/07/06/基于AndroidVideoCache的预加载/","excerpt":"<p>最近有做需求关于视频缓存，了解到相关的开源库<a href=\"https://www.jianshu.com/p/dfc18278b053\">AndroidVideoCache</a>，\b一款市面上相对比较流行的视频缓存框架，而我想利用该框架进行视频缓存的处理，并且希望能够支持预加载。然而该框架作者在18年就已经停止了维护，所以留下了无限的编程空间给其他程序员，对于视频预加载，只搜到一篇<a href=\"https://www.jianshu.com/p/dfc18278b053\">《AndroidVideoCache源码详解以及改造系列-源码篇》</a>，然而点进该作者的博客列表，说好的预加载呢？？？后面也没有了下文，搜遍全网好像没有做AndroidVideoCache的预加载相关的事情，那么这样子的话……自己干吧。</p>\n<p>首先需要明白AndroidVideoCache的实现原理，推荐查看<a href=\"https://www.jianshu.com/p/4745de02dcdc\">《AndroidVideoCache-视频边播放边缓存的代理策略》</a>这里不再赘述。</p>\n<p>其实预加载的思路很简单，在进行一个播放视频后，再返回接下来需要预加载的视频url，启用后台线程去请求下载数据，不过中间涉及的细节逻辑比较多。</p>\n<h2 id=\"一、实现方案\"><a href=\"#一、实现方案\" class=\"headerlink\" title=\"一、实现方案\"></a>一、实现方案</h2><p>主要逻辑为：</p>\n<p>1、后台开启一个线程去请求并预加载一部分的数据</p>\n<p>2、可能需要预加载的数据大于&gt;1，利用队列先进入的先进行加载，加上前面的条件 使用HandlerThread再适合不过了。</p>\n<p>我们首先定义好需要去处理的任务情况：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">preload</span><span class=\"params\">( String method，Call call)</span> &#123;</span><br><span class=\"line\">       <span class=\"keyword\">switch</span> (method) &#123;</span><br><span class=\"line\">           <span class=\"keyword\">case</span> <span class=\"string\">&quot;addPreloadURL&quot;</span>:</span><br><span class=\"line\">               addPreloadURL(call); <span class=\"comment\">//添加url到预加载队列</span></span><br><span class=\"line\">               <span class=\"keyword\">break</span>;</span><br><span class=\"line\">           <span class=\"keyword\">case</span> <span class=\"string\">&quot;cancelPreloadURLIfNeeded&quot;</span>:</span><br><span class=\"line\">               cancelPreloadURLIfNeeded(call); <span class=\"comment\">//取消对应的url预加载（因为可能是立马需要播放这个视频，那么就不需要预加载了）</span></span><br><span class=\"line\">               <span class=\"keyword\">break</span>;</span><br><span class=\"line\">           <span class=\"keyword\">case</span> <span class=\"string\">&quot;cancelAnyPreloads&quot;</span>: </span><br><span class=\"line\">               cancelAnyPreLoads();<span class=\"comment\">//取消所有的预加载，主要是方便管理任务</span></span><br><span class=\"line\">               <span class=\"keyword\">break</span>;</span><br><span class=\"line\">           <span class=\"keyword\">default</span>:</span><br><span class=\"line\">           </span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n\n<p>那么对于每次的预加载逻辑基本上是这样的方法执行顺序：</p>\n<p> cancelPreloadURLIfNeeded()-&gt;addPreloadURL();   &#x2F;&#x2F;取消对应url加载的任务，因为有可能该url不需要再进行预加载了（参考抖音，当用户瞬间下滑几个视频，那么很多视频就需要跳过了不需要再进行预加载）</p>\n<p> cancelAnyPreLoads()-&gt;addPreloadURL();   &#x2F;&#x2F;取消对应url加载的任务（这时候需要立马播放最新的视频，那么就应该让出网速给该视频），之后再添加新一轮的预加载url。</p>\n<p>接下来具体的处理逻辑VideoPreLoader类，我直接放上所有的代码逻辑吧,为方便观察删除了一部分不太重要的逻辑，其实总体流程也比较简单。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">VideoPreLoader</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> Handler handler;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> HandlerThread handlerThread;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> List&lt;String&gt; cancelList = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"title function_\">VideoPreLoader</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    handlerThread = <span class=\"keyword\">new</span> <span class=\"title class_\">HandlerThread</span>(<span class=\"string\">&quot;VideoPreLoaderThread&quot;</span>);</span><br><span class=\"line\">    handlerThread.start();</span><br><span class=\"line\">    handler = <span class=\"keyword\">new</span> <span class=\"title class_\">Handler</span>(handlerThread.getLooper()) &#123;</span><br><span class=\"line\">      <span class=\"meta\">@Override</span></span><br><span class=\"line\">      <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">handleMessage</span><span class=\"params\">(Message msg)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">super</span>.handleMessage(msg);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">void</span> <span class=\"title function_\">addPreloadURL</span><span class=\"params\">(<span class=\"keyword\">final</span> VideoPreLoadModel data)</span> &#123;</span><br><span class=\"line\">    handler.post(<span class=\"keyword\">new</span> <span class=\"title class_\">Runnable</span>() &#123;</span><br><span class=\"line\">      <span class=\"meta\">@Override</span></span><br><span class=\"line\">      <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        realPreload(data);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">void</span> <span class=\"title function_\">cancelPreloadURLIfNeeded</span><span class=\"params\">(String url)</span> &#123;</span><br><span class=\"line\">    cancelList.add(url);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">void</span> <span class=\"title function_\">cancelAnyPreLoads</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    handler.removeCallbacksAndMessages(<span class=\"literal\">null</span>);</span><br><span class=\"line\">    cancelList.clear();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">realPreload</span><span class=\"params\">(VideoPreLoadModel data)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (data == <span class=\"literal\">null</span> || isCancel(data.originalUrl)) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"type\">HttpURLConnection</span> <span class=\"variable\">conn</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">      <span class=\"type\">URL</span> <span class=\"variable\">myURL</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">URL</span>(data.proxyUrl);</span><br><span class=\"line\">      conn = (HttpURLConnection) myURL.openConnection();</span><br><span class=\"line\">      conn.connect();</span><br><span class=\"line\">      <span class=\"type\">InputStream</span> <span class=\"variable\">is</span> <span class=\"operator\">=</span> conn.getInputStream();</span><br><span class=\"line\">      <span class=\"type\">byte</span>[] buf = <span class=\"keyword\">new</span> <span class=\"title class_\">byte</span>[<span class=\"number\">1024</span>];</span><br><span class=\"line\">      <span class=\"type\">int</span> <span class=\"variable\">downLoadedSize</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">      <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">numRead</span> <span class=\"operator\">=</span> is.read(buf);</span><br><span class=\"line\">        downLoadedSize += numRead;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (downLoadedSize &gt;= data.preLoadBytes || numRead == -<span class=\"number\">1</span>) &#123; <span class=\"comment\">//Reached  preload range or end of Input stream.</span></span><br><span class=\"line\">          <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125; <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>);</span><br><span class=\"line\">      is.close();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ....</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"type\">boolean</span> <span class=\"title function_\">isCancel</span><span class=\"params\">(String url)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (TextUtils.isEmpty(url)) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (String cancelUrl : cancelList) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (cancelUrl.equals(url)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>对于这段代码中其实有“两个”队列，一个是HandlerThread中的队列，熟悉消息机制的同学应该都能明白，内部是一个looper在不断地循环获取消息，当一个消息处理完毕之后才会处理下一个消息。我还定义了一个就是取消队列，因为HandlerThread中的任务我们不太好控制取消具体的任务，所以设置了一个取消队列，当之后的消息再需要执行的时候会首先判断是否是在取消队列里面，这样子就能做到对预加载队列逻辑的控制。</p>\n<h2 id=\"二、关于一些细节问题\"><a href=\"#二、关于一些细节问题\" class=\"headerlink\" title=\"二、关于一些细节问题\"></a>二、关于一些细节问题</h2><p>这样子我们在播放一个视频的时候，只需要传给我们接下来将会播放的视频的URL，我们就能对其预加载并缓存下来，但是会存在其他条件：</p>\n<h5 id=\"预加载的长度？\"><a href=\"#预加载的长度？\" class=\"headerlink\" title=\"预加载的长度？\"></a>预加载的长度？</h5><p>对于视频加载长度，我们很容易想到在视频url请求加入Range在header上面，比如</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">conn.addRequestProperty(<span class=\"string\">&quot;Range&quot;</span>, <span class=\"string\">&quot;0-102400&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n<p>我们只获取前102400 bytes，不用将整个视频全部进行预加载，我有进行这样的尝试，但是实际发现是有坑的。我做了很多尝试，发现不论怎么请求，拿到的 responseCode 虽然是206，但是 还是把数据给全部下载完了，这就有点不科学了！！</p>\n<p>最终去源码中才发现：源码有对range做正则匹配</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">Pattern</span> <span class=\"variable\">RANGE_HEADER_PATTERN</span> <span class=\"operator\">=</span> Pattern.compile(<span class=\"string\">&quot;[R,r]ange:[ ]?bytes=(\\\\d*)-&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"type\">long</span> <span class=\"title function_\">findRangeOffset</span><span class=\"params\">(String request)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">Matcher</span> <span class=\"variable\">matcher</span> <span class=\"operator\">=</span> RANGE_HEADER_PATTERN.matcher(request);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (matcher.find()) &#123;</span><br><span class=\"line\">            <span class=\"type\">String</span> <span class=\"variable\">rangeValue</span> <span class=\"operator\">=</span> matcher.group(<span class=\"number\">1</span>);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> Long.parseLong(rangeValue);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>看清楚了 <strong><em>“[R,r]ange:[ ]?bytes&#x3D;(\\d</em>)-“</strong>* 它只去匹配了前面的的，也就是说 我传入了 0-102400 它最终只当作是：Range：0- 来处理，导致addRequestProperty设置的range实现。坑！不过能理解作者为什么这么做，后面总结会讲到。没有办法只有使用最原始的方法进行判断了：在每次获取inputStream的时候进行判断是否达到预加载的大小，虽然有一定的性能开销，但是不去改源码的话也没有 办法了。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">      <span class=\"type\">int</span> <span class=\"variable\">numRead</span> <span class=\"operator\">=</span> is.read(buf);</span><br><span class=\"line\">      downLoadedSize += numRead;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (downLoadedSize &gt;= data.preLoadBytes || numRead == -<span class=\"number\">1</span>) &#123; <span class=\"comment\">//Reached  preload range or end of Input stream.</span></span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>);</span><br><span class=\"line\">    is.close();</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"三、总结\"><a href=\"#三、总结\" class=\"headerlink\" title=\"三、总结\"></a>三、总结</h2><p>本文主要讲了基于AndroidVideoCache的预加载具体实现原理，以及其中遇到的坑</p>\n<p>1、预加载主要通过HandlerThread去实现后台网络的访问以及缓存的处理逻辑</p>\n<p>2、加入取消队列去控制对应需要取消的任务</p>\n<p>3、对于预加载的size只能通过读取的时候进行判断，没有办法使用range去判断。其实很容易理解作者为什么正则要这样写，因为它只是一个视频缓存框架，主要是用来做“边播边存”，所以每次去进行请求的时候应该都是在原有的缓存之上去进行缓存数据处理，而缓存最终需要处理完的就是 content-size，不需要再去管Range中的结束范围了。</p>\n","cover":null,"images":[],"content":"<p>最近有做需求关于视频缓存，了解到相关的开源库<a href=\"https://www.jianshu.com/p/dfc18278b053\">AndroidVideoCache</a>，\b一款市面上相对比较流行的视频缓存框架，而我想利用该框架进行视频缓存的处理，并且希望能够支持预加载。然而该框架作者在18年就已经停止了维护，所以留下了无限的编程空间给其他程序员，对于视频预加载，只搜到一篇<a href=\"https://www.jianshu.com/p/dfc18278b053\">《AndroidVideoCache源码详解以及改造系列-源码篇》</a>，然而点进该作者的博客列表，说好的预加载呢？？？后面也没有了下文，搜遍全网好像没有做AndroidVideoCache的预加载相关的事情，那么这样子的话……自己干吧。</p>\n<p>首先需要明白AndroidVideoCache的实现原理，推荐查看<a href=\"https://www.jianshu.com/p/4745de02dcdc\">《AndroidVideoCache-视频边播放边缓存的代理策略》</a>这里不再赘述。</p>\n<p>其实预加载的思路很简单，在进行一个播放视频后，再返回接下来需要预加载的视频url，启用后台线程去请求下载数据，不过中间涉及的细节逻辑比较多。</p>\n<h2 id=\"一、实现方案\"><a href=\"#一、实现方案\" class=\"headerlink\" title=\"一、实现方案\"></a>一、实现方案</h2><p>主要逻辑为：</p>\n<p>1、后台开启一个线程去请求并预加载一部分的数据</p>\n<p>2、可能需要预加载的数据大于&gt;1，利用队列先进入的先进行加载，加上前面的条件 使用HandlerThread再适合不过了。</p>\n<p>我们首先定义好需要去处理的任务情况：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">preload</span><span class=\"params\">( String method，Call call)</span> &#123;</span><br><span class=\"line\">       <span class=\"keyword\">switch</span> (method) &#123;</span><br><span class=\"line\">           <span class=\"keyword\">case</span> <span class=\"string\">&quot;addPreloadURL&quot;</span>:</span><br><span class=\"line\">               addPreloadURL(call); <span class=\"comment\">//添加url到预加载队列</span></span><br><span class=\"line\">               <span class=\"keyword\">break</span>;</span><br><span class=\"line\">           <span class=\"keyword\">case</span> <span class=\"string\">&quot;cancelPreloadURLIfNeeded&quot;</span>:</span><br><span class=\"line\">               cancelPreloadURLIfNeeded(call); <span class=\"comment\">//取消对应的url预加载（因为可能是立马需要播放这个视频，那么就不需要预加载了）</span></span><br><span class=\"line\">               <span class=\"keyword\">break</span>;</span><br><span class=\"line\">           <span class=\"keyword\">case</span> <span class=\"string\">&quot;cancelAnyPreloads&quot;</span>: </span><br><span class=\"line\">               cancelAnyPreLoads();<span class=\"comment\">//取消所有的预加载，主要是方便管理任务</span></span><br><span class=\"line\">               <span class=\"keyword\">break</span>;</span><br><span class=\"line\">           <span class=\"keyword\">default</span>:</span><br><span class=\"line\">           </span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n\n<p>那么对于每次的预加载逻辑基本上是这样的方法执行顺序：</p>\n<p> cancelPreloadURLIfNeeded()-&gt;addPreloadURL();   &#x2F;&#x2F;取消对应url加载的任务，因为有可能该url不需要再进行预加载了（参考抖音，当用户瞬间下滑几个视频，那么很多视频就需要跳过了不需要再进行预加载）</p>\n<p> cancelAnyPreLoads()-&gt;addPreloadURL();   &#x2F;&#x2F;取消对应url加载的任务（这时候需要立马播放最新的视频，那么就应该让出网速给该视频），之后再添加新一轮的预加载url。</p>\n<p>接下来具体的处理逻辑VideoPreLoader类，我直接放上所有的代码逻辑吧,为方便观察删除了一部分不太重要的逻辑，其实总体流程也比较简单。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">VideoPreLoader</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> Handler handler;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> HandlerThread handlerThread;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> List&lt;String&gt; cancelList = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"title function_\">VideoPreLoader</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    handlerThread = <span class=\"keyword\">new</span> <span class=\"title class_\">HandlerThread</span>(<span class=\"string\">&quot;VideoPreLoaderThread&quot;</span>);</span><br><span class=\"line\">    handlerThread.start();</span><br><span class=\"line\">    handler = <span class=\"keyword\">new</span> <span class=\"title class_\">Handler</span>(handlerThread.getLooper()) &#123;</span><br><span class=\"line\">      <span class=\"meta\">@Override</span></span><br><span class=\"line\">      <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">handleMessage</span><span class=\"params\">(Message msg)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">super</span>.handleMessage(msg);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">void</span> <span class=\"title function_\">addPreloadURL</span><span class=\"params\">(<span class=\"keyword\">final</span> VideoPreLoadModel data)</span> &#123;</span><br><span class=\"line\">    handler.post(<span class=\"keyword\">new</span> <span class=\"title class_\">Runnable</span>() &#123;</span><br><span class=\"line\">      <span class=\"meta\">@Override</span></span><br><span class=\"line\">      <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        realPreload(data);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">void</span> <span class=\"title function_\">cancelPreloadURLIfNeeded</span><span class=\"params\">(String url)</span> &#123;</span><br><span class=\"line\">    cancelList.add(url);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">void</span> <span class=\"title function_\">cancelAnyPreLoads</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    handler.removeCallbacksAndMessages(<span class=\"literal\">null</span>);</span><br><span class=\"line\">    cancelList.clear();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">realPreload</span><span class=\"params\">(VideoPreLoadModel data)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (data == <span class=\"literal\">null</span> || isCancel(data.originalUrl)) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"type\">HttpURLConnection</span> <span class=\"variable\">conn</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">      <span class=\"type\">URL</span> <span class=\"variable\">myURL</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">URL</span>(data.proxyUrl);</span><br><span class=\"line\">      conn = (HttpURLConnection) myURL.openConnection();</span><br><span class=\"line\">      conn.connect();</span><br><span class=\"line\">      <span class=\"type\">InputStream</span> <span class=\"variable\">is</span> <span class=\"operator\">=</span> conn.getInputStream();</span><br><span class=\"line\">      <span class=\"type\">byte</span>[] buf = <span class=\"keyword\">new</span> <span class=\"title class_\">byte</span>[<span class=\"number\">1024</span>];</span><br><span class=\"line\">      <span class=\"type\">int</span> <span class=\"variable\">downLoadedSize</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">      <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">numRead</span> <span class=\"operator\">=</span> is.read(buf);</span><br><span class=\"line\">        downLoadedSize += numRead;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (downLoadedSize &gt;= data.preLoadBytes || numRead == -<span class=\"number\">1</span>) &#123; <span class=\"comment\">//Reached  preload range or end of Input stream.</span></span><br><span class=\"line\">          <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125; <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>);</span><br><span class=\"line\">      is.close();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ....</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"type\">boolean</span> <span class=\"title function_\">isCancel</span><span class=\"params\">(String url)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (TextUtils.isEmpty(url)) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (String cancelUrl : cancelList) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (cancelUrl.equals(url)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>对于这段代码中其实有“两个”队列，一个是HandlerThread中的队列，熟悉消息机制的同学应该都能明白，内部是一个looper在不断地循环获取消息，当一个消息处理完毕之后才会处理下一个消息。我还定义了一个就是取消队列，因为HandlerThread中的任务我们不太好控制取消具体的任务，所以设置了一个取消队列，当之后的消息再需要执行的时候会首先判断是否是在取消队列里面，这样子就能做到对预加载队列逻辑的控制。</p>\n<h2 id=\"二、关于一些细节问题\"><a href=\"#二、关于一些细节问题\" class=\"headerlink\" title=\"二、关于一些细节问题\"></a>二、关于一些细节问题</h2><p>这样子我们在播放一个视频的时候，只需要传给我们接下来将会播放的视频的URL，我们就能对其预加载并缓存下来，但是会存在其他条件：</p>\n<h5 id=\"预加载的长度？\"><a href=\"#预加载的长度？\" class=\"headerlink\" title=\"预加载的长度？\"></a>预加载的长度？</h5><p>对于视频加载长度，我们很容易想到在视频url请求加入Range在header上面，比如</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">conn.addRequestProperty(<span class=\"string\">&quot;Range&quot;</span>, <span class=\"string\">&quot;0-102400&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n<p>我们只获取前102400 bytes，不用将整个视频全部进行预加载，我有进行这样的尝试，但是实际发现是有坑的。我做了很多尝试，发现不论怎么请求，拿到的 responseCode 虽然是206，但是 还是把数据给全部下载完了，这就有点不科学了！！</p>\n<p>最终去源码中才发现：源码有对range做正则匹配</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">Pattern</span> <span class=\"variable\">RANGE_HEADER_PATTERN</span> <span class=\"operator\">=</span> Pattern.compile(<span class=\"string\">&quot;[R,r]ange:[ ]?bytes=(\\\\d*)-&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"type\">long</span> <span class=\"title function_\">findRangeOffset</span><span class=\"params\">(String request)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">Matcher</span> <span class=\"variable\">matcher</span> <span class=\"operator\">=</span> RANGE_HEADER_PATTERN.matcher(request);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (matcher.find()) &#123;</span><br><span class=\"line\">            <span class=\"type\">String</span> <span class=\"variable\">rangeValue</span> <span class=\"operator\">=</span> matcher.group(<span class=\"number\">1</span>);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> Long.parseLong(rangeValue);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>看清楚了 <strong><em>“[R,r]ange:[ ]?bytes&#x3D;(\\d</em>)-“</strong>* 它只去匹配了前面的的，也就是说 我传入了 0-102400 它最终只当作是：Range：0- 来处理，导致addRequestProperty设置的range实现。坑！不过能理解作者为什么这么做，后面总结会讲到。没有办法只有使用最原始的方法进行判断了：在每次获取inputStream的时候进行判断是否达到预加载的大小，虽然有一定的性能开销，但是不去改源码的话也没有 办法了。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">      <span class=\"type\">int</span> <span class=\"variable\">numRead</span> <span class=\"operator\">=</span> is.read(buf);</span><br><span class=\"line\">      downLoadedSize += numRead;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (downLoadedSize &gt;= data.preLoadBytes || numRead == -<span class=\"number\">1</span>) &#123; <span class=\"comment\">//Reached  preload range or end of Input stream.</span></span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>);</span><br><span class=\"line\">    is.close();</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"三、总结\"><a href=\"#三、总结\" class=\"headerlink\" title=\"三、总结\"></a>三、总结</h2><p>本文主要讲了基于AndroidVideoCache的预加载具体实现原理，以及其中遇到的坑</p>\n<p>1、预加载主要通过HandlerThread去实现后台网络的访问以及缓存的处理逻辑</p>\n<p>2、加入取消队列去控制对应需要取消的任务</p>\n<p>3、对于预加载的size只能通过读取的时候进行判断，没有办法使用range去判断。其实很容易理解作者为什么正则要这样写，因为它只是一个视频缓存框架，主要是用来做“边播边存”，所以每次去进行请求的时候应该都是在原有的缓存之上去进行缓存数据处理，而缓存最终需要处理完的就是 content-size，不需要再去管Range中的结束范围了。</p>\n","categories":[{"name":"技术文章","slug":"technology","api":"api/categories/technology.json"}],"tags":[{"name":"音视频","slug":"音视频","api":"api/tags/音视频.json"}],"api":"api/posts/2020/07/06/基于AndroidVideoCache的预加载.json"}],"info":{"type":"archive","year":2020,"month":7}},"api":"api/archives/2020/07/page.1.json"}