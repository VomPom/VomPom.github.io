{"data":{"index":1,"total":1,"posts":[{"title":"Flutter坑之共享FlutterEngine页面切换无法点击","slug":"Flutter坑之共享FlutterEngine页面切换无法点击","date":"2020-09-21T11:22:00.000Z","updated":"2025-05-20T11:46:57.000Z","comments":true,"url":"2020/09/21/Flutter坑之共享FlutterEngine页面切换无法点击/","excerpt":"<p>最近在研究做Flutter一块相关的内容，方案上采用的是单FlutterEngine，全局Flutter元素共用一个FlutterEngine，对于使用单Engine遇到一个很大的坑，页面切换之后无法点击，页面就像卡死了一样，以下三种情况都会发生：</p>\n<p>第一种：两个FlutterFragment在tab中进行切换，假如AB代表两个FlutterFragment，当A切换到B，再从B切换到A的时候，页面就无法点击。</p>\n<p>第二种：在FlutterActivity中打开新的FlutterActivity，新的FlutterActivity页面跟上述的情况一样，也是无法点击。</p>\n<p>第三种：在Tab中打开FlutterFragment之后再打开FlutterActivity，情况一样，依然无法点击。</p>\n<p>如下动图所示：</p>\n<img src=\"https://cdn.julis.wang/blog/img/20200921223629331.gif\">\n<p>（来自issue <a href=\"https://github.com/flutter/flutter/issues/49950）\">https://github.com/flutter/flutter/issues/49950）</a></p>\n<p>但他们有一个共同的特点：当页面卡死的时候，手动进入后台（打开任务管理或者home键退出）再回到前台，页面就会“刷新”，一切又变得正常了。那么推测：多半与跟页面Fragment和Activity的生命周期有关。我尝试了在进入页面后,再手动模拟“页面退出再回来的周期”，也就是先调用一次<code>onPause()</code>再调用一次<code>onResume()</code>，然而并没有什么卵用……</p>\n<img src=\"https://cdn.julis.wang/blog/img/20200921223648282.gif\">\n<p>可这是为什么呢？？太坑了……踏遍了千山万水也没有找到有人有解决方案，很多人都说别用共享引擎，但是想到 闲鱼Flutter_boost 和HelloBike的thrio框架也都是用的共享引擎啊，他们为什么没有问题？找了很久的解决方法，两天，甚至晚上做梦都梦在关于这个问题。真的是……难受。加了各种各样的群，也没有人能解答这个问题。终于……我去打印了两个Activity的生命周期，才发现事情的端倪。</p>\n<h3 id=\"关于Activity与Fragment的切换的生命周期\"><a href=\"#关于Activity与Fragment的切换的生命周期\" class=\"headerlink\" title=\"关于Activity与Fragment的切换的生命周期\"></a><strong>关于Activity与Fragment的切换的生命周期</strong></h3><p>这里向大家在简单介绍一下Activity和Fragment切换生命周期，相信大家都有被面试问过：现在有两个Activity A和B，在A打开B这一段时间Activity的生命周期变化情况：</p>\n<h6 id=\"A-onPause-gt-B-onCreate-gt-B-onStart-gt-B-onResume-gt-A-onStop\"><a href=\"#A-onPause-gt-B-onCreate-gt-B-onStart-gt-B-onResume-gt-A-onStop\" class=\"headerlink\" title=\"A.onPause() -&gt;B.onCreate()-&gt; B.onStart() -&gt;B.onResume() -&gt;A.onStop()\"></a>A.onPause() -&gt;B.onCreate()-&gt; B.onStart() -&gt;B.onResume() -&gt;A.onStop()</h6><p>A的onStop() 的调用情况分为两种：当设置Activity A的主题windowIsTranslucent属性为true，A Activity并不会调用onStop方法，只会调用onPause()方法。</p>\n<p>ok说完了Activity再说说Fragment，对于我们的问题：Fragment生命周期考虑tab间切换（也就是两个FlutterFragment之间的切换），两个Fragment的切换，并不会导致Fragment的onPause()和onStop()调用，只会调用<code>onHiddenChanged(boolean hidden)</code>，hiden为true表示该Fragment被隐藏了，false表示当前Fragment可见。</p>\n<h3 id=\"关于Flutter单Engine方案\"><a href=\"#关于Flutter单Engine方案\" class=\"headerlink\" title=\"关于Flutter单Engine方案\"></a><strong>关于Flutter单Engine方案</strong></h3><p>现在关于讲解Flutter单Engine方案也比较多，推荐去看这篇—&gt; <a href=\"https://zhuanlan.zhihu.com/p/38026271\">为追求高性能，我必须告诉你Flutter引擎线程的事实…</a> 关于对单Engine的讲解，单Engine方案，我们可以简单理解为：<strong>所有应用中的FlutterView都是由同一个FlutterEngine来渲染的。</strong>当然这看起来是废话，但这就是问题的关键，那么对于所有的FlutterView都是用的同一个FlutterEngine渲染，那么FlutterEngine是怎么去控制的呢？如果让你去设计，你会怎么设计呢？</p>\n<p>这篇博客—&gt;<a href=\"https://cloud.tencent.com/developer/article/1568737\">flutter单引擎方案</a>讲解了一种单Engine的实现方案，可以参考，不过其中也需要对Engine进行多次new，不过这并不是最重要的，我们需要明白的是：<strong>当FlutterEngine去渲染FlutterView B的时候，它需要attach再在B上，从FlutterView A detach掉，再返回FlutterView A的时候，它需要从FlutterView B上detach掉，再attach到A上。</strong></p>\n<h3 id=\"Flutter坑！\"><a href=\"#Flutter坑！\" class=\"headerlink\" title=\"Flutter坑！\"></a><strong>Flutter坑！</strong></h3><p>现在我们明白了生命周期的变化，我们接下来去看FlutterActivity中响应生命周期中的源码。对于FlutterActivity A打开FlutterActivity B，他们依次会调用：</p>\n<h6 id=\"A-onPause-gt-B-onCreate-gt-B-onStart-gt-B-onResume-gt-A-onStop-1\"><a href=\"#A-onPause-gt-B-onCreate-gt-B-onStart-gt-B-onResume-gt-A-onStop-1\" class=\"headerlink\" title=\"A.onPause() -&gt;B.onCreate()-&gt; B.onStart() -&gt;B.onResume() -&gt;A.onStop()\"></a>A.onPause() -&gt;B.onCreate()-&gt; B.onStart() -&gt;B.onResume() -&gt;A.onStop()</h6><p>我们来看看FlutterActivity在对应的生命周期里面做了什么,</p>\n<p>对于<strong>A.onPause()</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title function_\">onPause</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">super</span>.onPause();</span><br><span class=\"line\">  delegate.onPause();</span><br><span class=\"line\">  lifecycle.handleLifecycleEvent(Lifecycle.Event.ON_PAUSE);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们知道：FlutterActivity和Fragment主要由FlutterActivityAndFragmentDelegate来进行管理，这里我们主要关注delegate里面的内容</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> <span class=\"title function_\">onPause</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">  Log.v(TAG, <span class=\"string\">&quot;onPause()&quot;</span>);</span><br><span class=\"line\">  ensureAlive();</span><br><span class=\"line\">  flutterEngine.getLifecycleChannel().appIsInactive();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里是关键我们看到了flutterEngine与生命周期相关的代码，接下来我们看其他几个生命周期里面对于flutterEngine的Lifecycle管理情况</p>\n<p>对于<strong>B.onCreate()</strong>只进行了相关的view创建工作.</p>\n<p>对于<strong>B.onStart()</strong>中有执行<code>doInitialFlutterViewRun();</code>，其中比较关键的一句就是：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">if (host.getInitialRoute() != null) &#123;</span><br><span class=\"line\">  flutterEngine.getNavigationChannel().setInitialRoute(host.getInitialRoute());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>对于<strong>B.onResume()</strong> </p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> <span class=\"title function_\">onResume</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">  Log.v(TAG, <span class=\"string\">&quot;onResume()&quot;</span>);</span><br><span class=\"line\">  ensureAlive();</span><br><span class=\"line\">  flutterEngine.getLifecycleChannel().appIsResumed();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>最后是<strong>A.onStop()</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> <span class=\"title function_\">onStop</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">  Log.v(TAG, <span class=\"string\">&quot;onStop()&quot;</span>);</span><br><span class=\"line\">  ensureAlive();</span><br><span class=\"line\">  flutterEngine.getLifecycleChannel().appIsPaused();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>看到了A.onStop()，聪明的人应该都看出来问题了，我们重新整理一下从Activity A启动到B，flutterEngine相关的生命周期主要执行了以下流程：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">A.onPause() -&gt; flutterEngine.getLifecycleChannel().appIsInactive()</span><br><span class=\"line\"></span><br><span class=\"line\">B.onCreate()-&gt;  nothing.</span><br><span class=\"line\"></span><br><span class=\"line\">B.onStart() -&gt; flutterEngine.getNavigationChannel().setInitialRoute(host.getInitialRoute());</span><br><span class=\"line\"></span><br><span class=\"line\">B.onResume() -&gt; flutterEngine.getLifecycleChannel().appIsResumed();</span><br><span class=\"line\"></span><br><span class=\"line\">A.onStop()-&gt; flutterEngine.getLifecycleChannel().appIsPaused();</span><br></pre></td></tr></table></figure>\n<p>其实问题已经出来了：<strong>由于我们使用的是单FlutterEngine方案，那么上面生命周期中的flutterEngine为同一实例！</strong>，由于Activity的生命周期机制，前一个Activity的生命周期的onStop是在最后调用的，也就是这时候告诉了FlutterEngine: 这时候appIsPaused，你不用在渲染了，那么这时页面就会成一种“卡死”的状态！正常的生命周期这时候FlutterEngine应该是appIsResumed()。这也就能解释为什么退出到后台（调用了onPause()）再回来（调用onResume()）最终的FlutterEngine是调用了.appIsResumed();显示正常。</p>\n<p>于是找到问题了，那么如何解决呢？这还不简单，当然是去绕过不用去调用A.onStop()呀！怎么可能不用调用A.onStop() 呢？错了，不用去调用其中的delegate中的flutterEngine.getLifecycleChannel().appIsPaused();就好了，我这边的方案与Flutter_boost的方案一样，也对FlutterActivty的代码进行了重写，所以能比较灵活的去改动FlutterActivityAndFragmentDelegate。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> <span class=\"title function_\">onStop</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">  Log.v(TAG, <span class=\"string\">&quot;onStop()&quot;</span>);</span><br><span class=\"line\">  ensureAlive();</span><br><span class=\"line\">  <span class=\"comment\">// flutterEngine.getLifecycleChannel().appIsPaused();</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>对于Fragment的切换也是同样一个思路，就留着大家想一下吧。</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a><strong>总结</strong></h3><p>1、Activity A切换到B的生命周期（A不透明的情况下）：A.onPause() -&gt;B.onCreate()-&gt; B.onStart() -&gt;B.onResume() -&gt;A.onStop()</p>\n<p>2、至于flutterEngine.getLifecycleChannel().appIsPaused();内部具体做了什么事，还得具体去研究一下，字面上理解就是。</p>\n<p>3、Flutter混合原生做开发坑实在是太多了，官方也没有做相应的解决方案，有什么问题，一定要大胆的想，大胆的去尝试！</p>\n","cover":null,"images":["https://cdn.julis.wang/blog/img/20200921223629331.gif","https://cdn.julis.wang/blog/img/20200921223648282.gif"],"content":"<p>最近在研究做Flutter一块相关的内容，方案上采用的是单FlutterEngine，全局Flutter元素共用一个FlutterEngine，对于使用单Engine遇到一个很大的坑，页面切换之后无法点击，页面就像卡死了一样，以下三种情况都会发生：</p>\n<p>第一种：两个FlutterFragment在tab中进行切换，假如AB代表两个FlutterFragment，当A切换到B，再从B切换到A的时候，页面就无法点击。</p>\n<p>第二种：在FlutterActivity中打开新的FlutterActivity，新的FlutterActivity页面跟上述的情况一样，也是无法点击。</p>\n<p>第三种：在Tab中打开FlutterFragment之后再打开FlutterActivity，情况一样，依然无法点击。</p>\n<p>如下动图所示：</p>\n<img src=\"https://cdn.julis.wang/blog/img/20200921223629331.gif\">\n<p>（来自issue <a href=\"https://github.com/flutter/flutter/issues/49950）\">https://github.com/flutter/flutter/issues/49950）</a></p>\n<p>但他们有一个共同的特点：当页面卡死的时候，手动进入后台（打开任务管理或者home键退出）再回到前台，页面就会“刷新”，一切又变得正常了。那么推测：多半与跟页面Fragment和Activity的生命周期有关。我尝试了在进入页面后,再手动模拟“页面退出再回来的周期”，也就是先调用一次<code>onPause()</code>再调用一次<code>onResume()</code>，然而并没有什么卵用……</p>\n<img src=\"https://cdn.julis.wang/blog/img/20200921223648282.gif\">\n<p>可这是为什么呢？？太坑了……踏遍了千山万水也没有找到有人有解决方案，很多人都说别用共享引擎，但是想到 闲鱼Flutter_boost 和HelloBike的thrio框架也都是用的共享引擎啊，他们为什么没有问题？找了很久的解决方法，两天，甚至晚上做梦都梦在关于这个问题。真的是……难受。加了各种各样的群，也没有人能解答这个问题。终于……我去打印了两个Activity的生命周期，才发现事情的端倪。</p>\n<h3 id=\"关于Activity与Fragment的切换的生命周期\"><a href=\"#关于Activity与Fragment的切换的生命周期\" class=\"headerlink\" title=\"关于Activity与Fragment的切换的生命周期\"></a><strong>关于Activity与Fragment的切换的生命周期</strong></h3><p>这里向大家在简单介绍一下Activity和Fragment切换生命周期，相信大家都有被面试问过：现在有两个Activity A和B，在A打开B这一段时间Activity的生命周期变化情况：</p>\n<h6 id=\"A-onPause-gt-B-onCreate-gt-B-onStart-gt-B-onResume-gt-A-onStop\"><a href=\"#A-onPause-gt-B-onCreate-gt-B-onStart-gt-B-onResume-gt-A-onStop\" class=\"headerlink\" title=\"A.onPause() -&gt;B.onCreate()-&gt; B.onStart() -&gt;B.onResume() -&gt;A.onStop()\"></a>A.onPause() -&gt;B.onCreate()-&gt; B.onStart() -&gt;B.onResume() -&gt;A.onStop()</h6><p>A的onStop() 的调用情况分为两种：当设置Activity A的主题windowIsTranslucent属性为true，A Activity并不会调用onStop方法，只会调用onPause()方法。</p>\n<p>ok说完了Activity再说说Fragment，对于我们的问题：Fragment生命周期考虑tab间切换（也就是两个FlutterFragment之间的切换），两个Fragment的切换，并不会导致Fragment的onPause()和onStop()调用，只会调用<code>onHiddenChanged(boolean hidden)</code>，hiden为true表示该Fragment被隐藏了，false表示当前Fragment可见。</p>\n<h3 id=\"关于Flutter单Engine方案\"><a href=\"#关于Flutter单Engine方案\" class=\"headerlink\" title=\"关于Flutter单Engine方案\"></a><strong>关于Flutter单Engine方案</strong></h3><p>现在关于讲解Flutter单Engine方案也比较多，推荐去看这篇—&gt; <a href=\"https://zhuanlan.zhihu.com/p/38026271\">为追求高性能，我必须告诉你Flutter引擎线程的事实…</a> 关于对单Engine的讲解，单Engine方案，我们可以简单理解为：<strong>所有应用中的FlutterView都是由同一个FlutterEngine来渲染的。</strong>当然这看起来是废话，但这就是问题的关键，那么对于所有的FlutterView都是用的同一个FlutterEngine渲染，那么FlutterEngine是怎么去控制的呢？如果让你去设计，你会怎么设计呢？</p>\n<p>这篇博客—&gt;<a href=\"https://cloud.tencent.com/developer/article/1568737\">flutter单引擎方案</a>讲解了一种单Engine的实现方案，可以参考，不过其中也需要对Engine进行多次new，不过这并不是最重要的，我们需要明白的是：<strong>当FlutterEngine去渲染FlutterView B的时候，它需要attach再在B上，从FlutterView A detach掉，再返回FlutterView A的时候，它需要从FlutterView B上detach掉，再attach到A上。</strong></p>\n<h3 id=\"Flutter坑！\"><a href=\"#Flutter坑！\" class=\"headerlink\" title=\"Flutter坑！\"></a><strong>Flutter坑！</strong></h3><p>现在我们明白了生命周期的变化，我们接下来去看FlutterActivity中响应生命周期中的源码。对于FlutterActivity A打开FlutterActivity B，他们依次会调用：</p>\n<h6 id=\"A-onPause-gt-B-onCreate-gt-B-onStart-gt-B-onResume-gt-A-onStop-1\"><a href=\"#A-onPause-gt-B-onCreate-gt-B-onStart-gt-B-onResume-gt-A-onStop-1\" class=\"headerlink\" title=\"A.onPause() -&gt;B.onCreate()-&gt; B.onStart() -&gt;B.onResume() -&gt;A.onStop()\"></a>A.onPause() -&gt;B.onCreate()-&gt; B.onStart() -&gt;B.onResume() -&gt;A.onStop()</h6><p>我们来看看FlutterActivity在对应的生命周期里面做了什么,</p>\n<p>对于<strong>A.onPause()</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title function_\">onPause</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">super</span>.onPause();</span><br><span class=\"line\">  delegate.onPause();</span><br><span class=\"line\">  lifecycle.handleLifecycleEvent(Lifecycle.Event.ON_PAUSE);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们知道：FlutterActivity和Fragment主要由FlutterActivityAndFragmentDelegate来进行管理，这里我们主要关注delegate里面的内容</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> <span class=\"title function_\">onPause</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">  Log.v(TAG, <span class=\"string\">&quot;onPause()&quot;</span>);</span><br><span class=\"line\">  ensureAlive();</span><br><span class=\"line\">  flutterEngine.getLifecycleChannel().appIsInactive();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里是关键我们看到了flutterEngine与生命周期相关的代码，接下来我们看其他几个生命周期里面对于flutterEngine的Lifecycle管理情况</p>\n<p>对于<strong>B.onCreate()</strong>只进行了相关的view创建工作.</p>\n<p>对于<strong>B.onStart()</strong>中有执行<code>doInitialFlutterViewRun();</code>，其中比较关键的一句就是：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">if (host.getInitialRoute() != null) &#123;</span><br><span class=\"line\">  flutterEngine.getNavigationChannel().setInitialRoute(host.getInitialRoute());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>对于<strong>B.onResume()</strong> </p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> <span class=\"title function_\">onResume</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">  Log.v(TAG, <span class=\"string\">&quot;onResume()&quot;</span>);</span><br><span class=\"line\">  ensureAlive();</span><br><span class=\"line\">  flutterEngine.getLifecycleChannel().appIsResumed();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>最后是<strong>A.onStop()</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> <span class=\"title function_\">onStop</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">  Log.v(TAG, <span class=\"string\">&quot;onStop()&quot;</span>);</span><br><span class=\"line\">  ensureAlive();</span><br><span class=\"line\">  flutterEngine.getLifecycleChannel().appIsPaused();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>看到了A.onStop()，聪明的人应该都看出来问题了，我们重新整理一下从Activity A启动到B，flutterEngine相关的生命周期主要执行了以下流程：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">A.onPause() -&gt; flutterEngine.getLifecycleChannel().appIsInactive()</span><br><span class=\"line\"></span><br><span class=\"line\">B.onCreate()-&gt;  nothing.</span><br><span class=\"line\"></span><br><span class=\"line\">B.onStart() -&gt; flutterEngine.getNavigationChannel().setInitialRoute(host.getInitialRoute());</span><br><span class=\"line\"></span><br><span class=\"line\">B.onResume() -&gt; flutterEngine.getLifecycleChannel().appIsResumed();</span><br><span class=\"line\"></span><br><span class=\"line\">A.onStop()-&gt; flutterEngine.getLifecycleChannel().appIsPaused();</span><br></pre></td></tr></table></figure>\n<p>其实问题已经出来了：<strong>由于我们使用的是单FlutterEngine方案，那么上面生命周期中的flutterEngine为同一实例！</strong>，由于Activity的生命周期机制，前一个Activity的生命周期的onStop是在最后调用的，也就是这时候告诉了FlutterEngine: 这时候appIsPaused，你不用在渲染了，那么这时页面就会成一种“卡死”的状态！正常的生命周期这时候FlutterEngine应该是appIsResumed()。这也就能解释为什么退出到后台（调用了onPause()）再回来（调用onResume()）最终的FlutterEngine是调用了.appIsResumed();显示正常。</p>\n<p>于是找到问题了，那么如何解决呢？这还不简单，当然是去绕过不用去调用A.onStop()呀！怎么可能不用调用A.onStop() 呢？错了，不用去调用其中的delegate中的flutterEngine.getLifecycleChannel().appIsPaused();就好了，我这边的方案与Flutter_boost的方案一样，也对FlutterActivty的代码进行了重写，所以能比较灵活的去改动FlutterActivityAndFragmentDelegate。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> <span class=\"title function_\">onStop</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">  Log.v(TAG, <span class=\"string\">&quot;onStop()&quot;</span>);</span><br><span class=\"line\">  ensureAlive();</span><br><span class=\"line\">  <span class=\"comment\">// flutterEngine.getLifecycleChannel().appIsPaused();</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>对于Fragment的切换也是同样一个思路，就留着大家想一下吧。</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a><strong>总结</strong></h3><p>1、Activity A切换到B的生命周期（A不透明的情况下）：A.onPause() -&gt;B.onCreate()-&gt; B.onStart() -&gt;B.onResume() -&gt;A.onStop()</p>\n<p>2、至于flutterEngine.getLifecycleChannel().appIsPaused();内部具体做了什么事，还得具体去研究一下，字面上理解就是。</p>\n<p>3、Flutter混合原生做开发坑实在是太多了，官方也没有做相应的解决方案，有什么问题，一定要大胆的想，大胆的去尝试！</p>\n","categories":[{"name":"技术文章","slug":"technology","api":"api/categories/technology.json"}],"tags":[{"name":"Flutter","slug":"Flutter","api":"api/tags/Flutter.json"}],"api":"api/posts/2020/09/21/Flutter坑之共享FlutterEngine页面切换无法点击.json"},{"title":"从Android返回键退出和直接杀死进程退出说起","slug":"从Android返回键退出和直接杀死进程退出说起","date":"2020-09-09T01:31:00.000Z","updated":"2025-05-20T11:46:57.000Z","comments":true,"url":"2020/09/09/从Android返回键退出和直接杀死进程退出说起/","excerpt":"<p>最近开发的时候，使用了一个单例模式，当我返回键退出App，再重新启动，发现App的确是从首页启动，但还没有执行为单例类设置数值的位置。可是！断点调试的时候发现这时候已经有了一个数据，并且是上一次运行留下的数据，当时觉得很神奇，明明根Activity已经执行了OnDestroy()，而且再启动的确是从首页过来的，讲道理应该是“everything will be new”，但是单例里面的数据仍然存在，这可是为什么呢？</p>\n<p>Google搜了一下，噢！恍然大悟，看到这一块的知识很久没有用就忘掉了，或者说对运行机制相关还不太熟悉吧，所以在此重新整理总结一份。</p>\n<h4 id=\"返回键退出和直接杀死进程退出的区别？\"><a href=\"#返回键退出和直接杀死进程退出的区别？\" class=\"headerlink\" title=\"返回键退出和直接杀死进程退出的区别？\"></a>返回键退出和直接杀死进程退出的区别？</h4><p><strong>直接杀死退出</strong>：所有的内存都会被回收，重新启动应用程序时，会重新调用Application的<code>OnCreate()</code>方法，会调用onSaveInstanceState方法。</p>\n<p><strong>返回键退出程序</strong>：退出程序后，一些加载过的静态变量并没有被回收，重新启动也不需要调用Application的OnCreate()方法。</p>\n<p>于是我们就知道，静态变量并没有被回收，而我们的单例模式实例就是静态变量，没有被回收，于是我们就知道为什么单例模式数据还存在了，于是在响应的位置对其数据进行释放。可是 why？这两者的差异究竟是什么导致的？我们要知其然，也要知其所以然。</p>\n<h4 id=\"关于直接杀死进程\"><a href=\"#关于直接杀死进程\" class=\"headerlink\" title=\"关于直接杀死进程\"></a>关于直接杀死进程</h4><p>这里我们应该很好去理解，Android中的每一个App都是运行在自己VM实例之中(沙盒)。每一个VM实例在linux中又是一个单独的进程，通过任务管理杀掉一个进程，那么对应进程里面的数据全部被回收掉。</p>\n<h4 id=\"关于返回键退出\"><a href=\"#关于返回键退出\" class=\"headerlink\" title=\"关于返回键退出\"></a>关于返回键退出</h4><p>通过对源码的追溯，如果不对onBackPressed()做特殊的处理，无论是AppCompatActivity还是android.app.Activity，发现都会通过执行onBackPressed(),最后到Activity的finish()方法，也就是说当App退出到根的时候，最终只是执行的是当前App根Activity的finish()方法，整个App“依然在运行”，只是看不到界面了，那么也就是说，如果在App中运行的Service之类的后台任务并没结束，仍然在运行。</p>\n<p>那为什么单例模里面的静态变量没有回收呢？如果问你的话，你怎么答？emmmmm……因为……它没有被销毁嘛，所以它还在。当然不能这么回答了，需要用理论依据来解释。</p>\n<h4 id=\"关于方法区与静态变量\"><a href=\"#关于方法区与静态变量\" class=\"headerlink\" title=\"关于方法区与静态变量\"></a>关于方法区与静态变量</h4><p>我们知道静态变量存在与JVM的方法区中，静态变量在类被加载的时候分配内存，Java虚拟机规范中说过可以不要求虚拟机在方法区实现垃圾收集，如下图所示：</p>\n<img src=\"https://cdn.julis.wang/blog/img/20200908231258604.png\">\n<p>那么我们是不是可以理解为方法区中不会进行垃圾回收？查到来自《深入理解Java虚拟机》中的解释：</p>\n<blockquote>\n<p>很多人以为方法区（或者HotSopt 虚拟机中的永久代）是没有垃圾收集的，Java虚拟机规范中确实说过可以不要求虚拟机在方法区实现垃圾收集，而且性价比一般较低，在对的新生代生一般能回收70%~95%的空间，而永久代远低于此。</p>\n<p>永久代的垃圾手机主要回收两部分内容：<strong>废弃常量</strong>和<strong>无用的类</strong>。 回收废弃常量与回收Java堆中的对象非常相似。以常量池中字面量的回收为例，若字符串“abc”已经进入常量池中，但当前系统没有任何String对象引用常量池中的“abc”常量，也没有其他地方引用该字面量，若发生内存回收，且必要的话，该“abc”就会被系统清理出常量池。常量池中其他的类（接口）、方法、字段的符号引用与此类似。</p>\n<p>无用的类需要满足3个条件：</p>\n<p>（1）该类所有的实例都已经被回收，即Java堆中不存在该类的任何实例；<br>（2）加载该类的ClassLoader已经被回收；<br>（3）该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</p>\n</blockquote>\n<p>那么对于我们的静态变量来说，如果不是我们手动处理的话设置实例为null的话，或其他操作的话，那么就不会满足上面的条件。那么静态变量会在什么时候被销毁呢？答案很简单了就：<strong>静态变量在类被卸载的时候销毁，类在什么时候被卸载？在进程结束的时候。</strong>那么这也自然能解释我最开始遇到的情况了，返回键返回结束App后进程并没有结束，当下一次再启动App的时候，进程并没有销毁而，因是同一个进程，所以单例中的数据依然存在。</p>\n","cover":null,"images":["https://cdn.julis.wang/blog/img/20200908231258604.png"],"content":"<p>最近开发的时候，使用了一个单例模式，当我返回键退出App，再重新启动，发现App的确是从首页启动，但还没有执行为单例类设置数值的位置。可是！断点调试的时候发现这时候已经有了一个数据，并且是上一次运行留下的数据，当时觉得很神奇，明明根Activity已经执行了OnDestroy()，而且再启动的确是从首页过来的，讲道理应该是“everything will be new”，但是单例里面的数据仍然存在，这可是为什么呢？</p>\n<p>Google搜了一下，噢！恍然大悟，看到这一块的知识很久没有用就忘掉了，或者说对运行机制相关还不太熟悉吧，所以在此重新整理总结一份。</p>\n<h4 id=\"返回键退出和直接杀死进程退出的区别？\"><a href=\"#返回键退出和直接杀死进程退出的区别？\" class=\"headerlink\" title=\"返回键退出和直接杀死进程退出的区别？\"></a>返回键退出和直接杀死进程退出的区别？</h4><p><strong>直接杀死退出</strong>：所有的内存都会被回收，重新启动应用程序时，会重新调用Application的<code>OnCreate()</code>方法，会调用onSaveInstanceState方法。</p>\n<p><strong>返回键退出程序</strong>：退出程序后，一些加载过的静态变量并没有被回收，重新启动也不需要调用Application的OnCreate()方法。</p>\n<p>于是我们就知道，静态变量并没有被回收，而我们的单例模式实例就是静态变量，没有被回收，于是我们就知道为什么单例模式数据还存在了，于是在响应的位置对其数据进行释放。可是 why？这两者的差异究竟是什么导致的？我们要知其然，也要知其所以然。</p>\n<h4 id=\"关于直接杀死进程\"><a href=\"#关于直接杀死进程\" class=\"headerlink\" title=\"关于直接杀死进程\"></a>关于直接杀死进程</h4><p>这里我们应该很好去理解，Android中的每一个App都是运行在自己VM实例之中(沙盒)。每一个VM实例在linux中又是一个单独的进程，通过任务管理杀掉一个进程，那么对应进程里面的数据全部被回收掉。</p>\n<h4 id=\"关于返回键退出\"><a href=\"#关于返回键退出\" class=\"headerlink\" title=\"关于返回键退出\"></a>关于返回键退出</h4><p>通过对源码的追溯，如果不对onBackPressed()做特殊的处理，无论是AppCompatActivity还是android.app.Activity，发现都会通过执行onBackPressed(),最后到Activity的finish()方法，也就是说当App退出到根的时候，最终只是执行的是当前App根Activity的finish()方法，整个App“依然在运行”，只是看不到界面了，那么也就是说，如果在App中运行的Service之类的后台任务并没结束，仍然在运行。</p>\n<p>那为什么单例模里面的静态变量没有回收呢？如果问你的话，你怎么答？emmmmm……因为……它没有被销毁嘛，所以它还在。当然不能这么回答了，需要用理论依据来解释。</p>\n<h4 id=\"关于方法区与静态变量\"><a href=\"#关于方法区与静态变量\" class=\"headerlink\" title=\"关于方法区与静态变量\"></a>关于方法区与静态变量</h4><p>我们知道静态变量存在与JVM的方法区中，静态变量在类被加载的时候分配内存，Java虚拟机规范中说过可以不要求虚拟机在方法区实现垃圾收集，如下图所示：</p>\n<img src=\"https://cdn.julis.wang/blog/img/20200908231258604.png\">\n<p>那么我们是不是可以理解为方法区中不会进行垃圾回收？查到来自《深入理解Java虚拟机》中的解释：</p>\n<blockquote>\n<p>很多人以为方法区（或者HotSopt 虚拟机中的永久代）是没有垃圾收集的，Java虚拟机规范中确实说过可以不要求虚拟机在方法区实现垃圾收集，而且性价比一般较低，在对的新生代生一般能回收70%~95%的空间，而永久代远低于此。</p>\n<p>永久代的垃圾手机主要回收两部分内容：<strong>废弃常量</strong>和<strong>无用的类</strong>。 回收废弃常量与回收Java堆中的对象非常相似。以常量池中字面量的回收为例，若字符串“abc”已经进入常量池中，但当前系统没有任何String对象引用常量池中的“abc”常量，也没有其他地方引用该字面量，若发生内存回收，且必要的话，该“abc”就会被系统清理出常量池。常量池中其他的类（接口）、方法、字段的符号引用与此类似。</p>\n<p>无用的类需要满足3个条件：</p>\n<p>（1）该类所有的实例都已经被回收，即Java堆中不存在该类的任何实例；<br>（2）加载该类的ClassLoader已经被回收；<br>（3）该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</p>\n</blockquote>\n<p>那么对于我们的静态变量来说，如果不是我们手动处理的话设置实例为null的话，或其他操作的话，那么就不会满足上面的条件。那么静态变量会在什么时候被销毁呢？答案很简单了就：<strong>静态变量在类被卸载的时候销毁，类在什么时候被卸载？在进程结束的时候。</strong>那么这也自然能解释我最开始遇到的情况了，返回键返回结束App后进程并没有结束，当下一次再启动App的时候，进程并没有销毁而，因是同一个进程，所以单例中的数据依然存在。</p>\n","categories":[{"name":"技术文章","slug":"technology","api":"api/categories/technology.json"}],"tags":[{"name":"安卓","slug":"Android","api":"api/tags/Android.json"}],"api":"api/posts/2020/09/09/从Android返回键退出和直接杀死进程退出说起.json"},{"title":"扇形等分-突然想到的一个数学问题","slug":"扇形等分-突然想到的一个数学问题","date":"2020-09-01T07:13:00.000Z","updated":"2025-11-08T03:27:40.918Z","comments":true,"url":"2020/09/01/扇形等分-突然想到的一个数学问题/","excerpt":"<p>ps:博客有可能会因为一些 markdown 兼容性不支持，可以查看：<br><a href=\"https://www.douban.com/note/776327336/\">https://www.douban.com/note/776327336/</a></p>\n<img src=\"https://cdn.julis.wang/blog/img/1521743510550.jpg\">\n","cover":null,"images":["https://cdn.julis.wang/blog/img/1521743510550.jpg"],"content":"<p>ps:博客有可能会因为一些 markdown 兼容性不支持，可以查看：<br><a href=\"https://www.douban.com/note/776327336/\">https://www.douban.com/note/776327336/</a></p>\n<img src=\"https://cdn.julis.wang/blog/img/1521743510550.jpg\">\n","categories":[{"name":"算法研究","slug":"算法研究","api":"api/categories/算法研究.json"}],"tags":[{"name":"数学","slug":"数学","api":"api/tags/数学.json"}],"api":"api/posts/2020/09/01/扇形等分-突然想到的一个数学问题.json"}],"info":{"type":"archive","year":2020,"month":9}},"api":"api/archives/2020/09/page.1.json"}