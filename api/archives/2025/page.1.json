{"data":{"index":1,"total":1,"posts":[{"title":"手写一个精简版Koin：深入理解依赖注入核心原理","slug":"Koin-源码理解相关","date":"2025-08-25T13:08:00.000Z","updated":"2025-08-25T13:44:34.603Z","comments":true,"url":"2025/08/25/Koin-源码理解相关/","excerpt":"<p>在现代 Android 应用开发中，依赖注入（Dependency Injection, DI）已成为构建松耦合、可测试代码的重要技术。Koin 作为一个轻量级的Kotlin依赖注入框架，因其简洁的DSL和易用性深受开发者喜爱。最近对其源码进行学习了解，通过手写一个极度精简的 Koin 核心代码，来透彻理解Koin的注册、解析和参数传递机制。</p>\n<blockquote>\n<p><strong>本文代码基于 Koin 源码思想实现，仅用于学习核心原理，并非 Koin官 方代码。</strong></p>\n</blockquote>\n<h2 id=\"核心概念与项目结构\"><a href=\"#核心概念与项目结构\" class=\"headerlink\" title=\"核心概念与项目结构\"></a>核心概念与项目结构</h2><p>下图是基于 koin 4.1 解析的 主要类UML图，可以比较清晰地看看各个类之间的关系</p>\n<img src=\"https://cdn.julis.wang/blog/img/koin_uml.png\"> \n<p>power by <a href=\"https://www.mermaidchart.com/\">mermaidchart</a></p>\n<p>主要类：</p>\n<ul>\n<li><strong><code>KoinApplication</code></strong>: Koin启动的入口，负责初始化容器和加载模块。</li>\n<li><strong><code>Koin</code></strong>: 核心容器，持有实例注册表 InstanceRegistry 和作用域注册表 ScopeRegistry。</li>\n<li><strong><code>Module</code></strong>: 定义依赖的地方，存放了所有的 bean 定义 BeanDefinition 与 InstanceFactory。</li>\n<li><strong><code>BeanDefinition</code></strong>: 对一个依赖项的定义，包括其类型、限定符、所属作用域以及创建它的 lambda 表达式。</li>\n<li><strong><code>InstanceFactory</code></strong>: 负责根据 <code>BeanDefinition</code> 创建实例的核心工厂，分为 <code>SingleFactory</code> (单例)、<code>FactoryFactory</code> (工厂模式) 和 <code>ScopeFactory</code> (作用域内单例)。</li>\n<li><strong><code>Scope</code></strong>: 作用域，用于管理特定生命周期内的实例。</li>\n<li><strong><code>ParametersHolder</code></strong>: 参数容器，用于在获取实例时动态传递参数。</li>\n</ul>\n<h2 id=\"手写-koin-代码介绍\"><a href=\"#手写-koin-代码介绍\" class=\"headerlink\" title=\"手写 koin 代码介绍\"></a>手写 koin 代码介绍</h2><p>基于对源码的理解和参考，实现了 koin 的基本功能，整体分成三部分：简单 single 数据存取、包含 scope 能力、动态参数能力，分成三个文件夹，顺序123是基于前面带代码累加的。</p>\n<p><strong>简单 single 数据存取</strong><br>代码实现在：<a href=\"https://github.com/VomPom/JProject/blob/master/app/src/main/java/wang/julis/jproject/example/source/koin/noScope1/KoinWithoutScope.kt\">KoinWithoutScope.kt</a></p>\n<p>这是一份最简单的代码，大概200行不到，基本上包含了 koin 的核心思想：启动时注册组件定义。解析时，先查作用域缓存，命中则直接返回。未命中则递归解析其依赖项，调用工厂函数创建实例，最后返回实例。</p>\n<p>从这也能看出来 koin 的缺点：Koin 启动时 (startKoin) 需要将所有模块的定义 (BeanDefinition) 注册到容器中。实例数量过多会显著增加启动注册过程的耗时，影响应用启动速度。由于每个实例都会对应一个 BeanDefinition 以及 Factory ，内存占用会相应地上升。</p>\n<p>整个流程简单来讲就是生成一个 map，通过 key 获取对于的数据。</p>\n<p><strong>Scope 能力</strong><br>代码实现在：<a href=\"https://github.com/VomPom/JProject/blob/master/app/src/main/java/wang/julis/jproject/example/source/koin/scope2/KoinWithScope.kt\">KoinWithScope.kt</a></p>\n<p>这一份是在之前的能力上进行添加，此前将所有的数据都注册到 “root” 这个容器内，全局通用，但为了将不同作用域分开，需要引入 scope 的概念。</p>\n<p>简单理解就是在通过 key 获取的 map 里面的数据的时候，这个 key 是有一定的规则的，核心逻辑在这里：<br> <figure class=\"highlight kotlin\"><table><tr><td class=\"code\"><pre><span class=\"line\"> <span class=\"keyword\">inline</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">indexKey</span><span class=\"params\">(clazz: <span class=\"type\">KClass</span>&lt;*&gt;, typeQualifier: <span class=\"type\">String</span>?, scopeQualifier: <span class=\"type\">String</span>)</span></span>: String &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> buildString &#123;</span><br><span class=\"line\">        append(clazz.java.name)</span><br><span class=\"line\">        append(<span class=\"string\">&#x27;:&#x27;</span>)</span><br><span class=\"line\">        append(typeQualifier ?: <span class=\"string\">&quot;&quot;</span>)</span><br><span class=\"line\">        append(<span class=\"string\">&#x27;:&#x27;</span>)</span><br><span class=\"line\">        append(scopeQualifier)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br> 不同的 scope 实际上也就是获取的 key 值的不同。</p>\n<p><strong>动态参数能力</strong><br>代码实现在：<a href=\"https://github.com/VomPom/JProject/blob/master/app/src/main/java/wang/julis/jproject/example/source/koin/parameter3/KoinWithParameter.kt\">KoinWithParameter.kt</a></p>\n<p>最后在 scope 的基础上实现了一个比较重要的能力-动态参数能力，通过这个能力可以让有实例能够在运行的时候根据参数动态创建。这个能力也是像在安卓 Activity&#x2F;Fragment 里面 viewmodel() 实现依赖注入的必要实现。 </p>\n<p>简单理解就是在 get() 的时候将参数传入到获取实例的调用链中，在运行时执行注册的 Lambda 函数invoke时候将作为参数传递到构造方法中去。这里单独拎出来实现是因为这个参数传递影响到整个流程的逻辑，为了上上面的两个能力逻辑更简单清晰，单独在这一部分实现。</p>\n<h2 id=\"Koin-的注册流程（Declaration）\"><a href=\"#Koin-的注册流程（Declaration）\" class=\"headerlink\" title=\"Koin 的注册流程（Declaration）\"></a>Koin 的注册流程（Declaration）</h2><p>注册是DI容器工作的第一步。通过 <code>startKoin</code> 和 <code>module</code> DSL来声明依赖。</p>\n<h3 id=\"启动-Koin-与模块加载\"><a href=\"#启动-Koin-与模块加载\" class=\"headerlink\" title=\"启动 Koin 与模块加载\"></a>启动 Koin 与模块加载</h3><p>整个启动加载流程将 kotlin 的语法糖用到了极致，也就使得整个代码看起来是如此的简洁。</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> myApp = startKoin &#123;</span><br><span class=\"line\">    modules(appModule)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 定义一个模块</span></span><br><span class=\"line\"><span class=\"keyword\">val</span> appModule = module &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 注册一个单例，其构造需要一個 Int 参数</span></span><br><span class=\"line\">    single &#123; (<span class=\"keyword\">data</span>: <span class=\"built_in\">Int</span>) -&gt; ComponentInt(<span class=\"keyword\">data</span>) &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 注册一个工厂（每次获取都是新实例），其构造需要 Int 和 Float 参数</span></span><br><span class=\"line\">    factory &#123; (data1: <span class=\"built_in\">Int</span>, data2: <span class=\"built_in\">Float</span>) -&gt; ComponentIntFloat(data1, data2) &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>流程剖析：</strong></p>\n<p><strong><code>startKoin</code></strong><br>这是一个顶级函数，它调用 <code>GlobalContext.startKoin</code>，创建并初始化一个 <code>KoinApplication</code> 对象。</p>\n<p><strong><code>modules(...)</code></strong><br><code>KoinApplication</code> 的方法，它将传入的 <code>Module</code> 列表交给 <code>Koin</code> 实例的 <code>loadModels</code> 方法处理。</p>\n<p><strong><code>module &#123; ... &#125;</code></strong><br>DSL函数，它创建一个 <code>Module</code> 对象，并执行其中的配置lambda。</p>\n<p><strong><code>single/factory/scope</code></strong><br><code>Module</code> 的扩展函数。它们的作用是：</p>\n<ul>\n<li>使用 <code>_createDefinition</code> 将 lambda 表达式包装成一个 <code>BeanDefinition</code>对象。</li>\n<li>使用 <code>_InstanceFactory</code> 将 <code>BeanDefinition</code> 包装成对应的 <code>InstanceFactory</code>。</li>\n<li>调用 <code>indexPrimaryType</code>，生成一个<strong>唯一的Key</strong>（格式：<code>类名:限定符:作用域</code>），并将 <code>Factory</code> 存入 <code>Module.mappings</code> 这个 <code>HashMap</code> 中。</li>\n</ul>\n<p><strong>最终存储</strong><br><code>Koin</code> 的 <code>InstanceRegistry</code> 会遍历所有 <code>Module</code>，将它们 <code>mappings</code> 中的全部 <code>Factory</code> 都合并到自己的 <code>_instances</code>（一个 <code>ConcurrentHashMap</code>）中。</p>\n<p>至此，所有依赖的定义都已注册到容器中，静待获取。</p>\n<h2 id=\"Koin的实例获取流程（Retrieval）\"><a href=\"#Koin的实例获取流程（Retrieval）\" class=\"headerlink\" title=\"Koin的实例获取流程（Retrieval）\"></a>Koin的实例获取流程（Retrieval）</h2><figure class=\"highlight kotlin\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 获取无参依赖（普通方式）</span></span><br><span class=\"line\"><span class=\"keyword\">val</span> component = <span class=\"keyword\">get</span>&lt;Component&gt;()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 通过 scope 作用域限定进行获取</span></span><br><span class=\"line\"><span class=\"keyword\">val</span> scope = koin.createScope(<span class=\"string\">&quot;scope&quot;</span>, scopeQualifier)</span><br><span class=\"line\"><span class=\"keyword\">val</span> component = scope.<span class=\"keyword\">get</span>&lt;Component&gt;()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 通过需要动态参数的获取</span></span><br><span class=\"line\"><span class=\"keyword\">val</span> componentWithArgs = <span class=\"keyword\">get</span>&lt;ComponentInt&gt; &#123; parametersOf(<span class=\"number\">42</span>) &#125;</span><br><span class=\"line\"><span class=\"keyword\">val</span> componentWithMultiArgs = <span class=\"keyword\">get</span>&lt;ComponentIntFloat&gt; &#123; parametersOf(<span class=\"number\">101</span>, <span class=\"number\">3.14f</span>) &#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"流程剖析\"><a href=\"#流程剖析\" class=\"headerlink\" title=\"流程剖析\"></a>流程剖析</h3><p><strong><code>Scope.get&lt;T&gt;</code></strong></p>\n<p>这是 <code>Scope</code> 的一个扩展函数。它首先创建一个 <code>ResolutionContext</code>，封装了当前作用域、要解析的类型、限定符以及最重要的——<strong>参数持有器 <code>ParametersHolder</code></strong>（由 <code>parametersOf</code> 函数创建）。</p>\n<p> <strong>解析上下文（ResolutionContext）</strong></p>\n<p> 这个上下文对象包含了解析一个实例所需的所有信息。</p>\n<p><strong>核心解析器（CoreResolver）</strong><br><code>get</code> 操作会委托给 <code>Koin</code> 的 <code>CoreResolver</code>进行处理。源码里面对于查找顺序有非常清晰的层次体现：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"type\">&lt;T&gt;</span> <span class=\"title\">resolveFromContext</span><span class=\"params\">(scope : <span class=\"type\">Scope</span>, instanceContext: <span class=\"type\">ResolutionContext</span>)</span></span>: T &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> resolveFromContextOrNull(scope,instanceContext) ?: throwNoDefinitionFound(instanceContext)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"type\">&lt;T&gt;</span> <span class=\"title\">resolveFromContextOrNull</span><span class=\"params\">(scope : <span class=\"type\">Scope</span>, instanceContext: <span class=\"type\">ResolutionContext</span>, lookupParent : <span class=\"type\">Boolean</span> = <span class=\"literal\">true</span>)</span></span>: T? &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> resolveFromInjectedParameters(instanceContext)</span><br><span class=\"line\">          ?: resolveFromRegistry(scope,instanceContext)</span><br><span class=\"line\">          ?: resolveFromStackedParameters(scope,instanceContext)</span><br><span class=\"line\">          ?: resolveFromScopeSource(scope,instanceContext)</span><br><span class=\"line\">          ?: resolveFromScopeArchetype(scope,instanceContext)</span><br><span class=\"line\">          ?: <span class=\"keyword\">if</span> (lookupParent) resolveFromParentScopes(scope,instanceContext) <span class=\"keyword\">else</span> <span class=\"literal\">null</span></span><br><span class=\"line\">          ?: resolveInExtensions(scope,instanceContext)</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n\n<p> <strong>查找工厂</strong></p>\n<ul>\n<li><code>Resolver</code> 会调用 <code>InstanceRegistry.resolveDefinition</code>。</li>\n<li>该方法使用和注册时<strong>相同的算法</strong>生成Key（类名:限定符:作用域），然后从 <code>_instances</code> 中查找对应的 <code>InstanceFactory</code>。</li>\n</ul>\n<p> <strong>创建实例</strong></p>\n<ul>\n<li><p>找到 <code>Factory</code> 后，调用其 <code>get(context: ResolutionContext)</code> 方法。</p>\n</li>\n<li><p><code>Factory</code> 会调用自己的 <code>create</code> 方法。<strong>关键一步来了</strong>：在 <code>create</code> 方法中，会执行 <code>BeanDefinition.definition.invoke(context.scope, parameters)</code>。这其实就是执行了之前注册的 lambda：<code>&#123; (data: Int) -&gt; ComponentInt(data) &#125;</code>。</p>\n</li>\n<li><p><strong>参数传递</strong>：这里的 <code>parameters</code> 就是在 <code>get</code> 时传入的 <code>ParametersHolder</code>。Lambda 的参数 <code>(data: Int)</code> 会从 <code>ParametersHolder</code> 中按顺序（或使用解构）取出值</p>\n</li>\n</ul>\n<p><strong>返回实例</strong></p>\n<p>工厂将创建好的实例返回给调用者。</p>\n<p>对于 <code>SingleFactory</code>，它会将第一次创建出来的实例缓存起来，后续调用直接返回缓存实例。<code>FactoryFactory</code> 则每次都会执行 <code>create</code> 方法。</p>\n<h2 id=\"其他技术\"><a href=\"#其他技术\" class=\"headerlink\" title=\"其他技术\"></a>其他技术</h2><h3 id=\"DslMarker-的作用\"><a href=\"#DslMarker-的作用\" class=\"headerlink\" title=\"@DslMarker 的作用\"></a>@DslMarker 的作用</h3><p>在实现的过程中发现如下图所示：koin 的代码有颜色分层，能比较清晰地看到各个 block 之间的差异，自己写的代码全部是白色。</p>\n<img src=\"https://cdn.julis.wang/blog/img/koin_color_contrast.png\"> \n\n\n<p>代码开头定义了三个注解：<code>@KoinApplicationDslMarker</code>, <code>@KoinDslMarker</code>, <code>@OptionDslMarker</code>。这是Kotlin DSL的<strong>安全卫士</strong>。</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@DslMarker</span></span><br><span class=\"line\"><span class=\"keyword\">annotation</span> <span class=\"keyword\">class</span> <span class=\"title class_\">KoinDslMarker</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@KoinDslMarker</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Module</span> &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">single</span><span class=\"params\">(...)</span></span> &#123; ... &#125; <span class=\"comment\">// 这个single在DSL里</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@KoinDslMarker</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">KoinApplication</span> &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">modules</span><span class=\"params\">(...)</span></span> &#123; ... &#125; <span class=\"comment\">// 这个modules在DSL里</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">test</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    startKoin &#123;</span><br><span class=\"line\">        modules(...) <span class=\"comment\">// 正确：在 KoinApplication 的 lambda 里</span></span><br><span class=\"line\">        single &#123; ... &#125; <span class=\"comment\">// 编译错误！@DslMarker 阻止了隐式地使用外部 Receiver (Module)</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>@DslMarker</code> 实际的作用是防止在嵌套的DSL Lambda中，意外地调用到外层 Receiver 的方法，从而让DSL书写更加清晰和安全。代码颜色是由 IDE 提供的效果。在代码中加上几个注解之后，效果如图所示：</p>\n<img src=\"https://cdn.julis.wang/blog/img/koin_color_annotation.png\"> \n<p>跟 koin 的颜色不太一致，不过能明显看到代码有分层，应该是由于 koin 对 annotation 也有处理，这里没有再深入研究。</p>\n<h3 id=\"2-优雅的参数传递与解构\"><a href=\"#2-优雅的参数传递与解构\" class=\"headerlink\" title=\"2. 优雅的参数传递与解构\"></a>2. 优雅的参数传递与解构</h3><p>这个逻辑复刻了Koin的动态参数特性。</p>\n<ul>\n<li><strong><code>ParametersHolder</code></strong>：一个轻量的参数容器，内部用一个 <code>List&lt;Any?&gt;</code> 存储参数。</li>\n<li><strong><code>parametersOf</code></strong>：辅助函数，优雅地创建 <code>ParametersHolder</code>。</li>\n<li><strong>解构声明（Destructuring Declaration）</strong>：<code>ParametersHolder</code> 重写了 <code>component1()</code> 到 <code>component5()</code> 操作符。这使得在定义lambda时，可以直接用 <code>(a: A, b: B)</code> 的形式来接收参数，而不是手动调用 <code>parameters.get&lt;X&gt;(0)</code>。</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 注册端：看起来就像普通函数</span></span><br><span class=\"line\">single &#123; (id: <span class=\"built_in\">Int</span>, name: String) -&gt; User(id, name) &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 获取端：传递参数非常直观</span></span><br><span class=\"line\"><span class=\"keyword\">val</span> user = <span class=\"keyword\">get</span>&lt;User&gt; &#123; parametersOf(<span class=\"number\">123</span>, <span class=\"string\">&quot;Julius&quot;</span>) &#125;</span><br></pre></td></tr></table></figure>\n<p>这种设计极大地提升了API的简洁性和可读性。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>通过这个手写的迷你Koin，可以深刻地理解到，一个现代DI容器的核心无非是解决两个问题：</p>\n<ol>\n<li><strong>如何注册（Declaration）</strong>：通过DSL将依赖的创建方式（Lambda）以键值对的形式保存到一个全局的注册表中。</li>\n<li><strong>如何获取（Retrieval）</strong>：根据请求的类型、限定符和作用域生成Key，从注册表中找到对应的创建工厂，并调用它来生成实例。支持通过参数容器实现动态传参。</li>\n</ol>\n<p>除此之外，诸如 <code>@DslMarker</code> 保证DSL安全、<strong>解构</strong>实现参数优雅传递，都是构建一个健壮、易用框架的关键技术。</p>\n<p>虽然这个实现省略了Koin的许多高级功能（如完整的Scope生命周期管理、属性注入、Android特定支持等），但它已经囊括了最核心、最精妙的设计思想，再理解其他的模块也会简单很多。</p>\n<p>实现的所有源码位于：<a href=\"https://github.com/VomPom/JProject/tree/master/app/src/main/java/wang/julis/jproject/example/source/koin\">JProject&#x2F;source&#x2F;koin</a></p>\n","cover":null,"images":["https://cdn.julis.wang/blog/img/koin_uml.png","https://cdn.julis.wang/blog/img/koin_color_contrast.png","https://cdn.julis.wang/blog/img/koin_color_annotation.png"],"content":"<p>在现代 Android 应用开发中，依赖注入（Dependency Injection, DI）已成为构建松耦合、可测试代码的重要技术。Koin 作为一个轻量级的Kotlin依赖注入框架，因其简洁的DSL和易用性深受开发者喜爱。最近对其源码进行学习了解，通过手写一个极度精简的 Koin 核心代码，来透彻理解Koin的注册、解析和参数传递机制。</p>\n<blockquote>\n<p><strong>本文代码基于 Koin 源码思想实现，仅用于学习核心原理，并非 Koin官 方代码。</strong></p>\n</blockquote>\n<h2 id=\"核心概念与项目结构\"><a href=\"#核心概念与项目结构\" class=\"headerlink\" title=\"核心概念与项目结构\"></a>核心概念与项目结构</h2><p>下图是基于 koin 4.1 解析的 主要类UML图，可以比较清晰地看看各个类之间的关系</p>\n<img src=\"https://cdn.julis.wang/blog/img/koin_uml.png\"> \n<p>power by <a href=\"https://www.mermaidchart.com/\">mermaidchart</a></p>\n<p>主要类：</p>\n<ul>\n<li><strong><code>KoinApplication</code></strong>: Koin启动的入口，负责初始化容器和加载模块。</li>\n<li><strong><code>Koin</code></strong>: 核心容器，持有实例注册表 InstanceRegistry 和作用域注册表 ScopeRegistry。</li>\n<li><strong><code>Module</code></strong>: 定义依赖的地方，存放了所有的 bean 定义 BeanDefinition 与 InstanceFactory。</li>\n<li><strong><code>BeanDefinition</code></strong>: 对一个依赖项的定义，包括其类型、限定符、所属作用域以及创建它的 lambda 表达式。</li>\n<li><strong><code>InstanceFactory</code></strong>: 负责根据 <code>BeanDefinition</code> 创建实例的核心工厂，分为 <code>SingleFactory</code> (单例)、<code>FactoryFactory</code> (工厂模式) 和 <code>ScopeFactory</code> (作用域内单例)。</li>\n<li><strong><code>Scope</code></strong>: 作用域，用于管理特定生命周期内的实例。</li>\n<li><strong><code>ParametersHolder</code></strong>: 参数容器，用于在获取实例时动态传递参数。</li>\n</ul>\n<h2 id=\"手写-koin-代码介绍\"><a href=\"#手写-koin-代码介绍\" class=\"headerlink\" title=\"手写 koin 代码介绍\"></a>手写 koin 代码介绍</h2><p>基于对源码的理解和参考，实现了 koin 的基本功能，整体分成三部分：简单 single 数据存取、包含 scope 能力、动态参数能力，分成三个文件夹，顺序123是基于前面带代码累加的。</p>\n<p><strong>简单 single 数据存取</strong><br>代码实现在：<a href=\"https://github.com/VomPom/JProject/blob/master/app/src/main/java/wang/julis/jproject/example/source/koin/noScope1/KoinWithoutScope.kt\">KoinWithoutScope.kt</a></p>\n<p>这是一份最简单的代码，大概200行不到，基本上包含了 koin 的核心思想：启动时注册组件定义。解析时，先查作用域缓存，命中则直接返回。未命中则递归解析其依赖项，调用工厂函数创建实例，最后返回实例。</p>\n<p>从这也能看出来 koin 的缺点：Koin 启动时 (startKoin) 需要将所有模块的定义 (BeanDefinition) 注册到容器中。实例数量过多会显著增加启动注册过程的耗时，影响应用启动速度。由于每个实例都会对应一个 BeanDefinition 以及 Factory ，内存占用会相应地上升。</p>\n<p>整个流程简单来讲就是生成一个 map，通过 key 获取对于的数据。</p>\n<p><strong>Scope 能力</strong><br>代码实现在：<a href=\"https://github.com/VomPom/JProject/blob/master/app/src/main/java/wang/julis/jproject/example/source/koin/scope2/KoinWithScope.kt\">KoinWithScope.kt</a></p>\n<p>这一份是在之前的能力上进行添加，此前将所有的数据都注册到 “root” 这个容器内，全局通用，但为了将不同作用域分开，需要引入 scope 的概念。</p>\n<p>简单理解就是在通过 key 获取的 map 里面的数据的时候，这个 key 是有一定的规则的，核心逻辑在这里：<br> <figure class=\"highlight kotlin\"><table><tr><td class=\"code\"><pre><span class=\"line\"> <span class=\"keyword\">inline</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">indexKey</span><span class=\"params\">(clazz: <span class=\"type\">KClass</span>&lt;*&gt;, typeQualifier: <span class=\"type\">String</span>?, scopeQualifier: <span class=\"type\">String</span>)</span></span>: String &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> buildString &#123;</span><br><span class=\"line\">        append(clazz.java.name)</span><br><span class=\"line\">        append(<span class=\"string\">&#x27;:&#x27;</span>)</span><br><span class=\"line\">        append(typeQualifier ?: <span class=\"string\">&quot;&quot;</span>)</span><br><span class=\"line\">        append(<span class=\"string\">&#x27;:&#x27;</span>)</span><br><span class=\"line\">        append(scopeQualifier)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br> 不同的 scope 实际上也就是获取的 key 值的不同。</p>\n<p><strong>动态参数能力</strong><br>代码实现在：<a href=\"https://github.com/VomPom/JProject/blob/master/app/src/main/java/wang/julis/jproject/example/source/koin/parameter3/KoinWithParameter.kt\">KoinWithParameter.kt</a></p>\n<p>最后在 scope 的基础上实现了一个比较重要的能力-动态参数能力，通过这个能力可以让有实例能够在运行的时候根据参数动态创建。这个能力也是像在安卓 Activity&#x2F;Fragment 里面 viewmodel() 实现依赖注入的必要实现。 </p>\n<p>简单理解就是在 get() 的时候将参数传入到获取实例的调用链中，在运行时执行注册的 Lambda 函数invoke时候将作为参数传递到构造方法中去。这里单独拎出来实现是因为这个参数传递影响到整个流程的逻辑，为了上上面的两个能力逻辑更简单清晰，单独在这一部分实现。</p>\n<h2 id=\"Koin-的注册流程（Declaration）\"><a href=\"#Koin-的注册流程（Declaration）\" class=\"headerlink\" title=\"Koin 的注册流程（Declaration）\"></a>Koin 的注册流程（Declaration）</h2><p>注册是DI容器工作的第一步。通过 <code>startKoin</code> 和 <code>module</code> DSL来声明依赖。</p>\n<h3 id=\"启动-Koin-与模块加载\"><a href=\"#启动-Koin-与模块加载\" class=\"headerlink\" title=\"启动 Koin 与模块加载\"></a>启动 Koin 与模块加载</h3><p>整个启动加载流程将 kotlin 的语法糖用到了极致，也就使得整个代码看起来是如此的简洁。</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> myApp = startKoin &#123;</span><br><span class=\"line\">    modules(appModule)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 定义一个模块</span></span><br><span class=\"line\"><span class=\"keyword\">val</span> appModule = module &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 注册一个单例，其构造需要一個 Int 参数</span></span><br><span class=\"line\">    single &#123; (<span class=\"keyword\">data</span>: <span class=\"built_in\">Int</span>) -&gt; ComponentInt(<span class=\"keyword\">data</span>) &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 注册一个工厂（每次获取都是新实例），其构造需要 Int 和 Float 参数</span></span><br><span class=\"line\">    factory &#123; (data1: <span class=\"built_in\">Int</span>, data2: <span class=\"built_in\">Float</span>) -&gt; ComponentIntFloat(data1, data2) &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>流程剖析：</strong></p>\n<p><strong><code>startKoin</code></strong><br>这是一个顶级函数，它调用 <code>GlobalContext.startKoin</code>，创建并初始化一个 <code>KoinApplication</code> 对象。</p>\n<p><strong><code>modules(...)</code></strong><br><code>KoinApplication</code> 的方法，它将传入的 <code>Module</code> 列表交给 <code>Koin</code> 实例的 <code>loadModels</code> 方法处理。</p>\n<p><strong><code>module &#123; ... &#125;</code></strong><br>DSL函数，它创建一个 <code>Module</code> 对象，并执行其中的配置lambda。</p>\n<p><strong><code>single/factory/scope</code></strong><br><code>Module</code> 的扩展函数。它们的作用是：</p>\n<ul>\n<li>使用 <code>_createDefinition</code> 将 lambda 表达式包装成一个 <code>BeanDefinition</code>对象。</li>\n<li>使用 <code>_InstanceFactory</code> 将 <code>BeanDefinition</code> 包装成对应的 <code>InstanceFactory</code>。</li>\n<li>调用 <code>indexPrimaryType</code>，生成一个<strong>唯一的Key</strong>（格式：<code>类名:限定符:作用域</code>），并将 <code>Factory</code> 存入 <code>Module.mappings</code> 这个 <code>HashMap</code> 中。</li>\n</ul>\n<p><strong>最终存储</strong><br><code>Koin</code> 的 <code>InstanceRegistry</code> 会遍历所有 <code>Module</code>，将它们 <code>mappings</code> 中的全部 <code>Factory</code> 都合并到自己的 <code>_instances</code>（一个 <code>ConcurrentHashMap</code>）中。</p>\n<p>至此，所有依赖的定义都已注册到容器中，静待获取。</p>\n<h2 id=\"Koin的实例获取流程（Retrieval）\"><a href=\"#Koin的实例获取流程（Retrieval）\" class=\"headerlink\" title=\"Koin的实例获取流程（Retrieval）\"></a>Koin的实例获取流程（Retrieval）</h2><figure class=\"highlight kotlin\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 获取无参依赖（普通方式）</span></span><br><span class=\"line\"><span class=\"keyword\">val</span> component = <span class=\"keyword\">get</span>&lt;Component&gt;()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 通过 scope 作用域限定进行获取</span></span><br><span class=\"line\"><span class=\"keyword\">val</span> scope = koin.createScope(<span class=\"string\">&quot;scope&quot;</span>, scopeQualifier)</span><br><span class=\"line\"><span class=\"keyword\">val</span> component = scope.<span class=\"keyword\">get</span>&lt;Component&gt;()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 通过需要动态参数的获取</span></span><br><span class=\"line\"><span class=\"keyword\">val</span> componentWithArgs = <span class=\"keyword\">get</span>&lt;ComponentInt&gt; &#123; parametersOf(<span class=\"number\">42</span>) &#125;</span><br><span class=\"line\"><span class=\"keyword\">val</span> componentWithMultiArgs = <span class=\"keyword\">get</span>&lt;ComponentIntFloat&gt; &#123; parametersOf(<span class=\"number\">101</span>, <span class=\"number\">3.14f</span>) &#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"流程剖析\"><a href=\"#流程剖析\" class=\"headerlink\" title=\"流程剖析\"></a>流程剖析</h3><p><strong><code>Scope.get&lt;T&gt;</code></strong></p>\n<p>这是 <code>Scope</code> 的一个扩展函数。它首先创建一个 <code>ResolutionContext</code>，封装了当前作用域、要解析的类型、限定符以及最重要的——<strong>参数持有器 <code>ParametersHolder</code></strong>（由 <code>parametersOf</code> 函数创建）。</p>\n<p> <strong>解析上下文（ResolutionContext）</strong></p>\n<p> 这个上下文对象包含了解析一个实例所需的所有信息。</p>\n<p><strong>核心解析器（CoreResolver）</strong><br><code>get</code> 操作会委托给 <code>Koin</code> 的 <code>CoreResolver</code>进行处理。源码里面对于查找顺序有非常清晰的层次体现：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"type\">&lt;T&gt;</span> <span class=\"title\">resolveFromContext</span><span class=\"params\">(scope : <span class=\"type\">Scope</span>, instanceContext: <span class=\"type\">ResolutionContext</span>)</span></span>: T &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> resolveFromContextOrNull(scope,instanceContext) ?: throwNoDefinitionFound(instanceContext)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"type\">&lt;T&gt;</span> <span class=\"title\">resolveFromContextOrNull</span><span class=\"params\">(scope : <span class=\"type\">Scope</span>, instanceContext: <span class=\"type\">ResolutionContext</span>, lookupParent : <span class=\"type\">Boolean</span> = <span class=\"literal\">true</span>)</span></span>: T? &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> resolveFromInjectedParameters(instanceContext)</span><br><span class=\"line\">          ?: resolveFromRegistry(scope,instanceContext)</span><br><span class=\"line\">          ?: resolveFromStackedParameters(scope,instanceContext)</span><br><span class=\"line\">          ?: resolveFromScopeSource(scope,instanceContext)</span><br><span class=\"line\">          ?: resolveFromScopeArchetype(scope,instanceContext)</span><br><span class=\"line\">          ?: <span class=\"keyword\">if</span> (lookupParent) resolveFromParentScopes(scope,instanceContext) <span class=\"keyword\">else</span> <span class=\"literal\">null</span></span><br><span class=\"line\">          ?: resolveInExtensions(scope,instanceContext)</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n\n<p> <strong>查找工厂</strong></p>\n<ul>\n<li><code>Resolver</code> 会调用 <code>InstanceRegistry.resolveDefinition</code>。</li>\n<li>该方法使用和注册时<strong>相同的算法</strong>生成Key（类名:限定符:作用域），然后从 <code>_instances</code> 中查找对应的 <code>InstanceFactory</code>。</li>\n</ul>\n<p> <strong>创建实例</strong></p>\n<ul>\n<li><p>找到 <code>Factory</code> 后，调用其 <code>get(context: ResolutionContext)</code> 方法。</p>\n</li>\n<li><p><code>Factory</code> 会调用自己的 <code>create</code> 方法。<strong>关键一步来了</strong>：在 <code>create</code> 方法中，会执行 <code>BeanDefinition.definition.invoke(context.scope, parameters)</code>。这其实就是执行了之前注册的 lambda：<code>&#123; (data: Int) -&gt; ComponentInt(data) &#125;</code>。</p>\n</li>\n<li><p><strong>参数传递</strong>：这里的 <code>parameters</code> 就是在 <code>get</code> 时传入的 <code>ParametersHolder</code>。Lambda 的参数 <code>(data: Int)</code> 会从 <code>ParametersHolder</code> 中按顺序（或使用解构）取出值</p>\n</li>\n</ul>\n<p><strong>返回实例</strong></p>\n<p>工厂将创建好的实例返回给调用者。</p>\n<p>对于 <code>SingleFactory</code>，它会将第一次创建出来的实例缓存起来，后续调用直接返回缓存实例。<code>FactoryFactory</code> 则每次都会执行 <code>create</code> 方法。</p>\n<h2 id=\"其他技术\"><a href=\"#其他技术\" class=\"headerlink\" title=\"其他技术\"></a>其他技术</h2><h3 id=\"DslMarker-的作用\"><a href=\"#DslMarker-的作用\" class=\"headerlink\" title=\"@DslMarker 的作用\"></a>@DslMarker 的作用</h3><p>在实现的过程中发现如下图所示：koin 的代码有颜色分层，能比较清晰地看到各个 block 之间的差异，自己写的代码全部是白色。</p>\n<img src=\"https://cdn.julis.wang/blog/img/koin_color_contrast.png\"> \n\n\n<p>代码开头定义了三个注解：<code>@KoinApplicationDslMarker</code>, <code>@KoinDslMarker</code>, <code>@OptionDslMarker</code>。这是Kotlin DSL的<strong>安全卫士</strong>。</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@DslMarker</span></span><br><span class=\"line\"><span class=\"keyword\">annotation</span> <span class=\"keyword\">class</span> <span class=\"title class_\">KoinDslMarker</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@KoinDslMarker</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Module</span> &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">single</span><span class=\"params\">(...)</span></span> &#123; ... &#125; <span class=\"comment\">// 这个single在DSL里</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@KoinDslMarker</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">KoinApplication</span> &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">modules</span><span class=\"params\">(...)</span></span> &#123; ... &#125; <span class=\"comment\">// 这个modules在DSL里</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">test</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    startKoin &#123;</span><br><span class=\"line\">        modules(...) <span class=\"comment\">// 正确：在 KoinApplication 的 lambda 里</span></span><br><span class=\"line\">        single &#123; ... &#125; <span class=\"comment\">// 编译错误！@DslMarker 阻止了隐式地使用外部 Receiver (Module)</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>@DslMarker</code> 实际的作用是防止在嵌套的DSL Lambda中，意外地调用到外层 Receiver 的方法，从而让DSL书写更加清晰和安全。代码颜色是由 IDE 提供的效果。在代码中加上几个注解之后，效果如图所示：</p>\n<img src=\"https://cdn.julis.wang/blog/img/koin_color_annotation.png\"> \n<p>跟 koin 的颜色不太一致，不过能明显看到代码有分层，应该是由于 koin 对 annotation 也有处理，这里没有再深入研究。</p>\n<h3 id=\"2-优雅的参数传递与解构\"><a href=\"#2-优雅的参数传递与解构\" class=\"headerlink\" title=\"2. 优雅的参数传递与解构\"></a>2. 优雅的参数传递与解构</h3><p>这个逻辑复刻了Koin的动态参数特性。</p>\n<ul>\n<li><strong><code>ParametersHolder</code></strong>：一个轻量的参数容器，内部用一个 <code>List&lt;Any?&gt;</code> 存储参数。</li>\n<li><strong><code>parametersOf</code></strong>：辅助函数，优雅地创建 <code>ParametersHolder</code>。</li>\n<li><strong>解构声明（Destructuring Declaration）</strong>：<code>ParametersHolder</code> 重写了 <code>component1()</code> 到 <code>component5()</code> 操作符。这使得在定义lambda时，可以直接用 <code>(a: A, b: B)</code> 的形式来接收参数，而不是手动调用 <code>parameters.get&lt;X&gt;(0)</code>。</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 注册端：看起来就像普通函数</span></span><br><span class=\"line\">single &#123; (id: <span class=\"built_in\">Int</span>, name: String) -&gt; User(id, name) &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 获取端：传递参数非常直观</span></span><br><span class=\"line\"><span class=\"keyword\">val</span> user = <span class=\"keyword\">get</span>&lt;User&gt; &#123; parametersOf(<span class=\"number\">123</span>, <span class=\"string\">&quot;Julius&quot;</span>) &#125;</span><br></pre></td></tr></table></figure>\n<p>这种设计极大地提升了API的简洁性和可读性。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>通过这个手写的迷你Koin，可以深刻地理解到，一个现代DI容器的核心无非是解决两个问题：</p>\n<ol>\n<li><strong>如何注册（Declaration）</strong>：通过DSL将依赖的创建方式（Lambda）以键值对的形式保存到一个全局的注册表中。</li>\n<li><strong>如何获取（Retrieval）</strong>：根据请求的类型、限定符和作用域生成Key，从注册表中找到对应的创建工厂，并调用它来生成实例。支持通过参数容器实现动态传参。</li>\n</ol>\n<p>除此之外，诸如 <code>@DslMarker</code> 保证DSL安全、<strong>解构</strong>实现参数优雅传递，都是构建一个健壮、易用框架的关键技术。</p>\n<p>虽然这个实现省略了Koin的许多高级功能（如完整的Scope生命周期管理、属性注入、Android特定支持等），但它已经囊括了最核心、最精妙的设计思想，再理解其他的模块也会简单很多。</p>\n<p>实现的所有源码位于：<a href=\"https://github.com/VomPom/JProject/tree/master/app/src/main/java/wang/julis/jproject/example/source/koin\">JProject&#x2F;source&#x2F;koin</a></p>\n","categories":[{"name":"技术文章","slug":"technology","api":"api/categories/technology.json"}],"tags":[{"name":"koin","slug":"koin","api":"api/tags/koin.json"}],"api":"api/posts/2025/08/25/Koin-源码理解相关.json"},{"title":"[Compose Multiplatform]跨平台博客应用实践","slug":"Compose-Multiplatform-跨平台博客应用实践","date":"2025-07-28T12:28:00.000Z","updated":"2025-07-28T14:51:23.535Z","comments":true,"url":"2025/07/28/Compose-Multiplatform-跨平台博客应用实践/","excerpt":"<h2 id=\"用-CMP-构建跨平台博客应用：一次-Kotlin-的全栈实践\"><a href=\"#用-CMP-构建跨平台博客应用：一次-Kotlin-的全栈实践\" class=\"headerlink\" title=\"用 CMP 构建跨平台博客应用：一次 Kotlin 的全栈实践\"></a>用 CMP 构建跨平台博客应用：一次 Kotlin 的全栈实践</h2><p>在追求高效开发的时代，跨平台技术已成为移动应用开发的主流选择，此前基于鸿蒙的开发平台开发 <a href=\"https://julis.wang/2025/05/16/%E9%B8%BF%E8%92%99-%E5%86%99%E4%BA%86%E4%B8%AA%E5%9F%BA%E4%BA%8EHexo%E5%8D%9A%E5%AE%A2%E7%9A%84%E9%B8%BF%E8%92%99App/\">blog_harmony</a>，将自己博客文章进行展示。本文将介绍基于 <strong>CMP(Compose Multiplatform)</strong> 构建的开源博客应用 <a href=\"https://github.com/VomPom/blog_kmp\">blog_kmp</a>，展示如何用 Kotlin 实现跨平台的应用开发。</p>\n<h3 id=\"Compose-Multiplatform\"><a href=\"#Compose-Multiplatform\" class=\"headerlink\" title=\"Compose Multiplatform\"></a>Compose Multiplatform</h3><p>Compose Multiplatform 是 JetBrains 推出的声明式 UI 框架，基于 Jetpack Compose 扩展而来：</p>\n<ul>\n<li><strong>核心优势</strong>：用同一套 Kotlin 代码构建 Android、iOS、Desktop 和 Web 应用</li>\n<li><strong>开发效率</strong>：实时预览、热重载加速开发迭代</li>\n<li><strong>原生性能</strong>：通过 Skia 渲染引擎实现接近原生体验</li>\n<li><strong>共享逻辑</strong>：业务逻辑、网络请求、状态管理可 100% 复用</li>\n</ul>\n<h3 id=\"项目架构与技术栈\"><a href=\"#项目架构与技术栈\" class=\"headerlink\" title=\"项目架构与技术栈\"></a>项目架构与技术栈</h3><p>blog_kmp 采用分层架构设计，核心模块包括：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"code\"><pre><span class=\"line\">shared/</span><br><span class=\"line\">├── src/commonMain/kotlin/  # 共享业务逻辑</span><br><span class=\"line\">│   ├── <span class=\"keyword\">data</span>/               # 数据层</span><br><span class=\"line\">│   ├── domain/             # 领域模型</span><br><span class=\"line\">│   └── presentation/       # UI状态管理</span><br><span class=\"line\">├── src/androidMain/        # Android 平台代码</span><br><span class=\"line\">└── src/iosMain/            # iOS 平台适配</span><br><span class=\"line\">├── composeApp</span><br><span class=\"line\">│   ├── build.gradle.kts</span><br><span class=\"line\">│   └── src</span><br><span class=\"line\">│       ├── androidMain     # Android 平台代码</span><br><span class=\"line\">│       ├── commonMain      # 共享业务逻辑</span><br><span class=\"line\">│            ├── App.kt     # 界面展示入口</span><br><span class=\"line\">│            ├── <span class=\"keyword\">data</span>       # 数据层</span><br><span class=\"line\">│            │   ├── api        # 网络请求</span><br><span class=\"line\">│            │   ├── di         # koin 依赖注入</span><br><span class=\"line\">│            │   ├── model      # model 数据</span><br><span class=\"line\">│            │   └── repository # 数据缓存管理</span><br><span class=\"line\">│            │</span><br><span class=\"line\">│            ├── navigation  # 页面间导航管理</span><br><span class=\"line\">│            ├── platform    # 通过对各个平台抽象的接口 </span><br><span class=\"line\">│            └── ui          # 通用 UI 逻辑</span><br><span class=\"line\">│</span><br><span class=\"line\">│       ├── desktopMain     # Desktop 平台适配</span><br><span class=\"line\">│       └── iosMain         # iOS 平台适配</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"功能预览\"><a href=\"#功能预览\" class=\"headerlink\" title=\"功能预览\"></a>功能预览</h2><h3 id=\"Android\"><a href=\"#Android\" class=\"headerlink\" title=\"Android\"></a>Android</h3><p><img src=\"https://cdn.julis.wang/github/blog_cmp/android.png\"></p>\n<h4 id=\"深色模式\"><a href=\"#深色模式\" class=\"headerlink\" title=\"深色模式\"></a>深色模式</h4><p><img src=\"https://cdn.julis.wang/github/blog_cmp/dark.png\"></p>\n<h3 id=\"iOS\"><a href=\"#iOS\" class=\"headerlink\" title=\"iOS\"></a>iOS</h3><p><img src=\"https://cdn.julis.wang/github/blog_cmp/ios.png\"></p>\n<h3 id=\"Desktop\"><a href=\"#Desktop\" class=\"headerlink\" title=\"Desktop\"></a>Desktop</h3><p><img src=\"https://cdn.julis.wang/github/blog_cmp/desktop.png\"></p>\n<h4 id=\"主要技术栈\"><a href=\"#主要技术栈\" class=\"headerlink\" title=\"主要技术栈\"></a>主要技术栈</h4><ol>\n<li><strong>Ktor 客户端</strong> - 网络请求</li>\n</ol>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> httpClient = HttpClient &#123;</span><br><span class=\"line\">    install(ContentNegotiation) &#123;</span><br><span class=\"line\">        json(Json &#123; ignoreUnknownKeys = <span class=\"literal\">true</span> &#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">suspend</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">loadPosts</span><span class=\"params\">()</span></span>: List&lt;Post&gt; = </span><br><span class=\"line\">    httpClient.<span class=\"keyword\">get</span>(<span class=\"string\">&quot;https://cdn.julis/api/posts&quot;</span>).body()</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li><strong>DataStore</strong> - 跨平台数据库</li>\n</ol>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> dataKey = stringPreferencesKey(key)</span><br><span class=\"line\"><span class=\"keyword\">val</span> result = dataStore.<span class=\"keyword\">data</span></span><br><span class=\"line\">    .<span class=\"keyword\">catch</span> &#123; exception -&gt;</span><br><span class=\"line\">        <span class=\"comment\">// dataStore.data throws an IOException when an error is encountered when reading data</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (exception <span class=\"keyword\">is</span> IOException) &#123;</span><br><span class=\"line\">            emit(emptyPreferences())</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> exception</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    .map &#123; preferences -&gt;</span><br><span class=\"line\">        <span class=\"keyword\">val</span> <span class=\"keyword\">data</span>: String? = preferences[dataKey]</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">data</span> == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"literal\">null</span></span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (isJson) Json.decodeFromString&lt;T&gt;(<span class=\"keyword\">data</span>) <span class=\"keyword\">else</span> (<span class=\"keyword\">data</span> <span class=\"keyword\">as</span> T)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li><strong>Koin</strong> - 依赖注入</li>\n</ol>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> sharedModule = module &#123;</span><br><span class=\"line\">    single&lt;PostRepository&gt; &#123; PostRepositoryImpl(<span class=\"keyword\">get</span>()) &#125;</span><br><span class=\"line\">    viewModel &#123; PostViewModel(<span class=\"keyword\">get</span>()) &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"4\">\n<li><strong>Kotlinx.Serialization</strong> - JSON 解析</li>\n</ol>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Serializable</span></span><br><span class=\"line\"><span class=\"keyword\">data</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Post</span>(</span><br><span class=\"line\">    <span class=\"keyword\">val</span> id: String,</span><br><span class=\"line\">    <span class=\"keyword\">val</span> title: String,</span><br><span class=\"line\">    <span class=\"keyword\">val</span> content: String</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n\n<ol start=\"5\">\n<li><strong>compose-webview-multiplatform</strong> - WebView 浏览器<br>使用的第三方开发<a href=\"https://github.com/KevinnZou/compose-webview-multiplatform\">compose-webview-multiplatform</a>基于 <a href=\"https://github.com/chromiumembedded/java-cef\">java-cef</a>开发，不过这个library 在 desktop 平台表现不是太好，待完善。</li>\n</ol>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> state = rememberWebViewState(postUrl)</span><br><span class=\"line\"> WebView(state = state,modifier = Modifier.fillMaxSize())            </span><br></pre></td></tr></table></figure>\n\n\n<h3 id=\"平台特定实现\"><a href=\"#平台特定实现\" class=\"headerlink\" title=\"平台特定实现\"></a>平台特定实现</h3><p>UI 层面三端能够使用同一份代码，但为了体验，可能需要针对不同的设计，在桌面端可以设计更好地体验UI。这里避免不了 if-else 的UI逻辑，以及一些依赖各种系统的 api 需要单独实现，比如：深色模式监听、资源存储路径、系统信息、状态栏颜色等。</p>\n<p><strong>Android 端</strong><br>Android 特定的功能结合使用起来非常的简单，毕竟都是有血缘关系的。可以使用 AndroidView 直接渲染原生的 UI 页面。</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"code\"><pre><span class=\"line\">AndroidView(</span><br><span class=\"line\">      modifier = Modifier.fillMaxSize(),</span><br><span class=\"line\">      factory = &#123; context -&gt;</span><br><span class=\"line\">          MyView(context) &#125;</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      update = &#123; view -&gt;&#125;</span><br><span class=\"line\">  )</span><br></pre></td></tr></table></figure>\n\n<p><strong>iOS 端</strong><br>iOS端主要需要 XCode 进行配合，还需要关注开发者账号相关的信息等，其他与 Android 端实现没有太大的差异。</p>\n<p><strong>桌面端</strong><br>利用 Compose Desktop 的窗口管理，可以实现窗口多开。</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> = application &#123;</span><br><span class=\"line\">    Window(onCloseRequest = ::exitApplication) &#123;</span><br><span class=\"line\">        DesktopAppTheme &#123; AppContent() &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<h3 id=\"🚀-性能优化实践\"><a href=\"#🚀-性能优化实践\" class=\"headerlink\" title=\"🚀 性能优化实践\"></a>🚀 性能优化实践</h3><ol>\n<li><strong>分页加载</strong>：实现懒加载防止长列表卡顿</li>\n</ol>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"code\"><pre><span class=\"line\">LazyColumn &#123;</span><br><span class=\"line\">    itemsIndexed(posts) &#123; _, post -&gt;</span><br><span class=\"line\">        PostItem(post)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    item &#123; <span class=\"keyword\">if</span> (loading) LoadingIndicator() &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li><strong>本地缓存</strong>：DataStore 离线存储 + Ktor 缓存策略</li>\n</ol>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"code\"><pre><span class=\"line\">HttpClient &#123;</span><br><span class=\"line\">    install(HttpCache) <span class=\"comment\">// 启用 HTTP 缓存</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li><strong>图像处理</strong>：搭配 Coil 实现高效图片加载</li>\n</ol>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"code\"><pre><span class=\"line\">AsyncImage(</span><br><span class=\"line\">    modifier = Modifier.size(<span class=\"number\">80.</span>dp)</span><br><span class=\"line\">        .shadow(</span><br><span class=\"line\">            elevation = <span class=\"number\">5.</span>dp,</span><br><span class=\"line\">            shape = CircleShape,</span><br><span class=\"line\">            spotColor = Color.Black</span><br><span class=\"line\">        )</span><br><span class=\"line\">        .clip(CircleShape)</span><br><span class=\"line\">        .clickable &#123; &#125;,</span><br><span class=\"line\">    model = AppConfig.AVATAR,</span><br><span class=\"line\">    contentDescription = AppConfig.AVATAR,</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n<h3 id=\"开发经验总结\"><a href=\"#开发经验总结\" class=\"headerlink\" title=\"开发经验总结\"></a>开发经验总结</h3><ol>\n<li><p><strong>UI界面</strong><br>  使用 <a href=\"https://developer.android.com/compose\">Compose</a> 进行界面布局开发，声明性编程范式相比于传统的 xml 布局开发，高效很多，使用也很方便。使用了这种方式，传统的 UI 开发方式再也回不去了。</p>\n</li>\n<li><p><strong>状态管理</strong><br>使用 <code>mutableStateOf</code> 实现响应式更新，或者使用 <code>derivedStateOf</code> 实现派生状态的处理。</p>\n</li>\n</ol>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> pagIndex <span class=\"keyword\">by</span> remember &#123; mutableStateOf(<span class=\"number\">0</span>) &#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> errorState <span class=\"keyword\">by</span> remember &#123; mutableStateOf&lt;String?&gt;(<span class=\"literal\">null</span>) &#125;   </span><br><span class=\"line\"><span class=\"keyword\">val</span> themeState <span class=\"keyword\">by</span> mineViewModel.appTheme.collectAsState()</span><br><span class=\"line\"><span class=\"keyword\">val</span> uiChecked <span class=\"keyword\">by</span> remember(themeState) &#123; derivedStateOf &#123; themeState == ThemeConstants.DARK &#125; &#125;</span><br></pre></td></tr></table></figure>\n\n\n<ol start=\"3\">\n<li><strong>导航</strong></li>\n</ol>\n<p>实现 <code>Compose Navigator</code> 统一路由管理</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> gotoDebug: () -&gt; <span class=\"built_in\">Unit</span> = &#123;</span><br><span class=\"line\">    navController.navigate(Routes.Debug())</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">val</span> goToPostDetail: (Post) -&gt; <span class=\"built_in\">Unit</span> = &#123; it -&gt;</span><br><span class=\"line\">    navController.navigate(Routes.PostDetail(title = it.title, it.url))</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ol start=\"4\">\n<li><strong>Kotlin Flow</strong><br>简化异步编程，让网络请求的代码看起来更直观</li>\n</ol>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">loadAllPost</span><span class=\"params\">()</span></span>: Flow&lt;List&lt;PostV2&gt;&gt; = load(<span class=\"string\">&quot;allPosts&quot;</span>) &#123;</span><br><span class=\"line\">    postApi.getAllPost()?.<span class=\"keyword\">data</span> ?: emptyList()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">suspend</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">getAllPost</span><span class=\"params\">()</span></span>: SearchResponse? = request&lt;SearchResponse&gt;(getUrl(<span class=\"string\">&quot;api/search.json&quot;</span>))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">suspend</span> <span class=\"keyword\">inline</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"type\">&lt;<span class=\"keyword\">reified</span> T&gt;</span> <span class=\"title\">request</span><span class=\"params\">(url: <span class=\"type\">String</span>)</span></span>: T? &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        client.<span class=\"keyword\">get</span>(url).body()</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (e: Exception) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (e <span class=\"keyword\">is</span> CancellationException) <span class=\"keyword\">throw</span> e</span><br><span class=\"line\">        e.printStackTrace()</span><br><span class=\"line\">        <span class=\"literal\">null</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>经过一番各种折腾，将很多在工作上无法使用的能力（Koin、Flow、DataStore……）都体验使用了一下，在业余的时间完成了基于博客文章构建的 App 在三个平台上的开发，实际上最初我也想搭建 WebJs 的平台的，后面删除掉了，因为涉及到 web 平台开发的各种库相比客户端少很多，兼容起来也比较费劲。KMP&#x2F;CMP 这块技术确实是能很大地节省开发人力，多端使用同一份UI逻辑代码，部分逻辑也可以用 kotlin 统一进行封装，后续维护也会方便很多。但这里有个缺点就是涉及到的库所需要的 kotlin&#x2F;Java 版本要求比较高，除非开发一些独立的 App，否则公司里的项目想基于这些技术去实现不太大可能。以及如果所需要的能力比较依赖与原生，比如音视频领域就有一定的局限性，总体来讲更适合偏交互业务的开发。</p>\n<p><strong>项目源码</strong>: <a href=\"https://github.com/VomPom/blog_kmp\">https://github.com/VomPom/blog_kmp</a>  </p>\n","cover":null,"images":["https://cdn.julis.wang/github/blog_cmp/android.png","https://cdn.julis.wang/github/blog_cmp/dark.png","https://cdn.julis.wang/github/blog_cmp/ios.png","https://cdn.julis.wang/github/blog_cmp/desktop.png"],"content":"<h2 id=\"用-CMP-构建跨平台博客应用：一次-Kotlin-的全栈实践\"><a href=\"#用-CMP-构建跨平台博客应用：一次-Kotlin-的全栈实践\" class=\"headerlink\" title=\"用 CMP 构建跨平台博客应用：一次 Kotlin 的全栈实践\"></a>用 CMP 构建跨平台博客应用：一次 Kotlin 的全栈实践</h2><p>在追求高效开发的时代，跨平台技术已成为移动应用开发的主流选择，此前基于鸿蒙的开发平台开发 <a href=\"https://julis.wang/2025/05/16/%E9%B8%BF%E8%92%99-%E5%86%99%E4%BA%86%E4%B8%AA%E5%9F%BA%E4%BA%8EHexo%E5%8D%9A%E5%AE%A2%E7%9A%84%E9%B8%BF%E8%92%99App/\">blog_harmony</a>，将自己博客文章进行展示。本文将介绍基于 <strong>CMP(Compose Multiplatform)</strong> 构建的开源博客应用 <a href=\"https://github.com/VomPom/blog_kmp\">blog_kmp</a>，展示如何用 Kotlin 实现跨平台的应用开发。</p>\n<h3 id=\"Compose-Multiplatform\"><a href=\"#Compose-Multiplatform\" class=\"headerlink\" title=\"Compose Multiplatform\"></a>Compose Multiplatform</h3><p>Compose Multiplatform 是 JetBrains 推出的声明式 UI 框架，基于 Jetpack Compose 扩展而来：</p>\n<ul>\n<li><strong>核心优势</strong>：用同一套 Kotlin 代码构建 Android、iOS、Desktop 和 Web 应用</li>\n<li><strong>开发效率</strong>：实时预览、热重载加速开发迭代</li>\n<li><strong>原生性能</strong>：通过 Skia 渲染引擎实现接近原生体验</li>\n<li><strong>共享逻辑</strong>：业务逻辑、网络请求、状态管理可 100% 复用</li>\n</ul>\n<h3 id=\"项目架构与技术栈\"><a href=\"#项目架构与技术栈\" class=\"headerlink\" title=\"项目架构与技术栈\"></a>项目架构与技术栈</h3><p>blog_kmp 采用分层架构设计，核心模块包括：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"code\"><pre><span class=\"line\">shared/</span><br><span class=\"line\">├── src/commonMain/kotlin/  # 共享业务逻辑</span><br><span class=\"line\">│   ├── <span class=\"keyword\">data</span>/               # 数据层</span><br><span class=\"line\">│   ├── domain/             # 领域模型</span><br><span class=\"line\">│   └── presentation/       # UI状态管理</span><br><span class=\"line\">├── src/androidMain/        # Android 平台代码</span><br><span class=\"line\">└── src/iosMain/            # iOS 平台适配</span><br><span class=\"line\">├── composeApp</span><br><span class=\"line\">│   ├── build.gradle.kts</span><br><span class=\"line\">│   └── src</span><br><span class=\"line\">│       ├── androidMain     # Android 平台代码</span><br><span class=\"line\">│       ├── commonMain      # 共享业务逻辑</span><br><span class=\"line\">│            ├── App.kt     # 界面展示入口</span><br><span class=\"line\">│            ├── <span class=\"keyword\">data</span>       # 数据层</span><br><span class=\"line\">│            │   ├── api        # 网络请求</span><br><span class=\"line\">│            │   ├── di         # koin 依赖注入</span><br><span class=\"line\">│            │   ├── model      # model 数据</span><br><span class=\"line\">│            │   └── repository # 数据缓存管理</span><br><span class=\"line\">│            │</span><br><span class=\"line\">│            ├── navigation  # 页面间导航管理</span><br><span class=\"line\">│            ├── platform    # 通过对各个平台抽象的接口 </span><br><span class=\"line\">│            └── ui          # 通用 UI 逻辑</span><br><span class=\"line\">│</span><br><span class=\"line\">│       ├── desktopMain     # Desktop 平台适配</span><br><span class=\"line\">│       └── iosMain         # iOS 平台适配</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"功能预览\"><a href=\"#功能预览\" class=\"headerlink\" title=\"功能预览\"></a>功能预览</h2><h3 id=\"Android\"><a href=\"#Android\" class=\"headerlink\" title=\"Android\"></a>Android</h3><p><img src=\"https://cdn.julis.wang/github/blog_cmp/android.png\"></p>\n<h4 id=\"深色模式\"><a href=\"#深色模式\" class=\"headerlink\" title=\"深色模式\"></a>深色模式</h4><p><img src=\"https://cdn.julis.wang/github/blog_cmp/dark.png\"></p>\n<h3 id=\"iOS\"><a href=\"#iOS\" class=\"headerlink\" title=\"iOS\"></a>iOS</h3><p><img src=\"https://cdn.julis.wang/github/blog_cmp/ios.png\"></p>\n<h3 id=\"Desktop\"><a href=\"#Desktop\" class=\"headerlink\" title=\"Desktop\"></a>Desktop</h3><p><img src=\"https://cdn.julis.wang/github/blog_cmp/desktop.png\"></p>\n<h4 id=\"主要技术栈\"><a href=\"#主要技术栈\" class=\"headerlink\" title=\"主要技术栈\"></a>主要技术栈</h4><ol>\n<li><strong>Ktor 客户端</strong> - 网络请求</li>\n</ol>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> httpClient = HttpClient &#123;</span><br><span class=\"line\">    install(ContentNegotiation) &#123;</span><br><span class=\"line\">        json(Json &#123; ignoreUnknownKeys = <span class=\"literal\">true</span> &#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">suspend</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">loadPosts</span><span class=\"params\">()</span></span>: List&lt;Post&gt; = </span><br><span class=\"line\">    httpClient.<span class=\"keyword\">get</span>(<span class=\"string\">&quot;https://cdn.julis/api/posts&quot;</span>).body()</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li><strong>DataStore</strong> - 跨平台数据库</li>\n</ol>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> dataKey = stringPreferencesKey(key)</span><br><span class=\"line\"><span class=\"keyword\">val</span> result = dataStore.<span class=\"keyword\">data</span></span><br><span class=\"line\">    .<span class=\"keyword\">catch</span> &#123; exception -&gt;</span><br><span class=\"line\">        <span class=\"comment\">// dataStore.data throws an IOException when an error is encountered when reading data</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (exception <span class=\"keyword\">is</span> IOException) &#123;</span><br><span class=\"line\">            emit(emptyPreferences())</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> exception</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    .map &#123; preferences -&gt;</span><br><span class=\"line\">        <span class=\"keyword\">val</span> <span class=\"keyword\">data</span>: String? = preferences[dataKey]</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">data</span> == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"literal\">null</span></span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (isJson) Json.decodeFromString&lt;T&gt;(<span class=\"keyword\">data</span>) <span class=\"keyword\">else</span> (<span class=\"keyword\">data</span> <span class=\"keyword\">as</span> T)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li><strong>Koin</strong> - 依赖注入</li>\n</ol>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> sharedModule = module &#123;</span><br><span class=\"line\">    single&lt;PostRepository&gt; &#123; PostRepositoryImpl(<span class=\"keyword\">get</span>()) &#125;</span><br><span class=\"line\">    viewModel &#123; PostViewModel(<span class=\"keyword\">get</span>()) &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"4\">\n<li><strong>Kotlinx.Serialization</strong> - JSON 解析</li>\n</ol>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Serializable</span></span><br><span class=\"line\"><span class=\"keyword\">data</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Post</span>(</span><br><span class=\"line\">    <span class=\"keyword\">val</span> id: String,</span><br><span class=\"line\">    <span class=\"keyword\">val</span> title: String,</span><br><span class=\"line\">    <span class=\"keyword\">val</span> content: String</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n\n<ol start=\"5\">\n<li><strong>compose-webview-multiplatform</strong> - WebView 浏览器<br>使用的第三方开发<a href=\"https://github.com/KevinnZou/compose-webview-multiplatform\">compose-webview-multiplatform</a>基于 <a href=\"https://github.com/chromiumembedded/java-cef\">java-cef</a>开发，不过这个library 在 desktop 平台表现不是太好，待完善。</li>\n</ol>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> state = rememberWebViewState(postUrl)</span><br><span class=\"line\"> WebView(state = state,modifier = Modifier.fillMaxSize())            </span><br></pre></td></tr></table></figure>\n\n\n<h3 id=\"平台特定实现\"><a href=\"#平台特定实现\" class=\"headerlink\" title=\"平台特定实现\"></a>平台特定实现</h3><p>UI 层面三端能够使用同一份代码，但为了体验，可能需要针对不同的设计，在桌面端可以设计更好地体验UI。这里避免不了 if-else 的UI逻辑，以及一些依赖各种系统的 api 需要单独实现，比如：深色模式监听、资源存储路径、系统信息、状态栏颜色等。</p>\n<p><strong>Android 端</strong><br>Android 特定的功能结合使用起来非常的简单，毕竟都是有血缘关系的。可以使用 AndroidView 直接渲染原生的 UI 页面。</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"code\"><pre><span class=\"line\">AndroidView(</span><br><span class=\"line\">      modifier = Modifier.fillMaxSize(),</span><br><span class=\"line\">      factory = &#123; context -&gt;</span><br><span class=\"line\">          MyView(context) &#125;</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      update = &#123; view -&gt;&#125;</span><br><span class=\"line\">  )</span><br></pre></td></tr></table></figure>\n\n<p><strong>iOS 端</strong><br>iOS端主要需要 XCode 进行配合，还需要关注开发者账号相关的信息等，其他与 Android 端实现没有太大的差异。</p>\n<p><strong>桌面端</strong><br>利用 Compose Desktop 的窗口管理，可以实现窗口多开。</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> = application &#123;</span><br><span class=\"line\">    Window(onCloseRequest = ::exitApplication) &#123;</span><br><span class=\"line\">        DesktopAppTheme &#123; AppContent() &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<h3 id=\"🚀-性能优化实践\"><a href=\"#🚀-性能优化实践\" class=\"headerlink\" title=\"🚀 性能优化实践\"></a>🚀 性能优化实践</h3><ol>\n<li><strong>分页加载</strong>：实现懒加载防止长列表卡顿</li>\n</ol>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"code\"><pre><span class=\"line\">LazyColumn &#123;</span><br><span class=\"line\">    itemsIndexed(posts) &#123; _, post -&gt;</span><br><span class=\"line\">        PostItem(post)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    item &#123; <span class=\"keyword\">if</span> (loading) LoadingIndicator() &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li><strong>本地缓存</strong>：DataStore 离线存储 + Ktor 缓存策略</li>\n</ol>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"code\"><pre><span class=\"line\">HttpClient &#123;</span><br><span class=\"line\">    install(HttpCache) <span class=\"comment\">// 启用 HTTP 缓存</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li><strong>图像处理</strong>：搭配 Coil 实现高效图片加载</li>\n</ol>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"code\"><pre><span class=\"line\">AsyncImage(</span><br><span class=\"line\">    modifier = Modifier.size(<span class=\"number\">80.</span>dp)</span><br><span class=\"line\">        .shadow(</span><br><span class=\"line\">            elevation = <span class=\"number\">5.</span>dp,</span><br><span class=\"line\">            shape = CircleShape,</span><br><span class=\"line\">            spotColor = Color.Black</span><br><span class=\"line\">        )</span><br><span class=\"line\">        .clip(CircleShape)</span><br><span class=\"line\">        .clickable &#123; &#125;,</span><br><span class=\"line\">    model = AppConfig.AVATAR,</span><br><span class=\"line\">    contentDescription = AppConfig.AVATAR,</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n<h3 id=\"开发经验总结\"><a href=\"#开发经验总结\" class=\"headerlink\" title=\"开发经验总结\"></a>开发经验总结</h3><ol>\n<li><p><strong>UI界面</strong><br>  使用 <a href=\"https://developer.android.com/compose\">Compose</a> 进行界面布局开发，声明性编程范式相比于传统的 xml 布局开发，高效很多，使用也很方便。使用了这种方式，传统的 UI 开发方式再也回不去了。</p>\n</li>\n<li><p><strong>状态管理</strong><br>使用 <code>mutableStateOf</code> 实现响应式更新，或者使用 <code>derivedStateOf</code> 实现派生状态的处理。</p>\n</li>\n</ol>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> pagIndex <span class=\"keyword\">by</span> remember &#123; mutableStateOf(<span class=\"number\">0</span>) &#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> errorState <span class=\"keyword\">by</span> remember &#123; mutableStateOf&lt;String?&gt;(<span class=\"literal\">null</span>) &#125;   </span><br><span class=\"line\"><span class=\"keyword\">val</span> themeState <span class=\"keyword\">by</span> mineViewModel.appTheme.collectAsState()</span><br><span class=\"line\"><span class=\"keyword\">val</span> uiChecked <span class=\"keyword\">by</span> remember(themeState) &#123; derivedStateOf &#123; themeState == ThemeConstants.DARK &#125; &#125;</span><br></pre></td></tr></table></figure>\n\n\n<ol start=\"3\">\n<li><strong>导航</strong></li>\n</ol>\n<p>实现 <code>Compose Navigator</code> 统一路由管理</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> gotoDebug: () -&gt; <span class=\"built_in\">Unit</span> = &#123;</span><br><span class=\"line\">    navController.navigate(Routes.Debug())</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">val</span> goToPostDetail: (Post) -&gt; <span class=\"built_in\">Unit</span> = &#123; it -&gt;</span><br><span class=\"line\">    navController.navigate(Routes.PostDetail(title = it.title, it.url))</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ol start=\"4\">\n<li><strong>Kotlin Flow</strong><br>简化异步编程，让网络请求的代码看起来更直观</li>\n</ol>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">loadAllPost</span><span class=\"params\">()</span></span>: Flow&lt;List&lt;PostV2&gt;&gt; = load(<span class=\"string\">&quot;allPosts&quot;</span>) &#123;</span><br><span class=\"line\">    postApi.getAllPost()?.<span class=\"keyword\">data</span> ?: emptyList()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">suspend</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">getAllPost</span><span class=\"params\">()</span></span>: SearchResponse? = request&lt;SearchResponse&gt;(getUrl(<span class=\"string\">&quot;api/search.json&quot;</span>))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">suspend</span> <span class=\"keyword\">inline</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"type\">&lt;<span class=\"keyword\">reified</span> T&gt;</span> <span class=\"title\">request</span><span class=\"params\">(url: <span class=\"type\">String</span>)</span></span>: T? &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        client.<span class=\"keyword\">get</span>(url).body()</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (e: Exception) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (e <span class=\"keyword\">is</span> CancellationException) <span class=\"keyword\">throw</span> e</span><br><span class=\"line\">        e.printStackTrace()</span><br><span class=\"line\">        <span class=\"literal\">null</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>经过一番各种折腾，将很多在工作上无法使用的能力（Koin、Flow、DataStore……）都体验使用了一下，在业余的时间完成了基于博客文章构建的 App 在三个平台上的开发，实际上最初我也想搭建 WebJs 的平台的，后面删除掉了，因为涉及到 web 平台开发的各种库相比客户端少很多，兼容起来也比较费劲。KMP&#x2F;CMP 这块技术确实是能很大地节省开发人力，多端使用同一份UI逻辑代码，部分逻辑也可以用 kotlin 统一进行封装，后续维护也会方便很多。但这里有个缺点就是涉及到的库所需要的 kotlin&#x2F;Java 版本要求比较高，除非开发一些独立的 App，否则公司里的项目想基于这些技术去实现不太大可能。以及如果所需要的能力比较依赖与原生，比如音视频领域就有一定的局限性，总体来讲更适合偏交互业务的开发。</p>\n<p><strong>项目源码</strong>: <a href=\"https://github.com/VomPom/blog_kmp\">https://github.com/VomPom/blog_kmp</a>  </p>\n","categories":[{"name":"思考总结","slug":"thinking","api":"api/categories/thinking.json"}],"tags":[{"name":"KMP","slug":"KMP","api":"api/tags/KMP.json"}],"api":"api/posts/2025/07/28/Compose-Multiplatform-跨平台博客应用实践.json"},{"title":"[鸿蒙]写了个基于Hexo博客的鸿蒙App","slug":"鸿蒙-写了个基于Hexo博客的鸿蒙App","date":"2025-05-16T12:10:00.000Z","updated":"2025-07-28T14:52:28.959Z","comments":true,"url":"2025/05/16/鸿蒙-写了个基于Hexo博客的鸿蒙App/","excerpt":"<p>最近部门也在跟进<a href=\"https://www.harmonyos.com/\">鸿蒙</a>平台的业务开发，自己主要是做 Android 开发，主要使用 Kotlin&#x2F;Java 语言。，需要对新的开发平台和开发模式进行学习，在业余时间开了个项目练手，做了个基于 Hexo 博客内容开发的App。鸿蒙主要使用<a href=\"https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts\">ArkTS语言</a>和<a href=\"https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkui\">ArkUI框架</a>进行开发，有使用 <a href=\"https://developer.android.com/compose\">Jetpack Compose</a> 和 JavaScript&#x2F;TypeScript 的开发经验的话，上手会比较的轻松。本文主要介绍做的App功能以及对鸿蒙开发的一个总结。</p>\n<h2 id=\"App-简介\"><a href=\"#App-简介\" class=\"headerlink\" title=\"App 简介\"></a>App 简介</h2><p>后台数据来自 <a href=\"https://hexo.io/\">Hexo</a> 生成的博客文章，利用 <a href=\"https://github.com/ryanuo/hexo-generator-wxapi\">hexo-generator-wxapi</a> 生成 api .json 文件，再利用 <a href=\"https://www.qiniu.com/\">七牛云</a> 提供对图片和 .json 文件 CDN。</p>\n<p>实现的功能</p>\n<ul>\n<li>博客列表分页加载</li>\n<li>文章详情加载</li>\n<li>文章按分类&#x2F;标签展示</li>\n<li>文章内容统计</li>\n<li>深色&#x2F;浅色模式切换</li>\n<li>数据本地缓存</li>\n</ul>\n<h3 id=\"功能预览\"><a href=\"#功能预览\" class=\"headerlink\" title=\"功能预览\"></a>功能预览</h3><table>\n<thead>\n<tr>\n<th></th>\n<th></th>\n<th></th>\n<th></th>\n<th></th>\n<th></th>\n</tr>\n</thead>\n<tbody><tr>\n<td><img src=\"https://cdn.julis.wang/github/blog_harmony/light_blog_list.jpeg\"  alt=\"博客列表\" /></td>\n<td><img src=\"https://cdn.julis.wang/github/blog_harmony/light_stats.jpeg\"  alt=\"统计\" /></td>\n<td><img src=\"https://cdn.julis.wang/github/blog_harmony/light_mine.jpeg\" alt=\"个人\" /></td>\n<td><img src=\"https://cdn.julis.wang/github/blog_harmony/light_detail.jpeg\"  alt=\"文章详情\" /></td>\n<td><img src=\"https://cdn.julis.wang/github/blog_harmony/light_category.jpeg\"  alt=\"分类\" /></td>\n<td><img src=\"https://cdn.julis.wang/github/blog_harmony/light_tag.jpeg\"  alt=\"标签\" /></td>\n</tr>\n</tbody></table>\n<h3 id=\"依赖项\"><a href=\"#依赖项\" class=\"headerlink\" title=\"依赖项\"></a>依赖项</h3><h4 id=\"Hexo\"><a href=\"#Hexo\" class=\"headerlink\" title=\"Hexo\"></a>Hexo</h4><ul>\n<li><a href=\"https://hexo.io/\">Hexo</a> 快速、简洁且高效的博客框架</li>\n<li><a href=\"https://github.com/ryanuo/hexo-generator-wxapi\">hexo-generator-wxapi</a> 用于将 Hexo 博客内容生成 api 风格的.json文件</li>\n<li><a href=\"https://www.qiniu.com/\">七牛云</a> 提供对图片和.json文件 CDN加速</li>\n</ul>\n<h4 id=\"HarmonyOS\"><a href=\"#HarmonyOS\" class=\"headerlink\" title=\"HarmonyOS\"></a>HarmonyOS</h4><ul>\n<li><a href=\"https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts\">ArkTS</a> ArkTS在TypeScript（简称TS）生态基础上做了进一步扩展，保持了TS的基本风格，同时通过规范定义强化开发期静态检查和分析，提升代码健壮性，并实现更好的程序执行稳定性和性能。</li>\n<li><a href=\"https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkui\">ArkUI</a>  ArkUI（方舟UI框架）为应用的UI开发提供了完整的基础设施，包括简洁的UI语法、丰富的UI功能（组件、布局、动画以及交互事件），以及实时界面预览工具等，可以支持开发者进行可视化界面开发。</li>\n<li><a href=\"https://gitee.com/openharmony-sig/ohos_pull_to_refresh\">ohos_pull_to_refresh</a> 列表加载&#x2F;刷新控件(没有’No more’的状态)</li>\n<li><a href=\"https://github.com/Tencent/MMKV\">MMKV</a> 是基于 mmap 内存映射的 key-value 组件</li>\n</ul>\n<h2 id=\"鸿蒙开发总结\"><a href=\"#鸿蒙开发总结\" class=\"headerlink\" title=\"鸿蒙开发总结\"></a>鸿蒙开发总结</h2><h3 id=\"ArkTs-语言\"><a href=\"#ArkTs-语言\" class=\"headerlink\" title=\"ArkTs 语言\"></a>ArkTs 语言</h3><p>ArkTS 是 TypeScript 的超集，TypeScript 又是 JavaScript 的超集，所以对于基本数据类型使用的是 TypeScript 语法。他们三者的关系如下图所示：</p>\n  <img src=\"https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtybbs/713/408/959/0030086000713408959.20241009110308.85777546121432927171131630988896:50001231000000:2800:D599CEDEC4315A859E47A08CEC5D4D3E334431F82ABC9FD0E9B6AD0F91CD2FF5.png\" width=\"80%\" alt=\"ArkTS与TypeScript的关系\" />\n\n<p>相关的差异可以参考社区话题讨论 <a href=\"https://developer.huawei.com/consumer/cn/forum/topic/0203163854317501934\">ArkTS与Typescript的区别？\n</a></p>\n<p>这里主要记录一下自己使用过程中踩过的坑：</p>\n<h4 id=\"基本语言类型\"><a href=\"#基本语言类型\" class=\"headerlink\" title=\"基本语言类型\"></a>基本语言类型</h4><p>Number 和 number 是两个不同的类型，Number 是 JavaScript 中的一个全局对象，可以使用 new Number() 来创建一个 Number 对象。同理对于 String 和 string，Boolean 和 boolean 也是一样的，大写开头的是<strong>包装对象类型</strong>，小写的是<strong>原始类型</strong>，这点Java&#x2F;kotlin也有类似的包装对象比较好理解，但 Object 居然也有大小写之区分相比难理解点，写代码的时候好几次忽略了这个事，<strong>Object</strong> 是所有对象的基类，object 表示非原始类型（即不是 number、string、boolean、symbol、null 或 undefined 的所有类型）。可以是任何对象、数组、函数、类实例等。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">let obj: object;</span><br><span class=\"line\">obj = &#123; a: 1 &#125;;         // ✅ 正确：普通对象</span><br><span class=\"line\">obj = [1, 2, 3];        // ✅ 正确：数组</span><br><span class=\"line\">obj = () =&gt; &#123;&#125;;         // ✅ 正确：函数</span><br><span class=\"line\">obj = new Date();       // ✅ 正确：类实例</span><br><span class=\"line\"></span><br><span class=\"line\">obj = 42;               // ❌ 错误：原始类型 number</span><br><span class=\"line\">obj = &quot;hello&quot;;          // ❌ 错误：原始类型 string</span><br></pre></td></tr></table></figure>\n<p>两则的区别</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">特性</th>\n<th align=\"left\">object</th>\n<th align=\"left\">Object</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><strong>允许的值</strong></td>\n<td align=\"left\">仅非原始类型（对象、数组等）</td>\n<td align=\"left\">任意类型（包括原始值）</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>原始值处理</strong></td>\n<td align=\"left\">禁止</td>\n<td align=\"left\">自动装箱（如 42 → Number）</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>使用场景</strong></td>\n<td align=\"left\">明确限制为非原始类型时</td>\n<td align=\"left\">极少使用（通常用 unknown 或具体类型替代）</td>\n</tr>\n</tbody></table>\n<h4 id=\"Map-等集合类当作普通-JavaScript-对象来操作\"><a href=\"#Map-等集合类当作普通-JavaScript-对象来操作\" class=\"headerlink\" title=\"Map 等集合类当作普通 JavaScript 对象来操作\"></a>Map 等集合类当作普通 JavaScript 对象来操作</h4><figure class=\"highlight ts\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> map = <span class=\"keyword\">new</span> <span class=\"title class_\">Map</span>&lt;<span class=\"built_in\">string</span>, <span class=\"built_in\">object</span>&gt;();</span><br><span class=\"line\">map[<span class=\"string\">&quot;key&quot;</span>] = value;            <span class=\"comment\">// ❌ 错误用法！</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(map.<span class=\"title function_\">get</span>(<span class=\"string\">&quot;biz&quot;</span>));   <span class=\"comment\">// ❌ 输出 undefined</span></span><br></pre></td></tr></table></figure>\n<p>最开始挺奇怪的 map 明明设置了值，但是对应的 map size 为0，遍历 map 也没有数据。后来才发现是这种方式 不会 触发 Map 的内部机制，而是绕过了 Map 的方法，直接操作对象的属性，赋值后，键值对 不会 被存入 Map 的真实存储中，而是作为对象的普通属性存在。正确的用法是：</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> map = <span class=\"keyword\">new</span> <span class=\"title class_\">Map</span>&lt;<span class=\"built_in\">string</span>, <span class=\"built_in\">object</span>&gt;();</span><br><span class=\"line\">map.<span class=\"property\">set</span>[<span class=\"string\">&quot;key&quot;</span>] = value;        <span class=\"comment\">//  ✅ 正确用法！</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(map.<span class=\"title function_\">get</span>(<span class=\"string\">&quot;biz&quot;</span>));   <span class=\"comment\">//  ✅ 输出 value</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"struct-的困扰\"><a href=\"#struct-的困扰\" class=\"headerlink\" title=\"struct 的困扰\"></a>struct 的困扰</h4><p>在 js 里面是没有 <code>struct</code> 这个关键词的，从刚接触到现在它唯一的作用就是：和 <code>@Component</code>绑定声明一个UI控件。例如：</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> struct <span class=\"title class_\">ToolBar</span>&#123;&#125;</span><br></pre></td></tr></table></figure>\n<p><code>@Component</code> 和 <code>struct</code> 两则缺一不可，既然必须有 <code>@Component</code>来标注这是一个UI控件，为什么不能下面这样呢？能省掉一个关键字。</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ToolBar</span> &#123;&#125;</span><br></pre></td></tr></table></figure>\n<p>同样困扰的人还有很多，这里有一份讨论<a href=\"https://developer.huawei.com/consumer/cn/forum/topic/0204135301248599134\">定义组件时的stuct关键字是什么？</a><br>官方也有一份聊胜于无的介绍</p>\n<blockquote>\n<p>struct和class的区别是什么? </p>\n<p>struct只在自定义组件中使用，@Component装饰的struct就是自定义组件，自定义组件和class是两个概念，自定义组件没有类型，也不能等同于class。如果开发者需要使用组件作为参数在组件之间传递，可以使用自定义占位节点。</p>\n</blockquote>\n<p>我猜测这样是为了省掉对<code>@Component</code>装饰器编译的工作量，如果使用 class 声明，那么声明的UI控件就有“面向对象”的能力，实际上只希望它是一个UI控件声明，不需要它有其他的能力。难道不能对 <code>@Component</code> 装饰过的对象收回“面向对象”的能力么？当然能啊，估计要做很多编译检查的事儿。另外，从开发理解的层面上来讲，它确实也已经不是”对象”了，它只是一个干巴巴的一个UI结构，所以干脆就搞了一个新的关键词 struct。</p>\n<h3 id=\"ArkUI-框架\"><a href=\"#ArkUI-框架\" class=\"headerlink\" title=\"ArkUI 框架\"></a>ArkUI 框架</h3><p>整体框架使用的方式和 <a href=\"https://developer.android.com/compose\">Jetpack Compose</a> 类似，都是声明式UI框架。compose 里面使用  <code>@Composable</code>来标记某个方法这个方法便成了<code>UI控件</code>，控件里面的状态管理使用 <code>remember</code>+ <code>mutableState</code>来控制。而 ArkUI 通过 @State、@Link、@Prop 等装饰器来控制。了解了这些个装饰器的用法，基本上就能理解 ArkUI 的开发流程了。</p>\n<h4 id=\"构建-UI-的-Component-Builder\"><a href=\"#构建-UI-的-Component-Builder\" class=\"headerlink\" title=\"构建 UI 的 @Component @Builder\"></a>构建 UI 的 @Component @Builder</h4><p>@Component 和 @Builder 组合起来实现的差不多就是 Compose 里面使用  <code>@Composable</code> 装饰某个方法的作用，用于构建 UI 或可复用的逻辑单元。<br><strong>@Component</strong><br>用于创建一个自定义组件，组件可以包含独立的 UI 结构、状态管理和生命周期。</p>\n<p><strong>@Builder</strong><br>定义可复用的 UI 片段，用于创建一个UI 构建函数，封装一段可复用的 UI 代码块。不是独立组件，而是嵌入到其他组件或布局中执行，主要作用是复用和逻辑隔离，例如：关于页面，里面的文本是差不多的样式，只是内容不一样，那么只需要保留一个 text 属性出来接收参数。或者某块UI比较复杂，可以抽离一部分UI成为一个独立的UI逻辑模块。</p>\n<h3 id=\"构建-UI-的状态控制装饰器\"><a href=\"#构建-UI-的状态控制装饰器\" class=\"headerlink\" title=\"构建 UI 的状态控制装饰器\"></a>构建 UI 的状态控制装饰器</h3><p><strong>@State</strong><br>比较常用的装饰器，和 Compose 里面 remember+mutableStateOf 的作用差不多，对应的值改变之后，对相关的使用到该属性UI的地方进行刷新。</p>\n<p><strong>@Prop</strong><br>@Prop 装饰的变量和父组件建立单向的同步关系，@Prop变量允许在本地修改，但修改后的变化不会同步回父组件。</p>\n<p>也就是在某个 @Component 的组件内有一个 @State 装饰的属性，传递到子 @Component 组件 @Prop 修饰的属性。子控件对这个属性修改之后，父控件不会对这个改变感知，父控件UI不会改变。</p>\n<p><strong>@Link</strong><br>子组件中被@Link装饰的变量与其父组件中对应的数据源建立双向数据绑定。<br>跟 @Prop 的作用类似，不过是双向的，子控件对这个属性修改之后，父控件会感知这个变化，父控件UI会随着这个属性改变而改变。</p>\n<p><strong>@BuilderParam</strong><br>主要用于动态注入 UI 构建逻辑（即 @Builder 函数），实现父组件向子组件传递可定制的 UI 片段，也就是向子控件传递 UI 参数。</p>\n<p>基本上比较常用到的就这些，还有很多例如：@LocalBuilder @StorageLink @Styles等，都是为了解决开发过过程中遇到的问题，但是只要掌握了 ArkUI UI组件的声明周期和状态管理的基本原理理解其他装饰器还是比较简单的。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>总体开发体验下来，鸿蒙开发学习成本并不是特别高，比较快能上手，但设计的 api 更像一个缝合怪，且使用上不太收敛。很多库还需要再建设，例如音视频开发对应的支持库还不是特别成熟。不过，作为一个从头搞的生态来说能实现成这样已经很不错了，就像此前武磊登陆西甲，以及目前被看好的青年新星王钰栋，都是”自己的孩子”，需要迈出第一步。现在，很多公司也在适配鸿蒙了，期待未来能从 Android 跟 iOS 的生态中争夺出一片大市场。</p>\n<p>项目源码：<a href=\"https://github.com/VomPom/blog_harmony\">https://github.com/VomPom/blog_harmony</a></p>\n","cover":null,"images":["https://cdn.julis.wang/github/blog_harmony/light_blog_list.jpeg","https://cdn.julis.wang/github/blog_harmony/light_stats.jpeg","https://cdn.julis.wang/github/blog_harmony/light_mine.jpeg","https://cdn.julis.wang/github/blog_harmony/light_detail.jpeg","https://cdn.julis.wang/github/blog_harmony/light_category.jpeg","https://cdn.julis.wang/github/blog_harmony/light_tag.jpeg","https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtybbs/713/408/959/0030086000713408959.20241009110308.85777546121432927171131630988896:50001231000000:2800:D599CEDEC4315A859E47A08CEC5D4D3E334431F82ABC9FD0E9B6AD0F91CD2FF5.png"],"content":"<p>最近部门也在跟进<a href=\"https://www.harmonyos.com/\">鸿蒙</a>平台的业务开发，自己主要是做 Android 开发，主要使用 Kotlin&#x2F;Java 语言。，需要对新的开发平台和开发模式进行学习，在业余时间开了个项目练手，做了个基于 Hexo 博客内容开发的App。鸿蒙主要使用<a href=\"https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts\">ArkTS语言</a>和<a href=\"https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkui\">ArkUI框架</a>进行开发，有使用 <a href=\"https://developer.android.com/compose\">Jetpack Compose</a> 和 JavaScript&#x2F;TypeScript 的开发经验的话，上手会比较的轻松。本文主要介绍做的App功能以及对鸿蒙开发的一个总结。</p>\n<h2 id=\"App-简介\"><a href=\"#App-简介\" class=\"headerlink\" title=\"App 简介\"></a>App 简介</h2><p>后台数据来自 <a href=\"https://hexo.io/\">Hexo</a> 生成的博客文章，利用 <a href=\"https://github.com/ryanuo/hexo-generator-wxapi\">hexo-generator-wxapi</a> 生成 api .json 文件，再利用 <a href=\"https://www.qiniu.com/\">七牛云</a> 提供对图片和 .json 文件 CDN。</p>\n<p>实现的功能</p>\n<ul>\n<li>博客列表分页加载</li>\n<li>文章详情加载</li>\n<li>文章按分类&#x2F;标签展示</li>\n<li>文章内容统计</li>\n<li>深色&#x2F;浅色模式切换</li>\n<li>数据本地缓存</li>\n</ul>\n<h3 id=\"功能预览\"><a href=\"#功能预览\" class=\"headerlink\" title=\"功能预览\"></a>功能预览</h3><table>\n<thead>\n<tr>\n<th></th>\n<th></th>\n<th></th>\n<th></th>\n<th></th>\n<th></th>\n</tr>\n</thead>\n<tbody><tr>\n<td><img src=\"https://cdn.julis.wang/github/blog_harmony/light_blog_list.jpeg\"  alt=\"博客列表\" /></td>\n<td><img src=\"https://cdn.julis.wang/github/blog_harmony/light_stats.jpeg\"  alt=\"统计\" /></td>\n<td><img src=\"https://cdn.julis.wang/github/blog_harmony/light_mine.jpeg\" alt=\"个人\" /></td>\n<td><img src=\"https://cdn.julis.wang/github/blog_harmony/light_detail.jpeg\"  alt=\"文章详情\" /></td>\n<td><img src=\"https://cdn.julis.wang/github/blog_harmony/light_category.jpeg\"  alt=\"分类\" /></td>\n<td><img src=\"https://cdn.julis.wang/github/blog_harmony/light_tag.jpeg\"  alt=\"标签\" /></td>\n</tr>\n</tbody></table>\n<h3 id=\"依赖项\"><a href=\"#依赖项\" class=\"headerlink\" title=\"依赖项\"></a>依赖项</h3><h4 id=\"Hexo\"><a href=\"#Hexo\" class=\"headerlink\" title=\"Hexo\"></a>Hexo</h4><ul>\n<li><a href=\"https://hexo.io/\">Hexo</a> 快速、简洁且高效的博客框架</li>\n<li><a href=\"https://github.com/ryanuo/hexo-generator-wxapi\">hexo-generator-wxapi</a> 用于将 Hexo 博客内容生成 api 风格的.json文件</li>\n<li><a href=\"https://www.qiniu.com/\">七牛云</a> 提供对图片和.json文件 CDN加速</li>\n</ul>\n<h4 id=\"HarmonyOS\"><a href=\"#HarmonyOS\" class=\"headerlink\" title=\"HarmonyOS\"></a>HarmonyOS</h4><ul>\n<li><a href=\"https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts\">ArkTS</a> ArkTS在TypeScript（简称TS）生态基础上做了进一步扩展，保持了TS的基本风格，同时通过规范定义强化开发期静态检查和分析，提升代码健壮性，并实现更好的程序执行稳定性和性能。</li>\n<li><a href=\"https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkui\">ArkUI</a>  ArkUI（方舟UI框架）为应用的UI开发提供了完整的基础设施，包括简洁的UI语法、丰富的UI功能（组件、布局、动画以及交互事件），以及实时界面预览工具等，可以支持开发者进行可视化界面开发。</li>\n<li><a href=\"https://gitee.com/openharmony-sig/ohos_pull_to_refresh\">ohos_pull_to_refresh</a> 列表加载&#x2F;刷新控件(没有’No more’的状态)</li>\n<li><a href=\"https://github.com/Tencent/MMKV\">MMKV</a> 是基于 mmap 内存映射的 key-value 组件</li>\n</ul>\n<h2 id=\"鸿蒙开发总结\"><a href=\"#鸿蒙开发总结\" class=\"headerlink\" title=\"鸿蒙开发总结\"></a>鸿蒙开发总结</h2><h3 id=\"ArkTs-语言\"><a href=\"#ArkTs-语言\" class=\"headerlink\" title=\"ArkTs 语言\"></a>ArkTs 语言</h3><p>ArkTS 是 TypeScript 的超集，TypeScript 又是 JavaScript 的超集，所以对于基本数据类型使用的是 TypeScript 语法。他们三者的关系如下图所示：</p>\n  <img src=\"https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtybbs/713/408/959/0030086000713408959.20241009110308.85777546121432927171131630988896:50001231000000:2800:D599CEDEC4315A859E47A08CEC5D4D3E334431F82ABC9FD0E9B6AD0F91CD2FF5.png\" width=\"80%\" alt=\"ArkTS与TypeScript的关系\" />\n\n<p>相关的差异可以参考社区话题讨论 <a href=\"https://developer.huawei.com/consumer/cn/forum/topic/0203163854317501934\">ArkTS与Typescript的区别？\n</a></p>\n<p>这里主要记录一下自己使用过程中踩过的坑：</p>\n<h4 id=\"基本语言类型\"><a href=\"#基本语言类型\" class=\"headerlink\" title=\"基本语言类型\"></a>基本语言类型</h4><p>Number 和 number 是两个不同的类型，Number 是 JavaScript 中的一个全局对象，可以使用 new Number() 来创建一个 Number 对象。同理对于 String 和 string，Boolean 和 boolean 也是一样的，大写开头的是<strong>包装对象类型</strong>，小写的是<strong>原始类型</strong>，这点Java&#x2F;kotlin也有类似的包装对象比较好理解，但 Object 居然也有大小写之区分相比难理解点，写代码的时候好几次忽略了这个事，<strong>Object</strong> 是所有对象的基类，object 表示非原始类型（即不是 number、string、boolean、symbol、null 或 undefined 的所有类型）。可以是任何对象、数组、函数、类实例等。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">let obj: object;</span><br><span class=\"line\">obj = &#123; a: 1 &#125;;         // ✅ 正确：普通对象</span><br><span class=\"line\">obj = [1, 2, 3];        // ✅ 正确：数组</span><br><span class=\"line\">obj = () =&gt; &#123;&#125;;         // ✅ 正确：函数</span><br><span class=\"line\">obj = new Date();       // ✅ 正确：类实例</span><br><span class=\"line\"></span><br><span class=\"line\">obj = 42;               // ❌ 错误：原始类型 number</span><br><span class=\"line\">obj = &quot;hello&quot;;          // ❌ 错误：原始类型 string</span><br></pre></td></tr></table></figure>\n<p>两则的区别</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">特性</th>\n<th align=\"left\">object</th>\n<th align=\"left\">Object</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><strong>允许的值</strong></td>\n<td align=\"left\">仅非原始类型（对象、数组等）</td>\n<td align=\"left\">任意类型（包括原始值）</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>原始值处理</strong></td>\n<td align=\"left\">禁止</td>\n<td align=\"left\">自动装箱（如 42 → Number）</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>使用场景</strong></td>\n<td align=\"left\">明确限制为非原始类型时</td>\n<td align=\"left\">极少使用（通常用 unknown 或具体类型替代）</td>\n</tr>\n</tbody></table>\n<h4 id=\"Map-等集合类当作普通-JavaScript-对象来操作\"><a href=\"#Map-等集合类当作普通-JavaScript-对象来操作\" class=\"headerlink\" title=\"Map 等集合类当作普通 JavaScript 对象来操作\"></a>Map 等集合类当作普通 JavaScript 对象来操作</h4><figure class=\"highlight ts\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> map = <span class=\"keyword\">new</span> <span class=\"title class_\">Map</span>&lt;<span class=\"built_in\">string</span>, <span class=\"built_in\">object</span>&gt;();</span><br><span class=\"line\">map[<span class=\"string\">&quot;key&quot;</span>] = value;            <span class=\"comment\">// ❌ 错误用法！</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(map.<span class=\"title function_\">get</span>(<span class=\"string\">&quot;biz&quot;</span>));   <span class=\"comment\">// ❌ 输出 undefined</span></span><br></pre></td></tr></table></figure>\n<p>最开始挺奇怪的 map 明明设置了值，但是对应的 map size 为0，遍历 map 也没有数据。后来才发现是这种方式 不会 触发 Map 的内部机制，而是绕过了 Map 的方法，直接操作对象的属性，赋值后，键值对 不会 被存入 Map 的真实存储中，而是作为对象的普通属性存在。正确的用法是：</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> map = <span class=\"keyword\">new</span> <span class=\"title class_\">Map</span>&lt;<span class=\"built_in\">string</span>, <span class=\"built_in\">object</span>&gt;();</span><br><span class=\"line\">map.<span class=\"property\">set</span>[<span class=\"string\">&quot;key&quot;</span>] = value;        <span class=\"comment\">//  ✅ 正确用法！</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(map.<span class=\"title function_\">get</span>(<span class=\"string\">&quot;biz&quot;</span>));   <span class=\"comment\">//  ✅ 输出 value</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"struct-的困扰\"><a href=\"#struct-的困扰\" class=\"headerlink\" title=\"struct 的困扰\"></a>struct 的困扰</h4><p>在 js 里面是没有 <code>struct</code> 这个关键词的，从刚接触到现在它唯一的作用就是：和 <code>@Component</code>绑定声明一个UI控件。例如：</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> struct <span class=\"title class_\">ToolBar</span>&#123;&#125;</span><br></pre></td></tr></table></figure>\n<p><code>@Component</code> 和 <code>struct</code> 两则缺一不可，既然必须有 <code>@Component</code>来标注这是一个UI控件，为什么不能下面这样呢？能省掉一个关键字。</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ToolBar</span> &#123;&#125;</span><br></pre></td></tr></table></figure>\n<p>同样困扰的人还有很多，这里有一份讨论<a href=\"https://developer.huawei.com/consumer/cn/forum/topic/0204135301248599134\">定义组件时的stuct关键字是什么？</a><br>官方也有一份聊胜于无的介绍</p>\n<blockquote>\n<p>struct和class的区别是什么? </p>\n<p>struct只在自定义组件中使用，@Component装饰的struct就是自定义组件，自定义组件和class是两个概念，自定义组件没有类型，也不能等同于class。如果开发者需要使用组件作为参数在组件之间传递，可以使用自定义占位节点。</p>\n</blockquote>\n<p>我猜测这样是为了省掉对<code>@Component</code>装饰器编译的工作量，如果使用 class 声明，那么声明的UI控件就有“面向对象”的能力，实际上只希望它是一个UI控件声明，不需要它有其他的能力。难道不能对 <code>@Component</code> 装饰过的对象收回“面向对象”的能力么？当然能啊，估计要做很多编译检查的事儿。另外，从开发理解的层面上来讲，它确实也已经不是”对象”了，它只是一个干巴巴的一个UI结构，所以干脆就搞了一个新的关键词 struct。</p>\n<h3 id=\"ArkUI-框架\"><a href=\"#ArkUI-框架\" class=\"headerlink\" title=\"ArkUI 框架\"></a>ArkUI 框架</h3><p>整体框架使用的方式和 <a href=\"https://developer.android.com/compose\">Jetpack Compose</a> 类似，都是声明式UI框架。compose 里面使用  <code>@Composable</code>来标记某个方法这个方法便成了<code>UI控件</code>，控件里面的状态管理使用 <code>remember</code>+ <code>mutableState</code>来控制。而 ArkUI 通过 @State、@Link、@Prop 等装饰器来控制。了解了这些个装饰器的用法，基本上就能理解 ArkUI 的开发流程了。</p>\n<h4 id=\"构建-UI-的-Component-Builder\"><a href=\"#构建-UI-的-Component-Builder\" class=\"headerlink\" title=\"构建 UI 的 @Component @Builder\"></a>构建 UI 的 @Component @Builder</h4><p>@Component 和 @Builder 组合起来实现的差不多就是 Compose 里面使用  <code>@Composable</code> 装饰某个方法的作用，用于构建 UI 或可复用的逻辑单元。<br><strong>@Component</strong><br>用于创建一个自定义组件，组件可以包含独立的 UI 结构、状态管理和生命周期。</p>\n<p><strong>@Builder</strong><br>定义可复用的 UI 片段，用于创建一个UI 构建函数，封装一段可复用的 UI 代码块。不是独立组件，而是嵌入到其他组件或布局中执行，主要作用是复用和逻辑隔离，例如：关于页面，里面的文本是差不多的样式，只是内容不一样，那么只需要保留一个 text 属性出来接收参数。或者某块UI比较复杂，可以抽离一部分UI成为一个独立的UI逻辑模块。</p>\n<h3 id=\"构建-UI-的状态控制装饰器\"><a href=\"#构建-UI-的状态控制装饰器\" class=\"headerlink\" title=\"构建 UI 的状态控制装饰器\"></a>构建 UI 的状态控制装饰器</h3><p><strong>@State</strong><br>比较常用的装饰器，和 Compose 里面 remember+mutableStateOf 的作用差不多，对应的值改变之后，对相关的使用到该属性UI的地方进行刷新。</p>\n<p><strong>@Prop</strong><br>@Prop 装饰的变量和父组件建立单向的同步关系，@Prop变量允许在本地修改，但修改后的变化不会同步回父组件。</p>\n<p>也就是在某个 @Component 的组件内有一个 @State 装饰的属性，传递到子 @Component 组件 @Prop 修饰的属性。子控件对这个属性修改之后，父控件不会对这个改变感知，父控件UI不会改变。</p>\n<p><strong>@Link</strong><br>子组件中被@Link装饰的变量与其父组件中对应的数据源建立双向数据绑定。<br>跟 @Prop 的作用类似，不过是双向的，子控件对这个属性修改之后，父控件会感知这个变化，父控件UI会随着这个属性改变而改变。</p>\n<p><strong>@BuilderParam</strong><br>主要用于动态注入 UI 构建逻辑（即 @Builder 函数），实现父组件向子组件传递可定制的 UI 片段，也就是向子控件传递 UI 参数。</p>\n<p>基本上比较常用到的就这些，还有很多例如：@LocalBuilder @StorageLink @Styles等，都是为了解决开发过过程中遇到的问题，但是只要掌握了 ArkUI UI组件的声明周期和状态管理的基本原理理解其他装饰器还是比较简单的。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>总体开发体验下来，鸿蒙开发学习成本并不是特别高，比较快能上手，但设计的 api 更像一个缝合怪，且使用上不太收敛。很多库还需要再建设，例如音视频开发对应的支持库还不是特别成熟。不过，作为一个从头搞的生态来说能实现成这样已经很不错了，就像此前武磊登陆西甲，以及目前被看好的青年新星王钰栋，都是”自己的孩子”，需要迈出第一步。现在，很多公司也在适配鸿蒙了，期待未来能从 Android 跟 iOS 的生态中争夺出一片大市场。</p>\n<p>项目源码：<a href=\"https://github.com/VomPom/blog_harmony\">https://github.com/VomPom/blog_harmony</a></p>\n","categories":[{"name":"思考总结","slug":"thinking","api":"api/categories/thinking.json"}],"tags":[{"name":"鸿蒙","slug":"鸿蒙","api":"api/tags/鸿蒙.json"}],"api":"api/posts/2025/05/16/鸿蒙-写了个基于Hexo博客的鸿蒙App.json"},{"title":"KV-存储之mmkv","slug":"KV-存储之mmkv","date":"2025-03-30T03:38:00.000Z","updated":"2025-05-20T11:46:57.000Z","comments":true,"url":"2025/03/30/KV-存储之mmkv/","excerpt":"<p>在平时的业务中，需要用到轻量级存储业务中的数据（例如设置数据存储），绝大多数时候 Anroid 管法提供的 <a href=\"https://developer.android.com/reference/android/content/SharedPreferences\">SharedPreferences</a>  组件就能实现，但针对一些需要高效的场景它就不那么使用了，不适合存储大量数据、多线程操作的不安全性、数据明文不安全性，以及不支持多进程之间的调用等各种问题。<br><a href=\"https://github.com/Tencent/MMKV\">MMKV</a>的诞生就是为了解决以上的问题，本文主要对 MMKV 源码的学习知识点进行一些总结。</p>\n<h2 id=\"核心设计与原理\"><a href=\"#核心设计与原理\" class=\"headerlink\" title=\"核心设计与原理\"></a>核心设计与原理</h2><p>在官方的开源工程中可以看到如下的一些介绍</p>\n<blockquote>\n<p>MMKV 是基于 mmap 内存映射的 key-value 组件，底层序列化&#x2F;反序列化使用 protobuf 实现，性能高，稳定性强。从 2015 年中至今在微信上使用，其性能和稳定性经过了时间的验证。</p>\n</blockquote>\n<h3 id=\"传统I-O与-mmap\"><a href=\"#传统I-O与-mmap\" class=\"headerlink\" title=\"传统I&#x2F;O与 mmap\"></a>传统I&#x2F;O与 mmap</h3><p>mmap 这个是 mmkv 实现的核心，没有 mmap 那么就没有 mmkv。对于 <code>SharedPreferences</code>的实现来说，每次的数据更新都将操作本地文件，而本地文件的写入是通过传统的I&#x2F;O实现。要理解两者的实现差异，需要先理解 Linux <strong>用户空间与内核空间</strong>设计。</p>\n<h4 id=\"用户空间与内核空间\"><a href=\"#用户空间与内核空间\" class=\"headerlink\" title=\"用户空间与内核空间\"></a><strong>用户空间与内核空间</strong></h4><p>Linux的进程是相互独立的，一个进程是不能直接操作或者访问别一个进程空间的。每个进程空间还分为用户空间和内核（Kernel）空间，相当于把Kernel和上层的应用程序抽像的隔离开。</p>\n<p><strong>用户空间</strong>和<strong>内核空间</strong>，用户空间是用户程序代码运行的地方，内核空间是内核代码运行的地方。为了安全，它们是隔离的，即使用户的程序崩溃了，内核也不受影响。</p>\n<p>这里有两个隔离，一个进程间是相互隔离的，二是进程内有用户空间和内核空间的隔离。</p>\n<p>进程间，用户空间的数据不可共享，所以用户空间 &#x3D; 不可共享空间<br>进程间，内核空间的数据可共享，所以内核空间 &#x3D; 可共享空间，所以Linux系统的内存通常是MemFree+Cache<br>所有进程共用1个内核空间。</p>\n<h4 id=\"传统I-O读写流程\"><a href=\"#传统I-O读写流程\" class=\"headerlink\" title=\"传统I&#x2F;O读写流程\"></a><strong>传统I&#x2F;O读写流程</strong></h4><p>常规文件读写操作（调用read&#x2F;fread等函数）过程如下：</p>\n<ul>\n<li><p>进程发起读写文件请求。</p>\n</li>\n<li><p>内核通过查找进程文件符表，定位到内核已打开文件集上的文件信息，从而找到此文件的<code>inode</code>。</p>\n</li>\n<li><p><code>inode</code> 在 <code>address_space</code> 上查找要请求的文件页是否已经缓存在页缓存中。如果存在，则直接返回这片文件页的内容。</p>\n</li>\n<li><p>如果不存在，则通过 <code>inode</code> 定位到文件磁盘地址，将数据从磁盘复制到页缓存。之后再次发起读页面过程，进而将页缓存中的数据发给用户进程。</p>\n<blockquote>\n<p><strong>什么是 inode</strong> ?</p>\n<p>全称为 index node，既<strong>存储文件元信息的区域</strong>，中文译名“索引节点”。<br>包含：文件权限、文件拥有者的UID、文件的大小等等。</p>\n</blockquote>\n</li>\n</ul>\n<img src=\"https://cdn.julis.wang/blog/img/ee519ba873acf3f80fd4ccec86ed72e7.png\">\n\n\n<p>总结来说，常规文件操作为了提高读写效率和保护磁盘，使用了页缓存机制。这样造成读文件时需要先将文件页从磁盘拷贝到页缓存中，由于页缓存处在内核空间，不能被用户进程直接寻址访问，所以还需要将页缓存中的数据页再次拷贝到用户空间中。这样，通过了两次数据拷贝过程，才能完成<strong>进程</strong>对<strong>文件</strong>内容的访问。</p>\n<h4 id=\"mmap基本概念和原理\"><a href=\"#mmap基本概念和原理\" class=\"headerlink\" title=\"mmap基本概念和原理\"></a><strong>mmap基本概念和原理</strong></h4><p>内存映射（mmap），就是<strong>将文件的磁盘扇区映射到进程的虚拟内存空间</strong>的过程，即将一个文件映射到进程的虚拟空间，实现文件磁盘地址和进程虚拟空间中一段虚拟地址的一一对应关系。实现这样的映射关系后，进程就可以采用指针的方式读写操作这一段内存，而系统会自动回写脏页面到对应的文件磁盘上，即完成了对文件的操作而不必再调用read,write等系统调用函数。</p>\n<img src=\"https://cdn.julis.wang/blog/img/mmap_1.png\">\n\n<p>由上图可知，进程的虚拟地址空间，由多个虚拟内存区域构成。每个虚拟内存区域都是进程在虚拟地址空间中的一个同质区间，即具有同样特性的连续地址范围。上图中所示的text数据段（代码段）、初始数据段、BSS数据段、堆、栈和内存映射，都是一个独立的虚拟内存区域。内存映射的地址空间处在堆栈之间的空余部分。</p>\n<p>linux内核使用 <code>vm_area_struc</code>t 结构来表示一个独立的虚拟内存区域，由于每个不同质的虚拟内存区域功能和内部机制都不同，因此一个进程使用多个 <code>vm_area_struct</code> 结构来分别表示不同类型的虚拟内存区域。各个 <code>vm_area_struct</code> 结构使用链表或者树形结构链接，方便进程快速访问，如下图所示：</p>\n<img src=\"https://cdn.julis.wang/blog/img/mmap_2_1.png\">\n\n<p><code>vm_area_struct</code> 结构中包含区域起始和终止地址以及其他相关信息。这样，进程对某一虚拟内存区域的任何操作需要用要的信息，都可以从 <code>vm_area_struct</code> 中获得。mmap函数就是要创建一个新的 <code>vm_area_struct</code> 结构，并将其与文件的物理磁盘地址相连。</p>\n<p>mmap内存映射的实现过程，总的来说可以分为三个阶段：</p>\n<p><strong>阶段一：进程启动映射过程，并在虚拟地址空间中为映射创建虚拟映射区域</strong></p>\n<ul>\n<li>进程在用户空间调用mmap库函数</li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> *<span class=\"title\">mmap</span><span class=\"params\">(<span class=\"type\">void</span> *addr, <span class=\"type\">size_t</span> length, <span class=\"type\">int</span> prot, <span class=\"type\">int</span> flags, <span class=\"type\">int</span> fd, <span class=\"type\">off_t</span> offset)</span></span>;</span><br></pre></td></tr></table></figure>\n\n<p><code>addr</code>：指定映射的虚拟内存地址，可以设置为 NULL，让内核自动选择合适的虚拟内存地址</p>\n<p><code>length</code>：映射的长度。</p>\n<p><code>prot</code>：映射内存的保护模式，可选值如下：  </p>\n<p><code>flags</code>：指定映射的类型</p>\n<p><code>fd</code>：进行映射的文件句柄。</p>\n<p><code>offset</code>：文件偏移量（从文件的何处开始映射）</p>\n<ul>\n<li><p>在当前进程的虚拟地址空间中，寻找一段空闲的满足要求的连续的虚拟地址</p>\n</li>\n<li><p>为此虚拟区分配一个 <code>vm_area_struct</code> 结构，接着对这个结构的各个域进行了初始化</p>\n</li>\n<li><p>将新创建的虚拟区结构 <code>vm_area_struct</code> 对象插入到进程的虚拟地址区域链表&#x2F;树中</p>\n</li>\n</ul>\n<p><strong>阶段二：调用内核空间的mmap函数（不同于用户空间函数），实现文件物理地址和进程虚拟地址的一一映射关系</strong></p>\n<ul>\n<li><p>为映射分配了新的虚拟地址区域后，通过待映射的文件指针，在文件描述符表中找到对应的文件描述符，通过文件描述符，链接到内核“已打开文件集”中该文件的文件结构体（struct file），每个文件结构体维护着和这个已打开文件相关各项信息。</p>\n</li>\n<li><p>为映射分配了新的虚拟地址区域后，通过待映射的文件指针，在文件描述符表中找到对应的文件描述符，通过文件描述符，链接到内核“已打开文件集”中该文件的文件结构体（struct file），每个文件结构体维护着和这个已打开文件相关各项信息。</p>\n</li>\n<li><p>通过该文件的文件结构体，链接到 <code>file_operations</code> 模块，调用内核mmap函数，其原型为：</p>\n</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">int mmap(struct file *filp, struct vm_area_struct *vma) //不同于用户空间mmap库函数</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>内核mmap函数通过虚拟文件系统inode模块定位到文件磁盘物理地址。</p>\n</li>\n<li><p>通过 <code>remap_pfn_range</code> 函数建立页表，即实现了文件地址和虚拟地址区域的映射关系。此时，这片虚拟地址并没有任何数据关联到物理内存(主存)中。</p>\n</li>\n</ul>\n<blockquote>\n<p>主存</p>\n<p>主存储器（Main memory），简称主存。是计算机硬件的一个重要部件，其作用是存放指令和数据，并能由中央处理器（CPU）直接随机存取</p>\n</blockquote>\n<p><strong>阶段三：进程发起对这片映射地址空间的访问，引发缺页异常，实现文件内容到主存（物理内存）的拷贝</strong></p>\n<blockquote>\n<p>前两个阶段仅在于创建虚拟区间并完成地址映射，但是并没有将任何文件数据的拷贝至主存。真正的文件读取是当进程发起读或写操作时</p>\n</blockquote>\n<ul>\n<li><p>进程的读或写操作访问虚拟地址空间这一段映射地址，通过查询页表，发现这一段地址并不在物理页上。因为目前只建立了地址映射，真正的硬盘数据还没有拷贝到内存中，因此引发缺页异常。</p>\n</li>\n<li><p>缺页异常进行一系列判断，确定无非法操作后，内核发起请求调页过程。</p>\n</li>\n<li><p>调页过程先在交换缓存空间（swap cache）中寻找需要访问的内存页，如果没有则调用nopage函数把所缺的页从磁盘装入到主存中。</p>\n</li>\n<li><p>之后进程即可对这片主存进行读或者写的操作，如果写操作改变了其内容，一定时间后系统会自动回写脏页面到对应磁盘地址，也即完成了写入到文件的过程。</p>\n</li>\n</ul>\n<blockquote>\n<p>修改过的脏页面并不会立即更新回文件中，而是有一段时间的延迟，可以调用<code>msync()</code>来强制同步, 这样所写的内容就能立即保存到文件里了</p>\n</blockquote>\n<p>常规文件操作需要从磁盘到内核空间页缓存再到用户空间主存的两次数据拷贝。而mmap文件映射，只需要从磁盘到用户空间主存的一次数据拷贝过程。mmap的关键点是实现了用户空间和内核空间的数据直接交互而省去了空间不同数据不通的繁琐过程，因此 mmap 效率更高。</p>\n<p>以上是 mmap 的基本概念和原理，搞明白了这些才能看明白整个 mmkv 里面的逻辑处理</p>\n<h3 id=\"mmkv-一次-put-的流程\"><a href=\"#mmkv-一次-put-的流程\" class=\"headerlink\" title=\"mmkv 一次 put 的流程\"></a>mmkv 一次 put 的流程</h3><p>mmkv初始化比较简单，主要涉及到一些配置的初始化，文件夹创建等，其中最重要的逻辑 mmap 调用被封装到一个 <code>MemoryFile</code>到对象里面 </p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">MemoryFile::mmap</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">auto</span> oldPtr = m_ptr;</span><br><span class=\"line\">    <span class=\"keyword\">auto</span> mode = m_readOnly ? PROT_READ : (PROT_READ | PROT_WRITE);</span><br><span class=\"line\">    m_ptr = (<span class=\"type\">char</span> *) ::<span class=\"built_in\">mmap</span>(m_ptr, m_size, mode, MAP_SHARED, m_diskFile.m_fd, <span class=\"number\">0</span>);</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>主要记录一下一次 put 任务的流程，以 <code>mmkv.putInt(&quot;int&quot;, 1)</code>为例，进过 JNI 的调用到了</p>\n<p><strong>native-birdge.cpp</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">MMKV_JNI jboolean <span class=\"title\">encodeInt</span><span class=\"params\">(JNIEnv *env, jobject obj, jlong handle, jstring oKey, jint value)</span> </span>&#123;</span><br><span class=\"line\">    MMKV *kv = <span class=\"built_in\">reinterpret_cast</span>&lt;MMKV *&gt;(handle);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (kv &amp;&amp; oKey) &#123;</span><br><span class=\"line\">        string key = <span class=\"built_in\">jstring2string</span>(env, oKey);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (jboolean) kv-&gt;<span class=\"built_in\">set</span>((<span class=\"type\">int32_t</span>) value, key);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (jboolean) <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>进入了<strong>MMVK.cpp</strong>的 </p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">MMKV::set</span><span class=\"params\">(<span class=\"type\">int32_t</span> value, MMKVKey_t key, <span class=\"type\">uint32_t</span> expireDuration)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">isKeyEmpty</span>(key)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"type\">size_t</span> size = <span class=\"built_in\">mmkv_unlikely</span>(m_enableKeyExpire) ? Fixed32Size + <span class=\"built_in\">pbInt32Size</span>(value) : <span class=\"built_in\">pbInt32Size</span>(value);</span><br><span class=\"line\">    <span class=\"function\">MMBuffer <span class=\"title\">data</span><span class=\"params\">(size)</span></span>;</span><br><span class=\"line\">    <span class=\"function\">CodedOutputData <span class=\"title\">output</span><span class=\"params\">(data.getPtr(), size)</span></span>;</span><br><span class=\"line\">    output.<span class=\"built_in\">writeInt32</span>(value);</span><br><span class=\"line\">    <span class=\"comment\">// ... 省略一些校验逻辑</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">setDataForKey</span>(std::<span class=\"built_in\">move</span>(data), key);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这一步主要是准备一下数据，并使用 <code>MMBuffer</code> <code>CodedOutputData</code>将写入的数据进行一次包装（不仅仅是 key-value，还有数据size等等），实际调用在<code>setDataForKey</code></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">MMKV::setDataForKey</span><span class=\"params\">(MMBuffer &amp;&amp;data, MMKVKey_t key, <span class=\"type\">bool</span> isDataHolder)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">checkLoadData</span>(); <span class=\"comment\">// 状态同步相关的逻辑</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (m_crypter) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// ... 省略加密的处理逻辑</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">auto</span> itr = m_dic-&gt;<span class=\"built_in\">find</span>(key);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (itr != m_dic-&gt;<span class=\"built_in\">end</span>()) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// compare data before appending to file</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (<span class=\"built_in\">isCompareBeforeSetEnabled</span>()) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">auto</span> basePtr = (<span class=\"type\">uint8_t</span> *) (m_file-&gt;<span class=\"built_in\">getMemory</span>()) + Fixed32Size;</span><br><span class=\"line\">                MMBuffer oldValueData = itr-&gt;second.<span class=\"built_in\">toMMBuffer</span>(basePtr);</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (isDataHolder) &#123;</span><br><span class=\"line\">                    <span class=\"function\">CodedInputData <span class=\"title\">inputData</span><span class=\"params\">(oldValueData.getPtr(), oldValueData.length())</span></span>;</span><br><span class=\"line\">                    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                        <span class=\"comment\">// read extra holder header bytes and to real MMBuffer</span></span><br><span class=\"line\">                        oldValueData = CodedInputData::<span class=\"built_in\">readRealData</span>(oldValueData);</span><br><span class=\"line\">                        <span class=\"keyword\">if</span> (oldValueData == data) &#123;</span><br><span class=\"line\">                            <span class=\"comment\">// MMKVInfo(&quot;[key] %s, set the same data&quot;, key.c_str());</span></span><br><span class=\"line\">                            <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125; <span class=\"built_in\">catch</span> (std::exception &amp;exception) &#123;</span><br><span class=\"line\">                        <span class=\"built_in\">MMKVWarning</span>(<span class=\"string\">&quot;compareBeforeSet exception: %s&quot;</span>, exception.<span class=\"built_in\">what</span>());</span><br><span class=\"line\">                    &#125; <span class=\"built_in\">catch</span> (...) &#123;</span><br><span class=\"line\">                        <span class=\"built_in\">MMKVWarning</span>(<span class=\"string\">&quot;compareBeforeSet fail&quot;</span>);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                     ...</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"type\">bool</span> onlyOneKey = !<span class=\"built_in\">isMultiProcess</span>() &amp;&amp; m_dic-&gt;<span class=\"built_in\">size</span>() == <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (<span class=\"built_in\">mmkv_likely</span>(!m_enableKeyExpire)) &#123;</span><br><span class=\"line\">                ...</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                KVHolderRet_t ret;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (onlyOneKey) &#123;</span><br><span class=\"line\">                    ret = <span class=\"built_in\">overrideDataWithKey</span>(data, key, isDataHolder);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    ret = <span class=\"built_in\">appendDataWithKey</span>(data, key, isDataHolder);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (!ret.first) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                itr = m_dic-&gt;<span class=\"built_in\">find</span>(key);</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (itr != m_dic-&gt;<span class=\"built_in\">end</span>()) &#123;</span><br><span class=\"line\">                    itr-&gt;second = std::<span class=\"built_in\">move</span>(ret.second);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// in case filterExpiredKeys() is triggered</span></span><br><span class=\"line\">                    m_dic-&gt;<span class=\"built_in\">emplace</span>(key, std::<span class=\"built_in\">move</span>(ret.second));</span><br><span class=\"line\">                    <span class=\"built_in\">mmkv_retain_key</span>(key);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">           ...</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    m_hasFullWriteback = <span class=\"literal\">false</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里面的代码逻辑很长，做了很多 if-else 的逻辑，最终走向两个大分支：</p>\n<p>key 是新增的走 <code>appendDataWithKey</code></p>\n<p>key 将会覆盖原来的将会走 <code>overrideDataWithKey</code></p>\n<p>有这两个分支，主要是因为 mmkv 存储采用的  <a href=\"https://protobuf.com.cn/\">protobuf 协议</a>，另外有一个很重要的方法也在这里执行了：<code>checkLoadData();</code>  安卓里面的多进程实现，将需要这里的一些逻辑，在 mmkv多进程原理篇进行讲解。</p>\n<p><code>appendDataWithKey</code> 转换为 <code>MMBuffer</code>并继续向下执行</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">KVHolderRet_t <span class=\"title\">MMKV::appendDataWithKey</span><span class=\"params\">(<span class=\"type\">const</span> MMBuffer &amp;data, MMKVKey_t key, <span class=\"type\">bool</span> isDataHolder)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">auto</span> keyData = <span class=\"built_in\">MMBuffer</span>((<span class=\"type\">void</span> *) key.<span class=\"built_in\">data</span>(), key.<span class=\"built_in\">size</span>(), MMBufferNoCopy);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">doAppendDataWithKey</span>(data, keyData, isDataHolder, <span class=\"built_in\">static_cast</span>&lt;<span class=\"type\">uint32_t</span>&gt;(keyData.<span class=\"built_in\">length</span>()));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>doAppendDataWithKey</code> 里面的代码也很长，不过也就只做一件事：将k-v值写入到文件里面做准备，真正的写入逻辑在 <code>m_output-&gt;writeData(keyData);</code>，这里先后调用了两次 <code>writeData</code>,是先写入key再写入了 value。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">KVHolderRet_t</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">MMKV::doAppendDataWithKey</span><span class=\"params\">(<span class=\"type\">const</span> MMBuffer &amp;data, <span class=\"type\">const</span> MMBuffer &amp;keyData, <span class=\"type\">bool</span> isDataHolder, <span class=\"type\">uint32_t</span> originKeyLength)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">auto</span> isKeyEncoded = (originKeyLength &lt; keyData.<span class=\"built_in\">length</span>());</span><br><span class=\"line\">    <span class=\"keyword\">auto</span> keyLength = <span class=\"built_in\">static_cast</span>&lt;<span class=\"type\">uint32_t</span>&gt;(keyData.<span class=\"built_in\">length</span>());</span><br><span class=\"line\">    <span class=\"keyword\">auto</span> valueLength = <span class=\"built_in\">static_cast</span>&lt;<span class=\"type\">uint32_t</span>&gt;(data.<span class=\"built_in\">length</span>());</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (isDataHolder) &#123;</span><br><span class=\"line\">        valueLength += <span class=\"built_in\">pbRawVarint32Size</span>(valueLength);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// size needed to encode the key</span></span><br><span class=\"line\">    <span class=\"type\">size_t</span> size = isKeyEncoded ? keyLength : (keyLength + <span class=\"built_in\">pbRawVarint32Size</span>(keyLength));</span><br><span class=\"line\">    <span class=\"comment\">// size needed to encode the value</span></span><br><span class=\"line\">    size += valueLength + <span class=\"built_in\">pbRawVarint32Size</span>(valueLength);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">SCOPED_LOCK</span>(m_exclusiveProcessLock);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">bool</span> hasEnoughSize = <span class=\"built_in\">ensureMemorySize</span>(size);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!hasEnoughSize || !<span class=\"built_in\">isFileValid</span>()) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">make_pair</span>(<span class=\"literal\">false</span>, <span class=\"built_in\">KeyValueHolder</span>());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">\t\t...</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (isKeyEncoded) &#123;</span><br><span class=\"line\">            m_output-&gt;<span class=\"built_in\">writeRawData</span>(keyData);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            m_output-&gt;<span class=\"built_in\">writeData</span>(keyData);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (isDataHolder) &#123;</span><br><span class=\"line\">            m_output-&gt;<span class=\"built_in\">writeRawVarint32</span>((<span class=\"type\">int32_t</span>) valueLength);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        m_output-&gt;<span class=\"built_in\">writeData</span>(data); <span class=\"comment\">// note: write size of data</span></span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">    ...</span><br><span class=\"line\">    m_actualSize += size;</span><br><span class=\"line\">    <span class=\"built_in\">updateCRCDigest</span>(ptr, size);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">make_pair</span>(<span class=\"literal\">true</span>, <span class=\"built_in\">KeyValueHolder</span>(originKeyLength, valueLength, offset));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>writeData</code> 进行了两步先写入数据的 <strong>长度信息</strong>，再写入真实的数据，这里还是因为  <a href=\"https://protobuf.com.cn/\">protobuf 协议</a>设计相关</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">CodedOutputData::writeData</span><span class=\"params\">(<span class=\"type\">const</span> MMBuffer &amp;value)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>-&gt;<span class=\"built_in\">writeRawVarint32</span>((<span class=\"type\">int32_t</span>) value.<span class=\"built_in\">length</span>());</span><br><span class=\"line\">    <span class=\"keyword\">this</span>-&gt;<span class=\"built_in\">writeRawData</span>(value);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>最终走到了<code>writeRawData</code> 关键代码</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">CodedOutputData::writeRawData</span><span class=\"params\">(<span class=\"type\">const</span> MMBuffer &amp;data)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"type\">size_t</span> numberOfBytes = data.<span class=\"built_in\">length</span>();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (m_position + numberOfBytes &gt; m_size) &#123;</span><br><span class=\"line\">       ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">memcpy</span>(m_ptr + m_position, data.<span class=\"built_in\">getPtr</span>(), numberOfBytes);</span><br><span class=\"line\">    m_position += numberOfBytes;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>核心逻辑使用 <code>memcpy</code> 将数据直接通过 memcpy 直接在内存层面进行拷贝，而这里的 <code>m_ptr</code>就是最开始通过<code>mmap</code>创建出来的指针！！到这里一次写入基本上就结束了。</p>\n<h3 id=\"mmkv-一次-get-的流程\"><a href=\"#mmkv-一次-get-的流程\" class=\"headerlink\" title=\"mmkv 一次 get 的流程\"></a>mmkv 一次 get 的流程</h3><p>依然先通过 JNI走到</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">MMKV_JNI jint <span class=\"title\">decodeInt</span><span class=\"params\">(JNIEnv *env, jobject obj, jlong handle, jstring oKey, jint defaultValue)</span> </span>&#123;</span><br><span class=\"line\">    MMKV *kv = <span class=\"built_in\">reinterpret_cast</span>&lt;MMKV *&gt;(handle);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (kv &amp;&amp; oKey) &#123;</span><br><span class=\"line\">        string key = <span class=\"built_in\">jstring2string</span>(env, oKey);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (jint) kv-&gt;<span class=\"built_in\">getInt32</span>(key, defaultValue);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> defaultValue;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>再到 mmkv getInt32</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int32_t</span> <span class=\"title\">MMKV::getInt32</span><span class=\"params\">(MMKVKey_t key, <span class=\"type\">int32_t</span> defaultValue, <span class=\"type\">bool</span> *hasValue)</span> </span>&#123;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">    <span class=\"built_in\">SCOPED_LOCK</span>(m_lock);</span><br><span class=\"line\">    <span class=\"built_in\">SCOPED_LOCK</span>(m_sharedProcessLock);</span><br><span class=\"line\">    <span class=\"keyword\">auto</span> data = <span class=\"built_in\">getDataForKey</span>(key);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (data.<span class=\"built_in\">length</span>() &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"function\">CodedInputData <span class=\"title\">input</span><span class=\"params\">(data.getPtr(), data.length())</span></span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (hasValue != <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">                *hasValue = <span class=\"literal\">true</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> input.<span class=\"built_in\">readInt32</span>();</span><br><span class=\"line\">        &#125; </span><br><span class=\"line\">        ...</span><br><span class=\"line\">    <span class=\"keyword\">return</span> defaultValue;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>getRawDataForKey</code>方法，主要有两个分支，一种是加密逻辑，另一种是非加密逻辑，但他们流程都差不多从一个  map 里面根据 key 获取一个对象（这个对象暂时并不是 get 最终的返回值），那这个 map 是从哪里来的呢？</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">MMBuffer <span class=\"title\">MMKV::getRawDataForKey</span><span class=\"params\">(MMKVKey_t key)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">checkLoadData</span>();</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">ifndef</span> MMKV_DISABLE_CRYPT</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (m_crypter) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">auto</span> itr = m_dicCrypt-&gt;<span class=\"built_in\">find</span>(key);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (itr != m_dicCrypt-&gt;<span class=\"built_in\">end</span>()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">auto</span> basePtr = (<span class=\"type\">uint8_t</span> *) (m_file-&gt;<span class=\"built_in\">getMemory</span>()) + Fixed32Size;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> itr-&gt;second.<span class=\"built_in\">toMMBuffer</span>(basePtr, m_crypter);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span></span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">auto</span> itr = m_dic-&gt;<span class=\"built_in\">find</span>(key);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (itr != m_dic-&gt;<span class=\"built_in\">end</span>()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">auto</span> basePtr = (<span class=\"type\">uint8_t</span> *) (m_file-&gt;<span class=\"built_in\">getMemory</span>()) + Fixed32Size;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> itr-&gt;second.<span class=\"built_in\">toMMBuffer</span>(basePtr);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    MMBuffer nan;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> nan;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>从源码里面溯源<code>m_dicCrypt</code>和 <code>m_dic</code> 是在 MMKV 初始化的时候生成的，主要逻辑在 <code>MMKV_IO .cpp</code>里面的 <code>loadFromFile</code>方法内：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">MMKV::loadFromFile</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">loadMetaInfoAndCheck</span>();</span><br><span class=\"line\">\t\t...</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!m_file-&gt;<span class=\"built_in\">isFileValid</span>()) &#123;</span><br><span class=\"line\">        m_file-&gt;<span class=\"built_in\">reloadFromFile</span>(m_expectedCapacity);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!m_file-&gt;<span class=\"built_in\">isFileValid</span>()) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">MMKVError</span>(<span class=\"string\">&quot;file [%s] not valid&quot;</span>, m_path.<span class=\"built_in\">c_str</span>());</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">bool</span> loadFromFile = <span class=\"literal\">false</span>, needFullWriteback = <span class=\"literal\">false</span>;</span><br><span class=\"line\">        <span class=\"built_in\">checkDataValid</span>(loadFromFile, needFullWriteback);</span><br><span class=\"line\">        ...</span><br><span class=\"line\">        <span class=\"keyword\">auto</span> ptr = (<span class=\"type\">uint8_t</span> *) m_file-&gt;<span class=\"built_in\">getMemory</span>();</span><br><span class=\"line\">        <span class=\"comment\">// loading</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (loadFromFile &amp;&amp; m_actualSize &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\t\t\t...</span><br><span class=\"line\">            <span class=\"function\">MMBuffer <span class=\"title\">inputBuffer</span><span class=\"params\">(ptr + Fixed32Size, m_actualSize, MMBufferNoCopy)</span></span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (m_crypter) &#123;</span><br><span class=\"line\">                <span class=\"built_in\">clearDictionary</span>(m_dicCrypt);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"built_in\">clearDictionary</span>(m_dic);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (needFullWriteback) &#123;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">ifndef</span> MMKV_DISABLE_CRYPT</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (m_crypter) &#123;</span><br><span class=\"line\">                    MiniPBCoder::<span class=\"built_in\">greedyDecodeMap</span>(*m_dicCrypt, inputBuffer, m_crypter);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span></span></span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    MiniPBCoder::<span class=\"built_in\">greedyDecodeMap</span>(*m_dic, inputBuffer);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">ifndef</span> MMKV_DISABLE_CRYPT</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (m_crypter) &#123;</span><br><span class=\"line\">                    MiniPBCoder::<span class=\"built_in\">decodeMap</span>(*m_dicCrypt, inputBuffer, m_crypter);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span></span></span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    MiniPBCoder::<span class=\"built_in\">decodeMap</span>(*m_dic, inputBuffer);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            m_output = <span class=\"keyword\">new</span> <span class=\"built_in\">CodedOutputData</span>(ptr + Fixed32Size, m_file-&gt;<span class=\"built_in\">getFileSize</span>() - Fixed32Size);</span><br><span class=\"line\">            m_output-&gt;<span class=\"built_in\">seek</span>(m_actualSize);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (needFullWriteback) &#123;</span><br><span class=\"line\">                <span class=\"built_in\">fullWriteback</span>();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// file not valid or empty, discard everything</span></span><br><span class=\"line\">            <span class=\"built_in\">SCOPED_LOCK</span>(m_exclusiveProcessLock);</span><br><span class=\"line\"></span><br><span class=\"line\">            m_output = <span class=\"keyword\">new</span> <span class=\"built_in\">CodedOutputData</span>(ptr + Fixed32Size, m_file-&gt;<span class=\"built_in\">getFileSize</span>() - Fixed32Size);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (m_actualSize &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                <span class=\"built_in\">writeActualSize</span>(<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"literal\">nullptr</span>, IncreaseSequence);</span><br><span class=\"line\">                <span class=\"built_in\">sync</span>(MMKV_SYNC);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"built_in\">writeActualSize</span>(<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"literal\">nullptr</span>, KeepSequence);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">\t\t\t\t...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    m_needLoadFromFile = <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>总统来说就是在初始化的时候就会将基于<code>protobuf</code>协议的本地文件里面的数据加载到内存，并将其放在一个 map 内，方便后续使用。</p>\n<p>回到 <code>int32_t MMKV::getInt32()</code>通过 <code>getDataForKey(key)</code>获取到一个<code>MMBuffer</code>对象，并通过 <strong>CodedInputData</strong>进行反序列化操作，读取 <strong>Varint32</strong> 的 <strong>valueSize</strong> 值，随后不断循环通过 <strong>CodedInputData</strong>  读取到<strong>value</strong> 值。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int32_t</span> <span class=\"title\">MMKV::getInt32</span><span class=\"params\">(MMKVKey_t key, <span class=\"type\">int32_t</span> defaultValue, <span class=\"type\">bool</span> *hasValue)</span> </span>&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"keyword\">auto</span> data = <span class=\"built_in\">getDataForKey</span>(key);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (data.<span class=\"built_in\">length</span>() &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"function\">CodedInputData <span class=\"title\">input</span><span class=\"params\">(data.getPtr(), data.length())</span></span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (hasValue != <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">                *hasValue = <span class=\"literal\">true</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> input.<span class=\"built_in\">readInt32</span>();</span><br><span class=\"line\">        &#125; </span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  \t...</span><br><span class=\"line\">    <span class=\"keyword\">return</span> defaultValue;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"mmkv-与-SharedPreferences\"><a href=\"#mmkv-与-SharedPreferences\" class=\"headerlink\" title=\"mmkv 与 SharedPreferences\"></a>mmkv 与 SharedPreferences</h2><p>以下是 <strong>MMKV</strong> 与 <strong>SharedPreferences</strong> 的优劣势对比总结，结合性能、安全性、功能支持等核心维度进行分析：</p>\n<h3 id=\"性能对比\"><a href=\"#性能对比\" class=\"headerlink\" title=\"性能对比\"></a><strong>性能对比</strong></h3><table>\n<thead>\n<tr>\n<th align=\"left\"><strong>维度</strong></th>\n<th align=\"left\"><strong>SharedPreferences</strong></th>\n<th align=\"left\"><strong>MMKV</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><strong>读写速度</strong></td>\n<td align=\"left\">慢（同步 I&#x2F;O，多次数据拷贝）</td>\n<td align=\"left\">快（<code>mmap</code> 零拷贝，内存直接操作）</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>线程安全</strong></td>\n<td align=\"left\">需自行加锁（<code>apply()</code> 异步写入仍有风险）</td>\n<td align=\"left\">内置多线程锁（文件锁 + 内存锁）</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>大数据量支持</strong></td>\n<td align=\"left\">性能急剧下降（全量 XML 解析&#x2F;序列化）</td>\n<td align=\"left\">高效（增量更新，Protobuf 编码）</td>\n</tr>\n</tbody></table>\n<h3 id=\"安全性与稳定性\"><a href=\"#安全性与稳定性\" class=\"headerlink\" title=\"安全性与稳定性\"></a><strong>安全性与稳定性</strong></h3><table>\n<thead>\n<tr>\n<th align=\"left\"><strong>维度</strong></th>\n<th align=\"left\"><strong>SharedPreferences</strong></th>\n<th align=\"left\"><strong>MMKV</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><strong>数据加密</strong></td>\n<td align=\"left\">无（明文存储）</td>\n<td align=\"left\">支持 AES-128&#x2F;AES-256 加密</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>崩溃恢复</strong></td>\n<td align=\"left\">可能因异常导致 XML 损坏</td>\n<td align=\"left\">通过 CRC 校验 + 备份文件保障完整性</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>系统版本适配</strong></td>\n<td align=\"left\">部分版本有 ANR 问题（如 <code>apply()</code>）</td>\n<td align=\"left\">无系统级兼容性问题</td>\n</tr>\n</tbody></table>\n<h3 id=\"功能支持\"><a href=\"#功能支持\" class=\"headerlink\" title=\"功能支持\"></a><strong>功能支持</strong></h3><table>\n<thead>\n<tr>\n<th align=\"left\"><strong>维度</strong></th>\n<th align=\"left\"><strong>SharedPreferences</strong></th>\n<th align=\"left\"><strong>MMKV</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><strong>多进程</strong></td>\n<td align=\"left\">不支持（跨进程数据不同步）</td>\n<td align=\"left\">支持（通过文件锁 + <code>mmap</code> 共享内存）</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>数据类型</strong></td>\n<td align=\"left\">仅支持基本类型（int&#x2F;String 等）</td>\n<td align=\"left\">支持基本类型、二进制数据（MMBuffer）</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>加密存储</strong></td>\n<td align=\"left\">明文存储（XML）</td>\n<td align=\"left\">支持 AES 加密（可选）</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>增量更新</strong></td>\n<td align=\"left\">全量写入（即使只改一个键值）</td>\n<td align=\"left\">仅追加新数据，定期整理</td>\n</tr>\n</tbody></table>\n<p>从上面的对比看看，mmkv 在很多层面都是领先 SharedPreferences 的，那么 mmkv 是否有缺陷呢？答案是有的。</p>\n<blockquote>\n<p>任何的操作系统、任何的软件，在往磁盘写数据的过程中如果发生了意外——例如程序崩溃，或者断电关机——磁盘里的文件就会以这种写了一半的、不完整的形式被保留。写了一半的数据怎么用啊？没法用，这就是文件的损坏。这种问题是不可能避免的，MMKV 虽然由于底层机制的原因，在程序崩溃的时候不会影响数据往磁盘的写入，但断电关机之类的操作系统级别的崩溃，MMKV 就没办法了，文件照样会损坏。对于这种文件损坏，SharedPreferences 和 DataStore 的应对方式是在每次写入新数据之前都对现有文件做一次自动备份，这样在发生了意外出现了文件损坏之后，它们就会把备份的数据恢复过来；而 MMKV，没有这种自动的备份和恢复，那么当文件发生了损坏，数据就丢了，之前保存的各种信息只能被重置。也就是说，MMKV 是唯一会丢数据的方案。</p>\n</blockquote>\n<p>在 mmkv 里面有 <a href=\"https://info.support.huawei.com/info-finder/encyclopedia/zh/CRC.html\">CRC</a> 校验，如果不通过的话，将会废弃掉之前所有的数据。在 mmkv 里面也有人反馈：<a href=\"https://github.com/Tencent/MMKV/issues/729\">https://github.com/Tencent/MMKV/issues/729</a> 在写入的过程中因为一些特殊情况写入失败，会导致本地的文件损坏且不可recovery。</p>\n<p>那有什么办法避免这个问题呢？有大佬开源另一个 KV 框架 <a href=\"https://github.com/BillyWei01/FastKV\">FastKV</a>对这个问题进行了处理，采用通过double-write等方法确保数据的完整性，原理是数据依次写入A&#x2F;B两个文件，如果写入A过程中崩溃，B仍是完整的，如果A完整写入了，则B写入时崩溃也不要紧。这种实现方式理论上是不错的，不太清楚 mmkv 为什么没有采取这样的逻辑。不过这个库并没有经过大量业务进行验证，只能作为一个学习的方案先看看。</p>\n<p>另外谷歌已经开发了新的KV存储框架<a href=\"https://cloud.google.com/datastore/docs/concepts/overview?hl=zh-cn\">DataStore</a>，<code>SharedPreferences</code>也将渐渐地退出历史的舞台了。不过 DataStore 的性能目前仍然没有 mmkv 的好。关于这三者的比较可以查看： <a href=\"https://juejin.cn/post/7112268981163016229\">《Android 的键值对存储有没有最优解？》</a></p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>这篇文章深入剖析了 <strong>MMKV</strong>（腾讯开源的高性能键值存储组件）的核心设计与实现原理，重点对比了传统 I&#x2F;O 与 <code>mmap</code> 内存映射的差异，并详细分析了 MMKV 的读写流程以及和 SharedPreferences 的各方面对比。</p>\n<p><strong>参考</strong></p>\n<p><a href=\"https://juejin.cn/post/7112268981163016229\">《Android 的键值对存储有没有最优解？》</a></p>\n<p><a href=\"https://yangjie2.github.io/2021/11/14/mmap%E5%8E%9F%E7%90%86%E4%B8%8E%E5%BA%94%E7%94%A8/\">《mmap原理与应用》</a></p>\n<p><a href=\"https://blog.csdn.net/zhanglh046/article/details/115603788\">《文件内存映射和传统I&#x2F;O机制》</a></p>\n<p><a href=\"https://blog.csdn.net/luo_boke/article/details/109311432\">Android 内存映射mmap浅谈</a></p>\n","cover":null,"images":["https://cdn.julis.wang/blog/img/ee519ba873acf3f80fd4ccec86ed72e7.png","https://cdn.julis.wang/blog/img/mmap_1.png","https://cdn.julis.wang/blog/img/mmap_2_1.png"],"content":"<p>在平时的业务中，需要用到轻量级存储业务中的数据（例如设置数据存储），绝大多数时候 Anroid 管法提供的 <a href=\"https://developer.android.com/reference/android/content/SharedPreferences\">SharedPreferences</a>  组件就能实现，但针对一些需要高效的场景它就不那么使用了，不适合存储大量数据、多线程操作的不安全性、数据明文不安全性，以及不支持多进程之间的调用等各种问题。<br><a href=\"https://github.com/Tencent/MMKV\">MMKV</a>的诞生就是为了解决以上的问题，本文主要对 MMKV 源码的学习知识点进行一些总结。</p>\n<h2 id=\"核心设计与原理\"><a href=\"#核心设计与原理\" class=\"headerlink\" title=\"核心设计与原理\"></a>核心设计与原理</h2><p>在官方的开源工程中可以看到如下的一些介绍</p>\n<blockquote>\n<p>MMKV 是基于 mmap 内存映射的 key-value 组件，底层序列化&#x2F;反序列化使用 protobuf 实现，性能高，稳定性强。从 2015 年中至今在微信上使用，其性能和稳定性经过了时间的验证。</p>\n</blockquote>\n<h3 id=\"传统I-O与-mmap\"><a href=\"#传统I-O与-mmap\" class=\"headerlink\" title=\"传统I&#x2F;O与 mmap\"></a>传统I&#x2F;O与 mmap</h3><p>mmap 这个是 mmkv 实现的核心，没有 mmap 那么就没有 mmkv。对于 <code>SharedPreferences</code>的实现来说，每次的数据更新都将操作本地文件，而本地文件的写入是通过传统的I&#x2F;O实现。要理解两者的实现差异，需要先理解 Linux <strong>用户空间与内核空间</strong>设计。</p>\n<h4 id=\"用户空间与内核空间\"><a href=\"#用户空间与内核空间\" class=\"headerlink\" title=\"用户空间与内核空间\"></a><strong>用户空间与内核空间</strong></h4><p>Linux的进程是相互独立的，一个进程是不能直接操作或者访问别一个进程空间的。每个进程空间还分为用户空间和内核（Kernel）空间，相当于把Kernel和上层的应用程序抽像的隔离开。</p>\n<p><strong>用户空间</strong>和<strong>内核空间</strong>，用户空间是用户程序代码运行的地方，内核空间是内核代码运行的地方。为了安全，它们是隔离的，即使用户的程序崩溃了，内核也不受影响。</p>\n<p>这里有两个隔离，一个进程间是相互隔离的，二是进程内有用户空间和内核空间的隔离。</p>\n<p>进程间，用户空间的数据不可共享，所以用户空间 &#x3D; 不可共享空间<br>进程间，内核空间的数据可共享，所以内核空间 &#x3D; 可共享空间，所以Linux系统的内存通常是MemFree+Cache<br>所有进程共用1个内核空间。</p>\n<h4 id=\"传统I-O读写流程\"><a href=\"#传统I-O读写流程\" class=\"headerlink\" title=\"传统I&#x2F;O读写流程\"></a><strong>传统I&#x2F;O读写流程</strong></h4><p>常规文件读写操作（调用read&#x2F;fread等函数）过程如下：</p>\n<ul>\n<li><p>进程发起读写文件请求。</p>\n</li>\n<li><p>内核通过查找进程文件符表，定位到内核已打开文件集上的文件信息，从而找到此文件的<code>inode</code>。</p>\n</li>\n<li><p><code>inode</code> 在 <code>address_space</code> 上查找要请求的文件页是否已经缓存在页缓存中。如果存在，则直接返回这片文件页的内容。</p>\n</li>\n<li><p>如果不存在，则通过 <code>inode</code> 定位到文件磁盘地址，将数据从磁盘复制到页缓存。之后再次发起读页面过程，进而将页缓存中的数据发给用户进程。</p>\n<blockquote>\n<p><strong>什么是 inode</strong> ?</p>\n<p>全称为 index node，既<strong>存储文件元信息的区域</strong>，中文译名“索引节点”。<br>包含：文件权限、文件拥有者的UID、文件的大小等等。</p>\n</blockquote>\n</li>\n</ul>\n<img src=\"https://cdn.julis.wang/blog/img/ee519ba873acf3f80fd4ccec86ed72e7.png\">\n\n\n<p>总结来说，常规文件操作为了提高读写效率和保护磁盘，使用了页缓存机制。这样造成读文件时需要先将文件页从磁盘拷贝到页缓存中，由于页缓存处在内核空间，不能被用户进程直接寻址访问，所以还需要将页缓存中的数据页再次拷贝到用户空间中。这样，通过了两次数据拷贝过程，才能完成<strong>进程</strong>对<strong>文件</strong>内容的访问。</p>\n<h4 id=\"mmap基本概念和原理\"><a href=\"#mmap基本概念和原理\" class=\"headerlink\" title=\"mmap基本概念和原理\"></a><strong>mmap基本概念和原理</strong></h4><p>内存映射（mmap），就是<strong>将文件的磁盘扇区映射到进程的虚拟内存空间</strong>的过程，即将一个文件映射到进程的虚拟空间，实现文件磁盘地址和进程虚拟空间中一段虚拟地址的一一对应关系。实现这样的映射关系后，进程就可以采用指针的方式读写操作这一段内存，而系统会自动回写脏页面到对应的文件磁盘上，即完成了对文件的操作而不必再调用read,write等系统调用函数。</p>\n<img src=\"https://cdn.julis.wang/blog/img/mmap_1.png\">\n\n<p>由上图可知，进程的虚拟地址空间，由多个虚拟内存区域构成。每个虚拟内存区域都是进程在虚拟地址空间中的一个同质区间，即具有同样特性的连续地址范围。上图中所示的text数据段（代码段）、初始数据段、BSS数据段、堆、栈和内存映射，都是一个独立的虚拟内存区域。内存映射的地址空间处在堆栈之间的空余部分。</p>\n<p>linux内核使用 <code>vm_area_struc</code>t 结构来表示一个独立的虚拟内存区域，由于每个不同质的虚拟内存区域功能和内部机制都不同，因此一个进程使用多个 <code>vm_area_struct</code> 结构来分别表示不同类型的虚拟内存区域。各个 <code>vm_area_struct</code> 结构使用链表或者树形结构链接，方便进程快速访问，如下图所示：</p>\n<img src=\"https://cdn.julis.wang/blog/img/mmap_2_1.png\">\n\n<p><code>vm_area_struct</code> 结构中包含区域起始和终止地址以及其他相关信息。这样，进程对某一虚拟内存区域的任何操作需要用要的信息，都可以从 <code>vm_area_struct</code> 中获得。mmap函数就是要创建一个新的 <code>vm_area_struct</code> 结构，并将其与文件的物理磁盘地址相连。</p>\n<p>mmap内存映射的实现过程，总的来说可以分为三个阶段：</p>\n<p><strong>阶段一：进程启动映射过程，并在虚拟地址空间中为映射创建虚拟映射区域</strong></p>\n<ul>\n<li>进程在用户空间调用mmap库函数</li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> *<span class=\"title\">mmap</span><span class=\"params\">(<span class=\"type\">void</span> *addr, <span class=\"type\">size_t</span> length, <span class=\"type\">int</span> prot, <span class=\"type\">int</span> flags, <span class=\"type\">int</span> fd, <span class=\"type\">off_t</span> offset)</span></span>;</span><br></pre></td></tr></table></figure>\n\n<p><code>addr</code>：指定映射的虚拟内存地址，可以设置为 NULL，让内核自动选择合适的虚拟内存地址</p>\n<p><code>length</code>：映射的长度。</p>\n<p><code>prot</code>：映射内存的保护模式，可选值如下：  </p>\n<p><code>flags</code>：指定映射的类型</p>\n<p><code>fd</code>：进行映射的文件句柄。</p>\n<p><code>offset</code>：文件偏移量（从文件的何处开始映射）</p>\n<ul>\n<li><p>在当前进程的虚拟地址空间中，寻找一段空闲的满足要求的连续的虚拟地址</p>\n</li>\n<li><p>为此虚拟区分配一个 <code>vm_area_struct</code> 结构，接着对这个结构的各个域进行了初始化</p>\n</li>\n<li><p>将新创建的虚拟区结构 <code>vm_area_struct</code> 对象插入到进程的虚拟地址区域链表&#x2F;树中</p>\n</li>\n</ul>\n<p><strong>阶段二：调用内核空间的mmap函数（不同于用户空间函数），实现文件物理地址和进程虚拟地址的一一映射关系</strong></p>\n<ul>\n<li><p>为映射分配了新的虚拟地址区域后，通过待映射的文件指针，在文件描述符表中找到对应的文件描述符，通过文件描述符，链接到内核“已打开文件集”中该文件的文件结构体（struct file），每个文件结构体维护着和这个已打开文件相关各项信息。</p>\n</li>\n<li><p>为映射分配了新的虚拟地址区域后，通过待映射的文件指针，在文件描述符表中找到对应的文件描述符，通过文件描述符，链接到内核“已打开文件集”中该文件的文件结构体（struct file），每个文件结构体维护着和这个已打开文件相关各项信息。</p>\n</li>\n<li><p>通过该文件的文件结构体，链接到 <code>file_operations</code> 模块，调用内核mmap函数，其原型为：</p>\n</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">int mmap(struct file *filp, struct vm_area_struct *vma) //不同于用户空间mmap库函数</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>内核mmap函数通过虚拟文件系统inode模块定位到文件磁盘物理地址。</p>\n</li>\n<li><p>通过 <code>remap_pfn_range</code> 函数建立页表，即实现了文件地址和虚拟地址区域的映射关系。此时，这片虚拟地址并没有任何数据关联到物理内存(主存)中。</p>\n</li>\n</ul>\n<blockquote>\n<p>主存</p>\n<p>主存储器（Main memory），简称主存。是计算机硬件的一个重要部件，其作用是存放指令和数据，并能由中央处理器（CPU）直接随机存取</p>\n</blockquote>\n<p><strong>阶段三：进程发起对这片映射地址空间的访问，引发缺页异常，实现文件内容到主存（物理内存）的拷贝</strong></p>\n<blockquote>\n<p>前两个阶段仅在于创建虚拟区间并完成地址映射，但是并没有将任何文件数据的拷贝至主存。真正的文件读取是当进程发起读或写操作时</p>\n</blockquote>\n<ul>\n<li><p>进程的读或写操作访问虚拟地址空间这一段映射地址，通过查询页表，发现这一段地址并不在物理页上。因为目前只建立了地址映射，真正的硬盘数据还没有拷贝到内存中，因此引发缺页异常。</p>\n</li>\n<li><p>缺页异常进行一系列判断，确定无非法操作后，内核发起请求调页过程。</p>\n</li>\n<li><p>调页过程先在交换缓存空间（swap cache）中寻找需要访问的内存页，如果没有则调用nopage函数把所缺的页从磁盘装入到主存中。</p>\n</li>\n<li><p>之后进程即可对这片主存进行读或者写的操作，如果写操作改变了其内容，一定时间后系统会自动回写脏页面到对应磁盘地址，也即完成了写入到文件的过程。</p>\n</li>\n</ul>\n<blockquote>\n<p>修改过的脏页面并不会立即更新回文件中，而是有一段时间的延迟，可以调用<code>msync()</code>来强制同步, 这样所写的内容就能立即保存到文件里了</p>\n</blockquote>\n<p>常规文件操作需要从磁盘到内核空间页缓存再到用户空间主存的两次数据拷贝。而mmap文件映射，只需要从磁盘到用户空间主存的一次数据拷贝过程。mmap的关键点是实现了用户空间和内核空间的数据直接交互而省去了空间不同数据不通的繁琐过程，因此 mmap 效率更高。</p>\n<p>以上是 mmap 的基本概念和原理，搞明白了这些才能看明白整个 mmkv 里面的逻辑处理</p>\n<h3 id=\"mmkv-一次-put-的流程\"><a href=\"#mmkv-一次-put-的流程\" class=\"headerlink\" title=\"mmkv 一次 put 的流程\"></a>mmkv 一次 put 的流程</h3><p>mmkv初始化比较简单，主要涉及到一些配置的初始化，文件夹创建等，其中最重要的逻辑 mmap 调用被封装到一个 <code>MemoryFile</code>到对象里面 </p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">MemoryFile::mmap</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">auto</span> oldPtr = m_ptr;</span><br><span class=\"line\">    <span class=\"keyword\">auto</span> mode = m_readOnly ? PROT_READ : (PROT_READ | PROT_WRITE);</span><br><span class=\"line\">    m_ptr = (<span class=\"type\">char</span> *) ::<span class=\"built_in\">mmap</span>(m_ptr, m_size, mode, MAP_SHARED, m_diskFile.m_fd, <span class=\"number\">0</span>);</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>主要记录一下一次 put 任务的流程，以 <code>mmkv.putInt(&quot;int&quot;, 1)</code>为例，进过 JNI 的调用到了</p>\n<p><strong>native-birdge.cpp</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">MMKV_JNI jboolean <span class=\"title\">encodeInt</span><span class=\"params\">(JNIEnv *env, jobject obj, jlong handle, jstring oKey, jint value)</span> </span>&#123;</span><br><span class=\"line\">    MMKV *kv = <span class=\"built_in\">reinterpret_cast</span>&lt;MMKV *&gt;(handle);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (kv &amp;&amp; oKey) &#123;</span><br><span class=\"line\">        string key = <span class=\"built_in\">jstring2string</span>(env, oKey);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (jboolean) kv-&gt;<span class=\"built_in\">set</span>((<span class=\"type\">int32_t</span>) value, key);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (jboolean) <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>进入了<strong>MMVK.cpp</strong>的 </p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">MMKV::set</span><span class=\"params\">(<span class=\"type\">int32_t</span> value, MMKVKey_t key, <span class=\"type\">uint32_t</span> expireDuration)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">isKeyEmpty</span>(key)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"type\">size_t</span> size = <span class=\"built_in\">mmkv_unlikely</span>(m_enableKeyExpire) ? Fixed32Size + <span class=\"built_in\">pbInt32Size</span>(value) : <span class=\"built_in\">pbInt32Size</span>(value);</span><br><span class=\"line\">    <span class=\"function\">MMBuffer <span class=\"title\">data</span><span class=\"params\">(size)</span></span>;</span><br><span class=\"line\">    <span class=\"function\">CodedOutputData <span class=\"title\">output</span><span class=\"params\">(data.getPtr(), size)</span></span>;</span><br><span class=\"line\">    output.<span class=\"built_in\">writeInt32</span>(value);</span><br><span class=\"line\">    <span class=\"comment\">// ... 省略一些校验逻辑</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">setDataForKey</span>(std::<span class=\"built_in\">move</span>(data), key);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这一步主要是准备一下数据，并使用 <code>MMBuffer</code> <code>CodedOutputData</code>将写入的数据进行一次包装（不仅仅是 key-value，还有数据size等等），实际调用在<code>setDataForKey</code></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">MMKV::setDataForKey</span><span class=\"params\">(MMBuffer &amp;&amp;data, MMKVKey_t key, <span class=\"type\">bool</span> isDataHolder)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">checkLoadData</span>(); <span class=\"comment\">// 状态同步相关的逻辑</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (m_crypter) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// ... 省略加密的处理逻辑</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">auto</span> itr = m_dic-&gt;<span class=\"built_in\">find</span>(key);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (itr != m_dic-&gt;<span class=\"built_in\">end</span>()) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// compare data before appending to file</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (<span class=\"built_in\">isCompareBeforeSetEnabled</span>()) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">auto</span> basePtr = (<span class=\"type\">uint8_t</span> *) (m_file-&gt;<span class=\"built_in\">getMemory</span>()) + Fixed32Size;</span><br><span class=\"line\">                MMBuffer oldValueData = itr-&gt;second.<span class=\"built_in\">toMMBuffer</span>(basePtr);</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (isDataHolder) &#123;</span><br><span class=\"line\">                    <span class=\"function\">CodedInputData <span class=\"title\">inputData</span><span class=\"params\">(oldValueData.getPtr(), oldValueData.length())</span></span>;</span><br><span class=\"line\">                    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                        <span class=\"comment\">// read extra holder header bytes and to real MMBuffer</span></span><br><span class=\"line\">                        oldValueData = CodedInputData::<span class=\"built_in\">readRealData</span>(oldValueData);</span><br><span class=\"line\">                        <span class=\"keyword\">if</span> (oldValueData == data) &#123;</span><br><span class=\"line\">                            <span class=\"comment\">// MMKVInfo(&quot;[key] %s, set the same data&quot;, key.c_str());</span></span><br><span class=\"line\">                            <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125; <span class=\"built_in\">catch</span> (std::exception &amp;exception) &#123;</span><br><span class=\"line\">                        <span class=\"built_in\">MMKVWarning</span>(<span class=\"string\">&quot;compareBeforeSet exception: %s&quot;</span>, exception.<span class=\"built_in\">what</span>());</span><br><span class=\"line\">                    &#125; <span class=\"built_in\">catch</span> (...) &#123;</span><br><span class=\"line\">                        <span class=\"built_in\">MMKVWarning</span>(<span class=\"string\">&quot;compareBeforeSet fail&quot;</span>);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                     ...</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"type\">bool</span> onlyOneKey = !<span class=\"built_in\">isMultiProcess</span>() &amp;&amp; m_dic-&gt;<span class=\"built_in\">size</span>() == <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (<span class=\"built_in\">mmkv_likely</span>(!m_enableKeyExpire)) &#123;</span><br><span class=\"line\">                ...</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                KVHolderRet_t ret;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (onlyOneKey) &#123;</span><br><span class=\"line\">                    ret = <span class=\"built_in\">overrideDataWithKey</span>(data, key, isDataHolder);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    ret = <span class=\"built_in\">appendDataWithKey</span>(data, key, isDataHolder);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (!ret.first) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                itr = m_dic-&gt;<span class=\"built_in\">find</span>(key);</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (itr != m_dic-&gt;<span class=\"built_in\">end</span>()) &#123;</span><br><span class=\"line\">                    itr-&gt;second = std::<span class=\"built_in\">move</span>(ret.second);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// in case filterExpiredKeys() is triggered</span></span><br><span class=\"line\">                    m_dic-&gt;<span class=\"built_in\">emplace</span>(key, std::<span class=\"built_in\">move</span>(ret.second));</span><br><span class=\"line\">                    <span class=\"built_in\">mmkv_retain_key</span>(key);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">           ...</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    m_hasFullWriteback = <span class=\"literal\">false</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里面的代码逻辑很长，做了很多 if-else 的逻辑，最终走向两个大分支：</p>\n<p>key 是新增的走 <code>appendDataWithKey</code></p>\n<p>key 将会覆盖原来的将会走 <code>overrideDataWithKey</code></p>\n<p>有这两个分支，主要是因为 mmkv 存储采用的  <a href=\"https://protobuf.com.cn/\">protobuf 协议</a>，另外有一个很重要的方法也在这里执行了：<code>checkLoadData();</code>  安卓里面的多进程实现，将需要这里的一些逻辑，在 mmkv多进程原理篇进行讲解。</p>\n<p><code>appendDataWithKey</code> 转换为 <code>MMBuffer</code>并继续向下执行</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">KVHolderRet_t <span class=\"title\">MMKV::appendDataWithKey</span><span class=\"params\">(<span class=\"type\">const</span> MMBuffer &amp;data, MMKVKey_t key, <span class=\"type\">bool</span> isDataHolder)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">auto</span> keyData = <span class=\"built_in\">MMBuffer</span>((<span class=\"type\">void</span> *) key.<span class=\"built_in\">data</span>(), key.<span class=\"built_in\">size</span>(), MMBufferNoCopy);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">doAppendDataWithKey</span>(data, keyData, isDataHolder, <span class=\"built_in\">static_cast</span>&lt;<span class=\"type\">uint32_t</span>&gt;(keyData.<span class=\"built_in\">length</span>()));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>doAppendDataWithKey</code> 里面的代码也很长，不过也就只做一件事：将k-v值写入到文件里面做准备，真正的写入逻辑在 <code>m_output-&gt;writeData(keyData);</code>，这里先后调用了两次 <code>writeData</code>,是先写入key再写入了 value。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">KVHolderRet_t</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">MMKV::doAppendDataWithKey</span><span class=\"params\">(<span class=\"type\">const</span> MMBuffer &amp;data, <span class=\"type\">const</span> MMBuffer &amp;keyData, <span class=\"type\">bool</span> isDataHolder, <span class=\"type\">uint32_t</span> originKeyLength)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">auto</span> isKeyEncoded = (originKeyLength &lt; keyData.<span class=\"built_in\">length</span>());</span><br><span class=\"line\">    <span class=\"keyword\">auto</span> keyLength = <span class=\"built_in\">static_cast</span>&lt;<span class=\"type\">uint32_t</span>&gt;(keyData.<span class=\"built_in\">length</span>());</span><br><span class=\"line\">    <span class=\"keyword\">auto</span> valueLength = <span class=\"built_in\">static_cast</span>&lt;<span class=\"type\">uint32_t</span>&gt;(data.<span class=\"built_in\">length</span>());</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (isDataHolder) &#123;</span><br><span class=\"line\">        valueLength += <span class=\"built_in\">pbRawVarint32Size</span>(valueLength);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// size needed to encode the key</span></span><br><span class=\"line\">    <span class=\"type\">size_t</span> size = isKeyEncoded ? keyLength : (keyLength + <span class=\"built_in\">pbRawVarint32Size</span>(keyLength));</span><br><span class=\"line\">    <span class=\"comment\">// size needed to encode the value</span></span><br><span class=\"line\">    size += valueLength + <span class=\"built_in\">pbRawVarint32Size</span>(valueLength);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">SCOPED_LOCK</span>(m_exclusiveProcessLock);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">bool</span> hasEnoughSize = <span class=\"built_in\">ensureMemorySize</span>(size);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!hasEnoughSize || !<span class=\"built_in\">isFileValid</span>()) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">make_pair</span>(<span class=\"literal\">false</span>, <span class=\"built_in\">KeyValueHolder</span>());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">\t\t...</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (isKeyEncoded) &#123;</span><br><span class=\"line\">            m_output-&gt;<span class=\"built_in\">writeRawData</span>(keyData);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            m_output-&gt;<span class=\"built_in\">writeData</span>(keyData);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (isDataHolder) &#123;</span><br><span class=\"line\">            m_output-&gt;<span class=\"built_in\">writeRawVarint32</span>((<span class=\"type\">int32_t</span>) valueLength);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        m_output-&gt;<span class=\"built_in\">writeData</span>(data); <span class=\"comment\">// note: write size of data</span></span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">    ...</span><br><span class=\"line\">    m_actualSize += size;</span><br><span class=\"line\">    <span class=\"built_in\">updateCRCDigest</span>(ptr, size);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">make_pair</span>(<span class=\"literal\">true</span>, <span class=\"built_in\">KeyValueHolder</span>(originKeyLength, valueLength, offset));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>writeData</code> 进行了两步先写入数据的 <strong>长度信息</strong>，再写入真实的数据，这里还是因为  <a href=\"https://protobuf.com.cn/\">protobuf 协议</a>设计相关</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">CodedOutputData::writeData</span><span class=\"params\">(<span class=\"type\">const</span> MMBuffer &amp;value)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>-&gt;<span class=\"built_in\">writeRawVarint32</span>((<span class=\"type\">int32_t</span>) value.<span class=\"built_in\">length</span>());</span><br><span class=\"line\">    <span class=\"keyword\">this</span>-&gt;<span class=\"built_in\">writeRawData</span>(value);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>最终走到了<code>writeRawData</code> 关键代码</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">CodedOutputData::writeRawData</span><span class=\"params\">(<span class=\"type\">const</span> MMBuffer &amp;data)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"type\">size_t</span> numberOfBytes = data.<span class=\"built_in\">length</span>();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (m_position + numberOfBytes &gt; m_size) &#123;</span><br><span class=\"line\">       ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">memcpy</span>(m_ptr + m_position, data.<span class=\"built_in\">getPtr</span>(), numberOfBytes);</span><br><span class=\"line\">    m_position += numberOfBytes;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>核心逻辑使用 <code>memcpy</code> 将数据直接通过 memcpy 直接在内存层面进行拷贝，而这里的 <code>m_ptr</code>就是最开始通过<code>mmap</code>创建出来的指针！！到这里一次写入基本上就结束了。</p>\n<h3 id=\"mmkv-一次-get-的流程\"><a href=\"#mmkv-一次-get-的流程\" class=\"headerlink\" title=\"mmkv 一次 get 的流程\"></a>mmkv 一次 get 的流程</h3><p>依然先通过 JNI走到</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">MMKV_JNI jint <span class=\"title\">decodeInt</span><span class=\"params\">(JNIEnv *env, jobject obj, jlong handle, jstring oKey, jint defaultValue)</span> </span>&#123;</span><br><span class=\"line\">    MMKV *kv = <span class=\"built_in\">reinterpret_cast</span>&lt;MMKV *&gt;(handle);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (kv &amp;&amp; oKey) &#123;</span><br><span class=\"line\">        string key = <span class=\"built_in\">jstring2string</span>(env, oKey);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (jint) kv-&gt;<span class=\"built_in\">getInt32</span>(key, defaultValue);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> defaultValue;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>再到 mmkv getInt32</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int32_t</span> <span class=\"title\">MMKV::getInt32</span><span class=\"params\">(MMKVKey_t key, <span class=\"type\">int32_t</span> defaultValue, <span class=\"type\">bool</span> *hasValue)</span> </span>&#123;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">    <span class=\"built_in\">SCOPED_LOCK</span>(m_lock);</span><br><span class=\"line\">    <span class=\"built_in\">SCOPED_LOCK</span>(m_sharedProcessLock);</span><br><span class=\"line\">    <span class=\"keyword\">auto</span> data = <span class=\"built_in\">getDataForKey</span>(key);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (data.<span class=\"built_in\">length</span>() &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"function\">CodedInputData <span class=\"title\">input</span><span class=\"params\">(data.getPtr(), data.length())</span></span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (hasValue != <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">                *hasValue = <span class=\"literal\">true</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> input.<span class=\"built_in\">readInt32</span>();</span><br><span class=\"line\">        &#125; </span><br><span class=\"line\">        ...</span><br><span class=\"line\">    <span class=\"keyword\">return</span> defaultValue;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>getRawDataForKey</code>方法，主要有两个分支，一种是加密逻辑，另一种是非加密逻辑，但他们流程都差不多从一个  map 里面根据 key 获取一个对象（这个对象暂时并不是 get 最终的返回值），那这个 map 是从哪里来的呢？</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">MMBuffer <span class=\"title\">MMKV::getRawDataForKey</span><span class=\"params\">(MMKVKey_t key)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">checkLoadData</span>();</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">ifndef</span> MMKV_DISABLE_CRYPT</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (m_crypter) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">auto</span> itr = m_dicCrypt-&gt;<span class=\"built_in\">find</span>(key);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (itr != m_dicCrypt-&gt;<span class=\"built_in\">end</span>()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">auto</span> basePtr = (<span class=\"type\">uint8_t</span> *) (m_file-&gt;<span class=\"built_in\">getMemory</span>()) + Fixed32Size;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> itr-&gt;second.<span class=\"built_in\">toMMBuffer</span>(basePtr, m_crypter);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span></span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">auto</span> itr = m_dic-&gt;<span class=\"built_in\">find</span>(key);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (itr != m_dic-&gt;<span class=\"built_in\">end</span>()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">auto</span> basePtr = (<span class=\"type\">uint8_t</span> *) (m_file-&gt;<span class=\"built_in\">getMemory</span>()) + Fixed32Size;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> itr-&gt;second.<span class=\"built_in\">toMMBuffer</span>(basePtr);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    MMBuffer nan;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> nan;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>从源码里面溯源<code>m_dicCrypt</code>和 <code>m_dic</code> 是在 MMKV 初始化的时候生成的，主要逻辑在 <code>MMKV_IO .cpp</code>里面的 <code>loadFromFile</code>方法内：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">MMKV::loadFromFile</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">loadMetaInfoAndCheck</span>();</span><br><span class=\"line\">\t\t...</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!m_file-&gt;<span class=\"built_in\">isFileValid</span>()) &#123;</span><br><span class=\"line\">        m_file-&gt;<span class=\"built_in\">reloadFromFile</span>(m_expectedCapacity);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!m_file-&gt;<span class=\"built_in\">isFileValid</span>()) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">MMKVError</span>(<span class=\"string\">&quot;file [%s] not valid&quot;</span>, m_path.<span class=\"built_in\">c_str</span>());</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">bool</span> loadFromFile = <span class=\"literal\">false</span>, needFullWriteback = <span class=\"literal\">false</span>;</span><br><span class=\"line\">        <span class=\"built_in\">checkDataValid</span>(loadFromFile, needFullWriteback);</span><br><span class=\"line\">        ...</span><br><span class=\"line\">        <span class=\"keyword\">auto</span> ptr = (<span class=\"type\">uint8_t</span> *) m_file-&gt;<span class=\"built_in\">getMemory</span>();</span><br><span class=\"line\">        <span class=\"comment\">// loading</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (loadFromFile &amp;&amp; m_actualSize &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\t\t\t...</span><br><span class=\"line\">            <span class=\"function\">MMBuffer <span class=\"title\">inputBuffer</span><span class=\"params\">(ptr + Fixed32Size, m_actualSize, MMBufferNoCopy)</span></span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (m_crypter) &#123;</span><br><span class=\"line\">                <span class=\"built_in\">clearDictionary</span>(m_dicCrypt);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"built_in\">clearDictionary</span>(m_dic);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (needFullWriteback) &#123;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">ifndef</span> MMKV_DISABLE_CRYPT</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (m_crypter) &#123;</span><br><span class=\"line\">                    MiniPBCoder::<span class=\"built_in\">greedyDecodeMap</span>(*m_dicCrypt, inputBuffer, m_crypter);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span></span></span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    MiniPBCoder::<span class=\"built_in\">greedyDecodeMap</span>(*m_dic, inputBuffer);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">ifndef</span> MMKV_DISABLE_CRYPT</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (m_crypter) &#123;</span><br><span class=\"line\">                    MiniPBCoder::<span class=\"built_in\">decodeMap</span>(*m_dicCrypt, inputBuffer, m_crypter);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span></span></span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    MiniPBCoder::<span class=\"built_in\">decodeMap</span>(*m_dic, inputBuffer);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            m_output = <span class=\"keyword\">new</span> <span class=\"built_in\">CodedOutputData</span>(ptr + Fixed32Size, m_file-&gt;<span class=\"built_in\">getFileSize</span>() - Fixed32Size);</span><br><span class=\"line\">            m_output-&gt;<span class=\"built_in\">seek</span>(m_actualSize);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (needFullWriteback) &#123;</span><br><span class=\"line\">                <span class=\"built_in\">fullWriteback</span>();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// file not valid or empty, discard everything</span></span><br><span class=\"line\">            <span class=\"built_in\">SCOPED_LOCK</span>(m_exclusiveProcessLock);</span><br><span class=\"line\"></span><br><span class=\"line\">            m_output = <span class=\"keyword\">new</span> <span class=\"built_in\">CodedOutputData</span>(ptr + Fixed32Size, m_file-&gt;<span class=\"built_in\">getFileSize</span>() - Fixed32Size);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (m_actualSize &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                <span class=\"built_in\">writeActualSize</span>(<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"literal\">nullptr</span>, IncreaseSequence);</span><br><span class=\"line\">                <span class=\"built_in\">sync</span>(MMKV_SYNC);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"built_in\">writeActualSize</span>(<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"literal\">nullptr</span>, KeepSequence);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">\t\t\t\t...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    m_needLoadFromFile = <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>总统来说就是在初始化的时候就会将基于<code>protobuf</code>协议的本地文件里面的数据加载到内存，并将其放在一个 map 内，方便后续使用。</p>\n<p>回到 <code>int32_t MMKV::getInt32()</code>通过 <code>getDataForKey(key)</code>获取到一个<code>MMBuffer</code>对象，并通过 <strong>CodedInputData</strong>进行反序列化操作，读取 <strong>Varint32</strong> 的 <strong>valueSize</strong> 值，随后不断循环通过 <strong>CodedInputData</strong>  读取到<strong>value</strong> 值。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int32_t</span> <span class=\"title\">MMKV::getInt32</span><span class=\"params\">(MMKVKey_t key, <span class=\"type\">int32_t</span> defaultValue, <span class=\"type\">bool</span> *hasValue)</span> </span>&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"keyword\">auto</span> data = <span class=\"built_in\">getDataForKey</span>(key);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (data.<span class=\"built_in\">length</span>() &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"function\">CodedInputData <span class=\"title\">input</span><span class=\"params\">(data.getPtr(), data.length())</span></span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (hasValue != <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">                *hasValue = <span class=\"literal\">true</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> input.<span class=\"built_in\">readInt32</span>();</span><br><span class=\"line\">        &#125; </span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  \t...</span><br><span class=\"line\">    <span class=\"keyword\">return</span> defaultValue;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"mmkv-与-SharedPreferences\"><a href=\"#mmkv-与-SharedPreferences\" class=\"headerlink\" title=\"mmkv 与 SharedPreferences\"></a>mmkv 与 SharedPreferences</h2><p>以下是 <strong>MMKV</strong> 与 <strong>SharedPreferences</strong> 的优劣势对比总结，结合性能、安全性、功能支持等核心维度进行分析：</p>\n<h3 id=\"性能对比\"><a href=\"#性能对比\" class=\"headerlink\" title=\"性能对比\"></a><strong>性能对比</strong></h3><table>\n<thead>\n<tr>\n<th align=\"left\"><strong>维度</strong></th>\n<th align=\"left\"><strong>SharedPreferences</strong></th>\n<th align=\"left\"><strong>MMKV</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><strong>读写速度</strong></td>\n<td align=\"left\">慢（同步 I&#x2F;O，多次数据拷贝）</td>\n<td align=\"left\">快（<code>mmap</code> 零拷贝，内存直接操作）</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>线程安全</strong></td>\n<td align=\"left\">需自行加锁（<code>apply()</code> 异步写入仍有风险）</td>\n<td align=\"left\">内置多线程锁（文件锁 + 内存锁）</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>大数据量支持</strong></td>\n<td align=\"left\">性能急剧下降（全量 XML 解析&#x2F;序列化）</td>\n<td align=\"left\">高效（增量更新，Protobuf 编码）</td>\n</tr>\n</tbody></table>\n<h3 id=\"安全性与稳定性\"><a href=\"#安全性与稳定性\" class=\"headerlink\" title=\"安全性与稳定性\"></a><strong>安全性与稳定性</strong></h3><table>\n<thead>\n<tr>\n<th align=\"left\"><strong>维度</strong></th>\n<th align=\"left\"><strong>SharedPreferences</strong></th>\n<th align=\"left\"><strong>MMKV</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><strong>数据加密</strong></td>\n<td align=\"left\">无（明文存储）</td>\n<td align=\"left\">支持 AES-128&#x2F;AES-256 加密</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>崩溃恢复</strong></td>\n<td align=\"left\">可能因异常导致 XML 损坏</td>\n<td align=\"left\">通过 CRC 校验 + 备份文件保障完整性</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>系统版本适配</strong></td>\n<td align=\"left\">部分版本有 ANR 问题（如 <code>apply()</code>）</td>\n<td align=\"left\">无系统级兼容性问题</td>\n</tr>\n</tbody></table>\n<h3 id=\"功能支持\"><a href=\"#功能支持\" class=\"headerlink\" title=\"功能支持\"></a><strong>功能支持</strong></h3><table>\n<thead>\n<tr>\n<th align=\"left\"><strong>维度</strong></th>\n<th align=\"left\"><strong>SharedPreferences</strong></th>\n<th align=\"left\"><strong>MMKV</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><strong>多进程</strong></td>\n<td align=\"left\">不支持（跨进程数据不同步）</td>\n<td align=\"left\">支持（通过文件锁 + <code>mmap</code> 共享内存）</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>数据类型</strong></td>\n<td align=\"left\">仅支持基本类型（int&#x2F;String 等）</td>\n<td align=\"left\">支持基本类型、二进制数据（MMBuffer）</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>加密存储</strong></td>\n<td align=\"left\">明文存储（XML）</td>\n<td align=\"left\">支持 AES 加密（可选）</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>增量更新</strong></td>\n<td align=\"left\">全量写入（即使只改一个键值）</td>\n<td align=\"left\">仅追加新数据，定期整理</td>\n</tr>\n</tbody></table>\n<p>从上面的对比看看，mmkv 在很多层面都是领先 SharedPreferences 的，那么 mmkv 是否有缺陷呢？答案是有的。</p>\n<blockquote>\n<p>任何的操作系统、任何的软件，在往磁盘写数据的过程中如果发生了意外——例如程序崩溃，或者断电关机——磁盘里的文件就会以这种写了一半的、不完整的形式被保留。写了一半的数据怎么用啊？没法用，这就是文件的损坏。这种问题是不可能避免的，MMKV 虽然由于底层机制的原因，在程序崩溃的时候不会影响数据往磁盘的写入，但断电关机之类的操作系统级别的崩溃，MMKV 就没办法了，文件照样会损坏。对于这种文件损坏，SharedPreferences 和 DataStore 的应对方式是在每次写入新数据之前都对现有文件做一次自动备份，这样在发生了意外出现了文件损坏之后，它们就会把备份的数据恢复过来；而 MMKV，没有这种自动的备份和恢复，那么当文件发生了损坏，数据就丢了，之前保存的各种信息只能被重置。也就是说，MMKV 是唯一会丢数据的方案。</p>\n</blockquote>\n<p>在 mmkv 里面有 <a href=\"https://info.support.huawei.com/info-finder/encyclopedia/zh/CRC.html\">CRC</a> 校验，如果不通过的话，将会废弃掉之前所有的数据。在 mmkv 里面也有人反馈：<a href=\"https://github.com/Tencent/MMKV/issues/729\">https://github.com/Tencent/MMKV/issues/729</a> 在写入的过程中因为一些特殊情况写入失败，会导致本地的文件损坏且不可recovery。</p>\n<p>那有什么办法避免这个问题呢？有大佬开源另一个 KV 框架 <a href=\"https://github.com/BillyWei01/FastKV\">FastKV</a>对这个问题进行了处理，采用通过double-write等方法确保数据的完整性，原理是数据依次写入A&#x2F;B两个文件，如果写入A过程中崩溃，B仍是完整的，如果A完整写入了，则B写入时崩溃也不要紧。这种实现方式理论上是不错的，不太清楚 mmkv 为什么没有采取这样的逻辑。不过这个库并没有经过大量业务进行验证，只能作为一个学习的方案先看看。</p>\n<p>另外谷歌已经开发了新的KV存储框架<a href=\"https://cloud.google.com/datastore/docs/concepts/overview?hl=zh-cn\">DataStore</a>，<code>SharedPreferences</code>也将渐渐地退出历史的舞台了。不过 DataStore 的性能目前仍然没有 mmkv 的好。关于这三者的比较可以查看： <a href=\"https://juejin.cn/post/7112268981163016229\">《Android 的键值对存储有没有最优解？》</a></p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>这篇文章深入剖析了 <strong>MMKV</strong>（腾讯开源的高性能键值存储组件）的核心设计与实现原理，重点对比了传统 I&#x2F;O 与 <code>mmap</code> 内存映射的差异，并详细分析了 MMKV 的读写流程以及和 SharedPreferences 的各方面对比。</p>\n<p><strong>参考</strong></p>\n<p><a href=\"https://juejin.cn/post/7112268981163016229\">《Android 的键值对存储有没有最优解？》</a></p>\n<p><a href=\"https://yangjie2.github.io/2021/11/14/mmap%E5%8E%9F%E7%90%86%E4%B8%8E%E5%BA%94%E7%94%A8/\">《mmap原理与应用》</a></p>\n<p><a href=\"https://blog.csdn.net/zhanglh046/article/details/115603788\">《文件内存映射和传统I&#x2F;O机制》</a></p>\n<p><a href=\"https://blog.csdn.net/luo_boke/article/details/109311432\">Android 内存映射mmap浅谈</a></p>\n","categories":[],"tags":[{"name":"mmap","slug":"mmap","api":"api/tags/mmap.json"}],"api":"api/posts/2025/03/30/KV-存储之mmkv.json"},{"title":"RetroFit2 源码学习相关","slug":"Learn-from-RetroFit","date":"2025-03-17T12:28:00.000Z","updated":"2025-05-20T11:46:57.000Z","comments":true,"url":"2025/03/17/Learn-from-RetroFit/","excerpt":"<p>研究 <a href=\"https://github.com/square/retrofit\">retrofit</a> 目标：理解动态代理、注解、反射、学习它所用到的设计模式，达到自己能手写它的核心实现。</p>\n<p>最近终于有点精力能够去研究研究源码了， 真的是写的一个非常好的的开源库，以前刚接触安卓的时候扒拉过相关的源码，但是随着工作了几年之后，经验的积累，让我对源码里面的东西能够体会更深刻，自己也尝试去手写里面的核心实现，看完源码对整体的架构理解了之后，以为自己能很顺利的写下来，实则不然。<br>知识还是需要知行合一，这篇文章主要记录 <a href=\"https://github.com/square/retrofit\">retrofit</a>  的一些知识点。</p>\n<h3 id=\"retrofit-的设计模式\"><a href=\"#retrofit-的设计模式\" class=\"headerlink\" title=\"retrofit 的设计模式\"></a>retrofit 的设计模式</h3><p>retrofit 里面中使用了多种设计模式，以实现其灵活、可扩展和高性能的特性：</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">设计模式</th>\n<th align=\"left\">应用场景</th>\n<th align=\"left\">作用</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><strong>建造者模式</strong></td>\n<td align=\"left\"><code>Retrofit.Builder</code></td>\n<td align=\"left\">灵活配置 Retrofit 实例</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>工厂模式</strong></td>\n<td align=\"left\"><code>Converter.Factory</code>、<code>CallAdapter.Factory</code></td>\n<td align=\"left\">创建 Converter 和 CallAdapter 实例</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>动态代理模式</strong></td>\n<td align=\"left\">接口方法转换为 HTTP 请求</td>\n<td align=\"left\">运行时生成接口代理对象</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>适配器模式</strong></td>\n<td align=\"left\"><code>CallAdapter</code></td>\n<td align=\"left\">将 <code>Call</code> 适配为其他类型</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>装饰器模式</strong></td>\n<td align=\"left\"><code>OkHttp</code> 拦截器</td>\n<td align=\"left\">增强 HTTP 请求和响应的功能</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>观察者模式</strong></td>\n<td align=\"left\">与 <code>RxJava</code> 或 <code>LiveData</code> 结合</td>\n<td align=\"left\">实现异步数据流的订阅和通知</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>策略模式</strong></td>\n<td align=\"left\"><code>Converter</code> 和 <code>CallAdapter</code> 选择</td>\n<td align=\"left\">动态选择数据转换或调用适配策略</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>单例模式</strong></td>\n<td align=\"left\"><code>Retrofit</code> 实例共享</td>\n<td align=\"left\">确保全局只有一个 Retrofit 实例</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>模板方法模式</strong></td>\n<td align=\"left\"><code>Call</code> 的实现</td>\n<td align=\"left\">定义 HTTP 请求的执行流程</td>\n</tr>\n</tbody></table>\n<p><strong>retrofit 的动态代理模式</strong></p>\n<p>retrofit 用了诸多的设计模式，其中最经典的莫过于动态代理模式了，在了解 retrofit 之前，我一直以为这样的网络请求形式是最直观的，参考以前写的<a href=\"https://julis.wang/2019/05/13/%E5%9F%BA%E4%BA%8EVolley%E6%A1%86%E6%9E%B6%E7%9A%84%E8%BF%94%E5%9B%9E%E6%95%B0%E6%8D%AE%E7%9A%84%E8%8C%83%E5%9E%8B%E5%A4%84%E7%90%86/\">基于Volley框架的返回数据的范型处理</a></p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"code\"><pre><span class=\"line\">Request.<span class=\"keyword\">get</span>(</span><br><span class=\"line\">    url = url,</span><br><span class=\"line\">    params = param,</span><br><span class=\"line\">    listener = <span class=\"keyword\">object</span> : OnRequestListener&lt;Data&gt; &#123;</span><br><span class=\"line\">        <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onSuccess</span><span class=\"params\">(commonData: <span class=\"type\">CommonData</span>?, <span class=\"keyword\">data</span>: <span class=\"type\">Data</span>?)</span></span> &#123;&#125;</span><br><span class=\"line\">        <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onFailure</span><span class=\"params\">(errorCode: <span class=\"type\">Int</span>, errorMessage: <span class=\"type\">String</span>?)</span></span> &#123;&#125;</span><br><span class=\"line\">    &#125;)</span><br></pre></td></tr></table></figure>\n\n<p>以为这样很直观，逻辑也很清晰，实则 代码冗余，回调嵌套，如果有多个连续的请求，代码会变得难以维护，而 retrofit 搭配上协程能这样实现：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> <span class=\"keyword\">data</span> = apiService.getXXX(params)</span><br></pre></td></tr></table></figure>\n\n<p>简单到不能再简单，<code>动态代理</code>功不可没，上面的 apiService 是一个接口，由：<code> retrofit.create(ApiInterface::class.java)</code> 生成其实例，动态代理其核心实现：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> &lt;T&gt; T <span class=\"title function_\">create</span><span class=\"params\">(<span class=\"keyword\">final</span> Class&lt;T&gt; service)</span> &#123;</span><br><span class=\"line\">    validateServiceInterface(service);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (T)</span><br><span class=\"line\">        Proxy.newProxyInstance(</span><br><span class=\"line\">            service.getClassLoader(),</span><br><span class=\"line\">            <span class=\"keyword\">new</span> <span class=\"title class_\">Class</span>&lt;?&gt;[] &#123;service&#125;,</span><br><span class=\"line\">            <span class=\"keyword\">new</span> <span class=\"title class_\">InvocationHandler</span>() &#123;</span><br><span class=\"line\">              <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"type\">Platform</span> <span class=\"variable\">platform</span> <span class=\"operator\">=</span> Platform.get();</span><br><span class=\"line\">              <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Object[] emptyArgs = <span class=\"keyword\">new</span> <span class=\"title class_\">Object</span>[<span class=\"number\">0</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">              <span class=\"meta\">@Override</span></span><br><span class=\"line\">              <span class=\"keyword\">public</span> <span class=\"meta\">@Nullable</span> Object <span class=\"title function_\">invoke</span><span class=\"params\">(Object proxy, Method method, <span class=\"meta\">@Nullable</span> Object[] args)</span> <span class=\"keyword\">throws</span> Throwable &#123;</span><br><span class=\"line\">                <span class=\"comment\">// ....</span></span><br><span class=\"line\">                <span class=\"keyword\">return</span> platform.isDefaultMethod(method)</span><br><span class=\"line\">                    ? platform.invokeDefaultMethod(method, service, proxy, args)</span><br><span class=\"line\">                    : loadServiceMethod(method).invoke(args);</span><br><span class=\"line\">              &#125;</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n\n<p>由<code>loadServiceMethod(method).invoke(args)</code> 负责将接口方法（通过 Java 反射获取的 <code>Method</code> 对象）解析并转换为一个可执行的 HTTP 请求。</p>\n<p><code>Proxy.newProxyInstance</code> 方法，参数：</p>\n<ul>\n<li><p>ClassLoader loader 用于加载代理类的类加载器。</p>\n</li>\n<li><p>Class&lt;?&gt;[] interfaces 代理类需要实现的接口数组，代理对象将实现这些接口，并拦截对这些接口方法的调用。只能代理实现了接口的类，不能代理没有接口的类。</p>\n</li>\n<li><p>InvocationHandler h<br>调用处理器，负责处理代理对象上的方法调用。每次调用代理对象的方法时，都会调用 <code>InvocationHandler</code> 的 <code>invoke</code> 方法。对于 Retrofit 的接口我们并没有去“实现”它的方法，所有的逻辑都由&#96;&#96; retrofit.create()<code>方法里面返回的 </code>InvocationHandler<code>实现的 </code>invoke&#96;方法实现的。</p>\n</li>\n</ul>\n<h3 id=\"核心实现逻辑\"><a href=\"#核心实现逻辑\" class=\"headerlink\" title=\"核心实现逻辑\"></a>核心实现逻辑</h3><h4 id=\"协程的支持\"><a href=\"#协程的支持\" class=\"headerlink\" title=\"协程的支持\"></a><strong>协程的支持</strong></h4><p>Retrofit 支持多种异步编程模型，包括回调、RxJava 和协程等，这里主要记录一下对协程的支持。普通方法和异步逻辑的分叉在：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (!isKotlinSuspendFunction) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> new CallAdapted&lt;&gt;(requestFactory, callFactory, responseConverter, callAdapter);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (continuationWantsResponse) &#123;</span><br><span class=\"line\">      <span class=\"comment\">//noinspection unchecked Kotlin compiler guarantees ReturnT to be Object.</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> (HttpServiceMethod&lt;ResponseT, ReturnT&gt;)</span><br><span class=\"line\">          new SuspendForResponse&lt;&gt;(</span><br><span class=\"line\">              requestFactory,</span><br><span class=\"line\">              callFactory,</span><br><span class=\"line\">              responseConverter,</span><br><span class=\"line\">              (CallAdapter&lt;ResponseT, Call&lt;ResponseT&gt;&gt;) callAdapter);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">//noinspection unchecked Kotlin compiler guarantees ReturnT to be Object.</span></span><br><span class=\"line\">\t\t\t<span class=\"comment\">//...</span></span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面代码关键变量<code>isKotlinSuspendFunction</code> ，用于判断是否为协程方法（suspend修饰），判断逻辑很简单，只需要判定方法最后一个参数是否为<code> Continuation.class</code> 即可。这里的分叉逻辑都继承自<code>HttpServiceMethod&lt;T&gt;</code>实现 <code>ReturnT adapt(Call&lt;ResponseT&gt; call, Object[] args)</code>这个抽象方法，这也是 retrofit 使用 <strong>适配器模式</strong>的地方，把不同的调用方式进行统一。对于协程方式的调用有实现：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">protected</span> Object adapt(Call&lt;ResponseT&gt; call, Object[] args) &#123;</span><br><span class=\"line\">      call = callAdapter.adapt(call);</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">//noinspection unchecked Checked by reflection inside RequestFactory.</span></span><br><span class=\"line\">      Continuation&lt;Response&lt;ResponseT&gt;&gt; continuation =</span><br><span class=\"line\">          (Continuation&lt;Response&lt;ResponseT&gt;&gt;) args[args.length - <span class=\"number\">1</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">// See SuspendForBody for explanation about this try/catch.</span></span><br><span class=\"line\">      <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> KotlinExtensions.awaitResponse(call, continuation);</span><br><span class=\"line\">      &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>.suspendAndThrow(e, continuation);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight kotlin\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">suspend</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"type\">&lt;T&gt;</span> Call<span class=\"type\">&lt;T&gt;</span>.<span class=\"title\">awaitResponse</span><span class=\"params\">()</span></span>: Response&lt;T&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> suspendCancellableCoroutine &#123; continuation -&gt;</span><br><span class=\"line\">    continuation.invokeOnCancellation &#123;</span><br><span class=\"line\">      cancel()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    enqueue(<span class=\"keyword\">object</span> : Callback&lt;T&gt; &#123;</span><br><span class=\"line\">      <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onResponse</span><span class=\"params\">(call: <span class=\"type\">Call</span>&lt;<span class=\"type\">T</span>&gt;, response: <span class=\"type\">Response</span>&lt;<span class=\"type\">T</span>&gt;)</span></span> &#123;</span><br><span class=\"line\">        continuation.resume(response)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onFailure</span><span class=\"params\">(call: <span class=\"type\">Call</span>&lt;<span class=\"type\">T</span>&gt;, t: <span class=\"type\">Throwable</span>)</span></span> &#123;</span><br><span class=\"line\">        continuation.resumeWithException(t)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里就一切都明朗了，实现了 <code>Call</code>的扩展方法，这里的 <code>Call</code>并不是 <code>okhttp3.Call</code>，它只是 retrofit  <code>okhttp3.Call</code>为方便框架整体逻辑的处理而定义的，比如 retrofit 的 <code>Call</code> 是泛型化的，可以直接返回解析后的对象，<code>enqueue</code>同理。</p>\n<p><code>suspendCancellableCoroutine</code>方法是实现协程方法的关键，它可以将基于回调的异步操作封装成一个挂起函数，怎么理解呢？对 扩展方法<code>awaitResponse</code>反编译可以看到方法定义是这样的：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Object <span class=\"title function_\">await</span><span class=\"params\">(<span class=\"meta\">@NotNull</span> Call $<span class=\"built_in\">this</span>$await, <span class=\"meta\">@NotNull</span> Continuation $completion)</span> </span><br></pre></td></tr></table></figure>\n\n<p>其实这里跟定义一个 <code>listener</code>去监听方法的回调有点像，这个方法改写成 <code>listener</code>的实现话大概就是这样：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"type\">&lt;T&gt;</span> Call<span class=\"type\">&lt;T&gt;</span>.<span class=\"title\">awaitResponse</span><span class=\"params\">(listener:<span class=\"type\">Listener</span>&lt;<span class=\"type\">T</span>&gt;)</span></span>: Response&lt;T&gt; &#123;</span><br><span class=\"line\">        enqueue(<span class=\"keyword\">object</span> : Callback&lt;T&gt; &#123;</span><br><span class=\"line\">            <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onResponse</span><span class=\"params\">(call: <span class=\"type\">Call</span>&lt;<span class=\"type\">T</span>&gt;, response: <span class=\"type\">Response</span>&lt;<span class=\"type\">T</span>&gt;)</span></span> &#123;</span><br><span class=\"line\">                Listener.resume(response)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onFailure</span><span class=\"params\">(call: <span class=\"type\">Call</span>&lt;<span class=\"type\">T</span>&gt;, t: <span class=\"type\">Throwable</span>)</span></span> &#123;</span><br><span class=\"line\">                Listener.resumeWithException(t)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可看到改造实现需要传递一个 <code>listener</code>，哪这个 <code>listener</code>是什么？前面其有如何判断一个方法是否为协程的方法的逻辑：判定方法最后一个参数是否为<code> Continuation.class</code> 即可。这里的  <code>listener</code> 其实可以等价于 一个 <code>Continuation</code>实例，kotlin 的协程库帮我们实现了对应的封装，对于使用我们不会直观地感受<code>Continuation</code>的存在，实际它贯穿整个协程。关于协程这里不再赘述，可以查看 <a href=\"https://juejin.cn/post/7142743424670629895?searchId=202503230943390124BC33C1668EC4B62B\">《带着问题分析Kotlin协程原理》</a>了解。</p>\n<h3 id=\"返回数据格式的解析\"><a href=\"#返回数据格式的解析\" class=\"headerlink\" title=\"返回数据格式的解析\"></a><strong>返回数据格式的解析</strong></h3><p>对于<strong>Converter</strong>,在协程和普通方法调用分叉逻辑的前面点：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"code\"><pre><span class=\"line\">Converter&lt;ResponseBody, ResponseT&gt; responseConverter = createResponseConverter(retrofit, method, responseType);</span><br></pre></td></tr></table></figure>\n\n<p><code>createResponseConverter</code>之后一路走到</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> &lt;T&gt; Converter&lt;ResponseBody, T&gt; nextResponseBodyConverter(</span><br><span class=\"line\">    <span class=\"meta\">@Nullable</span> Converter.Factory skipPast, Type type, Annotation[] annotations) &#123;</span><br><span class=\"line\">  Objects.requireNonNull(type, <span class=\"string\">&quot;type == null&quot;</span>);</span><br><span class=\"line\">  Objects.requireNonNull(annotations, <span class=\"string\">&quot;annotations == null&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  int start = converterFactories.indexOf(skipPast) + <span class=\"number\">1</span>;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (int i = start, count = converterFactories.size(); i &lt; count; i++) &#123;</span><br><span class=\"line\">    Converter&lt;ResponseBody, ?&gt; converter =</span><br><span class=\"line\">        converterFactories.<span class=\"keyword\">get</span>(i).responseBodyConverter(type, annotations, <span class=\"keyword\">this</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (converter != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">      <span class=\"comment\">//noinspection unchecked</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> (Converter&lt;ResponseBody, T&gt;) converter;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>converterFactories</code> 的值就是在 retrofit 初始化的时候进行使用  <code>public Builder addConverterFactory(Converter.Factory factory)</code>添加的值。可以看到是按添加到<code>List&lt;Converter.Factory&gt; converterFactories</code>里面的顺序进行选择的，默认<code>GsonConverterFactory</code>实现了利用 <code>Gson</code>进行数据转化 ，如果我们自己实现<code>Converter.Factory</code>的接口的话，那么可以根据一定的规则判断是否要返回我们自定义的 <code>Converter</code>，如果不需要使用就返回 null，会自动匹配下一个能使用的 <code>Converter</code>。注意这里并不会因为前一个  <code>Converter</code> 解析失败而自动尝试使用下一个<code>Converter</code>（当然，你可以在自定义的<code>Converter</code>里面做类似这样的尝试策略）。</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><ul>\n<li><p>这篇文章深入剖析了 <strong>Retrofit</strong> 框架的核心设计模式、动态代理机制、协程支持以及数据解析逻辑，通过源码分析和手写实现，帮助读者更好地理解 Retrofit 的工作原理，并强调了理论与实践结合的重要性。</p>\n</li>\n<li><p>为加深对 retrofit 的理解，可以尝试手写核心实现，自己尝试的的代码在 <a href=\"https://github.com/VomPom/JProject/tree/master/app/src/main/java/wang/julis/jproject/example/source/retrofit2/learn/vmfit\">vmfit</a> </p>\n</li>\n<li><p>附一张 retrofit 的全流程图，来源：<a href=\"https://cloud.tencent.com/developer/article/1683334\">https://cloud.tencent.com/developer/article/1683334</a></p>\n</li>\n</ul>\n<img src=\"https://cdn.julis.wang/blog/img/ru5ssbhumq.jpeg\">","cover":null,"images":["https://cdn.julis.wang/blog/img/ru5ssbhumq.jpeg"],"content":"<p>研究 <a href=\"https://github.com/square/retrofit\">retrofit</a> 目标：理解动态代理、注解、反射、学习它所用到的设计模式，达到自己能手写它的核心实现。</p>\n<p>最近终于有点精力能够去研究研究源码了， 真的是写的一个非常好的的开源库，以前刚接触安卓的时候扒拉过相关的源码，但是随着工作了几年之后，经验的积累，让我对源码里面的东西能够体会更深刻，自己也尝试去手写里面的核心实现，看完源码对整体的架构理解了之后，以为自己能很顺利的写下来，实则不然。<br>知识还是需要知行合一，这篇文章主要记录 <a href=\"https://github.com/square/retrofit\">retrofit</a>  的一些知识点。</p>\n<h3 id=\"retrofit-的设计模式\"><a href=\"#retrofit-的设计模式\" class=\"headerlink\" title=\"retrofit 的设计模式\"></a>retrofit 的设计模式</h3><p>retrofit 里面中使用了多种设计模式，以实现其灵活、可扩展和高性能的特性：</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">设计模式</th>\n<th align=\"left\">应用场景</th>\n<th align=\"left\">作用</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><strong>建造者模式</strong></td>\n<td align=\"left\"><code>Retrofit.Builder</code></td>\n<td align=\"left\">灵活配置 Retrofit 实例</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>工厂模式</strong></td>\n<td align=\"left\"><code>Converter.Factory</code>、<code>CallAdapter.Factory</code></td>\n<td align=\"left\">创建 Converter 和 CallAdapter 实例</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>动态代理模式</strong></td>\n<td align=\"left\">接口方法转换为 HTTP 请求</td>\n<td align=\"left\">运行时生成接口代理对象</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>适配器模式</strong></td>\n<td align=\"left\"><code>CallAdapter</code></td>\n<td align=\"left\">将 <code>Call</code> 适配为其他类型</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>装饰器模式</strong></td>\n<td align=\"left\"><code>OkHttp</code> 拦截器</td>\n<td align=\"left\">增强 HTTP 请求和响应的功能</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>观察者模式</strong></td>\n<td align=\"left\">与 <code>RxJava</code> 或 <code>LiveData</code> 结合</td>\n<td align=\"left\">实现异步数据流的订阅和通知</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>策略模式</strong></td>\n<td align=\"left\"><code>Converter</code> 和 <code>CallAdapter</code> 选择</td>\n<td align=\"left\">动态选择数据转换或调用适配策略</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>单例模式</strong></td>\n<td align=\"left\"><code>Retrofit</code> 实例共享</td>\n<td align=\"left\">确保全局只有一个 Retrofit 实例</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>模板方法模式</strong></td>\n<td align=\"left\"><code>Call</code> 的实现</td>\n<td align=\"left\">定义 HTTP 请求的执行流程</td>\n</tr>\n</tbody></table>\n<p><strong>retrofit 的动态代理模式</strong></p>\n<p>retrofit 用了诸多的设计模式，其中最经典的莫过于动态代理模式了，在了解 retrofit 之前，我一直以为这样的网络请求形式是最直观的，参考以前写的<a href=\"https://julis.wang/2019/05/13/%E5%9F%BA%E4%BA%8EVolley%E6%A1%86%E6%9E%B6%E7%9A%84%E8%BF%94%E5%9B%9E%E6%95%B0%E6%8D%AE%E7%9A%84%E8%8C%83%E5%9E%8B%E5%A4%84%E7%90%86/\">基于Volley框架的返回数据的范型处理</a></p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"code\"><pre><span class=\"line\">Request.<span class=\"keyword\">get</span>(</span><br><span class=\"line\">    url = url,</span><br><span class=\"line\">    params = param,</span><br><span class=\"line\">    listener = <span class=\"keyword\">object</span> : OnRequestListener&lt;Data&gt; &#123;</span><br><span class=\"line\">        <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onSuccess</span><span class=\"params\">(commonData: <span class=\"type\">CommonData</span>?, <span class=\"keyword\">data</span>: <span class=\"type\">Data</span>?)</span></span> &#123;&#125;</span><br><span class=\"line\">        <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onFailure</span><span class=\"params\">(errorCode: <span class=\"type\">Int</span>, errorMessage: <span class=\"type\">String</span>?)</span></span> &#123;&#125;</span><br><span class=\"line\">    &#125;)</span><br></pre></td></tr></table></figure>\n\n<p>以为这样很直观，逻辑也很清晰，实则 代码冗余，回调嵌套，如果有多个连续的请求，代码会变得难以维护，而 retrofit 搭配上协程能这样实现：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> <span class=\"keyword\">data</span> = apiService.getXXX(params)</span><br></pre></td></tr></table></figure>\n\n<p>简单到不能再简单，<code>动态代理</code>功不可没，上面的 apiService 是一个接口，由：<code> retrofit.create(ApiInterface::class.java)</code> 生成其实例，动态代理其核心实现：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> &lt;T&gt; T <span class=\"title function_\">create</span><span class=\"params\">(<span class=\"keyword\">final</span> Class&lt;T&gt; service)</span> &#123;</span><br><span class=\"line\">    validateServiceInterface(service);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (T)</span><br><span class=\"line\">        Proxy.newProxyInstance(</span><br><span class=\"line\">            service.getClassLoader(),</span><br><span class=\"line\">            <span class=\"keyword\">new</span> <span class=\"title class_\">Class</span>&lt;?&gt;[] &#123;service&#125;,</span><br><span class=\"line\">            <span class=\"keyword\">new</span> <span class=\"title class_\">InvocationHandler</span>() &#123;</span><br><span class=\"line\">              <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"type\">Platform</span> <span class=\"variable\">platform</span> <span class=\"operator\">=</span> Platform.get();</span><br><span class=\"line\">              <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Object[] emptyArgs = <span class=\"keyword\">new</span> <span class=\"title class_\">Object</span>[<span class=\"number\">0</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">              <span class=\"meta\">@Override</span></span><br><span class=\"line\">              <span class=\"keyword\">public</span> <span class=\"meta\">@Nullable</span> Object <span class=\"title function_\">invoke</span><span class=\"params\">(Object proxy, Method method, <span class=\"meta\">@Nullable</span> Object[] args)</span> <span class=\"keyword\">throws</span> Throwable &#123;</span><br><span class=\"line\">                <span class=\"comment\">// ....</span></span><br><span class=\"line\">                <span class=\"keyword\">return</span> platform.isDefaultMethod(method)</span><br><span class=\"line\">                    ? platform.invokeDefaultMethod(method, service, proxy, args)</span><br><span class=\"line\">                    : loadServiceMethod(method).invoke(args);</span><br><span class=\"line\">              &#125;</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n\n<p>由<code>loadServiceMethod(method).invoke(args)</code> 负责将接口方法（通过 Java 反射获取的 <code>Method</code> 对象）解析并转换为一个可执行的 HTTP 请求。</p>\n<p><code>Proxy.newProxyInstance</code> 方法，参数：</p>\n<ul>\n<li><p>ClassLoader loader 用于加载代理类的类加载器。</p>\n</li>\n<li><p>Class&lt;?&gt;[] interfaces 代理类需要实现的接口数组，代理对象将实现这些接口，并拦截对这些接口方法的调用。只能代理实现了接口的类，不能代理没有接口的类。</p>\n</li>\n<li><p>InvocationHandler h<br>调用处理器，负责处理代理对象上的方法调用。每次调用代理对象的方法时，都会调用 <code>InvocationHandler</code> 的 <code>invoke</code> 方法。对于 Retrofit 的接口我们并没有去“实现”它的方法，所有的逻辑都由&#96;&#96; retrofit.create()<code>方法里面返回的 </code>InvocationHandler<code>实现的 </code>invoke&#96;方法实现的。</p>\n</li>\n</ul>\n<h3 id=\"核心实现逻辑\"><a href=\"#核心实现逻辑\" class=\"headerlink\" title=\"核心实现逻辑\"></a>核心实现逻辑</h3><h4 id=\"协程的支持\"><a href=\"#协程的支持\" class=\"headerlink\" title=\"协程的支持\"></a><strong>协程的支持</strong></h4><p>Retrofit 支持多种异步编程模型，包括回调、RxJava 和协程等，这里主要记录一下对协程的支持。普通方法和异步逻辑的分叉在：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (!isKotlinSuspendFunction) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> new CallAdapted&lt;&gt;(requestFactory, callFactory, responseConverter, callAdapter);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (continuationWantsResponse) &#123;</span><br><span class=\"line\">      <span class=\"comment\">//noinspection unchecked Kotlin compiler guarantees ReturnT to be Object.</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> (HttpServiceMethod&lt;ResponseT, ReturnT&gt;)</span><br><span class=\"line\">          new SuspendForResponse&lt;&gt;(</span><br><span class=\"line\">              requestFactory,</span><br><span class=\"line\">              callFactory,</span><br><span class=\"line\">              responseConverter,</span><br><span class=\"line\">              (CallAdapter&lt;ResponseT, Call&lt;ResponseT&gt;&gt;) callAdapter);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">//noinspection unchecked Kotlin compiler guarantees ReturnT to be Object.</span></span><br><span class=\"line\">\t\t\t<span class=\"comment\">//...</span></span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面代码关键变量<code>isKotlinSuspendFunction</code> ，用于判断是否为协程方法（suspend修饰），判断逻辑很简单，只需要判定方法最后一个参数是否为<code> Continuation.class</code> 即可。这里的分叉逻辑都继承自<code>HttpServiceMethod&lt;T&gt;</code>实现 <code>ReturnT adapt(Call&lt;ResponseT&gt; call, Object[] args)</code>这个抽象方法，这也是 retrofit 使用 <strong>适配器模式</strong>的地方，把不同的调用方式进行统一。对于协程方式的调用有实现：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">protected</span> Object adapt(Call&lt;ResponseT&gt; call, Object[] args) &#123;</span><br><span class=\"line\">      call = callAdapter.adapt(call);</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">//noinspection unchecked Checked by reflection inside RequestFactory.</span></span><br><span class=\"line\">      Continuation&lt;Response&lt;ResponseT&gt;&gt; continuation =</span><br><span class=\"line\">          (Continuation&lt;Response&lt;ResponseT&gt;&gt;) args[args.length - <span class=\"number\">1</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">// See SuspendForBody for explanation about this try/catch.</span></span><br><span class=\"line\">      <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> KotlinExtensions.awaitResponse(call, continuation);</span><br><span class=\"line\">      &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>.suspendAndThrow(e, continuation);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight kotlin\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">suspend</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"type\">&lt;T&gt;</span> Call<span class=\"type\">&lt;T&gt;</span>.<span class=\"title\">awaitResponse</span><span class=\"params\">()</span></span>: Response&lt;T&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> suspendCancellableCoroutine &#123; continuation -&gt;</span><br><span class=\"line\">    continuation.invokeOnCancellation &#123;</span><br><span class=\"line\">      cancel()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    enqueue(<span class=\"keyword\">object</span> : Callback&lt;T&gt; &#123;</span><br><span class=\"line\">      <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onResponse</span><span class=\"params\">(call: <span class=\"type\">Call</span>&lt;<span class=\"type\">T</span>&gt;, response: <span class=\"type\">Response</span>&lt;<span class=\"type\">T</span>&gt;)</span></span> &#123;</span><br><span class=\"line\">        continuation.resume(response)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onFailure</span><span class=\"params\">(call: <span class=\"type\">Call</span>&lt;<span class=\"type\">T</span>&gt;, t: <span class=\"type\">Throwable</span>)</span></span> &#123;</span><br><span class=\"line\">        continuation.resumeWithException(t)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里就一切都明朗了，实现了 <code>Call</code>的扩展方法，这里的 <code>Call</code>并不是 <code>okhttp3.Call</code>，它只是 retrofit  <code>okhttp3.Call</code>为方便框架整体逻辑的处理而定义的，比如 retrofit 的 <code>Call</code> 是泛型化的，可以直接返回解析后的对象，<code>enqueue</code>同理。</p>\n<p><code>suspendCancellableCoroutine</code>方法是实现协程方法的关键，它可以将基于回调的异步操作封装成一个挂起函数，怎么理解呢？对 扩展方法<code>awaitResponse</code>反编译可以看到方法定义是这样的：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Object <span class=\"title function_\">await</span><span class=\"params\">(<span class=\"meta\">@NotNull</span> Call $<span class=\"built_in\">this</span>$await, <span class=\"meta\">@NotNull</span> Continuation $completion)</span> </span><br></pre></td></tr></table></figure>\n\n<p>其实这里跟定义一个 <code>listener</code>去监听方法的回调有点像，这个方法改写成 <code>listener</code>的实现话大概就是这样：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"type\">&lt;T&gt;</span> Call<span class=\"type\">&lt;T&gt;</span>.<span class=\"title\">awaitResponse</span><span class=\"params\">(listener:<span class=\"type\">Listener</span>&lt;<span class=\"type\">T</span>&gt;)</span></span>: Response&lt;T&gt; &#123;</span><br><span class=\"line\">        enqueue(<span class=\"keyword\">object</span> : Callback&lt;T&gt; &#123;</span><br><span class=\"line\">            <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onResponse</span><span class=\"params\">(call: <span class=\"type\">Call</span>&lt;<span class=\"type\">T</span>&gt;, response: <span class=\"type\">Response</span>&lt;<span class=\"type\">T</span>&gt;)</span></span> &#123;</span><br><span class=\"line\">                Listener.resume(response)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onFailure</span><span class=\"params\">(call: <span class=\"type\">Call</span>&lt;<span class=\"type\">T</span>&gt;, t: <span class=\"type\">Throwable</span>)</span></span> &#123;</span><br><span class=\"line\">                Listener.resumeWithException(t)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可看到改造实现需要传递一个 <code>listener</code>，哪这个 <code>listener</code>是什么？前面其有如何判断一个方法是否为协程的方法的逻辑：判定方法最后一个参数是否为<code> Continuation.class</code> 即可。这里的  <code>listener</code> 其实可以等价于 一个 <code>Continuation</code>实例，kotlin 的协程库帮我们实现了对应的封装，对于使用我们不会直观地感受<code>Continuation</code>的存在，实际它贯穿整个协程。关于协程这里不再赘述，可以查看 <a href=\"https://juejin.cn/post/7142743424670629895?searchId=202503230943390124BC33C1668EC4B62B\">《带着问题分析Kotlin协程原理》</a>了解。</p>\n<h3 id=\"返回数据格式的解析\"><a href=\"#返回数据格式的解析\" class=\"headerlink\" title=\"返回数据格式的解析\"></a><strong>返回数据格式的解析</strong></h3><p>对于<strong>Converter</strong>,在协程和普通方法调用分叉逻辑的前面点：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"code\"><pre><span class=\"line\">Converter&lt;ResponseBody, ResponseT&gt; responseConverter = createResponseConverter(retrofit, method, responseType);</span><br></pre></td></tr></table></figure>\n\n<p><code>createResponseConverter</code>之后一路走到</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> &lt;T&gt; Converter&lt;ResponseBody, T&gt; nextResponseBodyConverter(</span><br><span class=\"line\">    <span class=\"meta\">@Nullable</span> Converter.Factory skipPast, Type type, Annotation[] annotations) &#123;</span><br><span class=\"line\">  Objects.requireNonNull(type, <span class=\"string\">&quot;type == null&quot;</span>);</span><br><span class=\"line\">  Objects.requireNonNull(annotations, <span class=\"string\">&quot;annotations == null&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  int start = converterFactories.indexOf(skipPast) + <span class=\"number\">1</span>;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (int i = start, count = converterFactories.size(); i &lt; count; i++) &#123;</span><br><span class=\"line\">    Converter&lt;ResponseBody, ?&gt; converter =</span><br><span class=\"line\">        converterFactories.<span class=\"keyword\">get</span>(i).responseBodyConverter(type, annotations, <span class=\"keyword\">this</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (converter != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">      <span class=\"comment\">//noinspection unchecked</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> (Converter&lt;ResponseBody, T&gt;) converter;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>converterFactories</code> 的值就是在 retrofit 初始化的时候进行使用  <code>public Builder addConverterFactory(Converter.Factory factory)</code>添加的值。可以看到是按添加到<code>List&lt;Converter.Factory&gt; converterFactories</code>里面的顺序进行选择的，默认<code>GsonConverterFactory</code>实现了利用 <code>Gson</code>进行数据转化 ，如果我们自己实现<code>Converter.Factory</code>的接口的话，那么可以根据一定的规则判断是否要返回我们自定义的 <code>Converter</code>，如果不需要使用就返回 null，会自动匹配下一个能使用的 <code>Converter</code>。注意这里并不会因为前一个  <code>Converter</code> 解析失败而自动尝试使用下一个<code>Converter</code>（当然，你可以在自定义的<code>Converter</code>里面做类似这样的尝试策略）。</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><ul>\n<li><p>这篇文章深入剖析了 <strong>Retrofit</strong> 框架的核心设计模式、动态代理机制、协程支持以及数据解析逻辑，通过源码分析和手写实现，帮助读者更好地理解 Retrofit 的工作原理，并强调了理论与实践结合的重要性。</p>\n</li>\n<li><p>为加深对 retrofit 的理解，可以尝试手写核心实现，自己尝试的的代码在 <a href=\"https://github.com/VomPom/JProject/tree/master/app/src/main/java/wang/julis/jproject/example/source/retrofit2/learn/vmfit\">vmfit</a> </p>\n</li>\n<li><p>附一张 retrofit 的全流程图，来源：<a href=\"https://cloud.tencent.com/developer/article/1683334\">https://cloud.tencent.com/developer/article/1683334</a></p>\n</li>\n</ul>\n<img src=\"https://cdn.julis.wang/blog/img/ru5ssbhumq.jpeg\">","categories":[{"name":"技术文章","slug":"technology","api":"api/categories/technology.json"}],"tags":[{"name":"Android","slug":"Android","api":"api/tags/Android.json"}],"api":"api/posts/2025/03/17/Learn-from-RetroFit.json"},{"title":"Android屏幕刷新机制","slug":"Android屏幕刷新机制","date":"2025-02-24T02:49:00.000Z","updated":"2025-05-20T11:46:57.000Z","comments":true,"url":"2025/02/24/Android屏幕刷新机制/","excerpt":"<p>最近在研究 Android 屏幕显示与渲染相关的内容，平时经常看到这些类 <code>ViewRootImpl</code>、<code>Choreographer</code>、<code>Surface</code> 、 <code>SurfaceFlinger</code>等，知道它们都用于屏幕渲染相关，但对它们细节了解较少，相关的文章也比较多，不需要自己完全重新再编写一份，于是对相关内容进行一个总结,<br>主要来源：<a href=\"https://juejin.cn/post/6863756420380196877\">《Android屏幕刷新机制—VSyncChoreographer 全面理解》</a>，这篇博客是我认为是目前看到过最好的一篇，文章由浅入深比较好理解。不过文章里面图片链接资源已经失效，为以后复习相关知识点，在此将其整理删除冗余内容，并对图片资源进行更新。</p>\n<h2 id=\"一、背景和疑问\"><a href=\"#一、背景和疑问\" class=\"headerlink\" title=\"一、背景和疑问\"></a><strong>一、背景和疑问</strong></h2><p>在Android中，当我们谈到 <strong>布局优化</strong>、<strong>卡顿优化</strong> 时，通常都知道 需要减少布局层级、减少主线程耗时操作，这样可以减少<strong>丢帧</strong>。如果丢帧比较严重，那么界面可能会有明显的卡顿感。我们知道 通常手机刷新是每秒60次，即每隔16.6ms刷新一次。 问题来了：</p>\n<ol>\n<li><strong>丢帧</strong>(掉帧) ，是说 这一帧延迟显示 还是丢弃不再显示 ？</li>\n<li>布局层级较多&#x2F;主线程耗时 是如何造成 丢帧的呢？</li>\n<li>16.6ms刷新一次 是啥意思？是每16.6ms都走一次 measure&#x2F;layout&#x2F;draw ？</li>\n<li>measure&#x2F;layout&#x2F;draw 走完，界面就立刻刷新了吗?</li>\n<li>如果界面没动静止了，还会刷新吗？</li>\n<li>可能你知道<strong>VSYNC</strong>，这个具体指啥？在屏幕刷新中如何工作的？</li>\n<li>可能你还听过屏幕刷新使用 <strong>双缓存</strong>、<strong>三缓存</strong>，这又是啥意思呢？</li>\n<li>可能你还听过神秘的<strong>Choreographer</strong>，这又是干啥的？</li>\n</ol>\n<h2 id=\"二、显示系统基础知识\"><a href=\"#二、显示系统基础知识\" class=\"headerlink\" title=\"二、显示系统基础知识\"></a><strong>二、显示系统基础知识</strong></h2><p>在一个典型的显示系统中，一般包括CPU、GPU、Display三个部分， CPU负责计算帧数据，把计算好的数据交给GPU，GPU会对图形数据进行渲染，渲染好后放到buffer(图像缓冲区)里存起来，然后Display（屏幕或显示器）负责把buffer里的数据呈现到屏幕上。如下图：</p>\n<img src=\"https://cdn.julis.wang/blog/img/0nq54q5jtq.jpeg\">\n\n<p>单缓存，从缓存映射到屏幕。</p>\n<h3 id=\"2-1-基础概念\"><a href=\"#2-1-基础概念\" class=\"headerlink\" title=\"2.1 基础概念\"></a><strong>2.1 基础概念</strong></h3><ul>\n<li><strong>屏幕刷新频率</strong> 一秒内屏幕刷新的次数（一秒内显示了多少帧的图像），单位 Hz（赫兹），如常见的 60 Hz。<strong>刷新频率取决于硬件的固定参数</strong>（不会变的）。</li>\n<li><strong>逐行扫描</strong> 显示器并不是一次性将画面显示到屏幕上，而是从左到右边，从上到下逐行扫描，顺序显示整屏的一个个像素点，不过这一过程快到人眼无法察觉到变化。以 60 Hz 刷新率的屏幕为例，这一过程即 1000 &#x2F; 60 ≈ 16ms。</li>\n<li><strong>帧率</strong> （Frame Rate） 表示 <strong>GPU 在一秒内绘制操作的帧数</strong>，单位 fps。例如在电影界采用 24 帧的速度足够使画面运行的非常流畅。而 Android 系统则采用更加流程的 60 fps，即每秒钟GPU最多绘制 60 帧画面。帧率是动态变化的，例如当画面静止时，GPU 是没有绘制操作的，屏幕刷新的还是buffer中的数据，即GPU最后操作的帧数据。</li>\n<li><strong>画面撕裂</strong>（tearing） 一个屏幕内的数据来自2个不同的帧，画面会出现撕裂感，如下图</li>\n</ul>\n<img src=\"https://cdn.julis.wang/blog/img/xxm0lvzypa.jpeg\">\n\n<p>明显看出画面错位的位置，这就是画面撕裂。</p>\n<h3 id=\"2-2-双缓存\"><a href=\"#2-2-双缓存\" class=\"headerlink\" title=\"2.2 双缓存\"></a><strong>2.2 双缓存</strong></h3><h5 id=\"2-2-1-画面撕裂-原因\"><a href=\"#2-2-1-画面撕裂-原因\" class=\"headerlink\" title=\"2.2.1  画面撕裂 原因\"></a><strong>2.2.1  画面撕裂 原因</strong></h5><p>屏幕刷新频是固定的，比如每16.6ms从buffer取数据显示完一帧，理想情况下帧率和刷新频率保持一致，即每绘制完成一帧，显示器显示一帧。但是CPU&#x2F;GPU写数据是不可控的，所以会出现buffer里有些数据根本没显示出来就被重写了，即buffer里的数据可能是来自不同的帧的， 当屏幕刷新时，此时它并不知道buffer的状态，因此从buffer抓取的帧并不是完整的一帧画面，即出现画面撕裂。</p>\n<p>简单说就是Display在显示的过程中，buffer内数据被CPU&#x2F;GPU修改，导致画面撕裂。</p>\n<h5 id=\"2-2-2-双缓存\"><a href=\"#2-2-2-双缓存\" class=\"headerlink\" title=\"2.2.2  双缓存\"></a><strong>2.2.2  双缓存</strong></h5><p>那咋解决画面撕裂呢？答案是使用 双缓存。</p>\n<p>由于图像绘制和屏幕读取 使用的是同个buffer，所以屏幕刷新时可能读取到的是不完整的一帧画面。</p>\n<p><strong>双缓存</strong>，让绘制和显示器拥有各自的buffer：GPU 始终将完成的一帧图像数据写入到 <strong>Back Buffer</strong>，而显示器使用 <strong>Frame Buffer</strong>，当屏幕刷新时，Frame Buffer 并不会发生变化，当Back buffer准备就绪后，它们才进行交换。如下图：</p>\n<img src=\"https://cdn.julis.wang/blog/img/q2vukxpyvq.jpeg\">\n\n<p>双缓存，CPU&#x2F;GPU写数据到Back Buffer，显示器从Frame Buffer取数据</p>\n<h5 id=\"2-2-3-VSync\"><a href=\"#2-2-3-VSync\" class=\"headerlink\" title=\"2.2.3  VSync\"></a><strong>2.2.3  VSync</strong></h5><p>问题又来了：什么时候进行两个buffer的交换呢？</p>\n<p>假如是 Back buffer准备完成一帧数据以后就进行，那么如果此时屏幕还没有完整显示上一帧内容的话，肯定是会出问题的。看来只能是等到屏幕处理完一帧数据后，才可以执行这一操作了。</p>\n<p>当扫描完一个屏幕后，设备需要重新回到第一行以进入下一次的循环，此时有一段时间空隙，称为VerticalBlanking Interval(VBI)。那，这个时间点就是我们进行缓冲区交换的最佳时间。因为此时屏幕没有在刷新，也就避免了交换过程中出现 screen tearing的状况。</p>\n<p><strong>VSync</strong>(垂直同步)是VerticalSynchronization的简写，它利用VBI时期出现的vertical sync pulse（垂直同步脉冲）来保证双缓冲在最佳时间点才进行交换。另外，交换是指各自的内存地址，可以认为该操作是瞬间完成。</p>\n<p>所以说V-sync这个概念并不是Google首创的，它在早年的PC机领域就已经出现了。</p>\n<h2 id=\"三、Android屏幕刷新机制\"><a href=\"#三、Android屏幕刷新机制\" class=\"headerlink\" title=\"三、Android屏幕刷新机制\"></a><strong>三、Android屏幕刷新机制</strong></h2><h3 id=\"3-1-Android4-1之前的问题\"><a href=\"#3-1-Android4-1之前的问题\" class=\"headerlink\" title=\"3.1 Android4.1之前的问题\"></a><strong>3.1 Android4.1之前的问题</strong></h3><p>具体到Android中，在Android4.1之前，屏幕刷新也遵循 上面介绍的 双缓存+VSync 机制。如下图：</p>\n<img src=\"https://cdn.julis.wang/blog/img/1ax0mz0nu1.jpeg\">\n\n<p>双缓存会在VSync脉冲时交换，但CPU&#x2F;GPU绘制是随机的</p>\n<p>以时间的顺序来看下将会发生的过程：</p>\n<ol>\n<li>Display显示第0帧数据，此时CPU和<a href=\"https://cloud.tencent.com/solution/render?from_column=20065&from=20065\">GPU渲染</a>第1帧画面，且在Display显示下一帧前完成</li>\n<li>因为渲染及时，Display在第0帧显示完成后，也就是第1个VSync后，缓存进行交换，然后正常显示第1帧</li>\n<li>接着第2帧开始处理，是直到第2个VSync快来前才开始处理的。</li>\n<li>第2个VSync来时，由于第2帧数据还没有准备就绪，缓存没有交换，显示的还是第1帧。这种情况被Android开发组命名为“Jank”，即发生了<strong>丢帧</strong>。</li>\n<li>当第2帧数据准备完成后，它并不会马上被显示，而是要等待下一个VSync 进行缓存交换再显示。</li>\n</ol>\n<p>所以总的来说，就是屏幕平白无故地多显示了一次第1帧。</p>\n<p>原因是 第2帧的CPU&#x2F;GPU计算 没能在VSync信号到来前完成 。</p>\n<p>我们知道，<strong>双缓存的交换 是在Vsyn到来时进行，交换后屏幕会取Frame buffer内的新数据，而实际 此时的Back buffer 就可以供GPU准备下一帧数据了。如果 Vsyn到来时  CPU&#x2F;GPU就开始操作的话，是有完整的16.6ms的，这样应该会基本避免jank的出现了</strong>（除非CPU&#x2F;GPU计算超过了16.6ms）。  那如何让 CPU&#x2F;GPU计算在 Vsyn到来时进行呢？</p>\n<h3 id=\"3-2-drawing-with-VSync\"><a href=\"#3-2-drawing-with-VSync\" class=\"headerlink\" title=\"3.2 drawing with VSync\"></a><strong>3.2 drawing with VSync</strong></h3><p>为了优化显示性能，Google在Android 4.1系统中对Android Display系统进行了重构，实现了Project Butter（黄油工程）：系统在收到VSync pulse后，将马上开始下一帧的渲染。即<strong>一旦收到VSync通知（16ms触发一次），CPU和GPU 才立刻开始计算然后把数据写入buffer</strong>。如下图：</p>\n<img src=\"https://cdn.julis.wang/blog/img/uuqflxwo53.jpeg\">\n\n<p>VSync脉冲到来：双缓存交换，且开始CPU&#x2F;GPU绘制 CPU&#x2F;GPU根据VSYNC信号同步处理数据，可以让CPU&#x2F;GPU有完整的16ms时间来处理数据，减少了jank。</p>\n<p>一句话总结，<strong>VSync同步使得CPU&#x2F;GPU充分利用了16.6ms时间，减少jank。</strong></p>\n<p>问题又来了，如果界面比较复杂，CPU&#x2F;GPU的处理时间较长 超过了16.6ms呢？如下图：</p>\n<img src=\"https://cdn.julis.wang/blog/img/po2jd1h7u8.jpeg\">\n\n<p>虽然CPU&#x2F;GPU开始在VSync，但超过16.6ms</p>\n<ol>\n<li>在第二个时间段内，但却因 GPU 还在处理 B 帧，缓存没能交换，导致 A 帧被重复显示。</li>\n<li>而B完成后，又因为缺乏VSync pulse信号，它只能等待下一个signal的来临。于是在这一过程中，有一大段时间是被浪费的。</li>\n<li>当下一个VSync出现时，CPU&#x2F;GPU马上执行操作（A帧），且缓存交换，相应的显示屏对应的就是B。这时看起来就是正常的。只不过由于执行时间仍然超过16ms，导致下一次应该执行的缓冲区交换又被推迟了——如此循环反复，便出现了越来越多的“Jank”。</li>\n</ol>\n<p><strong>为什么 CPU 不能在第二个 16ms 处理绘制工作呢？</strong></p>\n<p>原因是只有两个 buffer，Back buffer正在被GPU用来处理B帧的数据， Frame buffer的内容用于Display的显示，这样两个buffer都被占用，CPU 则无法准备下一帧的数据。那么，如果再提供一个buffer，CPU、GPU 和显示设备都能使用各自的buffer工作，互不影响。</p>\n<h3 id=\"3-3-三缓存\"><a href=\"#3-3-三缓存\" class=\"headerlink\" title=\"3.3 三缓存\"></a><strong>3.3 三缓存</strong></h3><p><strong>三缓存</strong>就是在双缓冲机制基础上增加了一个 Graphic Buffer 缓冲区，这样可以最大限度的利用空闲时间，带来的坏处是多使用的一个 Graphic Buffer 所占用的内存。</p>\n<img src=\"https://cdn.julis.wang/blog/img/ldq7oda57p.jpeg\">\n\n<p>三缓存</p>\n<ol>\n<li>第一个Jank，是不可避免的。但是在第二个 16ms 时间段，CPU&#x2F;GPU 使用 <strong>第三个 Buffer</strong> 完成C帧的计算，虽然还是会多显示一次 A 帧，但后续显示就比较顺畅了，有效避免 Jank 的进一步加剧。</li>\n<li>注意在第3段中，A帧的计算已完成，但是在第4个vsync来的时候才显示，如果是双缓冲，那在第三个vynsc就可以显示了。</li>\n</ol>\n<p><strong>三缓冲有效利用了等待vysnc的时间，减少了jank，但是带来了延迟。</strong> 所以，是不是 Buffer 越多越好呢？这个是否定的，Buffer 正常还是两个，当出现 Jank 后三个足以。</p>\n<p>以上就是Android屏幕刷新的原理了。</p>\n<h2 id=\"四、Choreographer\"><a href=\"#四、Choreographer\" class=\"headerlink\" title=\"四、Choreographer\"></a><strong>四、Choreographer</strong></h2><h3 id=\"4-1-概述\"><a href=\"#4-1-概述\" class=\"headerlink\" title=\"4.1 概述\"></a><strong>4.1 概述</strong></h3><p>上面讲到，Google在Android 4.1系统中对Android Display系统进行了优化：在收到VSync pulse后，将马上开始下一帧的渲染。即<strong>一旦收到VSync通知，CPU和GPU就立刻开始计算然后把数据写入buffer</strong>。本节就来讲 “drawing with VSync” 的实现——<strong>Choreographer</strong>。</p>\n<ul>\n<li>Choreographer，意为 舞蹈编导、编舞者。在这里就是指 对CPU&#x2F;GPU绘制的指导—— 收到VSync信号 才开始绘制，保证绘制拥有完整的16.6ms，避免绘制的随机性。</li>\n<li>Choreographer，是一个Java类，包路径android.view.Choreographer。类注释是“协调动画、输入和绘图的计时”。</li>\n<li>通常 应用层不会直接使用Choreographer，而是使用更高级的API，例如动画和View绘制相关的ValueAnimator.start()、View.invalidate()等。</li>\n<li>业界一般通过Choreographer来监控应用的帧率。</li>\n</ul>\n<h3 id=\"4-2-源码分析\"><a href=\"#4-2-源码分析\" class=\"headerlink\" title=\"4.2 源码分析\"></a><strong>4.2 源码分析</strong></h3><p>学习 Choreographer 可以帮助理解 每帧运行的原理，也可加深对 Handler机制、View绘制流程的理解，这样再去做UI优化、卡顿优化，思路会更清晰。</p>\n<p>好了，下面开始源码分析了~</p>\n<h5 id=\"4-2-1-入口-和-实例创建\"><a href=\"#4-2-1-入口-和-实例创建\" class=\"headerlink\" title=\"4.2.1 入口 和 实例创建\"></a><strong>4.2.1 入口 和 实例创建</strong></h5><p>在<a href=\"https://juejin.cn/post/7076274407416528909\">《Window和WindowManager》</a>、<a href=\"https://blog.csdn.net/allen_xu_2012_new/article/details/131167564\">《Activity的启动过程详解》</a>中介绍过，Activity启动 走完onResume方法后，会进行<strong>window的添加</strong>。window添加过程会 调用ViewRootImpl的setView()方法，setView()方法会调用requestLayout()方法来请求绘制布局，requestLayout()方法内部又会走到scheduleTraversals()方法，最后会走到performTraversals()方法，接着到了我们熟知的测量、布局、绘制三大流程了。</p>\n<p>另外，查看源码发现，当我们使用 ValueAnimator.start()、View.invalidate()时，最后也是走到ViewRootImpl的scheduleTraversals()方法。（View.invalidate()内部会循环获取ViewParent直到ViewRootImpl的invalidateChildInParent()方法，然后走到scheduleTraversals()，可自行查看源码 ）</p>\n<p>即 <strong>所有UI的变化都是走到ViewRootImpl的scheduleTraversals()方法。</strong></p>\n<p>那么问题又来了，scheduleTraversals() 到 performTraversals() 中间 经历了什么呢？是立刻执行吗？答案很显然是否定的，根据我们上面的介绍，在VSync信号到来时才会执行绘制，即performTraversals()方法。下面来瞅瞅这是如何实现的：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//ViewRootImpl.java</span></span><br><span class=\"line\"><span class=\"keyword\">void</span> <span class=\"title function_\">scheduleTraversals</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!mTraversalScheduled) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//此字段保证同时间多次更改只会刷新一次，例如TextView连续两次setText(),也只会走一次绘制流程</span></span><br><span class=\"line\">        mTraversalScheduled = <span class=\"literal\">true</span>;</span><br><span class=\"line\">        <span class=\"comment\">//添加同步屏障，屏蔽同步消息，保证VSync到来立即执行绘制</span></span><br><span class=\"line\">        mTraversalBarrier = mHandler.getLooper().getQueue().postSyncBarrier();</span><br><span class=\"line\">        <span class=\"comment\">//mTraversalRunnable是TraversalRunnable实例，最终走到run()，也即doTraversal();</span></span><br><span class=\"line\">        mChoreographer.postCallback(</span><br><span class=\"line\">                Choreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, <span class=\"literal\">null</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!mUnbufferedInputDispatch) &#123;</span><br><span class=\"line\">            scheduleConsumeBatchedInput();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        notifyRendererOfFramePending();</span><br><span class=\"line\">        pokeDrawLockIfNeeded();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">final</span> <span class=\"keyword\">class</span> <span class=\"title class_\">TraversalRunnable</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Runnable</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        doTraversal();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">final</span> <span class=\"type\">TraversalRunnable</span> <span class=\"variable\">mTraversalRunnable</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">TraversalRunnable</span>();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">void</span> <span class=\"title function_\">doTraversal</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mTraversalScheduled) &#123;</span><br><span class=\"line\">        mTraversalScheduled = <span class=\"literal\">false</span>;</span><br><span class=\"line\">        <span class=\"comment\">//移除同步屏障</span></span><br><span class=\"line\">        mHandler.getLooper().getQueue().removeSyncBarrier(mTraversalBarrier);</span><br><span class=\"line\">        ...</span><br><span class=\"line\">        <span class=\"comment\">//开始三大绘制流程</span></span><br><span class=\"line\">        performTraversals();</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>主要有以下逻辑：</p>\n<ol>\n<li>首先使用mTraversalScheduled字段保证同时间多次更改只会刷新一次，例如TextView连续两次setText()，也只会走一次绘制流程。</li>\n<li>然后把当前线程的<a href=\"https://cloud.tencent.com/product/message-queue-catalog?from_column=20065&from=20065\">消息队列</a>Queue添加了<strong>同步屏障</strong>，这样就屏蔽了正常的同步消息，保证VSync到来后立即执行绘制，而不是要等前面的同步消息。后面会具体分析同步屏障和异步消息的代码逻辑。</li>\n<li>调用了mChoreographer.postCallback()方法，发送一个会在下一帧执行的回调，即<strong>在下一个VSync到来时会执行TraversalRunnable–&gt;doTraversal()—&gt;performTraversals()–&gt;绘制流程</strong>。</li>\n</ol>\n<p>接下来，就是分析的重点——Choreographer。我们先看它的实例mChoreographer，是在ViewRootImpl的构造方法内使用Choreographer.getInstance()创建：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">Choreographer mChoreographer;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//ViewRootImpl实例是在添加window时创建</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"title function_\">ViewRootImpl</span><span class=\"params\">(Context context, Display display)</span> &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    mChoreographer = Choreographer.getInstance();</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们先来看看Choreographer.getInstance()：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Choreographer <span class=\"title function_\">getInstance</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> sThreadInstance.get();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> ThreadLocal&lt;Choreographer&gt; sThreadInstance =</span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">ThreadLocal</span>&lt;Choreographer&gt;() &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">protected</span> Choreographer <span class=\"title function_\">initialValue</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">Looper</span> <span class=\"variable\">looper</span> <span class=\"operator\">=</span> Looper.myLooper();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (looper == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//当前线程要有looper，Choreographer实例需要传入</span></span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">IllegalStateException</span>(<span class=\"string\">&quot;The current thread must have a looper!&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"type\">Choreographer</span> <span class=\"variable\">choreographer</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Choreographer</span>(looper, VSYNC_SOURCE_APP);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (looper == Looper.getMainLooper()) &#123;</span><br><span class=\"line\">            mMainInstance = choreographer;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> choreographer;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>看到这里 如你对Handler机制中looper比较熟悉的话，应该知道 Choreographer和Looper一样 是线程单例的。且当前线程要有looper，Choreographer实例需要传入。接着看看Choreographer构造方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"title function_\">Choreographer</span><span class=\"params\">(Looper looper, <span class=\"type\">int</span> vsyncSource)</span> &#123;</span><br><span class=\"line\">    mLooper = looper;</span><br><span class=\"line\">    <span class=\"comment\">//使用当前线程looper创建 mHandler</span></span><br><span class=\"line\">    mHandler = <span class=\"keyword\">new</span> <span class=\"title class_\">FrameHandler</span>(looper);</span><br><span class=\"line\">    <span class=\"comment\">//USE_VSYNC 4.1以上默认是true，表示 具备接受VSync的能力，这个接受能力就是FrameDisplayEventReceiver</span></span><br><span class=\"line\">    mDisplayEventReceiver = USE_VSYNC</span><br><span class=\"line\">            ? <span class=\"keyword\">new</span> <span class=\"title class_\">FrameDisplayEventReceiver</span>(looper, vsyncSource)</span><br><span class=\"line\">            : <span class=\"literal\">null</span>;</span><br><span class=\"line\">    mLastFrameTimeNanos = Long.MIN_VALUE;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 计算一帧的时间，Android手机屏幕是60Hz的刷新频率，就是16ms</span></span><br><span class=\"line\">    mFrameIntervalNanos = (<span class=\"type\">long</span>)(<span class=\"number\">1000000000</span> / getRefreshRate());</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 创建一个链表类型CallbackQueue的数组，大小为5，</span></span><br><span class=\"line\">    <span class=\"comment\">//也就是数组中有五个链表，每个链表存相同类型的任务：输入、动画、遍历绘制等任务（CALLBACK_INPUT、CALLBACK_ANIMATION、CALLBACK_TRAVERSAL）</span></span><br><span class=\"line\">    mCallbackQueues = <span class=\"keyword\">new</span> <span class=\"title class_\">CallbackQueue</span>[CALLBACK_LAST + <span class=\"number\">1</span>];</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt;= CALLBACK_LAST; i++) &#123;</span><br><span class=\"line\">        mCallbackQueues[i] = <span class=\"keyword\">new</span> <span class=\"title class_\">CallbackQueue</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// b/68769804: For low FPS experiments.</span></span><br><span class=\"line\">    setFPSDivisor(SystemProperties.getInt(ThreadedRenderer.DEBUG_FPS_DIVISOR, <span class=\"number\">1</span>));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>代码中都有注释，创建了一个mHandler、VSync事件接收器mDisplayEventReceiver、任务链表数组mCallbackQueues。FrameHandler、FrameDisplayEventReceiver、CallbackQueue后面会一一说明。</p>\n<h5 id=\"4-2-2-安排任务—postCallback\"><a href=\"#4-2-2-安排任务—postCallback\" class=\"headerlink\" title=\"4.2.2 安排任务—postCallback\"></a><strong>4.2.2 安排任务—postCallback</strong></h5><p>回头看mChoreographer.postCallback(Choreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, null)方法，注意到第一个参数是CALLBACK_TRAVERSAL，表示回调任务的类型，共有以下5种类型：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//输入事件，首先执行</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">CALLBACK_INPUT</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"comment\">//动画，第二执行</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">CALLBACK_ANIMATION</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"comment\">//插入更新的动画，第三执行</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">CALLBACK_INSETS_ANIMATION</span> <span class=\"operator\">=</span> <span class=\"number\">2</span>;</span><br><span class=\"line\"><span class=\"comment\">//绘制，第四执行</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">CALLBACK_TRAVERSAL</span> <span class=\"operator\">=</span> <span class=\"number\">3</span>;</span><br><span class=\"line\"><span class=\"comment\">//提交，最后执行，</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">CALLBACK_COMMIT</span> <span class=\"operator\">=</span> <span class=\"number\">4</span>;</span><br></pre></td></tr></table></figure>\n\n<p>五种类型任务对应存入对应的CallbackQueue中，每当收到 VSYNC 信号时，Choreographer 将首先处理 INPUT 类型的任务，然后是 ANIMATION 类型，最后才是 TRAVERSAL 类型。</p>\n<p>postCallback()内部调用postCallbackDelayed()，接着又调用postCallbackDelayedInternal()，来瞅瞅：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">postCallbackDelayedInternal</span><span class=\"params\">(<span class=\"type\">int</span> callbackType,</span></span><br><span class=\"line\"><span class=\"params\">        Object action, Object token, <span class=\"type\">long</span> delayMillis)</span> &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (mLock) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 当前时间</span></span><br><span class=\"line\">        <span class=\"keyword\">final</span> <span class=\"type\">long</span> <span class=\"variable\">now</span> <span class=\"operator\">=</span> SystemClock.uptimeMillis();</span><br><span class=\"line\">        <span class=\"comment\">// 加上延迟时间</span></span><br><span class=\"line\">        <span class=\"keyword\">final</span> <span class=\"type\">long</span> <span class=\"variable\">dueTime</span> <span class=\"operator\">=</span> now + delayMillis;</span><br><span class=\"line\">        <span class=\"comment\">//取对应类型的CallbackQueue添加任务</span></span><br><span class=\"line\">        mCallbackQueues[callbackType].addCallbackLocked(dueTime, action, token);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (dueTime &lt;= now) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//立即执行</span></span><br><span class=\"line\">            scheduleFrameLocked(now);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">//延迟运行，最终也会走到scheduleFrameLocked()</span></span><br><span class=\"line\">            <span class=\"type\">Message</span> <span class=\"variable\">msg</span> <span class=\"operator\">=</span> mHandler.obtainMessage(MSG_DO_SCHEDULE_CALLBACK, action);</span><br><span class=\"line\">            msg.arg1 = callbackType;</span><br><span class=\"line\">            msg.setAsynchronous(<span class=\"literal\">true</span>);</span><br><span class=\"line\">            mHandler.sendMessageAtTime(msg, dueTime);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>首先取对应类型的CallbackQueue添加任务，action就是mTraversalRunnable，token是null。<strong>CallbackQueue的addCallbackLocked()就是把 dueTime、action、token组装成CallbackRecord后 存入CallbackQueue的下一个节点</strong>，具体代码比较简单，不再跟进。</p>\n<p>然后注意到如果没有延迟会执行scheduleFrameLocked()方法，有延迟就会使用 mHandler发送MSG_DO_SCHEDULE_CALLBACK消息，并且注意到 <strong>使用msg.setAsynchronous(true)把消息设置成异步</strong>，这是因为前面设置了同步屏障，只有异步消息才会执行。我们看下mHandler的对这个消息的处理：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">class</span> <span class=\"title class_\">FrameHandler</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">Handler</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">FrameHandler</span><span class=\"params\">(Looper looper)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">super</span>(looper);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">handleMessage</span><span class=\"params\">(Message msg)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">switch</span> (msg.what) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> MSG_DO_FRAME:</span><br><span class=\"line\">                <span class=\"comment\">// 执行doFrame,即绘制过程</span></span><br><span class=\"line\">                doFrame(System.nanoTime(), <span class=\"number\">0</span>);</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> MSG_DO_SCHEDULE_VSYNC:</span><br><span class=\"line\">                <span class=\"comment\">//申请VSYNC信号，例如当前需要绘制任务时</span></span><br><span class=\"line\">                doScheduleVsync();</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> MSG_DO_SCHEDULE_CALLBACK:</span><br><span class=\"line\">                <span class=\"comment\">//需要延迟的任务，最终还是执行上述两个事件</span></span><br><span class=\"line\">                doScheduleCallback(msg.arg1);</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>直接使用doScheduleCallback方法，看看：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> <span class=\"title function_\">doScheduleCallback</span><span class=\"params\">(<span class=\"type\">int</span> callbackType)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (mLock) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!mFrameScheduled) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">final</span> <span class=\"type\">long</span> <span class=\"variable\">now</span> <span class=\"operator\">=</span> SystemClock.uptimeMillis();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (mCallbackQueues[callbackType].hasDueCallbacksLocked(now)) &#123;</span><br><span class=\"line\">                scheduleFrameLocked(now);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>发现也是走到这里，即延迟运行最终也会走到scheduleFrameLocked()，跟进看看：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">scheduleFrameLocked</span><span class=\"params\">(<span class=\"type\">long</span> now)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!mFrameScheduled) &#123;</span><br><span class=\"line\">        mFrameScheduled = <span class=\"literal\">true</span>;</span><br><span class=\"line\">        <span class=\"comment\">//开启了VSYNC</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (USE_VSYNC) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (DEBUG_FRAMES) &#123;</span><br><span class=\"line\">                Log.d(TAG, <span class=\"string\">&quot;Scheduling next frame on vsync.&quot;</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">//当前执行的线程，是否是mLooper所在线程</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (isRunningOnLooperThreadLocked()) &#123;</span><br><span class=\"line\">                <span class=\"comment\">//申请 VSYNC 信号</span></span><br><span class=\"line\">                scheduleVsyncLocked();</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 若不在，就用mHandler发送消息到原线程，最后还是调用scheduleVsyncLocked方法</span></span><br><span class=\"line\">                <span class=\"type\">Message</span> <span class=\"variable\">msg</span> <span class=\"operator\">=</span> mHandler.obtainMessage(MSG_DO_SCHEDULE_VSYNC);</span><br><span class=\"line\">                msg.setAsynchronous(<span class=\"literal\">true</span>);<span class=\"comment\">//异步</span></span><br><span class=\"line\">                mHandler.sendMessageAtFrontOfQueue(msg);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 如果未开启VSYNC则直接doFrame方法（4.1后默认开启）</span></span><br><span class=\"line\">            <span class=\"keyword\">final</span> <span class=\"type\">long</span> <span class=\"variable\">nextFrameTime</span> <span class=\"operator\">=</span> Math.max(</span><br><span class=\"line\">                    mLastFrameTimeNanos / TimeUtils.NANOS_PER_MS + sFrameDelay, now);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (DEBUG_FRAMES) &#123;</span><br><span class=\"line\">                Log.d(TAG, <span class=\"string\">&quot;Scheduling next frame in &quot;</span> + (nextFrameTime - now) + <span class=\"string\">&quot; ms.&quot;</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"type\">Message</span> <span class=\"variable\">msg</span> <span class=\"operator\">=</span> mHandler.obtainMessage(MSG_DO_FRAME);</span><br><span class=\"line\">            msg.setAsynchronous(<span class=\"literal\">true</span>);<span class=\"comment\">//异步</span></span><br><span class=\"line\">            mHandler.sendMessageAtTime(msg, nextFrameTime);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>如果系统未开启 VSYNC 机制，此时直接发送 MSG_DO_FRAME 消息到 FrameHandler。注意查看上面贴出的 FrameHandler 代码，此时直接执行 doFrame 方法。</li>\n<li>Android 4.1 之后系统默认开启 VSYNC，在 Choreographer 的构造方法会创建一个 FrameDisplayEventReceiver，scheduleVsyncLocked 方法将会通过它申请 VSYNC 信号。</li>\n<li>isRunningOnLooperThreadLocked 方法，其内部根据 Looper 判断是否在原线程，否则发送消息到 FrameHandler。最终还是会调用 scheduleVsyncLocked 方法申请 VSYNC 信号。</li>\n</ol>\n<p>到这里，<strong>FrameHandler的作用很明显里了：发送异步消息（因为前面设置了同步屏障）。有延迟的任务发延迟消息、不在原线程的发到原线程、没开启VSYNC的直接走 doFrame 方法取执行绘制。</strong></p>\n<h5 id=\"4-2-3-申请和接受VSync\"><a href=\"#4-2-3-申请和接受VSync\" class=\"headerlink\" title=\"4.2.3 申请和接受VSync\"></a><strong>4.2.3 申请和接受VSync</strong></h5><p>好了， 接着就看 scheduleVsyncLocked 方法是如何申请 VSYNC 信号的。猜测肯定申请 VSYNC 信号后，信号到来时也是走doFrame() 方法，doFrame()后面再看。先跟进scheduleVsyncLocked():</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">scheduleVsyncLocked</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    mDisplayEventReceiver.scheduleVsync();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>很简单，调用mDisplayEventReceiver的scheduleVsync()方法，mDisplayEventReceiver是Choreographer构造方法中创建，是FrameDisplayEventReceiver 的实例。FrameDisplayEventReceiver是 DisplayEventReceiver 的子类，DisplayEventReceiver 是一个 abstract class：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"title function_\">DisplayEventReceiver</span><span class=\"params\">(Looper looper, <span class=\"type\">int</span> vsyncSource)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (looper == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">IllegalArgumentException</span>(<span class=\"string\">&quot;looper must not be null&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    mMessageQueue = looper.getQueue();</span><br><span class=\"line\">    <span class=\"comment\">// 注册VSYNC信号监听者</span></span><br><span class=\"line\">    mReceiverPtr = nativeInit(<span class=\"keyword\">new</span> <span class=\"title class_\">WeakReference</span>&lt;DisplayEventReceiver&gt;(<span class=\"built_in\">this</span>), mMessageQueue,</span><br><span class=\"line\">            vsyncSource);</span><br><span class=\"line\"></span><br><span class=\"line\">    mCloseGuard.open(<span class=\"string\">&quot;dispose&quot;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在 DisplayEventReceiver 的构造方法会通过 JNI 创建一个 IDisplayEventConnection 的 VSYNC 的监听者。</p>\n<p>FrameDisplayEventReceiver的scheduleVsync()就是在 DisplayEventReceiver中：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">scheduleVsync</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mReceiverPtr == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        Log.w(TAG, <span class=\"string\">&quot;Attempted to schedule a vertical sync pulse but the display event &quot;</span></span><br><span class=\"line\">                + <span class=\"string\">&quot;receiver has already been disposed.&quot;</span>);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 申请VSYNC中断信号，会回调onVsync方法</span></span><br><span class=\"line\">        nativeScheduleVsync(mReceiverPtr);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>那么scheduleVsync()就是使用native方法nativeScheduleVsync()去申请VSYNC信号。这个native方法就看不了了，只需要知道<strong>VSYNC信号的接受回调是onVsync()</strong>，我们直接看onVsync()：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 接收到VSync脉冲时 回调</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> timestampNanos VSync脉冲的时间戳</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> physicalDisplayId Stable display ID that uniquely describes a (display, port) pair.</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> frame 帧号码，自增</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"meta\">@UnsupportedAppUsage</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">onVsync</span><span class=\"params\">(<span class=\"type\">long</span> timestampNanos, <span class=\"type\">long</span> physicalDisplayId, <span class=\"type\">int</span> frame)</span> &#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>具体实现是在FrameDisplayEventReceiver中：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">class</span> <span class=\"title class_\">FrameDisplayEventReceiver</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">DisplayEventReceiver</span></span><br><span class=\"line\">        <span class=\"keyword\">implements</span> <span class=\"title class_\">Runnable</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">boolean</span> mHavePendingVsync;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">long</span> mTimestampNanos;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">int</span> mFrame;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">FrameDisplayEventReceiver</span><span class=\"params\">(Looper looper, <span class=\"type\">int</span> vsyncSource)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">super</span>(looper, vsyncSource);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">onVsync</span><span class=\"params\">(<span class=\"type\">long</span> timestampNanos, <span class=\"type\">long</span> physicalDisplayId, <span class=\"type\">int</span> frame)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// Post the vsync event to the Handler.</span></span><br><span class=\"line\">        <span class=\"comment\">// The idea is to prevent incoming vsync events from completely starving</span></span><br><span class=\"line\">        <span class=\"comment\">// the message queue.  If there are no messages in the queue with timestamps</span></span><br><span class=\"line\">        <span class=\"comment\">// earlier than the frame time, then the vsync event will be processed immediately.</span></span><br><span class=\"line\">        <span class=\"comment\">// Otherwise, messages that predate the vsync event will be handled first.</span></span><br><span class=\"line\">        <span class=\"type\">long</span> <span class=\"variable\">now</span> <span class=\"operator\">=</span> System.nanoTime();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (timestampNanos &gt; now) &#123;</span><br><span class=\"line\">            Log.w(TAG, <span class=\"string\">&quot;Frame time is &quot;</span> + ((timestampNanos - now) * <span class=\"number\">0.000001f</span>)</span><br><span class=\"line\">                    + <span class=\"string\">&quot; ms in the future!  Check that graphics HAL is generating vsync &quot;</span></span><br><span class=\"line\">                    + <span class=\"string\">&quot;timestamps using the correct timebase.&quot;</span>);</span><br><span class=\"line\">            timestampNanos = now;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mHavePendingVsync) &#123;</span><br><span class=\"line\">            Log.w(TAG, <span class=\"string\">&quot;Already have a pending vsync event.  There should only be &quot;</span></span><br><span class=\"line\">                    + <span class=\"string\">&quot;one at a time.&quot;</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            mHavePendingVsync = <span class=\"literal\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        mTimestampNanos = timestampNanos;</span><br><span class=\"line\">        mFrame = frame;</span><br><span class=\"line\">        <span class=\"comment\">//将本身作为runnable传入msg， 发消息后 会走run()，即doFrame()，也是异步消息</span></span><br><span class=\"line\">        <span class=\"type\">Message</span> <span class=\"variable\">msg</span> <span class=\"operator\">=</span> Message.obtain(mHandler, <span class=\"built_in\">this</span>);</span><br><span class=\"line\">        msg.setAsynchronous(<span class=\"literal\">true</span>);</span><br><span class=\"line\">        mHandler.sendMessageAtTime(msg, timestampNanos / TimeUtils.NANOS_PER_MS);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        mHavePendingVsync = <span class=\"literal\">false</span>;</span><br><span class=\"line\">        doFrame(mTimestampNanos, mFrame);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>onVsync()中，将接收器本身作为runnable传入异步消息msg，并使用mHandler发送msg，最终执行的就是doFrame()方法了。</p>\n<p>注意一点是，<strong>onVsync()方法中只是使用mHandler发送消息到MessageQueue中，不一定是立刻执行，如何MessageQueue中前面有较为耗时的操作，那么就要等完成，才会执行本次的doFrame()</strong>。</p>\n<h5 id=\"4-2-4-doFrame\"><a href=\"#4-2-4-doFrame\" class=\"headerlink\" title=\"4.2.4 doFrame\"></a><strong>4.2.4 doFrame</strong></h5><p>和上面猜测一样，申请VSync信号接收到后确实是走 doFrame()方法，那么就来看看Choreographer的doFrame()：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> <span class=\"title function_\">doFrame</span><span class=\"params\">(<span class=\"type\">long</span> frameTimeNanos, <span class=\"type\">int</span> frame)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"type\">long</span> startNanos;</span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (mLock) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!mFrameScheduled) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span>; <span class=\"comment\">// no work to do</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        ...</span><br><span class=\"line\">        <span class=\"comment\">// 预期执行时间</span></span><br><span class=\"line\">        <span class=\"type\">long</span> <span class=\"variable\">intendedFrameTimeNanos</span> <span class=\"operator\">=</span> frameTimeNanos;</span><br><span class=\"line\">        startNanos = System.nanoTime();</span><br><span class=\"line\">        <span class=\"comment\">// 超时时间是否超过一帧的时间（这是因为MessageQueue虽然添加了同步屏障，但是还是有正在执行的同步任务，导致doFrame延迟执行了）</span></span><br><span class=\"line\">        <span class=\"keyword\">final</span> <span class=\"type\">long</span> <span class=\"variable\">jitterNanos</span> <span class=\"operator\">=</span> startNanos - frameTimeNanos;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (jitterNanos &gt;= mFrameIntervalNanos) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 计算掉帧数</span></span><br><span class=\"line\">            <span class=\"keyword\">final</span> <span class=\"type\">long</span> <span class=\"variable\">skippedFrames</span> <span class=\"operator\">=</span> jitterNanos / mFrameIntervalNanos;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (skippedFrames &gt;= SKIPPED_FRAME_WARNING_LIMIT) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 掉帧超过30帧打印Log提示</span></span><br><span class=\"line\">                Log.i(TAG, <span class=\"string\">&quot;Skipped &quot;</span> + skippedFrames + <span class=\"string\">&quot; frames!  &quot;</span></span><br><span class=\"line\">                        + <span class=\"string\">&quot;The application may be doing too much work on its main thread.&quot;</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">final</span> <span class=\"type\">long</span> <span class=\"variable\">lastFrameOffset</span> <span class=\"operator\">=</span> jitterNanos % mFrameIntervalNanos;</span><br><span class=\"line\">            ...</span><br><span class=\"line\">            frameTimeNanos = startNanos - lastFrameOffset;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        ...</span><br><span class=\"line\"></span><br><span class=\"line\">        mFrameInfo.setVsync(intendedFrameTimeNanos, frameTimeNanos);</span><br><span class=\"line\">        <span class=\"comment\">// Frame标志位恢复</span></span><br><span class=\"line\">        mFrameScheduled = <span class=\"literal\">false</span>;</span><br><span class=\"line\">        <span class=\"comment\">// 记录最后一帧时间</span></span><br><span class=\"line\">        mLastFrameTimeNanos = frameTimeNanos;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 按类型顺序 执行任务</span></span><br><span class=\"line\">        Trace.traceBegin(Trace.TRACE_TAG_VIEW, <span class=\"string\">&quot;Choreographer#doFrame&quot;</span>);</span><br><span class=\"line\">        AnimationUtils.lockAnimationClock(frameTimeNanos / TimeUtils.NANOS_PER_MS);</span><br><span class=\"line\"></span><br><span class=\"line\">        mFrameInfo.markInputHandlingStart();</span><br><span class=\"line\">        doCallbacks(Choreographer.CALLBACK_INPUT, frameTimeNanos);</span><br><span class=\"line\"></span><br><span class=\"line\">        mFrameInfo.markAnimationsStart();</span><br><span class=\"line\">        doCallbacks(Choreographer.CALLBACK_ANIMATION, frameTimeNanos);</span><br><span class=\"line\">        doCallbacks(Choreographer.CALLBACK_INSETS_ANIMATION, frameTimeNanos);</span><br><span class=\"line\"></span><br><span class=\"line\">        mFrameInfo.markPerformTraversalsStart();</span><br><span class=\"line\">        doCallbacks(Choreographer.CALLBACK_TRAVERSAL, frameTimeNanos);</span><br><span class=\"line\"></span><br><span class=\"line\">        doCallbacks(Choreographer.CALLBACK_COMMIT, frameTimeNanos);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        AnimationUtils.unlockAnimationClock();</span><br><span class=\"line\">        Trace.traceEnd(Trace.TRACE_TAG_VIEW);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面都有注释了很好理解，接着看任务的具体执行doCallbacks 方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> <span class=\"title function_\">doCallbacks</span><span class=\"params\">(<span class=\"type\">int</span> callbackType, <span class=\"type\">long</span> frameTimeNanos)</span> &#123;</span><br><span class=\"line\">    CallbackRecord callbacks;</span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (mLock) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">final</span> <span class=\"type\">long</span> <span class=\"variable\">now</span> <span class=\"operator\">=</span> System.nanoTime();</span><br><span class=\"line\">        <span class=\"comment\">// 根据指定的类型CallbackkQueue中查找到达执行时间的CallbackRecord</span></span><br><span class=\"line\">        callbacks = mCallbackQueues[callbackType].extractDueCallbacksLocked(now / TimeUtils.NANOS_PER_MS);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (callbacks == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        mCallbacksRunning = <span class=\"literal\">true</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//提交任务类型</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (callbackType == Choreographer.CALLBACK_COMMIT) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">final</span> <span class=\"type\">long</span> <span class=\"variable\">jitterNanos</span> <span class=\"operator\">=</span> now - frameTimeNanos;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (jitterNanos &gt;= <span class=\"number\">2</span> * mFrameIntervalNanos) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">final</span> <span class=\"type\">long</span> <span class=\"variable\">lastFrameOffset</span> <span class=\"operator\">=</span> jitterNanos % mFrameIntervalNanos</span><br><span class=\"line\">                        + mFrameIntervalNanos;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (DEBUG_JANK) &#123;</span><br><span class=\"line\">                    Log.d(TAG, <span class=\"string\">&quot;Commit callback delayed by &quot;</span> + (jitterNanos * <span class=\"number\">0.000001f</span>)</span><br><span class=\"line\">                            + <span class=\"string\">&quot; ms which is more than twice the frame interval of &quot;</span></span><br><span class=\"line\">                            + (mFrameIntervalNanos * <span class=\"number\">0.000001f</span>) + <span class=\"string\">&quot; ms!  &quot;</span></span><br><span class=\"line\">                            + <span class=\"string\">&quot;Setting frame time to &quot;</span> + (lastFrameOffset * <span class=\"number\">0.000001f</span>)</span><br><span class=\"line\">                            + <span class=\"string\">&quot; ms in the past.&quot;</span>);</span><br><span class=\"line\">                    mDebugPrintNextFrameTimeDelta = <span class=\"literal\">true</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                frameTimeNanos = now - lastFrameOffset;</span><br><span class=\"line\">                mLastFrameTimeNanos = frameTimeNanos;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 迭代执行队列所有任务</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">CallbackRecord</span> <span class=\"variable\">c</span> <span class=\"operator\">=</span> callbacks; c != <span class=\"literal\">null</span>; c = c.next) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 回调CallbackRecord的run，其内部回调Callback的run</span></span><br><span class=\"line\">            c.run(frameTimeNanos);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span> (mLock) &#123;</span><br><span class=\"line\">            mCallbacksRunning = <span class=\"literal\">false</span>;</span><br><span class=\"line\">            <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">final</span> <span class=\"type\">CallbackRecord</span> <span class=\"variable\">next</span> <span class=\"operator\">=</span> callbacks.next;</span><br><span class=\"line\">                <span class=\"comment\">//回收CallbackRecord</span></span><br><span class=\"line\">                recycleCallbackLocked(callbacks);</span><br><span class=\"line\">                callbacks = next;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">while</span> (callbacks != <span class=\"literal\">null</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>主要内容就是取对应任务类型的队列，遍历队列执行所有任务，执行任务是 CallbackRecord的 run 方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">class</span> <span class=\"title class_\">CallbackRecord</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> CallbackRecord next;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">long</span> dueTime;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> Object action; <span class=\"comment\">// Runnable or FrameCallback</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Object token;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@UnsupportedAppUsage</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">(<span class=\"type\">long</span> frameTimeNanos)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (token == FRAME_CALLBACK_TOKEN) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 通过postFrameCallback 或 postFrameCallbackDelayed，会执行这里</span></span><br><span class=\"line\">            ((FrameCallback)action).doFrame(frameTimeNanos);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">//取出Runnable执行run()</span></span><br><span class=\"line\">            ((Runnable)action).run();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>前面看到mChoreographer.postCallback传的token是null，所以取出action，就是Runnable，执行run()，这里的action就是 ViewRootImpl 发起的绘制任务mTraversalRunnable了，那么<strong>这样整个逻辑就闭环了</strong>。</p>\n<p>那么 啥时候 token &#x3D;&#x3D; FRAME_CALLBACK_TOKEN 呢？答案是Choreographer的postFrameCallback()方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">postFrameCallback</span><span class=\"params\">(FrameCallback callback)</span> &#123;</span><br><span class=\"line\">    postFrameCallbackDelayed(callback, <span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">postFrameCallbackDelayed</span><span class=\"params\">(FrameCallback callback, <span class=\"type\">long</span> delayMillis)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (callback == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">IllegalArgumentException</span>(<span class=\"string\">&quot;callback must not be null&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//也是走到是postCallbackDelayedInternal，并且注意是CALLBACK_ANIMATION类型，</span></span><br><span class=\"line\">    <span class=\"comment\">//token是FRAME_CALLBACK_TOKEN，action就是FrameCallback</span></span><br><span class=\"line\">    postCallbackDelayedInternal(CALLBACK_ANIMATION,</span><br><span class=\"line\">            callback, FRAME_CALLBACK_TOKEN, delayMillis);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">FrameCallback</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">doFrame</span><span class=\"params\">(<span class=\"type\">long</span> frameTimeNanos)</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可以看到postFrameCallback()传入的是FrameCallback实例，接口FrameCallback只有一个doFrame()方法。并且也是走到postCallbackDelayedInternal，FrameCallback实例作为action传入，token则是FRAME_CALLBACK_TOKEN，并且任务是CALLBACK_ANIMATION类型。</p>\n<p><strong>Choreographer的postFrameCallback()通常用来计算丢帧情况</strong>，使用方式如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">      <span class=\"comment\">//Application.java</span></span><br><span class=\"line\">       <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">onCreate</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">           <span class=\"built_in\">super</span>.onCreate();</span><br><span class=\"line\">           <span class=\"comment\">//在Application中使用postFrameCallback</span></span><br><span class=\"line\">           Choreographer.getInstance().postFrameCallback(<span class=\"keyword\">new</span> <span class=\"title class_\">FPSFrameCallback</span>(System.nanoTime()));</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">FPSFrameCallback</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Choreographer</span>.FrameCallback &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">String</span> <span class=\"variable\">TAG</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;FPS_TEST&quot;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">long</span> <span class=\"variable\">mLastFrameTimeNanos</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">long</span> mFrameIntervalNanos;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">FPSFrameCallback</span><span class=\"params\">(<span class=\"type\">long</span> lastFrameTimeNanos)</span> &#123;</span><br><span class=\"line\">        mLastFrameTimeNanos = lastFrameTimeNanos;</span><br><span class=\"line\">        mFrameIntervalNanos = (<span class=\"type\">long</span>)(<span class=\"number\">1000000000</span> / <span class=\"number\">60.0</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">doFrame</span><span class=\"params\">(<span class=\"type\">long</span> frameTimeNanos)</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//初始化时间</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mLastFrameTimeNanos == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            mLastFrameTimeNanos = frameTimeNanos;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> <span class=\"type\">long</span> <span class=\"variable\">jitterNanos</span> <span class=\"operator\">=</span> frameTimeNanos - mLastFrameTimeNanos;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (jitterNanos &gt;= mFrameIntervalNanos) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">final</span> <span class=\"type\">long</span> <span class=\"variable\">skippedFrames</span> <span class=\"operator\">=</span> jitterNanos / mFrameIntervalNanos;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(skippedFrames&gt;<span class=\"number\">30</span>)&#123;</span><br><span class=\"line\">                <span class=\"comment\">//丢帧30以上打印日志</span></span><br><span class=\"line\">                Log.i(TAG, <span class=\"string\">&quot;Skipped &quot;</span> + skippedFrames + <span class=\"string\">&quot; frames!  &quot;</span></span><br><span class=\"line\">                        + <span class=\"string\">&quot;The application may be doing too much work on its main thread.&quot;</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        mLastFrameTimeNanos=frameTimeNanos;</span><br><span class=\"line\">        <span class=\"comment\">//注册下一帧回调</span></span><br><span class=\"line\">        Choreographer.getInstance().postFrameCallback(<span class=\"built_in\">this</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"4-2-5-小结\"><a href=\"#4-2-5-小结\" class=\"headerlink\" title=\"4.2.5 小结\"></a><strong>4.2.5 小结</strong></h5><p>使用Choreographer的postCallback()、postFrameCallback() 作用理解：发送任务 存队列中，监听VSync信号，当前VSync到来时 会使用mHandler发送异步message，这个message的Runnable就是队列中的所有任务。</p>\n<p>好了，Choreographer整个代码逻辑都讲完了，引用《Android 之 Choreographer 详细分析》的流程图：</p>\n<p>原文流程图为：<a href=\"https://i-blog.csdnimg.cn/blog_migrate/5ff22e98afde4ff780f8a291d1081619.png\">Android 之 Choreographer</a>，但并不是很形象，引用另一张流程图：</p>\n<img src=\"https://cdn.julis.wang/blog/img/aab4273a0af898dcc9bb0fdcc0447b5a.png\">\n<h2 id=\"六、疑问解答\"><a href=\"#六、疑问解答\" class=\"headerlink\" title=\"六、疑问解答\"></a><strong>六、疑问解答</strong></h2><ol>\n<li><strong>丢帧</strong>(掉帧) ，是说 这一帧延迟显示 还是丢弃不再显示 ？ 答：延迟显示，因为缓存交换的时机只能等下一个VSync了。</li>\n<li>布局层级较多&#x2F;主线程耗时 是如何造成 丢帧的呢？ 答：布局层级较多&#x2F;主线程耗时 会影响CPU&#x2F;GPU的执行时间，大于16.6ms时只能等下一个VSync了。</li>\n<li>16.6ms刷新一次 是啥意思？是每16.6ms都走一次 measure&#x2F;layout&#x2F;draw ？ 答：屏幕的固定刷新频率是60Hz，即16.6ms。不是每16.6ms都走一次 measure&#x2F;layout&#x2F;draw，而是有绘制任务才会走，并且绘制时间间隔是取决于布局复杂度及主线程耗时。</li>\n<li>measure&#x2F;layout&#x2F;draw 走完，界面就立刻刷新了吗? 答：不是。measure&#x2F;layout&#x2F;draw 走完后 会在VSync到来时进行缓存交换和刷新。</li>\n<li>如果界面没动静止了，还会刷新吗？ 答：屏幕会固定没16.6ms刷新，但CPU&#x2F;GPU不走绘制流程。见下面的SysTrace图。</li>\n<li>可能你知道<strong>VSYNC</strong>，这个具体指啥？在屏幕刷新中如何工作的？ 答：当扫描完一个屏幕后，设备需要重新回到第一行以进入下一次的循环，此时会出现的vertical sync pulse（垂直同步脉冲）来保证双缓冲在最佳时间点才进行交换。并且Android4.1后 CPU&#x2F;GPU的绘制是在VSYNC到来时开始。</li>\n<li>可能你还听过屏幕刷新使用 <strong>双缓存</strong>、<strong>三缓存</strong>，这又是啥意思呢？ 答：双缓存是Back buffer、Frame buffer，用于解决画面撕裂。三缓存增加一个Back buffer，用于减少Jank。</li>\n<li>可能你还听过神秘的<strong>Choreographer</strong>，这又是干啥的？ 答：用于实现——“CPU&#x2F;GPU的绘制是在VSYNC到来时开始”。</li>\n</ol>\n","cover":null,"images":["https://cdn.julis.wang/blog/img/0nq54q5jtq.jpeg","https://cdn.julis.wang/blog/img/xxm0lvzypa.jpeg","https://cdn.julis.wang/blog/img/q2vukxpyvq.jpeg","https://cdn.julis.wang/blog/img/1ax0mz0nu1.jpeg","https://cdn.julis.wang/blog/img/uuqflxwo53.jpeg","https://cdn.julis.wang/blog/img/po2jd1h7u8.jpeg","https://cdn.julis.wang/blog/img/ldq7oda57p.jpeg","https://cdn.julis.wang/blog/img/aab4273a0af898dcc9bb0fdcc0447b5a.png"],"content":"<p>最近在研究 Android 屏幕显示与渲染相关的内容，平时经常看到这些类 <code>ViewRootImpl</code>、<code>Choreographer</code>、<code>Surface</code> 、 <code>SurfaceFlinger</code>等，知道它们都用于屏幕渲染相关，但对它们细节了解较少，相关的文章也比较多，不需要自己完全重新再编写一份，于是对相关内容进行一个总结,<br>主要来源：<a href=\"https://juejin.cn/post/6863756420380196877\">《Android屏幕刷新机制—VSyncChoreographer 全面理解》</a>，这篇博客是我认为是目前看到过最好的一篇，文章由浅入深比较好理解。不过文章里面图片链接资源已经失效，为以后复习相关知识点，在此将其整理删除冗余内容，并对图片资源进行更新。</p>\n<h2 id=\"一、背景和疑问\"><a href=\"#一、背景和疑问\" class=\"headerlink\" title=\"一、背景和疑问\"></a><strong>一、背景和疑问</strong></h2><p>在Android中，当我们谈到 <strong>布局优化</strong>、<strong>卡顿优化</strong> 时，通常都知道 需要减少布局层级、减少主线程耗时操作，这样可以减少<strong>丢帧</strong>。如果丢帧比较严重，那么界面可能会有明显的卡顿感。我们知道 通常手机刷新是每秒60次，即每隔16.6ms刷新一次。 问题来了：</p>\n<ol>\n<li><strong>丢帧</strong>(掉帧) ，是说 这一帧延迟显示 还是丢弃不再显示 ？</li>\n<li>布局层级较多&#x2F;主线程耗时 是如何造成 丢帧的呢？</li>\n<li>16.6ms刷新一次 是啥意思？是每16.6ms都走一次 measure&#x2F;layout&#x2F;draw ？</li>\n<li>measure&#x2F;layout&#x2F;draw 走完，界面就立刻刷新了吗?</li>\n<li>如果界面没动静止了，还会刷新吗？</li>\n<li>可能你知道<strong>VSYNC</strong>，这个具体指啥？在屏幕刷新中如何工作的？</li>\n<li>可能你还听过屏幕刷新使用 <strong>双缓存</strong>、<strong>三缓存</strong>，这又是啥意思呢？</li>\n<li>可能你还听过神秘的<strong>Choreographer</strong>，这又是干啥的？</li>\n</ol>\n<h2 id=\"二、显示系统基础知识\"><a href=\"#二、显示系统基础知识\" class=\"headerlink\" title=\"二、显示系统基础知识\"></a><strong>二、显示系统基础知识</strong></h2><p>在一个典型的显示系统中，一般包括CPU、GPU、Display三个部分， CPU负责计算帧数据，把计算好的数据交给GPU，GPU会对图形数据进行渲染，渲染好后放到buffer(图像缓冲区)里存起来，然后Display（屏幕或显示器）负责把buffer里的数据呈现到屏幕上。如下图：</p>\n<img src=\"https://cdn.julis.wang/blog/img/0nq54q5jtq.jpeg\">\n\n<p>单缓存，从缓存映射到屏幕。</p>\n<h3 id=\"2-1-基础概念\"><a href=\"#2-1-基础概念\" class=\"headerlink\" title=\"2.1 基础概念\"></a><strong>2.1 基础概念</strong></h3><ul>\n<li><strong>屏幕刷新频率</strong> 一秒内屏幕刷新的次数（一秒内显示了多少帧的图像），单位 Hz（赫兹），如常见的 60 Hz。<strong>刷新频率取决于硬件的固定参数</strong>（不会变的）。</li>\n<li><strong>逐行扫描</strong> 显示器并不是一次性将画面显示到屏幕上，而是从左到右边，从上到下逐行扫描，顺序显示整屏的一个个像素点，不过这一过程快到人眼无法察觉到变化。以 60 Hz 刷新率的屏幕为例，这一过程即 1000 &#x2F; 60 ≈ 16ms。</li>\n<li><strong>帧率</strong> （Frame Rate） 表示 <strong>GPU 在一秒内绘制操作的帧数</strong>，单位 fps。例如在电影界采用 24 帧的速度足够使画面运行的非常流畅。而 Android 系统则采用更加流程的 60 fps，即每秒钟GPU最多绘制 60 帧画面。帧率是动态变化的，例如当画面静止时，GPU 是没有绘制操作的，屏幕刷新的还是buffer中的数据，即GPU最后操作的帧数据。</li>\n<li><strong>画面撕裂</strong>（tearing） 一个屏幕内的数据来自2个不同的帧，画面会出现撕裂感，如下图</li>\n</ul>\n<img src=\"https://cdn.julis.wang/blog/img/xxm0lvzypa.jpeg\">\n\n<p>明显看出画面错位的位置，这就是画面撕裂。</p>\n<h3 id=\"2-2-双缓存\"><a href=\"#2-2-双缓存\" class=\"headerlink\" title=\"2.2 双缓存\"></a><strong>2.2 双缓存</strong></h3><h5 id=\"2-2-1-画面撕裂-原因\"><a href=\"#2-2-1-画面撕裂-原因\" class=\"headerlink\" title=\"2.2.1  画面撕裂 原因\"></a><strong>2.2.1  画面撕裂 原因</strong></h5><p>屏幕刷新频是固定的，比如每16.6ms从buffer取数据显示完一帧，理想情况下帧率和刷新频率保持一致，即每绘制完成一帧，显示器显示一帧。但是CPU&#x2F;GPU写数据是不可控的，所以会出现buffer里有些数据根本没显示出来就被重写了，即buffer里的数据可能是来自不同的帧的， 当屏幕刷新时，此时它并不知道buffer的状态，因此从buffer抓取的帧并不是完整的一帧画面，即出现画面撕裂。</p>\n<p>简单说就是Display在显示的过程中，buffer内数据被CPU&#x2F;GPU修改，导致画面撕裂。</p>\n<h5 id=\"2-2-2-双缓存\"><a href=\"#2-2-2-双缓存\" class=\"headerlink\" title=\"2.2.2  双缓存\"></a><strong>2.2.2  双缓存</strong></h5><p>那咋解决画面撕裂呢？答案是使用 双缓存。</p>\n<p>由于图像绘制和屏幕读取 使用的是同个buffer，所以屏幕刷新时可能读取到的是不完整的一帧画面。</p>\n<p><strong>双缓存</strong>，让绘制和显示器拥有各自的buffer：GPU 始终将完成的一帧图像数据写入到 <strong>Back Buffer</strong>，而显示器使用 <strong>Frame Buffer</strong>，当屏幕刷新时，Frame Buffer 并不会发生变化，当Back buffer准备就绪后，它们才进行交换。如下图：</p>\n<img src=\"https://cdn.julis.wang/blog/img/q2vukxpyvq.jpeg\">\n\n<p>双缓存，CPU&#x2F;GPU写数据到Back Buffer，显示器从Frame Buffer取数据</p>\n<h5 id=\"2-2-3-VSync\"><a href=\"#2-2-3-VSync\" class=\"headerlink\" title=\"2.2.3  VSync\"></a><strong>2.2.3  VSync</strong></h5><p>问题又来了：什么时候进行两个buffer的交换呢？</p>\n<p>假如是 Back buffer准备完成一帧数据以后就进行，那么如果此时屏幕还没有完整显示上一帧内容的话，肯定是会出问题的。看来只能是等到屏幕处理完一帧数据后，才可以执行这一操作了。</p>\n<p>当扫描完一个屏幕后，设备需要重新回到第一行以进入下一次的循环，此时有一段时间空隙，称为VerticalBlanking Interval(VBI)。那，这个时间点就是我们进行缓冲区交换的最佳时间。因为此时屏幕没有在刷新，也就避免了交换过程中出现 screen tearing的状况。</p>\n<p><strong>VSync</strong>(垂直同步)是VerticalSynchronization的简写，它利用VBI时期出现的vertical sync pulse（垂直同步脉冲）来保证双缓冲在最佳时间点才进行交换。另外，交换是指各自的内存地址，可以认为该操作是瞬间完成。</p>\n<p>所以说V-sync这个概念并不是Google首创的，它在早年的PC机领域就已经出现了。</p>\n<h2 id=\"三、Android屏幕刷新机制\"><a href=\"#三、Android屏幕刷新机制\" class=\"headerlink\" title=\"三、Android屏幕刷新机制\"></a><strong>三、Android屏幕刷新机制</strong></h2><h3 id=\"3-1-Android4-1之前的问题\"><a href=\"#3-1-Android4-1之前的问题\" class=\"headerlink\" title=\"3.1 Android4.1之前的问题\"></a><strong>3.1 Android4.1之前的问题</strong></h3><p>具体到Android中，在Android4.1之前，屏幕刷新也遵循 上面介绍的 双缓存+VSync 机制。如下图：</p>\n<img src=\"https://cdn.julis.wang/blog/img/1ax0mz0nu1.jpeg\">\n\n<p>双缓存会在VSync脉冲时交换，但CPU&#x2F;GPU绘制是随机的</p>\n<p>以时间的顺序来看下将会发生的过程：</p>\n<ol>\n<li>Display显示第0帧数据，此时CPU和<a href=\"https://cloud.tencent.com/solution/render?from_column=20065&from=20065\">GPU渲染</a>第1帧画面，且在Display显示下一帧前完成</li>\n<li>因为渲染及时，Display在第0帧显示完成后，也就是第1个VSync后，缓存进行交换，然后正常显示第1帧</li>\n<li>接着第2帧开始处理，是直到第2个VSync快来前才开始处理的。</li>\n<li>第2个VSync来时，由于第2帧数据还没有准备就绪，缓存没有交换，显示的还是第1帧。这种情况被Android开发组命名为“Jank”，即发生了<strong>丢帧</strong>。</li>\n<li>当第2帧数据准备完成后，它并不会马上被显示，而是要等待下一个VSync 进行缓存交换再显示。</li>\n</ol>\n<p>所以总的来说，就是屏幕平白无故地多显示了一次第1帧。</p>\n<p>原因是 第2帧的CPU&#x2F;GPU计算 没能在VSync信号到来前完成 。</p>\n<p>我们知道，<strong>双缓存的交换 是在Vsyn到来时进行，交换后屏幕会取Frame buffer内的新数据，而实际 此时的Back buffer 就可以供GPU准备下一帧数据了。如果 Vsyn到来时  CPU&#x2F;GPU就开始操作的话，是有完整的16.6ms的，这样应该会基本避免jank的出现了</strong>（除非CPU&#x2F;GPU计算超过了16.6ms）。  那如何让 CPU&#x2F;GPU计算在 Vsyn到来时进行呢？</p>\n<h3 id=\"3-2-drawing-with-VSync\"><a href=\"#3-2-drawing-with-VSync\" class=\"headerlink\" title=\"3.2 drawing with VSync\"></a><strong>3.2 drawing with VSync</strong></h3><p>为了优化显示性能，Google在Android 4.1系统中对Android Display系统进行了重构，实现了Project Butter（黄油工程）：系统在收到VSync pulse后，将马上开始下一帧的渲染。即<strong>一旦收到VSync通知（16ms触发一次），CPU和GPU 才立刻开始计算然后把数据写入buffer</strong>。如下图：</p>\n<img src=\"https://cdn.julis.wang/blog/img/uuqflxwo53.jpeg\">\n\n<p>VSync脉冲到来：双缓存交换，且开始CPU&#x2F;GPU绘制 CPU&#x2F;GPU根据VSYNC信号同步处理数据，可以让CPU&#x2F;GPU有完整的16ms时间来处理数据，减少了jank。</p>\n<p>一句话总结，<strong>VSync同步使得CPU&#x2F;GPU充分利用了16.6ms时间，减少jank。</strong></p>\n<p>问题又来了，如果界面比较复杂，CPU&#x2F;GPU的处理时间较长 超过了16.6ms呢？如下图：</p>\n<img src=\"https://cdn.julis.wang/blog/img/po2jd1h7u8.jpeg\">\n\n<p>虽然CPU&#x2F;GPU开始在VSync，但超过16.6ms</p>\n<ol>\n<li>在第二个时间段内，但却因 GPU 还在处理 B 帧，缓存没能交换，导致 A 帧被重复显示。</li>\n<li>而B完成后，又因为缺乏VSync pulse信号，它只能等待下一个signal的来临。于是在这一过程中，有一大段时间是被浪费的。</li>\n<li>当下一个VSync出现时，CPU&#x2F;GPU马上执行操作（A帧），且缓存交换，相应的显示屏对应的就是B。这时看起来就是正常的。只不过由于执行时间仍然超过16ms，导致下一次应该执行的缓冲区交换又被推迟了——如此循环反复，便出现了越来越多的“Jank”。</li>\n</ol>\n<p><strong>为什么 CPU 不能在第二个 16ms 处理绘制工作呢？</strong></p>\n<p>原因是只有两个 buffer，Back buffer正在被GPU用来处理B帧的数据， Frame buffer的内容用于Display的显示，这样两个buffer都被占用，CPU 则无法准备下一帧的数据。那么，如果再提供一个buffer，CPU、GPU 和显示设备都能使用各自的buffer工作，互不影响。</p>\n<h3 id=\"3-3-三缓存\"><a href=\"#3-3-三缓存\" class=\"headerlink\" title=\"3.3 三缓存\"></a><strong>3.3 三缓存</strong></h3><p><strong>三缓存</strong>就是在双缓冲机制基础上增加了一个 Graphic Buffer 缓冲区，这样可以最大限度的利用空闲时间，带来的坏处是多使用的一个 Graphic Buffer 所占用的内存。</p>\n<img src=\"https://cdn.julis.wang/blog/img/ldq7oda57p.jpeg\">\n\n<p>三缓存</p>\n<ol>\n<li>第一个Jank，是不可避免的。但是在第二个 16ms 时间段，CPU&#x2F;GPU 使用 <strong>第三个 Buffer</strong> 完成C帧的计算，虽然还是会多显示一次 A 帧，但后续显示就比较顺畅了，有效避免 Jank 的进一步加剧。</li>\n<li>注意在第3段中，A帧的计算已完成，但是在第4个vsync来的时候才显示，如果是双缓冲，那在第三个vynsc就可以显示了。</li>\n</ol>\n<p><strong>三缓冲有效利用了等待vysnc的时间，减少了jank，但是带来了延迟。</strong> 所以，是不是 Buffer 越多越好呢？这个是否定的，Buffer 正常还是两个，当出现 Jank 后三个足以。</p>\n<p>以上就是Android屏幕刷新的原理了。</p>\n<h2 id=\"四、Choreographer\"><a href=\"#四、Choreographer\" class=\"headerlink\" title=\"四、Choreographer\"></a><strong>四、Choreographer</strong></h2><h3 id=\"4-1-概述\"><a href=\"#4-1-概述\" class=\"headerlink\" title=\"4.1 概述\"></a><strong>4.1 概述</strong></h3><p>上面讲到，Google在Android 4.1系统中对Android Display系统进行了优化：在收到VSync pulse后，将马上开始下一帧的渲染。即<strong>一旦收到VSync通知，CPU和GPU就立刻开始计算然后把数据写入buffer</strong>。本节就来讲 “drawing with VSync” 的实现——<strong>Choreographer</strong>。</p>\n<ul>\n<li>Choreographer，意为 舞蹈编导、编舞者。在这里就是指 对CPU&#x2F;GPU绘制的指导—— 收到VSync信号 才开始绘制，保证绘制拥有完整的16.6ms，避免绘制的随机性。</li>\n<li>Choreographer，是一个Java类，包路径android.view.Choreographer。类注释是“协调动画、输入和绘图的计时”。</li>\n<li>通常 应用层不会直接使用Choreographer，而是使用更高级的API，例如动画和View绘制相关的ValueAnimator.start()、View.invalidate()等。</li>\n<li>业界一般通过Choreographer来监控应用的帧率。</li>\n</ul>\n<h3 id=\"4-2-源码分析\"><a href=\"#4-2-源码分析\" class=\"headerlink\" title=\"4.2 源码分析\"></a><strong>4.2 源码分析</strong></h3><p>学习 Choreographer 可以帮助理解 每帧运行的原理，也可加深对 Handler机制、View绘制流程的理解，这样再去做UI优化、卡顿优化，思路会更清晰。</p>\n<p>好了，下面开始源码分析了~</p>\n<h5 id=\"4-2-1-入口-和-实例创建\"><a href=\"#4-2-1-入口-和-实例创建\" class=\"headerlink\" title=\"4.2.1 入口 和 实例创建\"></a><strong>4.2.1 入口 和 实例创建</strong></h5><p>在<a href=\"https://juejin.cn/post/7076274407416528909\">《Window和WindowManager》</a>、<a href=\"https://blog.csdn.net/allen_xu_2012_new/article/details/131167564\">《Activity的启动过程详解》</a>中介绍过，Activity启动 走完onResume方法后，会进行<strong>window的添加</strong>。window添加过程会 调用ViewRootImpl的setView()方法，setView()方法会调用requestLayout()方法来请求绘制布局，requestLayout()方法内部又会走到scheduleTraversals()方法，最后会走到performTraversals()方法，接着到了我们熟知的测量、布局、绘制三大流程了。</p>\n<p>另外，查看源码发现，当我们使用 ValueAnimator.start()、View.invalidate()时，最后也是走到ViewRootImpl的scheduleTraversals()方法。（View.invalidate()内部会循环获取ViewParent直到ViewRootImpl的invalidateChildInParent()方法，然后走到scheduleTraversals()，可自行查看源码 ）</p>\n<p>即 <strong>所有UI的变化都是走到ViewRootImpl的scheduleTraversals()方法。</strong></p>\n<p>那么问题又来了，scheduleTraversals() 到 performTraversals() 中间 经历了什么呢？是立刻执行吗？答案很显然是否定的，根据我们上面的介绍，在VSync信号到来时才会执行绘制，即performTraversals()方法。下面来瞅瞅这是如何实现的：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//ViewRootImpl.java</span></span><br><span class=\"line\"><span class=\"keyword\">void</span> <span class=\"title function_\">scheduleTraversals</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!mTraversalScheduled) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//此字段保证同时间多次更改只会刷新一次，例如TextView连续两次setText(),也只会走一次绘制流程</span></span><br><span class=\"line\">        mTraversalScheduled = <span class=\"literal\">true</span>;</span><br><span class=\"line\">        <span class=\"comment\">//添加同步屏障，屏蔽同步消息，保证VSync到来立即执行绘制</span></span><br><span class=\"line\">        mTraversalBarrier = mHandler.getLooper().getQueue().postSyncBarrier();</span><br><span class=\"line\">        <span class=\"comment\">//mTraversalRunnable是TraversalRunnable实例，最终走到run()，也即doTraversal();</span></span><br><span class=\"line\">        mChoreographer.postCallback(</span><br><span class=\"line\">                Choreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, <span class=\"literal\">null</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!mUnbufferedInputDispatch) &#123;</span><br><span class=\"line\">            scheduleConsumeBatchedInput();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        notifyRendererOfFramePending();</span><br><span class=\"line\">        pokeDrawLockIfNeeded();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">final</span> <span class=\"keyword\">class</span> <span class=\"title class_\">TraversalRunnable</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Runnable</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        doTraversal();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">final</span> <span class=\"type\">TraversalRunnable</span> <span class=\"variable\">mTraversalRunnable</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">TraversalRunnable</span>();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">void</span> <span class=\"title function_\">doTraversal</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mTraversalScheduled) &#123;</span><br><span class=\"line\">        mTraversalScheduled = <span class=\"literal\">false</span>;</span><br><span class=\"line\">        <span class=\"comment\">//移除同步屏障</span></span><br><span class=\"line\">        mHandler.getLooper().getQueue().removeSyncBarrier(mTraversalBarrier);</span><br><span class=\"line\">        ...</span><br><span class=\"line\">        <span class=\"comment\">//开始三大绘制流程</span></span><br><span class=\"line\">        performTraversals();</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>主要有以下逻辑：</p>\n<ol>\n<li>首先使用mTraversalScheduled字段保证同时间多次更改只会刷新一次，例如TextView连续两次setText()，也只会走一次绘制流程。</li>\n<li>然后把当前线程的<a href=\"https://cloud.tencent.com/product/message-queue-catalog?from_column=20065&from=20065\">消息队列</a>Queue添加了<strong>同步屏障</strong>，这样就屏蔽了正常的同步消息，保证VSync到来后立即执行绘制，而不是要等前面的同步消息。后面会具体分析同步屏障和异步消息的代码逻辑。</li>\n<li>调用了mChoreographer.postCallback()方法，发送一个会在下一帧执行的回调，即<strong>在下一个VSync到来时会执行TraversalRunnable–&gt;doTraversal()—&gt;performTraversals()–&gt;绘制流程</strong>。</li>\n</ol>\n<p>接下来，就是分析的重点——Choreographer。我们先看它的实例mChoreographer，是在ViewRootImpl的构造方法内使用Choreographer.getInstance()创建：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">Choreographer mChoreographer;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//ViewRootImpl实例是在添加window时创建</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"title function_\">ViewRootImpl</span><span class=\"params\">(Context context, Display display)</span> &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    mChoreographer = Choreographer.getInstance();</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们先来看看Choreographer.getInstance()：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Choreographer <span class=\"title function_\">getInstance</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> sThreadInstance.get();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> ThreadLocal&lt;Choreographer&gt; sThreadInstance =</span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">ThreadLocal</span>&lt;Choreographer&gt;() &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">protected</span> Choreographer <span class=\"title function_\">initialValue</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">Looper</span> <span class=\"variable\">looper</span> <span class=\"operator\">=</span> Looper.myLooper();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (looper == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//当前线程要有looper，Choreographer实例需要传入</span></span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">IllegalStateException</span>(<span class=\"string\">&quot;The current thread must have a looper!&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"type\">Choreographer</span> <span class=\"variable\">choreographer</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Choreographer</span>(looper, VSYNC_SOURCE_APP);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (looper == Looper.getMainLooper()) &#123;</span><br><span class=\"line\">            mMainInstance = choreographer;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> choreographer;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>看到这里 如你对Handler机制中looper比较熟悉的话，应该知道 Choreographer和Looper一样 是线程单例的。且当前线程要有looper，Choreographer实例需要传入。接着看看Choreographer构造方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"title function_\">Choreographer</span><span class=\"params\">(Looper looper, <span class=\"type\">int</span> vsyncSource)</span> &#123;</span><br><span class=\"line\">    mLooper = looper;</span><br><span class=\"line\">    <span class=\"comment\">//使用当前线程looper创建 mHandler</span></span><br><span class=\"line\">    mHandler = <span class=\"keyword\">new</span> <span class=\"title class_\">FrameHandler</span>(looper);</span><br><span class=\"line\">    <span class=\"comment\">//USE_VSYNC 4.1以上默认是true，表示 具备接受VSync的能力，这个接受能力就是FrameDisplayEventReceiver</span></span><br><span class=\"line\">    mDisplayEventReceiver = USE_VSYNC</span><br><span class=\"line\">            ? <span class=\"keyword\">new</span> <span class=\"title class_\">FrameDisplayEventReceiver</span>(looper, vsyncSource)</span><br><span class=\"line\">            : <span class=\"literal\">null</span>;</span><br><span class=\"line\">    mLastFrameTimeNanos = Long.MIN_VALUE;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 计算一帧的时间，Android手机屏幕是60Hz的刷新频率，就是16ms</span></span><br><span class=\"line\">    mFrameIntervalNanos = (<span class=\"type\">long</span>)(<span class=\"number\">1000000000</span> / getRefreshRate());</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 创建一个链表类型CallbackQueue的数组，大小为5，</span></span><br><span class=\"line\">    <span class=\"comment\">//也就是数组中有五个链表，每个链表存相同类型的任务：输入、动画、遍历绘制等任务（CALLBACK_INPUT、CALLBACK_ANIMATION、CALLBACK_TRAVERSAL）</span></span><br><span class=\"line\">    mCallbackQueues = <span class=\"keyword\">new</span> <span class=\"title class_\">CallbackQueue</span>[CALLBACK_LAST + <span class=\"number\">1</span>];</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt;= CALLBACK_LAST; i++) &#123;</span><br><span class=\"line\">        mCallbackQueues[i] = <span class=\"keyword\">new</span> <span class=\"title class_\">CallbackQueue</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// b/68769804: For low FPS experiments.</span></span><br><span class=\"line\">    setFPSDivisor(SystemProperties.getInt(ThreadedRenderer.DEBUG_FPS_DIVISOR, <span class=\"number\">1</span>));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>代码中都有注释，创建了一个mHandler、VSync事件接收器mDisplayEventReceiver、任务链表数组mCallbackQueues。FrameHandler、FrameDisplayEventReceiver、CallbackQueue后面会一一说明。</p>\n<h5 id=\"4-2-2-安排任务—postCallback\"><a href=\"#4-2-2-安排任务—postCallback\" class=\"headerlink\" title=\"4.2.2 安排任务—postCallback\"></a><strong>4.2.2 安排任务—postCallback</strong></h5><p>回头看mChoreographer.postCallback(Choreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, null)方法，注意到第一个参数是CALLBACK_TRAVERSAL，表示回调任务的类型，共有以下5种类型：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//输入事件，首先执行</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">CALLBACK_INPUT</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"comment\">//动画，第二执行</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">CALLBACK_ANIMATION</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"comment\">//插入更新的动画，第三执行</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">CALLBACK_INSETS_ANIMATION</span> <span class=\"operator\">=</span> <span class=\"number\">2</span>;</span><br><span class=\"line\"><span class=\"comment\">//绘制，第四执行</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">CALLBACK_TRAVERSAL</span> <span class=\"operator\">=</span> <span class=\"number\">3</span>;</span><br><span class=\"line\"><span class=\"comment\">//提交，最后执行，</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">CALLBACK_COMMIT</span> <span class=\"operator\">=</span> <span class=\"number\">4</span>;</span><br></pre></td></tr></table></figure>\n\n<p>五种类型任务对应存入对应的CallbackQueue中，每当收到 VSYNC 信号时，Choreographer 将首先处理 INPUT 类型的任务，然后是 ANIMATION 类型，最后才是 TRAVERSAL 类型。</p>\n<p>postCallback()内部调用postCallbackDelayed()，接着又调用postCallbackDelayedInternal()，来瞅瞅：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">postCallbackDelayedInternal</span><span class=\"params\">(<span class=\"type\">int</span> callbackType,</span></span><br><span class=\"line\"><span class=\"params\">        Object action, Object token, <span class=\"type\">long</span> delayMillis)</span> &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (mLock) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 当前时间</span></span><br><span class=\"line\">        <span class=\"keyword\">final</span> <span class=\"type\">long</span> <span class=\"variable\">now</span> <span class=\"operator\">=</span> SystemClock.uptimeMillis();</span><br><span class=\"line\">        <span class=\"comment\">// 加上延迟时间</span></span><br><span class=\"line\">        <span class=\"keyword\">final</span> <span class=\"type\">long</span> <span class=\"variable\">dueTime</span> <span class=\"operator\">=</span> now + delayMillis;</span><br><span class=\"line\">        <span class=\"comment\">//取对应类型的CallbackQueue添加任务</span></span><br><span class=\"line\">        mCallbackQueues[callbackType].addCallbackLocked(dueTime, action, token);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (dueTime &lt;= now) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//立即执行</span></span><br><span class=\"line\">            scheduleFrameLocked(now);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">//延迟运行，最终也会走到scheduleFrameLocked()</span></span><br><span class=\"line\">            <span class=\"type\">Message</span> <span class=\"variable\">msg</span> <span class=\"operator\">=</span> mHandler.obtainMessage(MSG_DO_SCHEDULE_CALLBACK, action);</span><br><span class=\"line\">            msg.arg1 = callbackType;</span><br><span class=\"line\">            msg.setAsynchronous(<span class=\"literal\">true</span>);</span><br><span class=\"line\">            mHandler.sendMessageAtTime(msg, dueTime);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>首先取对应类型的CallbackQueue添加任务，action就是mTraversalRunnable，token是null。<strong>CallbackQueue的addCallbackLocked()就是把 dueTime、action、token组装成CallbackRecord后 存入CallbackQueue的下一个节点</strong>，具体代码比较简单，不再跟进。</p>\n<p>然后注意到如果没有延迟会执行scheduleFrameLocked()方法，有延迟就会使用 mHandler发送MSG_DO_SCHEDULE_CALLBACK消息，并且注意到 <strong>使用msg.setAsynchronous(true)把消息设置成异步</strong>，这是因为前面设置了同步屏障，只有异步消息才会执行。我们看下mHandler的对这个消息的处理：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">class</span> <span class=\"title class_\">FrameHandler</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">Handler</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">FrameHandler</span><span class=\"params\">(Looper looper)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">super</span>(looper);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">handleMessage</span><span class=\"params\">(Message msg)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">switch</span> (msg.what) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> MSG_DO_FRAME:</span><br><span class=\"line\">                <span class=\"comment\">// 执行doFrame,即绘制过程</span></span><br><span class=\"line\">                doFrame(System.nanoTime(), <span class=\"number\">0</span>);</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> MSG_DO_SCHEDULE_VSYNC:</span><br><span class=\"line\">                <span class=\"comment\">//申请VSYNC信号，例如当前需要绘制任务时</span></span><br><span class=\"line\">                doScheduleVsync();</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> MSG_DO_SCHEDULE_CALLBACK:</span><br><span class=\"line\">                <span class=\"comment\">//需要延迟的任务，最终还是执行上述两个事件</span></span><br><span class=\"line\">                doScheduleCallback(msg.arg1);</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>直接使用doScheduleCallback方法，看看：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> <span class=\"title function_\">doScheduleCallback</span><span class=\"params\">(<span class=\"type\">int</span> callbackType)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (mLock) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!mFrameScheduled) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">final</span> <span class=\"type\">long</span> <span class=\"variable\">now</span> <span class=\"operator\">=</span> SystemClock.uptimeMillis();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (mCallbackQueues[callbackType].hasDueCallbacksLocked(now)) &#123;</span><br><span class=\"line\">                scheduleFrameLocked(now);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>发现也是走到这里，即延迟运行最终也会走到scheduleFrameLocked()，跟进看看：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">scheduleFrameLocked</span><span class=\"params\">(<span class=\"type\">long</span> now)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!mFrameScheduled) &#123;</span><br><span class=\"line\">        mFrameScheduled = <span class=\"literal\">true</span>;</span><br><span class=\"line\">        <span class=\"comment\">//开启了VSYNC</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (USE_VSYNC) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (DEBUG_FRAMES) &#123;</span><br><span class=\"line\">                Log.d(TAG, <span class=\"string\">&quot;Scheduling next frame on vsync.&quot;</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">//当前执行的线程，是否是mLooper所在线程</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (isRunningOnLooperThreadLocked()) &#123;</span><br><span class=\"line\">                <span class=\"comment\">//申请 VSYNC 信号</span></span><br><span class=\"line\">                scheduleVsyncLocked();</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 若不在，就用mHandler发送消息到原线程，最后还是调用scheduleVsyncLocked方法</span></span><br><span class=\"line\">                <span class=\"type\">Message</span> <span class=\"variable\">msg</span> <span class=\"operator\">=</span> mHandler.obtainMessage(MSG_DO_SCHEDULE_VSYNC);</span><br><span class=\"line\">                msg.setAsynchronous(<span class=\"literal\">true</span>);<span class=\"comment\">//异步</span></span><br><span class=\"line\">                mHandler.sendMessageAtFrontOfQueue(msg);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 如果未开启VSYNC则直接doFrame方法（4.1后默认开启）</span></span><br><span class=\"line\">            <span class=\"keyword\">final</span> <span class=\"type\">long</span> <span class=\"variable\">nextFrameTime</span> <span class=\"operator\">=</span> Math.max(</span><br><span class=\"line\">                    mLastFrameTimeNanos / TimeUtils.NANOS_PER_MS + sFrameDelay, now);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (DEBUG_FRAMES) &#123;</span><br><span class=\"line\">                Log.d(TAG, <span class=\"string\">&quot;Scheduling next frame in &quot;</span> + (nextFrameTime - now) + <span class=\"string\">&quot; ms.&quot;</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"type\">Message</span> <span class=\"variable\">msg</span> <span class=\"operator\">=</span> mHandler.obtainMessage(MSG_DO_FRAME);</span><br><span class=\"line\">            msg.setAsynchronous(<span class=\"literal\">true</span>);<span class=\"comment\">//异步</span></span><br><span class=\"line\">            mHandler.sendMessageAtTime(msg, nextFrameTime);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>如果系统未开启 VSYNC 机制，此时直接发送 MSG_DO_FRAME 消息到 FrameHandler。注意查看上面贴出的 FrameHandler 代码，此时直接执行 doFrame 方法。</li>\n<li>Android 4.1 之后系统默认开启 VSYNC，在 Choreographer 的构造方法会创建一个 FrameDisplayEventReceiver，scheduleVsyncLocked 方法将会通过它申请 VSYNC 信号。</li>\n<li>isRunningOnLooperThreadLocked 方法，其内部根据 Looper 判断是否在原线程，否则发送消息到 FrameHandler。最终还是会调用 scheduleVsyncLocked 方法申请 VSYNC 信号。</li>\n</ol>\n<p>到这里，<strong>FrameHandler的作用很明显里了：发送异步消息（因为前面设置了同步屏障）。有延迟的任务发延迟消息、不在原线程的发到原线程、没开启VSYNC的直接走 doFrame 方法取执行绘制。</strong></p>\n<h5 id=\"4-2-3-申请和接受VSync\"><a href=\"#4-2-3-申请和接受VSync\" class=\"headerlink\" title=\"4.2.3 申请和接受VSync\"></a><strong>4.2.3 申请和接受VSync</strong></h5><p>好了， 接着就看 scheduleVsyncLocked 方法是如何申请 VSYNC 信号的。猜测肯定申请 VSYNC 信号后，信号到来时也是走doFrame() 方法，doFrame()后面再看。先跟进scheduleVsyncLocked():</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">scheduleVsyncLocked</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    mDisplayEventReceiver.scheduleVsync();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>很简单，调用mDisplayEventReceiver的scheduleVsync()方法，mDisplayEventReceiver是Choreographer构造方法中创建，是FrameDisplayEventReceiver 的实例。FrameDisplayEventReceiver是 DisplayEventReceiver 的子类，DisplayEventReceiver 是一个 abstract class：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"title function_\">DisplayEventReceiver</span><span class=\"params\">(Looper looper, <span class=\"type\">int</span> vsyncSource)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (looper == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">IllegalArgumentException</span>(<span class=\"string\">&quot;looper must not be null&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    mMessageQueue = looper.getQueue();</span><br><span class=\"line\">    <span class=\"comment\">// 注册VSYNC信号监听者</span></span><br><span class=\"line\">    mReceiverPtr = nativeInit(<span class=\"keyword\">new</span> <span class=\"title class_\">WeakReference</span>&lt;DisplayEventReceiver&gt;(<span class=\"built_in\">this</span>), mMessageQueue,</span><br><span class=\"line\">            vsyncSource);</span><br><span class=\"line\"></span><br><span class=\"line\">    mCloseGuard.open(<span class=\"string\">&quot;dispose&quot;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在 DisplayEventReceiver 的构造方法会通过 JNI 创建一个 IDisplayEventConnection 的 VSYNC 的监听者。</p>\n<p>FrameDisplayEventReceiver的scheduleVsync()就是在 DisplayEventReceiver中：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">scheduleVsync</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mReceiverPtr == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        Log.w(TAG, <span class=\"string\">&quot;Attempted to schedule a vertical sync pulse but the display event &quot;</span></span><br><span class=\"line\">                + <span class=\"string\">&quot;receiver has already been disposed.&quot;</span>);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 申请VSYNC中断信号，会回调onVsync方法</span></span><br><span class=\"line\">        nativeScheduleVsync(mReceiverPtr);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>那么scheduleVsync()就是使用native方法nativeScheduleVsync()去申请VSYNC信号。这个native方法就看不了了，只需要知道<strong>VSYNC信号的接受回调是onVsync()</strong>，我们直接看onVsync()：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 接收到VSync脉冲时 回调</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> timestampNanos VSync脉冲的时间戳</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> physicalDisplayId Stable display ID that uniquely describes a (display, port) pair.</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> frame 帧号码，自增</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"meta\">@UnsupportedAppUsage</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">onVsync</span><span class=\"params\">(<span class=\"type\">long</span> timestampNanos, <span class=\"type\">long</span> physicalDisplayId, <span class=\"type\">int</span> frame)</span> &#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>具体实现是在FrameDisplayEventReceiver中：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">class</span> <span class=\"title class_\">FrameDisplayEventReceiver</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">DisplayEventReceiver</span></span><br><span class=\"line\">        <span class=\"keyword\">implements</span> <span class=\"title class_\">Runnable</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">boolean</span> mHavePendingVsync;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">long</span> mTimestampNanos;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">int</span> mFrame;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">FrameDisplayEventReceiver</span><span class=\"params\">(Looper looper, <span class=\"type\">int</span> vsyncSource)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">super</span>(looper, vsyncSource);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">onVsync</span><span class=\"params\">(<span class=\"type\">long</span> timestampNanos, <span class=\"type\">long</span> physicalDisplayId, <span class=\"type\">int</span> frame)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// Post the vsync event to the Handler.</span></span><br><span class=\"line\">        <span class=\"comment\">// The idea is to prevent incoming vsync events from completely starving</span></span><br><span class=\"line\">        <span class=\"comment\">// the message queue.  If there are no messages in the queue with timestamps</span></span><br><span class=\"line\">        <span class=\"comment\">// earlier than the frame time, then the vsync event will be processed immediately.</span></span><br><span class=\"line\">        <span class=\"comment\">// Otherwise, messages that predate the vsync event will be handled first.</span></span><br><span class=\"line\">        <span class=\"type\">long</span> <span class=\"variable\">now</span> <span class=\"operator\">=</span> System.nanoTime();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (timestampNanos &gt; now) &#123;</span><br><span class=\"line\">            Log.w(TAG, <span class=\"string\">&quot;Frame time is &quot;</span> + ((timestampNanos - now) * <span class=\"number\">0.000001f</span>)</span><br><span class=\"line\">                    + <span class=\"string\">&quot; ms in the future!  Check that graphics HAL is generating vsync &quot;</span></span><br><span class=\"line\">                    + <span class=\"string\">&quot;timestamps using the correct timebase.&quot;</span>);</span><br><span class=\"line\">            timestampNanos = now;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mHavePendingVsync) &#123;</span><br><span class=\"line\">            Log.w(TAG, <span class=\"string\">&quot;Already have a pending vsync event.  There should only be &quot;</span></span><br><span class=\"line\">                    + <span class=\"string\">&quot;one at a time.&quot;</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            mHavePendingVsync = <span class=\"literal\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        mTimestampNanos = timestampNanos;</span><br><span class=\"line\">        mFrame = frame;</span><br><span class=\"line\">        <span class=\"comment\">//将本身作为runnable传入msg， 发消息后 会走run()，即doFrame()，也是异步消息</span></span><br><span class=\"line\">        <span class=\"type\">Message</span> <span class=\"variable\">msg</span> <span class=\"operator\">=</span> Message.obtain(mHandler, <span class=\"built_in\">this</span>);</span><br><span class=\"line\">        msg.setAsynchronous(<span class=\"literal\">true</span>);</span><br><span class=\"line\">        mHandler.sendMessageAtTime(msg, timestampNanos / TimeUtils.NANOS_PER_MS);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        mHavePendingVsync = <span class=\"literal\">false</span>;</span><br><span class=\"line\">        doFrame(mTimestampNanos, mFrame);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>onVsync()中，将接收器本身作为runnable传入异步消息msg，并使用mHandler发送msg，最终执行的就是doFrame()方法了。</p>\n<p>注意一点是，<strong>onVsync()方法中只是使用mHandler发送消息到MessageQueue中，不一定是立刻执行，如何MessageQueue中前面有较为耗时的操作，那么就要等完成，才会执行本次的doFrame()</strong>。</p>\n<h5 id=\"4-2-4-doFrame\"><a href=\"#4-2-4-doFrame\" class=\"headerlink\" title=\"4.2.4 doFrame\"></a><strong>4.2.4 doFrame</strong></h5><p>和上面猜测一样，申请VSync信号接收到后确实是走 doFrame()方法，那么就来看看Choreographer的doFrame()：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> <span class=\"title function_\">doFrame</span><span class=\"params\">(<span class=\"type\">long</span> frameTimeNanos, <span class=\"type\">int</span> frame)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"type\">long</span> startNanos;</span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (mLock) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!mFrameScheduled) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span>; <span class=\"comment\">// no work to do</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        ...</span><br><span class=\"line\">        <span class=\"comment\">// 预期执行时间</span></span><br><span class=\"line\">        <span class=\"type\">long</span> <span class=\"variable\">intendedFrameTimeNanos</span> <span class=\"operator\">=</span> frameTimeNanos;</span><br><span class=\"line\">        startNanos = System.nanoTime();</span><br><span class=\"line\">        <span class=\"comment\">// 超时时间是否超过一帧的时间（这是因为MessageQueue虽然添加了同步屏障，但是还是有正在执行的同步任务，导致doFrame延迟执行了）</span></span><br><span class=\"line\">        <span class=\"keyword\">final</span> <span class=\"type\">long</span> <span class=\"variable\">jitterNanos</span> <span class=\"operator\">=</span> startNanos - frameTimeNanos;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (jitterNanos &gt;= mFrameIntervalNanos) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 计算掉帧数</span></span><br><span class=\"line\">            <span class=\"keyword\">final</span> <span class=\"type\">long</span> <span class=\"variable\">skippedFrames</span> <span class=\"operator\">=</span> jitterNanos / mFrameIntervalNanos;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (skippedFrames &gt;= SKIPPED_FRAME_WARNING_LIMIT) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 掉帧超过30帧打印Log提示</span></span><br><span class=\"line\">                Log.i(TAG, <span class=\"string\">&quot;Skipped &quot;</span> + skippedFrames + <span class=\"string\">&quot; frames!  &quot;</span></span><br><span class=\"line\">                        + <span class=\"string\">&quot;The application may be doing too much work on its main thread.&quot;</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">final</span> <span class=\"type\">long</span> <span class=\"variable\">lastFrameOffset</span> <span class=\"operator\">=</span> jitterNanos % mFrameIntervalNanos;</span><br><span class=\"line\">            ...</span><br><span class=\"line\">            frameTimeNanos = startNanos - lastFrameOffset;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        ...</span><br><span class=\"line\"></span><br><span class=\"line\">        mFrameInfo.setVsync(intendedFrameTimeNanos, frameTimeNanos);</span><br><span class=\"line\">        <span class=\"comment\">// Frame标志位恢复</span></span><br><span class=\"line\">        mFrameScheduled = <span class=\"literal\">false</span>;</span><br><span class=\"line\">        <span class=\"comment\">// 记录最后一帧时间</span></span><br><span class=\"line\">        mLastFrameTimeNanos = frameTimeNanos;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 按类型顺序 执行任务</span></span><br><span class=\"line\">        Trace.traceBegin(Trace.TRACE_TAG_VIEW, <span class=\"string\">&quot;Choreographer#doFrame&quot;</span>);</span><br><span class=\"line\">        AnimationUtils.lockAnimationClock(frameTimeNanos / TimeUtils.NANOS_PER_MS);</span><br><span class=\"line\"></span><br><span class=\"line\">        mFrameInfo.markInputHandlingStart();</span><br><span class=\"line\">        doCallbacks(Choreographer.CALLBACK_INPUT, frameTimeNanos);</span><br><span class=\"line\"></span><br><span class=\"line\">        mFrameInfo.markAnimationsStart();</span><br><span class=\"line\">        doCallbacks(Choreographer.CALLBACK_ANIMATION, frameTimeNanos);</span><br><span class=\"line\">        doCallbacks(Choreographer.CALLBACK_INSETS_ANIMATION, frameTimeNanos);</span><br><span class=\"line\"></span><br><span class=\"line\">        mFrameInfo.markPerformTraversalsStart();</span><br><span class=\"line\">        doCallbacks(Choreographer.CALLBACK_TRAVERSAL, frameTimeNanos);</span><br><span class=\"line\"></span><br><span class=\"line\">        doCallbacks(Choreographer.CALLBACK_COMMIT, frameTimeNanos);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        AnimationUtils.unlockAnimationClock();</span><br><span class=\"line\">        Trace.traceEnd(Trace.TRACE_TAG_VIEW);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面都有注释了很好理解，接着看任务的具体执行doCallbacks 方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> <span class=\"title function_\">doCallbacks</span><span class=\"params\">(<span class=\"type\">int</span> callbackType, <span class=\"type\">long</span> frameTimeNanos)</span> &#123;</span><br><span class=\"line\">    CallbackRecord callbacks;</span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (mLock) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">final</span> <span class=\"type\">long</span> <span class=\"variable\">now</span> <span class=\"operator\">=</span> System.nanoTime();</span><br><span class=\"line\">        <span class=\"comment\">// 根据指定的类型CallbackkQueue中查找到达执行时间的CallbackRecord</span></span><br><span class=\"line\">        callbacks = mCallbackQueues[callbackType].extractDueCallbacksLocked(now / TimeUtils.NANOS_PER_MS);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (callbacks == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        mCallbacksRunning = <span class=\"literal\">true</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//提交任务类型</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (callbackType == Choreographer.CALLBACK_COMMIT) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">final</span> <span class=\"type\">long</span> <span class=\"variable\">jitterNanos</span> <span class=\"operator\">=</span> now - frameTimeNanos;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (jitterNanos &gt;= <span class=\"number\">2</span> * mFrameIntervalNanos) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">final</span> <span class=\"type\">long</span> <span class=\"variable\">lastFrameOffset</span> <span class=\"operator\">=</span> jitterNanos % mFrameIntervalNanos</span><br><span class=\"line\">                        + mFrameIntervalNanos;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (DEBUG_JANK) &#123;</span><br><span class=\"line\">                    Log.d(TAG, <span class=\"string\">&quot;Commit callback delayed by &quot;</span> + (jitterNanos * <span class=\"number\">0.000001f</span>)</span><br><span class=\"line\">                            + <span class=\"string\">&quot; ms which is more than twice the frame interval of &quot;</span></span><br><span class=\"line\">                            + (mFrameIntervalNanos * <span class=\"number\">0.000001f</span>) + <span class=\"string\">&quot; ms!  &quot;</span></span><br><span class=\"line\">                            + <span class=\"string\">&quot;Setting frame time to &quot;</span> + (lastFrameOffset * <span class=\"number\">0.000001f</span>)</span><br><span class=\"line\">                            + <span class=\"string\">&quot; ms in the past.&quot;</span>);</span><br><span class=\"line\">                    mDebugPrintNextFrameTimeDelta = <span class=\"literal\">true</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                frameTimeNanos = now - lastFrameOffset;</span><br><span class=\"line\">                mLastFrameTimeNanos = frameTimeNanos;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 迭代执行队列所有任务</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">CallbackRecord</span> <span class=\"variable\">c</span> <span class=\"operator\">=</span> callbacks; c != <span class=\"literal\">null</span>; c = c.next) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 回调CallbackRecord的run，其内部回调Callback的run</span></span><br><span class=\"line\">            c.run(frameTimeNanos);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span> (mLock) &#123;</span><br><span class=\"line\">            mCallbacksRunning = <span class=\"literal\">false</span>;</span><br><span class=\"line\">            <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">final</span> <span class=\"type\">CallbackRecord</span> <span class=\"variable\">next</span> <span class=\"operator\">=</span> callbacks.next;</span><br><span class=\"line\">                <span class=\"comment\">//回收CallbackRecord</span></span><br><span class=\"line\">                recycleCallbackLocked(callbacks);</span><br><span class=\"line\">                callbacks = next;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">while</span> (callbacks != <span class=\"literal\">null</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>主要内容就是取对应任务类型的队列，遍历队列执行所有任务，执行任务是 CallbackRecord的 run 方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">class</span> <span class=\"title class_\">CallbackRecord</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> CallbackRecord next;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">long</span> dueTime;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> Object action; <span class=\"comment\">// Runnable or FrameCallback</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Object token;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@UnsupportedAppUsage</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">(<span class=\"type\">long</span> frameTimeNanos)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (token == FRAME_CALLBACK_TOKEN) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 通过postFrameCallback 或 postFrameCallbackDelayed，会执行这里</span></span><br><span class=\"line\">            ((FrameCallback)action).doFrame(frameTimeNanos);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">//取出Runnable执行run()</span></span><br><span class=\"line\">            ((Runnable)action).run();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>前面看到mChoreographer.postCallback传的token是null，所以取出action，就是Runnable，执行run()，这里的action就是 ViewRootImpl 发起的绘制任务mTraversalRunnable了，那么<strong>这样整个逻辑就闭环了</strong>。</p>\n<p>那么 啥时候 token &#x3D;&#x3D; FRAME_CALLBACK_TOKEN 呢？答案是Choreographer的postFrameCallback()方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">postFrameCallback</span><span class=\"params\">(FrameCallback callback)</span> &#123;</span><br><span class=\"line\">    postFrameCallbackDelayed(callback, <span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">postFrameCallbackDelayed</span><span class=\"params\">(FrameCallback callback, <span class=\"type\">long</span> delayMillis)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (callback == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">IllegalArgumentException</span>(<span class=\"string\">&quot;callback must not be null&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//也是走到是postCallbackDelayedInternal，并且注意是CALLBACK_ANIMATION类型，</span></span><br><span class=\"line\">    <span class=\"comment\">//token是FRAME_CALLBACK_TOKEN，action就是FrameCallback</span></span><br><span class=\"line\">    postCallbackDelayedInternal(CALLBACK_ANIMATION,</span><br><span class=\"line\">            callback, FRAME_CALLBACK_TOKEN, delayMillis);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">FrameCallback</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">doFrame</span><span class=\"params\">(<span class=\"type\">long</span> frameTimeNanos)</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可以看到postFrameCallback()传入的是FrameCallback实例，接口FrameCallback只有一个doFrame()方法。并且也是走到postCallbackDelayedInternal，FrameCallback实例作为action传入，token则是FRAME_CALLBACK_TOKEN，并且任务是CALLBACK_ANIMATION类型。</p>\n<p><strong>Choreographer的postFrameCallback()通常用来计算丢帧情况</strong>，使用方式如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">      <span class=\"comment\">//Application.java</span></span><br><span class=\"line\">       <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">onCreate</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">           <span class=\"built_in\">super</span>.onCreate();</span><br><span class=\"line\">           <span class=\"comment\">//在Application中使用postFrameCallback</span></span><br><span class=\"line\">           Choreographer.getInstance().postFrameCallback(<span class=\"keyword\">new</span> <span class=\"title class_\">FPSFrameCallback</span>(System.nanoTime()));</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">FPSFrameCallback</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Choreographer</span>.FrameCallback &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">String</span> <span class=\"variable\">TAG</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;FPS_TEST&quot;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">long</span> <span class=\"variable\">mLastFrameTimeNanos</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">long</span> mFrameIntervalNanos;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">FPSFrameCallback</span><span class=\"params\">(<span class=\"type\">long</span> lastFrameTimeNanos)</span> &#123;</span><br><span class=\"line\">        mLastFrameTimeNanos = lastFrameTimeNanos;</span><br><span class=\"line\">        mFrameIntervalNanos = (<span class=\"type\">long</span>)(<span class=\"number\">1000000000</span> / <span class=\"number\">60.0</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">doFrame</span><span class=\"params\">(<span class=\"type\">long</span> frameTimeNanos)</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//初始化时间</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mLastFrameTimeNanos == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            mLastFrameTimeNanos = frameTimeNanos;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> <span class=\"type\">long</span> <span class=\"variable\">jitterNanos</span> <span class=\"operator\">=</span> frameTimeNanos - mLastFrameTimeNanos;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (jitterNanos &gt;= mFrameIntervalNanos) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">final</span> <span class=\"type\">long</span> <span class=\"variable\">skippedFrames</span> <span class=\"operator\">=</span> jitterNanos / mFrameIntervalNanos;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(skippedFrames&gt;<span class=\"number\">30</span>)&#123;</span><br><span class=\"line\">                <span class=\"comment\">//丢帧30以上打印日志</span></span><br><span class=\"line\">                Log.i(TAG, <span class=\"string\">&quot;Skipped &quot;</span> + skippedFrames + <span class=\"string\">&quot; frames!  &quot;</span></span><br><span class=\"line\">                        + <span class=\"string\">&quot;The application may be doing too much work on its main thread.&quot;</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        mLastFrameTimeNanos=frameTimeNanos;</span><br><span class=\"line\">        <span class=\"comment\">//注册下一帧回调</span></span><br><span class=\"line\">        Choreographer.getInstance().postFrameCallback(<span class=\"built_in\">this</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"4-2-5-小结\"><a href=\"#4-2-5-小结\" class=\"headerlink\" title=\"4.2.5 小结\"></a><strong>4.2.5 小结</strong></h5><p>使用Choreographer的postCallback()、postFrameCallback() 作用理解：发送任务 存队列中，监听VSync信号，当前VSync到来时 会使用mHandler发送异步message，这个message的Runnable就是队列中的所有任务。</p>\n<p>好了，Choreographer整个代码逻辑都讲完了，引用《Android 之 Choreographer 详细分析》的流程图：</p>\n<p>原文流程图为：<a href=\"https://i-blog.csdnimg.cn/blog_migrate/5ff22e98afde4ff780f8a291d1081619.png\">Android 之 Choreographer</a>，但并不是很形象，引用另一张流程图：</p>\n<img src=\"https://cdn.julis.wang/blog/img/aab4273a0af898dcc9bb0fdcc0447b5a.png\">\n<h2 id=\"六、疑问解答\"><a href=\"#六、疑问解答\" class=\"headerlink\" title=\"六、疑问解答\"></a><strong>六、疑问解答</strong></h2><ol>\n<li><strong>丢帧</strong>(掉帧) ，是说 这一帧延迟显示 还是丢弃不再显示 ？ 答：延迟显示，因为缓存交换的时机只能等下一个VSync了。</li>\n<li>布局层级较多&#x2F;主线程耗时 是如何造成 丢帧的呢？ 答：布局层级较多&#x2F;主线程耗时 会影响CPU&#x2F;GPU的执行时间，大于16.6ms时只能等下一个VSync了。</li>\n<li>16.6ms刷新一次 是啥意思？是每16.6ms都走一次 measure&#x2F;layout&#x2F;draw ？ 答：屏幕的固定刷新频率是60Hz，即16.6ms。不是每16.6ms都走一次 measure&#x2F;layout&#x2F;draw，而是有绘制任务才会走，并且绘制时间间隔是取决于布局复杂度及主线程耗时。</li>\n<li>measure&#x2F;layout&#x2F;draw 走完，界面就立刻刷新了吗? 答：不是。measure&#x2F;layout&#x2F;draw 走完后 会在VSync到来时进行缓存交换和刷新。</li>\n<li>如果界面没动静止了，还会刷新吗？ 答：屏幕会固定没16.6ms刷新，但CPU&#x2F;GPU不走绘制流程。见下面的SysTrace图。</li>\n<li>可能你知道<strong>VSYNC</strong>，这个具体指啥？在屏幕刷新中如何工作的？ 答：当扫描完一个屏幕后，设备需要重新回到第一行以进入下一次的循环，此时会出现的vertical sync pulse（垂直同步脉冲）来保证双缓冲在最佳时间点才进行交换。并且Android4.1后 CPU&#x2F;GPU的绘制是在VSYNC到来时开始。</li>\n<li>可能你还听过屏幕刷新使用 <strong>双缓存</strong>、<strong>三缓存</strong>，这又是啥意思呢？ 答：双缓存是Back buffer、Frame buffer，用于解决画面撕裂。三缓存增加一个Back buffer，用于减少Jank。</li>\n<li>可能你还听过神秘的<strong>Choreographer</strong>，这又是干啥的？ 答：用于实现——“CPU&#x2F;GPU的绘制是在VSYNC到来时开始”。</li>\n</ol>\n","categories":[{"name":"技术文章","slug":"technology","api":"api/categories/technology.json"}],"tags":[{"name":"安卓","slug":"Android","api":"api/tags/Android.json"}],"api":"api/posts/2025/02/24/Android屏幕刷新机制.json"}],"info":{"type":"archive","year":2025}},"api":"api/archives/2025/page.1.json"}