{"data":{"index":1,"total":1,"posts":[{"title":"KV-存储之mmkv","slug":"KV-存储之mmkv","date":"2025-03-30T03:38:00.000Z","updated":"2025-05-20T11:46:57.000Z","comments":true,"url":"2025/03/30/KV-存储之mmkv/","excerpt":"<p>在平时的业务中，需要用到轻量级存储业务中的数据（例如设置数据存储），绝大多数时候 Anroid 管法提供的 <a href=\"https://developer.android.com/reference/android/content/SharedPreferences\">SharedPreferences</a>  组件就能实现，但针对一些需要高效的场景它就不那么使用了，不适合存储大量数据、多线程操作的不安全性、数据明文不安全性，以及不支持多进程之间的调用等各种问题。<br><a href=\"https://github.com/Tencent/MMKV\">MMKV</a>的诞生就是为了解决以上的问题，本文主要对 MMKV 源码的学习知识点进行一些总结。</p>\n<h2 id=\"核心设计与原理\"><a href=\"#核心设计与原理\" class=\"headerlink\" title=\"核心设计与原理\"></a>核心设计与原理</h2><p>在官方的开源工程中可以看到如下的一些介绍</p>\n<blockquote>\n<p>MMKV 是基于 mmap 内存映射的 key-value 组件，底层序列化/反序列化使用 protobuf 实现，性能高，稳定性强。从 2015 年中至今在微信上使用，其性能和稳定性经过了时间的验证。</p>\n</blockquote>\n<h3 id=\"传统I-O与-mmap\"><a href=\"#传统I-O与-mmap\" class=\"headerlink\" title=\"传统I/O与 mmap\"></a>传统I/O与 mmap</h3><p>mmap 这个是 mmkv 实现的核心，没有 mmap 那么就没有 mmkv。对于 <code>SharedPreferences</code>的实现来说，每次的数据更新都将操作本地文件，而本地文件的写入是通过传统的I/O实现。要理解两者的实现差异，需要先理解 Linux <strong>用户空间与内核空间</strong>设计。</p>\n<h4 id=\"用户空间与内核空间\"><a href=\"#用户空间与内核空间\" class=\"headerlink\" title=\"用户空间与内核空间\"></a><strong>用户空间与内核空间</strong></h4><p>Linux的进程是相互独立的，一个进程是不能直接操作或者访问别一个进程空间的。每个进程空间还分为用户空间和内核（Kernel）空间，相当于把Kernel和上层的应用程序抽像的隔离开。</p>\n<p><strong>用户空间</strong>和<strong>内核空间</strong>，用户空间是用户程序代码运行的地方，内核空间是内核代码运行的地方。为了安全，它们是隔离的，即使用户的程序崩溃了，内核也不受影响。</p>\n<p>这里有两个隔离，一个进程间是相互隔离的，二是进程内有用户空间和内核空间的隔离。</p>\n<p>进程间，用户空间的数据不可共享，所以用户空间 = 不可共享空间<br>进程间，内核空间的数据可共享，所以内核空间 = 可共享空间，所以Linux系统的内存通常是MemFree+Cache<br>所有进程共用1个内核空间。</p>\n<h4 id=\"传统I-O读写流程\"><a href=\"#传统I-O读写流程\" class=\"headerlink\" title=\"传统I/O读写流程\"></a><strong>传统I/O读写流程</strong></h4><p>常规文件读写操作（调用read/fread等函数）过程如下：</p>\n<ul>\n<li><p>进程发起读写文件请求。</p>\n</li>\n<li><p>内核通过查找进程文件符表，定位到内核已打开文件集上的文件信息，从而找到此文件的<code>inode</code>。</p>\n</li>\n<li><p><code>inode</code> 在 <code>address_space</code> 上查找要请求的文件页是否已经缓存在页缓存中。如果存在，则直接返回这片文件页的内容。</p>\n</li>\n<li><p>如果不存在，则通过 <code>inode</code> 定位到文件磁盘地址，将数据从磁盘复制到页缓存。之后再次发起读页面过程，进而将页缓存中的数据发给用户进程。</p>\n<blockquote>\n<p><strong>什么是 inode</strong> ?</p>\n<p>全称为 index node，既<strong>存储文件元信息的区域</strong>，中文译名“索引节点”。<br>包含：文件权限、文件拥有者的UID、文件的大小等等。</p>\n<img src=\"https://cdn.julis.wang/blog/img/ee519ba873acf3f80fd4ccec86ed72e7.png\">\n</blockquote>\n</li>\n</ul>\n<p>总结来说，常规文件操作为了提高读写效率和保护磁盘，使用了页缓存机制。这样造成读文件时需要先将文件页从磁盘拷贝到页缓存中，由于页缓存处在内核空间，不能被用户进程直接寻址访问，所以还需要将页缓存中的数据页再次拷贝到用户空间中。这样，通过了两次数据拷贝过程，才能完成<strong>进程</strong>对<strong>文件</strong>内容的访问。</p>\n<h4 id=\"mmap基本概念和原理\"><a href=\"#mmap基本概念和原理\" class=\"headerlink\" title=\"mmap基本概念和原理\"></a><strong>mmap基本概念和原理</strong></h4><p>内存映射（mmap），就是<strong>将文件的磁盘扇区映射到进程的虚拟内存空间</strong>的过程，即将一个文件映射到进程的虚拟空间，实现文件磁盘地址和进程虚拟空间中一段虚拟地址的一一对应关系。实现这样的映射关系后，进程就可以采用指针的方式读写操作这一段内存，而系统会自动回写脏页面到对应的文件磁盘上，即完成了对文件的操作而不必再调用read,write等系统调用函数。</p>\n<img src=\"https://cdn.julis.wang/blog/img/mmap_1.png\">\n<p>由上图可知，进程的虚拟地址空间，由多个虚拟内存区域构成。每个虚拟内存区域都是进程在虚拟地址空间中的一个同质区间，即具有同样特性的连续地址范围。上图中所示的text数据段（代码段）、初始数据段、BSS数据段、堆、栈和内存映射，都是一个独立的虚拟内存区域。内存映射的地址空间处在堆栈之间的空余部分。</p>\n<p>linux内核使用 <code>vm_area_struc</code>t 结构来表示一个独立的虚拟内存区域，由于每个不同质的虚拟内存区域功能和内部机制都不同，因此一个进程使用多个 <code>vm_area_struct</code> 结构来分别表示不同类型的虚拟内存区域。各个 <code>vm_area_struct</code> 结构使用链表或者树形结构链接，方便进程快速访问，如下图所示：</p>\n<img src=\"https://cdn.julis.wang/blog/img/mmap_2_1.png\">\n<p><code>vm_area_struct</code> 结构中包含区域起始和终止地址以及其他相关信息。这样，进程对某一虚拟内存区域的任何操作需要用要的信息，都可以从 <code>vm_area_struct</code> 中获得。mmap函数就是要创建一个新的 <code>vm_area_struct</code> 结构，并将其与文件的物理磁盘地址相连。</p>\n<p>mmap内存映射的实现过程，总的来说可以分为三个阶段：</p>\n<p><strong>阶段一：进程启动映射过程，并在虚拟地址空间中为映射创建虚拟映射区域</strong></p>\n<ul>\n<li>进程在用户空间调用mmap库函数</li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> *<span class=\"title\">mmap</span><span class=\"params\">(<span class=\"type\">void</span> *addr, <span class=\"type\">size_t</span> length, <span class=\"type\">int</span> prot, <span class=\"type\">int</span> flags, <span class=\"type\">int</span> fd, <span class=\"type\">off_t</span> offset)</span></span>;</span><br></pre></td></tr></table></figure>\n<p><code>addr</code>：指定映射的虚拟内存地址，可以设置为 NULL，让内核自动选择合适的虚拟内存地址</p>\n<p><code>length</code>：映射的长度。</p>\n<p><code>prot</code>：映射内存的保护模式，可选值如下：  </p>\n<p><code>flags</code>：指定映射的类型</p>\n<p><code>fd</code>：进行映射的文件句柄。</p>\n<p><code>offset</code>：文件偏移量（从文件的何处开始映射）</p>\n<ul>\n<li><p>在当前进程的虚拟地址空间中，寻找一段空闲的满足要求的连续的虚拟地址</p>\n</li>\n<li><p>为此虚拟区分配一个 <code>vm_area_struct</code> 结构，接着对这个结构的各个域进行了初始化</p>\n</li>\n<li><p>将新创建的虚拟区结构 <code>vm_area_struct</code> 对象插入到进程的虚拟地址区域链表/树中</p>\n</li>\n</ul>\n<p><strong>阶段二：调用内核空间的mmap函数（不同于用户空间函数），实现文件物理地址和进程虚拟地址的一一映射关系</strong></p>\n<ul>\n<li>为映射分配了新的虚拟地址区域后，通过待映射的文件指针，在文件描述符表中找到对应的文件描述符，通过文件描述符，链接到内核“已打开文件集”中该文件的文件结构体（struct file），每个文件结构体维护着和这个已打开文件相关各项信息。</li>\n<li><p>为映射分配了新的虚拟地址区域后，通过待映射的文件指针，在文件描述符表中找到对应的文件描述符，通过文件描述符，链接到内核“已打开文件集”中该文件的文件结构体（struct file），每个文件结构体维护着和这个已打开文件相关各项信息。</p>\n</li>\n<li><p>通过该文件的文件结构体，链接到 <code>file_operations</code> 模块，调用内核mmap函数，其原型为：</p>\n</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">int mmap(struct file *filp, struct vm_area_struct *vma) //不同于用户空间mmap库函数</span><br></pre></td></tr></table></figure>\n<ul>\n<li><p>内核mmap函数通过虚拟文件系统inode模块定位到文件磁盘物理地址。</p>\n</li>\n<li><p>通过 <code>remap_pfn_range</code> 函数建立页表，即实现了文件地址和虚拟地址区域的映射关系。此时，这片虚拟地址并没有任何数据关联到物理内存(主存)中。</p>\n</li>\n</ul>\n<blockquote>\n<p>主存</p>\n<p>主存储器（Main memory），简称主存。是计算机硬件的一个重要部件，其作用是存放指令和数据，并能由中央处理器（CPU）直接随机存取</p>\n</blockquote>\n<p><strong>阶段三：进程发起对这片映射地址空间的访问，引发缺页异常，实现文件内容到主存（物理内存）的拷贝</strong></p>\n<blockquote>\n<p>前两个阶段仅在于创建虚拟区间并完成地址映射，但是并没有将任何文件数据的拷贝至主存。真正的文件读取是当进程发起读或写操作时</p>\n</blockquote>\n<ul>\n<li><p>进程的读或写操作访问虚拟地址空间这一段映射地址，通过查询页表，发现这一段地址并不在物理页上。因为目前只建立了地址映射，真正的硬盘数据还没有拷贝到内存中，因此引发缺页异常。</p>\n</li>\n<li><p>缺页异常进行一系列判断，确定无非法操作后，内核发起请求调页过程。</p>\n</li>\n<li><p>调页过程先在交换缓存空间（swap cache）中寻找需要访问的内存页，如果没有则调用nopage函数把所缺的页从磁盘装入到主存中。</p>\n</li>\n<li><p>之后进程即可对这片主存进行读或者写的操作，如果写操作改变了其内容，一定时间后系统会自动回写脏页面到对应磁盘地址，也即完成了写入到文件的过程。</p>\n</li>\n</ul>\n<blockquote>\n<p>修改过的脏页面并不会立即更新回文件中，而是有一段时间的延迟，可以调用<code>msync()</code>来强制同步, 这样所写的内容就能立即保存到文件里了</p>\n</blockquote>\n<p>常规文件操作需要从磁盘到内核空间页缓存再到用户空间主存的两次数据拷贝。而mmap文件映射，只需要从磁盘到用户空间主存的一次数据拷贝过程。mmap的关键点是实现了用户空间和内核空间的数据直接交互而省去了空间不同数据不通的繁琐过程，因此 mmap 效率更高。</p>\n<p>以上是 mmap 的基本概念和原理，搞明白了这些才能看明白整个 mmkv 里面的逻辑处理</p>\n<h3 id=\"mmkv-一次-put-的流程\"><a href=\"#mmkv-一次-put-的流程\" class=\"headerlink\" title=\"mmkv 一次 put 的流程\"></a>mmkv 一次 put 的流程</h3><p>mmkv初始化比较简单，主要涉及到一些配置的初始化，文件夹创建等，其中最重要的逻辑 mmap 调用被封装到一个 <code>MemoryFile</code>到对象里面 </p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">MemoryFile::mmap</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">auto</span> oldPtr = m_ptr;</span><br><span class=\"line\">    <span class=\"keyword\">auto</span> mode = m_readOnly ? PROT_READ : (PROT_READ | PROT_WRITE);</span><br><span class=\"line\">    m_ptr = (<span class=\"type\">char</span> *) ::<span class=\"built_in\">mmap</span>(m_ptr, m_size, mode, MAP_SHARED, m_diskFile.m_fd, <span class=\"number\">0</span>);</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>主要记录一下一次 put 任务的流程，以 <code>mmkv.putInt(&quot;int&quot;, 1)</code>为例，进过 JNI 的调用到了</p>\n<p><strong>native-birdge.cpp</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">MMKV_JNI jboolean <span class=\"title\">encodeInt</span><span class=\"params\">(JNIEnv *env, jobject obj, jlong handle, jstring oKey, jint value)</span> </span>&#123;</span><br><span class=\"line\">    MMKV *kv = <span class=\"built_in\">reinterpret_cast</span>&lt;MMKV *&gt;(handle);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (kv &amp;&amp; oKey) &#123;</span><br><span class=\"line\">        string key = <span class=\"built_in\">jstring2string</span>(env, oKey);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (jboolean) kv-&gt;<span class=\"built_in\">set</span>((<span class=\"type\">int32_t</span>) value, key);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (jboolean) <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>进入了<strong>MMVK.cpp</strong>的 </p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">MMKV::set</span><span class=\"params\">(<span class=\"type\">int32_t</span> value, MMKVKey_t key, <span class=\"type\">uint32_t</span> expireDuration)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">isKeyEmpty</span>(key)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"type\">size_t</span> size = <span class=\"built_in\">mmkv_unlikely</span>(m_enableKeyExpire) ? Fixed32Size + <span class=\"built_in\">pbInt32Size</span>(value) : <span class=\"built_in\">pbInt32Size</span>(value);</span><br><span class=\"line\">    <span class=\"function\">MMBuffer <span class=\"title\">data</span><span class=\"params\">(size)</span></span>;</span><br><span class=\"line\">    <span class=\"function\">CodedOutputData <span class=\"title\">output</span><span class=\"params\">(data.getPtr(), size)</span></span>;</span><br><span class=\"line\">    output.<span class=\"built_in\">writeInt32</span>(value);</span><br><span class=\"line\">    <span class=\"comment\">// ... 省略一些校验逻辑</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">setDataForKey</span>(std::<span class=\"built_in\">move</span>(data), key);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这一步主要是准备一下数据，并使用 <code>MMBuffer</code> <code>CodedOutputData</code>将写入的数据进行一次包装（不仅仅是 key-value，还有数据size等等），实际调用在<code>setDataForKey</code></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">MMKV::setDataForKey</span><span class=\"params\">(MMBuffer &amp;&amp;data, MMKVKey_t key, <span class=\"type\">bool</span> isDataHolder)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">checkLoadData</span>(); <span class=\"comment\">// 状态同步相关的逻辑</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (m_crypter) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// ... 省略加密的处理逻辑</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">auto</span> itr = m_dic-&gt;<span class=\"built_in\">find</span>(key);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (itr != m_dic-&gt;<span class=\"built_in\">end</span>()) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// compare data before appending to file</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (<span class=\"built_in\">isCompareBeforeSetEnabled</span>()) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">auto</span> basePtr = (<span class=\"type\">uint8_t</span> *) (m_file-&gt;<span class=\"built_in\">getMemory</span>()) + Fixed32Size;</span><br><span class=\"line\">                MMBuffer oldValueData = itr-&gt;second.<span class=\"built_in\">toMMBuffer</span>(basePtr);</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (isDataHolder) &#123;</span><br><span class=\"line\">                    <span class=\"function\">CodedInputData <span class=\"title\">inputData</span><span class=\"params\">(oldValueData.getPtr(), oldValueData.length())</span></span>;</span><br><span class=\"line\">                    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                        <span class=\"comment\">// read extra holder header bytes and to real MMBuffer</span></span><br><span class=\"line\">                        oldValueData = CodedInputData::<span class=\"built_in\">readRealData</span>(oldValueData);</span><br><span class=\"line\">                        <span class=\"keyword\">if</span> (oldValueData == data) &#123;</span><br><span class=\"line\">                            <span class=\"comment\">// MMKVInfo(&quot;[key] %s, set the same data&quot;, key.c_str());</span></span><br><span class=\"line\">                            <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125; <span class=\"built_in\">catch</span> (std::exception &amp;exception) &#123;</span><br><span class=\"line\">                        <span class=\"built_in\">MMKVWarning</span>(<span class=\"string\">&quot;compareBeforeSet exception: %s&quot;</span>, exception.<span class=\"built_in\">what</span>());</span><br><span class=\"line\">                    &#125; <span class=\"built_in\">catch</span> (...) &#123;</span><br><span class=\"line\">                        <span class=\"built_in\">MMKVWarning</span>(<span class=\"string\">&quot;compareBeforeSet fail&quot;</span>);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                     ...</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"type\">bool</span> onlyOneKey = !<span class=\"built_in\">isMultiProcess</span>() &amp;&amp; m_dic-&gt;<span class=\"built_in\">size</span>() == <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (<span class=\"built_in\">mmkv_likely</span>(!m_enableKeyExpire)) &#123;</span><br><span class=\"line\">                ...</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                KVHolderRet_t ret;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (onlyOneKey) &#123;</span><br><span class=\"line\">                    ret = <span class=\"built_in\">overrideDataWithKey</span>(data, key, isDataHolder);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    ret = <span class=\"built_in\">appendDataWithKey</span>(data, key, isDataHolder);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (!ret.first) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                itr = m_dic-&gt;<span class=\"built_in\">find</span>(key);</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (itr != m_dic-&gt;<span class=\"built_in\">end</span>()) &#123;</span><br><span class=\"line\">                    itr-&gt;second = std::<span class=\"built_in\">move</span>(ret.second);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// in case filterExpiredKeys() is triggered</span></span><br><span class=\"line\">                    m_dic-&gt;<span class=\"built_in\">emplace</span>(key, std::<span class=\"built_in\">move</span>(ret.second));</span><br><span class=\"line\">                    <span class=\"built_in\">mmkv_retain_key</span>(key);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">           ...</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    m_hasFullWriteback = <span class=\"literal\">false</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里面的代码逻辑很长，做了很多 if-else 的逻辑，最终走向两个大分支：</p>\n<p>key 是新增的走 <code>appendDataWithKey</code></p>\n<p>key 将会覆盖原来的将会走 <code>overrideDataWithKey</code></p>\n<p>有这两个分支，主要是因为 mmkv 存储采用的  <a href=\"https://protobuf.com.cn/\">protobuf 协议</a>，另外有一个很重要的方法也在这里执行了：<code>checkLoadData();</code>  安卓里面的多进程实现，将需要这里的一些逻辑，在 mmkv多进程原理篇进行讲解。</p>\n<p><code>appendDataWithKey</code> 转换为 <code>MMBuffer</code>并继续向下执行</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">KVHolderRet_t <span class=\"title\">MMKV::appendDataWithKey</span><span class=\"params\">(<span class=\"type\">const</span> MMBuffer &amp;data, MMKVKey_t key, <span class=\"type\">bool</span> isDataHolder)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">auto</span> keyData = <span class=\"built_in\">MMBuffer</span>((<span class=\"type\">void</span> *) key.<span class=\"built_in\">data</span>(), key.<span class=\"built_in\">size</span>(), MMBufferNoCopy);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">doAppendDataWithKey</span>(data, keyData, isDataHolder, <span class=\"built_in\">static_cast</span>&lt;<span class=\"type\">uint32_t</span>&gt;(keyData.<span class=\"built_in\">length</span>()));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>doAppendDataWithKey</code> 里面的代码也很长，不过也就只做一件事：将k-v值写入到文件里面做准备，真正的写入逻辑在 <code>m_output-&gt;writeData(keyData);</code>，这里先后调用了两次 <code>writeData</code>,是先写入key再写入了 value。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">KVHolderRet_t</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">MMKV::doAppendDataWithKey</span><span class=\"params\">(<span class=\"type\">const</span> MMBuffer &amp;data, <span class=\"type\">const</span> MMBuffer &amp;keyData, <span class=\"type\">bool</span> isDataHolder, <span class=\"type\">uint32_t</span> originKeyLength)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">auto</span> isKeyEncoded = (originKeyLength &lt; keyData.<span class=\"built_in\">length</span>());</span><br><span class=\"line\">    <span class=\"keyword\">auto</span> keyLength = <span class=\"built_in\">static_cast</span>&lt;<span class=\"type\">uint32_t</span>&gt;(keyData.<span class=\"built_in\">length</span>());</span><br><span class=\"line\">    <span class=\"keyword\">auto</span> valueLength = <span class=\"built_in\">static_cast</span>&lt;<span class=\"type\">uint32_t</span>&gt;(data.<span class=\"built_in\">length</span>());</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (isDataHolder) &#123;</span><br><span class=\"line\">        valueLength += <span class=\"built_in\">pbRawVarint32Size</span>(valueLength);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// size needed to encode the key</span></span><br><span class=\"line\">    <span class=\"type\">size_t</span> size = isKeyEncoded ? keyLength : (keyLength + <span class=\"built_in\">pbRawVarint32Size</span>(keyLength));</span><br><span class=\"line\">    <span class=\"comment\">// size needed to encode the value</span></span><br><span class=\"line\">    size += valueLength + <span class=\"built_in\">pbRawVarint32Size</span>(valueLength);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">SCOPED_LOCK</span>(m_exclusiveProcessLock);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">bool</span> hasEnoughSize = <span class=\"built_in\">ensureMemorySize</span>(size);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!hasEnoughSize || !<span class=\"built_in\">isFileValid</span>()) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">make_pair</span>(<span class=\"literal\">false</span>, <span class=\"built_in\">KeyValueHolder</span>());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">\t\t...</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (isKeyEncoded) &#123;</span><br><span class=\"line\">            m_output-&gt;<span class=\"built_in\">writeRawData</span>(keyData);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            m_output-&gt;<span class=\"built_in\">writeData</span>(keyData);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (isDataHolder) &#123;</span><br><span class=\"line\">            m_output-&gt;<span class=\"built_in\">writeRawVarint32</span>((<span class=\"type\">int32_t</span>) valueLength);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        m_output-&gt;<span class=\"built_in\">writeData</span>(data); <span class=\"comment\">// note: write size of data</span></span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">    ...</span><br><span class=\"line\">    m_actualSize += size;</span><br><span class=\"line\">    <span class=\"built_in\">updateCRCDigest</span>(ptr, size);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">make_pair</span>(<span class=\"literal\">true</span>, <span class=\"built_in\">KeyValueHolder</span>(originKeyLength, valueLength, offset));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>writeData</code> 进行了两步先写入数据的 <strong>长度信息</strong>，再写入真实的数据，这里还是因为  <a href=\"https://protobuf.com.cn/\">protobuf 协议</a>设计相关</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">CodedOutputData::writeData</span><span class=\"params\">(<span class=\"type\">const</span> MMBuffer &amp;value)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>-&gt;<span class=\"built_in\">writeRawVarint32</span>((<span class=\"type\">int32_t</span>) value.<span class=\"built_in\">length</span>());</span><br><span class=\"line\">    <span class=\"keyword\">this</span>-&gt;<span class=\"built_in\">writeRawData</span>(value);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>最终走到了<code>writeRawData</code> 关键代码</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">CodedOutputData::writeRawData</span><span class=\"params\">(<span class=\"type\">const</span> MMBuffer &amp;data)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"type\">size_t</span> numberOfBytes = data.<span class=\"built_in\">length</span>();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (m_position + numberOfBytes &gt; m_size) &#123;</span><br><span class=\"line\">       ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">memcpy</span>(m_ptr + m_position, data.<span class=\"built_in\">getPtr</span>(), numberOfBytes);</span><br><span class=\"line\">    m_position += numberOfBytes;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>核心逻辑使用 <code>memcpy</code> 将数据直接通过 memcpy 直接在内存层面进行拷贝，而这里的 <code>m_ptr</code>就是最开始通过<code>mmap</code>创建出来的指针！！到这里一次写入基本上就结束了。</p>\n<h3 id=\"mmkv-一次-get-的流程\"><a href=\"#mmkv-一次-get-的流程\" class=\"headerlink\" title=\"mmkv 一次 get 的流程\"></a>mmkv 一次 get 的流程</h3><p>依然先通过 JNI走到</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">MMKV_JNI jint <span class=\"title\">decodeInt</span><span class=\"params\">(JNIEnv *env, jobject obj, jlong handle, jstring oKey, jint defaultValue)</span> </span>&#123;</span><br><span class=\"line\">    MMKV *kv = <span class=\"built_in\">reinterpret_cast</span>&lt;MMKV *&gt;(handle);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (kv &amp;&amp; oKey) &#123;</span><br><span class=\"line\">        string key = <span class=\"built_in\">jstring2string</span>(env, oKey);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (jint) kv-&gt;<span class=\"built_in\">getInt32</span>(key, defaultValue);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> defaultValue;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>再到 mmkv getInt32</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int32_t</span> <span class=\"title\">MMKV::getInt32</span><span class=\"params\">(MMKVKey_t key, <span class=\"type\">int32_t</span> defaultValue, <span class=\"type\">bool</span> *hasValue)</span> </span>&#123;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">    <span class=\"built_in\">SCOPED_LOCK</span>(m_lock);</span><br><span class=\"line\">    <span class=\"built_in\">SCOPED_LOCK</span>(m_sharedProcessLock);</span><br><span class=\"line\">    <span class=\"keyword\">auto</span> data = <span class=\"built_in\">getDataForKey</span>(key);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (data.<span class=\"built_in\">length</span>() &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"function\">CodedInputData <span class=\"title\">input</span><span class=\"params\">(data.getPtr(), data.length())</span></span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (hasValue != <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">                *hasValue = <span class=\"literal\">true</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> input.<span class=\"built_in\">readInt32</span>();</span><br><span class=\"line\">        &#125; </span><br><span class=\"line\">        ...</span><br><span class=\"line\">    <span class=\"keyword\">return</span> defaultValue;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>getRawDataForKey</code>方法，主要有两个分支，一种是加密逻辑，另一种是非加密逻辑，但他们流程都差不多从一个  map 里面根据 key 获取一个对象（这个对象暂时并不是 get 最终的返回值），那这个 map 是从哪里来的呢？</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">MMBuffer <span class=\"title\">MMKV::getRawDataForKey</span><span class=\"params\">(MMKVKey_t key)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">checkLoadData</span>();</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">ifndef</span> MMKV_DISABLE_CRYPT</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (m_crypter) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">auto</span> itr = m_dicCrypt-&gt;<span class=\"built_in\">find</span>(key);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (itr != m_dicCrypt-&gt;<span class=\"built_in\">end</span>()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">auto</span> basePtr = (<span class=\"type\">uint8_t</span> *) (m_file-&gt;<span class=\"built_in\">getMemory</span>()) + Fixed32Size;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> itr-&gt;second.<span class=\"built_in\">toMMBuffer</span>(basePtr, m_crypter);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span></span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">auto</span> itr = m_dic-&gt;<span class=\"built_in\">find</span>(key);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (itr != m_dic-&gt;<span class=\"built_in\">end</span>()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">auto</span> basePtr = (<span class=\"type\">uint8_t</span> *) (m_file-&gt;<span class=\"built_in\">getMemory</span>()) + Fixed32Size;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> itr-&gt;second.<span class=\"built_in\">toMMBuffer</span>(basePtr);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    MMBuffer nan;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> nan;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>从源码里面溯源<code>m_dicCrypt</code>和 <code>m_dic</code> 是在 MMKV 初始化的时候生成的，主要逻辑在 <code>MMKV_IO .cpp</code>里面的 <code>loadFromFile</code>方法内：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">MMKV::loadFromFile</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">loadMetaInfoAndCheck</span>();</span><br><span class=\"line\">\t\t...</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!m_file-&gt;<span class=\"built_in\">isFileValid</span>()) &#123;</span><br><span class=\"line\">        m_file-&gt;<span class=\"built_in\">reloadFromFile</span>(m_expectedCapacity);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!m_file-&gt;<span class=\"built_in\">isFileValid</span>()) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">MMKVError</span>(<span class=\"string\">&quot;file [%s] not valid&quot;</span>, m_path.<span class=\"built_in\">c_str</span>());</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">bool</span> loadFromFile = <span class=\"literal\">false</span>, needFullWriteback = <span class=\"literal\">false</span>;</span><br><span class=\"line\">        <span class=\"built_in\">checkDataValid</span>(loadFromFile, needFullWriteback);</span><br><span class=\"line\">        ...</span><br><span class=\"line\">        <span class=\"keyword\">auto</span> ptr = (<span class=\"type\">uint8_t</span> *) m_file-&gt;<span class=\"built_in\">getMemory</span>();</span><br><span class=\"line\">        <span class=\"comment\">// loading</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (loadFromFile &amp;&amp; m_actualSize &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\t\t\t...</span><br><span class=\"line\">            <span class=\"function\">MMBuffer <span class=\"title\">inputBuffer</span><span class=\"params\">(ptr + Fixed32Size, m_actualSize, MMBufferNoCopy)</span></span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (m_crypter) &#123;</span><br><span class=\"line\">                <span class=\"built_in\">clearDictionary</span>(m_dicCrypt);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"built_in\">clearDictionary</span>(m_dic);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (needFullWriteback) &#123;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">ifndef</span> MMKV_DISABLE_CRYPT</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (m_crypter) &#123;</span><br><span class=\"line\">                    MiniPBCoder::<span class=\"built_in\">greedyDecodeMap</span>(*m_dicCrypt, inputBuffer, m_crypter);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span></span></span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    MiniPBCoder::<span class=\"built_in\">greedyDecodeMap</span>(*m_dic, inputBuffer);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">ifndef</span> MMKV_DISABLE_CRYPT</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (m_crypter) &#123;</span><br><span class=\"line\">                    MiniPBCoder::<span class=\"built_in\">decodeMap</span>(*m_dicCrypt, inputBuffer, m_crypter);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span></span></span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    MiniPBCoder::<span class=\"built_in\">decodeMap</span>(*m_dic, inputBuffer);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            m_output = <span class=\"keyword\">new</span> <span class=\"built_in\">CodedOutputData</span>(ptr + Fixed32Size, m_file-&gt;<span class=\"built_in\">getFileSize</span>() - Fixed32Size);</span><br><span class=\"line\">            m_output-&gt;<span class=\"built_in\">seek</span>(m_actualSize);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (needFullWriteback) &#123;</span><br><span class=\"line\">                <span class=\"built_in\">fullWriteback</span>();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// file not valid or empty, discard everything</span></span><br><span class=\"line\">            <span class=\"built_in\">SCOPED_LOCK</span>(m_exclusiveProcessLock);</span><br><span class=\"line\"></span><br><span class=\"line\">            m_output = <span class=\"keyword\">new</span> <span class=\"built_in\">CodedOutputData</span>(ptr + Fixed32Size, m_file-&gt;<span class=\"built_in\">getFileSize</span>() - Fixed32Size);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (m_actualSize &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                <span class=\"built_in\">writeActualSize</span>(<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"literal\">nullptr</span>, IncreaseSequence);</span><br><span class=\"line\">                <span class=\"built_in\">sync</span>(MMKV_SYNC);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"built_in\">writeActualSize</span>(<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"literal\">nullptr</span>, KeepSequence);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">\t\t\t\t...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    m_needLoadFromFile = <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>总统来说就是在初始化的时候就会将基于<code>protobuf</code>协议的本地文件里面的数据加载到内存，并将其放在一个 map 内，方便后续使用。</p>\n<p>回到 <code>int32_t MMKV::getInt32()</code>通过 <code>getDataForKey(key)</code>获取到一个<code>MMBuffer</code>对象，并通过 <strong>CodedInputData</strong>进行反序列化操作，读取 <strong>Varint32</strong> 的 <strong>valueSize</strong> 值，随后不断循环通过 <strong>CodedInputData</strong>  读取到<strong>value</strong> 值。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int32_t</span> <span class=\"title\">MMKV::getInt32</span><span class=\"params\">(MMKVKey_t key, <span class=\"type\">int32_t</span> defaultValue, <span class=\"type\">bool</span> *hasValue)</span> </span>&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"keyword\">auto</span> data = <span class=\"built_in\">getDataForKey</span>(key);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (data.<span class=\"built_in\">length</span>() &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"function\">CodedInputData <span class=\"title\">input</span><span class=\"params\">(data.getPtr(), data.length())</span></span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (hasValue != <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">                *hasValue = <span class=\"literal\">true</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> input.<span class=\"built_in\">readInt32</span>();</span><br><span class=\"line\">        &#125; </span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  \t...</span><br><span class=\"line\">    <span class=\"keyword\">return</span> defaultValue;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h2 id=\"mmkv-与-SharedPreferences\"><a href=\"#mmkv-与-SharedPreferences\" class=\"headerlink\" title=\"mmkv 与 SharedPreferences\"></a>mmkv 与 SharedPreferences</h2><p>以下是 <strong>MMKV</strong> 与 <strong>SharedPreferences</strong> 的优劣势对比总结，结合性能、安全性、功能支持等核心维度进行分析：</p>\n<h3 id=\"性能对比\"><a href=\"#性能对比\" class=\"headerlink\" title=\"性能对比\"></a><strong>性能对比</strong></h3><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\"><strong>维度</strong></th>\n<th style=\"text-align:left\"><strong>SharedPreferences</strong></th>\n<th style=\"text-align:left\"><strong>MMKV</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\"><strong>读写速度</strong></td>\n<td style=\"text-align:left\">慢（同步 I/O，多次数据拷贝）</td>\n<td style=\"text-align:left\">快（<code>mmap</code> 零拷贝，内存直接操作）</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>线程安全</strong></td>\n<td style=\"text-align:left\">需自行加锁（<code>apply()</code> 异步写入仍有风险）</td>\n<td style=\"text-align:left\">内置多线程锁（文件锁 + 内存锁）</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>大数据量支持</strong></td>\n<td style=\"text-align:left\">性能急剧下降（全量 XML 解析/序列化）</td>\n<td style=\"text-align:left\">高效（增量更新，Protobuf 编码）</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h3 id=\"安全性与稳定性\"><a href=\"#安全性与稳定性\" class=\"headerlink\" title=\"安全性与稳定性\"></a><strong>安全性与稳定性</strong></h3><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\"><strong>维度</strong></th>\n<th style=\"text-align:left\"><strong>SharedPreferences</strong></th>\n<th style=\"text-align:left\"><strong>MMKV</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\"><strong>数据加密</strong></td>\n<td style=\"text-align:left\">无（明文存储）</td>\n<td style=\"text-align:left\">支持 AES-128/AES-256 加密</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>崩溃恢复</strong></td>\n<td style=\"text-align:left\">可能因异常导致 XML 损坏</td>\n<td style=\"text-align:left\">通过 CRC 校验 + 备份文件保障完整性</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>系统版本适配</strong></td>\n<td style=\"text-align:left\">部分版本有 ANR 问题（如 <code>apply()</code>）</td>\n<td style=\"text-align:left\">无系统级兼容性问题</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h3 id=\"功能支持\"><a href=\"#功能支持\" class=\"headerlink\" title=\"功能支持\"></a><strong>功能支持</strong></h3><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\"><strong>维度</strong></th>\n<th style=\"text-align:left\"><strong>SharedPreferences</strong></th>\n<th style=\"text-align:left\"><strong>MMKV</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\"><strong>多进程</strong></td>\n<td style=\"text-align:left\">不支持（跨进程数据不同步）</td>\n<td style=\"text-align:left\">支持（通过文件锁 + <code>mmap</code> 共享内存）</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>数据类型</strong></td>\n<td style=\"text-align:left\">仅支持基本类型（int/String 等）</td>\n<td style=\"text-align:left\">支持基本类型、二进制数据（MMBuffer）</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>加密存储</strong></td>\n<td style=\"text-align:left\">明文存储（XML）</td>\n<td style=\"text-align:left\">支持 AES 加密（可选）</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>增量更新</strong></td>\n<td style=\"text-align:left\">全量写入（即使只改一个键值）</td>\n<td style=\"text-align:left\">仅追加新数据，定期整理</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>从上面的对比看看，mmkv 在很多层面都是领先 SharedPreferences 的，那么 mmkv 是否有缺陷呢？答案是有的。</p>\n<blockquote>\n<p>任何的操作系统、任何的软件，在往磁盘写数据的过程中如果发生了意外——例如程序崩溃，或者断电关机——磁盘里的文件就会以这种写了一半的、不完整的形式被保留。写了一半的数据怎么用啊？没法用，这就是文件的损坏。这种问题是不可能避免的，MMKV 虽然由于底层机制的原因，在程序崩溃的时候不会影响数据往磁盘的写入，但断电关机之类的操作系统级别的崩溃，MMKV 就没办法了，文件照样会损坏。对于这种文件损坏，SharedPreferences 和 DataStore 的应对方式是在每次写入新数据之前都对现有文件做一次自动备份，这样在发生了意外出现了文件损坏之后，它们就会把备份的数据恢复过来；而 MMKV，没有这种自动的备份和恢复，那么当文件发生了损坏，数据就丢了，之前保存的各种信息只能被重置。也就是说，MMKV 是唯一会丢数据的方案。</p>\n</blockquote>\n<p>在 mmkv 里面有 <a href=\"https://info.support.huawei.com/info-finder/encyclopedia/zh/CRC.html\">CRC</a> 校验，如果不通过的话，将会废弃掉之前所有的数据。在 mmkv 里面也有人反馈：<a href=\"https://github.com/Tencent/MMKV/issues/729\">https://github.com/Tencent/MMKV/issues/729</a> 在写入的过程中因为一些特殊情况写入失败，会导致本地的文件损坏且不可recovery。</p>\n<p>那有什么办法避免这个问题呢？有大佬开源另一个 KV 框架 <a href=\"https://github.com/BillyWei01/FastKV\">FastKV</a>对这个问题进行了处理，采用通过double-write等方法确保数据的完整性，原理是数据依次写入A/B两个文件，如果写入A过程中崩溃，B仍是完整的，如果A完整写入了，则B写入时崩溃也不要紧。这种实现方式理论上是不错的，不太清楚 mmkv 为什么没有采取这样的逻辑。不过这个库并没有经过大量业务进行验证，只能作为一个学习的方案先看看。</p>\n<p>另外谷歌已经开发了新的KV存储框架<a href=\"https://cloud.google.com/datastore/docs/concepts/overview?hl=zh-cn\">DataStore</a>，<code>SharedPreferences</code>也将渐渐地退出历史的舞台了。不过 DataStore 的性能目前仍然没有 mmkv 的好。关于这三者的比较可以查看： <a href=\"https://juejin.cn/post/7112268981163016229\">《Android 的键值对存储有没有最优解？》</a></p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>这篇文章深入剖析了 <strong>MMKV</strong>（腾讯开源的高性能键值存储组件）的核心设计与实现原理，重点对比了传统 I/O 与 <code>mmap</code> 内存映射的差异，并详细分析了 MMKV 的读写流程以及和 SharedPreferences 的各方面对比。</p>\n<p><strong>参考</strong></p>\n<p><a href=\"https://juejin.cn/post/7112268981163016229\">《Android 的键值对存储有没有最优解？》</a></p>\n<p><a href=\"https://yangjie2.github.io/2021/11/14/mmap%E5%8E%9F%E7%90%86%E4%B8%8E%E5%BA%94%E7%94%A8/\">《mmap原理与应用》</a></p>\n<p><a href=\"https://blog.csdn.net/zhanglh046/article/details/115603788\">《文件内存映射和传统I/O机制》</a></p>\n<p><a href=\"https://blog.csdn.net/luo_boke/article/details/109311432\">Android 内存映射mmap浅谈</a></p>\n","cover":null,"images":["https://cdn.julis.wang/blog/img/ee519ba873acf3f80fd4ccec86ed72e7.png","https://cdn.julis.wang/blog/img/mmap_1.png","https://cdn.julis.wang/blog/img/mmap_2_1.png"],"content":"<p>在平时的业务中，需要用到轻量级存储业务中的数据（例如设置数据存储），绝大多数时候 Anroid 管法提供的 <a href=\"https://developer.android.com/reference/android/content/SharedPreferences\">SharedPreferences</a>  组件就能实现，但针对一些需要高效的场景它就不那么使用了，不适合存储大量数据、多线程操作的不安全性、数据明文不安全性，以及不支持多进程之间的调用等各种问题。<br><a href=\"https://github.com/Tencent/MMKV\">MMKV</a>的诞生就是为了解决以上的问题，本文主要对 MMKV 源码的学习知识点进行一些总结。</p>\n<h2 id=\"核心设计与原理\"><a href=\"#核心设计与原理\" class=\"headerlink\" title=\"核心设计与原理\"></a>核心设计与原理</h2><p>在官方的开源工程中可以看到如下的一些介绍</p>\n<blockquote>\n<p>MMKV 是基于 mmap 内存映射的 key-value 组件，底层序列化/反序列化使用 protobuf 实现，性能高，稳定性强。从 2015 年中至今在微信上使用，其性能和稳定性经过了时间的验证。</p>\n</blockquote>\n<h3 id=\"传统I-O与-mmap\"><a href=\"#传统I-O与-mmap\" class=\"headerlink\" title=\"传统I/O与 mmap\"></a>传统I/O与 mmap</h3><p>mmap 这个是 mmkv 实现的核心，没有 mmap 那么就没有 mmkv。对于 <code>SharedPreferences</code>的实现来说，每次的数据更新都将操作本地文件，而本地文件的写入是通过传统的I/O实现。要理解两者的实现差异，需要先理解 Linux <strong>用户空间与内核空间</strong>设计。</p>\n<h4 id=\"用户空间与内核空间\"><a href=\"#用户空间与内核空间\" class=\"headerlink\" title=\"用户空间与内核空间\"></a><strong>用户空间与内核空间</strong></h4><p>Linux的进程是相互独立的，一个进程是不能直接操作或者访问别一个进程空间的。每个进程空间还分为用户空间和内核（Kernel）空间，相当于把Kernel和上层的应用程序抽像的隔离开。</p>\n<p><strong>用户空间</strong>和<strong>内核空间</strong>，用户空间是用户程序代码运行的地方，内核空间是内核代码运行的地方。为了安全，它们是隔离的，即使用户的程序崩溃了，内核也不受影响。</p>\n<p>这里有两个隔离，一个进程间是相互隔离的，二是进程内有用户空间和内核空间的隔离。</p>\n<p>进程间，用户空间的数据不可共享，所以用户空间 = 不可共享空间<br>进程间，内核空间的数据可共享，所以内核空间 = 可共享空间，所以Linux系统的内存通常是MemFree+Cache<br>所有进程共用1个内核空间。</p>\n<h4 id=\"传统I-O读写流程\"><a href=\"#传统I-O读写流程\" class=\"headerlink\" title=\"传统I/O读写流程\"></a><strong>传统I/O读写流程</strong></h4><p>常规文件读写操作（调用read/fread等函数）过程如下：</p>\n<ul>\n<li><p>进程发起读写文件请求。</p>\n</li>\n<li><p>内核通过查找进程文件符表，定位到内核已打开文件集上的文件信息，从而找到此文件的<code>inode</code>。</p>\n</li>\n<li><p><code>inode</code> 在 <code>address_space</code> 上查找要请求的文件页是否已经缓存在页缓存中。如果存在，则直接返回这片文件页的内容。</p>\n</li>\n<li><p>如果不存在，则通过 <code>inode</code> 定位到文件磁盘地址，将数据从磁盘复制到页缓存。之后再次发起读页面过程，进而将页缓存中的数据发给用户进程。</p>\n<blockquote>\n<p><strong>什么是 inode</strong> ?</p>\n<p>全称为 index node，既<strong>存储文件元信息的区域</strong>，中文译名“索引节点”。<br>包含：文件权限、文件拥有者的UID、文件的大小等等。</p>\n<img src=\"https://cdn.julis.wang/blog/img/ee519ba873acf3f80fd4ccec86ed72e7.png\">\n</blockquote>\n</li>\n</ul>\n<p>总结来说，常规文件操作为了提高读写效率和保护磁盘，使用了页缓存机制。这样造成读文件时需要先将文件页从磁盘拷贝到页缓存中，由于页缓存处在内核空间，不能被用户进程直接寻址访问，所以还需要将页缓存中的数据页再次拷贝到用户空间中。这样，通过了两次数据拷贝过程，才能完成<strong>进程</strong>对<strong>文件</strong>内容的访问。</p>\n<h4 id=\"mmap基本概念和原理\"><a href=\"#mmap基本概念和原理\" class=\"headerlink\" title=\"mmap基本概念和原理\"></a><strong>mmap基本概念和原理</strong></h4><p>内存映射（mmap），就是<strong>将文件的磁盘扇区映射到进程的虚拟内存空间</strong>的过程，即将一个文件映射到进程的虚拟空间，实现文件磁盘地址和进程虚拟空间中一段虚拟地址的一一对应关系。实现这样的映射关系后，进程就可以采用指针的方式读写操作这一段内存，而系统会自动回写脏页面到对应的文件磁盘上，即完成了对文件的操作而不必再调用read,write等系统调用函数。</p>\n<img src=\"https://cdn.julis.wang/blog/img/mmap_1.png\">\n<p>由上图可知，进程的虚拟地址空间，由多个虚拟内存区域构成。每个虚拟内存区域都是进程在虚拟地址空间中的一个同质区间，即具有同样特性的连续地址范围。上图中所示的text数据段（代码段）、初始数据段、BSS数据段、堆、栈和内存映射，都是一个独立的虚拟内存区域。内存映射的地址空间处在堆栈之间的空余部分。</p>\n<p>linux内核使用 <code>vm_area_struc</code>t 结构来表示一个独立的虚拟内存区域，由于每个不同质的虚拟内存区域功能和内部机制都不同，因此一个进程使用多个 <code>vm_area_struct</code> 结构来分别表示不同类型的虚拟内存区域。各个 <code>vm_area_struct</code> 结构使用链表或者树形结构链接，方便进程快速访问，如下图所示：</p>\n<img src=\"https://cdn.julis.wang/blog/img/mmap_2_1.png\">\n<p><code>vm_area_struct</code> 结构中包含区域起始和终止地址以及其他相关信息。这样，进程对某一虚拟内存区域的任何操作需要用要的信息，都可以从 <code>vm_area_struct</code> 中获得。mmap函数就是要创建一个新的 <code>vm_area_struct</code> 结构，并将其与文件的物理磁盘地址相连。</p>\n<p>mmap内存映射的实现过程，总的来说可以分为三个阶段：</p>\n<p><strong>阶段一：进程启动映射过程，并在虚拟地址空间中为映射创建虚拟映射区域</strong></p>\n<ul>\n<li>进程在用户空间调用mmap库函数</li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> *<span class=\"title\">mmap</span><span class=\"params\">(<span class=\"type\">void</span> *addr, <span class=\"type\">size_t</span> length, <span class=\"type\">int</span> prot, <span class=\"type\">int</span> flags, <span class=\"type\">int</span> fd, <span class=\"type\">off_t</span> offset)</span></span>;</span><br></pre></td></tr></table></figure>\n<p><code>addr</code>：指定映射的虚拟内存地址，可以设置为 NULL，让内核自动选择合适的虚拟内存地址</p>\n<p><code>length</code>：映射的长度。</p>\n<p><code>prot</code>：映射内存的保护模式，可选值如下：  </p>\n<p><code>flags</code>：指定映射的类型</p>\n<p><code>fd</code>：进行映射的文件句柄。</p>\n<p><code>offset</code>：文件偏移量（从文件的何处开始映射）</p>\n<ul>\n<li><p>在当前进程的虚拟地址空间中，寻找一段空闲的满足要求的连续的虚拟地址</p>\n</li>\n<li><p>为此虚拟区分配一个 <code>vm_area_struct</code> 结构，接着对这个结构的各个域进行了初始化</p>\n</li>\n<li><p>将新创建的虚拟区结构 <code>vm_area_struct</code> 对象插入到进程的虚拟地址区域链表/树中</p>\n</li>\n</ul>\n<p><strong>阶段二：调用内核空间的mmap函数（不同于用户空间函数），实现文件物理地址和进程虚拟地址的一一映射关系</strong></p>\n<ul>\n<li>为映射分配了新的虚拟地址区域后，通过待映射的文件指针，在文件描述符表中找到对应的文件描述符，通过文件描述符，链接到内核“已打开文件集”中该文件的文件结构体（struct file），每个文件结构体维护着和这个已打开文件相关各项信息。</li>\n<li><p>为映射分配了新的虚拟地址区域后，通过待映射的文件指针，在文件描述符表中找到对应的文件描述符，通过文件描述符，链接到内核“已打开文件集”中该文件的文件结构体（struct file），每个文件结构体维护着和这个已打开文件相关各项信息。</p>\n</li>\n<li><p>通过该文件的文件结构体，链接到 <code>file_operations</code> 模块，调用内核mmap函数，其原型为：</p>\n</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">int mmap(struct file *filp, struct vm_area_struct *vma) //不同于用户空间mmap库函数</span><br></pre></td></tr></table></figure>\n<ul>\n<li><p>内核mmap函数通过虚拟文件系统inode模块定位到文件磁盘物理地址。</p>\n</li>\n<li><p>通过 <code>remap_pfn_range</code> 函数建立页表，即实现了文件地址和虚拟地址区域的映射关系。此时，这片虚拟地址并没有任何数据关联到物理内存(主存)中。</p>\n</li>\n</ul>\n<blockquote>\n<p>主存</p>\n<p>主存储器（Main memory），简称主存。是计算机硬件的一个重要部件，其作用是存放指令和数据，并能由中央处理器（CPU）直接随机存取</p>\n</blockquote>\n<p><strong>阶段三：进程发起对这片映射地址空间的访问，引发缺页异常，实现文件内容到主存（物理内存）的拷贝</strong></p>\n<blockquote>\n<p>前两个阶段仅在于创建虚拟区间并完成地址映射，但是并没有将任何文件数据的拷贝至主存。真正的文件读取是当进程发起读或写操作时</p>\n</blockquote>\n<ul>\n<li><p>进程的读或写操作访问虚拟地址空间这一段映射地址，通过查询页表，发现这一段地址并不在物理页上。因为目前只建立了地址映射，真正的硬盘数据还没有拷贝到内存中，因此引发缺页异常。</p>\n</li>\n<li><p>缺页异常进行一系列判断，确定无非法操作后，内核发起请求调页过程。</p>\n</li>\n<li><p>调页过程先在交换缓存空间（swap cache）中寻找需要访问的内存页，如果没有则调用nopage函数把所缺的页从磁盘装入到主存中。</p>\n</li>\n<li><p>之后进程即可对这片主存进行读或者写的操作，如果写操作改变了其内容，一定时间后系统会自动回写脏页面到对应磁盘地址，也即完成了写入到文件的过程。</p>\n</li>\n</ul>\n<blockquote>\n<p>修改过的脏页面并不会立即更新回文件中，而是有一段时间的延迟，可以调用<code>msync()</code>来强制同步, 这样所写的内容就能立即保存到文件里了</p>\n</blockquote>\n<p>常规文件操作需要从磁盘到内核空间页缓存再到用户空间主存的两次数据拷贝。而mmap文件映射，只需要从磁盘到用户空间主存的一次数据拷贝过程。mmap的关键点是实现了用户空间和内核空间的数据直接交互而省去了空间不同数据不通的繁琐过程，因此 mmap 效率更高。</p>\n<p>以上是 mmap 的基本概念和原理，搞明白了这些才能看明白整个 mmkv 里面的逻辑处理</p>\n<h3 id=\"mmkv-一次-put-的流程\"><a href=\"#mmkv-一次-put-的流程\" class=\"headerlink\" title=\"mmkv 一次 put 的流程\"></a>mmkv 一次 put 的流程</h3><p>mmkv初始化比较简单，主要涉及到一些配置的初始化，文件夹创建等，其中最重要的逻辑 mmap 调用被封装到一个 <code>MemoryFile</code>到对象里面 </p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">MemoryFile::mmap</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">auto</span> oldPtr = m_ptr;</span><br><span class=\"line\">    <span class=\"keyword\">auto</span> mode = m_readOnly ? PROT_READ : (PROT_READ | PROT_WRITE);</span><br><span class=\"line\">    m_ptr = (<span class=\"type\">char</span> *) ::<span class=\"built_in\">mmap</span>(m_ptr, m_size, mode, MAP_SHARED, m_diskFile.m_fd, <span class=\"number\">0</span>);</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>主要记录一下一次 put 任务的流程，以 <code>mmkv.putInt(&quot;int&quot;, 1)</code>为例，进过 JNI 的调用到了</p>\n<p><strong>native-birdge.cpp</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">MMKV_JNI jboolean <span class=\"title\">encodeInt</span><span class=\"params\">(JNIEnv *env, jobject obj, jlong handle, jstring oKey, jint value)</span> </span>&#123;</span><br><span class=\"line\">    MMKV *kv = <span class=\"built_in\">reinterpret_cast</span>&lt;MMKV *&gt;(handle);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (kv &amp;&amp; oKey) &#123;</span><br><span class=\"line\">        string key = <span class=\"built_in\">jstring2string</span>(env, oKey);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (jboolean) kv-&gt;<span class=\"built_in\">set</span>((<span class=\"type\">int32_t</span>) value, key);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (jboolean) <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>进入了<strong>MMVK.cpp</strong>的 </p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">MMKV::set</span><span class=\"params\">(<span class=\"type\">int32_t</span> value, MMKVKey_t key, <span class=\"type\">uint32_t</span> expireDuration)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">isKeyEmpty</span>(key)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"type\">size_t</span> size = <span class=\"built_in\">mmkv_unlikely</span>(m_enableKeyExpire) ? Fixed32Size + <span class=\"built_in\">pbInt32Size</span>(value) : <span class=\"built_in\">pbInt32Size</span>(value);</span><br><span class=\"line\">    <span class=\"function\">MMBuffer <span class=\"title\">data</span><span class=\"params\">(size)</span></span>;</span><br><span class=\"line\">    <span class=\"function\">CodedOutputData <span class=\"title\">output</span><span class=\"params\">(data.getPtr(), size)</span></span>;</span><br><span class=\"line\">    output.<span class=\"built_in\">writeInt32</span>(value);</span><br><span class=\"line\">    <span class=\"comment\">// ... 省略一些校验逻辑</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">setDataForKey</span>(std::<span class=\"built_in\">move</span>(data), key);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这一步主要是准备一下数据，并使用 <code>MMBuffer</code> <code>CodedOutputData</code>将写入的数据进行一次包装（不仅仅是 key-value，还有数据size等等），实际调用在<code>setDataForKey</code></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">MMKV::setDataForKey</span><span class=\"params\">(MMBuffer &amp;&amp;data, MMKVKey_t key, <span class=\"type\">bool</span> isDataHolder)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">checkLoadData</span>(); <span class=\"comment\">// 状态同步相关的逻辑</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (m_crypter) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// ... 省略加密的处理逻辑</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">auto</span> itr = m_dic-&gt;<span class=\"built_in\">find</span>(key);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (itr != m_dic-&gt;<span class=\"built_in\">end</span>()) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// compare data before appending to file</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (<span class=\"built_in\">isCompareBeforeSetEnabled</span>()) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">auto</span> basePtr = (<span class=\"type\">uint8_t</span> *) (m_file-&gt;<span class=\"built_in\">getMemory</span>()) + Fixed32Size;</span><br><span class=\"line\">                MMBuffer oldValueData = itr-&gt;second.<span class=\"built_in\">toMMBuffer</span>(basePtr);</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (isDataHolder) &#123;</span><br><span class=\"line\">                    <span class=\"function\">CodedInputData <span class=\"title\">inputData</span><span class=\"params\">(oldValueData.getPtr(), oldValueData.length())</span></span>;</span><br><span class=\"line\">                    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                        <span class=\"comment\">// read extra holder header bytes and to real MMBuffer</span></span><br><span class=\"line\">                        oldValueData = CodedInputData::<span class=\"built_in\">readRealData</span>(oldValueData);</span><br><span class=\"line\">                        <span class=\"keyword\">if</span> (oldValueData == data) &#123;</span><br><span class=\"line\">                            <span class=\"comment\">// MMKVInfo(&quot;[key] %s, set the same data&quot;, key.c_str());</span></span><br><span class=\"line\">                            <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125; <span class=\"built_in\">catch</span> (std::exception &amp;exception) &#123;</span><br><span class=\"line\">                        <span class=\"built_in\">MMKVWarning</span>(<span class=\"string\">&quot;compareBeforeSet exception: %s&quot;</span>, exception.<span class=\"built_in\">what</span>());</span><br><span class=\"line\">                    &#125; <span class=\"built_in\">catch</span> (...) &#123;</span><br><span class=\"line\">                        <span class=\"built_in\">MMKVWarning</span>(<span class=\"string\">&quot;compareBeforeSet fail&quot;</span>);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                     ...</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"type\">bool</span> onlyOneKey = !<span class=\"built_in\">isMultiProcess</span>() &amp;&amp; m_dic-&gt;<span class=\"built_in\">size</span>() == <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (<span class=\"built_in\">mmkv_likely</span>(!m_enableKeyExpire)) &#123;</span><br><span class=\"line\">                ...</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                KVHolderRet_t ret;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (onlyOneKey) &#123;</span><br><span class=\"line\">                    ret = <span class=\"built_in\">overrideDataWithKey</span>(data, key, isDataHolder);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    ret = <span class=\"built_in\">appendDataWithKey</span>(data, key, isDataHolder);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (!ret.first) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                itr = m_dic-&gt;<span class=\"built_in\">find</span>(key);</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (itr != m_dic-&gt;<span class=\"built_in\">end</span>()) &#123;</span><br><span class=\"line\">                    itr-&gt;second = std::<span class=\"built_in\">move</span>(ret.second);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// in case filterExpiredKeys() is triggered</span></span><br><span class=\"line\">                    m_dic-&gt;<span class=\"built_in\">emplace</span>(key, std::<span class=\"built_in\">move</span>(ret.second));</span><br><span class=\"line\">                    <span class=\"built_in\">mmkv_retain_key</span>(key);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">           ...</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    m_hasFullWriteback = <span class=\"literal\">false</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里面的代码逻辑很长，做了很多 if-else 的逻辑，最终走向两个大分支：</p>\n<p>key 是新增的走 <code>appendDataWithKey</code></p>\n<p>key 将会覆盖原来的将会走 <code>overrideDataWithKey</code></p>\n<p>有这两个分支，主要是因为 mmkv 存储采用的  <a href=\"https://protobuf.com.cn/\">protobuf 协议</a>，另外有一个很重要的方法也在这里执行了：<code>checkLoadData();</code>  安卓里面的多进程实现，将需要这里的一些逻辑，在 mmkv多进程原理篇进行讲解。</p>\n<p><code>appendDataWithKey</code> 转换为 <code>MMBuffer</code>并继续向下执行</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">KVHolderRet_t <span class=\"title\">MMKV::appendDataWithKey</span><span class=\"params\">(<span class=\"type\">const</span> MMBuffer &amp;data, MMKVKey_t key, <span class=\"type\">bool</span> isDataHolder)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">auto</span> keyData = <span class=\"built_in\">MMBuffer</span>((<span class=\"type\">void</span> *) key.<span class=\"built_in\">data</span>(), key.<span class=\"built_in\">size</span>(), MMBufferNoCopy);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">doAppendDataWithKey</span>(data, keyData, isDataHolder, <span class=\"built_in\">static_cast</span>&lt;<span class=\"type\">uint32_t</span>&gt;(keyData.<span class=\"built_in\">length</span>()));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>doAppendDataWithKey</code> 里面的代码也很长，不过也就只做一件事：将k-v值写入到文件里面做准备，真正的写入逻辑在 <code>m_output-&gt;writeData(keyData);</code>，这里先后调用了两次 <code>writeData</code>,是先写入key再写入了 value。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">KVHolderRet_t</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">MMKV::doAppendDataWithKey</span><span class=\"params\">(<span class=\"type\">const</span> MMBuffer &amp;data, <span class=\"type\">const</span> MMBuffer &amp;keyData, <span class=\"type\">bool</span> isDataHolder, <span class=\"type\">uint32_t</span> originKeyLength)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">auto</span> isKeyEncoded = (originKeyLength &lt; keyData.<span class=\"built_in\">length</span>());</span><br><span class=\"line\">    <span class=\"keyword\">auto</span> keyLength = <span class=\"built_in\">static_cast</span>&lt;<span class=\"type\">uint32_t</span>&gt;(keyData.<span class=\"built_in\">length</span>());</span><br><span class=\"line\">    <span class=\"keyword\">auto</span> valueLength = <span class=\"built_in\">static_cast</span>&lt;<span class=\"type\">uint32_t</span>&gt;(data.<span class=\"built_in\">length</span>());</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (isDataHolder) &#123;</span><br><span class=\"line\">        valueLength += <span class=\"built_in\">pbRawVarint32Size</span>(valueLength);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// size needed to encode the key</span></span><br><span class=\"line\">    <span class=\"type\">size_t</span> size = isKeyEncoded ? keyLength : (keyLength + <span class=\"built_in\">pbRawVarint32Size</span>(keyLength));</span><br><span class=\"line\">    <span class=\"comment\">// size needed to encode the value</span></span><br><span class=\"line\">    size += valueLength + <span class=\"built_in\">pbRawVarint32Size</span>(valueLength);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">SCOPED_LOCK</span>(m_exclusiveProcessLock);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">bool</span> hasEnoughSize = <span class=\"built_in\">ensureMemorySize</span>(size);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!hasEnoughSize || !<span class=\"built_in\">isFileValid</span>()) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">make_pair</span>(<span class=\"literal\">false</span>, <span class=\"built_in\">KeyValueHolder</span>());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">\t\t...</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (isKeyEncoded) &#123;</span><br><span class=\"line\">            m_output-&gt;<span class=\"built_in\">writeRawData</span>(keyData);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            m_output-&gt;<span class=\"built_in\">writeData</span>(keyData);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (isDataHolder) &#123;</span><br><span class=\"line\">            m_output-&gt;<span class=\"built_in\">writeRawVarint32</span>((<span class=\"type\">int32_t</span>) valueLength);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        m_output-&gt;<span class=\"built_in\">writeData</span>(data); <span class=\"comment\">// note: write size of data</span></span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">    ...</span><br><span class=\"line\">    m_actualSize += size;</span><br><span class=\"line\">    <span class=\"built_in\">updateCRCDigest</span>(ptr, size);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">make_pair</span>(<span class=\"literal\">true</span>, <span class=\"built_in\">KeyValueHolder</span>(originKeyLength, valueLength, offset));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>writeData</code> 进行了两步先写入数据的 <strong>长度信息</strong>，再写入真实的数据，这里还是因为  <a href=\"https://protobuf.com.cn/\">protobuf 协议</a>设计相关</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">CodedOutputData::writeData</span><span class=\"params\">(<span class=\"type\">const</span> MMBuffer &amp;value)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>-&gt;<span class=\"built_in\">writeRawVarint32</span>((<span class=\"type\">int32_t</span>) value.<span class=\"built_in\">length</span>());</span><br><span class=\"line\">    <span class=\"keyword\">this</span>-&gt;<span class=\"built_in\">writeRawData</span>(value);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>最终走到了<code>writeRawData</code> 关键代码</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">CodedOutputData::writeRawData</span><span class=\"params\">(<span class=\"type\">const</span> MMBuffer &amp;data)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"type\">size_t</span> numberOfBytes = data.<span class=\"built_in\">length</span>();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (m_position + numberOfBytes &gt; m_size) &#123;</span><br><span class=\"line\">       ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">memcpy</span>(m_ptr + m_position, data.<span class=\"built_in\">getPtr</span>(), numberOfBytes);</span><br><span class=\"line\">    m_position += numberOfBytes;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>核心逻辑使用 <code>memcpy</code> 将数据直接通过 memcpy 直接在内存层面进行拷贝，而这里的 <code>m_ptr</code>就是最开始通过<code>mmap</code>创建出来的指针！！到这里一次写入基本上就结束了。</p>\n<h3 id=\"mmkv-一次-get-的流程\"><a href=\"#mmkv-一次-get-的流程\" class=\"headerlink\" title=\"mmkv 一次 get 的流程\"></a>mmkv 一次 get 的流程</h3><p>依然先通过 JNI走到</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">MMKV_JNI jint <span class=\"title\">decodeInt</span><span class=\"params\">(JNIEnv *env, jobject obj, jlong handle, jstring oKey, jint defaultValue)</span> </span>&#123;</span><br><span class=\"line\">    MMKV *kv = <span class=\"built_in\">reinterpret_cast</span>&lt;MMKV *&gt;(handle);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (kv &amp;&amp; oKey) &#123;</span><br><span class=\"line\">        string key = <span class=\"built_in\">jstring2string</span>(env, oKey);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (jint) kv-&gt;<span class=\"built_in\">getInt32</span>(key, defaultValue);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> defaultValue;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>再到 mmkv getInt32</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int32_t</span> <span class=\"title\">MMKV::getInt32</span><span class=\"params\">(MMKVKey_t key, <span class=\"type\">int32_t</span> defaultValue, <span class=\"type\">bool</span> *hasValue)</span> </span>&#123;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">    <span class=\"built_in\">SCOPED_LOCK</span>(m_lock);</span><br><span class=\"line\">    <span class=\"built_in\">SCOPED_LOCK</span>(m_sharedProcessLock);</span><br><span class=\"line\">    <span class=\"keyword\">auto</span> data = <span class=\"built_in\">getDataForKey</span>(key);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (data.<span class=\"built_in\">length</span>() &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"function\">CodedInputData <span class=\"title\">input</span><span class=\"params\">(data.getPtr(), data.length())</span></span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (hasValue != <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">                *hasValue = <span class=\"literal\">true</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> input.<span class=\"built_in\">readInt32</span>();</span><br><span class=\"line\">        &#125; </span><br><span class=\"line\">        ...</span><br><span class=\"line\">    <span class=\"keyword\">return</span> defaultValue;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>getRawDataForKey</code>方法，主要有两个分支，一种是加密逻辑，另一种是非加密逻辑，但他们流程都差不多从一个  map 里面根据 key 获取一个对象（这个对象暂时并不是 get 最终的返回值），那这个 map 是从哪里来的呢？</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">MMBuffer <span class=\"title\">MMKV::getRawDataForKey</span><span class=\"params\">(MMKVKey_t key)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">checkLoadData</span>();</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">ifndef</span> MMKV_DISABLE_CRYPT</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (m_crypter) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">auto</span> itr = m_dicCrypt-&gt;<span class=\"built_in\">find</span>(key);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (itr != m_dicCrypt-&gt;<span class=\"built_in\">end</span>()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">auto</span> basePtr = (<span class=\"type\">uint8_t</span> *) (m_file-&gt;<span class=\"built_in\">getMemory</span>()) + Fixed32Size;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> itr-&gt;second.<span class=\"built_in\">toMMBuffer</span>(basePtr, m_crypter);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span></span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">auto</span> itr = m_dic-&gt;<span class=\"built_in\">find</span>(key);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (itr != m_dic-&gt;<span class=\"built_in\">end</span>()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">auto</span> basePtr = (<span class=\"type\">uint8_t</span> *) (m_file-&gt;<span class=\"built_in\">getMemory</span>()) + Fixed32Size;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> itr-&gt;second.<span class=\"built_in\">toMMBuffer</span>(basePtr);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    MMBuffer nan;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> nan;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>从源码里面溯源<code>m_dicCrypt</code>和 <code>m_dic</code> 是在 MMKV 初始化的时候生成的，主要逻辑在 <code>MMKV_IO .cpp</code>里面的 <code>loadFromFile</code>方法内：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">MMKV::loadFromFile</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">loadMetaInfoAndCheck</span>();</span><br><span class=\"line\">\t\t...</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!m_file-&gt;<span class=\"built_in\">isFileValid</span>()) &#123;</span><br><span class=\"line\">        m_file-&gt;<span class=\"built_in\">reloadFromFile</span>(m_expectedCapacity);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!m_file-&gt;<span class=\"built_in\">isFileValid</span>()) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">MMKVError</span>(<span class=\"string\">&quot;file [%s] not valid&quot;</span>, m_path.<span class=\"built_in\">c_str</span>());</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">bool</span> loadFromFile = <span class=\"literal\">false</span>, needFullWriteback = <span class=\"literal\">false</span>;</span><br><span class=\"line\">        <span class=\"built_in\">checkDataValid</span>(loadFromFile, needFullWriteback);</span><br><span class=\"line\">        ...</span><br><span class=\"line\">        <span class=\"keyword\">auto</span> ptr = (<span class=\"type\">uint8_t</span> *) m_file-&gt;<span class=\"built_in\">getMemory</span>();</span><br><span class=\"line\">        <span class=\"comment\">// loading</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (loadFromFile &amp;&amp; m_actualSize &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\t\t\t...</span><br><span class=\"line\">            <span class=\"function\">MMBuffer <span class=\"title\">inputBuffer</span><span class=\"params\">(ptr + Fixed32Size, m_actualSize, MMBufferNoCopy)</span></span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (m_crypter) &#123;</span><br><span class=\"line\">                <span class=\"built_in\">clearDictionary</span>(m_dicCrypt);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"built_in\">clearDictionary</span>(m_dic);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (needFullWriteback) &#123;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">ifndef</span> MMKV_DISABLE_CRYPT</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (m_crypter) &#123;</span><br><span class=\"line\">                    MiniPBCoder::<span class=\"built_in\">greedyDecodeMap</span>(*m_dicCrypt, inputBuffer, m_crypter);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span></span></span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    MiniPBCoder::<span class=\"built_in\">greedyDecodeMap</span>(*m_dic, inputBuffer);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">ifndef</span> MMKV_DISABLE_CRYPT</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (m_crypter) &#123;</span><br><span class=\"line\">                    MiniPBCoder::<span class=\"built_in\">decodeMap</span>(*m_dicCrypt, inputBuffer, m_crypter);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span></span></span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    MiniPBCoder::<span class=\"built_in\">decodeMap</span>(*m_dic, inputBuffer);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            m_output = <span class=\"keyword\">new</span> <span class=\"built_in\">CodedOutputData</span>(ptr + Fixed32Size, m_file-&gt;<span class=\"built_in\">getFileSize</span>() - Fixed32Size);</span><br><span class=\"line\">            m_output-&gt;<span class=\"built_in\">seek</span>(m_actualSize);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (needFullWriteback) &#123;</span><br><span class=\"line\">                <span class=\"built_in\">fullWriteback</span>();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// file not valid or empty, discard everything</span></span><br><span class=\"line\">            <span class=\"built_in\">SCOPED_LOCK</span>(m_exclusiveProcessLock);</span><br><span class=\"line\"></span><br><span class=\"line\">            m_output = <span class=\"keyword\">new</span> <span class=\"built_in\">CodedOutputData</span>(ptr + Fixed32Size, m_file-&gt;<span class=\"built_in\">getFileSize</span>() - Fixed32Size);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (m_actualSize &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                <span class=\"built_in\">writeActualSize</span>(<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"literal\">nullptr</span>, IncreaseSequence);</span><br><span class=\"line\">                <span class=\"built_in\">sync</span>(MMKV_SYNC);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"built_in\">writeActualSize</span>(<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"literal\">nullptr</span>, KeepSequence);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">\t\t\t\t...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    m_needLoadFromFile = <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>总统来说就是在初始化的时候就会将基于<code>protobuf</code>协议的本地文件里面的数据加载到内存，并将其放在一个 map 内，方便后续使用。</p>\n<p>回到 <code>int32_t MMKV::getInt32()</code>通过 <code>getDataForKey(key)</code>获取到一个<code>MMBuffer</code>对象，并通过 <strong>CodedInputData</strong>进行反序列化操作，读取 <strong>Varint32</strong> 的 <strong>valueSize</strong> 值，随后不断循环通过 <strong>CodedInputData</strong>  读取到<strong>value</strong> 值。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int32_t</span> <span class=\"title\">MMKV::getInt32</span><span class=\"params\">(MMKVKey_t key, <span class=\"type\">int32_t</span> defaultValue, <span class=\"type\">bool</span> *hasValue)</span> </span>&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"keyword\">auto</span> data = <span class=\"built_in\">getDataForKey</span>(key);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (data.<span class=\"built_in\">length</span>() &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"function\">CodedInputData <span class=\"title\">input</span><span class=\"params\">(data.getPtr(), data.length())</span></span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (hasValue != <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">                *hasValue = <span class=\"literal\">true</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> input.<span class=\"built_in\">readInt32</span>();</span><br><span class=\"line\">        &#125; </span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  \t...</span><br><span class=\"line\">    <span class=\"keyword\">return</span> defaultValue;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h2 id=\"mmkv-与-SharedPreferences\"><a href=\"#mmkv-与-SharedPreferences\" class=\"headerlink\" title=\"mmkv 与 SharedPreferences\"></a>mmkv 与 SharedPreferences</h2><p>以下是 <strong>MMKV</strong> 与 <strong>SharedPreferences</strong> 的优劣势对比总结，结合性能、安全性、功能支持等核心维度进行分析：</p>\n<h3 id=\"性能对比\"><a href=\"#性能对比\" class=\"headerlink\" title=\"性能对比\"></a><strong>性能对比</strong></h3><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\"><strong>维度</strong></th>\n<th style=\"text-align:left\"><strong>SharedPreferences</strong></th>\n<th style=\"text-align:left\"><strong>MMKV</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\"><strong>读写速度</strong></td>\n<td style=\"text-align:left\">慢（同步 I/O，多次数据拷贝）</td>\n<td style=\"text-align:left\">快（<code>mmap</code> 零拷贝，内存直接操作）</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>线程安全</strong></td>\n<td style=\"text-align:left\">需自行加锁（<code>apply()</code> 异步写入仍有风险）</td>\n<td style=\"text-align:left\">内置多线程锁（文件锁 + 内存锁）</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>大数据量支持</strong></td>\n<td style=\"text-align:left\">性能急剧下降（全量 XML 解析/序列化）</td>\n<td style=\"text-align:left\">高效（增量更新，Protobuf 编码）</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h3 id=\"安全性与稳定性\"><a href=\"#安全性与稳定性\" class=\"headerlink\" title=\"安全性与稳定性\"></a><strong>安全性与稳定性</strong></h3><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\"><strong>维度</strong></th>\n<th style=\"text-align:left\"><strong>SharedPreferences</strong></th>\n<th style=\"text-align:left\"><strong>MMKV</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\"><strong>数据加密</strong></td>\n<td style=\"text-align:left\">无（明文存储）</td>\n<td style=\"text-align:left\">支持 AES-128/AES-256 加密</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>崩溃恢复</strong></td>\n<td style=\"text-align:left\">可能因异常导致 XML 损坏</td>\n<td style=\"text-align:left\">通过 CRC 校验 + 备份文件保障完整性</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>系统版本适配</strong></td>\n<td style=\"text-align:left\">部分版本有 ANR 问题（如 <code>apply()</code>）</td>\n<td style=\"text-align:left\">无系统级兼容性问题</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h3 id=\"功能支持\"><a href=\"#功能支持\" class=\"headerlink\" title=\"功能支持\"></a><strong>功能支持</strong></h3><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\"><strong>维度</strong></th>\n<th style=\"text-align:left\"><strong>SharedPreferences</strong></th>\n<th style=\"text-align:left\"><strong>MMKV</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\"><strong>多进程</strong></td>\n<td style=\"text-align:left\">不支持（跨进程数据不同步）</td>\n<td style=\"text-align:left\">支持（通过文件锁 + <code>mmap</code> 共享内存）</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>数据类型</strong></td>\n<td style=\"text-align:left\">仅支持基本类型（int/String 等）</td>\n<td style=\"text-align:left\">支持基本类型、二进制数据（MMBuffer）</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>加密存储</strong></td>\n<td style=\"text-align:left\">明文存储（XML）</td>\n<td style=\"text-align:left\">支持 AES 加密（可选）</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>增量更新</strong></td>\n<td style=\"text-align:left\">全量写入（即使只改一个键值）</td>\n<td style=\"text-align:left\">仅追加新数据，定期整理</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>从上面的对比看看，mmkv 在很多层面都是领先 SharedPreferences 的，那么 mmkv 是否有缺陷呢？答案是有的。</p>\n<blockquote>\n<p>任何的操作系统、任何的软件，在往磁盘写数据的过程中如果发生了意外——例如程序崩溃，或者断电关机——磁盘里的文件就会以这种写了一半的、不完整的形式被保留。写了一半的数据怎么用啊？没法用，这就是文件的损坏。这种问题是不可能避免的，MMKV 虽然由于底层机制的原因，在程序崩溃的时候不会影响数据往磁盘的写入，但断电关机之类的操作系统级别的崩溃，MMKV 就没办法了，文件照样会损坏。对于这种文件损坏，SharedPreferences 和 DataStore 的应对方式是在每次写入新数据之前都对现有文件做一次自动备份，这样在发生了意外出现了文件损坏之后，它们就会把备份的数据恢复过来；而 MMKV，没有这种自动的备份和恢复，那么当文件发生了损坏，数据就丢了，之前保存的各种信息只能被重置。也就是说，MMKV 是唯一会丢数据的方案。</p>\n</blockquote>\n<p>在 mmkv 里面有 <a href=\"https://info.support.huawei.com/info-finder/encyclopedia/zh/CRC.html\">CRC</a> 校验，如果不通过的话，将会废弃掉之前所有的数据。在 mmkv 里面也有人反馈：<a href=\"https://github.com/Tencent/MMKV/issues/729\">https://github.com/Tencent/MMKV/issues/729</a> 在写入的过程中因为一些特殊情况写入失败，会导致本地的文件损坏且不可recovery。</p>\n<p>那有什么办法避免这个问题呢？有大佬开源另一个 KV 框架 <a href=\"https://github.com/BillyWei01/FastKV\">FastKV</a>对这个问题进行了处理，采用通过double-write等方法确保数据的完整性，原理是数据依次写入A/B两个文件，如果写入A过程中崩溃，B仍是完整的，如果A完整写入了，则B写入时崩溃也不要紧。这种实现方式理论上是不错的，不太清楚 mmkv 为什么没有采取这样的逻辑。不过这个库并没有经过大量业务进行验证，只能作为一个学习的方案先看看。</p>\n<p>另外谷歌已经开发了新的KV存储框架<a href=\"https://cloud.google.com/datastore/docs/concepts/overview?hl=zh-cn\">DataStore</a>，<code>SharedPreferences</code>也将渐渐地退出历史的舞台了。不过 DataStore 的性能目前仍然没有 mmkv 的好。关于这三者的比较可以查看： <a href=\"https://juejin.cn/post/7112268981163016229\">《Android 的键值对存储有没有最优解？》</a></p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>这篇文章深入剖析了 <strong>MMKV</strong>（腾讯开源的高性能键值存储组件）的核心设计与实现原理，重点对比了传统 I/O 与 <code>mmap</code> 内存映射的差异，并详细分析了 MMKV 的读写流程以及和 SharedPreferences 的各方面对比。</p>\n<p><strong>参考</strong></p>\n<p><a href=\"https://juejin.cn/post/7112268981163016229\">《Android 的键值对存储有没有最优解？》</a></p>\n<p><a href=\"https://yangjie2.github.io/2021/11/14/mmap%E5%8E%9F%E7%90%86%E4%B8%8E%E5%BA%94%E7%94%A8/\">《mmap原理与应用》</a></p>\n<p><a href=\"https://blog.csdn.net/zhanglh046/article/details/115603788\">《文件内存映射和传统I/O机制》</a></p>\n<p><a href=\"https://blog.csdn.net/luo_boke/article/details/109311432\">Android 内存映射mmap浅谈</a></p>\n","categories":[],"tags":[{"name":"mmap","slug":"mmap","api":"api/tags/mmap.json"}],"api":"api/posts/2025/03/30/KV-存储之mmkv.json"},{"title":"RetroFit2 源码学习相关","slug":"Learn-from-RetroFit","date":"2025-03-17T12:28:00.000Z","updated":"2025-05-20T11:46:57.000Z","comments":true,"url":"2025/03/17/Learn-from-RetroFit/","excerpt":"<p>研究 <a href=\"https://github.com/square/retrofit\">retrofit</a> 目标：理解动态代理、注解、反射、学习它所用到的设计模式，达到自己能手写它的核心实现。</p>\n<p>最近终于有点精力能够去研究研究源码了， 真的是写的一个非常好的的开源库，以前刚接触安卓的时候扒拉过相关的源码，但是随着工作了几年之后，经验的积累，让我对源码里面的东西能够体会更深刻，自己也尝试去手写里面的核心实现，看完源码对整体的架构理解了之后，以为自己能很顺利的写下来，实则不然。<br>知识还是需要知行合一，这篇文章主要记录 <a href=\"https://github.com/square/retrofit\">retrofit</a>  的一些知识点。</p>\n<h3 id=\"retrofit-的设计模式\"><a href=\"#retrofit-的设计模式\" class=\"headerlink\" title=\"retrofit 的设计模式\"></a>retrofit 的设计模式</h3><p>retrofit 里面中使用了多种设计模式，以实现其灵活、可扩展和高性能的特性：</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">设计模式</th>\n<th style=\"text-align:left\">应用场景</th>\n<th style=\"text-align:left\">作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\"><strong>建造者模式</strong></td>\n<td style=\"text-align:left\"><code>Retrofit.Builder</code></td>\n<td style=\"text-align:left\">灵活配置 Retrofit 实例</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>工厂模式</strong></td>\n<td style=\"text-align:left\"><code>Converter.Factory</code>、<code>CallAdapter.Factory</code></td>\n<td style=\"text-align:left\">创建 Converter 和 CallAdapter 实例</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>动态代理模式</strong></td>\n<td style=\"text-align:left\">接口方法转换为 HTTP 请求</td>\n<td style=\"text-align:left\">运行时生成接口代理对象</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>适配器模式</strong></td>\n<td style=\"text-align:left\"><code>CallAdapter</code></td>\n<td style=\"text-align:left\">将 <code>Call</code> 适配为其他类型</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>装饰器模式</strong></td>\n<td style=\"text-align:left\"><code>OkHttp</code> 拦截器</td>\n<td style=\"text-align:left\">增强 HTTP 请求和响应的功能</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>观察者模式</strong></td>\n<td style=\"text-align:left\">与 <code>RxJava</code> 或 <code>LiveData</code> 结合</td>\n<td style=\"text-align:left\">实现异步数据流的订阅和通知</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>策略模式</strong></td>\n<td style=\"text-align:left\"><code>Converter</code> 和 <code>CallAdapter</code> 选择</td>\n<td style=\"text-align:left\">动态选择数据转换或调用适配策略</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>单例模式</strong></td>\n<td style=\"text-align:left\"><code>Retrofit</code> 实例共享</td>\n<td style=\"text-align:left\">确保全局只有一个 Retrofit 实例</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>模板方法模式</strong></td>\n<td style=\"text-align:left\"><code>Call</code> 的实现</td>\n<td style=\"text-align:left\">定义 HTTP 请求的执行流程</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p><strong>retrofit 的动态代理模式</strong></p>\n<p>retrofit 用了诸多的设计模式，其中最经典的莫过于动态代理模式了，在了解 retrofit 之前，我一直以为这样的网络请求形式是最直观的，参考以前写的<a href=\"https://julis.wang/2019/05/13/%E5%9F%BA%E4%BA%8EVolley%E6%A1%86%E6%9E%B6%E7%9A%84%E8%BF%94%E5%9B%9E%E6%95%B0%E6%8D%AE%E7%9A%84%E8%8C%83%E5%9E%8B%E5%A4%84%E7%90%86/\">基于Volley框架的返回数据的范型处理</a></p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"code\"><pre><span class=\"line\">Request.<span class=\"keyword\">get</span>(</span><br><span class=\"line\">    url = url,</span><br><span class=\"line\">    params = param,</span><br><span class=\"line\">    listener = <span class=\"keyword\">object</span> : OnRequestListener&lt;Data&gt; &#123;</span><br><span class=\"line\">        <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onSuccess</span><span class=\"params\">(commonData: <span class=\"type\">CommonData</span>?, <span class=\"keyword\">data</span>: <span class=\"type\">Data</span>?)</span></span> &#123;&#125;</span><br><span class=\"line\">        <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onFailure</span><span class=\"params\">(errorCode: <span class=\"type\">Int</span>, errorMessage: <span class=\"type\">String</span>?)</span></span> &#123;&#125;</span><br><span class=\"line\">    &#125;)</span><br></pre></td></tr></table></figure>\n<p>以为这样很直观，逻辑也很清晰，实则 代码冗余，回调嵌套，如果有多个连续的请求，代码会变得难以维护，而 retrofit 搭配上协程能这样实现：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> <span class=\"keyword\">data</span> = apiService.getXXX(params)</span><br></pre></td></tr></table></figure>\n<p>简单到不能再简单，<code>动态代理</code>功不可没，上面的 apiService 是一个接口，由：<code>retrofit.create(ApiInterface::class.java)</code> 生成其实例，动态代理其核心实现：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> &lt;T&gt; T <span class=\"title function_\">create</span><span class=\"params\">(<span class=\"keyword\">final</span> Class&lt;T&gt; service)</span> &#123;</span><br><span class=\"line\">    validateServiceInterface(service);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (T)</span><br><span class=\"line\">        Proxy.newProxyInstance(</span><br><span class=\"line\">            service.getClassLoader(),</span><br><span class=\"line\">            <span class=\"keyword\">new</span> <span class=\"title class_\">Class</span>&lt;?&gt;[] &#123;service&#125;,</span><br><span class=\"line\">            <span class=\"keyword\">new</span> <span class=\"title class_\">InvocationHandler</span>() &#123;</span><br><span class=\"line\">              <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"type\">Platform</span> <span class=\"variable\">platform</span> <span class=\"operator\">=</span> Platform.get();</span><br><span class=\"line\">              <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Object[] emptyArgs = <span class=\"keyword\">new</span> <span class=\"title class_\">Object</span>[<span class=\"number\">0</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">              <span class=\"meta\">@Override</span></span><br><span class=\"line\">              <span class=\"keyword\">public</span> <span class=\"meta\">@Nullable</span> Object <span class=\"title function_\">invoke</span><span class=\"params\">(Object proxy, Method method, <span class=\"meta\">@Nullable</span> Object[] args)</span> <span class=\"keyword\">throws</span> Throwable &#123;</span><br><span class=\"line\">                <span class=\"comment\">// ....</span></span><br><span class=\"line\">                <span class=\"keyword\">return</span> platform.isDefaultMethod(method)</span><br><span class=\"line\">                    ? platform.invokeDefaultMethod(method, service, proxy, args)</span><br><span class=\"line\">                    : loadServiceMethod(method).invoke(args);</span><br><span class=\"line\">              &#125;</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<p>由<code>loadServiceMethod(method).invoke(args)</code> 负责将接口方法（通过 Java 反射获取的 <code>Method</code> 对象）解析并转换为一个可执行的 HTTP 请求。</p>\n<p><code>Proxy.newProxyInstance</code> 方法，参数：</p>\n<ul>\n<li><p>ClassLoader loader 用于加载代理类的类加载器。</p>\n</li>\n<li><p>Class&lt;?&gt;[] interfaces 代理类需要实现的接口数组，代理对象将实现这些接口，并拦截对这些接口方法的调用。只能代理实现了接口的类，不能代理没有接口的类。</p>\n</li>\n<li><p>InvocationHandler h<br>调用处理器，负责处理代理对象上的方法调用。每次调用代理对象的方法时，都会调用 <code>InvocationHandler</code> 的 <code>invoke</code> 方法。对于 Retrofit 的接口我们并没有去“实现”它的方法，所有的逻辑都由<code>` retrofit.create()</code>方法里面返回的 <code>InvocationHandler</code>实现的 <code>invoke</code>方法实现的。</p>\n</li>\n</ul>\n<h3 id=\"核心实现逻辑\"><a href=\"#核心实现逻辑\" class=\"headerlink\" title=\"核心实现逻辑\"></a>核心实现逻辑</h3><h4 id=\"协程的支持\"><a href=\"#协程的支持\" class=\"headerlink\" title=\"协程的支持\"></a><strong>协程的支持</strong></h4><p>Retrofit 支持多种异步编程模型，包括回调、RxJava 和协程等，这里主要记录一下对协程的支持。普通方法和异步逻辑的分叉在：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (!isKotlinSuspendFunction) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> new CallAdapted&lt;&gt;(requestFactory, callFactory, responseConverter, callAdapter);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (continuationWantsResponse) &#123;</span><br><span class=\"line\">      <span class=\"comment\">//noinspection unchecked Kotlin compiler guarantees ReturnT to be Object.</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> (HttpServiceMethod&lt;ResponseT, ReturnT&gt;)</span><br><span class=\"line\">          new SuspendForResponse&lt;&gt;(</span><br><span class=\"line\">              requestFactory,</span><br><span class=\"line\">              callFactory,</span><br><span class=\"line\">              responseConverter,</span><br><span class=\"line\">              (CallAdapter&lt;ResponseT, Call&lt;ResponseT&gt;&gt;) callAdapter);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">//noinspection unchecked Kotlin compiler guarantees ReturnT to be Object.</span></span><br><span class=\"line\">\t\t\t<span class=\"comment\">//...</span></span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>上面代码关键变量<code>isKotlinSuspendFunction</code> ，用于判断是否为协程方法（suspend修饰），判断逻辑很简单，只需要判定方法最后一个参数是否为<code>Continuation.class</code> 即可。这里的分叉逻辑都继承自<code>HttpServiceMethod&lt;T&gt;</code>实现 <code>ReturnT adapt(Call&lt;ResponseT&gt; call, Object[] args)</code>这个抽象方法，这也是 retrofit 使用 <strong>适配器模式</strong>的地方，把不同的调用方式进行统一。对于协程方式的调用有实现：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">protected</span> Object adapt(Call&lt;ResponseT&gt; call, Object[] args) &#123;</span><br><span class=\"line\">      call = callAdapter.adapt(call);</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">//noinspection unchecked Checked by reflection inside RequestFactory.</span></span><br><span class=\"line\">      Continuation&lt;Response&lt;ResponseT&gt;&gt; continuation =</span><br><span class=\"line\">          (Continuation&lt;Response&lt;ResponseT&gt;&gt;) args[args.length - <span class=\"number\">1</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">// See SuspendForBody for explanation about this try/catch.</span></span><br><span class=\"line\">      <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> KotlinExtensions.awaitResponse(call, continuation);</span><br><span class=\"line\">      &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>.suspendAndThrow(e, continuation);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">suspend</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"type\">&lt;T&gt;</span> Call<span class=\"type\">&lt;T&gt;</span>.<span class=\"title\">awaitResponse</span><span class=\"params\">()</span></span>: Response&lt;T&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> suspendCancellableCoroutine &#123; continuation -&gt;</span><br><span class=\"line\">    continuation.invokeOnCancellation &#123;</span><br><span class=\"line\">      cancel()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    enqueue(<span class=\"keyword\">object</span> : Callback&lt;T&gt; &#123;</span><br><span class=\"line\">      <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onResponse</span><span class=\"params\">(call: <span class=\"type\">Call</span>&lt;<span class=\"type\">T</span>&gt;, response: <span class=\"type\">Response</span>&lt;<span class=\"type\">T</span>&gt;)</span></span> &#123;</span><br><span class=\"line\">        continuation.resume(response)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onFailure</span><span class=\"params\">(call: <span class=\"type\">Call</span>&lt;<span class=\"type\">T</span>&gt;, t: <span class=\"type\">Throwable</span>)</span></span> &#123;</span><br><span class=\"line\">        continuation.resumeWithException(t)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里就一切都明朗了，实现了 <code>Call</code>的扩展方法，这里的 <code>Call</code>并不是 <code>okhttp3.Call</code>，它只是 retrofit  <code>okhttp3.Call</code>为方便框架整体逻辑的处理而定义的，比如 retrofit 的 <code>Call</code> 是泛型化的，可以直接返回解析后的对象，<code>enqueue</code>同理。</p>\n<p><code>suspendCancellableCoroutine</code>方法是实现协程方法的关键，它可以将基于回调的异步操作封装成一个挂起函数，怎么理解呢？对 扩展方法<code>awaitResponse</code>反编译可以看到方法定义是这样的：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Object <span class=\"title function_\">await</span><span class=\"params\">(<span class=\"meta\">@NotNull</span> Call $<span class=\"built_in\">this</span>$await, <span class=\"meta\">@NotNull</span> Continuation $completion)</span> </span><br></pre></td></tr></table></figure>\n<p>其实这里跟定义一个 <code>listener</code>去监听方法的回调有点像，这个方法改写成 <code>listener</code>的实现话大概就是这样：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"type\">&lt;T&gt;</span> Call<span class=\"type\">&lt;T&gt;</span>.<span class=\"title\">awaitResponse</span><span class=\"params\">(listener:<span class=\"type\">Listener</span>&lt;<span class=\"type\">T</span>&gt;)</span></span>: Response&lt;T&gt; &#123;</span><br><span class=\"line\">        enqueue(<span class=\"keyword\">object</span> : Callback&lt;T&gt; &#123;</span><br><span class=\"line\">            <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onResponse</span><span class=\"params\">(call: <span class=\"type\">Call</span>&lt;<span class=\"type\">T</span>&gt;, response: <span class=\"type\">Response</span>&lt;<span class=\"type\">T</span>&gt;)</span></span> &#123;</span><br><span class=\"line\">                Listener.resume(response)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onFailure</span><span class=\"params\">(call: <span class=\"type\">Call</span>&lt;<span class=\"type\">T</span>&gt;, t: <span class=\"type\">Throwable</span>)</span></span> &#123;</span><br><span class=\"line\">                Listener.resumeWithException(t)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>可看到改造实现需要传递一个 <code>listener</code>，哪这个 <code>listener</code>是什么？前面其有如何判断一个方法是否为协程的方法的逻辑：判定方法最后一个参数是否为<code>Continuation.class</code> 即可。这里的  <code>listener</code> 其实可以等价于 一个 <code>Continuation</code>实例，kotlin 的协程库帮我们实现了对应的封装，对于使用我们不会直观地感受<code>Continuation</code>的存在，实际它贯穿整个协程。关于协程这里不再赘述，可以查看 <a href=\"https://juejin.cn/post/7142743424670629895?searchId=202503230943390124BC33C1668EC4B62B\">《带着问题分析Kotlin协程原理》</a>了解。</p>\n<h3 id=\"返回数据格式的解析\"><a href=\"#返回数据格式的解析\" class=\"headerlink\" title=\"返回数据格式的解析\"></a><strong>返回数据格式的解析</strong></h3><p>对于<strong>Converter</strong>,在协程和普通方法调用分叉逻辑的前面点：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"code\"><pre><span class=\"line\">Converter&lt;ResponseBody, ResponseT&gt; responseConverter = createResponseConverter(retrofit, method, responseType);</span><br></pre></td></tr></table></figure>\n<p><code>createResponseConverter</code>之后一路走到</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> &lt;T&gt; Converter&lt;ResponseBody, T&gt; nextResponseBodyConverter(</span><br><span class=\"line\">    <span class=\"meta\">@Nullable</span> Converter.Factory skipPast, Type type, Annotation[] annotations) &#123;</span><br><span class=\"line\">  Objects.requireNonNull(type, <span class=\"string\">&quot;type == null&quot;</span>);</span><br><span class=\"line\">  Objects.requireNonNull(annotations, <span class=\"string\">&quot;annotations == null&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  int start = converterFactories.indexOf(skipPast) + <span class=\"number\">1</span>;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (int i = start, count = converterFactories.size(); i &lt; count; i++) &#123;</span><br><span class=\"line\">    Converter&lt;ResponseBody, ?&gt; converter =</span><br><span class=\"line\">        converterFactories.<span class=\"keyword\">get</span>(i).responseBodyConverter(type, annotations, <span class=\"keyword\">this</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (converter != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">      <span class=\"comment\">//noinspection unchecked</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> (Converter&lt;ResponseBody, T&gt;) converter;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>converterFactories</code> 的值就是在 retrofit 初始化的时候进行使用  <code>public Builder addConverterFactory(Converter.Factory factory)</code>添加的值。可以看到是按添加到<code>List&lt;Converter.Factory&gt; converterFactories</code>里面的顺序进行选择的，默认<code>GsonConverterFactory</code>实现了利用 <code>Gson</code>进行数据转化 ，如果我们自己实现<code>Converter.Factory</code>的接口的话，那么可以根据一定的规则判断是否要返回我们自定义的 <code>Converter</code>，如果不需要使用就返回 null，会自动匹配下一个能使用的 <code>Converter</code>。注意这里并不会因为前一个  <code>Converter</code> 解析失败而自动尝试使用下一个<code>Converter</code>（当然，你可以在自定义的<code>Converter</code>里面做类似这样的尝试策略）。</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><ul>\n<li><p>这篇文章深入剖析了 <strong>Retrofit</strong> 框架的核心设计模式、动态代理机制、协程支持以及数据解析逻辑，通过源码分析和手写实现，帮助读者更好地理解 Retrofit 的工作原理，并强调了理论与实践结合的重要性。</p>\n</li>\n<li><p>为加深对 retrofit 的理解，可以尝试手写核心实现，自己尝试的的代码在 <a href=\"https://github.com/VomPom/JProject/tree/master/app/src/main/java/wang/julis/jproject/example/source/retrofit2/learn/vmfit\">vmfit</a> </p>\n</li>\n<li><p>附一张 retrofit 的全流程图，来源：<a href=\"https://cloud.tencent.com/developer/article/1683334\">https://cloud.tencent.com/developer/article/1683334</a></p>\n</li>\n</ul>\n<img src=\"https://cdn.julis.wang/blog/img/ru5ssbhumq.jpeg\">","cover":null,"images":["https://cdn.julis.wang/blog/img/ru5ssbhumq.jpeg"],"content":"<p>研究 <a href=\"https://github.com/square/retrofit\">retrofit</a> 目标：理解动态代理、注解、反射、学习它所用到的设计模式，达到自己能手写它的核心实现。</p>\n<p>最近终于有点精力能够去研究研究源码了， 真的是写的一个非常好的的开源库，以前刚接触安卓的时候扒拉过相关的源码，但是随着工作了几年之后，经验的积累，让我对源码里面的东西能够体会更深刻，自己也尝试去手写里面的核心实现，看完源码对整体的架构理解了之后，以为自己能很顺利的写下来，实则不然。<br>知识还是需要知行合一，这篇文章主要记录 <a href=\"https://github.com/square/retrofit\">retrofit</a>  的一些知识点。</p>\n<h3 id=\"retrofit-的设计模式\"><a href=\"#retrofit-的设计模式\" class=\"headerlink\" title=\"retrofit 的设计模式\"></a>retrofit 的设计模式</h3><p>retrofit 里面中使用了多种设计模式，以实现其灵活、可扩展和高性能的特性：</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">设计模式</th>\n<th style=\"text-align:left\">应用场景</th>\n<th style=\"text-align:left\">作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\"><strong>建造者模式</strong></td>\n<td style=\"text-align:left\"><code>Retrofit.Builder</code></td>\n<td style=\"text-align:left\">灵活配置 Retrofit 实例</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>工厂模式</strong></td>\n<td style=\"text-align:left\"><code>Converter.Factory</code>、<code>CallAdapter.Factory</code></td>\n<td style=\"text-align:left\">创建 Converter 和 CallAdapter 实例</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>动态代理模式</strong></td>\n<td style=\"text-align:left\">接口方法转换为 HTTP 请求</td>\n<td style=\"text-align:left\">运行时生成接口代理对象</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>适配器模式</strong></td>\n<td style=\"text-align:left\"><code>CallAdapter</code></td>\n<td style=\"text-align:left\">将 <code>Call</code> 适配为其他类型</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>装饰器模式</strong></td>\n<td style=\"text-align:left\"><code>OkHttp</code> 拦截器</td>\n<td style=\"text-align:left\">增强 HTTP 请求和响应的功能</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>观察者模式</strong></td>\n<td style=\"text-align:left\">与 <code>RxJava</code> 或 <code>LiveData</code> 结合</td>\n<td style=\"text-align:left\">实现异步数据流的订阅和通知</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>策略模式</strong></td>\n<td style=\"text-align:left\"><code>Converter</code> 和 <code>CallAdapter</code> 选择</td>\n<td style=\"text-align:left\">动态选择数据转换或调用适配策略</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>单例模式</strong></td>\n<td style=\"text-align:left\"><code>Retrofit</code> 实例共享</td>\n<td style=\"text-align:left\">确保全局只有一个 Retrofit 实例</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>模板方法模式</strong></td>\n<td style=\"text-align:left\"><code>Call</code> 的实现</td>\n<td style=\"text-align:left\">定义 HTTP 请求的执行流程</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p><strong>retrofit 的动态代理模式</strong></p>\n<p>retrofit 用了诸多的设计模式，其中最经典的莫过于动态代理模式了，在了解 retrofit 之前，我一直以为这样的网络请求形式是最直观的，参考以前写的<a href=\"https://julis.wang/2019/05/13/%E5%9F%BA%E4%BA%8EVolley%E6%A1%86%E6%9E%B6%E7%9A%84%E8%BF%94%E5%9B%9E%E6%95%B0%E6%8D%AE%E7%9A%84%E8%8C%83%E5%9E%8B%E5%A4%84%E7%90%86/\">基于Volley框架的返回数据的范型处理</a></p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"code\"><pre><span class=\"line\">Request.<span class=\"keyword\">get</span>(</span><br><span class=\"line\">    url = url,</span><br><span class=\"line\">    params = param,</span><br><span class=\"line\">    listener = <span class=\"keyword\">object</span> : OnRequestListener&lt;Data&gt; &#123;</span><br><span class=\"line\">        <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onSuccess</span><span class=\"params\">(commonData: <span class=\"type\">CommonData</span>?, <span class=\"keyword\">data</span>: <span class=\"type\">Data</span>?)</span></span> &#123;&#125;</span><br><span class=\"line\">        <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onFailure</span><span class=\"params\">(errorCode: <span class=\"type\">Int</span>, errorMessage: <span class=\"type\">String</span>?)</span></span> &#123;&#125;</span><br><span class=\"line\">    &#125;)</span><br></pre></td></tr></table></figure>\n<p>以为这样很直观，逻辑也很清晰，实则 代码冗余，回调嵌套，如果有多个连续的请求，代码会变得难以维护，而 retrofit 搭配上协程能这样实现：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> <span class=\"keyword\">data</span> = apiService.getXXX(params)</span><br></pre></td></tr></table></figure>\n<p>简单到不能再简单，<code>动态代理</code>功不可没，上面的 apiService 是一个接口，由：<code>retrofit.create(ApiInterface::class.java)</code> 生成其实例，动态代理其核心实现：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> &lt;T&gt; T <span class=\"title function_\">create</span><span class=\"params\">(<span class=\"keyword\">final</span> Class&lt;T&gt; service)</span> &#123;</span><br><span class=\"line\">    validateServiceInterface(service);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (T)</span><br><span class=\"line\">        Proxy.newProxyInstance(</span><br><span class=\"line\">            service.getClassLoader(),</span><br><span class=\"line\">            <span class=\"keyword\">new</span> <span class=\"title class_\">Class</span>&lt;?&gt;[] &#123;service&#125;,</span><br><span class=\"line\">            <span class=\"keyword\">new</span> <span class=\"title class_\">InvocationHandler</span>() &#123;</span><br><span class=\"line\">              <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"type\">Platform</span> <span class=\"variable\">platform</span> <span class=\"operator\">=</span> Platform.get();</span><br><span class=\"line\">              <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Object[] emptyArgs = <span class=\"keyword\">new</span> <span class=\"title class_\">Object</span>[<span class=\"number\">0</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">              <span class=\"meta\">@Override</span></span><br><span class=\"line\">              <span class=\"keyword\">public</span> <span class=\"meta\">@Nullable</span> Object <span class=\"title function_\">invoke</span><span class=\"params\">(Object proxy, Method method, <span class=\"meta\">@Nullable</span> Object[] args)</span> <span class=\"keyword\">throws</span> Throwable &#123;</span><br><span class=\"line\">                <span class=\"comment\">// ....</span></span><br><span class=\"line\">                <span class=\"keyword\">return</span> platform.isDefaultMethod(method)</span><br><span class=\"line\">                    ? platform.invokeDefaultMethod(method, service, proxy, args)</span><br><span class=\"line\">                    : loadServiceMethod(method).invoke(args);</span><br><span class=\"line\">              &#125;</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<p>由<code>loadServiceMethod(method).invoke(args)</code> 负责将接口方法（通过 Java 反射获取的 <code>Method</code> 对象）解析并转换为一个可执行的 HTTP 请求。</p>\n<p><code>Proxy.newProxyInstance</code> 方法，参数：</p>\n<ul>\n<li><p>ClassLoader loader 用于加载代理类的类加载器。</p>\n</li>\n<li><p>Class&lt;?&gt;[] interfaces 代理类需要实现的接口数组，代理对象将实现这些接口，并拦截对这些接口方法的调用。只能代理实现了接口的类，不能代理没有接口的类。</p>\n</li>\n<li><p>InvocationHandler h<br>调用处理器，负责处理代理对象上的方法调用。每次调用代理对象的方法时，都会调用 <code>InvocationHandler</code> 的 <code>invoke</code> 方法。对于 Retrofit 的接口我们并没有去“实现”它的方法，所有的逻辑都由<code>` retrofit.create()</code>方法里面返回的 <code>InvocationHandler</code>实现的 <code>invoke</code>方法实现的。</p>\n</li>\n</ul>\n<h3 id=\"核心实现逻辑\"><a href=\"#核心实现逻辑\" class=\"headerlink\" title=\"核心实现逻辑\"></a>核心实现逻辑</h3><h4 id=\"协程的支持\"><a href=\"#协程的支持\" class=\"headerlink\" title=\"协程的支持\"></a><strong>协程的支持</strong></h4><p>Retrofit 支持多种异步编程模型，包括回调、RxJava 和协程等，这里主要记录一下对协程的支持。普通方法和异步逻辑的分叉在：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (!isKotlinSuspendFunction) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> new CallAdapted&lt;&gt;(requestFactory, callFactory, responseConverter, callAdapter);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (continuationWantsResponse) &#123;</span><br><span class=\"line\">      <span class=\"comment\">//noinspection unchecked Kotlin compiler guarantees ReturnT to be Object.</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> (HttpServiceMethod&lt;ResponseT, ReturnT&gt;)</span><br><span class=\"line\">          new SuspendForResponse&lt;&gt;(</span><br><span class=\"line\">              requestFactory,</span><br><span class=\"line\">              callFactory,</span><br><span class=\"line\">              responseConverter,</span><br><span class=\"line\">              (CallAdapter&lt;ResponseT, Call&lt;ResponseT&gt;&gt;) callAdapter);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">//noinspection unchecked Kotlin compiler guarantees ReturnT to be Object.</span></span><br><span class=\"line\">\t\t\t<span class=\"comment\">//...</span></span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>上面代码关键变量<code>isKotlinSuspendFunction</code> ，用于判断是否为协程方法（suspend修饰），判断逻辑很简单，只需要判定方法最后一个参数是否为<code>Continuation.class</code> 即可。这里的分叉逻辑都继承自<code>HttpServiceMethod&lt;T&gt;</code>实现 <code>ReturnT adapt(Call&lt;ResponseT&gt; call, Object[] args)</code>这个抽象方法，这也是 retrofit 使用 <strong>适配器模式</strong>的地方，把不同的调用方式进行统一。对于协程方式的调用有实现：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">protected</span> Object adapt(Call&lt;ResponseT&gt; call, Object[] args) &#123;</span><br><span class=\"line\">      call = callAdapter.adapt(call);</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">//noinspection unchecked Checked by reflection inside RequestFactory.</span></span><br><span class=\"line\">      Continuation&lt;Response&lt;ResponseT&gt;&gt; continuation =</span><br><span class=\"line\">          (Continuation&lt;Response&lt;ResponseT&gt;&gt;) args[args.length - <span class=\"number\">1</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">// See SuspendForBody for explanation about this try/catch.</span></span><br><span class=\"line\">      <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> KotlinExtensions.awaitResponse(call, continuation);</span><br><span class=\"line\">      &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>.suspendAndThrow(e, continuation);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">suspend</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"type\">&lt;T&gt;</span> Call<span class=\"type\">&lt;T&gt;</span>.<span class=\"title\">awaitResponse</span><span class=\"params\">()</span></span>: Response&lt;T&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> suspendCancellableCoroutine &#123; continuation -&gt;</span><br><span class=\"line\">    continuation.invokeOnCancellation &#123;</span><br><span class=\"line\">      cancel()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    enqueue(<span class=\"keyword\">object</span> : Callback&lt;T&gt; &#123;</span><br><span class=\"line\">      <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onResponse</span><span class=\"params\">(call: <span class=\"type\">Call</span>&lt;<span class=\"type\">T</span>&gt;, response: <span class=\"type\">Response</span>&lt;<span class=\"type\">T</span>&gt;)</span></span> &#123;</span><br><span class=\"line\">        continuation.resume(response)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onFailure</span><span class=\"params\">(call: <span class=\"type\">Call</span>&lt;<span class=\"type\">T</span>&gt;, t: <span class=\"type\">Throwable</span>)</span></span> &#123;</span><br><span class=\"line\">        continuation.resumeWithException(t)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里就一切都明朗了，实现了 <code>Call</code>的扩展方法，这里的 <code>Call</code>并不是 <code>okhttp3.Call</code>，它只是 retrofit  <code>okhttp3.Call</code>为方便框架整体逻辑的处理而定义的，比如 retrofit 的 <code>Call</code> 是泛型化的，可以直接返回解析后的对象，<code>enqueue</code>同理。</p>\n<p><code>suspendCancellableCoroutine</code>方法是实现协程方法的关键，它可以将基于回调的异步操作封装成一个挂起函数，怎么理解呢？对 扩展方法<code>awaitResponse</code>反编译可以看到方法定义是这样的：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Object <span class=\"title function_\">await</span><span class=\"params\">(<span class=\"meta\">@NotNull</span> Call $<span class=\"built_in\">this</span>$await, <span class=\"meta\">@NotNull</span> Continuation $completion)</span> </span><br></pre></td></tr></table></figure>\n<p>其实这里跟定义一个 <code>listener</code>去监听方法的回调有点像，这个方法改写成 <code>listener</code>的实现话大概就是这样：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"type\">&lt;T&gt;</span> Call<span class=\"type\">&lt;T&gt;</span>.<span class=\"title\">awaitResponse</span><span class=\"params\">(listener:<span class=\"type\">Listener</span>&lt;<span class=\"type\">T</span>&gt;)</span></span>: Response&lt;T&gt; &#123;</span><br><span class=\"line\">        enqueue(<span class=\"keyword\">object</span> : Callback&lt;T&gt; &#123;</span><br><span class=\"line\">            <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onResponse</span><span class=\"params\">(call: <span class=\"type\">Call</span>&lt;<span class=\"type\">T</span>&gt;, response: <span class=\"type\">Response</span>&lt;<span class=\"type\">T</span>&gt;)</span></span> &#123;</span><br><span class=\"line\">                Listener.resume(response)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onFailure</span><span class=\"params\">(call: <span class=\"type\">Call</span>&lt;<span class=\"type\">T</span>&gt;, t: <span class=\"type\">Throwable</span>)</span></span> &#123;</span><br><span class=\"line\">                Listener.resumeWithException(t)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>可看到改造实现需要传递一个 <code>listener</code>，哪这个 <code>listener</code>是什么？前面其有如何判断一个方法是否为协程的方法的逻辑：判定方法最后一个参数是否为<code>Continuation.class</code> 即可。这里的  <code>listener</code> 其实可以等价于 一个 <code>Continuation</code>实例，kotlin 的协程库帮我们实现了对应的封装，对于使用我们不会直观地感受<code>Continuation</code>的存在，实际它贯穿整个协程。关于协程这里不再赘述，可以查看 <a href=\"https://juejin.cn/post/7142743424670629895?searchId=202503230943390124BC33C1668EC4B62B\">《带着问题分析Kotlin协程原理》</a>了解。</p>\n<h3 id=\"返回数据格式的解析\"><a href=\"#返回数据格式的解析\" class=\"headerlink\" title=\"返回数据格式的解析\"></a><strong>返回数据格式的解析</strong></h3><p>对于<strong>Converter</strong>,在协程和普通方法调用分叉逻辑的前面点：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"code\"><pre><span class=\"line\">Converter&lt;ResponseBody, ResponseT&gt; responseConverter = createResponseConverter(retrofit, method, responseType);</span><br></pre></td></tr></table></figure>\n<p><code>createResponseConverter</code>之后一路走到</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> &lt;T&gt; Converter&lt;ResponseBody, T&gt; nextResponseBodyConverter(</span><br><span class=\"line\">    <span class=\"meta\">@Nullable</span> Converter.Factory skipPast, Type type, Annotation[] annotations) &#123;</span><br><span class=\"line\">  Objects.requireNonNull(type, <span class=\"string\">&quot;type == null&quot;</span>);</span><br><span class=\"line\">  Objects.requireNonNull(annotations, <span class=\"string\">&quot;annotations == null&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  int start = converterFactories.indexOf(skipPast) + <span class=\"number\">1</span>;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (int i = start, count = converterFactories.size(); i &lt; count; i++) &#123;</span><br><span class=\"line\">    Converter&lt;ResponseBody, ?&gt; converter =</span><br><span class=\"line\">        converterFactories.<span class=\"keyword\">get</span>(i).responseBodyConverter(type, annotations, <span class=\"keyword\">this</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (converter != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">      <span class=\"comment\">//noinspection unchecked</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> (Converter&lt;ResponseBody, T&gt;) converter;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>converterFactories</code> 的值就是在 retrofit 初始化的时候进行使用  <code>public Builder addConverterFactory(Converter.Factory factory)</code>添加的值。可以看到是按添加到<code>List&lt;Converter.Factory&gt; converterFactories</code>里面的顺序进行选择的，默认<code>GsonConverterFactory</code>实现了利用 <code>Gson</code>进行数据转化 ，如果我们自己实现<code>Converter.Factory</code>的接口的话，那么可以根据一定的规则判断是否要返回我们自定义的 <code>Converter</code>，如果不需要使用就返回 null，会自动匹配下一个能使用的 <code>Converter</code>。注意这里并不会因为前一个  <code>Converter</code> 解析失败而自动尝试使用下一个<code>Converter</code>（当然，你可以在自定义的<code>Converter</code>里面做类似这样的尝试策略）。</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><ul>\n<li><p>这篇文章深入剖析了 <strong>Retrofit</strong> 框架的核心设计模式、动态代理机制、协程支持以及数据解析逻辑，通过源码分析和手写实现，帮助读者更好地理解 Retrofit 的工作原理，并强调了理论与实践结合的重要性。</p>\n</li>\n<li><p>为加深对 retrofit 的理解，可以尝试手写核心实现，自己尝试的的代码在 <a href=\"https://github.com/VomPom/JProject/tree/master/app/src/main/java/wang/julis/jproject/example/source/retrofit2/learn/vmfit\">vmfit</a> </p>\n</li>\n<li><p>附一张 retrofit 的全流程图，来源：<a href=\"https://cloud.tencent.com/developer/article/1683334\">https://cloud.tencent.com/developer/article/1683334</a></p>\n</li>\n</ul>\n<img src=\"https://cdn.julis.wang/blog/img/ru5ssbhumq.jpeg\">","categories":[{"name":"技术文章","slug":"technology","api":"api/categories/technology.json"}],"tags":[{"name":"Android","slug":"Android","api":"api/tags/Android.json"}],"api":"api/posts/2025/03/17/Learn-from-RetroFit.json"}],"info":{"type":"archive","year":2025,"month":3}},"api":"api/archives/2025/03/page.1.json"}