{"data":{"index":1,"total":1,"posts":[{"title":"关于 pthread_key_t 导致的 Android Crash 的探索","slug":"关于-pthread-key-t-导致的-Android-Crash-的探索","date":"2024-11-10T08:11:00.000Z","updated":"2025-05-20T11:46:57.000Z","comments":true,"url":"2024/11/10/关于-pthread-key-t-导致的-Android-Crash-的探索/","excerpt":"<p>此前我负责的 SDK 已集成多个司内业务，一切运行正常，最近在接入到一些游戏项目中的时候发现存在比较多关于 <strong>libc.so</strong> 的 crash，在游戏中某个场景会使用SDK 进行逻辑处理，在部分手机会在短时间就直接 Crash，且集中在性能比较好的手机中。经过一番折腾，最后被定位在了一个跟 SDK 没有什么关系的地方：<code>pthread_key_t</code></p>\n<h2 id=\"Crash-表现\"><a href=\"#Crash-表现\" class=\"headerlink\" title=\"Crash 表现\"></a>Crash 表现</h2><p>在 Crash 上报平台中收到诸多的 Crash 上报，调用的形式多种多样，异常名都是<code>signal 6 (SIGABRT)</code></p>\n<p>但崩溃调用栈最终都停留在<br>  <code>/apex/com.android.runtime/lib64/bionic/libc.so pc (abort+168) </code></p>\n<p>以及中间都会经过：<br><code>/apex/com.android.runtime/lib64/bionic/libc.so (pthread_once+136)</code></p>\n<h3 id=\"难以复现的问题\"><a href=\"#难以复现的问题\" class=\"headerlink\" title=\"难以复现的问题\"></a>难以复现的问题</h3><p>由于我们的项目依赖于其他业务的SDK，最终的 SDK 打包合并在 Unity 的游戏中，我们不能直接使用游戏侧代码逻辑进行编译打包进行调试，这为问题的排查增大了一定的难度，只能在 Unity 的 demo 工程具体的表现为：</p>\n<p>1、部分性能好的手机（如小米14 pro）才会出现 Crash，而且在对应的游戏中必现，有些游戏又不会复现</p>\n<p>2、SDK里面同样的代码逻辑在测试 App 工程中完全不会复现</p>\n<p>3、SDK里面同样的代码逻辑在 Unity 测试游戏 demo 中也完全不会复现</p>\n<p>4、使用了业务方（游戏侧）的 Unity 的各种配置，依然没有复现</p>\n<p>5、崩溃栈中有涉及到 <strong>thread</strong> 相关的关键词，怀疑是线程相关问题，但在原生层开辟N个线程也没有复现</p>\n<p>6、其他各种尝试都没有复现：开辟大量内存、Unity 与 Android 调用方式调整……</p>\n<h2 id=\"解决线索与方案\"><a href=\"#解决线索与方案\" class=\"headerlink\" title=\"解决线索与方案\"></a>解决线索与方案</h2><p>一开始是怀疑业务方的环境与 SDK 运行环境有冲突，毕竟 SDK 已经在诸多业务中上线并正常运行了很久，不应该是 SDK 本身代码逻辑不对导致的才对。但没过多久，我们在另一个业务中也发现了这个问题，那说明并不是一个游戏环境导致。</p>\n<p>解决问题直接看对应的崩溃栈，其崩溃栈都是使用相关的组件导致的 Crash，询问了相关的开发大佬之后并没有得到解决办法，原因是我们使用的版本相对较老，经历了比较久的迭代，逻辑改掉了很多。二是有可能这个问题在新版本中已经修复掉了。于是我们进行了一大波改造升级，经过一段时间后，再次集成到业务方，原以为这个问题就此解决了，调用了一下创编 SDK 之后依然 crash，此时心拔凉拔凉……<br>但这时候比较能确定的是，这个 crash 跟依赖的SDK 没有直接关系，可能是由其他的环境问题什么。</p>\n<h3 id=\"问题线索-pthread-key\"><a href=\"#问题线索-pthread-key\" class=\"headerlink\" title=\"问题线索 pthread_key\"></a>问题线索 pthread_key</h3><p>在最开始的排查问题过程中一直在关注在环境的差异上面，经过一番折腾依然没有效果，方向错误了，于是再次回到 Crash 栈中来，在崩溃栈中都含有：<code>pthread_once</code>、<code>emutls_get_address</code>、<code>cxa_get_globals</code>、<code>emutls_init</code>相关的关键词，由于平时完全没有接触过这几个函数，对他们的了解比较少。但经过一番搜索之后，他们都有提到一个关键的术语：<strong>TLS (thread-local storage)</strong></p>\n<p>以及对几个函数调用的源码进行查看，发现这几个函数最终涉及到的都是 <code>pthread</code>  使用或者创建相关的</p>\n<p>其中在 cs.android的 <a href=\"https://cs.android.com/android/platform/superproject/main/+/main:external/compiler-rt/lib/builtins/emutls.c?q=emutls_init&ss=android/platform/superproject/main\">emutls.c</a> 源码里有：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">static</span> <span class=\"type\">void</span> <span class=\"title\">emutls_init</span><span class=\"params\">(<span class=\"type\">void</span>)</span> </span>&#123;</span><br><span class=\"line\"> <span class=\"keyword\">if</span> (<span class=\"built_in\">pthread_key_create</span>(&amp;emutls_pthread_key, emutls_key_destructor) != <span class=\"number\">0</span>)</span><br><span class=\"line\">\t<span class=\"built_in\">abort</span>();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里基本上可以和崩溃栈对应上了，正是这里执行的 <code>abort()</code>，那么原因是否是由 <code>pthread_key_create()</code>引起的呢？继续对 <code>pthread_key_create</code> 研究，原来在 Bionic 中，能够被开发者所使用的 Pthread Key 数量，是 <code>PTHREAD_KEYS_MAX</code> 宏所定义的 128 个。</p>\n<p>那我们遇到的问题是否也是同一个问题呢？得到答案最好的方式是验证，想办法做一个验证，用代码把系统能提供的 pthread_key 耗尽然后再使用我们创编SDK的功能，使用如下代码创建 <code>PTHREAD_KEYS_MAX</code>个 <code>pthread_key_t</code>，再直接使用创编 SDK，果不其然 Crash了，而且 crash 栈与上报的数据比较的一致（没有完全一致，毕竟一些场景还是会有点差异）。</p>\n<p>以下的代码会耗尽目前程序中的 key，只创建 pthread_key，而不释放掉</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">available_key</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; PTHREAD_KEYS_MAX; i++) &#123;</span><br><span class=\"line\">        <span class=\"type\">pthread_key_t</span> key;</span><br><span class=\"line\">        <span class=\"type\">int</span> result = pthread_key_create(&amp;key, detachDestructor);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (result == JNI_OK) &#123;</span><br><span class=\"line\">            __android_log_print(ANDROID_LOG_ERROR, <span class=\"string\">&quot;--julis&quot;</span>, <span class=\"string\">&quot;create thread key Success&quot;</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            __android_log_print(ANDROID_LOG_ERROR, <span class=\"string\">&quot;--julis&quot;</span>, <span class=\"string\">&quot;create thread key failed&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>从打印的日志里面看，在 Unity demo App 里面大概创建到 60 多的时候就创建失败了，也就是说Unity 本身可能就使用了很多 key，留给应用层开发的就只有几十个 key 了。</p>\n<p>虽然尝试是Crash了，但怎么能证明这个就是导致业务方 Crash 就是这个原因呢？以及怎么解释有的手机为什么会Crash，有的手机不会Crash呢？</p>\n<p>我们继续，从目前的推论来看，我们的创编SDK需要使用 <code>pthread_key_t</code>, 可能数量不够了，也就说创编SDK需要使用一定数量的key，那我们将刚才代码里面的<code> i &lt; PTHREAD_KEYS_MAX;</code> 进行调整，我们预留足够的 key 空间给创编SDK，<code>i &lt; target_number;</code> 于是在之前 crash 的手机和未 crash 的手机做了一次对比。</p>\n<p>以下是对部手机的测试结果，记录日志前面的数字就是代码里面的 <code>target_number</code></p>\n<img src=\"https://cdn.julis.wang/blog/img/j51nlsfd.jpg\">\n\n<p>从对比结果看，两部手机他们可以供应用层使用的 key 的数量是不同的，之前会 crash 的手机它可以使用的 key 明显是少于之前未 crash 手机的数量的，这也就能解释为什么有的手机为什么会 crash，有的手机不会 crash 了。以及，可以推测出来创编SDK使用了5个key左右。</p>\n<p>这里提一下在解决问题之初，我们发现 crash 的手机基本上都是市面上比较好的手机，且手机的 GPU 都集中于 Adreno 比较新的型号，一度误以为是相关底层 SDK 未进行兼容性适配导致。为什么性能更好的手机使用的 <code>pthread_key_t</code> 会更多？猜测可能是好的手机 Unity 运行相关的东西或者优化(这里的优化指的是游戏特效或者功能玩法)更多，所以消耗的资源就更多一点，当然这里只是个人猜测，具体原因还需要深入了解。</p>\n<p>还剩下一个问题：业务方的 App 为什么会Crash？于是将上面的 <code>available_key()</code>方法进行一次包装，并将其打包集成进游戏侧测试，从日志里面看到留给我们创编SDK使用的 key 只有3个了！而我们的 SDK 需要5个左右，问题原因基本就是这个了，那如何解决呢？</p>\n<h3 id=\"方案解决\"><a href=\"#方案解决\" class=\"headerlink\" title=\"方案解决\"></a>方案解决</h3><p>究其根本原因是 Android 系统的 <code>pthread_key_t</code> 的使用数量的限制，那么最直接的解决方式那就是降低对 <code>pthread_key_t</code> 的使用，但是由于我们依赖使用其他地方的 SDK，对其项目直接优化更改可能成本相对较高，直接修改源码解决的话一时半会儿无法解决。这里先对 <code>pthread_key_t</code> 数量限制相关的问题进行一些研究总结：</p>\n<p>在 Android 官方源码 <a href=\"https://android.googlesource.com/platform/bionic/+/master/libc/include/pthread.h\">pthread.h#pthread_key_create()</a> 里面有提到：</p>\n<blockquote>\n<p>There is a limit of <code>PTHREAD_KEYS_MAX</code> keys per process, but most callers should just use the C or C++ <code>thread_local</code> storage specifier anyway. When targeting new enough OS versions, the compiler will automatically use ELF TLS; when targeting old OS versions the emutls implementation will multiplex pthread keys behind the scenes, using one per library rather than one per thread-local variable. If you are implementing the runtime for a different language, you should consider similar implementation choices and avoid a direct one-to-one mapping from thread locals to pthread keys.<br>Returns 0 on success and returns an error number on failure.</p>\n</blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">int pthread_key_create(pthread_key_t* _Nonnull **key_ptr, void (* _Nullable **key_destructor)(void* _Nullable));</span><br></pre></td></tr></table></figure>\n\n<p>可以看到官方建议使用 <code>thread_local</code> 去实现 TLS，以及在新的系统版本中会使用 <code>ELF TLS</code> 对 <code>pthread_key_t</code> 将不直接依赖，<br>但条件相对比较高，参考官方更新：需要 miniSDK&gt;29 和NDK r26</p>\n<blockquote>\n<p>ELF TLS (Available for API level &gt;&#x3D; 29)<br>Android supports <a href=\"https://android.googlesource.com/platform/bionic/+/HEAD/docs/elf-tls.md\">ELF TLS</a> starting at API level 29. Since NDK r26, clang will automatically enable ELF TLS for <code>minSdkVersion 29</code> or higher. Otherwise, the existing emutls implementation (which uses <code>pthread_key_create()</code> behind the scenes) will continue to be used. This means that convenient C&#x2F;C++ thread-local syntax is available at any API level; at worst it will perform similarly to “roll your own” thread locals using <code>pthread_key_create()</code> but at best you’ll get the performance benefit of ELF TLS, and the NDK will take care of the details.</p>\n</blockquote>\n<p>最后我们的解决方式是依据上面 <code>pthread_key_create</code> 提到的</p>\n<blockquote>\n<p>There is a limit of <code>PTHREAD_KEYS_MAX</code> keys per process…..</p>\n</blockquote>\n<p>重点是：<strong>per process</strong>，每个进程有 <code>PTHREAD_KEYS_MAX</code>,这个<code>PTHREAD_KEYS_MAX</code>被定义在 <a href=\"https://android.googlesource.com/platform/bionic/+/refs/heads/main/libc/include/limits.h\">limits.h</a>  现在的 Android 基本上都是定义为128。那那我们将我们的SDK 使用的时候放在一个单独的进程不就ok了？事实是的，由于我们的SDK向业务只是提供一个 素材输入&#x3D;&gt;视频输出的功能，中间过程是一个黑盒，那么这个场景使用多进程是完全OK的，使用多进程还有一个好处就是能与游戏进程相独立，尽量减少两者之间的依赖。但多进程也带来了一些门槛，但这相比与改渲染 SDK 底层的源码来说是相对简单很多的，最终经过一番折腾我们将创编SDK得渲染放在了一个单独的进程，后试验运行在之前 Crash 过的游戏业务上一切正常。</p>\n<h3 id=\"pthread-key-检测工具\"><a href=\"#pthread-key-检测工具\" class=\"headerlink\" title=\"pthread_key 检测工具\"></a>pthread_key 检测工具</h3><p>为了以后接入其他游戏前不再发生类似的Crash问题，在接入业务前做一些技术评估，<code>pthread_key_t</code> 可用数量可能也需要成为一个考量指标，可用数的不同，可能需要不同的技术方案，我专门写了一个小工具，可方便查询业务项目目前使用了多少 pthread_key_t，能帮助项目排查当前问题是否是由于 <code>pthread_key_t</code> 占满导致的相关问题。</p>\n<p>不过我更想做一个能够检测项目里面有消耗过 pthread_key_t 的地方，将其 hook 住，打印出来对应的调用栈，这样就能方便业务排查。未来，随着 Android 业务的复杂化，这种问题可能会变成更多大型项目将会遇到。调研发现 Tencent 对外开源项目 <a href=\"https://github.com/Tencent/matrix?tab=readme-ov-file\">Tencent&#x2F;matrix</a> 已经有针对 pthread_key 做了相关的hook，业务侧也可以直接使用 matrix 进行检测，但其项目相对比较庞大，以及使用的方式较复杂。于是将其精简到一个小工具内，整体大小只有1MB 不到。</p>\n<p>源码地址：<a href=\"https://github.com/VomPom/PthreadKeyDetect\">PthreadKeyDetect</a></p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>本文主要记录了i创作SDK出现大佬了关于 <code>libc.so</code> 的 Crash，经过调查，问题被定位在 <code>pthread_key_t</code> 资源耗尽的问题上，并对其进行了相关研究，最后并解决了该问题的过程。</p>\n<h3 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h3><p><a href=\"https://android.googlesource.com/platform/bionic/+/HEAD/android-changes-for-ndk-developers.md#elf-tls-available-for-api-level-29\">Android linker changes for NDK developers</a></p>\n<p><a href=\"https://github.com/android/ndk/issues/789\">thread specific key leakage</a></p>\n<p><a href=\"https://juejin.cn/post/6987921143487283236\">pthread_key_create用法导致的崩溃修复</a></p>\n<p><a href=\"https://github.com/flutter/flutter/issues/127079\">Crash issue caused by pthread_key_create failed: 11 when integrating Flutter into our project #127079</a></p>\n<p><a href=\"https://muc.lists.netbsd.tech.userlevel.narkive.com/gFAi2gse/increase-pthread-keys-max\">Increase PTHREAD_KEYS_MAX</a></p>\n","cover":null,"images":["https://cdn.julis.wang/blog/img/j51nlsfd.jpg"],"content":"<p>此前我负责的 SDK 已集成多个司内业务，一切运行正常，最近在接入到一些游戏项目中的时候发现存在比较多关于 <strong>libc.so</strong> 的 crash，在游戏中某个场景会使用SDK 进行逻辑处理，在部分手机会在短时间就直接 Crash，且集中在性能比较好的手机中。经过一番折腾，最后被定位在了一个跟 SDK 没有什么关系的地方：<code>pthread_key_t</code></p>\n<h2 id=\"Crash-表现\"><a href=\"#Crash-表现\" class=\"headerlink\" title=\"Crash 表现\"></a>Crash 表现</h2><p>在 Crash 上报平台中收到诸多的 Crash 上报，调用的形式多种多样，异常名都是<code>signal 6 (SIGABRT)</code></p>\n<p>但崩溃调用栈最终都停留在<br>  <code>/apex/com.android.runtime/lib64/bionic/libc.so pc (abort+168) </code></p>\n<p>以及中间都会经过：<br><code>/apex/com.android.runtime/lib64/bionic/libc.so (pthread_once+136)</code></p>\n<h3 id=\"难以复现的问题\"><a href=\"#难以复现的问题\" class=\"headerlink\" title=\"难以复现的问题\"></a>难以复现的问题</h3><p>由于我们的项目依赖于其他业务的SDK，最终的 SDK 打包合并在 Unity 的游戏中，我们不能直接使用游戏侧代码逻辑进行编译打包进行调试，这为问题的排查增大了一定的难度，只能在 Unity 的 demo 工程具体的表现为：</p>\n<p>1、部分性能好的手机（如小米14 pro）才会出现 Crash，而且在对应的游戏中必现，有些游戏又不会复现</p>\n<p>2、SDK里面同样的代码逻辑在测试 App 工程中完全不会复现</p>\n<p>3、SDK里面同样的代码逻辑在 Unity 测试游戏 demo 中也完全不会复现</p>\n<p>4、使用了业务方（游戏侧）的 Unity 的各种配置，依然没有复现</p>\n<p>5、崩溃栈中有涉及到 <strong>thread</strong> 相关的关键词，怀疑是线程相关问题，但在原生层开辟N个线程也没有复现</p>\n<p>6、其他各种尝试都没有复现：开辟大量内存、Unity 与 Android 调用方式调整……</p>\n<h2 id=\"解决线索与方案\"><a href=\"#解决线索与方案\" class=\"headerlink\" title=\"解决线索与方案\"></a>解决线索与方案</h2><p>一开始是怀疑业务方的环境与 SDK 运行环境有冲突，毕竟 SDK 已经在诸多业务中上线并正常运行了很久，不应该是 SDK 本身代码逻辑不对导致的才对。但没过多久，我们在另一个业务中也发现了这个问题，那说明并不是一个游戏环境导致。</p>\n<p>解决问题直接看对应的崩溃栈，其崩溃栈都是使用相关的组件导致的 Crash，询问了相关的开发大佬之后并没有得到解决办法，原因是我们使用的版本相对较老，经历了比较久的迭代，逻辑改掉了很多。二是有可能这个问题在新版本中已经修复掉了。于是我们进行了一大波改造升级，经过一段时间后，再次集成到业务方，原以为这个问题就此解决了，调用了一下创编 SDK 之后依然 crash，此时心拔凉拔凉……<br>但这时候比较能确定的是，这个 crash 跟依赖的SDK 没有直接关系，可能是由其他的环境问题什么。</p>\n<h3 id=\"问题线索-pthread-key\"><a href=\"#问题线索-pthread-key\" class=\"headerlink\" title=\"问题线索 pthread_key\"></a>问题线索 pthread_key</h3><p>在最开始的排查问题过程中一直在关注在环境的差异上面，经过一番折腾依然没有效果，方向错误了，于是再次回到 Crash 栈中来，在崩溃栈中都含有：<code>pthread_once</code>、<code>emutls_get_address</code>、<code>cxa_get_globals</code>、<code>emutls_init</code>相关的关键词，由于平时完全没有接触过这几个函数，对他们的了解比较少。但经过一番搜索之后，他们都有提到一个关键的术语：<strong>TLS (thread-local storage)</strong></p>\n<p>以及对几个函数调用的源码进行查看，发现这几个函数最终涉及到的都是 <code>pthread</code>  使用或者创建相关的</p>\n<p>其中在 cs.android的 <a href=\"https://cs.android.com/android/platform/superproject/main/+/main:external/compiler-rt/lib/builtins/emutls.c?q=emutls_init&ss=android/platform/superproject/main\">emutls.c</a> 源码里有：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">static</span> <span class=\"type\">void</span> <span class=\"title\">emutls_init</span><span class=\"params\">(<span class=\"type\">void</span>)</span> </span>&#123;</span><br><span class=\"line\"> <span class=\"keyword\">if</span> (<span class=\"built_in\">pthread_key_create</span>(&amp;emutls_pthread_key, emutls_key_destructor) != <span class=\"number\">0</span>)</span><br><span class=\"line\">\t<span class=\"built_in\">abort</span>();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里基本上可以和崩溃栈对应上了，正是这里执行的 <code>abort()</code>，那么原因是否是由 <code>pthread_key_create()</code>引起的呢？继续对 <code>pthread_key_create</code> 研究，原来在 Bionic 中，能够被开发者所使用的 Pthread Key 数量，是 <code>PTHREAD_KEYS_MAX</code> 宏所定义的 128 个。</p>\n<p>那我们遇到的问题是否也是同一个问题呢？得到答案最好的方式是验证，想办法做一个验证，用代码把系统能提供的 pthread_key 耗尽然后再使用我们创编SDK的功能，使用如下代码创建 <code>PTHREAD_KEYS_MAX</code>个 <code>pthread_key_t</code>，再直接使用创编 SDK，果不其然 Crash了，而且 crash 栈与上报的数据比较的一致（没有完全一致，毕竟一些场景还是会有点差异）。</p>\n<p>以下的代码会耗尽目前程序中的 key，只创建 pthread_key，而不释放掉</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">available_key</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; PTHREAD_KEYS_MAX; i++) &#123;</span><br><span class=\"line\">        <span class=\"type\">pthread_key_t</span> key;</span><br><span class=\"line\">        <span class=\"type\">int</span> result = pthread_key_create(&amp;key, detachDestructor);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (result == JNI_OK) &#123;</span><br><span class=\"line\">            __android_log_print(ANDROID_LOG_ERROR, <span class=\"string\">&quot;--julis&quot;</span>, <span class=\"string\">&quot;create thread key Success&quot;</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            __android_log_print(ANDROID_LOG_ERROR, <span class=\"string\">&quot;--julis&quot;</span>, <span class=\"string\">&quot;create thread key failed&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>从打印的日志里面看，在 Unity demo App 里面大概创建到 60 多的时候就创建失败了，也就是说Unity 本身可能就使用了很多 key，留给应用层开发的就只有几十个 key 了。</p>\n<p>虽然尝试是Crash了，但怎么能证明这个就是导致业务方 Crash 就是这个原因呢？以及怎么解释有的手机为什么会Crash，有的手机不会Crash呢？</p>\n<p>我们继续，从目前的推论来看，我们的创编SDK需要使用 <code>pthread_key_t</code>, 可能数量不够了，也就说创编SDK需要使用一定数量的key，那我们将刚才代码里面的<code> i &lt; PTHREAD_KEYS_MAX;</code> 进行调整，我们预留足够的 key 空间给创编SDK，<code>i &lt; target_number;</code> 于是在之前 crash 的手机和未 crash 的手机做了一次对比。</p>\n<p>以下是对部手机的测试结果，记录日志前面的数字就是代码里面的 <code>target_number</code></p>\n<img src=\"https://cdn.julis.wang/blog/img/j51nlsfd.jpg\">\n\n<p>从对比结果看，两部手机他们可以供应用层使用的 key 的数量是不同的，之前会 crash 的手机它可以使用的 key 明显是少于之前未 crash 手机的数量的，这也就能解释为什么有的手机为什么会 crash，有的手机不会 crash 了。以及，可以推测出来创编SDK使用了5个key左右。</p>\n<p>这里提一下在解决问题之初，我们发现 crash 的手机基本上都是市面上比较好的手机，且手机的 GPU 都集中于 Adreno 比较新的型号，一度误以为是相关底层 SDK 未进行兼容性适配导致。为什么性能更好的手机使用的 <code>pthread_key_t</code> 会更多？猜测可能是好的手机 Unity 运行相关的东西或者优化(这里的优化指的是游戏特效或者功能玩法)更多，所以消耗的资源就更多一点，当然这里只是个人猜测，具体原因还需要深入了解。</p>\n<p>还剩下一个问题：业务方的 App 为什么会Crash？于是将上面的 <code>available_key()</code>方法进行一次包装，并将其打包集成进游戏侧测试，从日志里面看到留给我们创编SDK使用的 key 只有3个了！而我们的 SDK 需要5个左右，问题原因基本就是这个了，那如何解决呢？</p>\n<h3 id=\"方案解决\"><a href=\"#方案解决\" class=\"headerlink\" title=\"方案解决\"></a>方案解决</h3><p>究其根本原因是 Android 系统的 <code>pthread_key_t</code> 的使用数量的限制，那么最直接的解决方式那就是降低对 <code>pthread_key_t</code> 的使用，但是由于我们依赖使用其他地方的 SDK，对其项目直接优化更改可能成本相对较高，直接修改源码解决的话一时半会儿无法解决。这里先对 <code>pthread_key_t</code> 数量限制相关的问题进行一些研究总结：</p>\n<p>在 Android 官方源码 <a href=\"https://android.googlesource.com/platform/bionic/+/master/libc/include/pthread.h\">pthread.h#pthread_key_create()</a> 里面有提到：</p>\n<blockquote>\n<p>There is a limit of <code>PTHREAD_KEYS_MAX</code> keys per process, but most callers should just use the C or C++ <code>thread_local</code> storage specifier anyway. When targeting new enough OS versions, the compiler will automatically use ELF TLS; when targeting old OS versions the emutls implementation will multiplex pthread keys behind the scenes, using one per library rather than one per thread-local variable. If you are implementing the runtime for a different language, you should consider similar implementation choices and avoid a direct one-to-one mapping from thread locals to pthread keys.<br>Returns 0 on success and returns an error number on failure.</p>\n</blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">int pthread_key_create(pthread_key_t* _Nonnull **key_ptr, void (* _Nullable **key_destructor)(void* _Nullable));</span><br></pre></td></tr></table></figure>\n\n<p>可以看到官方建议使用 <code>thread_local</code> 去实现 TLS，以及在新的系统版本中会使用 <code>ELF TLS</code> 对 <code>pthread_key_t</code> 将不直接依赖，<br>但条件相对比较高，参考官方更新：需要 miniSDK&gt;29 和NDK r26</p>\n<blockquote>\n<p>ELF TLS (Available for API level &gt;&#x3D; 29)<br>Android supports <a href=\"https://android.googlesource.com/platform/bionic/+/HEAD/docs/elf-tls.md\">ELF TLS</a> starting at API level 29. Since NDK r26, clang will automatically enable ELF TLS for <code>minSdkVersion 29</code> or higher. Otherwise, the existing emutls implementation (which uses <code>pthread_key_create()</code> behind the scenes) will continue to be used. This means that convenient C&#x2F;C++ thread-local syntax is available at any API level; at worst it will perform similarly to “roll your own” thread locals using <code>pthread_key_create()</code> but at best you’ll get the performance benefit of ELF TLS, and the NDK will take care of the details.</p>\n</blockquote>\n<p>最后我们的解决方式是依据上面 <code>pthread_key_create</code> 提到的</p>\n<blockquote>\n<p>There is a limit of <code>PTHREAD_KEYS_MAX</code> keys per process…..</p>\n</blockquote>\n<p>重点是：<strong>per process</strong>，每个进程有 <code>PTHREAD_KEYS_MAX</code>,这个<code>PTHREAD_KEYS_MAX</code>被定义在 <a href=\"https://android.googlesource.com/platform/bionic/+/refs/heads/main/libc/include/limits.h\">limits.h</a>  现在的 Android 基本上都是定义为128。那那我们将我们的SDK 使用的时候放在一个单独的进程不就ok了？事实是的，由于我们的SDK向业务只是提供一个 素材输入&#x3D;&gt;视频输出的功能，中间过程是一个黑盒，那么这个场景使用多进程是完全OK的，使用多进程还有一个好处就是能与游戏进程相独立，尽量减少两者之间的依赖。但多进程也带来了一些门槛，但这相比与改渲染 SDK 底层的源码来说是相对简单很多的，最终经过一番折腾我们将创编SDK得渲染放在了一个单独的进程，后试验运行在之前 Crash 过的游戏业务上一切正常。</p>\n<h3 id=\"pthread-key-检测工具\"><a href=\"#pthread-key-检测工具\" class=\"headerlink\" title=\"pthread_key 检测工具\"></a>pthread_key 检测工具</h3><p>为了以后接入其他游戏前不再发生类似的Crash问题，在接入业务前做一些技术评估，<code>pthread_key_t</code> 可用数量可能也需要成为一个考量指标，可用数的不同，可能需要不同的技术方案，我专门写了一个小工具，可方便查询业务项目目前使用了多少 pthread_key_t，能帮助项目排查当前问题是否是由于 <code>pthread_key_t</code> 占满导致的相关问题。</p>\n<p>不过我更想做一个能够检测项目里面有消耗过 pthread_key_t 的地方，将其 hook 住，打印出来对应的调用栈，这样就能方便业务排查。未来，随着 Android 业务的复杂化，这种问题可能会变成更多大型项目将会遇到。调研发现 Tencent 对外开源项目 <a href=\"https://github.com/Tencent/matrix?tab=readme-ov-file\">Tencent&#x2F;matrix</a> 已经有针对 pthread_key 做了相关的hook，业务侧也可以直接使用 matrix 进行检测，但其项目相对比较庞大，以及使用的方式较复杂。于是将其精简到一个小工具内，整体大小只有1MB 不到。</p>\n<p>源码地址：<a href=\"https://github.com/VomPom/PthreadKeyDetect\">PthreadKeyDetect</a></p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>本文主要记录了i创作SDK出现大佬了关于 <code>libc.so</code> 的 Crash，经过调查，问题被定位在 <code>pthread_key_t</code> 资源耗尽的问题上，并对其进行了相关研究，最后并解决了该问题的过程。</p>\n<h3 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h3><p><a href=\"https://android.googlesource.com/platform/bionic/+/HEAD/android-changes-for-ndk-developers.md#elf-tls-available-for-api-level-29\">Android linker changes for NDK developers</a></p>\n<p><a href=\"https://github.com/android/ndk/issues/789\">thread specific key leakage</a></p>\n<p><a href=\"https://juejin.cn/post/6987921143487283236\">pthread_key_create用法导致的崩溃修复</a></p>\n<p><a href=\"https://github.com/flutter/flutter/issues/127079\">Crash issue caused by pthread_key_create failed: 11 when integrating Flutter into our project #127079</a></p>\n<p><a href=\"https://muc.lists.netbsd.tech.userlevel.narkive.com/gFAi2gse/increase-pthread-keys-max\">Increase PTHREAD_KEYS_MAX</a></p>\n","categories":[{"name":"技术文章","slug":"technology","api":"api/categories/technology.json"}],"tags":[{"name":"Android","slug":"Android","api":"api/tags/Android.json"}],"api":"api/posts/2024/11/10/关于-pthread-key-t-导致的-Android-Crash-的探索.json"},{"title":"[问题记录]Hexo TypeError: isDate is not a function","slug":"问题记录-Hexo-TypeError-isDate-is-not-a-function","date":"2024-08-25T02:24:00.000Z","updated":"2025-08-25T02:24:10.166Z","comments":true,"url":"2024/08/25/问题记录-Hexo-TypeError-isDate-is-not-a-function/","excerpt":"","cover":null,"images":[],"content":"","categories":[],"tags":[],"api":"api/posts/2024/08/25/问题记录-Hexo-TypeError-isDate-is-not-a-function.json"},{"title":"[译]软件开发人员的常青技能","slug":"软件开发人员的常青技能","date":"2024-07-08T23:27:19.000Z","updated":"2025-05-20T11:46:57.000Z","comments":true,"url":"2024/07/09/软件开发人员的常青技能/","excerpt":"<p>最近在 Github 看到这一篇将程序员一直需要使用的非技术核心能力进行了总结，深受里面内容的启发，语言、框架都是会过时的，但有些技能无论是什么语言或者框架都是通用的，如果要在这个行业持续深根，那么这些非技术能力是必备的且实用的。本文在原文上进行翻译，并对文中提到部分专业术语进行了解释，以及对指向外部链接的文档内容作了一些简单的概述，希望能帮助到查看此文档的人。</p>\n<p>原文地址：<a href=\"https://github.com/romenrg/evergreen-skills-developers.git\">evergreen-skills-developers</a></p>\n<p>中英双文地址：<a href=\"https://github.com/VomPom/evergreen-skills-developers/blob/master/README_en_cn.md\">[译]evergreen-skills-developers</a></p>\n<h2 id=\"原文翻译：\"><a href=\"#原文翻译：\" class=\"headerlink\" title=\"原文翻译：\"></a>原文翻译：</h2><p>这个仓库包括了一份“常青技能”清单，这份清单应该可以作为对技术精湛的软件工程师&#x2F;开发者客观评价。</p>\n<p>这份工作的是为了在招聘软件开发者&#x2F;工程师时，提供一个替代的技术面试的方案。文档关注的是软开发最佳实践、跨框架原则和通用的技能；而不是我们在行业中经常看到的语言层面，或者特定技术框架的内容。</p>\n<p>编程语言不断进化，公司也不断改变他们的技术栈，框架很快就会过时，有经验的工程师使用搜索引擎能在几分钟就能解决语法相关的问题。因此，在面试候选人时关注这些方面是否有意义呢？</p>\n<p>另一方面，技术框架以外的原理和非技术的技能是在谷歌上查不到的，这些技能是“常青”的，并且对工程师的表现有巨大的影响。这些更能反映出软件开发者&#x2F;工程师为团队带来的真正价值。</p>\n<p>这个仓库是基于以下文章的一个衍生作品：”<a href=\"https://www.romenrg.com/blog/2018/12/29/what-makes-a-great-software-engineer\">是什么造就了一位伟大的软件工程师</a>“。</p>\n<p>这是一个正在进行中的工作。重要的知识可能缺失，现有的条目可能可以改进，更好的分组策略也可能被发现。因此，任何贡献（即PR或问题）都是受欢迎的。请随时按照<a href=\"https://gptx.woa.com/CONTRIBUTING.md\">贡献指南</a>提出修改建议。</p>\n<h2 id=\"目录\"><a href=\"#目录\" class=\"headerlink\" title=\"目录\"></a>目录</h2><ul>\n<li><p><a href=\"#%E9%9D%9E%E6%8A%80%E6%9C%AF%E6%8A%80%E8%83%BD\">非技术技能</a></p>\n<ul>\n<li><a href=\"#%E6%A0%B8%E5%BF%83%E6%8A%80%E8%83%BD%EF%BC%88%E5%8F%88%E7%A7%B0%E2%80%9C%E8%BD%AF%E6%8A%80%E8%83%BD%E2%80%9D%EF%BC%89\">核心技能</a><ul>\n<li><a href=\"#%E4%BA%A4%E6%B5%81\">交流</a></li>\n<li><a href=\"#%E5%9B%A2%E9%98%9F\">团队</a></li>\n</ul>\n</li>\n<li><a href=\"#%E5%88%9B%E6%96%B0%E5%92%8C%E8%87%AA%E6%88%91%E7%AE%A1%E7%90%86%E6%8A%80%E8%83%BD\">创新和自我管理技能</a><ul>\n<li><a href=\"#%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B\">开发流程</a></li>\n<li><a href=\"#%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E8%83%BD%E5%8A%9B\">问题解决能力</a></li>\n<li><a href=\"#%E5%BF%83%E6%80%81\">心态</a></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p><a href=\"#%E6%8A%80%E8%83%BD%E8%83%BD%E5%8A%9B\">技能能力</a></p>\n<ul>\n<li><a href=\"#%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF%E8%83%BD%E5%8A%9B\">通用技术能力</a></li>\n<li><a href=\"#%E7%BC%96%E7%A8%8B%E5%87%86%E5%88%99\">编程准则</a><ul>\n<li><a href=\"#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84\">数据结构</a> </li>\n<li><a href=\"#%E4%BB%A3%E7%A0%81%E6%95%B4%E6%B4%81\">代码整洁</a></li>\n<li><a href=\"#%E6%BA%90%E7%A0%81%E7%AE%A1%E7%90%86\">源码管理</a></li>\n<li><a href=\"#%E6%8A%80%E6%9C%AF%E5%90%88%E4%BD%9C\">技术合作</a></li>\n<li><a href=\"#DevOps%E5%AE%9E%E8%B7%B5\">DevOps实践</a></li>\n<li><a href=\"%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86\">通用技术知识</a><ul>\n<li><a href=\"#%E8%AF%AD%E8%A8%80%E7%90%86%E8%AE%BA%E7%9F%A5%E8%AF%86\">语言理论知识</a></li>\n<li><a href=\"#%E4%BC%98%E5%8C%96\">优化</a></li>\n<li><a href=\"#%E5%B9%B6%E5%8F%91\">并发</a></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p><a href=\"#%E7%89%B9%E5%AE%9A%E9%A2%86%E5%9F%9F%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86\">特定领域技术知识</a></p>\n<ul>\n<li><p><a href=\"#%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91\">前端开发</a></p>\n</li>\n<li><p><a href=\"#%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91\">后端开发</a></p>\n</li>\n<li><p><a href=\"#%E6%9E%B6%E6%9E%84\">架构</a></p>\n</li>\n<li><p><a href=\"#%E5%9F%BA%E7%A1%80%E5%BB%BA%E8%AE%BE\">基础建设</a></p>\n</li>\n<li><p><a href=\"#%E5%AE%89%E5%85%A8\">安全</a></p>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"非技术技能\"><a href=\"#非技术技能\" class=\"headerlink\" title=\"非技术技能\"></a>非技术技能</h2><p>以下非技术能力可能是开发者最重要的能力。尽管一个人可能具备很强的技术能力，但在公司中没有良好的沟通、团队合作态度、开发流程、解决问题的能力和学习的心态的话，一切会变得非常糟糕。</p>\n<h3 id=\"核心技能（又称“软技能”）\"><a href=\"#核心技能（又称“软技能”）\" class=\"headerlink\" title=\"核心技能（又称“软技能”）\"></a>核心技能（又称“软技能”）</h3><h4 id=\"交流\"><a href=\"#交流\" class=\"headerlink\" title=\"交流\"></a>交流</h4><ul>\n<li>遵循邮件使用的最佳策略(例： <a href=\"https://www.grammarly.com/blog/email-etiquette-rules-to-know/\">some e-mail etiquette rules</a>)</li>\n</ul>\n<ul>\n<li><p>遵循沟通的最佳策略 (e.g. <a href=\"https://slack.com/intl/en-es/help/articles/115000769927-Use-threads-to-organize-discussions-\">use threads to organize discussions</a> and <a href=\"https://blog.rescuetime.com/slack-focus-guide/\">other best-practices from Slack</a>)</p>\n<p>两份链接指向的 slack 的一则使用文档和一份 slack 使用技巧文档</p>\n</li>\n<li><p><a href=\"https://jaxenter.com/aaaand-gone-true-cost-interruptions-128741.html\">最小化干扰</a></p>\n<p>链接指向的文章是一篇关于程序员在工作中，因被其他事项而中断程序开发的影响，一般人，在工作过程中断打扰后大约需要23分钟才能恢复到之前的状态，而程序员需要更久，文中强调了工作中断对程序员工作效率和心情的影响，并讨论了有计划和非计划性中断的不同影响。</p>\n</li>\n<li><p>保持礼貌</p>\n</li>\n</ul>\n<h4 id=\"团队\"><a href=\"#团队\" class=\"headerlink\" title=\"团队\"></a>团队</h4><ul>\n<li><p><a href=\"https://simpleprogrammer.com/empathy-software-developers\">练习同理心</a></p>\n</li>\n<li><p>保持谦逊和低调</p>\n</li>\n<li><p>做一个积极倾听的人</p>\n</li>\n<li><p>做一个好的导师</p>\n</li>\n<li><p>知识分享</p>\n</li>\n<li><p>得有见地</p>\n</li>\n</ul>\n<h3 id=\"创新和自我管理技能\"><a href=\"#创新和自我管理技能\" class=\"headerlink\" title=\"创新和自我管理技能\"></a>创新和自我管理技能</h3><h4 id=\"开发流程\"><a href=\"#开发流程\" class=\"headerlink\" title=\"开发流程\"></a>开发流程</h4><ul>\n<li><p>了解<a href=\"https://agilemanifesto.org/principles.html\">《敏捷开发原则》</a></p>\n</li>\n<li><p>适应迭代和增量开发</p>\n</li>\n<li><p>自组织的能力</p>\n<p>指的是个体或系统能够自发地、无需外部强制指挥，根据内部规则和相互作用来组织自身结构和行为的能力。这种能力在多个层面都有体现，包括个人自我管理、团队协作以及更广泛的社会和生态系统</p>\n</li>\n<li><p>避免产生错误的预估（比如：工时预估）</p>\n</li>\n<li><p>关注优先级和业务价值</p>\n</li>\n</ul>\n<h4 id=\"问题解决能力\"><a href=\"#问题解决能力\" class=\"headerlink\" title=\"问题解决能力\"></a>问题解决能力</h4><ul>\n<li><p>使用科学方法(<a href=\"https://en.wikipedia.org/wiki/Scientific_method\">Scientific Method</a>)</p>\n<blockquote>\n<p>科学方法是一种有系统地寻求知识的程序，涉及了以下三个步骤：问题的认知与表述、实验数据的收集、假说的构成与测试。</p>\n</blockquote>\n</li>\n<li><p>检索能力</p>\n</li>\n<li><p>横向思维</p>\n<blockquote>\n<p>横向思维，指使用间接的、具有创造力的、不是一望而知的推理方式来解决问题</p>\n</blockquote>\n</li>\n<li><p>抽象化能力</p>\n</li>\n<li><p>创造力</p>\n</li>\n<li><p><a href=\"http://en.wikipedia.org/wiki/5_Whys\">五问法</a></p>\n<blockquote>\n<p>五问法关键所在就是，鼓励解决问题的人要努力避开主观或自负的假设和逻辑陷阱，从结果着手，沿着因果关系链条，顺藤摸瓜，穿越不同的抽象层面，直至找出原有问题的根本原因。简而言之，就是鼓励解决问题的人要有“打破砂锅问到底”的精神。</p>\n</blockquote>\n</li>\n<li><p>风险管理</p>\n</li>\n</ul>\n<h4 id=\"心态\"><a href=\"#心态\" class=\"headerlink\" title=\"心态\"></a>心态</h4><ul>\n<li><p>不要害怕变化</p>\n</li>\n<li><p>敢于失败</p>\n</li>\n<li><p>终生学习</p>\n</li>\n<li><p><a href=\"https://en.wikipedia.org/wiki/Critical_thinking\">批判性思维</a> （保持理性，质疑决定，“让事实说话”）</p>\n</li>\n</ul>\n<h2 id=\"技能能力\"><a href=\"#技能能力\" class=\"headerlink\" title=\"技能能力\"></a>技能能力</h2><h3 id=\"通用技术能力\"><a href=\"#通用技术能力\" class=\"headerlink\" title=\"通用技术能力\"></a>通用技术能力</h3><p>有一些技术知识是永恒的，对任何软件工程师都有关，尽管他们将要从事的具体领域各不相同。为了深入了解他们的资历并了解他们的工程实践有多扎实，你可以和他们就编程原理、数据结构、清晰的代码、源代码管理、技术协作或者DevOps实践等主题进行交谈。如果这些基础扎实，他们可能能够毫无问题地学习你们特定领域的东西。</p>\n<h4 id=\"编程准则\"><a href=\"#编程准则\" class=\"headerlink\" title=\"编程准则\"></a>编程准则</h4><ul>\n<li><p>基本流程结构和逻辑代数</p>\n</li>\n<li><p>面向对象编程</p>\n</li>\n<li><p><a href=\"https://en.wikipedia.org/wiki/SOLID\">SOLID</a>, <a href=\"https://en.wikipedia.org/wiki/GRASP_(object-oriented_design)\">GRASP</a>面向对象设计</p>\n<blockquote>\n<p><strong>SOLID</strong>（单一功能、开闭原则、里氏替换、接口隔离以及依赖反转）</p>\n</blockquote>\n</li>\n</ul>\n<blockquote>\n<table>\n<thead>\n<tr>\n<th align=\"center\"></th>\n<th></th>\n<th></th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">S</td>\n<td><a href=\"https://zh.wikipedia.org/wiki/%E5%8D%95%E4%B8%80%E5%8A%9F%E8%83%BD%E5%8E%9F%E5%88%99\">单一功能原则</a></td>\n<td>认为“对象应该仅具有一种单一功能”的概念。</td>\n</tr>\n<tr>\n<td align=\"center\">O</td>\n<td><a href=\"https://zh.wikipedia.org/wiki/%E5%BC%80%E9%97%AD%E5%8E%9F%E5%88%99\">开闭原则</a></td>\n<td>认为“软件应该是对于扩展开放的，但是对于修改封闭的”的概念。</td>\n</tr>\n<tr>\n<td align=\"center\">L</td>\n<td><a href=\"https://zh.wikipedia.org/wiki/%E9%87%8C%E6%B0%8F%E6%9B%BF%E6%8D%A2%E5%8E%9F%E5%88%99\">里氏替换原则</a></td>\n<td>认为“程序中的对象应该是可以在不改变程序正确性的前提下被它的子类所替换的”的概念。参考契约式设计。</td>\n</tr>\n<tr>\n<td align=\"center\">I</td>\n<td><a href=\"https://zh.wikipedia.org/wiki/%E6%8E%A5%E5%8F%A3%E9%9A%94%E7%A6%BB%E5%8E%9F%E5%88%99\">接口隔离原则</a></td>\n<td>认为“多个特定客户端接口要好于一个宽泛用途的接口”的概念。</td>\n</tr>\n<tr>\n<td align=\"center\">D</td>\n<td><a href=\"https://zh.wikipedia.org/wiki/%E4%BE%9D%E8%B5%96%E5%8F%8D%E8%BD%AC%E5%8E%9F%E5%88%99\">依赖反转原则</a></td>\n<td>认为一个方法应该遵从“依赖于抽象而不是一个实例”的概念。 依赖注入是该原则的一种实现方式。</td>\n</tr>\n</tbody></table>\n<p><strong>GRASP</strong>中提到的模式和原则包括有控制器（controller）、创建者（creator）、中介（indirection）、信息专家（information expert）、低耦合性（low coupling）、高内聚性（high cohesion）、多态（polymorphism）、保护变化（protected variations）和纯虚构（pure Fabrication）[2]</p>\n</blockquote>\n<ul>\n<li><p>函数式编程（纯函数、不变性、递归……）</p>\n</li>\n<li><p><a href=\"http://amzotti.github.io/programming%20paradigms/2015/02/13/what-is-the-difference-between-procedural-function-imperative-and-declarative-programming-paradigms/\">声明式与命令式编程</a></p>\n<blockquote>\n<p>声明式和命令式编程范例只不过是描述在不同抽象层次上编码的流行词。声明式编程关注的是“做什么，而不是如何做”，而命令式编程则关注的是“如何做，而不是做什么”。声明式编程是在比命令式编程更高的抽象层次上进行编程。两者都有其适用的地方，例如在网页开发中使用框架时需要声明式编程，而在设计算法和其他底层需求时则需要命令式编程。</p>\n</blockquote>\n</li>\n</ul>\n<h4 id=\"数据结构\"><a href=\"#数据结构\" class=\"headerlink\" title=\"数据结构\"></a>数据结构</h4><ul>\n<li><p>基本数据结构（基本类型、数组、矩阵、对象…）</p>\n</li>\n<li><p>缓存和 memoization</p>\n<p>memoization 没有一个很好的词能翻译，大概意思就是通过存储函数调用的结果，并在再次使用相同输入调用函数时直接返回已存储的结果，从而加速计算逻辑。斐波那契数列就是一个使用 memoization 的例子</p>\n</li>\n<li><p>Hash codes、 tokens、编码（比如 Base64）</p>\n</li>\n<li><p><a href=\"https://stackoverflow.com/a/80113/1213497\">栈与堆内存</a> </p>\n<p>链接指向一则在 <a href=\"https://stackoverflow.com/questions/79923/what-and-where-are-the-stack-and-heap/80113#80113\">stackoverflow</a>  提出堆栈相关的诸多疑问，最高数回答解释了堆栈两种内存分配方式的基本概念、操作方式和性能差异，其中栈内存分配方式由于其后进先出的特性和近距离的存取模式，使得其在内存分配和回收上更加高效；而堆内存分配方式由于其动态和灵活的特性，对内存的管理相对复杂，但能够满足更多的内存需求</p>\n</li>\n</ul>\n<h4 id=\"代码整洁\"><a href=\"#代码整洁\" class=\"headerlink\" title=\"代码整洁\"></a>代码整洁</h4><ul>\n<li><p>懂得命名对代码的可读性的重要性</p>\n</li>\n<li><p>避免过长的方法和类，确保职责被划分到各个方法或者类中</p>\n</li>\n<li><p>遵循约定来管理项目结构</p>\n</li>\n<li><p>将复杂的布尔条件提取到命名良好的函数中</p>\n</li>\n<li><p>尽量编写尽可能自解释的代码（即通过阅读代码就能容易理解代码的功能）</p>\n</li>\n<li><p>良好的命名和轻量的文档而不是行内注释</p>\n<p><a href=\"https://www.codeproject.com/Articles/872073/Code-Comments-are-Lies\">代码注释通常可能会误导人</a>，因为它们经常被用作一种捷径，用来解释一段混乱的代码块的功能，而不是投入时间去重构它以提高其可读性。</p>\n<p>链接的文章主张编写清晰、自解释和可维护的代码，而不是过度依赖注释，同时也承认在某些特殊情况下，注释是有其必要性和价值的。</p>\n</li>\n<li><p>将文档编写为代码，理想情况下与代码一起，以便于维护（例如，在仓库中的“docs”文件夹中的 markdown 文件）</p>\n</li>\n<li><p>使用文档来描述“为什么”和“怎么做”（例如，目标、用例、组件、高级架构概述等）</p>\n</li>\n<li><p>在面向对象编程中，组合优于继承</p>\n</li>\n<li><p><a href=\"https://semver.org/\">Follow 语义化</a></p>\n</li>\n<li><p>了解TDD及其实践（例如，“红色，绿色，重构”）</p>\n<blockquote>\n<p><strong>TDD</strong>(测试驱动开发)是戴两顶帽子思考的开发方式：先戴上实现功能的帽子，在测试的辅助下，快速实现其功能；再戴上测试驱动开发的帽子，在测试的保护下，通过去除冗余的代码，提高代码品质。测试驱动着整个开发过程：首先，驱动代码的设计和功能的实现；其后，驱动代码的再设计和重构。</p>\n<ul>\n<li><p>红色：首先编写一个针对新功能的测试用例，此时由于功能尚未实现，测试用例将无法通过（失败，显示红色）</p>\n</li>\n<li><p>绿色：接下来编写功能代码，使得测试用例能够通过（成功，显示绿色）。在这个阶段，重点是让测试通过，而不是编写完美的代码。</p>\n</li>\n<li><p>重构：在测试用例通过后，对功能代码进行优化和重构，提高代码质量，同时确保测试用例仍然能够通过。</p>\n</li>\n</ul>\n</blockquote>\n</li>\n</ul>\n<h4 id=\"源码管理能力\"><a href=\"#源码管理能力\" class=\"headerlink\" title=\"源码管理能力\"></a>源码管理能力</h4><ul>\n<li><p>CVS（控制版本系统）&#x2F; SCM（源代码管理）基础知识：分支、标签、集中式与分散式等</p>\n</li>\n<li><p>SCM与仓库管理&#x2F;托管的区别（即<a href=\"https://stackoverflow.com/a/13321586\">Git与GitHub之间的区别</a>）</p>\n</li>\n<li><p>理解版本化的重要性</p>\n</li>\n<li><p>Commit 最佳实践</p>\n<ul>\n<li><p><a href=\"https://lucasr.org/2011/01/29/micro-commits/\">微提交</a> &#x2F;原子提交，良好的描述等</p>\n</li>\n<li><p><a href=\"https://www.conventionalcommits.org/en/v1.0.0/\">常规提交</a></p>\n</li>\n</ul>\n</li>\n<li><p>功能分支（短期）</p>\n</li>\n<li><p>基于主干的开发</p>\n</li>\n<li><p>依赖管理（包管理器的重要性，依赖地狱的风险等）</p>\n</li>\n</ul>\n<h4 id=\"技术合作\"><a href=\"#技术合作\" class=\"headerlink\" title=\"技术合作\"></a>技术合作</h4><ul>\n<li><p><a href=\"https://blog.github.com/2015-01-21-how-to-write-the-perfect-pull-request/\">代码 review 最佳实践</a></p>\n<ul>\n<li>一句话来说就是：在执行代码审查时关注相关部分。目的是学习，而不是指责。</li>\n</ul>\n</li>\n<li><p><a href=\"https://martinfowler.com/articles/on-pair-programming.html\">结对编程</a></p>\n<p>这篇文章主要讨论了结对编程（Pair Programming）的相关主题，包括其风格、时间管理、轮换策略、日常规划、物理环境设置、远程配对等方面。还探讨了结对编程的好处和挑战，以及如何说服管理者和同事采用这种方法。此外，文章还涉及了一些与配对编程相关的细节和常见问题</p>\n</li>\n</ul>\n<h4 id=\"DevOps-实践\"><a href=\"#DevOps-实践\" class=\"headerlink\" title=\"DevOps 实践\"></a>DevOps 实践</h4><ul>\n<li><p>自动化构建</p>\n</li>\n<li><p>构件仓库和镜像注册表</p>\n</li>\n<li><p>编写自动化测试</p>\n</li>\n<li><p>单元、集成和端到端（e2e）测试之间的区别</p>\n</li>\n<li><p>测试金字塔</p>\n</li>\n<li><p>持续集成</p>\n</li>\n<li><p>持续交付与持续部署</p>\n</li>\n<li><p>功能 Flag 和功能开关</p>\n</li>\n</ul>\n<h4 id=\"通用技术知识\"><a href=\"#通用技术知识\" class=\"headerlink\" title=\"通用技术知识\"></a>通用技术知识</h4><h5 id=\"语言理论知识\"><a href=\"#语言理论知识\" class=\"headerlink\" title=\"语言理论知识\"></a>语言理论知识</h5><ul>\n<li><p>正则表达式（regex）</p>\n</li>\n<li><p>编译型与解释型语言</p>\n</li>\n<li><p><a href=\"https://medium.com/@cpave3/understanding-types-static-vs-dynamic-strong-vs-weak-88a4e1f0ed5f\">动态与静态 &amp; 弱类型与强类型语言类型</a></p>\n</li>\n</ul>\n<h5 id=\"优化\"><a href=\"#优化\" class=\"headerlink\" title=\"优化\"></a>优化</h5><ul>\n<li><p>懒加载</p>\n</li>\n<li><p><a href=\"https://en.wikipedia.org/wiki/Profiling_(computer_programming)\">性能分析</a></p>\n</li>\n</ul>\n<h5 id=\"并发\"><a href=\"#并发\" class=\"headerlink\" title=\"并发\"></a>并发</h5><ul>\n<li><p>竞态条件</p>\n</li>\n<li><p>死锁</p>\n</li>\n<li><p>互斥</p>\n</li>\n</ul>\n<h3 id=\"特定领域技术知识\"><a href=\"#特定领域技术知识\" class=\"headerlink\" title=\"特定领域技术知识\"></a>特定领域技术知识</h3><p>在某些情况下，您可能希望工程师已经了解某些特定领域，例如前端、后端、架构、基础设施或安全方面。在这些情况下，还有一些跨框架的概念和原则，可用于推动针对每个领域的特定技术知识的内容。</p>\n<h4 id=\"前端开发\"><a href=\"#前端开发\" class=\"headerlink\" title=\"前端开发\"></a>前端开发</h4><ul>\n<li><p>API通信（不同的架构标准，数据如何传输…）</p>\n</li>\n<li><p>DOM（定义，理解，虚拟DOM…）</p>\n</li>\n<li><p>浏览器事件</p>\n</li>\n<li><p>响应式设计（目的，优点，渐进增强…）</p>\n</li>\n<li><p>客户端渲染（CSR）与服务器端渲染（SSR）</p>\n</li>\n<li><p>分页</p>\n</li>\n<li><p>状态管理（相关问题，无状态方法…）</p>\n</li>\n<li><p>MVC 和相关的衍生品</p>\n</li>\n<li><p>WebSockets 网络通信协议</p>\n</li>\n</ul>\n<h4 id=\"后端开发\"><a href=\"#后端开发\" class=\"headerlink\" title=\"后端开发\"></a>后端开发</h4><ul>\n<li><p>API设计（不同的架构标准，数据如何传输…）</p>\n</li>\n<li><p><a href=\"https://en.wikipedia.org/wiki/Message_broker\">消息代理</a></p>\n</li>\n<li><p>关系型数据库（它们是如何工作的，基本概念…）</p>\n</li>\n<li><p>非关系型数据库</p>\n</li>\n<li><p>数据库设计</p>\n</li>\n<li><p>ORM（对象关系映射）</p>\n</li>\n<li><p>批处理进程 &#x2F; 定时任务</p>\n</li>\n<li><p>会话处理</p>\n</li>\n<li><p><a href=\"https://lti.umuc.edu/contentadaptor/topics/byid/db0a8c4f-f738-4674-9f60-b75323cdb07f\">错误处理、审查、日志记录</a></p>\n</li>\n</ul>\n<h4 id=\"架构\"><a href=\"#架构\" class=\"headerlink\" title=\"架构\"></a>架构</h4><ul>\n<li><p>API</p>\n<ul>\n<li><p>标准协议：REST &#x2F; SOAP </p>\n</li>\n<li><p>安全性（例如拦截机器人，控制账户接管攻击等）</p>\n</li>\n<li><p>针对第三方服务故障的弹性橱窗（例如断路器）</p>\n</li>\n</ul>\n</li>\n<li><p>外部可配置化</p>\n</li>\n<li><p><a href=\"https://www.romenrg.com/blog/2019/12/31/everything-as-code/\">万物皆代码（即配置即代码，基础设施即代码，文档即代码…）</a></p>\n</li>\n<li><p>单体应用与微服务</p>\n</li>\n<li><p>领域驱动设计（DDD）</p>\n</li>\n<li><p>六边形架构</p>\n</li>\n<li><p>服务 Mesh</p>\n</li>\n<li><p>相关的互联网协议及其用法（如 HTTP, HTTPS, TCP, UDP, LDAP, SSH, SMTP…）</p>\n</li>\n<li><p><a href=\"https://en.wikipedia.org/wiki/Data_modeling\">数据建模</a></p>\n</li>\n</ul>\n<h4 id=\"基础设施\"><a href=\"#基础设施\" class=\"headerlink\" title=\"基础设施\"></a>基础设施</h4><ul>\n<li><p>虚拟机与容器</p>\n</li>\n<li><p>进程与线程</p>\n</li>\n<li><p>控制器-代理&#x2F;主副本模式</p>\n</li>\n<li><p>C&#x2F;S模式</p>\n</li>\n<li><p>IAAS, PAAS, SASS</p>\n</li>\n<li><p>Web服务器</p>\n</li>\n<li><p>反向代理</p>\n</li>\n<li><p>负载均衡</p>\n</li>\n<li><p>冗余</p>\n</li>\n<li><p>延迟</p>\n</li>\n<li><p>监控</p>\n</li>\n<li><p><a href=\"https://docs.honeycomb.io/learning-about-observability/intro-to-observability/\">可监控性</a></p>\n</li>\n</ul>\n<h4 id=\"安全\"><a href=\"#安全\" class=\"headerlink\" title=\"安全\"></a>安全</h4><ul>\n<li><p>身份和访问管理（IAM）</p>\n<ul>\n<li><p>认证（JWT, SSO）</p>\n</li>\n<li><p>授权（RBAC, ABAC）</p>\n</li>\n</ul>\n</li>\n<li><p>公钥密码系统（例如RSA）</p>\n</li>\n<li><p>加密协议（TLS, SSL）</p>\n</li>\n<li><p>最小权限原则</p>\n</li>\n<li><p>DoS &#x2F; DDoS</p>\n</li>\n<li><p>SQL 注入</p>\n</li>\n<li><p>中间人攻击</p>\n</li>\n<li><p>XSS（跨站脚本攻击） 和 CSRF（跨站请求伪造）</p>\n</li>\n</ul>\n","cover":null,"images":[],"content":"<p>最近在 Github 看到这一篇将程序员一直需要使用的非技术核心能力进行了总结，深受里面内容的启发，语言、框架都是会过时的，但有些技能无论是什么语言或者框架都是通用的，如果要在这个行业持续深根，那么这些非技术能力是必备的且实用的。本文在原文上进行翻译，并对文中提到部分专业术语进行了解释，以及对指向外部链接的文档内容作了一些简单的概述，希望能帮助到查看此文档的人。</p>\n<p>原文地址：<a href=\"https://github.com/romenrg/evergreen-skills-developers.git\">evergreen-skills-developers</a></p>\n<p>中英双文地址：<a href=\"https://github.com/VomPom/evergreen-skills-developers/blob/master/README_en_cn.md\">[译]evergreen-skills-developers</a></p>\n<h2 id=\"原文翻译：\"><a href=\"#原文翻译：\" class=\"headerlink\" title=\"原文翻译：\"></a>原文翻译：</h2><p>这个仓库包括了一份“常青技能”清单，这份清单应该可以作为对技术精湛的软件工程师&#x2F;开发者客观评价。</p>\n<p>这份工作的是为了在招聘软件开发者&#x2F;工程师时，提供一个替代的技术面试的方案。文档关注的是软开发最佳实践、跨框架原则和通用的技能；而不是我们在行业中经常看到的语言层面，或者特定技术框架的内容。</p>\n<p>编程语言不断进化，公司也不断改变他们的技术栈，框架很快就会过时，有经验的工程师使用搜索引擎能在几分钟就能解决语法相关的问题。因此，在面试候选人时关注这些方面是否有意义呢？</p>\n<p>另一方面，技术框架以外的原理和非技术的技能是在谷歌上查不到的，这些技能是“常青”的，并且对工程师的表现有巨大的影响。这些更能反映出软件开发者&#x2F;工程师为团队带来的真正价值。</p>\n<p>这个仓库是基于以下文章的一个衍生作品：”<a href=\"https://www.romenrg.com/blog/2018/12/29/what-makes-a-great-software-engineer\">是什么造就了一位伟大的软件工程师</a>“。</p>\n<p>这是一个正在进行中的工作。重要的知识可能缺失，现有的条目可能可以改进，更好的分组策略也可能被发现。因此，任何贡献（即PR或问题）都是受欢迎的。请随时按照<a href=\"https://gptx.woa.com/CONTRIBUTING.md\">贡献指南</a>提出修改建议。</p>\n<h2 id=\"目录\"><a href=\"#目录\" class=\"headerlink\" title=\"目录\"></a>目录</h2><ul>\n<li><p><a href=\"#%E9%9D%9E%E6%8A%80%E6%9C%AF%E6%8A%80%E8%83%BD\">非技术技能</a></p>\n<ul>\n<li><a href=\"#%E6%A0%B8%E5%BF%83%E6%8A%80%E8%83%BD%EF%BC%88%E5%8F%88%E7%A7%B0%E2%80%9C%E8%BD%AF%E6%8A%80%E8%83%BD%E2%80%9D%EF%BC%89\">核心技能</a><ul>\n<li><a href=\"#%E4%BA%A4%E6%B5%81\">交流</a></li>\n<li><a href=\"#%E5%9B%A2%E9%98%9F\">团队</a></li>\n</ul>\n</li>\n<li><a href=\"#%E5%88%9B%E6%96%B0%E5%92%8C%E8%87%AA%E6%88%91%E7%AE%A1%E7%90%86%E6%8A%80%E8%83%BD\">创新和自我管理技能</a><ul>\n<li><a href=\"#%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B\">开发流程</a></li>\n<li><a href=\"#%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E8%83%BD%E5%8A%9B\">问题解决能力</a></li>\n<li><a href=\"#%E5%BF%83%E6%80%81\">心态</a></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p><a href=\"#%E6%8A%80%E8%83%BD%E8%83%BD%E5%8A%9B\">技能能力</a></p>\n<ul>\n<li><a href=\"#%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF%E8%83%BD%E5%8A%9B\">通用技术能力</a></li>\n<li><a href=\"#%E7%BC%96%E7%A8%8B%E5%87%86%E5%88%99\">编程准则</a><ul>\n<li><a href=\"#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84\">数据结构</a> </li>\n<li><a href=\"#%E4%BB%A3%E7%A0%81%E6%95%B4%E6%B4%81\">代码整洁</a></li>\n<li><a href=\"#%E6%BA%90%E7%A0%81%E7%AE%A1%E7%90%86\">源码管理</a></li>\n<li><a href=\"#%E6%8A%80%E6%9C%AF%E5%90%88%E4%BD%9C\">技术合作</a></li>\n<li><a href=\"#DevOps%E5%AE%9E%E8%B7%B5\">DevOps实践</a></li>\n<li><a href=\"%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86\">通用技术知识</a><ul>\n<li><a href=\"#%E8%AF%AD%E8%A8%80%E7%90%86%E8%AE%BA%E7%9F%A5%E8%AF%86\">语言理论知识</a></li>\n<li><a href=\"#%E4%BC%98%E5%8C%96\">优化</a></li>\n<li><a href=\"#%E5%B9%B6%E5%8F%91\">并发</a></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p><a href=\"#%E7%89%B9%E5%AE%9A%E9%A2%86%E5%9F%9F%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86\">特定领域技术知识</a></p>\n<ul>\n<li><p><a href=\"#%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91\">前端开发</a></p>\n</li>\n<li><p><a href=\"#%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91\">后端开发</a></p>\n</li>\n<li><p><a href=\"#%E6%9E%B6%E6%9E%84\">架构</a></p>\n</li>\n<li><p><a href=\"#%E5%9F%BA%E7%A1%80%E5%BB%BA%E8%AE%BE\">基础建设</a></p>\n</li>\n<li><p><a href=\"#%E5%AE%89%E5%85%A8\">安全</a></p>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"非技术技能\"><a href=\"#非技术技能\" class=\"headerlink\" title=\"非技术技能\"></a>非技术技能</h2><p>以下非技术能力可能是开发者最重要的能力。尽管一个人可能具备很强的技术能力，但在公司中没有良好的沟通、团队合作态度、开发流程、解决问题的能力和学习的心态的话，一切会变得非常糟糕。</p>\n<h3 id=\"核心技能（又称“软技能”）\"><a href=\"#核心技能（又称“软技能”）\" class=\"headerlink\" title=\"核心技能（又称“软技能”）\"></a>核心技能（又称“软技能”）</h3><h4 id=\"交流\"><a href=\"#交流\" class=\"headerlink\" title=\"交流\"></a>交流</h4><ul>\n<li>遵循邮件使用的最佳策略(例： <a href=\"https://www.grammarly.com/blog/email-etiquette-rules-to-know/\">some e-mail etiquette rules</a>)</li>\n</ul>\n<ul>\n<li><p>遵循沟通的最佳策略 (e.g. <a href=\"https://slack.com/intl/en-es/help/articles/115000769927-Use-threads-to-organize-discussions-\">use threads to organize discussions</a> and <a href=\"https://blog.rescuetime.com/slack-focus-guide/\">other best-practices from Slack</a>)</p>\n<p>两份链接指向的 slack 的一则使用文档和一份 slack 使用技巧文档</p>\n</li>\n<li><p><a href=\"https://jaxenter.com/aaaand-gone-true-cost-interruptions-128741.html\">最小化干扰</a></p>\n<p>链接指向的文章是一篇关于程序员在工作中，因被其他事项而中断程序开发的影响，一般人，在工作过程中断打扰后大约需要23分钟才能恢复到之前的状态，而程序员需要更久，文中强调了工作中断对程序员工作效率和心情的影响，并讨论了有计划和非计划性中断的不同影响。</p>\n</li>\n<li><p>保持礼貌</p>\n</li>\n</ul>\n<h4 id=\"团队\"><a href=\"#团队\" class=\"headerlink\" title=\"团队\"></a>团队</h4><ul>\n<li><p><a href=\"https://simpleprogrammer.com/empathy-software-developers\">练习同理心</a></p>\n</li>\n<li><p>保持谦逊和低调</p>\n</li>\n<li><p>做一个积极倾听的人</p>\n</li>\n<li><p>做一个好的导师</p>\n</li>\n<li><p>知识分享</p>\n</li>\n<li><p>得有见地</p>\n</li>\n</ul>\n<h3 id=\"创新和自我管理技能\"><a href=\"#创新和自我管理技能\" class=\"headerlink\" title=\"创新和自我管理技能\"></a>创新和自我管理技能</h3><h4 id=\"开发流程\"><a href=\"#开发流程\" class=\"headerlink\" title=\"开发流程\"></a>开发流程</h4><ul>\n<li><p>了解<a href=\"https://agilemanifesto.org/principles.html\">《敏捷开发原则》</a></p>\n</li>\n<li><p>适应迭代和增量开发</p>\n</li>\n<li><p>自组织的能力</p>\n<p>指的是个体或系统能够自发地、无需外部强制指挥，根据内部规则和相互作用来组织自身结构和行为的能力。这种能力在多个层面都有体现，包括个人自我管理、团队协作以及更广泛的社会和生态系统</p>\n</li>\n<li><p>避免产生错误的预估（比如：工时预估）</p>\n</li>\n<li><p>关注优先级和业务价值</p>\n</li>\n</ul>\n<h4 id=\"问题解决能力\"><a href=\"#问题解决能力\" class=\"headerlink\" title=\"问题解决能力\"></a>问题解决能力</h4><ul>\n<li><p>使用科学方法(<a href=\"https://en.wikipedia.org/wiki/Scientific_method\">Scientific Method</a>)</p>\n<blockquote>\n<p>科学方法是一种有系统地寻求知识的程序，涉及了以下三个步骤：问题的认知与表述、实验数据的收集、假说的构成与测试。</p>\n</blockquote>\n</li>\n<li><p>检索能力</p>\n</li>\n<li><p>横向思维</p>\n<blockquote>\n<p>横向思维，指使用间接的、具有创造力的、不是一望而知的推理方式来解决问题</p>\n</blockquote>\n</li>\n<li><p>抽象化能力</p>\n</li>\n<li><p>创造力</p>\n</li>\n<li><p><a href=\"http://en.wikipedia.org/wiki/5_Whys\">五问法</a></p>\n<blockquote>\n<p>五问法关键所在就是，鼓励解决问题的人要努力避开主观或自负的假设和逻辑陷阱，从结果着手，沿着因果关系链条，顺藤摸瓜，穿越不同的抽象层面，直至找出原有问题的根本原因。简而言之，就是鼓励解决问题的人要有“打破砂锅问到底”的精神。</p>\n</blockquote>\n</li>\n<li><p>风险管理</p>\n</li>\n</ul>\n<h4 id=\"心态\"><a href=\"#心态\" class=\"headerlink\" title=\"心态\"></a>心态</h4><ul>\n<li><p>不要害怕变化</p>\n</li>\n<li><p>敢于失败</p>\n</li>\n<li><p>终生学习</p>\n</li>\n<li><p><a href=\"https://en.wikipedia.org/wiki/Critical_thinking\">批判性思维</a> （保持理性，质疑决定，“让事实说话”）</p>\n</li>\n</ul>\n<h2 id=\"技能能力\"><a href=\"#技能能力\" class=\"headerlink\" title=\"技能能力\"></a>技能能力</h2><h3 id=\"通用技术能力\"><a href=\"#通用技术能力\" class=\"headerlink\" title=\"通用技术能力\"></a>通用技术能力</h3><p>有一些技术知识是永恒的，对任何软件工程师都有关，尽管他们将要从事的具体领域各不相同。为了深入了解他们的资历并了解他们的工程实践有多扎实，你可以和他们就编程原理、数据结构、清晰的代码、源代码管理、技术协作或者DevOps实践等主题进行交谈。如果这些基础扎实，他们可能能够毫无问题地学习你们特定领域的东西。</p>\n<h4 id=\"编程准则\"><a href=\"#编程准则\" class=\"headerlink\" title=\"编程准则\"></a>编程准则</h4><ul>\n<li><p>基本流程结构和逻辑代数</p>\n</li>\n<li><p>面向对象编程</p>\n</li>\n<li><p><a href=\"https://en.wikipedia.org/wiki/SOLID\">SOLID</a>, <a href=\"https://en.wikipedia.org/wiki/GRASP_(object-oriented_design)\">GRASP</a>面向对象设计</p>\n<blockquote>\n<p><strong>SOLID</strong>（单一功能、开闭原则、里氏替换、接口隔离以及依赖反转）</p>\n</blockquote>\n</li>\n</ul>\n<blockquote>\n<table>\n<thead>\n<tr>\n<th align=\"center\"></th>\n<th></th>\n<th></th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">S</td>\n<td><a href=\"https://zh.wikipedia.org/wiki/%E5%8D%95%E4%B8%80%E5%8A%9F%E8%83%BD%E5%8E%9F%E5%88%99\">单一功能原则</a></td>\n<td>认为“对象应该仅具有一种单一功能”的概念。</td>\n</tr>\n<tr>\n<td align=\"center\">O</td>\n<td><a href=\"https://zh.wikipedia.org/wiki/%E5%BC%80%E9%97%AD%E5%8E%9F%E5%88%99\">开闭原则</a></td>\n<td>认为“软件应该是对于扩展开放的，但是对于修改封闭的”的概念。</td>\n</tr>\n<tr>\n<td align=\"center\">L</td>\n<td><a href=\"https://zh.wikipedia.org/wiki/%E9%87%8C%E6%B0%8F%E6%9B%BF%E6%8D%A2%E5%8E%9F%E5%88%99\">里氏替换原则</a></td>\n<td>认为“程序中的对象应该是可以在不改变程序正确性的前提下被它的子类所替换的”的概念。参考契约式设计。</td>\n</tr>\n<tr>\n<td align=\"center\">I</td>\n<td><a href=\"https://zh.wikipedia.org/wiki/%E6%8E%A5%E5%8F%A3%E9%9A%94%E7%A6%BB%E5%8E%9F%E5%88%99\">接口隔离原则</a></td>\n<td>认为“多个特定客户端接口要好于一个宽泛用途的接口”的概念。</td>\n</tr>\n<tr>\n<td align=\"center\">D</td>\n<td><a href=\"https://zh.wikipedia.org/wiki/%E4%BE%9D%E8%B5%96%E5%8F%8D%E8%BD%AC%E5%8E%9F%E5%88%99\">依赖反转原则</a></td>\n<td>认为一个方法应该遵从“依赖于抽象而不是一个实例”的概念。 依赖注入是该原则的一种实现方式。</td>\n</tr>\n</tbody></table>\n<p><strong>GRASP</strong>中提到的模式和原则包括有控制器（controller）、创建者（creator）、中介（indirection）、信息专家（information expert）、低耦合性（low coupling）、高内聚性（high cohesion）、多态（polymorphism）、保护变化（protected variations）和纯虚构（pure Fabrication）[2]</p>\n</blockquote>\n<ul>\n<li><p>函数式编程（纯函数、不变性、递归……）</p>\n</li>\n<li><p><a href=\"http://amzotti.github.io/programming%20paradigms/2015/02/13/what-is-the-difference-between-procedural-function-imperative-and-declarative-programming-paradigms/\">声明式与命令式编程</a></p>\n<blockquote>\n<p>声明式和命令式编程范例只不过是描述在不同抽象层次上编码的流行词。声明式编程关注的是“做什么，而不是如何做”，而命令式编程则关注的是“如何做，而不是做什么”。声明式编程是在比命令式编程更高的抽象层次上进行编程。两者都有其适用的地方，例如在网页开发中使用框架时需要声明式编程，而在设计算法和其他底层需求时则需要命令式编程。</p>\n</blockquote>\n</li>\n</ul>\n<h4 id=\"数据结构\"><a href=\"#数据结构\" class=\"headerlink\" title=\"数据结构\"></a>数据结构</h4><ul>\n<li><p>基本数据结构（基本类型、数组、矩阵、对象…）</p>\n</li>\n<li><p>缓存和 memoization</p>\n<p>memoization 没有一个很好的词能翻译，大概意思就是通过存储函数调用的结果，并在再次使用相同输入调用函数时直接返回已存储的结果，从而加速计算逻辑。斐波那契数列就是一个使用 memoization 的例子</p>\n</li>\n<li><p>Hash codes、 tokens、编码（比如 Base64）</p>\n</li>\n<li><p><a href=\"https://stackoverflow.com/a/80113/1213497\">栈与堆内存</a> </p>\n<p>链接指向一则在 <a href=\"https://stackoverflow.com/questions/79923/what-and-where-are-the-stack-and-heap/80113#80113\">stackoverflow</a>  提出堆栈相关的诸多疑问，最高数回答解释了堆栈两种内存分配方式的基本概念、操作方式和性能差异，其中栈内存分配方式由于其后进先出的特性和近距离的存取模式，使得其在内存分配和回收上更加高效；而堆内存分配方式由于其动态和灵活的特性，对内存的管理相对复杂，但能够满足更多的内存需求</p>\n</li>\n</ul>\n<h4 id=\"代码整洁\"><a href=\"#代码整洁\" class=\"headerlink\" title=\"代码整洁\"></a>代码整洁</h4><ul>\n<li><p>懂得命名对代码的可读性的重要性</p>\n</li>\n<li><p>避免过长的方法和类，确保职责被划分到各个方法或者类中</p>\n</li>\n<li><p>遵循约定来管理项目结构</p>\n</li>\n<li><p>将复杂的布尔条件提取到命名良好的函数中</p>\n</li>\n<li><p>尽量编写尽可能自解释的代码（即通过阅读代码就能容易理解代码的功能）</p>\n</li>\n<li><p>良好的命名和轻量的文档而不是行内注释</p>\n<p><a href=\"https://www.codeproject.com/Articles/872073/Code-Comments-are-Lies\">代码注释通常可能会误导人</a>，因为它们经常被用作一种捷径，用来解释一段混乱的代码块的功能，而不是投入时间去重构它以提高其可读性。</p>\n<p>链接的文章主张编写清晰、自解释和可维护的代码，而不是过度依赖注释，同时也承认在某些特殊情况下，注释是有其必要性和价值的。</p>\n</li>\n<li><p>将文档编写为代码，理想情况下与代码一起，以便于维护（例如，在仓库中的“docs”文件夹中的 markdown 文件）</p>\n</li>\n<li><p>使用文档来描述“为什么”和“怎么做”（例如，目标、用例、组件、高级架构概述等）</p>\n</li>\n<li><p>在面向对象编程中，组合优于继承</p>\n</li>\n<li><p><a href=\"https://semver.org/\">Follow 语义化</a></p>\n</li>\n<li><p>了解TDD及其实践（例如，“红色，绿色，重构”）</p>\n<blockquote>\n<p><strong>TDD</strong>(测试驱动开发)是戴两顶帽子思考的开发方式：先戴上实现功能的帽子，在测试的辅助下，快速实现其功能；再戴上测试驱动开发的帽子，在测试的保护下，通过去除冗余的代码，提高代码品质。测试驱动着整个开发过程：首先，驱动代码的设计和功能的实现；其后，驱动代码的再设计和重构。</p>\n<ul>\n<li><p>红色：首先编写一个针对新功能的测试用例，此时由于功能尚未实现，测试用例将无法通过（失败，显示红色）</p>\n</li>\n<li><p>绿色：接下来编写功能代码，使得测试用例能够通过（成功，显示绿色）。在这个阶段，重点是让测试通过，而不是编写完美的代码。</p>\n</li>\n<li><p>重构：在测试用例通过后，对功能代码进行优化和重构，提高代码质量，同时确保测试用例仍然能够通过。</p>\n</li>\n</ul>\n</blockquote>\n</li>\n</ul>\n<h4 id=\"源码管理能力\"><a href=\"#源码管理能力\" class=\"headerlink\" title=\"源码管理能力\"></a>源码管理能力</h4><ul>\n<li><p>CVS（控制版本系统）&#x2F; SCM（源代码管理）基础知识：分支、标签、集中式与分散式等</p>\n</li>\n<li><p>SCM与仓库管理&#x2F;托管的区别（即<a href=\"https://stackoverflow.com/a/13321586\">Git与GitHub之间的区别</a>）</p>\n</li>\n<li><p>理解版本化的重要性</p>\n</li>\n<li><p>Commit 最佳实践</p>\n<ul>\n<li><p><a href=\"https://lucasr.org/2011/01/29/micro-commits/\">微提交</a> &#x2F;原子提交，良好的描述等</p>\n</li>\n<li><p><a href=\"https://www.conventionalcommits.org/en/v1.0.0/\">常规提交</a></p>\n</li>\n</ul>\n</li>\n<li><p>功能分支（短期）</p>\n</li>\n<li><p>基于主干的开发</p>\n</li>\n<li><p>依赖管理（包管理器的重要性，依赖地狱的风险等）</p>\n</li>\n</ul>\n<h4 id=\"技术合作\"><a href=\"#技术合作\" class=\"headerlink\" title=\"技术合作\"></a>技术合作</h4><ul>\n<li><p><a href=\"https://blog.github.com/2015-01-21-how-to-write-the-perfect-pull-request/\">代码 review 最佳实践</a></p>\n<ul>\n<li>一句话来说就是：在执行代码审查时关注相关部分。目的是学习，而不是指责。</li>\n</ul>\n</li>\n<li><p><a href=\"https://martinfowler.com/articles/on-pair-programming.html\">结对编程</a></p>\n<p>这篇文章主要讨论了结对编程（Pair Programming）的相关主题，包括其风格、时间管理、轮换策略、日常规划、物理环境设置、远程配对等方面。还探讨了结对编程的好处和挑战，以及如何说服管理者和同事采用这种方法。此外，文章还涉及了一些与配对编程相关的细节和常见问题</p>\n</li>\n</ul>\n<h4 id=\"DevOps-实践\"><a href=\"#DevOps-实践\" class=\"headerlink\" title=\"DevOps 实践\"></a>DevOps 实践</h4><ul>\n<li><p>自动化构建</p>\n</li>\n<li><p>构件仓库和镜像注册表</p>\n</li>\n<li><p>编写自动化测试</p>\n</li>\n<li><p>单元、集成和端到端（e2e）测试之间的区别</p>\n</li>\n<li><p>测试金字塔</p>\n</li>\n<li><p>持续集成</p>\n</li>\n<li><p>持续交付与持续部署</p>\n</li>\n<li><p>功能 Flag 和功能开关</p>\n</li>\n</ul>\n<h4 id=\"通用技术知识\"><a href=\"#通用技术知识\" class=\"headerlink\" title=\"通用技术知识\"></a>通用技术知识</h4><h5 id=\"语言理论知识\"><a href=\"#语言理论知识\" class=\"headerlink\" title=\"语言理论知识\"></a>语言理论知识</h5><ul>\n<li><p>正则表达式（regex）</p>\n</li>\n<li><p>编译型与解释型语言</p>\n</li>\n<li><p><a href=\"https://medium.com/@cpave3/understanding-types-static-vs-dynamic-strong-vs-weak-88a4e1f0ed5f\">动态与静态 &amp; 弱类型与强类型语言类型</a></p>\n</li>\n</ul>\n<h5 id=\"优化\"><a href=\"#优化\" class=\"headerlink\" title=\"优化\"></a>优化</h5><ul>\n<li><p>懒加载</p>\n</li>\n<li><p><a href=\"https://en.wikipedia.org/wiki/Profiling_(computer_programming)\">性能分析</a></p>\n</li>\n</ul>\n<h5 id=\"并发\"><a href=\"#并发\" class=\"headerlink\" title=\"并发\"></a>并发</h5><ul>\n<li><p>竞态条件</p>\n</li>\n<li><p>死锁</p>\n</li>\n<li><p>互斥</p>\n</li>\n</ul>\n<h3 id=\"特定领域技术知识\"><a href=\"#特定领域技术知识\" class=\"headerlink\" title=\"特定领域技术知识\"></a>特定领域技术知识</h3><p>在某些情况下，您可能希望工程师已经了解某些特定领域，例如前端、后端、架构、基础设施或安全方面。在这些情况下，还有一些跨框架的概念和原则，可用于推动针对每个领域的特定技术知识的内容。</p>\n<h4 id=\"前端开发\"><a href=\"#前端开发\" class=\"headerlink\" title=\"前端开发\"></a>前端开发</h4><ul>\n<li><p>API通信（不同的架构标准，数据如何传输…）</p>\n</li>\n<li><p>DOM（定义，理解，虚拟DOM…）</p>\n</li>\n<li><p>浏览器事件</p>\n</li>\n<li><p>响应式设计（目的，优点，渐进增强…）</p>\n</li>\n<li><p>客户端渲染（CSR）与服务器端渲染（SSR）</p>\n</li>\n<li><p>分页</p>\n</li>\n<li><p>状态管理（相关问题，无状态方法…）</p>\n</li>\n<li><p>MVC 和相关的衍生品</p>\n</li>\n<li><p>WebSockets 网络通信协议</p>\n</li>\n</ul>\n<h4 id=\"后端开发\"><a href=\"#后端开发\" class=\"headerlink\" title=\"后端开发\"></a>后端开发</h4><ul>\n<li><p>API设计（不同的架构标准，数据如何传输…）</p>\n</li>\n<li><p><a href=\"https://en.wikipedia.org/wiki/Message_broker\">消息代理</a></p>\n</li>\n<li><p>关系型数据库（它们是如何工作的，基本概念…）</p>\n</li>\n<li><p>非关系型数据库</p>\n</li>\n<li><p>数据库设计</p>\n</li>\n<li><p>ORM（对象关系映射）</p>\n</li>\n<li><p>批处理进程 &#x2F; 定时任务</p>\n</li>\n<li><p>会话处理</p>\n</li>\n<li><p><a href=\"https://lti.umuc.edu/contentadaptor/topics/byid/db0a8c4f-f738-4674-9f60-b75323cdb07f\">错误处理、审查、日志记录</a></p>\n</li>\n</ul>\n<h4 id=\"架构\"><a href=\"#架构\" class=\"headerlink\" title=\"架构\"></a>架构</h4><ul>\n<li><p>API</p>\n<ul>\n<li><p>标准协议：REST &#x2F; SOAP </p>\n</li>\n<li><p>安全性（例如拦截机器人，控制账户接管攻击等）</p>\n</li>\n<li><p>针对第三方服务故障的弹性橱窗（例如断路器）</p>\n</li>\n</ul>\n</li>\n<li><p>外部可配置化</p>\n</li>\n<li><p><a href=\"https://www.romenrg.com/blog/2019/12/31/everything-as-code/\">万物皆代码（即配置即代码，基础设施即代码，文档即代码…）</a></p>\n</li>\n<li><p>单体应用与微服务</p>\n</li>\n<li><p>领域驱动设计（DDD）</p>\n</li>\n<li><p>六边形架构</p>\n</li>\n<li><p>服务 Mesh</p>\n</li>\n<li><p>相关的互联网协议及其用法（如 HTTP, HTTPS, TCP, UDP, LDAP, SSH, SMTP…）</p>\n</li>\n<li><p><a href=\"https://en.wikipedia.org/wiki/Data_modeling\">数据建模</a></p>\n</li>\n</ul>\n<h4 id=\"基础设施\"><a href=\"#基础设施\" class=\"headerlink\" title=\"基础设施\"></a>基础设施</h4><ul>\n<li><p>虚拟机与容器</p>\n</li>\n<li><p>进程与线程</p>\n</li>\n<li><p>控制器-代理&#x2F;主副本模式</p>\n</li>\n<li><p>C&#x2F;S模式</p>\n</li>\n<li><p>IAAS, PAAS, SASS</p>\n</li>\n<li><p>Web服务器</p>\n</li>\n<li><p>反向代理</p>\n</li>\n<li><p>负载均衡</p>\n</li>\n<li><p>冗余</p>\n</li>\n<li><p>延迟</p>\n</li>\n<li><p>监控</p>\n</li>\n<li><p><a href=\"https://docs.honeycomb.io/learning-about-observability/intro-to-observability/\">可监控性</a></p>\n</li>\n</ul>\n<h4 id=\"安全\"><a href=\"#安全\" class=\"headerlink\" title=\"安全\"></a>安全</h4><ul>\n<li><p>身份和访问管理（IAM）</p>\n<ul>\n<li><p>认证（JWT, SSO）</p>\n</li>\n<li><p>授权（RBAC, ABAC）</p>\n</li>\n</ul>\n</li>\n<li><p>公钥密码系统（例如RSA）</p>\n</li>\n<li><p>加密协议（TLS, SSL）</p>\n</li>\n<li><p>最小权限原则</p>\n</li>\n<li><p>DoS &#x2F; DDoS</p>\n</li>\n<li><p>SQL 注入</p>\n</li>\n<li><p>中间人攻击</p>\n</li>\n<li><p>XSS（跨站脚本攻击） 和 CSRF（跨站请求伪造）</p>\n</li>\n</ul>\n","categories":[],"tags":[],"api":"api/posts/2024/07/09/软件开发人员的常青技能.json"},{"title":"UTF-8字符编码相关","slug":"关于Windows中文字符乱码","date":"2024-04-11T06:23:00.000Z","updated":"2025-05-20T11:46:57.000Z","comments":true,"url":"2024/04/11/关于Windows中文字符乱码/","excerpt":"<p>最近在 Windows 上开发一些逻辑的时候遇到一些关于中文的坑，中文路径会乱码，是由于 Window 系统默认的编码格式是 <strong>GBK</strong>，而传入的参数编码格式是 <strong>UTF-8</strong>，导致整个程序出错。后续使用了&#96;&#96;MultiByteToWideChar<code> 和</code>WideCharToMultiByte&#96; 方法对编码进行一次改变，从而避免了这个问题的产生。但不了解相关原因，经过一番学习，对相关的概念进行一些简单的总结，并对一些 api  的实现源码进行分析。</p>\n<h3 id=\"ASCII-码\"><a href=\"#ASCII-码\" class=\"headerlink\" title=\"ASCII 码\"></a>ASCII 码</h3><p> ASCII ( American Standard Code for Information Interchange)<br> 256个符号，从 00000000 到 11111111    </p>\n<h3 id=\"ANSI\"><a href=\"#ANSI\" class=\"headerlink\" title=\"ANSI\"></a>ANSI</h3><p>ANSI（American National Standards Institute，美国国家标准协会）编码：ANSI 编码是一种基于 8 位的字符编码。它包含了 128 个美国英语字符和其他 128 个特殊字符，共 256 个字符。ANSI 编码主要用于表示英语字符，但它的局限性在于无法表示其他语言的字符。为了解决这个问题，各国家和地区分别制定了自己的 ANSI 编码标准，但这又引入了新的问题，即不同编码之间的互不兼容。</p>\n<p>​       美国和西欧：Windows-1252<br>​       中文（简体）：GB2312 或 GBK<br>​       中文（繁体）：Big5<br>​       日文：Shift-JIS<br>​       韩文：EUC-KR   </p>\n<h3 id=\"Unicode\"><a href=\"#Unicode\" class=\"headerlink\" title=\"Unicode\"></a>Unicode</h3><p>为了解决字符编码之间的兼容性问题，Unicode 标准应运而生。Unicode 是一种包含世界上大多数字符的编码方案，它为每个字符分配一个唯一的数字（称为码点），无论在任何平台、程序或语言中，都可以表示这些字符。Unicode 有多种实现方式，如 UTF-8、UTF-16 和 UTF-32。UTF-8 是最常用的 Unicode 实现方式，它是一种变长编码，可以使用 1 到 4 个字节来表示一个字符，这使得它在存储和传输方面更加高效</p>\n<p>  “FE FF” 是 Unicode 字符串的字节顺序标记（Byte Order Mark，简称 BOM），用于表示字符串的字节顺序<br>  Unicode Little-Endian，”FF FE”<br>  Unicode Big-Endian，”FE FF”</p>\n<h3 id=\"UTF-8\"><a href=\"#UTF-8\" class=\"headerlink\" title=\"UTF-8\"></a>UTF-8</h3><p>UTF-8 是 Unicode 的实现方式之一  ，是一种变长编码，它使用 1 到 4 个字节（8 位）来表示一个字符</p>\n<p><strong>单字节</strong>   所有的ASCII 字符<br><strong>二字节</strong>  带有附加符号的拉丁文、希腊文、西里尔字母、亚美尼亚语、希伯来文、阿拉伯文、叙利亚文及它拿字母则需要二个字节编码                </p>\n<p><strong>三字节</strong> 基本等同于GBK，含21000多个汉字 </p>\n<p><strong>四字节</strong> 中日韩超大字符集里面的汉字，有5万多个</p>\n<p><strong>UTF-8编码对照表</strong></p>\n<table>\n<thead>\n<tr>\n<th>Unicode 符号范围   (十六进制)</th>\n<th>UTF-8编码方式（二进制）</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>0000 0000 ~ 0000 007F</td>\n<td>0xxxxxxx</td>\n</tr>\n<tr>\n<td>0000 0080 ~ 0000 07FF</td>\n<td>110xxxxx 10xxxxxx</td>\n</tr>\n<tr>\n<td>0000 0800 ~ 0000 FFFF</td>\n<td>1110xxxx 10xxxxxx 10xxxxxx</td>\n</tr>\n<tr>\n<td>0001 0000 ~ 0010 FFFF</td>\n<td>11110xxx 10xxxxxx 10xxxxxx 10xxxxxx</td>\n</tr>\n</tbody></table>\n<h3 id=\"源码阅读：Java-String-toUtf8\"><a href=\"#源码阅读：Java-String-toUtf8\" class=\"headerlink\" title=\"源码阅读：Java String toUtf8\"></a>源码阅读：Java String toUtf8</h3><p> Java 的 String 默认用 UTF-16 存储数据，String 类的方法<code>.getBytes(StandardCharsets.UTF_8)</code> 将指定的字符集将字符串编码为 byte 序列，并将结果存储到一个新的 byte 数组中。</p>\n<p>其主要逻辑在:<a href=\"https://android.googlesource.com/platform/libcore/+/master/luni/src/main/java/libcore/util/CharsetUtils.java#46\">CharsetUtils.java#toUtf8Bytes</a></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">native</span> <span class=\"type\">byte</span>[] toUtf8Bytes(String s, <span class=\"type\">int</span> offset, <span class=\"type\">int</span> length);</span><br></pre></td></tr></table></figure>\n\n<p>对应的最终实现：<a href=\"https://android.googlesource.com/platform/libcore/+/3e8abdd9bdca823a635aac3adacf71ef227b18e1/luni/src/main/native/java_nio_charset_Charsets.cpp#183\">java_nio_charset_Charsets.cpp#Charsets_toUtf8Bytes</a> </p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">static</span> jbyteArray <span class=\"title\">Charsets_toUtf8Bytes</span><span class=\"params\">(JNIEnv* env, jclass, jcharArray javaChars, jint offset, jint length)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// ....此处省略 一些检查逻辑</span></span><br><span class=\"line\">    <span class=\"type\">const</span> <span class=\"type\">int</span> end = offset + length;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = offset; i &lt; end; ++i) &#123;</span><br><span class=\"line\">        jint ch = chars[i];</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (ch &lt; <span class=\"number\">0x80</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 单字节直接放进去</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!out.<span class=\"built_in\">append</span>(ch)) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (ch &lt; <span class=\"number\">0x800</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 双字节</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!out.<span class=\"built_in\">append</span>((ch &gt;&gt; <span class=\"number\">6</span>) | <span class=\"number\">0xc0</span>) || !out.<span class=\"built_in\">append</span>((ch &amp; <span class=\"number\">0x3f</span>) | <span class=\"number\">0x80</span>)) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"built_in\">U16_IS_SURROGATE</span>(ch)) &#123;</span><br><span class=\"line\">          \t<span class=\"comment\">// ....此处省略 UTF-16 代理字符串相关的逻辑</span></span><br><span class=\"line\">            ch = <span class=\"built_in\">U16_GET_SUPPLEMENTARY</span>(high, low);</span><br><span class=\"line\">            <span class=\"comment\">// 四字节 </span></span><br><span class=\"line\">            jbyte b1 = (ch &gt;&gt; <span class=\"number\">18</span>) | <span class=\"number\">0xf0</span>;</span><br><span class=\"line\">            jbyte b2 = ((ch &gt;&gt; <span class=\"number\">12</span>) &amp; <span class=\"number\">0x3f</span>) | <span class=\"number\">0x80</span>;</span><br><span class=\"line\">            jbyte b3 = ((ch &gt;&gt; <span class=\"number\">6</span>) &amp; <span class=\"number\">0x3f</span>) | <span class=\"number\">0x80</span>;</span><br><span class=\"line\">            jbyte b4 = (ch &amp; <span class=\"number\">0x3f</span>) | <span class=\"number\">0x80</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!out.<span class=\"built_in\">append</span>(b1) || !out.<span class=\"built_in\">append</span>(b2) || !out.<span class=\"built_in\">append</span>(b3) || !out.<span class=\"built_in\">append</span>(b4)) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 三字节.</span></span><br><span class=\"line\">            jbyte b1 = (ch &gt;&gt; <span class=\"number\">12</span>) | <span class=\"number\">0xe0</span>;</span><br><span class=\"line\">            jbyte b2 = ((ch &gt;&gt; <span class=\"number\">6</span>) &amp; <span class=\"number\">0x3f</span>) | <span class=\"number\">0x80</span>;</span><br><span class=\"line\">            jbyte b3 = (ch &amp; <span class=\"number\">0x3f</span>) | <span class=\"number\">0x80</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!out.<span class=\"built_in\">append</span>(b1) || !out.<span class=\"built_in\">append</span>(b2) || !out.<span class=\"built_in\">append</span>(b3)) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> out.<span class=\"built_in\">toByteArray</span>();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>整体的逻辑非常的好理解：判断输入值的区间，并分成单双三四字节的处理逻辑，其中有处理 UTF-16 代理字符串相关的逻辑此处忽略，可以了解<a href=\"https://learn.microsoft.com/zh-cn/windows/win32/intl/surrogates-and-supplementary-characters\">代理项和增补字符</a>。对应单字节符号处理，直接将原始值返回即可，其他的字节就一个一个地获取，这里分析一下对于双字节的逻辑处理。获取第一个字节的逻辑为：<code>(ch &gt;&gt; 6) | 0xc0 </code>第二个字节逻辑为 <code>(ch &amp; 0x3f) | 0x80</code> </p>\n<ul>\n<li><p><code>(ch &gt;&gt; 6) | 0xc0</code></p>\n<p>第一个字节的前两位是 <code>11</code>（十六进制中的 <code>0xc0</code>），后面的 5 位是 Unicode 码点的高 5 位</p>\n</li>\n<li><p><code>(ch &amp; 0x3f) | 0x80</code></p>\n<p>第二个字节的前两位是 <code>10</code>（十六进制中的 <code>0x80</code>），后面的 6 位是 Unicode 码点的低 6 位</p>\n</li>\n</ul>\n<p>举例，希腊符号  <code>ε</code>(epsilon) 在 UTF-8 编码里面是用双字节表示， Unicode 为 <code>0x03B5</code>  对应二进制数据：<code>0000001110110101</code>，计算流程如下所示：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"># ε 0x03B5 to UTF-8 </span><br><span class=\"line\"></span><br><span class=\"line\"># 第一个字节 (ch &gt;&gt; 6) | 0xc0</span><br><span class=\"line\">0000001110110101 &gt;&gt; 6</span><br><span class=\"line\">      0000001110 | 0xc0 (11000000)</span><br><span class=\"line\">        11000000</span><br><span class=\"line\">             ||</span><br><span class=\"line\">        11001110</span><br><span class=\"line\">            0xCE</span><br><span class=\"line\"></span><br><span class=\"line\"># 第二个字节 (ch &amp; 0x3f) | 0x80</span><br><span class=\"line\">0000001110110101 &amp; 0x3f (111111)</span><br><span class=\"line\">          111111</span><br><span class=\"line\">          110101 | 0x80 (10000000)</span><br><span class=\"line\">        10000000</span><br><span class=\"line\">              ||</span><br><span class=\"line\">        10110101</span><br><span class=\"line\">            0xB5</span><br></pre></td></tr></table></figure>\n\n<p>从而计算出  <code>ε</code> 对应的 UTF-8 Encoding为<code>0xCE 0xB5</code></p>\n<h3 id=\"“锟斤拷”和“烫”\"><a href=\"#“锟斤拷”和“烫”\" class=\"headerlink\" title=\"“锟斤拷”和“烫”\"></a>“锟斤拷”和“烫”</h3><p><code>“锟斤拷”</code>通常发生在UTF-8 到 GBK 编码的转换中，在 UTF-8 编码中，”0xEF 0xBF 0xBD” 是一个特殊的字符，表示 REPLACEMENT CHARACTER（替换字符），当解码器在解码字节序列时遇到无法识别的字节或无效的编码时，通常会用 REPLACEMENT CHARACTER（U+FFFD）替换这些无效的字节 ，”0xEF 0xBF 0xBD” 在 GBK 里面则编码成 “锟斤拷”。</p>\n<p><code>“烫”</code> 则是由于在 Windows 操作系统中，开发者在使用调试器调试程序时，会发现未初始化的内存通常会被填充为0xCC，而”0xCC” 在 GBK 里面则编码成“烫”。</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>本文主要讨论了字符编码的一些基本概念和原理，包括 ASCII、ANSI、Unicode 和 UTF-8 编码，文章分析了 Java String 类的<code>.getBytes(StandardCharsets.UTF_8)</code>方法的实现源码，解释了将 Unicode 字符串转换为 UTF-8 编码字节序列的过程，最后介绍了一下 “锟斤拷”和”烫”为什么会被展示。</p>\n","cover":null,"images":[],"content":"<p>最近在 Windows 上开发一些逻辑的时候遇到一些关于中文的坑，中文路径会乱码，是由于 Window 系统默认的编码格式是 <strong>GBK</strong>，而传入的参数编码格式是 <strong>UTF-8</strong>，导致整个程序出错。后续使用了&#96;&#96;MultiByteToWideChar<code> 和</code>WideCharToMultiByte&#96; 方法对编码进行一次改变，从而避免了这个问题的产生。但不了解相关原因，经过一番学习，对相关的概念进行一些简单的总结，并对一些 api  的实现源码进行分析。</p>\n<h3 id=\"ASCII-码\"><a href=\"#ASCII-码\" class=\"headerlink\" title=\"ASCII 码\"></a>ASCII 码</h3><p> ASCII ( American Standard Code for Information Interchange)<br> 256个符号，从 00000000 到 11111111    </p>\n<h3 id=\"ANSI\"><a href=\"#ANSI\" class=\"headerlink\" title=\"ANSI\"></a>ANSI</h3><p>ANSI（American National Standards Institute，美国国家标准协会）编码：ANSI 编码是一种基于 8 位的字符编码。它包含了 128 个美国英语字符和其他 128 个特殊字符，共 256 个字符。ANSI 编码主要用于表示英语字符，但它的局限性在于无法表示其他语言的字符。为了解决这个问题，各国家和地区分别制定了自己的 ANSI 编码标准，但这又引入了新的问题，即不同编码之间的互不兼容。</p>\n<p>​       美国和西欧：Windows-1252<br>​       中文（简体）：GB2312 或 GBK<br>​       中文（繁体）：Big5<br>​       日文：Shift-JIS<br>​       韩文：EUC-KR   </p>\n<h3 id=\"Unicode\"><a href=\"#Unicode\" class=\"headerlink\" title=\"Unicode\"></a>Unicode</h3><p>为了解决字符编码之间的兼容性问题，Unicode 标准应运而生。Unicode 是一种包含世界上大多数字符的编码方案，它为每个字符分配一个唯一的数字（称为码点），无论在任何平台、程序或语言中，都可以表示这些字符。Unicode 有多种实现方式，如 UTF-8、UTF-16 和 UTF-32。UTF-8 是最常用的 Unicode 实现方式，它是一种变长编码，可以使用 1 到 4 个字节来表示一个字符，这使得它在存储和传输方面更加高效</p>\n<p>  “FE FF” 是 Unicode 字符串的字节顺序标记（Byte Order Mark，简称 BOM），用于表示字符串的字节顺序<br>  Unicode Little-Endian，”FF FE”<br>  Unicode Big-Endian，”FE FF”</p>\n<h3 id=\"UTF-8\"><a href=\"#UTF-8\" class=\"headerlink\" title=\"UTF-8\"></a>UTF-8</h3><p>UTF-8 是 Unicode 的实现方式之一  ，是一种变长编码，它使用 1 到 4 个字节（8 位）来表示一个字符</p>\n<p><strong>单字节</strong>   所有的ASCII 字符<br><strong>二字节</strong>  带有附加符号的拉丁文、希腊文、西里尔字母、亚美尼亚语、希伯来文、阿拉伯文、叙利亚文及它拿字母则需要二个字节编码                </p>\n<p><strong>三字节</strong> 基本等同于GBK，含21000多个汉字 </p>\n<p><strong>四字节</strong> 中日韩超大字符集里面的汉字，有5万多个</p>\n<p><strong>UTF-8编码对照表</strong></p>\n<table>\n<thead>\n<tr>\n<th>Unicode 符号范围   (十六进制)</th>\n<th>UTF-8编码方式（二进制）</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>0000 0000 ~ 0000 007F</td>\n<td>0xxxxxxx</td>\n</tr>\n<tr>\n<td>0000 0080 ~ 0000 07FF</td>\n<td>110xxxxx 10xxxxxx</td>\n</tr>\n<tr>\n<td>0000 0800 ~ 0000 FFFF</td>\n<td>1110xxxx 10xxxxxx 10xxxxxx</td>\n</tr>\n<tr>\n<td>0001 0000 ~ 0010 FFFF</td>\n<td>11110xxx 10xxxxxx 10xxxxxx 10xxxxxx</td>\n</tr>\n</tbody></table>\n<h3 id=\"源码阅读：Java-String-toUtf8\"><a href=\"#源码阅读：Java-String-toUtf8\" class=\"headerlink\" title=\"源码阅读：Java String toUtf8\"></a>源码阅读：Java String toUtf8</h3><p> Java 的 String 默认用 UTF-16 存储数据，String 类的方法<code>.getBytes(StandardCharsets.UTF_8)</code> 将指定的字符集将字符串编码为 byte 序列，并将结果存储到一个新的 byte 数组中。</p>\n<p>其主要逻辑在:<a href=\"https://android.googlesource.com/platform/libcore/+/master/luni/src/main/java/libcore/util/CharsetUtils.java#46\">CharsetUtils.java#toUtf8Bytes</a></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">native</span> <span class=\"type\">byte</span>[] toUtf8Bytes(String s, <span class=\"type\">int</span> offset, <span class=\"type\">int</span> length);</span><br></pre></td></tr></table></figure>\n\n<p>对应的最终实现：<a href=\"https://android.googlesource.com/platform/libcore/+/3e8abdd9bdca823a635aac3adacf71ef227b18e1/luni/src/main/native/java_nio_charset_Charsets.cpp#183\">java_nio_charset_Charsets.cpp#Charsets_toUtf8Bytes</a> </p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">static</span> jbyteArray <span class=\"title\">Charsets_toUtf8Bytes</span><span class=\"params\">(JNIEnv* env, jclass, jcharArray javaChars, jint offset, jint length)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// ....此处省略 一些检查逻辑</span></span><br><span class=\"line\">    <span class=\"type\">const</span> <span class=\"type\">int</span> end = offset + length;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = offset; i &lt; end; ++i) &#123;</span><br><span class=\"line\">        jint ch = chars[i];</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (ch &lt; <span class=\"number\">0x80</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 单字节直接放进去</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!out.<span class=\"built_in\">append</span>(ch)) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (ch &lt; <span class=\"number\">0x800</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 双字节</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!out.<span class=\"built_in\">append</span>((ch &gt;&gt; <span class=\"number\">6</span>) | <span class=\"number\">0xc0</span>) || !out.<span class=\"built_in\">append</span>((ch &amp; <span class=\"number\">0x3f</span>) | <span class=\"number\">0x80</span>)) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"built_in\">U16_IS_SURROGATE</span>(ch)) &#123;</span><br><span class=\"line\">          \t<span class=\"comment\">// ....此处省略 UTF-16 代理字符串相关的逻辑</span></span><br><span class=\"line\">            ch = <span class=\"built_in\">U16_GET_SUPPLEMENTARY</span>(high, low);</span><br><span class=\"line\">            <span class=\"comment\">// 四字节 </span></span><br><span class=\"line\">            jbyte b1 = (ch &gt;&gt; <span class=\"number\">18</span>) | <span class=\"number\">0xf0</span>;</span><br><span class=\"line\">            jbyte b2 = ((ch &gt;&gt; <span class=\"number\">12</span>) &amp; <span class=\"number\">0x3f</span>) | <span class=\"number\">0x80</span>;</span><br><span class=\"line\">            jbyte b3 = ((ch &gt;&gt; <span class=\"number\">6</span>) &amp; <span class=\"number\">0x3f</span>) | <span class=\"number\">0x80</span>;</span><br><span class=\"line\">            jbyte b4 = (ch &amp; <span class=\"number\">0x3f</span>) | <span class=\"number\">0x80</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!out.<span class=\"built_in\">append</span>(b1) || !out.<span class=\"built_in\">append</span>(b2) || !out.<span class=\"built_in\">append</span>(b3) || !out.<span class=\"built_in\">append</span>(b4)) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 三字节.</span></span><br><span class=\"line\">            jbyte b1 = (ch &gt;&gt; <span class=\"number\">12</span>) | <span class=\"number\">0xe0</span>;</span><br><span class=\"line\">            jbyte b2 = ((ch &gt;&gt; <span class=\"number\">6</span>) &amp; <span class=\"number\">0x3f</span>) | <span class=\"number\">0x80</span>;</span><br><span class=\"line\">            jbyte b3 = (ch &amp; <span class=\"number\">0x3f</span>) | <span class=\"number\">0x80</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!out.<span class=\"built_in\">append</span>(b1) || !out.<span class=\"built_in\">append</span>(b2) || !out.<span class=\"built_in\">append</span>(b3)) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> out.<span class=\"built_in\">toByteArray</span>();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>整体的逻辑非常的好理解：判断输入值的区间，并分成单双三四字节的处理逻辑，其中有处理 UTF-16 代理字符串相关的逻辑此处忽略，可以了解<a href=\"https://learn.microsoft.com/zh-cn/windows/win32/intl/surrogates-and-supplementary-characters\">代理项和增补字符</a>。对应单字节符号处理，直接将原始值返回即可，其他的字节就一个一个地获取，这里分析一下对于双字节的逻辑处理。获取第一个字节的逻辑为：<code>(ch &gt;&gt; 6) | 0xc0 </code>第二个字节逻辑为 <code>(ch &amp; 0x3f) | 0x80</code> </p>\n<ul>\n<li><p><code>(ch &gt;&gt; 6) | 0xc0</code></p>\n<p>第一个字节的前两位是 <code>11</code>（十六进制中的 <code>0xc0</code>），后面的 5 位是 Unicode 码点的高 5 位</p>\n</li>\n<li><p><code>(ch &amp; 0x3f) | 0x80</code></p>\n<p>第二个字节的前两位是 <code>10</code>（十六进制中的 <code>0x80</code>），后面的 6 位是 Unicode 码点的低 6 位</p>\n</li>\n</ul>\n<p>举例，希腊符号  <code>ε</code>(epsilon) 在 UTF-8 编码里面是用双字节表示， Unicode 为 <code>0x03B5</code>  对应二进制数据：<code>0000001110110101</code>，计算流程如下所示：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"># ε 0x03B5 to UTF-8 </span><br><span class=\"line\"></span><br><span class=\"line\"># 第一个字节 (ch &gt;&gt; 6) | 0xc0</span><br><span class=\"line\">0000001110110101 &gt;&gt; 6</span><br><span class=\"line\">      0000001110 | 0xc0 (11000000)</span><br><span class=\"line\">        11000000</span><br><span class=\"line\">             ||</span><br><span class=\"line\">        11001110</span><br><span class=\"line\">            0xCE</span><br><span class=\"line\"></span><br><span class=\"line\"># 第二个字节 (ch &amp; 0x3f) | 0x80</span><br><span class=\"line\">0000001110110101 &amp; 0x3f (111111)</span><br><span class=\"line\">          111111</span><br><span class=\"line\">          110101 | 0x80 (10000000)</span><br><span class=\"line\">        10000000</span><br><span class=\"line\">              ||</span><br><span class=\"line\">        10110101</span><br><span class=\"line\">            0xB5</span><br></pre></td></tr></table></figure>\n\n<p>从而计算出  <code>ε</code> 对应的 UTF-8 Encoding为<code>0xCE 0xB5</code></p>\n<h3 id=\"“锟斤拷”和“烫”\"><a href=\"#“锟斤拷”和“烫”\" class=\"headerlink\" title=\"“锟斤拷”和“烫”\"></a>“锟斤拷”和“烫”</h3><p><code>“锟斤拷”</code>通常发生在UTF-8 到 GBK 编码的转换中，在 UTF-8 编码中，”0xEF 0xBF 0xBD” 是一个特殊的字符，表示 REPLACEMENT CHARACTER（替换字符），当解码器在解码字节序列时遇到无法识别的字节或无效的编码时，通常会用 REPLACEMENT CHARACTER（U+FFFD）替换这些无效的字节 ，”0xEF 0xBF 0xBD” 在 GBK 里面则编码成 “锟斤拷”。</p>\n<p><code>“烫”</code> 则是由于在 Windows 操作系统中，开发者在使用调试器调试程序时，会发现未初始化的内存通常会被填充为0xCC，而”0xCC” 在 GBK 里面则编码成“烫”。</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>本文主要讨论了字符编码的一些基本概念和原理，包括 ASCII、ANSI、Unicode 和 UTF-8 编码，文章分析了 Java String 类的<code>.getBytes(StandardCharsets.UTF_8)</code>方法的实现源码，解释了将 Unicode 字符串转换为 UTF-8 编码字节序列的过程，最后介绍了一下 “锟斤拷”和”烫”为什么会被展示。</p>\n","categories":[],"tags":[{"name":"UTF-8","slug":"UTF-8","api":"api/tags/UTF-8.json"}],"api":"api/posts/2024/04/11/关于Windows中文字符乱码.json"},{"title":"实现一个自定义 FFmpeg Filter","slug":"实现一个自定义FFmpeg-Filter","date":"2024-03-07T02:58:00.000Z","updated":"2025-05-20T11:46:57.000Z","comments":true,"url":"2024/03/07/实现一个自定义FFmpeg-Filter/","excerpt":"<p>此前在做  ffmpeg+某个第三库作为 filter 的集成，第三库是做AE特效相关的，与 ffmpeg 结合能让视频渲染效果大大提升。整体流程将第三方库作为 ffmpeg 的一个filter 形式进行结合，其中就涉及到 ffmpeg 的 filter 开发，本文即 对ffmpeg 的滤镜开发流程作一个总结。本文以实现一个视频垂直翻转的 filter 为例，ffmpeg 源码基于<a href=\"https://github.com/FFmpeg/FFmpeg/tree/release/6.1\">FFmpeg6.1</a> </p>\n<h2 id=\"实现自定义-Filter-流程\"><a href=\"#实现自定义-Filter-流程\" class=\"headerlink\" title=\"实现自定义 Filter 流程\"></a>实现自定义 Filter 流程</h2><ul>\n<li><p>编写 filter.c 文件</p>\n<p>一般视频滤镜以 vf_ 为前缀，视频滤镜以 af_ 为前缀，放在libavfilter目录下，参考其他 filter 代码逻辑，模块化配置相关参数，本文例以 vf_flip.c 实现视频的上下翻转</p>\n</li>\n<li><p>在 <code>libavfilter/allfilters.c</code> 注册</p>\n<p>例如：extern const AVFilter ff_vf_flip;  <code>ff_vf_flip</code>就是在 <code>vf_flip.c</code>的 filter 注册名称</p>\n</li>\n<li><p>修改 <code>libavfilter/Makefile</code> 添加编译配置： </p>\n<p>例如：OBJS-$(CONFIG_FLIP_FILTER)                   +&#x3D; vf_flip.o</p>\n</li>\n<li><p>编译打包</p>\n</li>\n</ul>\n<h2 id=\"编写-filter-c-文件\"><a href=\"#编写-filter-c-文件\" class=\"headerlink\" title=\"编写 filter.c 文件\"></a>编写 filter.c 文件</h2><h3 id=\"AVFilter主体\"><a href=\"#AVFilter主体\" class=\"headerlink\" title=\"AVFilter主体\"></a>AVFilter主体</h3><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">AVFilter</span> &#123;</span></span><br><span class=\"line\">  <span class=\"type\">const</span> <span class=\"type\">char</span> *name;</span><br><span class=\"line\">  <span class=\"type\">const</span> <span class=\"type\">char</span> *description;</span><br><span class=\"line\">  <span class=\"type\">const</span> AVFilterPad *inputs;</span><br><span class=\"line\">  <span class=\"type\">const</span> AVFilterPad *outputs;</span><br><span class=\"line\">  <span class=\"type\">const</span> AVClass *priv_class;</span><br><span class=\"line\">  <span class=\"type\">int</span> flags;</span><br><span class=\"line\">  <span class=\"type\">int</span> (*preinit)(AVFilterContext *ctx);</span><br><span class=\"line\">  <span class=\"type\">int</span> (*init)(AVFilterContext *ctx);</span><br><span class=\"line\">  <span class=\"type\">int</span> (*init_dict)(AVFilterContext *ctx, AVDictionary **options);</span><br><span class=\"line\">  <span class=\"type\">void</span> (*uninit)(AVFilterContext *ctx);</span><br><span class=\"line\">  <span class=\"type\">int</span> (*query_formats)(AVFilterContext *);</span><br><span class=\"line\">  <span class=\"type\">int</span> priv_size;   </span><br><span class=\"line\">  <span class=\"type\">int</span> flags_internal; </span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">AVFilter</span> *<span class=\"title\">next</span>;</span></span><br><span class=\"line\">  <span class=\"type\">int</span> (*process_command)(AVFilterContext *, <span class=\"type\">const</span> <span class=\"type\">char</span> *cmd, <span class=\"type\">const</span> <span class=\"type\">char</span> *arg, <span class=\"type\">char</span> *res, <span class=\"type\">int</span> res_len, <span class=\"type\">int</span> flags);</span><br><span class=\"line\">  <span class=\"type\">int</span> (*init_opaque)(AVFilterContext *ctx, <span class=\"type\">void</span> *opaque);</span><br><span class=\"line\">  <span class=\"type\">int</span> (*activate)(AVFilterContext *ctx);</span><br><span class=\"line\">&#125; AVFilter;</span><br></pre></td></tr></table></figure>\n\n<p>具体里面的属性作用可以参考：<a href=\"https://www.cnblogs.com/TaigaCon/p/10171464.html\">[ffmpeg] 定制滤波器</a>，可以根据需求实现里面的相关函数，接下来以一个最简单的 Filter 和一个较复杂一点的 Filter 举例。</p>\n<h3 id=\"最简单的-AVFilter\"><a href=\"#最简单的-AVFilter\" class=\"headerlink\" title=\"最简单的 AVFilter\"></a>最简单的 AVFilter</h3><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> &#123;</span></span><br><span class=\"line\">    <span class=\"type\">const</span> AVClass *<span class=\"class\"><span class=\"keyword\">class</span>;</span></span><br><span class=\"line\">&#125; NoopContext;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">int</span> <span class=\"title function_\">filter_frame</span><span class=\"params\">(AVFilterLink *link, AVFrame *frame)</span> &#123;</span><br><span class=\"line\">    av_log(<span class=\"literal\">NULL</span>, AV_LOG_INFO, <span class=\"string\">&quot;filter frame pts:%lld\\n&quot;</span>, frame-&gt;pts);</span><br><span class=\"line\">    NoopContext *noopContext = link-&gt;dst-&gt;priv;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ff_filter_frame(link-&gt;dst-&gt;outputs[<span class=\"number\">0</span>], frame);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">const</span> AVFilterPad noop_inputs[] = &#123;</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">                .name         = <span class=\"string\">&quot;default&quot;</span>,</span><br><span class=\"line\">                .type         = AVMEDIA_TYPE_VIDEO,</span><br><span class=\"line\">                .filter_frame = filter_frame,</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">const</span> AVFilterPad noop_outputs[] = &#123;</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">                .name = <span class=\"string\">&quot;default&quot;</span>,</span><br><span class=\"line\">                .type = AVMEDIA_TYPE_VIDEO,</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"type\">const</span> AVFilter ff_vf_noop = &#123;</span><br><span class=\"line\">        .name          = <span class=\"string\">&quot;noop&quot;</span>,</span><br><span class=\"line\">        .description   = NULL_IF_CONFIG_SMALL(<span class=\"string\">&quot;Pass the input video unchanged.&quot;</span>),</span><br><span class=\"line\">        .priv_size     = <span class=\"keyword\">sizeof</span>(NoopContext),</span><br><span class=\"line\">        FILTER_INPUTS(noop_inputs),</span><br><span class=\"line\">        FILTER_OUTPUTS(noop_outputs),</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>命令行运行：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">ffmpeg -i test.mp4 -vf &quot;noop&quot; noop.mp4</span><br></pre></td></tr></table></figure>\n\n<p> 正常输出文件（对原片没有做任何更改）,这个 filter 的作用是将输入的视频帧不做任何处理地传递给下一个过滤器，在处理每帧的时候会打印处理的 PTS，麻雀虽小五脏俱全，它包含了一个 AVFilter 基础的结构：</p>\n<ol>\n<li><p><strong><code>NoopContext</code></strong></p>\n<p>这是一个简单的结构体，包含一个指向 AVClass 的指针。在这个例子中，实际上没有使用到 NoopContext 结构体的任何成员，因为这个过滤器没有需要存储的私有数据。</p>\n</li>\n<li><p><strong><code>filter_frame</code></strong> </p>\n<p>这个函数的作用是处理输入的视频帧。在这个例子中，它只是打印帧的 PTS（Presentation Time Stamp，显示时间戳）并将帧传递给下一个过滤器，不对帧做任何修改。</p>\n</li>\n<li><p><strong><code>noop_inputs</code> 和 <code>noop_outputs</code></strong></p>\n<p>这两个数组定义了过滤器的输入和输出 Pad。在这个例子中，输入 Pad 类型为 AVMEDIA_TYPE_VIDEO，并关联了 <code>filter_frame</code> 函数。输出 Pad 也是 AVMEDIA_TYPE_VIDEO 类型，但没有关联任何函数，因为输出直接由 <code>filter_frame</code> 函数处理。</p>\n</li>\n<li><p><strong><code>ff_vf_noop</code></strong></p>\n<p>这是一个 AVFilter 结构体实例，包含了过滤器的名称、描述、私有数据大小以及输入和输出 Pad。在这个例子中，过滤器的名称为 “noop”，描述为 “Pass the input video unchanged.”，这也就是在执行：<code>ffmpeg -filters</code> 看到的 Filter描述内容。</p>\n</li>\n</ol>\n<p>接下来看一个稍微复杂的一个 AVFilter，实现一个视频的上下翻转</p>\n<h3 id=\"复杂一点的-AVFilter\"><a href=\"#复杂一点的-AVFilter\" class=\"headerlink\" title=\"复杂一点的 AVFilter\"></a>复杂一点的 AVFilter</h3><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">FlipContext</span> &#123;</span></span><br><span class=\"line\">    <span class=\"type\">const</span> AVClass *<span class=\"class\"><span class=\"keyword\">class</span>;</span></span><br><span class=\"line\">    <span class=\"type\">int</span> duration;</span><br><span class=\"line\">&#125; FlipContext;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> OFFSET(x) offsetof(FlipContext, x)</span></span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">const</span> AVOption flip_options[] = &#123;</span><br><span class=\"line\">        &#123;<span class=\"string\">&quot;duration&quot;</span>, <span class=\"string\">&quot;set flip duration&quot;</span>, OFFSET(duration), AV_OPT_TYPE_INT, &#123;.i64 = <span class=\"number\">0</span>&#125;, <span class=\"number\">0</span>, INT_MAX, .flags = AV_OPT_FLAG_FILTERING_PARAM&#125;,</span><br><span class=\"line\">        &#123;<span class=\"literal\">NULL</span>&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">static</span> av_cold <span class=\"type\">int</span> <span class=\"title function_\">flip_init</span><span class=\"params\">(AVFilterContext *ctx)</span> &#123;</span><br><span class=\"line\">    FlipContext *context = ctx-&gt;priv;</span><br><span class=\"line\">    av_log(<span class=\"literal\">NULL</span>, AV_LOG_ERROR, <span class=\"string\">&quot;Input duration: %d.\\n&quot;</span>, context-&gt;duration);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">static</span> av_cold <span class=\"type\">void</span> <span class=\"title function_\">flip_uninit</span><span class=\"params\">(AVFilterContext *ctx)</span> &#123;</span><br><span class=\"line\">    FlipContext *context = ctx-&gt;priv;</span><br><span class=\"line\">    <span class=\"comment\">// no-op 本例无需释放滤镜实例分配的内存、关闭文件、资源等</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 对输入的 AVFrame 进行翻转</span></span><br><span class=\"line\"><span class=\"type\">static</span> AVFrame *<span class=\"title function_\">flip_frame</span><span class=\"params\">(AVFilterContext *ctx, AVFrame *in_frame)</span> &#123;</span><br><span class=\"line\"> \t\tAVFilterLink *inlink = ctx-&gt;inputs[<span class=\"number\">0</span>];</span><br><span class=\"line\">    FlipContext *s = ctx-&gt;priv;</span><br><span class=\"line\">    <span class=\"type\">int64_t</span> pts = in_frame-&gt;pts;</span><br><span class=\"line\">    <span class=\"comment\">// 将时间戳（pts）转化以秒为单位的时间戳</span></span><br><span class=\"line\">    <span class=\"type\">float</span> time_s = TS2T(pts, inlink-&gt;time_base);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (time_s &gt; s-&gt;duration) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 超过对应的时间则直接输出in_frame</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> in_frame;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 创建输出帧并分配内存</span></span><br><span class=\"line\">    AVFrame *out_frame = av_frame_alloc();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!out_frame) &#123;</span><br><span class=\"line\">        av_frame_free(&amp;in_frame);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> out_frame;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 设置输出帧的属性</span></span><br><span class=\"line\">    out_frame-&gt;format = in_frame-&gt;format;</span><br><span class=\"line\">    out_frame-&gt;width = in_frame-&gt;width;</span><br><span class=\"line\">    out_frame-&gt;height = in_frame-&gt;height;</span><br><span class=\"line\">    out_frame-&gt;pts = in_frame-&gt;pts;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 分配输出帧的数据缓冲区</span></span><br><span class=\"line\">    <span class=\"type\">int</span> ret = av_frame_get_buffer(out_frame, <span class=\"number\">32</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ret &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        av_frame_free(&amp;in_frame);</span><br><span class=\"line\">        av_frame_free(&amp;out_frame);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> out_frame;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 这个示例仅适用于 YUV 格式的视频。对于其他格式（如 RGB）</span></span><br><span class=\"line\">    <span class=\"comment\">// 翻转输入帧的数据到输出帧</span></span><br><span class=\"line\">    <span class=\"comment\">// 翻转了 Y 分量，然后翻转了 U 和 V 分量</span></span><br><span class=\"line\">    <span class=\"comment\">//</span></span><br><span class=\"line\">    <span class=\"type\">uint8_t</span> *src_y = in_frame-&gt;data[<span class=\"number\">0</span>];</span><br><span class=\"line\">    <span class=\"type\">uint8_t</span> *src_u = in_frame-&gt;data[<span class=\"number\">1</span>];</span><br><span class=\"line\">    <span class=\"type\">uint8_t</span> *src_v = in_frame-&gt;data[<span class=\"number\">2</span>];</span><br><span class=\"line\">    <span class=\"type\">uint8_t</span> *dst_y = out_frame-&gt;data[<span class=\"number\">0</span>] + (in_frame-&gt;height - <span class=\"number\">1</span>) * out_frame-&gt;linesize[<span class=\"number\">0</span>];</span><br><span class=\"line\">    <span class=\"type\">uint8_t</span> *dst_u = out_frame-&gt;data[<span class=\"number\">1</span>] + (in_frame-&gt;height / <span class=\"number\">2</span> - <span class=\"number\">1</span>) * out_frame-&gt;linesize[<span class=\"number\">1</span>];</span><br><span class=\"line\">    <span class=\"type\">uint8_t</span> *dst_v = out_frame-&gt;data[<span class=\"number\">2</span>] + (in_frame-&gt;height / <span class=\"number\">2</span> - <span class=\"number\">1</span>) * out_frame-&gt;linesize[<span class=\"number\">2</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; in_frame-&gt;height; i++) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">memcpy</span>(dst_y, src_y, in_frame-&gt;width);</span><br><span class=\"line\">        src_y += in_frame-&gt;linesize[<span class=\"number\">0</span>];</span><br><span class=\"line\">        dst_y -= out_frame-&gt;linesize[<span class=\"number\">0</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (i &lt; in_frame-&gt;height / <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">memcpy</span>(dst_u, src_u, in_frame-&gt;width / <span class=\"number\">2</span>);</span><br><span class=\"line\">            <span class=\"built_in\">memcpy</span>(dst_v, src_v, in_frame-&gt;width / <span class=\"number\">2</span>);</span><br><span class=\"line\">            src_u += in_frame-&gt;linesize[<span class=\"number\">1</span>];</span><br><span class=\"line\">            src_v += in_frame-&gt;linesize[<span class=\"number\">2</span>];</span><br><span class=\"line\">            dst_u -= out_frame-&gt;linesize[<span class=\"number\">1</span>];</span><br><span class=\"line\">            dst_v -= out_frame-&gt;linesize[<span class=\"number\">2</span>];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> out_frame;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">int</span> <span class=\"title function_\">activate</span><span class=\"params\">(AVFilterContext *ctx)</span> &#123;</span><br><span class=\"line\">    AVFilterLink *inlink = ctx-&gt;inputs[<span class=\"number\">0</span>];</span><br><span class=\"line\">    AVFilterLink *outlink = ctx-&gt;outputs[<span class=\"number\">0</span>];</span><br><span class=\"line\">    AVFrame *in_frame = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    AVFrame *out_frame = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    <span class=\"type\">int</span> ret = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 获取输入帧</span></span><br><span class=\"line\">    ret = ff_inlink_consume_frame(inlink, &amp;in_frame);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ret &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 如果有输入帧，进行翻转处理</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (in_frame) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 对输出帧进行上下翻转处理</span></span><br><span class=\"line\">        out_frame = flip_frame(ctx, in_frame);</span><br><span class=\"line\">        <span class=\"comment\">// 将处理后的帧放入输出缓冲区</span></span><br><span class=\"line\">        ret = ff_filter_frame(outlink, out_frame);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (ret &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            av_frame_free(&amp;out_frame);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 如果没有输入帧，尝试请求一个新的输入帧</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!in_frame) &#123;</span><br><span class=\"line\">        ff_inlink_request_frame(inlink);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">int</span> status;</span><br><span class=\"line\">    <span class=\"type\">int64_t</span> pts;</span><br><span class=\"line\">    ret = ff_inlink_acknowledge_status(inlink, &amp;status, &amp;pts);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ret &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (status == AVERROR_EOF) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 输入链接已经结束，设置输出链接的状态为 EOF</span></span><br><span class=\"line\">        ff_outlink_set_status(outlink, AVERROR_EOF, pts);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">AVFILTER_DEFINE_CLASS(flip);</span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">const</span> AVFilterPad flip_inputs[] = &#123;</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">                .name = <span class=\"string\">&quot;default&quot;</span>,</span><br><span class=\"line\">                .type = AVMEDIA_TYPE_VIDEO,</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">const</span> AVFilterPad flip_outputs[] = &#123;</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">                .name = <span class=\"string\">&quot;default&quot;</span>,</span><br><span class=\"line\">                .type = AVMEDIA_TYPE_VIDEO,</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"type\">const</span> AVFilter ff_vf_flip = &#123;</span><br><span class=\"line\">        .name = <span class=\"string\">&quot;flip&quot;</span>,</span><br><span class=\"line\">        .description = NULL_IF_CONFIG_SMALL(<span class=\"string\">&quot;Flip the input video.&quot;</span>),</span><br><span class=\"line\">        .priv_size = <span class=\"keyword\">sizeof</span>(FlipContext),</span><br><span class=\"line\">        .priv_class = &amp;flip_class,</span><br><span class=\"line\">        .activate      = activate,</span><br><span class=\"line\">        .init = flip_init,</span><br><span class=\"line\">        .uninit = flip_uninit,</span><br><span class=\"line\">        FILTER_INPUTS(flip_inputs),</span><br><span class=\"line\">        FILTER_OUTPUTS(flip_outputs),</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>命令行运行：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">ffmpeg -i test.mp4 -filter_complex &quot;[0:v]flip=duration=5[out];&quot; -map &quot;[out]&quot; flip.mp4</span><br></pre></td></tr></table></figure>\n\n<p> 得到渲染好的视频，前5s是上下翻转的，后面的内容正常。</p>\n<p>相比于最简单的 AVFilter 多了几个实现：</p>\n<ol>\n<li><p><strong><code>AVOption flip_options</code></strong></p>\n<p>用于设置翻转持续时间的选项，外部命令配置可选输入<code>duration=5</code>，会自动对数据合法性进行校验。参数类型为 <code>AV_OPT_TYPE_INT</code>，默认值为 0，取值范围为 0 到 <code>INT_MAX</code>。<code>.flags</code> 设置为 <code>AV_OPT_FLAG_FILTERING_PARAM</code>，表示这是一个过滤参数。</p>\n</li>\n<li><p><strong><code>.priv_class</code></strong>  </p>\n<p>配置的<code>flip_class</code>实际是通过 <code>AVFILTER_DEFINE_CLASS(flip);</code> 宏实现的一个声明：见：<a href=\"https://github.com/FFmpeg/FFmpeg/blob/release/6.1/libavfilter/internal.h#L311\">internal.h#AVFILTER_DEFINE_CLASS_EXT</a></p>\n</li>\n<li><p><strong><code>**init</code>&amp; <code>uninit</code></strong></p>\n<p>滤镜在初始化或者释放资源的时候将会调用</p>\n</li>\n<li><p><strong><code>activate</code></strong></p>\n<p>这个函数首先获取输入帧，然后调用 <code>flip_frame</code> 函数进行翻转操作，并将处理后的帧放入输出链接。如果没有输入帧，它会请求一个新的输入帧。最后，它会确认输入链接的状态，并根据需要设置输出链接的状态。</p>\n</li>\n</ol>\n<p>这个例子相比最简单的 filter 使用了 <code>activate</code> 函数 用于帧渲染，而不是使用 <code>filter_frame</code>去渲染，这两个方法有什么区别于联系呢？查看：<a href=\"##filter_frame()%E5%92%8Cactivate()%E5%87%BD%E6%95%B0\">filter_frame和activate方法</a></p>\n<p>也能通过 <code>filter_frame</code>实现，对代码部分逻辑更新更改：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">const</span> AVFilterPad flip_inputs[] = &#123;</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">                .name = <span class=\"string\">&quot;default&quot;</span>,</span><br><span class=\"line\">                .type = AVMEDIA_TYPE_VIDEO,</span><br><span class=\"line\">                .filter_frame = filter_frame, <span class=\"comment\">//添加filter_frame 实现</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">const</span> AVFilter ff_vf_flip = &#123;</span><br><span class=\"line\">       ……</span><br><span class=\"line\">        .priv_class = &amp;flip_class,</span><br><span class=\"line\">       <span class=\"comment\">// .activate      = activate,</span></span><br><span class=\"line\">        .init = flip_init,</span><br><span class=\"line\">       ……</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">int</span> <span class=\"title function_\">filter_frame</span><span class=\"params\">(AVFilterLink *inlink, AVFrame *in)</span> &#123;</span><br><span class=\"line\">    AVFilterContext *ctx = inlink-&gt;dst;</span><br><span class=\"line\">    FlipContext *s = ctx-&gt;priv;</span><br><span class=\"line\">    AVFilterLink *outlink = ctx-&gt;outputs[<span class=\"number\">0</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">int64_t</span> pts = in-&gt;pts;</span><br><span class=\"line\">    <span class=\"comment\">// 将时间戳（pts）转化以秒为单位的时间戳</span></span><br><span class=\"line\">    <span class=\"type\">float</span> time_s = TS2T(pts, inlink-&gt;time_base);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (time_s &gt; s-&gt;duration) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 超过对应的时间则直接输出in_frame</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> ff_filter_frame(outlink, in);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        av_log(<span class=\"literal\">NULL</span>, AV_LOG_ERROR, <span class=\"string\">&quot;time_s s: %f.\\n&quot;</span>, time_s);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    AVFrame *out = flip_frame(ctx, in);</span><br><span class=\"line\">    <span class=\"comment\">// 释放输入帧</span></span><br><span class=\"line\">    av_frame_free(&amp;in);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 将输出帧传递给下一个滤镜</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> ff_filter_frame(outlink, out);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>命令行运行，得到的输出结果是一样的。</p>\n<h2 id=\"filter-frame-和activate-函数\"><a href=\"#filter-frame-和activate-函数\" class=\"headerlink\" title=\"filter_frame()和activate()函数\"></a>filter_frame()和activate()函数</h2><p>对于这点查了相关资料，看看源码相关的实现</p>\n<p>参考：<a href=\"https://www.ffmpeg.org/doxygen/5.0/filter__design_8txt.html\">https://www.ffmpeg.org/doxygen/5.0/filter__design_8txt.html</a></p>\n<blockquote>\n<p>The purpose of these rules is to ensure that frames flow in the filter graph without getting stuck and accumulating somewhere. Simple filters that output one frame for each input frame should not have to worry about it. There are two design for filters:one using the  <a href=\"https://www.ffmpeg.org/doxygen/5.0/vsink__nullsink_8c.html#aaa9a0e0f9de1464941d86a984cf77d37\">filter_frame</a>() and <a href=\"https://www.ffmpeg.org/doxygen/5.0/vsrc__mptestsrc_8c.html#a72949c8fcad3f201712a3569fc6888cb\">request_frame</a>() callbacks and the other using the activate() callback. The design using filter_frame() and request_frame() is legacy, but it is suitable for filters that have a single input and process one frame at a time. New filters with several inputs, that treat several frames at a time or that require a special treatment at EOF should probably use the design using activate(). activate ——– This method is called when something must be done in a filter</p>\n</blockquote>\n<p>大意，实现滤镜有两种实现方式：</p>\n<ul>\n<li><p><strong><code>filter_frame()</code></strong></p>\n<p>可以被认为是历史遗留产物。在早期的 AVFilter 设计中，<code>filter_frame()</code> 和 <code>request_frame()</code> 是主要用于处理输入帧和请求输出帧的回调函数。这种设计适用于简单的过滤器，例如单输入且每次处理一个帧的过滤器。</p>\n</li>\n<li><p><strong><code>activate()</code></strong></p>\n<p>随着 ffmpeg 和 AVFilter 的发展，处理需求变得越来越复杂，例如需要处理多个输入、一次处理多个帧或在文件结束（EOF）时进行特殊处理等。为了满足这些需求，引入了 <code>activate()</code> 函数，它提供了更灵活和强大的处理能力。因此，虽然 <code>filter_frame()</code> 在某些简单场景下仍然可以使用，但对于新的或复杂的过滤器，建议使用 <code>activate()</code> 函数。</p>\n</li>\n</ul>\n<p>如果两个方法都实现了，那他们谁会先执行呢？</p>\n<p>对应的源码处理逻辑： <a href=\"https://github.com/FFmpeg/FFmpeg/blob/release/6.1/libavfilter/avfilter.c#L1322\">avfilter.c</a></p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">ff_filter_activate</span><span class=\"params\">(AVFilterContext *filter)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> ret;</span><br><span class=\"line\">\t\t……</span><br><span class=\"line\">    ret = filter-&gt;filter-&gt;activate ? filter-&gt;filter-&gt;activate(filter) :</span><br><span class=\"line\">          ff_filter_activate_default(filter);</span><br><span class=\"line\">  \t……</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如果配置了activate() 函数则执行，否则执行 ff_filter_activate_default()-&gt;ff_filter_frame_to_filter()-&gt;ff_filter_frame_framed() 最终执行到配置的 filter_frame() 方法。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">int</span> <span class=\"title function_\">ff_filter_frame_framed</span><span class=\"params\">(AVFilterLink *link, AVFrame *frame)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> (*filter_frame)(AVFilterLink *, AVFrame *);</span><br><span class=\"line\">    AVFilterContext *dstctx = link-&gt;dst;</span><br><span class=\"line\">    AVFilterPad *dst = link-&gt;dstpad;</span><br><span class=\"line\">    <span class=\"type\">int</span> ret;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!(filter_frame = dst-&gt;filter_frame))</span><br><span class=\"line\">        filter_frame = default_filter_frame;</span><br><span class=\"line\">    ……</span><br><span class=\"line\">    ret = filter_frame(link, frame);  <span class=\"comment\">// 最终调用到的地方</span></span><br><span class=\"line\">    link-&gt;frame_count_out++;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">fail:</span><br><span class=\"line\">    ……</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>本文介绍了 FFmpeg 滤镜开发的整体流程，如何编写 filter.c 文件，并以一个最简单的 AVFilter 和一个较为复杂的 AVFilter 为例，解析了滤镜开发的具体步骤和代码实现，并介绍了 filter_frame() 和 activate() 函数的区别与联系。</p>\n<p>在滤镜开发过程中，需要注意的是，filter_frame() 和 activate() 函数的使用取决于滤镜的复杂性。对于简单的滤镜，可以使用 filter_frame() 函数；而对于需要处理多个输入、一次处理多个帧或在文件结束（EOF）时进行特殊处理的复杂滤镜，建议使用 activate() 函数。</p>\n<p>文中的源码可以查看：<a href=\"https://github.com/VomPom/FFmpeg/commit/9176f58ae60e0b70e5708b25017f374deac9fae7\">add most simplest  AVFilter and a simple video flip filter.</a></p>\n<h3 id=\"参考：\"><a href=\"#参考：\" class=\"headerlink\" title=\"参考：\"></a>参考：</h3><p><a href=\"https://www.cnblogs.com/TaigaCon/p/10171464.html\">https://www.cnblogs.com/TaigaCon/p/10171464.html</a></p>\n<p><a href=\"https://www.cnblogs.com/ranson7zop/p/7728639.html\">https://www.cnblogs.com/ranson7zop/p/7728639.html</a></p>\n<p><a href=\"https://www.ffmpeg.org/doxygen/5.0/filter__design_8txt.html\">https://www.ffmpeg.org/doxygen/5.0/filter__design_8txt.html</a></p>\n","cover":null,"images":[],"content":"<p>此前在做  ffmpeg+某个第三库作为 filter 的集成，第三库是做AE特效相关的，与 ffmpeg 结合能让视频渲染效果大大提升。整体流程将第三方库作为 ffmpeg 的一个filter 形式进行结合，其中就涉及到 ffmpeg 的 filter 开发，本文即 对ffmpeg 的滤镜开发流程作一个总结。本文以实现一个视频垂直翻转的 filter 为例，ffmpeg 源码基于<a href=\"https://github.com/FFmpeg/FFmpeg/tree/release/6.1\">FFmpeg6.1</a> </p>\n<h2 id=\"实现自定义-Filter-流程\"><a href=\"#实现自定义-Filter-流程\" class=\"headerlink\" title=\"实现自定义 Filter 流程\"></a>实现自定义 Filter 流程</h2><ul>\n<li><p>编写 filter.c 文件</p>\n<p>一般视频滤镜以 vf_ 为前缀，视频滤镜以 af_ 为前缀，放在libavfilter目录下，参考其他 filter 代码逻辑，模块化配置相关参数，本文例以 vf_flip.c 实现视频的上下翻转</p>\n</li>\n<li><p>在 <code>libavfilter/allfilters.c</code> 注册</p>\n<p>例如：extern const AVFilter ff_vf_flip;  <code>ff_vf_flip</code>就是在 <code>vf_flip.c</code>的 filter 注册名称</p>\n</li>\n<li><p>修改 <code>libavfilter/Makefile</code> 添加编译配置： </p>\n<p>例如：OBJS-$(CONFIG_FLIP_FILTER)                   +&#x3D; vf_flip.o</p>\n</li>\n<li><p>编译打包</p>\n</li>\n</ul>\n<h2 id=\"编写-filter-c-文件\"><a href=\"#编写-filter-c-文件\" class=\"headerlink\" title=\"编写 filter.c 文件\"></a>编写 filter.c 文件</h2><h3 id=\"AVFilter主体\"><a href=\"#AVFilter主体\" class=\"headerlink\" title=\"AVFilter主体\"></a>AVFilter主体</h3><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">AVFilter</span> &#123;</span></span><br><span class=\"line\">  <span class=\"type\">const</span> <span class=\"type\">char</span> *name;</span><br><span class=\"line\">  <span class=\"type\">const</span> <span class=\"type\">char</span> *description;</span><br><span class=\"line\">  <span class=\"type\">const</span> AVFilterPad *inputs;</span><br><span class=\"line\">  <span class=\"type\">const</span> AVFilterPad *outputs;</span><br><span class=\"line\">  <span class=\"type\">const</span> AVClass *priv_class;</span><br><span class=\"line\">  <span class=\"type\">int</span> flags;</span><br><span class=\"line\">  <span class=\"type\">int</span> (*preinit)(AVFilterContext *ctx);</span><br><span class=\"line\">  <span class=\"type\">int</span> (*init)(AVFilterContext *ctx);</span><br><span class=\"line\">  <span class=\"type\">int</span> (*init_dict)(AVFilterContext *ctx, AVDictionary **options);</span><br><span class=\"line\">  <span class=\"type\">void</span> (*uninit)(AVFilterContext *ctx);</span><br><span class=\"line\">  <span class=\"type\">int</span> (*query_formats)(AVFilterContext *);</span><br><span class=\"line\">  <span class=\"type\">int</span> priv_size;   </span><br><span class=\"line\">  <span class=\"type\">int</span> flags_internal; </span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">AVFilter</span> *<span class=\"title\">next</span>;</span></span><br><span class=\"line\">  <span class=\"type\">int</span> (*process_command)(AVFilterContext *, <span class=\"type\">const</span> <span class=\"type\">char</span> *cmd, <span class=\"type\">const</span> <span class=\"type\">char</span> *arg, <span class=\"type\">char</span> *res, <span class=\"type\">int</span> res_len, <span class=\"type\">int</span> flags);</span><br><span class=\"line\">  <span class=\"type\">int</span> (*init_opaque)(AVFilterContext *ctx, <span class=\"type\">void</span> *opaque);</span><br><span class=\"line\">  <span class=\"type\">int</span> (*activate)(AVFilterContext *ctx);</span><br><span class=\"line\">&#125; AVFilter;</span><br></pre></td></tr></table></figure>\n\n<p>具体里面的属性作用可以参考：<a href=\"https://www.cnblogs.com/TaigaCon/p/10171464.html\">[ffmpeg] 定制滤波器</a>，可以根据需求实现里面的相关函数，接下来以一个最简单的 Filter 和一个较复杂一点的 Filter 举例。</p>\n<h3 id=\"最简单的-AVFilter\"><a href=\"#最简单的-AVFilter\" class=\"headerlink\" title=\"最简单的 AVFilter\"></a>最简单的 AVFilter</h3><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> &#123;</span></span><br><span class=\"line\">    <span class=\"type\">const</span> AVClass *<span class=\"class\"><span class=\"keyword\">class</span>;</span></span><br><span class=\"line\">&#125; NoopContext;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">int</span> <span class=\"title function_\">filter_frame</span><span class=\"params\">(AVFilterLink *link, AVFrame *frame)</span> &#123;</span><br><span class=\"line\">    av_log(<span class=\"literal\">NULL</span>, AV_LOG_INFO, <span class=\"string\">&quot;filter frame pts:%lld\\n&quot;</span>, frame-&gt;pts);</span><br><span class=\"line\">    NoopContext *noopContext = link-&gt;dst-&gt;priv;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ff_filter_frame(link-&gt;dst-&gt;outputs[<span class=\"number\">0</span>], frame);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">const</span> AVFilterPad noop_inputs[] = &#123;</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">                .name         = <span class=\"string\">&quot;default&quot;</span>,</span><br><span class=\"line\">                .type         = AVMEDIA_TYPE_VIDEO,</span><br><span class=\"line\">                .filter_frame = filter_frame,</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">const</span> AVFilterPad noop_outputs[] = &#123;</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">                .name = <span class=\"string\">&quot;default&quot;</span>,</span><br><span class=\"line\">                .type = AVMEDIA_TYPE_VIDEO,</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"type\">const</span> AVFilter ff_vf_noop = &#123;</span><br><span class=\"line\">        .name          = <span class=\"string\">&quot;noop&quot;</span>,</span><br><span class=\"line\">        .description   = NULL_IF_CONFIG_SMALL(<span class=\"string\">&quot;Pass the input video unchanged.&quot;</span>),</span><br><span class=\"line\">        .priv_size     = <span class=\"keyword\">sizeof</span>(NoopContext),</span><br><span class=\"line\">        FILTER_INPUTS(noop_inputs),</span><br><span class=\"line\">        FILTER_OUTPUTS(noop_outputs),</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>命令行运行：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">ffmpeg -i test.mp4 -vf &quot;noop&quot; noop.mp4</span><br></pre></td></tr></table></figure>\n\n<p> 正常输出文件（对原片没有做任何更改）,这个 filter 的作用是将输入的视频帧不做任何处理地传递给下一个过滤器，在处理每帧的时候会打印处理的 PTS，麻雀虽小五脏俱全，它包含了一个 AVFilter 基础的结构：</p>\n<ol>\n<li><p><strong><code>NoopContext</code></strong></p>\n<p>这是一个简单的结构体，包含一个指向 AVClass 的指针。在这个例子中，实际上没有使用到 NoopContext 结构体的任何成员，因为这个过滤器没有需要存储的私有数据。</p>\n</li>\n<li><p><strong><code>filter_frame</code></strong> </p>\n<p>这个函数的作用是处理输入的视频帧。在这个例子中，它只是打印帧的 PTS（Presentation Time Stamp，显示时间戳）并将帧传递给下一个过滤器，不对帧做任何修改。</p>\n</li>\n<li><p><strong><code>noop_inputs</code> 和 <code>noop_outputs</code></strong></p>\n<p>这两个数组定义了过滤器的输入和输出 Pad。在这个例子中，输入 Pad 类型为 AVMEDIA_TYPE_VIDEO，并关联了 <code>filter_frame</code> 函数。输出 Pad 也是 AVMEDIA_TYPE_VIDEO 类型，但没有关联任何函数，因为输出直接由 <code>filter_frame</code> 函数处理。</p>\n</li>\n<li><p><strong><code>ff_vf_noop</code></strong></p>\n<p>这是一个 AVFilter 结构体实例，包含了过滤器的名称、描述、私有数据大小以及输入和输出 Pad。在这个例子中，过滤器的名称为 “noop”，描述为 “Pass the input video unchanged.”，这也就是在执行：<code>ffmpeg -filters</code> 看到的 Filter描述内容。</p>\n</li>\n</ol>\n<p>接下来看一个稍微复杂的一个 AVFilter，实现一个视频的上下翻转</p>\n<h3 id=\"复杂一点的-AVFilter\"><a href=\"#复杂一点的-AVFilter\" class=\"headerlink\" title=\"复杂一点的 AVFilter\"></a>复杂一点的 AVFilter</h3><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">FlipContext</span> &#123;</span></span><br><span class=\"line\">    <span class=\"type\">const</span> AVClass *<span class=\"class\"><span class=\"keyword\">class</span>;</span></span><br><span class=\"line\">    <span class=\"type\">int</span> duration;</span><br><span class=\"line\">&#125; FlipContext;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> OFFSET(x) offsetof(FlipContext, x)</span></span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">const</span> AVOption flip_options[] = &#123;</span><br><span class=\"line\">        &#123;<span class=\"string\">&quot;duration&quot;</span>, <span class=\"string\">&quot;set flip duration&quot;</span>, OFFSET(duration), AV_OPT_TYPE_INT, &#123;.i64 = <span class=\"number\">0</span>&#125;, <span class=\"number\">0</span>, INT_MAX, .flags = AV_OPT_FLAG_FILTERING_PARAM&#125;,</span><br><span class=\"line\">        &#123;<span class=\"literal\">NULL</span>&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">static</span> av_cold <span class=\"type\">int</span> <span class=\"title function_\">flip_init</span><span class=\"params\">(AVFilterContext *ctx)</span> &#123;</span><br><span class=\"line\">    FlipContext *context = ctx-&gt;priv;</span><br><span class=\"line\">    av_log(<span class=\"literal\">NULL</span>, AV_LOG_ERROR, <span class=\"string\">&quot;Input duration: %d.\\n&quot;</span>, context-&gt;duration);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">static</span> av_cold <span class=\"type\">void</span> <span class=\"title function_\">flip_uninit</span><span class=\"params\">(AVFilterContext *ctx)</span> &#123;</span><br><span class=\"line\">    FlipContext *context = ctx-&gt;priv;</span><br><span class=\"line\">    <span class=\"comment\">// no-op 本例无需释放滤镜实例分配的内存、关闭文件、资源等</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 对输入的 AVFrame 进行翻转</span></span><br><span class=\"line\"><span class=\"type\">static</span> AVFrame *<span class=\"title function_\">flip_frame</span><span class=\"params\">(AVFilterContext *ctx, AVFrame *in_frame)</span> &#123;</span><br><span class=\"line\"> \t\tAVFilterLink *inlink = ctx-&gt;inputs[<span class=\"number\">0</span>];</span><br><span class=\"line\">    FlipContext *s = ctx-&gt;priv;</span><br><span class=\"line\">    <span class=\"type\">int64_t</span> pts = in_frame-&gt;pts;</span><br><span class=\"line\">    <span class=\"comment\">// 将时间戳（pts）转化以秒为单位的时间戳</span></span><br><span class=\"line\">    <span class=\"type\">float</span> time_s = TS2T(pts, inlink-&gt;time_base);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (time_s &gt; s-&gt;duration) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 超过对应的时间则直接输出in_frame</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> in_frame;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 创建输出帧并分配内存</span></span><br><span class=\"line\">    AVFrame *out_frame = av_frame_alloc();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!out_frame) &#123;</span><br><span class=\"line\">        av_frame_free(&amp;in_frame);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> out_frame;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 设置输出帧的属性</span></span><br><span class=\"line\">    out_frame-&gt;format = in_frame-&gt;format;</span><br><span class=\"line\">    out_frame-&gt;width = in_frame-&gt;width;</span><br><span class=\"line\">    out_frame-&gt;height = in_frame-&gt;height;</span><br><span class=\"line\">    out_frame-&gt;pts = in_frame-&gt;pts;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 分配输出帧的数据缓冲区</span></span><br><span class=\"line\">    <span class=\"type\">int</span> ret = av_frame_get_buffer(out_frame, <span class=\"number\">32</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ret &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        av_frame_free(&amp;in_frame);</span><br><span class=\"line\">        av_frame_free(&amp;out_frame);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> out_frame;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 这个示例仅适用于 YUV 格式的视频。对于其他格式（如 RGB）</span></span><br><span class=\"line\">    <span class=\"comment\">// 翻转输入帧的数据到输出帧</span></span><br><span class=\"line\">    <span class=\"comment\">// 翻转了 Y 分量，然后翻转了 U 和 V 分量</span></span><br><span class=\"line\">    <span class=\"comment\">//</span></span><br><span class=\"line\">    <span class=\"type\">uint8_t</span> *src_y = in_frame-&gt;data[<span class=\"number\">0</span>];</span><br><span class=\"line\">    <span class=\"type\">uint8_t</span> *src_u = in_frame-&gt;data[<span class=\"number\">1</span>];</span><br><span class=\"line\">    <span class=\"type\">uint8_t</span> *src_v = in_frame-&gt;data[<span class=\"number\">2</span>];</span><br><span class=\"line\">    <span class=\"type\">uint8_t</span> *dst_y = out_frame-&gt;data[<span class=\"number\">0</span>] + (in_frame-&gt;height - <span class=\"number\">1</span>) * out_frame-&gt;linesize[<span class=\"number\">0</span>];</span><br><span class=\"line\">    <span class=\"type\">uint8_t</span> *dst_u = out_frame-&gt;data[<span class=\"number\">1</span>] + (in_frame-&gt;height / <span class=\"number\">2</span> - <span class=\"number\">1</span>) * out_frame-&gt;linesize[<span class=\"number\">1</span>];</span><br><span class=\"line\">    <span class=\"type\">uint8_t</span> *dst_v = out_frame-&gt;data[<span class=\"number\">2</span>] + (in_frame-&gt;height / <span class=\"number\">2</span> - <span class=\"number\">1</span>) * out_frame-&gt;linesize[<span class=\"number\">2</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; in_frame-&gt;height; i++) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">memcpy</span>(dst_y, src_y, in_frame-&gt;width);</span><br><span class=\"line\">        src_y += in_frame-&gt;linesize[<span class=\"number\">0</span>];</span><br><span class=\"line\">        dst_y -= out_frame-&gt;linesize[<span class=\"number\">0</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (i &lt; in_frame-&gt;height / <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">memcpy</span>(dst_u, src_u, in_frame-&gt;width / <span class=\"number\">2</span>);</span><br><span class=\"line\">            <span class=\"built_in\">memcpy</span>(dst_v, src_v, in_frame-&gt;width / <span class=\"number\">2</span>);</span><br><span class=\"line\">            src_u += in_frame-&gt;linesize[<span class=\"number\">1</span>];</span><br><span class=\"line\">            src_v += in_frame-&gt;linesize[<span class=\"number\">2</span>];</span><br><span class=\"line\">            dst_u -= out_frame-&gt;linesize[<span class=\"number\">1</span>];</span><br><span class=\"line\">            dst_v -= out_frame-&gt;linesize[<span class=\"number\">2</span>];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> out_frame;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">int</span> <span class=\"title function_\">activate</span><span class=\"params\">(AVFilterContext *ctx)</span> &#123;</span><br><span class=\"line\">    AVFilterLink *inlink = ctx-&gt;inputs[<span class=\"number\">0</span>];</span><br><span class=\"line\">    AVFilterLink *outlink = ctx-&gt;outputs[<span class=\"number\">0</span>];</span><br><span class=\"line\">    AVFrame *in_frame = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    AVFrame *out_frame = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    <span class=\"type\">int</span> ret = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 获取输入帧</span></span><br><span class=\"line\">    ret = ff_inlink_consume_frame(inlink, &amp;in_frame);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ret &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 如果有输入帧，进行翻转处理</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (in_frame) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 对输出帧进行上下翻转处理</span></span><br><span class=\"line\">        out_frame = flip_frame(ctx, in_frame);</span><br><span class=\"line\">        <span class=\"comment\">// 将处理后的帧放入输出缓冲区</span></span><br><span class=\"line\">        ret = ff_filter_frame(outlink, out_frame);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (ret &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            av_frame_free(&amp;out_frame);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 如果没有输入帧，尝试请求一个新的输入帧</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!in_frame) &#123;</span><br><span class=\"line\">        ff_inlink_request_frame(inlink);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">int</span> status;</span><br><span class=\"line\">    <span class=\"type\">int64_t</span> pts;</span><br><span class=\"line\">    ret = ff_inlink_acknowledge_status(inlink, &amp;status, &amp;pts);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ret &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (status == AVERROR_EOF) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 输入链接已经结束，设置输出链接的状态为 EOF</span></span><br><span class=\"line\">        ff_outlink_set_status(outlink, AVERROR_EOF, pts);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">AVFILTER_DEFINE_CLASS(flip);</span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">const</span> AVFilterPad flip_inputs[] = &#123;</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">                .name = <span class=\"string\">&quot;default&quot;</span>,</span><br><span class=\"line\">                .type = AVMEDIA_TYPE_VIDEO,</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">const</span> AVFilterPad flip_outputs[] = &#123;</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">                .name = <span class=\"string\">&quot;default&quot;</span>,</span><br><span class=\"line\">                .type = AVMEDIA_TYPE_VIDEO,</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"type\">const</span> AVFilter ff_vf_flip = &#123;</span><br><span class=\"line\">        .name = <span class=\"string\">&quot;flip&quot;</span>,</span><br><span class=\"line\">        .description = NULL_IF_CONFIG_SMALL(<span class=\"string\">&quot;Flip the input video.&quot;</span>),</span><br><span class=\"line\">        .priv_size = <span class=\"keyword\">sizeof</span>(FlipContext),</span><br><span class=\"line\">        .priv_class = &amp;flip_class,</span><br><span class=\"line\">        .activate      = activate,</span><br><span class=\"line\">        .init = flip_init,</span><br><span class=\"line\">        .uninit = flip_uninit,</span><br><span class=\"line\">        FILTER_INPUTS(flip_inputs),</span><br><span class=\"line\">        FILTER_OUTPUTS(flip_outputs),</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>命令行运行：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">ffmpeg -i test.mp4 -filter_complex &quot;[0:v]flip=duration=5[out];&quot; -map &quot;[out]&quot; flip.mp4</span><br></pre></td></tr></table></figure>\n\n<p> 得到渲染好的视频，前5s是上下翻转的，后面的内容正常。</p>\n<p>相比于最简单的 AVFilter 多了几个实现：</p>\n<ol>\n<li><p><strong><code>AVOption flip_options</code></strong></p>\n<p>用于设置翻转持续时间的选项，外部命令配置可选输入<code>duration=5</code>，会自动对数据合法性进行校验。参数类型为 <code>AV_OPT_TYPE_INT</code>，默认值为 0，取值范围为 0 到 <code>INT_MAX</code>。<code>.flags</code> 设置为 <code>AV_OPT_FLAG_FILTERING_PARAM</code>，表示这是一个过滤参数。</p>\n</li>\n<li><p><strong><code>.priv_class</code></strong>  </p>\n<p>配置的<code>flip_class</code>实际是通过 <code>AVFILTER_DEFINE_CLASS(flip);</code> 宏实现的一个声明：见：<a href=\"https://github.com/FFmpeg/FFmpeg/blob/release/6.1/libavfilter/internal.h#L311\">internal.h#AVFILTER_DEFINE_CLASS_EXT</a></p>\n</li>\n<li><p><strong><code>**init</code>&amp; <code>uninit</code></strong></p>\n<p>滤镜在初始化或者释放资源的时候将会调用</p>\n</li>\n<li><p><strong><code>activate</code></strong></p>\n<p>这个函数首先获取输入帧，然后调用 <code>flip_frame</code> 函数进行翻转操作，并将处理后的帧放入输出链接。如果没有输入帧，它会请求一个新的输入帧。最后，它会确认输入链接的状态，并根据需要设置输出链接的状态。</p>\n</li>\n</ol>\n<p>这个例子相比最简单的 filter 使用了 <code>activate</code> 函数 用于帧渲染，而不是使用 <code>filter_frame</code>去渲染，这两个方法有什么区别于联系呢？查看：<a href=\"##filter_frame()%E5%92%8Cactivate()%E5%87%BD%E6%95%B0\">filter_frame和activate方法</a></p>\n<p>也能通过 <code>filter_frame</code>实现，对代码部分逻辑更新更改：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">const</span> AVFilterPad flip_inputs[] = &#123;</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">                .name = <span class=\"string\">&quot;default&quot;</span>,</span><br><span class=\"line\">                .type = AVMEDIA_TYPE_VIDEO,</span><br><span class=\"line\">                .filter_frame = filter_frame, <span class=\"comment\">//添加filter_frame 实现</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">const</span> AVFilter ff_vf_flip = &#123;</span><br><span class=\"line\">       ……</span><br><span class=\"line\">        .priv_class = &amp;flip_class,</span><br><span class=\"line\">       <span class=\"comment\">// .activate      = activate,</span></span><br><span class=\"line\">        .init = flip_init,</span><br><span class=\"line\">       ……</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">int</span> <span class=\"title function_\">filter_frame</span><span class=\"params\">(AVFilterLink *inlink, AVFrame *in)</span> &#123;</span><br><span class=\"line\">    AVFilterContext *ctx = inlink-&gt;dst;</span><br><span class=\"line\">    FlipContext *s = ctx-&gt;priv;</span><br><span class=\"line\">    AVFilterLink *outlink = ctx-&gt;outputs[<span class=\"number\">0</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">int64_t</span> pts = in-&gt;pts;</span><br><span class=\"line\">    <span class=\"comment\">// 将时间戳（pts）转化以秒为单位的时间戳</span></span><br><span class=\"line\">    <span class=\"type\">float</span> time_s = TS2T(pts, inlink-&gt;time_base);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (time_s &gt; s-&gt;duration) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 超过对应的时间则直接输出in_frame</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> ff_filter_frame(outlink, in);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        av_log(<span class=\"literal\">NULL</span>, AV_LOG_ERROR, <span class=\"string\">&quot;time_s s: %f.\\n&quot;</span>, time_s);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    AVFrame *out = flip_frame(ctx, in);</span><br><span class=\"line\">    <span class=\"comment\">// 释放输入帧</span></span><br><span class=\"line\">    av_frame_free(&amp;in);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 将输出帧传递给下一个滤镜</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> ff_filter_frame(outlink, out);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>命令行运行，得到的输出结果是一样的。</p>\n<h2 id=\"filter-frame-和activate-函数\"><a href=\"#filter-frame-和activate-函数\" class=\"headerlink\" title=\"filter_frame()和activate()函数\"></a>filter_frame()和activate()函数</h2><p>对于这点查了相关资料，看看源码相关的实现</p>\n<p>参考：<a href=\"https://www.ffmpeg.org/doxygen/5.0/filter__design_8txt.html\">https://www.ffmpeg.org/doxygen/5.0/filter__design_8txt.html</a></p>\n<blockquote>\n<p>The purpose of these rules is to ensure that frames flow in the filter graph without getting stuck and accumulating somewhere. Simple filters that output one frame for each input frame should not have to worry about it. There are two design for filters:one using the  <a href=\"https://www.ffmpeg.org/doxygen/5.0/vsink__nullsink_8c.html#aaa9a0e0f9de1464941d86a984cf77d37\">filter_frame</a>() and <a href=\"https://www.ffmpeg.org/doxygen/5.0/vsrc__mptestsrc_8c.html#a72949c8fcad3f201712a3569fc6888cb\">request_frame</a>() callbacks and the other using the activate() callback. The design using filter_frame() and request_frame() is legacy, but it is suitable for filters that have a single input and process one frame at a time. New filters with several inputs, that treat several frames at a time or that require a special treatment at EOF should probably use the design using activate(). activate ——– This method is called when something must be done in a filter</p>\n</blockquote>\n<p>大意，实现滤镜有两种实现方式：</p>\n<ul>\n<li><p><strong><code>filter_frame()</code></strong></p>\n<p>可以被认为是历史遗留产物。在早期的 AVFilter 设计中，<code>filter_frame()</code> 和 <code>request_frame()</code> 是主要用于处理输入帧和请求输出帧的回调函数。这种设计适用于简单的过滤器，例如单输入且每次处理一个帧的过滤器。</p>\n</li>\n<li><p><strong><code>activate()</code></strong></p>\n<p>随着 ffmpeg 和 AVFilter 的发展，处理需求变得越来越复杂，例如需要处理多个输入、一次处理多个帧或在文件结束（EOF）时进行特殊处理等。为了满足这些需求，引入了 <code>activate()</code> 函数，它提供了更灵活和强大的处理能力。因此，虽然 <code>filter_frame()</code> 在某些简单场景下仍然可以使用，但对于新的或复杂的过滤器，建议使用 <code>activate()</code> 函数。</p>\n</li>\n</ul>\n<p>如果两个方法都实现了，那他们谁会先执行呢？</p>\n<p>对应的源码处理逻辑： <a href=\"https://github.com/FFmpeg/FFmpeg/blob/release/6.1/libavfilter/avfilter.c#L1322\">avfilter.c</a></p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">ff_filter_activate</span><span class=\"params\">(AVFilterContext *filter)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> ret;</span><br><span class=\"line\">\t\t……</span><br><span class=\"line\">    ret = filter-&gt;filter-&gt;activate ? filter-&gt;filter-&gt;activate(filter) :</span><br><span class=\"line\">          ff_filter_activate_default(filter);</span><br><span class=\"line\">  \t……</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如果配置了activate() 函数则执行，否则执行 ff_filter_activate_default()-&gt;ff_filter_frame_to_filter()-&gt;ff_filter_frame_framed() 最终执行到配置的 filter_frame() 方法。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">int</span> <span class=\"title function_\">ff_filter_frame_framed</span><span class=\"params\">(AVFilterLink *link, AVFrame *frame)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> (*filter_frame)(AVFilterLink *, AVFrame *);</span><br><span class=\"line\">    AVFilterContext *dstctx = link-&gt;dst;</span><br><span class=\"line\">    AVFilterPad *dst = link-&gt;dstpad;</span><br><span class=\"line\">    <span class=\"type\">int</span> ret;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!(filter_frame = dst-&gt;filter_frame))</span><br><span class=\"line\">        filter_frame = default_filter_frame;</span><br><span class=\"line\">    ……</span><br><span class=\"line\">    ret = filter_frame(link, frame);  <span class=\"comment\">// 最终调用到的地方</span></span><br><span class=\"line\">    link-&gt;frame_count_out++;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">fail:</span><br><span class=\"line\">    ……</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>本文介绍了 FFmpeg 滤镜开发的整体流程，如何编写 filter.c 文件，并以一个最简单的 AVFilter 和一个较为复杂的 AVFilter 为例，解析了滤镜开发的具体步骤和代码实现，并介绍了 filter_frame() 和 activate() 函数的区别与联系。</p>\n<p>在滤镜开发过程中，需要注意的是，filter_frame() 和 activate() 函数的使用取决于滤镜的复杂性。对于简单的滤镜，可以使用 filter_frame() 函数；而对于需要处理多个输入、一次处理多个帧或在文件结束（EOF）时进行特殊处理的复杂滤镜，建议使用 activate() 函数。</p>\n<p>文中的源码可以查看：<a href=\"https://github.com/VomPom/FFmpeg/commit/9176f58ae60e0b70e5708b25017f374deac9fae7\">add most simplest  AVFilter and a simple video flip filter.</a></p>\n<h3 id=\"参考：\"><a href=\"#参考：\" class=\"headerlink\" title=\"参考：\"></a>参考：</h3><p><a href=\"https://www.cnblogs.com/TaigaCon/p/10171464.html\">https://www.cnblogs.com/TaigaCon/p/10171464.html</a></p>\n<p><a href=\"https://www.cnblogs.com/ranson7zop/p/7728639.html\">https://www.cnblogs.com/ranson7zop/p/7728639.html</a></p>\n<p><a href=\"https://www.ffmpeg.org/doxygen/5.0/filter__design_8txt.html\">https://www.ffmpeg.org/doxygen/5.0/filter__design_8txt.html</a></p>\n","categories":[],"tags":[{"name":"FFmpeg","slug":"FFmpeg","api":"api/tags/FFmpeg.json"}],"api":"api/posts/2024/03/07/实现一个自定义FFmpeg-Filter.json"}],"info":{"type":"archive","year":2024}},"api":"api/archives/2024/page.1.json"}