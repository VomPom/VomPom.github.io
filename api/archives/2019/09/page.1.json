{"data":{"index":1,"total":1,"posts":[{"title":"观《百鸟朝凤》有感","slug":"观《百鸟朝凤》有感","date":"2019-09-07T18:16:00.000Z","updated":"2025-05-20T11:46:57.000Z","comments":true,"url":"2019/09/08/观《百鸟朝凤》有感/","excerpt":"<p>此刻子时，在朋友的推荐下看完了整部《百鸟朝凤》，看完之后我立马起身来打开电脑，心中思绪万千，准备写下来记录下来。自我观看了这么多电影以来，头一次是如此的触动，头一次留下来这样的眼泪，记得上一次很有感触还是因为《忠犬八公的故事》，那次泪水到了眼角，我忍住了，没有掉下来。这部电影实在是让我太感动了，我的泪水憋不下去了，源源不断地从眼眶里面流出来。我捂着自己的嘴巴，我怕自己嚎啕大哭起来，不停地抽泣。对一代匠人的崇敬之情，当然也让我想起来那个人……</p>\n<p>   他已经离我六年之余，从离开他之后，我的梦大部分都是关于他，梦中的情节很多都是让我感觉他躲起来了，然后又出现再了我的面前。每次梦醒，思前想后，万端交集，竟不能复寐，他便是我的爷爷-兴武老大人。</p>\n<p>   关于他的记忆开始慢慢变得模糊，有很多事情都已经忘记，但又有很多我根本不能忘记。影片中的焦师傅，爷爷的形象简直和他一模一样，都一样抽着大烟，瘦弱的身躯，头顶的中间光秃秃的，走路总是半佝偻着腰，但是眼神又是那么的坚毅。他们都对传统文化有着独特的情感，我的爷爷也算是一个匠人，他是一名竹匠（“四川话叫 mie匠”），他只告诉过我，那个年代他们靠卖竹制的东西（大抵是一些席子、竹帘、晒席之类的东西）过日子，每天都帮着各种编织，才养活了包括我爸在内的五个子女。家中很多东西，也都是竹子做的。在我小的时候，我记得基本上我们整个村，每家每户都有一片属于自家的竹林，它不仅能提供我们编制各种东西的原材料，也能提供做饭生火的材料。在我现在看来，它更能提供那种接近大自然的方式。每当夜里，如果有阵阵微风，竹林中便会的竹叶洒洒作响的声音，我也很久没有听到这种声音了。</p>\n<p>   如果我看到我的爷爷拿着一把弯刀去后院，那我一定知道他应该是要去砍竹子，只听哐哐哐一阵声，竹子便倒了下来，他会剔除掉竹子的枝丫，以及顶部较为脆弱细小的部分。然后用取当中的一节，再用刀将其剖开，根据所做的东西的不同，会将竹子的圆分成不同的等分。然后会做一个比较难得的操作，具体用文字表达我也不知道该用什么术语去说，就是将竹子外层坚韧的部分与内部相分离，分离后的竹条厚度均匀。这便是编制前的准备阶段，对于编制一些特殊的物品，竹条可能还会经过一些其他一些操作才能继续编制。</p>\n<p>   为了编一个撮箕或者簸箕，爷爷可能会花上一整天的时间，弯腰在地一点一点的编织着。我经常在旁边看着，我可能也想去尝试，但一不下心手就会因为竹子的锋利而流血。而爷爷的手并不一样，我记得他的手上有很多老茧，手指头也特别的硬，我感觉他的手就像带了一个硬皮手套一样，这都是岁月留下来的痕迹吧。他总是给我讲他们过去的故事，也会给我讲解人生大道理。他给我讲梁山伯与祝英台的故事，他也给我讲毛泽东，他也讲以前文化大革命的故事……讲以前生活是多么的不容易，他们遭受了多少苦，我都还记得。爷爷编织好的竹制品真的很精致耐用，家里现在也还留着一些当时他编好的东西。我觉得那都是艺术品，都是源于一个人对生活的热爱以及对匠人的诠释吧。</p>\n<p>   后来搬家了，原先家里的那片竹林离我们有一些距离，我爸想把它们都挖了卖掉，因为现在我们不需要那么多竹子了。我爷爷当然不允许啊！卖掉？直接就跟我爸翻脸。在我看来，那片竹林可能承载了太多爷爷的记忆吧，太多的舍不得。但爷爷去世之后，那片竹林还是被移除掉了，实在痛惜。我后悔没有跟我的爷爷学这些编制技术，我爸会一些，但是我认为他只是一个半吊子，和爷爷做的东西比起来实在是差太多了。我爸曾说：“现在谁还做那些啊？有钱我们可以买。”，对于他的话我有反驳过。买来的那些都是些没有被注入感情的废铜烂铁吧，与爷爷的东西差太远了。或许真的因为时代的发展吧，这些东西渐渐地都被淘汰掉了，但我认为这些都是才是真正应该被传承下来的，不仅仅是因为这一门技术，更多的那一份精神吧。是用钱买不来的，机器造不来的。</p>\n<p>   《百鸟朝凤》这部电影令人肃然起敬，质朴的人物形象，体现出来了当代中国传统文化的潦倒与窘境，传承不是说说而已，是每一个中国人应该有的责任。在现代多元文化的冲击下，更多人的失去了对精神的追求和向往，取而代之的是短暂的愉悦刺激以及碎片化的东西。<br>我们的生活其实可以更有内涵……</p>\n<p>困了，就写这么多吧，讲了一些乱七八糟的东西，懂得人自然懂吧。</p>\n<p>晚安~</p>\n<p><img src=\"https://pica.zhimg.com/70/fca270cbac1c48fb0f343fa336c23b3a_1440w.avis?source=172ae18b&biz_tag=Post\"></p>\n","cover":null,"images":["https://pica.zhimg.com/70/fca270cbac1c48fb0f343fa336c23b3a_1440w.avis?source=172ae18b&biz_tag=Post"],"content":"<p>此刻子时，在朋友的推荐下看完了整部《百鸟朝凤》，看完之后我立马起身来打开电脑，心中思绪万千，准备写下来记录下来。自我观看了这么多电影以来，头一次是如此的触动，头一次留下来这样的眼泪，记得上一次很有感触还是因为《忠犬八公的故事》，那次泪水到了眼角，我忍住了，没有掉下来。这部电影实在是让我太感动了，我的泪水憋不下去了，源源不断地从眼眶里面流出来。我捂着自己的嘴巴，我怕自己嚎啕大哭起来，不停地抽泣。对一代匠人的崇敬之情，当然也让我想起来那个人……</p>\n<p>   他已经离我六年之余，从离开他之后，我的梦大部分都是关于他，梦中的情节很多都是让我感觉他躲起来了，然后又出现再了我的面前。每次梦醒，思前想后，万端交集，竟不能复寐，他便是我的爷爷-兴武老大人。</p>\n<p>   关于他的记忆开始慢慢变得模糊，有很多事情都已经忘记，但又有很多我根本不能忘记。影片中的焦师傅，爷爷的形象简直和他一模一样，都一样抽着大烟，瘦弱的身躯，头顶的中间光秃秃的，走路总是半佝偻着腰，但是眼神又是那么的坚毅。他们都对传统文化有着独特的情感，我的爷爷也算是一个匠人，他是一名竹匠（“四川话叫 mie匠”），他只告诉过我，那个年代他们靠卖竹制的东西（大抵是一些席子、竹帘、晒席之类的东西）过日子，每天都帮着各种编织，才养活了包括我爸在内的五个子女。家中很多东西，也都是竹子做的。在我小的时候，我记得基本上我们整个村，每家每户都有一片属于自家的竹林，它不仅能提供我们编制各种东西的原材料，也能提供做饭生火的材料。在我现在看来，它更能提供那种接近大自然的方式。每当夜里，如果有阵阵微风，竹林中便会的竹叶洒洒作响的声音，我也很久没有听到这种声音了。</p>\n<p>   如果我看到我的爷爷拿着一把弯刀去后院，那我一定知道他应该是要去砍竹子，只听哐哐哐一阵声，竹子便倒了下来，他会剔除掉竹子的枝丫，以及顶部较为脆弱细小的部分。然后用取当中的一节，再用刀将其剖开，根据所做的东西的不同，会将竹子的圆分成不同的等分。然后会做一个比较难得的操作，具体用文字表达我也不知道该用什么术语去说，就是将竹子外层坚韧的部分与内部相分离，分离后的竹条厚度均匀。这便是编制前的准备阶段，对于编制一些特殊的物品，竹条可能还会经过一些其他一些操作才能继续编制。</p>\n<p>   为了编一个撮箕或者簸箕，爷爷可能会花上一整天的时间，弯腰在地一点一点的编织着。我经常在旁边看着，我可能也想去尝试，但一不下心手就会因为竹子的锋利而流血。而爷爷的手并不一样，我记得他的手上有很多老茧，手指头也特别的硬，我感觉他的手就像带了一个硬皮手套一样，这都是岁月留下来的痕迹吧。他总是给我讲他们过去的故事，也会给我讲解人生大道理。他给我讲梁山伯与祝英台的故事，他也给我讲毛泽东，他也讲以前文化大革命的故事……讲以前生活是多么的不容易，他们遭受了多少苦，我都还记得。爷爷编织好的竹制品真的很精致耐用，家里现在也还留着一些当时他编好的东西。我觉得那都是艺术品，都是源于一个人对生活的热爱以及对匠人的诠释吧。</p>\n<p>   后来搬家了，原先家里的那片竹林离我们有一些距离，我爸想把它们都挖了卖掉，因为现在我们不需要那么多竹子了。我爷爷当然不允许啊！卖掉？直接就跟我爸翻脸。在我看来，那片竹林可能承载了太多爷爷的记忆吧，太多的舍不得。但爷爷去世之后，那片竹林还是被移除掉了，实在痛惜。我后悔没有跟我的爷爷学这些编制技术，我爸会一些，但是我认为他只是一个半吊子，和爷爷做的东西比起来实在是差太多了。我爸曾说：“现在谁还做那些啊？有钱我们可以买。”，对于他的话我有反驳过。买来的那些都是些没有被注入感情的废铜烂铁吧，与爷爷的东西差太远了。或许真的因为时代的发展吧，这些东西渐渐地都被淘汰掉了，但我认为这些都是才是真正应该被传承下来的，不仅仅是因为这一门技术，更多的那一份精神吧。是用钱买不来的，机器造不来的。</p>\n<p>   《百鸟朝凤》这部电影令人肃然起敬，质朴的人物形象，体现出来了当代中国传统文化的潦倒与窘境，传承不是说说而已，是每一个中国人应该有的责任。在现代多元文化的冲击下，更多人的失去了对精神的追求和向往，取而代之的是短暂的愉悦刺激以及碎片化的东西。<br>我们的生活其实可以更有内涵……</p>\n<p>困了，就写这么多吧，讲了一些乱七八糟的东西，懂得人自然懂吧。</p>\n<p>晚安~</p>\n<p><img src=\"https://pica.zhimg.com/70/fca270cbac1c48fb0f343fa336c23b3a_1440w.avis?source=172ae18b&biz_tag=Post\"></p>\n","categories":[{"name":"读书电影","slug":"movie","api":"api/categories/movie.json"}],"tags":[{"name":"省","slug":"thinking","api":"api/tags/thinking.json"}],"api":"api/posts/2019/09/08/观《百鸟朝凤》有感.json"},{"title":"Android骨架屏效果的实现与原理解析","slug":"Android骨架屏效果的实现与原理解析","date":"2019-09-04T09:50:00.000Z","updated":"2025-05-20T11:46:57.000Z","comments":true,"url":"2019/09/04/Android骨架屏效果的实现与原理解析/","excerpt":"<p>大家在使用淘宝的时候，如下图所示有遇到这样的效果，其会只展示一部分骨架大致图，等数据加载完毕之后再展示真正的页面数据。与菊花图相比起来，这样的实现能更好的提升用户的体验，这种效果称做：Skeleton Screen Loading，中文叫做<strong>骨架屏</strong>，本文主要记录其实现过程。</p>\n<h2 id=\"1、骨架屏的实现方式\"><a href=\"#1、骨架屏的实现方式\" class=\"headerlink\" title=\"1、骨架屏的实现方式\"></a>1、骨架屏的实现方式</h2><img src=\"https://cdn.julis.wang/blog/img/b911cd8e3eba7fdc4bea89ad6cb07bf4a7d.png\">\n<p>在现在主流的骨架屏实现效果中有两种方式：</p>\n<ul>\n<li><p>通过View或者Adapter的替换来实现骨架屏效果。可以参考<a href=\"https://github.com/sharish/ShimmerRecyclerView\">ShimmerRecyclerView</a>、<a href=\"https://github.com/ethanhua/Skeleton\">Skeleton</a>及<a href=\"https://github.com/willowtreeapps/spruce-android\">spruce-android</a>。</p>\n</li>\n<li><p>自定义一个View来对布局中的View进行一层包裹，当加载数据时则根据View来绘制骨架，否则显示正常UI，参考<a href=\"https://github.com/rasoulmiri/Skeleton\">Skeleton Android</a>。</p>\n</li>\n</ul>\n<p>这些开源库中，自己比较喜欢今天<strong>Skeleton</strong>这个开源库，总结了有如下一些优缺点：</p>\n<p><strong>优点：</strong></p>\n<ol>\n<li>代码方案实现及使用方式简单，通过替换View和Adapter实现效果，使用Builder设计模式来构造。</li>\n<li>代码耦合程度不高。没有复杂的设计模式，使得代码结构清晰明了。</li>\n<li>骨架屏的效果使用相对于较灵活，可以对整个布局实现骨架屏效果，也可以对单一View实现骨架屏效果。</li>\n</ol>\n<p><strong>缺点：</strong></p>\n<ol>\n<li>需要对每个骨架屏效果单独写一套xml布局。</li>\n<li>使用的removeView和addView对 原有布局的view进行替换，存在一定的风险性</li>\n<li>必须清晰的知道所bind的View类型，存在一定的类型转化问题。</li>\n<li>依赖了shimmerlayout第三方库</li>\n</ol>\n<h2 id=\"2、Skeleton解读\"><a href=\"#2、Skeleton解读\" class=\"headerlink\" title=\"2、Skeleton解读\"></a>2、Skeleton解读</h2><p><strong>一、Skeleton的使用方式</strong></p>\n<p>展示骨架屏效果：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">View</span> <span class=\"variable\">rootView</span> <span class=\"operator\">=</span> findViewById(R.id.rootView);</span><br><span class=\"line\">skeletonScreen = Skeleton.bind(rootView)</span><br><span class=\"line\">           .load(R.layout.activity_view_skeleton)<span class=\"comment\">//骨架屏UI</span></span><br><span class=\"line\">           .duration(<span class=\"number\">1000</span>)<span class=\"comment\">//动画时间，以毫秒为单位</span></span><br><span class=\"line\">           .shimmer(<span class=\"literal\">true</span>)<span class=\"comment\">//是否开启动画</span></span><br><span class=\"line\">           .color(R.color.shimmer_color)<span class=\"comment\">//shimmer的颜色</span></span><br><span class=\"line\">           .angle(<span class=\"number\">30</span>)<span class=\"comment\">//shimmer的倾斜角度</span></span><br><span class=\"line\">           .show();</span><br></pre></td></tr></table></figure>\n<p>关闭骨架屏效果并展示原有View：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">skeletonScreen.hide()</span><br></pre></td></tr></table></figure>\n\n<p><strong>流程：</strong></p>\n<p> <strong>1. 选择需要替换的目标view<br> 2. 将骨架效果xml与目标view进行绑定<br> 3. 添加一些效果属性，比如：动画时间、是否开启展示动画、动画颜色等<br> 4. 在合适的实际关闭骨架屏效果</strong></p>\n<p><strong>二、Skeleton源码实现</strong></p>\n<p>Skeleton提供两个绑定方法，分别绑定普通View与RecyclerView，分别返回对应的Builder</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Skeleton</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> RecyclerViewSkeletonScreen.Builder <span class=\"title function_\">bind</span><span class=\"params\">(RecyclerView recyclerView)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">RecyclerViewSkeletonScreen</span>.Builder(recyclerView);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> ViewSkeletonScreen.Builder <span class=\"title function_\">bind</span><span class=\"params\">(View view)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ViewSkeletonScreen</span>.Builder(view);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们首先来看看如何实现与普通View绑定，构造方法中传入目标View，并对shimmer动画效果设置默认的颜色，在Builder里面我们可以看到各种相关参数的设定。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"title function_\">Builder</span><span class=\"params\">(View view)</span> &#123;</span><br><span class=\"line\">\t<span class=\"built_in\">this</span>.mView = view;</span><br><span class=\"line\">\t<span class=\"built_in\">this</span>.mShimmerColor = ContextCompat.getColor(mView.getContext(), R.color.shimmer_color);</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<p>接下来再到show的步骤，主要实现还是由ViewSkeletonScreen来实现</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> ViewSkeletonScreen <span class=\"title function_\">show</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">ViewSkeletonScreen</span> <span class=\"variable\">skeletonScreen</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ViewSkeletonScreen</span>(<span class=\"built_in\">this</span>);</span><br><span class=\"line\">    skeletonScreen.show();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> skeletonScreen;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>其中ViewSkeletonScreen与绑定的RecyclerViewSkeletonScreen都实现了SkeletonScreen接口，SkeletonScreen有两个接口方法分别是   </p>\n<pre><code>void show();\nvoid hide();\n</code></pre>\n<p>对于ViewSkeletonScreen.show()进入源码，这里出现一个比较重要的类<code>ViewReplacer</code>，等下再进行解析，通过show的源码清楚的知道逻辑：<br><strong>1、生成骨架效果View<br>2、利用生成的View替换目标View。</strong><br>其中生成骨架效果View阶段主要还是通过LayoutInflater去加载传入mSkeletonResID</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">show</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">       <span class=\"type\">View</span> <span class=\"variable\">skeletonLoadingView</span> <span class=\"operator\">=</span> generateSkeletonLoadingView();</span><br><span class=\"line\">       <span class=\"keyword\">if</span> (skeletonLoadingView != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">           mViewReplacer.replace(skeletonLoadingView);</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n<p>接下来主要讲解ViewReplacer类，其构造方法传入目标View</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"title function_\">ViewReplacer</span><span class=\"params\">(View sourceView)</span> &#123;</span><br><span class=\"line\">     mSourceView = sourceView;</span><br><span class=\"line\">     mSourceViewLayoutParams = mSourceView.getLayoutParams();</span><br><span class=\"line\">     mCurrentView = mSourceView;</span><br><span class=\"line\">     mSourceViewId = mSourceView.getId();</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n<p>其比较重要的方法有两个：<code>replace()</code> 和 <code>restore()</code> 这两个方法分别为SkeletonScreen 的show()和hide()的最终实现，首先看<code>replace()</code>方法，有两个方法重载，分别传入<code>targetViewResID</code>或者<code>targetView</code>，最终还是会走到<code>replace(View targetView)</code>中。<br>其主要逻辑为：</p>\n<p> <strong>1. 判断所替换的View和骨架屏效果View是否为同一个View<br> 2. remove掉在父布局中的目标View<br> 3. 将骨架屏效果View添加到目标View的父布局中</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">replace</span><span class=\"params\">(<span class=\"type\">int</span> targetViewResID)</span> &#123;</span><br><span class=\"line\">       <span class=\"keyword\">if</span> (mTargetViewResID == targetViewResID) &#123;</span><br><span class=\"line\">           <span class=\"keyword\">return</span>;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       <span class=\"keyword\">if</span> (init()) &#123;</span><br><span class=\"line\">           mTargetViewResID = targetViewResID;</span><br><span class=\"line\">           replace(LayoutInflater.from(mSourceView.getContext()).inflate(mTargetViewResID, mSourceParentView, <span class=\"literal\">false</span>));</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">replace</span><span class=\"params\">(View targetView)</span> &#123;</span><br><span class=\"line\">       <span class=\"keyword\">if</span> (mCurrentView == targetView) &#123;</span><br><span class=\"line\">           <span class=\"keyword\">return</span>;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       <span class=\"keyword\">if</span> (targetView.getParent() != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">           ((ViewGroup) targetView.getParent()).removeView(targetView);</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       <span class=\"keyword\">if</span> (init()) &#123;</span><br><span class=\"line\">           mTargetView = targetView;</span><br><span class=\"line\">           mSourceParentView.removeView(mCurrentView);</span><br><span class=\"line\">           mTargetView.setId(mSourceViewId);</span><br><span class=\"line\">           mSourceParentView.addView(mTargetView, mSourceViewIndexInParent, mSourceViewLayoutParams);</span><br><span class=\"line\">           mCurrentView = mTargetView;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n\n<p>在执行添加到目标View的父布局中，有执行一个init方法，主要做两件事：</p>\n<p> <strong>1. 获取目标View的父View<br> 2. 找到目标View在父View 中的位置索引，为之后添加骨架屏View到父View中做铺垫</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"type\">boolean</span> <span class=\"title function_\">init</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">     <span class=\"keyword\">if</span> (mSourceParentView == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">         mSourceParentView = (ViewGroup) mSourceView.getParent();</span><br><span class=\"line\">         <span class=\"keyword\">if</span> (mSourceParentView == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">             Log.e(TAG, <span class=\"string\">&quot;the source view have not attach to any view&quot;</span>);</span><br><span class=\"line\">             <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">         <span class=\"type\">int</span> <span class=\"variable\">count</span> <span class=\"operator\">=</span> mSourceParentView.getChildCount();</span><br><span class=\"line\">         <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">index</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; index &lt; count; index++) &#123;</span><br><span class=\"line\">             <span class=\"keyword\">if</span> (mSourceView == mSourceParentView.getChildAt(index)) &#123;</span><br><span class=\"line\">                 mSourceViewIndexInParent = index;</span><br><span class=\"line\">                 <span class=\"keyword\">break</span>;</span><br><span class=\"line\">             &#125;</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">     <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n<p>至此对普通View的骨架屏效果实现流程已经完全梳理完成，那对于<code>RecyclerView</code>呢？其实两者实现逻辑差不多，主要有两个差异：</p>\n<ol>\n<li>在<code>RecyclerViewSkeletonScreen</code>的Builder中，相比ViewSkeletonScreen多了一个adapter()方法，传入目标<code>RecyclerView</code>的<code>Adapter</code></li>\n<li>在show的时候对目标<code>RecyclerView</code>的adapter进行替换，使用骨架屏效果的adapter。hide的时候恢复为原先的Adapter</li>\n</ol>\n<h2 id=\"3、总结\"><a href=\"#3、总结\" class=\"headerlink\" title=\"3、总结\"></a>3、总结</h2><ol>\n<li>Skeleton的原理主要是通过替换目标View和RecyclerView的Adapter</li>\n<li>在Skeleton的使用过程中最需要关心的两个问题是：show()和hide()的时机</li>\n<li>对于整个页面的骨架屏效果实现，个人推荐在布局中添加一个全屏的空View盖在原先内容上</li>\n<li>注意一些异常情况下的hide()，要不然整个页面就“假死”状态了。</li>\n</ol>\n<p>参考：<br><a href=\"https://juejin.im/post/5c789a4ce51d457c042d3b31\">https://juejin.im/post/5c789a4ce51d457c042d3b31</a></p>\n","cover":null,"images":["https://cdn.julis.wang/blog/img/b911cd8e3eba7fdc4bea89ad6cb07bf4a7d.png"],"content":"<p>大家在使用淘宝的时候，如下图所示有遇到这样的效果，其会只展示一部分骨架大致图，等数据加载完毕之后再展示真正的页面数据。与菊花图相比起来，这样的实现能更好的提升用户的体验，这种效果称做：Skeleton Screen Loading，中文叫做<strong>骨架屏</strong>，本文主要记录其实现过程。</p>\n<h2 id=\"1、骨架屏的实现方式\"><a href=\"#1、骨架屏的实现方式\" class=\"headerlink\" title=\"1、骨架屏的实现方式\"></a>1、骨架屏的实现方式</h2><img src=\"https://cdn.julis.wang/blog/img/b911cd8e3eba7fdc4bea89ad6cb07bf4a7d.png\">\n<p>在现在主流的骨架屏实现效果中有两种方式：</p>\n<ul>\n<li><p>通过View或者Adapter的替换来实现骨架屏效果。可以参考<a href=\"https://github.com/sharish/ShimmerRecyclerView\">ShimmerRecyclerView</a>、<a href=\"https://github.com/ethanhua/Skeleton\">Skeleton</a>及<a href=\"https://github.com/willowtreeapps/spruce-android\">spruce-android</a>。</p>\n</li>\n<li><p>自定义一个View来对布局中的View进行一层包裹，当加载数据时则根据View来绘制骨架，否则显示正常UI，参考<a href=\"https://github.com/rasoulmiri/Skeleton\">Skeleton Android</a>。</p>\n</li>\n</ul>\n<p>这些开源库中，自己比较喜欢今天<strong>Skeleton</strong>这个开源库，总结了有如下一些优缺点：</p>\n<p><strong>优点：</strong></p>\n<ol>\n<li>代码方案实现及使用方式简单，通过替换View和Adapter实现效果，使用Builder设计模式来构造。</li>\n<li>代码耦合程度不高。没有复杂的设计模式，使得代码结构清晰明了。</li>\n<li>骨架屏的效果使用相对于较灵活，可以对整个布局实现骨架屏效果，也可以对单一View实现骨架屏效果。</li>\n</ol>\n<p><strong>缺点：</strong></p>\n<ol>\n<li>需要对每个骨架屏效果单独写一套xml布局。</li>\n<li>使用的removeView和addView对 原有布局的view进行替换，存在一定的风险性</li>\n<li>必须清晰的知道所bind的View类型，存在一定的类型转化问题。</li>\n<li>依赖了shimmerlayout第三方库</li>\n</ol>\n<h2 id=\"2、Skeleton解读\"><a href=\"#2、Skeleton解读\" class=\"headerlink\" title=\"2、Skeleton解读\"></a>2、Skeleton解读</h2><p><strong>一、Skeleton的使用方式</strong></p>\n<p>展示骨架屏效果：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">View</span> <span class=\"variable\">rootView</span> <span class=\"operator\">=</span> findViewById(R.id.rootView);</span><br><span class=\"line\">skeletonScreen = Skeleton.bind(rootView)</span><br><span class=\"line\">           .load(R.layout.activity_view_skeleton)<span class=\"comment\">//骨架屏UI</span></span><br><span class=\"line\">           .duration(<span class=\"number\">1000</span>)<span class=\"comment\">//动画时间，以毫秒为单位</span></span><br><span class=\"line\">           .shimmer(<span class=\"literal\">true</span>)<span class=\"comment\">//是否开启动画</span></span><br><span class=\"line\">           .color(R.color.shimmer_color)<span class=\"comment\">//shimmer的颜色</span></span><br><span class=\"line\">           .angle(<span class=\"number\">30</span>)<span class=\"comment\">//shimmer的倾斜角度</span></span><br><span class=\"line\">           .show();</span><br></pre></td></tr></table></figure>\n<p>关闭骨架屏效果并展示原有View：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">skeletonScreen.hide()</span><br></pre></td></tr></table></figure>\n\n<p><strong>流程：</strong></p>\n<p> <strong>1. 选择需要替换的目标view<br> 2. 将骨架效果xml与目标view进行绑定<br> 3. 添加一些效果属性，比如：动画时间、是否开启展示动画、动画颜色等<br> 4. 在合适的实际关闭骨架屏效果</strong></p>\n<p><strong>二、Skeleton源码实现</strong></p>\n<p>Skeleton提供两个绑定方法，分别绑定普通View与RecyclerView，分别返回对应的Builder</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Skeleton</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> RecyclerViewSkeletonScreen.Builder <span class=\"title function_\">bind</span><span class=\"params\">(RecyclerView recyclerView)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">RecyclerViewSkeletonScreen</span>.Builder(recyclerView);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> ViewSkeletonScreen.Builder <span class=\"title function_\">bind</span><span class=\"params\">(View view)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ViewSkeletonScreen</span>.Builder(view);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们首先来看看如何实现与普通View绑定，构造方法中传入目标View，并对shimmer动画效果设置默认的颜色，在Builder里面我们可以看到各种相关参数的设定。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"title function_\">Builder</span><span class=\"params\">(View view)</span> &#123;</span><br><span class=\"line\">\t<span class=\"built_in\">this</span>.mView = view;</span><br><span class=\"line\">\t<span class=\"built_in\">this</span>.mShimmerColor = ContextCompat.getColor(mView.getContext(), R.color.shimmer_color);</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<p>接下来再到show的步骤，主要实现还是由ViewSkeletonScreen来实现</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> ViewSkeletonScreen <span class=\"title function_\">show</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">ViewSkeletonScreen</span> <span class=\"variable\">skeletonScreen</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ViewSkeletonScreen</span>(<span class=\"built_in\">this</span>);</span><br><span class=\"line\">    skeletonScreen.show();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> skeletonScreen;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>其中ViewSkeletonScreen与绑定的RecyclerViewSkeletonScreen都实现了SkeletonScreen接口，SkeletonScreen有两个接口方法分别是   </p>\n<pre><code>void show();\nvoid hide();\n</code></pre>\n<p>对于ViewSkeletonScreen.show()进入源码，这里出现一个比较重要的类<code>ViewReplacer</code>，等下再进行解析，通过show的源码清楚的知道逻辑：<br><strong>1、生成骨架效果View<br>2、利用生成的View替换目标View。</strong><br>其中生成骨架效果View阶段主要还是通过LayoutInflater去加载传入mSkeletonResID</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">show</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">       <span class=\"type\">View</span> <span class=\"variable\">skeletonLoadingView</span> <span class=\"operator\">=</span> generateSkeletonLoadingView();</span><br><span class=\"line\">       <span class=\"keyword\">if</span> (skeletonLoadingView != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">           mViewReplacer.replace(skeletonLoadingView);</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n<p>接下来主要讲解ViewReplacer类，其构造方法传入目标View</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"title function_\">ViewReplacer</span><span class=\"params\">(View sourceView)</span> &#123;</span><br><span class=\"line\">     mSourceView = sourceView;</span><br><span class=\"line\">     mSourceViewLayoutParams = mSourceView.getLayoutParams();</span><br><span class=\"line\">     mCurrentView = mSourceView;</span><br><span class=\"line\">     mSourceViewId = mSourceView.getId();</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n<p>其比较重要的方法有两个：<code>replace()</code> 和 <code>restore()</code> 这两个方法分别为SkeletonScreen 的show()和hide()的最终实现，首先看<code>replace()</code>方法，有两个方法重载，分别传入<code>targetViewResID</code>或者<code>targetView</code>，最终还是会走到<code>replace(View targetView)</code>中。<br>其主要逻辑为：</p>\n<p> <strong>1. 判断所替换的View和骨架屏效果View是否为同一个View<br> 2. remove掉在父布局中的目标View<br> 3. 将骨架屏效果View添加到目标View的父布局中</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">replace</span><span class=\"params\">(<span class=\"type\">int</span> targetViewResID)</span> &#123;</span><br><span class=\"line\">       <span class=\"keyword\">if</span> (mTargetViewResID == targetViewResID) &#123;</span><br><span class=\"line\">           <span class=\"keyword\">return</span>;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       <span class=\"keyword\">if</span> (init()) &#123;</span><br><span class=\"line\">           mTargetViewResID = targetViewResID;</span><br><span class=\"line\">           replace(LayoutInflater.from(mSourceView.getContext()).inflate(mTargetViewResID, mSourceParentView, <span class=\"literal\">false</span>));</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">replace</span><span class=\"params\">(View targetView)</span> &#123;</span><br><span class=\"line\">       <span class=\"keyword\">if</span> (mCurrentView == targetView) &#123;</span><br><span class=\"line\">           <span class=\"keyword\">return</span>;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       <span class=\"keyword\">if</span> (targetView.getParent() != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">           ((ViewGroup) targetView.getParent()).removeView(targetView);</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       <span class=\"keyword\">if</span> (init()) &#123;</span><br><span class=\"line\">           mTargetView = targetView;</span><br><span class=\"line\">           mSourceParentView.removeView(mCurrentView);</span><br><span class=\"line\">           mTargetView.setId(mSourceViewId);</span><br><span class=\"line\">           mSourceParentView.addView(mTargetView, mSourceViewIndexInParent, mSourceViewLayoutParams);</span><br><span class=\"line\">           mCurrentView = mTargetView;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n\n<p>在执行添加到目标View的父布局中，有执行一个init方法，主要做两件事：</p>\n<p> <strong>1. 获取目标View的父View<br> 2. 找到目标View在父View 中的位置索引，为之后添加骨架屏View到父View中做铺垫</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"type\">boolean</span> <span class=\"title function_\">init</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">     <span class=\"keyword\">if</span> (mSourceParentView == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">         mSourceParentView = (ViewGroup) mSourceView.getParent();</span><br><span class=\"line\">         <span class=\"keyword\">if</span> (mSourceParentView == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">             Log.e(TAG, <span class=\"string\">&quot;the source view have not attach to any view&quot;</span>);</span><br><span class=\"line\">             <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">         <span class=\"type\">int</span> <span class=\"variable\">count</span> <span class=\"operator\">=</span> mSourceParentView.getChildCount();</span><br><span class=\"line\">         <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">index</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; index &lt; count; index++) &#123;</span><br><span class=\"line\">             <span class=\"keyword\">if</span> (mSourceView == mSourceParentView.getChildAt(index)) &#123;</span><br><span class=\"line\">                 mSourceViewIndexInParent = index;</span><br><span class=\"line\">                 <span class=\"keyword\">break</span>;</span><br><span class=\"line\">             &#125;</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">     <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n<p>至此对普通View的骨架屏效果实现流程已经完全梳理完成，那对于<code>RecyclerView</code>呢？其实两者实现逻辑差不多，主要有两个差异：</p>\n<ol>\n<li>在<code>RecyclerViewSkeletonScreen</code>的Builder中，相比ViewSkeletonScreen多了一个adapter()方法，传入目标<code>RecyclerView</code>的<code>Adapter</code></li>\n<li>在show的时候对目标<code>RecyclerView</code>的adapter进行替换，使用骨架屏效果的adapter。hide的时候恢复为原先的Adapter</li>\n</ol>\n<h2 id=\"3、总结\"><a href=\"#3、总结\" class=\"headerlink\" title=\"3、总结\"></a>3、总结</h2><ol>\n<li>Skeleton的原理主要是通过替换目标View和RecyclerView的Adapter</li>\n<li>在Skeleton的使用过程中最需要关心的两个问题是：show()和hide()的时机</li>\n<li>对于整个页面的骨架屏效果实现，个人推荐在布局中添加一个全屏的空View盖在原先内容上</li>\n<li>注意一些异常情况下的hide()，要不然整个页面就“假死”状态了。</li>\n</ol>\n<p>参考：<br><a href=\"https://juejin.im/post/5c789a4ce51d457c042d3b31\">https://juejin.im/post/5c789a4ce51d457c042d3b31</a></p>\n","categories":[{"name":"技术文章","slug":"technology","api":"api/categories/technology.json"}],"tags":[{"name":"Android","slug":"Android","api":"api/tags/Android.json"}],"api":"api/posts/2019/09/04/Android骨架屏效果的实现与原理解析.json"}],"info":{"type":"archive","year":2019,"month":9}},"api":"api/archives/2019/09/page.1.json"}