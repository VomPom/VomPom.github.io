{"data":{"index":1,"total":1,"posts":[{"title":"忙碌中求生活-记录23岁生日","slug":"★省★忙碌中求生活","date":"2019-07-13T11:36:00.000Z","updated":"2025-05-20T11:46:57.000Z","comments":true,"url":"2019/07/13/★省★忙碌中求生活/","excerpt":"<p>此时周六晚七点半，刚吃了一碗自己做的番茄鸡蛋面，将浸泡了很久的银耳原料装入了电饭煲内，静待熟时。回到自己的房间，窗外不断传来来往的车轱辘声，好像在告诉我他们很忙吧。看到书桌上的日历，还沉浸在六月份，我可能也很忙吧，都忘记将它带入七月份。</p>\n<p>来杭州一年有余，从一名大三学生暑假实习，到大四学生实习，再到应届毕业生签订转正合同，从而成为一名正式的“社会人儿”。时间过得真的很快吧，一周周一下子就没有了。进入了七月份，明显感觉比之前更忙了，或者说是因为自己身份的转变，导致肩上的责任变得不太一样了吧。因为工作节奏的改变，有时候也变得有些麻木吧，日记有时候总会忘记写，写字这件事感觉也变得有些奢侈起来，日语学习的节奏好像变得慢了起来。但是时间的脚步并不因为你的忙碌而停下来。</p>\n<p>我最近在读《时间简史》，讲述了从认知革命到农业革命再到人类文化的融合统一再到科学革命，作者用通俗的话语讲完了整个人类历史，真的很值得阅读。其中有一章节引发了我的思考，作者认为：农业革命是史上最大的骗局。因为在长达250万里里人类都靠狩猎或者采集果实为生，而到大约一万年前全然改变，从日升到日落，人类忙着对植物的培育，一心认为这样就能得到更多的水果、谷物和肉类，使得人类生活能够变得更加容易。然而事实上是人变得越来越辛苦。人类每次决定多做一点事情（比如用锄头来耕地，而不是直接将种子撒在地里面），我们认为这样没错，这样会使我们的收成更好一点，有了更好的收成，就不用更多地去担心荒年的问题了，不用挨饿了。工作努力一点，生活也能过得好一点。不过这都是理想的状态。</p>\n<p>人们确实工作得更努力也更辛苦，但没想到大家的孩子也更多了，人口慢慢地增加了，所得到的食物也就变得少了，生存压力也就更大了，资源也开始变得稀缺，而引发各种低问题。可是为什么他们不赶快放弃农耕回到原始的采集社会？原因在于，所有的改变都是必须点滴积累，经过许多代，才能改变社会，等到那个时候，已经没有人记得过去的生活方式和现在有什么不一样了，也没得选了。采用了农耕生活，村落的人口从100人到了110人，难道会有10个人自愿挨饿，好让其他人回到过去的美好时光？但这已经无法回头。于是人类付出了更多，但得到的却变得没有以前那样多。</p>\n<p>我们都各自为生活变得轻松而努力，但是事实上我们过得并不轻松。人的欲望永远也满足不了，今天拥有了这个，明天还想拥有更好的。现在，我们随手可以发送一条信息，传到地球另一方，而他立马能够回你。我们确实省下了很多时间和麻烦，但生活真的更轻松了么？我们以为省了时间，然而我们其实是把生活的步调调成了过去的10倍，于是我们整天忙忙碌碌、焦躁不安。</p>\n<p>这是原书作者对农业革命是史上最大的骗局的论证吧，我再赞同不过了。每每与我的爸妈打电话，我都会有很大的感触，他们总是在忙碌，他们每天都在拼命的挣钱，可是日子真的好起来了么？生活真的轻松了么？不久前，在家族微信群里面，我妈拍了一张我爸的照片放在群里，我爸双手背后，露出一脸笑意，背景好像是他们住那里的一个普通的建筑吧。想表现出: 你看我和你妈在玩，我们多开心啊。 当我看到这张照片的时候，我心里五谷杂粮。</p>\n<p>一方面是 我看到我爸的头发，愈发的白了，白了大多半了。记得上一次有这感触的时候，还是我大二的时候，那次我从学校回家，他到车站来接我，我坐他后面，我发现他的白头已经有很多很多了，那时我差点哭了出来。爸妈真的老了，可我还没有给他们带来好的生活，我曾告诉他们说：等我实习你们就回家吧，不要工作了，我能养活我自己，以后也能养活你们。可是他们并不，他们还是在工作，烈日下，每每打电话跟我说太阳是有多么多大温度是有多么高，我心里都很难受。可是他们总会说一句话：“这都是为了你以后更轻松一点”。此时我却不知道该说些什么。</p>\n<p>另一方面是 我看着我妈拍的那张照片，真的很糊，不是我妈不会拍照，也不是她眼神不好，真的是她的手机像素不好。我的爸妈，辛苦了大半辈子，其实也有很多积蓄了，虽然没有大城市里的那样多，但在老家里也算是稍微有一些钱的，可是他们却舍不得给自己多花一分钱，能将就用则用。每次电话，我都给他们讲让他们对自己好一点，我说 你们到底挣钱是为了做什么？给他们讲了很多道理，可是他们也总是会一句：“这都是为了你以后更轻松一点”。而我也只能强忍着，因为我现在还没有足够的能力，心里暗暗发誓：我会让他们过上轻松地日子。</p>\n<p>我其实一直都在思考一个问题：人到底活在这个世界上是为了什么？科学家无法解释，这是一个哲学问题，没有人知道正确的答案。我们只是沧海中的一粟，如果掀不起波浪，那么就好好感受海的浩瀚吧。忙忙碌碌，短视频以及直播的崛起，可能真的是因为都市生活节奏变得太快，于是都在夹缝中去寻找那一丝丝快感，其实可以做的很多吧，摘自网上“试着每天自己为自己做美味的饭菜，试着经常联络一下家人好友，试着拾起丢下很久的小说，试着用心养一颗植物，试着在空气清新的清晨去跑步，试着约一下自己暗恋已久的女孩…”。看看足球比赛，看看电影，多出去走走，再忙也不要忘记生活吧。</p>\n<p>快九点了，删删写写，也不道该放一些什么在日志上，那就这样吧。<br>祝自己二十三岁生日快乐 </p>\n<p>记录两张此时自己二十三岁的照片，没出门没刮胡子没收拾，一张沧桑一张微笑，生活亦如此吧。</p>\n<p>xxx.jpg</p>\n<p>—-二零一九年六月十一</p>\n","cover":null,"images":[],"content":"<p>此时周六晚七点半，刚吃了一碗自己做的番茄鸡蛋面，将浸泡了很久的银耳原料装入了电饭煲内，静待熟时。回到自己的房间，窗外不断传来来往的车轱辘声，好像在告诉我他们很忙吧。看到书桌上的日历，还沉浸在六月份，我可能也很忙吧，都忘记将它带入七月份。</p>\n<p>来杭州一年有余，从一名大三学生暑假实习，到大四学生实习，再到应届毕业生签订转正合同，从而成为一名正式的“社会人儿”。时间过得真的很快吧，一周周一下子就没有了。进入了七月份，明显感觉比之前更忙了，或者说是因为自己身份的转变，导致肩上的责任变得不太一样了吧。因为工作节奏的改变，有时候也变得有些麻木吧，日记有时候总会忘记写，写字这件事感觉也变得有些奢侈起来，日语学习的节奏好像变得慢了起来。但是时间的脚步并不因为你的忙碌而停下来。</p>\n<p>我最近在读《时间简史》，讲述了从认知革命到农业革命再到人类文化的融合统一再到科学革命，作者用通俗的话语讲完了整个人类历史，真的很值得阅读。其中有一章节引发了我的思考，作者认为：农业革命是史上最大的骗局。因为在长达250万里里人类都靠狩猎或者采集果实为生，而到大约一万年前全然改变，从日升到日落，人类忙着对植物的培育，一心认为这样就能得到更多的水果、谷物和肉类，使得人类生活能够变得更加容易。然而事实上是人变得越来越辛苦。人类每次决定多做一点事情（比如用锄头来耕地，而不是直接将种子撒在地里面），我们认为这样没错，这样会使我们的收成更好一点，有了更好的收成，就不用更多地去担心荒年的问题了，不用挨饿了。工作努力一点，生活也能过得好一点。不过这都是理想的状态。</p>\n<p>人们确实工作得更努力也更辛苦，但没想到大家的孩子也更多了，人口慢慢地增加了，所得到的食物也就变得少了，生存压力也就更大了，资源也开始变得稀缺，而引发各种低问题。可是为什么他们不赶快放弃农耕回到原始的采集社会？原因在于，所有的改变都是必须点滴积累，经过许多代，才能改变社会，等到那个时候，已经没有人记得过去的生活方式和现在有什么不一样了，也没得选了。采用了农耕生活，村落的人口从100人到了110人，难道会有10个人自愿挨饿，好让其他人回到过去的美好时光？但这已经无法回头。于是人类付出了更多，但得到的却变得没有以前那样多。</p>\n<p>我们都各自为生活变得轻松而努力，但是事实上我们过得并不轻松。人的欲望永远也满足不了，今天拥有了这个，明天还想拥有更好的。现在，我们随手可以发送一条信息，传到地球另一方，而他立马能够回你。我们确实省下了很多时间和麻烦，但生活真的更轻松了么？我们以为省了时间，然而我们其实是把生活的步调调成了过去的10倍，于是我们整天忙忙碌碌、焦躁不安。</p>\n<p>这是原书作者对农业革命是史上最大的骗局的论证吧，我再赞同不过了。每每与我的爸妈打电话，我都会有很大的感触，他们总是在忙碌，他们每天都在拼命的挣钱，可是日子真的好起来了么？生活真的轻松了么？不久前，在家族微信群里面，我妈拍了一张我爸的照片放在群里，我爸双手背后，露出一脸笑意，背景好像是他们住那里的一个普通的建筑吧。想表现出: 你看我和你妈在玩，我们多开心啊。 当我看到这张照片的时候，我心里五谷杂粮。</p>\n<p>一方面是 我看到我爸的头发，愈发的白了，白了大多半了。记得上一次有这感触的时候，还是我大二的时候，那次我从学校回家，他到车站来接我，我坐他后面，我发现他的白头已经有很多很多了，那时我差点哭了出来。爸妈真的老了，可我还没有给他们带来好的生活，我曾告诉他们说：等我实习你们就回家吧，不要工作了，我能养活我自己，以后也能养活你们。可是他们并不，他们还是在工作，烈日下，每每打电话跟我说太阳是有多么多大温度是有多么高，我心里都很难受。可是他们总会说一句话：“这都是为了你以后更轻松一点”。此时我却不知道该说些什么。</p>\n<p>另一方面是 我看着我妈拍的那张照片，真的很糊，不是我妈不会拍照，也不是她眼神不好，真的是她的手机像素不好。我的爸妈，辛苦了大半辈子，其实也有很多积蓄了，虽然没有大城市里的那样多，但在老家里也算是稍微有一些钱的，可是他们却舍不得给自己多花一分钱，能将就用则用。每次电话，我都给他们讲让他们对自己好一点，我说 你们到底挣钱是为了做什么？给他们讲了很多道理，可是他们也总是会一句：“这都是为了你以后更轻松一点”。而我也只能强忍着，因为我现在还没有足够的能力，心里暗暗发誓：我会让他们过上轻松地日子。</p>\n<p>我其实一直都在思考一个问题：人到底活在这个世界上是为了什么？科学家无法解释，这是一个哲学问题，没有人知道正确的答案。我们只是沧海中的一粟，如果掀不起波浪，那么就好好感受海的浩瀚吧。忙忙碌碌，短视频以及直播的崛起，可能真的是因为都市生活节奏变得太快，于是都在夹缝中去寻找那一丝丝快感，其实可以做的很多吧，摘自网上“试着每天自己为自己做美味的饭菜，试着经常联络一下家人好友，试着拾起丢下很久的小说，试着用心养一颗植物，试着在空气清新的清晨去跑步，试着约一下自己暗恋已久的女孩…”。看看足球比赛，看看电影，多出去走走，再忙也不要忘记生活吧。</p>\n<p>快九点了，删删写写，也不道该放一些什么在日志上，那就这样吧。<br>祝自己二十三岁生日快乐 </p>\n<p>记录两张此时自己二十三岁的照片，没出门没刮胡子没收拾，一张沧桑一张微笑，生活亦如此吧。</p>\n<p>xxx.jpg</p>\n<p>—-二零一九年六月十一</p>\n","categories":[{"name":"生活感想","slug":"life","api":"api/categories/life.json"}],"tags":[{"name":"生活","slug":"life","api":"api/tags/life.json"}],"api":"api/posts/2019/07/13/★省★忙碌中求生活.json"},{"title":"单例模式的设计","slug":"单例模式的设计","date":"2019-07-09T01:56:00.000Z","updated":"2025-05-20T11:46:57.000Z","comments":true,"url":"2019/07/09/单例模式的设计/","excerpt":"<p>原文回答于知乎(<a href=\"https://www.zhihu.com/question/277243683/answer/392772061\">如何把一段简单的代码变复杂？ - 落叶挽歌的回答</a>)</p>\n<p>我们都知道单例模式很简单，大概是这样：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//单线程单例模式实现</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Singleton</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Singleton instance=<span class=\"literal\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Singleton <span class=\"title function_\">getInstance</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(<span class=\"literal\">null</span>==instance)&#123;</span><br><span class=\"line\">            instance = <span class=\"keyword\">new</span> <span class=\"title class_\">Singleton</span>();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>但是呢，在多线程条件下getInstance()并不是一个原子操作。由于代码没有使用任何同步机制，因此该线程可能会出现线程交错的情形：在instance还是null的时候，如果两个线程同时执行到 if(null&#x3D;&#x3D;instance)那么会创建两个实例，从而违背了初衷。于是通过简单加锁来解决这种问题：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//简单加锁实现单例模式</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Singleton</span>  &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Singleton instance=<span class=\"literal\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Singleton <span class=\"title function_\">getInstance</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span> (Singleton.class)&#123;<span class=\"comment\">//加入synchronized同步</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(<span class=\"literal\">null</span>==instance)&#123;</span><br><span class=\"line\">                instance = <span class=\"keyword\">new</span> <span class=\"title class_\">Singleton</span>();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这种方式实现单例模式固然安全，但意味着每次调用 getInstance()都会申请锁，为了避免开销，我们想到了另一种办法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//基于双重检查锁定的错误单例模式实现</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Singleton</span>  &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Singleton instance=<span class=\"literal\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Singleton <span class=\"title function_\">getInstance</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(<span class=\"literal\">null</span>==instance)&#123;<span class=\"comment\">//先检查是否为null，再执行之上的代码</span></span><br><span class=\"line\">            <span class=\"keyword\">synchronized</span> (Singleton.class)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(<span class=\"literal\">null</span>==instance)&#123;</span><br><span class=\"line\">                    instance = <span class=\"keyword\">new</span> <span class=\"title class_\">Singleton</span>();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>通过这种方法，虽然第一次检查对变量instance的访问没有加锁从而使竞态仍然可能存在，它似乎避免了锁的开销又保障了线程的安全。然后对 instance &#x3D; new Singleton();进行伪代码独立子操作：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">obj=allocate(Singleton.class);<span class=\"comment\">//1、分配对象所需的存储空间</span></span><br><span class=\"line\">invokeConstructor(obj);<span class=\"comment\">//2、初始化obj的引用对象</span></span><br><span class=\"line\">instance=obj;<span class=\"comment\">//3、将对象引用写入共享变量</span></span><br></pre></td></tr></table></figure>\n<p>由于重排序的规则，临界区内的操作可以再临界区内重排序，因此JIT编译器可能将上述子操作重排序为：1-&gt;3-&gt;2，即在初始化对象之前将对象引用写入实例变量instace。由于锁对有序性的保障是有条件的，而操作1读取intance变量的时候并没有加锁，因此重排序是对1操作是有影响的：该线程可能看到一个未初始化（或者为初始化完毕）的实例，即intance不为null。于是该线程直接就直接返回这个instance变量所引用的实例，而实例可能是未初始化完毕的，这就是可能导致程序出错。明白问题的原因之后，解决方法也不难想到了：<strong>只需将instance变量加入volatile修饰则可</strong>。于是代码变成：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//基于双重检查锁定的正确单例模式实现</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Singleton</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">volatile</span> Singleton instance=<span class=\"literal\">null</span>;<span class=\"comment\">//加入volatile修饰</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Singleton <span class=\"title function_\">getInstance</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(<span class=\"literal\">null</span>==instance)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">synchronized</span> (Singleton.class)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(<span class=\"literal\">null</span>==instance)&#123;</span><br><span class=\"line\">                    instance = <span class=\"keyword\">new</span> <span class=\"title class_\">Singleton</span>();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>到此为止，才正确实现安全的“单例模式”。</p>\n<p>参考：《黄文海-Java多线程编程实战指南（核心篇）》</p>\n","cover":null,"images":[],"content":"<p>原文回答于知乎(<a href=\"https://www.zhihu.com/question/277243683/answer/392772061\">如何把一段简单的代码变复杂？ - 落叶挽歌的回答</a>)</p>\n<p>我们都知道单例模式很简单，大概是这样：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//单线程单例模式实现</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Singleton</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Singleton instance=<span class=\"literal\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Singleton <span class=\"title function_\">getInstance</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(<span class=\"literal\">null</span>==instance)&#123;</span><br><span class=\"line\">            instance = <span class=\"keyword\">new</span> <span class=\"title class_\">Singleton</span>();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>但是呢，在多线程条件下getInstance()并不是一个原子操作。由于代码没有使用任何同步机制，因此该线程可能会出现线程交错的情形：在instance还是null的时候，如果两个线程同时执行到 if(null&#x3D;&#x3D;instance)那么会创建两个实例，从而违背了初衷。于是通过简单加锁来解决这种问题：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//简单加锁实现单例模式</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Singleton</span>  &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Singleton instance=<span class=\"literal\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Singleton <span class=\"title function_\">getInstance</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span> (Singleton.class)&#123;<span class=\"comment\">//加入synchronized同步</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(<span class=\"literal\">null</span>==instance)&#123;</span><br><span class=\"line\">                instance = <span class=\"keyword\">new</span> <span class=\"title class_\">Singleton</span>();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这种方式实现单例模式固然安全，但意味着每次调用 getInstance()都会申请锁，为了避免开销，我们想到了另一种办法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//基于双重检查锁定的错误单例模式实现</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Singleton</span>  &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Singleton instance=<span class=\"literal\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Singleton <span class=\"title function_\">getInstance</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(<span class=\"literal\">null</span>==instance)&#123;<span class=\"comment\">//先检查是否为null，再执行之上的代码</span></span><br><span class=\"line\">            <span class=\"keyword\">synchronized</span> (Singleton.class)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(<span class=\"literal\">null</span>==instance)&#123;</span><br><span class=\"line\">                    instance = <span class=\"keyword\">new</span> <span class=\"title class_\">Singleton</span>();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>通过这种方法，虽然第一次检查对变量instance的访问没有加锁从而使竞态仍然可能存在，它似乎避免了锁的开销又保障了线程的安全。然后对 instance &#x3D; new Singleton();进行伪代码独立子操作：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">obj=allocate(Singleton.class);<span class=\"comment\">//1、分配对象所需的存储空间</span></span><br><span class=\"line\">invokeConstructor(obj);<span class=\"comment\">//2、初始化obj的引用对象</span></span><br><span class=\"line\">instance=obj;<span class=\"comment\">//3、将对象引用写入共享变量</span></span><br></pre></td></tr></table></figure>\n<p>由于重排序的规则，临界区内的操作可以再临界区内重排序，因此JIT编译器可能将上述子操作重排序为：1-&gt;3-&gt;2，即在初始化对象之前将对象引用写入实例变量instace。由于锁对有序性的保障是有条件的，而操作1读取intance变量的时候并没有加锁，因此重排序是对1操作是有影响的：该线程可能看到一个未初始化（或者为初始化完毕）的实例，即intance不为null。于是该线程直接就直接返回这个instance变量所引用的实例，而实例可能是未初始化完毕的，这就是可能导致程序出错。明白问题的原因之后，解决方法也不难想到了：<strong>只需将instance变量加入volatile修饰则可</strong>。于是代码变成：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//基于双重检查锁定的正确单例模式实现</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Singleton</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">volatile</span> Singleton instance=<span class=\"literal\">null</span>;<span class=\"comment\">//加入volatile修饰</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Singleton <span class=\"title function_\">getInstance</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(<span class=\"literal\">null</span>==instance)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">synchronized</span> (Singleton.class)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(<span class=\"literal\">null</span>==instance)&#123;</span><br><span class=\"line\">                    instance = <span class=\"keyword\">new</span> <span class=\"title class_\">Singleton</span>();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>到此为止，才正确实现安全的“单例模式”。</p>\n<p>参考：《黄文海-Java多线程编程实战指南（核心篇）》</p>\n","categories":[{"name":"技术文章","slug":"technology","api":"api/categories/technology.json"}],"tags":[{"name":"设计模式","slug":"design","api":"api/tags/design.json"}],"api":"api/posts/2019/07/09/单例模式的设计.json"},{"title":"Android监听截屏事件之媒体读取的探索","slug":"Android监听截屏事件之媒体读取的探索","date":"2019-07-02T09:58:00.000Z","updated":"2025-05-20T11:46:57.000Z","comments":true,"url":"2019/07/02/Android监听截屏事件之媒体读取的探索/","excerpt":"<p>最近做了一个需求：监听用户截屏，然后生成相关海报。<br>参考了<a href=\"https://blog.csdn.net/xietansheng/article/details/52692163\" title=\"Android 截屏事件监听\">Android 截屏事件监听</a>的文章，大致思路是：</p>\n<p>1、利用ContentObserver用来监听指定Uri的所有资源变化,当媒体库中有相关图片新增的时候，则发送相关的通知。</p>\n<p>2、得到回调的Uri后，借助ContentResolver在媒体数据库中查询最后一条数据</p>\n<p>3、对数据做一些过滤。比如短时间重复截屏的情况以及其他App也插入了媒体文件等情况做处理。</p>\n<p>不过有一些适配性的问题：</p>\n<p>1、截屏后读取文件数据库后获取到件的绝对路径后，利用“screenshot”等关键字判断是否是截屏图片，并不能适配所有手机截屏的命名规则，以及其他应用同时间产生带有“screenshot”等关键词的文件也会有问题。</p>\n<p>2、在某些型号手机中(现遇到Vivo)从数据库中读取的文件并不是获取到的最新的截屏文件，而且其他目录的文件，这里就有些难以理解了，所以今天取探究一下媒体数据库的读取。</p>\n<p>其中ContentObserver如下代码所示：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">   * 媒体内容观察者(观察媒体数据库的改变)</span></span><br><span class=\"line\"><span class=\"comment\">   */</span></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">class</span> <span class=\"title class_\">MediaContentObserver</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">ContentObserver</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">private</span> Uri mContentUri;</span><br><span class=\"line\">      <span class=\"keyword\">public</span> <span class=\"title function_\">MediaContentObserver</span><span class=\"params\">(Uri contentUri, Handler handler)</span> &#123;</span><br><span class=\"line\">          <span class=\"built_in\">super</span>(handler);</span><br><span class=\"line\">          mContentUri = contentUri;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      [<span class=\"meta\">@Override</span>](https:<span class=\"comment\">//my.oschina.net/u/1162528)</span></span><br><span class=\"line\">      <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">onChange</span><span class=\"params\">(<span class=\"type\">boolean</span> selfChange)</span> &#123;</span><br><span class=\"line\">          <span class=\"built_in\">super</span>.onChange(selfChange);</span><br><span class=\"line\">          handleMediaContentChange(mContentUri);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<p>其中获取最后一次更新的媒体文件时的代码(为便于查看 删除了判空处理代码)：<br> <figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">\t<span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">    * 处理媒体数据库的内容改变</span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">   <span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">handleMediaContentChange</span><span class=\"params\">(Uri contentUri)</span> &#123;</span><br><span class=\"line\">       <span class=\"type\">Cursor</span> <span class=\"variable\">cursor</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">       <span class=\"comment\">/** 读取媒体数据库时需要读取的列 */</span></span><br><span class=\"line\">       <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String[] MEDIA_PROJECTIONS =  &#123;</span><br><span class=\"line\">           MediaStore.Images.ImageColumns.DATA,</span><br><span class=\"line\">           MediaStore.Images.ImageColumns.DATE_TAKEN &#125;;</span><br><span class=\"line\">       <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">           <span class=\"comment\">// 数据改变时查询数据库中最后加入的一条数据</span></span><br><span class=\"line\">           cursor = mContext.getContentResolver().query(</span><br><span class=\"line\">                   contentUri,</span><br><span class=\"line\">                    MEDIA_PROJECTIONS,</span><br><span class=\"line\">                   <span class=\"literal\">null</span>,</span><br><span class=\"line\">                   <span class=\"literal\">null</span>,</span><br><span class=\"line\">                   MediaStore.Images.ImageColumns.DATE_ADDED + <span class=\"string\">&quot; desc limit 1&quot;</span></span><br><span class=\"line\">           );</span><br><span class=\"line\">           <span class=\"comment\">// 获取各列的索引</span></span><br><span class=\"line\">           <span class=\"type\">int</span> <span class=\"variable\">dataIndex</span> <span class=\"operator\">=</span> cursor.getColumnIndex(MediaStore.Images.ImageColumns.DATA);</span><br><span class=\"line\">           <span class=\"type\">int</span> <span class=\"variable\">dateTakenIndex</span> <span class=\"operator\">=</span> cursor.getColumnIndex(MediaStore.Images.ImageColumns.DATE_TAKEN);</span><br><span class=\"line\"></span><br><span class=\"line\">           <span class=\"comment\">// 获取行数据</span></span><br><span class=\"line\">           <span class=\"type\">String</span> <span class=\"variable\">data</span> <span class=\"operator\">=</span> cursor.getString(dataIndex);</span><br><span class=\"line\">           <span class=\"type\">long</span> <span class=\"variable\">dateTaken</span> <span class=\"operator\">=</span> cursor.getLong(dateTakenIndex);</span><br><span class=\"line\"></span><br><span class=\"line\">           <span class=\"comment\">// 处理获取到的第一行数据</span></span><br><span class=\"line\">           handleMediaRowData(data, dateTaken);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>这次的目的主要探究的是从数据库获取相关信息的过程</p>\n<p><strong>1、Android 的多媒体如何存储？</strong></p>\n<p>Android的多媒体文件主要存储在 &#x2F;data&#x2F;data&#x2F;com.android.providers.media&#x2F;databases 目录下，该目录下有连个db文件：</p>\n<p>内部存储数据库文件：internal.db</p>\n<p>存储卡数据库：external-XXXX.db</p>\n<p>媒体文件的操作主要是围绕着这两个数据库来进行，这两个数据库的结构是一样的。</p>\n<p>这两个数据库包含这些表：<br>album_art 、audio 、search 、album_info 、audio_genres、 searchhelpertitle、albums、 audio_genres_map、 thumbnails、<br>android_metadata、 audio_meta、 video、artist_info 、audio_playlists 、videothumbnails、artists 、audio_playlists_map、<br>artists_albums_map 、images</p>\n<p><strong>2、表的结构</strong><br>对于Images表：主要存储images信息。表结构如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">CREATE TABLE <span class=\"title function_\">images</span> <span class=\"params\">(</span></span><br><span class=\"line\"><span class=\"params\">   _id INTEGER PRIMARY KEY, </span></span><br><span class=\"line\"><span class=\"params\">   _data TEXT,</span></span><br><span class=\"line\"><span class=\"params\">   _size INTEGER,</span></span><br><span class=\"line\"><span class=\"params\">   _display_name TEXT,</span></span><br><span class=\"line\"><span class=\"params\">   mime_type TEXT,</span></span><br><span class=\"line\"><span class=\"params\">   title TEXT, </span></span><br><span class=\"line\"><span class=\"params\">   date_added INTEGER, </span></span><br><span class=\"line\"><span class=\"params\">   date_modified INTEGER,</span></span><br><span class=\"line\"><span class=\"params\">   description TEXT,</span></span><br><span class=\"line\"><span class=\"params\">   picasa_id TEXT,</span></span><br><span class=\"line\"><span class=\"params\">   isprivate INTEGER,</span></span><br><span class=\"line\"><span class=\"params\">   latitude DOUBLE, </span></span><br><span class=\"line\"><span class=\"params\">   longitude DOUBLE, </span></span><br><span class=\"line\"><span class=\"params\">   datetaken INTEGER, </span></span><br><span class=\"line\"><span class=\"params\">   orientation INTEGER, </span></span><br><span class=\"line\"><span class=\"params\">   mini_thumb_magic INTEGER, </span></span><br><span class=\"line\"><span class=\"params\">   bucket_id TEXT, </span></span><br><span class=\"line\"><span class=\"params\">   bucket_display_name TEXT )</span>;</span><br></pre></td></tr></table></figure>\n\n<p>各字段所表示意思，如图所示：</p>\n<img src=\"https://cdn.julis.wang/blog/img/2eb1be5d3ece2831fa9ca6d00678bf520a7.jpg\">\n\n<p><em>图片来自：<a href=\"https://blog.csdn.net/love_xsq/article/details/50387747\" title=\"Android MediaProvider数据库模式说明\">Android MediaProvider数据库模式说明</a></em></p>\n<p>所以在截屏监听数据的时候所读取的数据库返回值，分别为：</p>\n<p>_data  :图片据对路径</p>\n<p>datetaken：取子EXIF照片拍摄事件，空的话为文件修改时间</p>\n<pre><code>  private static final String[] MEDIA_PROJECTIONS =  &#123;\n        MediaStore.Images.ImageColumns.DATA,\n        MediaStore.Images.ImageColumns.DATE_TAKEN &#125;;\n</code></pre>\n<p>在查询过程中构造的数据库代码为：</p>\n<pre><code>public final Cursor query (Uri uri, \n\tString[] projection,\n\tString selection, \n\tString[] selectionArgs, \n\tString sortOrder)\n</code></pre>\n<p>&#96;<br>其中对应的构造参数官方解释为：</p>\n<blockquote>\n<p>uri\tThe URI, using the content:&#x2F;&#x2F; scheme, for the content to retrieve.</p>\n</blockquote>\n<blockquote>\n<p>projection\tA list of which columns to return. Passing null will return all columns, which is inefficient.  </p>\n</blockquote>\n<blockquote>\n<p>selection\tA filter declaring which rows to return, formatted as an SQL WHERE clause (excluding the WHERE itself). Passing null will return all rows for the given URI.</p>\n</blockquote>\n<blockquote>\n<p>selectionArgs\tYou may include ?s in selection, which will be replaced by the values from selectionArgs, in the order that they appear in the selection. The values will be bound as Strings.</p>\n</blockquote>\n<blockquote>\n<p>sortOrder\tHow to order the rows, formatted as an SQL ORDER BY clause (excluding the ORDER BY itself). Passing null will use the default sort order, which may be unordered.</p>\n</blockquote>\n<hr>\n<p>所以参数依次为：<br>所要查找的目标、所要的返回值、条件限制(类似sql中where)、匹配项、排序规则</p>\n<p>所以这里的查询就显而易见了：获取最新图片数据库下data和datatoken列的数据</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">cursor = mContext.getContentResolver().query(</span><br><span class=\"line\">                 contentUri,</span><br><span class=\"line\">                 MEDIA_PROJECTIONS,</span><br><span class=\"line\">                 <span class=\"literal\">null</span>,</span><br><span class=\"line\">                 <span class=\"literal\">null</span>,</span><br><span class=\"line\">                 MediaStore.Images.ImageColumns.DATE_ADDED + <span class=\"string\">&quot; desc limit 1&quot;</span></span><br><span class=\"line\">         );</span><br></pre></td></tr></table></figure>\n<p>然而…并不能解释vivo手机为什么查找出来不是最新截图的图片的问题</p>\n","cover":null,"images":["https://cdn.julis.wang/blog/img/2eb1be5d3ece2831fa9ca6d00678bf520a7.jpg"],"content":"<p>最近做了一个需求：监听用户截屏，然后生成相关海报。<br>参考了<a href=\"https://blog.csdn.net/xietansheng/article/details/52692163\" title=\"Android 截屏事件监听\">Android 截屏事件监听</a>的文章，大致思路是：</p>\n<p>1、利用ContentObserver用来监听指定Uri的所有资源变化,当媒体库中有相关图片新增的时候，则发送相关的通知。</p>\n<p>2、得到回调的Uri后，借助ContentResolver在媒体数据库中查询最后一条数据</p>\n<p>3、对数据做一些过滤。比如短时间重复截屏的情况以及其他App也插入了媒体文件等情况做处理。</p>\n<p>不过有一些适配性的问题：</p>\n<p>1、截屏后读取文件数据库后获取到件的绝对路径后，利用“screenshot”等关键字判断是否是截屏图片，并不能适配所有手机截屏的命名规则，以及其他应用同时间产生带有“screenshot”等关键词的文件也会有问题。</p>\n<p>2、在某些型号手机中(现遇到Vivo)从数据库中读取的文件并不是获取到的最新的截屏文件，而且其他目录的文件，这里就有些难以理解了，所以今天取探究一下媒体数据库的读取。</p>\n<p>其中ContentObserver如下代码所示：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">   * 媒体内容观察者(观察媒体数据库的改变)</span></span><br><span class=\"line\"><span class=\"comment\">   */</span></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">class</span> <span class=\"title class_\">MediaContentObserver</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">ContentObserver</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">private</span> Uri mContentUri;</span><br><span class=\"line\">      <span class=\"keyword\">public</span> <span class=\"title function_\">MediaContentObserver</span><span class=\"params\">(Uri contentUri, Handler handler)</span> &#123;</span><br><span class=\"line\">          <span class=\"built_in\">super</span>(handler);</span><br><span class=\"line\">          mContentUri = contentUri;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      [<span class=\"meta\">@Override</span>](https:<span class=\"comment\">//my.oschina.net/u/1162528)</span></span><br><span class=\"line\">      <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">onChange</span><span class=\"params\">(<span class=\"type\">boolean</span> selfChange)</span> &#123;</span><br><span class=\"line\">          <span class=\"built_in\">super</span>.onChange(selfChange);</span><br><span class=\"line\">          handleMediaContentChange(mContentUri);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<p>其中获取最后一次更新的媒体文件时的代码(为便于查看 删除了判空处理代码)：<br> <figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">\t<span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">    * 处理媒体数据库的内容改变</span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">   <span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">handleMediaContentChange</span><span class=\"params\">(Uri contentUri)</span> &#123;</span><br><span class=\"line\">       <span class=\"type\">Cursor</span> <span class=\"variable\">cursor</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">       <span class=\"comment\">/** 读取媒体数据库时需要读取的列 */</span></span><br><span class=\"line\">       <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String[] MEDIA_PROJECTIONS =  &#123;</span><br><span class=\"line\">           MediaStore.Images.ImageColumns.DATA,</span><br><span class=\"line\">           MediaStore.Images.ImageColumns.DATE_TAKEN &#125;;</span><br><span class=\"line\">       <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">           <span class=\"comment\">// 数据改变时查询数据库中最后加入的一条数据</span></span><br><span class=\"line\">           cursor = mContext.getContentResolver().query(</span><br><span class=\"line\">                   contentUri,</span><br><span class=\"line\">                    MEDIA_PROJECTIONS,</span><br><span class=\"line\">                   <span class=\"literal\">null</span>,</span><br><span class=\"line\">                   <span class=\"literal\">null</span>,</span><br><span class=\"line\">                   MediaStore.Images.ImageColumns.DATE_ADDED + <span class=\"string\">&quot; desc limit 1&quot;</span></span><br><span class=\"line\">           );</span><br><span class=\"line\">           <span class=\"comment\">// 获取各列的索引</span></span><br><span class=\"line\">           <span class=\"type\">int</span> <span class=\"variable\">dataIndex</span> <span class=\"operator\">=</span> cursor.getColumnIndex(MediaStore.Images.ImageColumns.DATA);</span><br><span class=\"line\">           <span class=\"type\">int</span> <span class=\"variable\">dateTakenIndex</span> <span class=\"operator\">=</span> cursor.getColumnIndex(MediaStore.Images.ImageColumns.DATE_TAKEN);</span><br><span class=\"line\"></span><br><span class=\"line\">           <span class=\"comment\">// 获取行数据</span></span><br><span class=\"line\">           <span class=\"type\">String</span> <span class=\"variable\">data</span> <span class=\"operator\">=</span> cursor.getString(dataIndex);</span><br><span class=\"line\">           <span class=\"type\">long</span> <span class=\"variable\">dateTaken</span> <span class=\"operator\">=</span> cursor.getLong(dateTakenIndex);</span><br><span class=\"line\"></span><br><span class=\"line\">           <span class=\"comment\">// 处理获取到的第一行数据</span></span><br><span class=\"line\">           handleMediaRowData(data, dateTaken);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>这次的目的主要探究的是从数据库获取相关信息的过程</p>\n<p><strong>1、Android 的多媒体如何存储？</strong></p>\n<p>Android的多媒体文件主要存储在 &#x2F;data&#x2F;data&#x2F;com.android.providers.media&#x2F;databases 目录下，该目录下有连个db文件：</p>\n<p>内部存储数据库文件：internal.db</p>\n<p>存储卡数据库：external-XXXX.db</p>\n<p>媒体文件的操作主要是围绕着这两个数据库来进行，这两个数据库的结构是一样的。</p>\n<p>这两个数据库包含这些表：<br>album_art 、audio 、search 、album_info 、audio_genres、 searchhelpertitle、albums、 audio_genres_map、 thumbnails、<br>android_metadata、 audio_meta、 video、artist_info 、audio_playlists 、videothumbnails、artists 、audio_playlists_map、<br>artists_albums_map 、images</p>\n<p><strong>2、表的结构</strong><br>对于Images表：主要存储images信息。表结构如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">CREATE TABLE <span class=\"title function_\">images</span> <span class=\"params\">(</span></span><br><span class=\"line\"><span class=\"params\">   _id INTEGER PRIMARY KEY, </span></span><br><span class=\"line\"><span class=\"params\">   _data TEXT,</span></span><br><span class=\"line\"><span class=\"params\">   _size INTEGER,</span></span><br><span class=\"line\"><span class=\"params\">   _display_name TEXT,</span></span><br><span class=\"line\"><span class=\"params\">   mime_type TEXT,</span></span><br><span class=\"line\"><span class=\"params\">   title TEXT, </span></span><br><span class=\"line\"><span class=\"params\">   date_added INTEGER, </span></span><br><span class=\"line\"><span class=\"params\">   date_modified INTEGER,</span></span><br><span class=\"line\"><span class=\"params\">   description TEXT,</span></span><br><span class=\"line\"><span class=\"params\">   picasa_id TEXT,</span></span><br><span class=\"line\"><span class=\"params\">   isprivate INTEGER,</span></span><br><span class=\"line\"><span class=\"params\">   latitude DOUBLE, </span></span><br><span class=\"line\"><span class=\"params\">   longitude DOUBLE, </span></span><br><span class=\"line\"><span class=\"params\">   datetaken INTEGER, </span></span><br><span class=\"line\"><span class=\"params\">   orientation INTEGER, </span></span><br><span class=\"line\"><span class=\"params\">   mini_thumb_magic INTEGER, </span></span><br><span class=\"line\"><span class=\"params\">   bucket_id TEXT, </span></span><br><span class=\"line\"><span class=\"params\">   bucket_display_name TEXT )</span>;</span><br></pre></td></tr></table></figure>\n\n<p>各字段所表示意思，如图所示：</p>\n<img src=\"https://cdn.julis.wang/blog/img/2eb1be5d3ece2831fa9ca6d00678bf520a7.jpg\">\n\n<p><em>图片来自：<a href=\"https://blog.csdn.net/love_xsq/article/details/50387747\" title=\"Android MediaProvider数据库模式说明\">Android MediaProvider数据库模式说明</a></em></p>\n<p>所以在截屏监听数据的时候所读取的数据库返回值，分别为：</p>\n<p>_data  :图片据对路径</p>\n<p>datetaken：取子EXIF照片拍摄事件，空的话为文件修改时间</p>\n<pre><code>  private static final String[] MEDIA_PROJECTIONS =  &#123;\n        MediaStore.Images.ImageColumns.DATA,\n        MediaStore.Images.ImageColumns.DATE_TAKEN &#125;;\n</code></pre>\n<p>在查询过程中构造的数据库代码为：</p>\n<pre><code>public final Cursor query (Uri uri, \n\tString[] projection,\n\tString selection, \n\tString[] selectionArgs, \n\tString sortOrder)\n</code></pre>\n<p>&#96;<br>其中对应的构造参数官方解释为：</p>\n<blockquote>\n<p>uri\tThe URI, using the content:&#x2F;&#x2F; scheme, for the content to retrieve.</p>\n</blockquote>\n<blockquote>\n<p>projection\tA list of which columns to return. Passing null will return all columns, which is inefficient.  </p>\n</blockquote>\n<blockquote>\n<p>selection\tA filter declaring which rows to return, formatted as an SQL WHERE clause (excluding the WHERE itself). Passing null will return all rows for the given URI.</p>\n</blockquote>\n<blockquote>\n<p>selectionArgs\tYou may include ?s in selection, which will be replaced by the values from selectionArgs, in the order that they appear in the selection. The values will be bound as Strings.</p>\n</blockquote>\n<blockquote>\n<p>sortOrder\tHow to order the rows, formatted as an SQL ORDER BY clause (excluding the ORDER BY itself). Passing null will use the default sort order, which may be unordered.</p>\n</blockquote>\n<hr>\n<p>所以参数依次为：<br>所要查找的目标、所要的返回值、条件限制(类似sql中where)、匹配项、排序规则</p>\n<p>所以这里的查询就显而易见了：获取最新图片数据库下data和datatoken列的数据</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">cursor = mContext.getContentResolver().query(</span><br><span class=\"line\">                 contentUri,</span><br><span class=\"line\">                 MEDIA_PROJECTIONS,</span><br><span class=\"line\">                 <span class=\"literal\">null</span>,</span><br><span class=\"line\">                 <span class=\"literal\">null</span>,</span><br><span class=\"line\">                 MediaStore.Images.ImageColumns.DATE_ADDED + <span class=\"string\">&quot; desc limit 1&quot;</span></span><br><span class=\"line\">         );</span><br></pre></td></tr></table></figure>\n<p>然而…并不能解释vivo手机为什么查找出来不是最新截图的图片的问题</p>\n","categories":[{"name":"技术文章","slug":"technology","api":"api/categories/technology.json"}],"tags":[{"name":"安卓","slug":"Android","api":"api/tags/Android.json"}],"api":"api/posts/2019/07/02/Android监听截屏事件之媒体读取的探索.json"}],"info":{"type":"archive","year":2019,"month":7}},"api":"api/archives/2019/07/page.1.json"}