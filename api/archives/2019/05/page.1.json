{"data":{"index":1,"total":1,"posts":[{"title":"95后，毕业半年，你过得好吗？","slug":"95后的你们毕业半年过得还好么？","date":"2019-05-20T01:42:00.000Z","updated":"2025-05-20T11:46:57.000Z","comments":true,"url":"2019/05/20/95后的你们毕业半年过得还好么？/","excerpt":"<p>原帖：<a href=\"https://www.zhihu.com/question/307640916/answer/686748493\">https://www.zhihu.com/question/307640916/answer/686748493</a><br>95后，毕业半年，你过得好吗？<br>亲爱的95后，毕业两年，你过得怎么样了？充实或是空虚，甜蜜还是苦涩，热爱生活还是生无可恋，期待写下你的故事。</p>\n<p>96年 刚参加完学校的毕业答辩回来，离毕业也不远了吧。从去年暑假开始就在杭州实习了，最开始是做php后端，后来转到了安卓开发。实习了差不多快一年了，就要成“资深实习生”了。说实话我感觉我过得很充实吧，依然热爱生活。实习期间租房+伙食费+路费，如果不干别的什么事，一个月请假天数在两三天的话，每个月的生活是过得还算是比较舒服的，不太愁。实习之后就第一个月问家里要了一下房租和押金，以及驾校的学费。可以说完全独立了吧。拿到公司的offer是10几k，还是蛮期待拿毕业证转正的时候吧：<br>96年 刚参加完学校的毕业答辩回来，离毕业也不远了吧。从去年暑假开始就在杭州实习了，最开始是做php后端，后来转到了安卓开发。实习了差不多快一年了，就要成“资深实习生”了。说实话我感觉我过得很充实吧，依然热爱生活。实习期间租房+伙食费+路费，如果不干别的什么事，一个月请假天数在两三天的话，每个月的生活是过得还算是比较舒服的，不太愁。实习之后就第一个月问家里要了一下房租和押金，以及驾校的学费。可以说完全独立了吧。拿到公司的offer是10几k，还是蛮期待拿毕业证转正的时候吧。</p>\n<p>在这里我好想讲讲近一年的实习生活，过得日子也算是充满酸甜苦辣吧。从刚开始从公司实习开始讲吧：当时的我好像什么都会，php也会、python、java、安卓啥都会一样，经过被阿里面试打击后，可以看此帖子：<a href=\"https://www.zhihu.com/question/268713348/answer/352195054\">https://www.zhihu.com/question/268713348/answer/352195054</a></p>\n<p>我稍微收敛了一点了吧，最后进入了杭州一家互联网公司，刚开始是干php的，干了一个多月一点，感觉并没有学到多少东西，做的业务比较多，因为我属于“实习”的状态吧，安排的任务也比较少，所以每天的日子过得也很“悠闲”，每天干完就回家了，大概下午六点多就走了……这前面的php实习期间算是伏笔吧。之后由于刚好公司内部有个安卓实习的位置，好像是没有招到合适的吧，最开始面试的时候说了我什么都会，所以有幸被调到了安卓组里面。我发现好像每天的需求做起来还是那么简单，所以每天依然走得特别早吧，还有点沾沾自喜的样子，然而回到家并没有继续学习相关知识，要不就和女朋友（ broken up.）漫步钱塘江边，要么就是回到家里写写字看看其他类型的书，反正过得很舒服吧。</p>\n<p>直到有一天我被“伤自尊”了，一度自我感觉良好的我被组内的同事叫去看一个问题，我看了很久也看不出来，因为很多Java基础我都有些快忘了吧，基础不太扎实，我对代码的深度理解也有问题，我只停留在用的阶段，我不懂其原理，我只会使用，我连他们的源码都没有看过。</p>\n<p>后来被他鞭策道：你现在确实很厉害，比我当时刚出大学的时候厉害多了，但是我觉得我一点比你做的好，那就是我一直坚持在学习。你每天回去那么早没有学习，你在做什么？你现在对你自己的定位有些问题，现在你虽然觉得这些需求能做，但是你知道这些需求都是最简单的，工作难度都是最低的，我们为什么不把那些高难的任务给你？是因为你现在能力还不够，现在给你简单任务就是想让你多一些时间去学习，让你尽早能够跟上团队的步伐。实话给你说：你很菜！你真的很菜……你师傅可能不太好给你讲所以我才给你讲这些，如果你现在的状态，你永远只能做那些最简单的任务，可能连之后的校招offer都拿不到，就算侥幸8月份能拿到校招offer，也许你之后能侥幸转正，但是你不坚持学习的话迟早会被行业淘汰……</p>\n<p>这位前辈的话一直在我脑海里面印象深刻，我是一个不服输的人，在被鞭策后，我真的不服气，我也不认输，当时他叫我周末会去看一看”EventBus”的源码，然后周一向他汇报一下看的结果。周末连续两天都在看其源码，说实话看起来真的很痛苦，因为自己以前都是直接用，不会去关心它内部的逻辑，但是依然坚持看了两天，做了很多笔记，把它内部实现逻辑也搞明白了。忐忑不安地等到了周一，我向他汇报，我给他讲述了内部原理以及源码解读，他给我提了几个问题，我答上了一半多一点，我正沾沾自喜时，他给我说：如果给你这次评价满分一百分的话，我最多给你打20分。</p>\n<p>**！！！！20分，我的天！**我当时一下子整个人就不好了，甚至都想去反驳他了，可是他之后给我讲得东西，让我打消了这个念头，我确实菜。我确实认识到了自己的不足，对源代码的解读真的还不够，Java基础也不太扎实，包括我的师傅也这样认为，我是一个不服输的人，不服气。我向我师傅请教了，大概给自己定了一个短期的学习计划：先把Java基础过一遍，再过一遍Android基础过一把，再开始去理解安卓深度的东西。从此开始，我感觉我开始暴走了。</p>\n<p>我每天都背一两本书回去学习，在地铁上有时候位置空我也会拿出来继续学习，偶尔还是会找女朋友去玩，但是当我11点钟回到家，我还是会拿出书来继续学习。然后第二天我会和我的师傅讲我昨天学了什么，然后讲出我的疑问。我的师傅真的是一个很耐心的人，他会给我仔细地讲解，包括平时的问题，如果我向组内请教问：1+1等于几？ 他们会告诉我等于2。然而我的师傅会告诉我 加法口诀表，甚至是乘法口诀表。那时候我每天都不曾忘记学习，每天都会去研究，那一段时间我真的压力很大，经常性的失眠，心跳特别快，后面也去看过一次医生说是“心悸”。当然那也是在压力下人做出的一些极端反应，所幸的是我坚持了过来。八月中，HR把我叫了过去，我还以为她又要批判我了，因为最开始被团队的人给鞭策了之后，她也找过我谈话了：你如果还继续现在的状态，可能之后的校招offer都不会发给你。这一次不一样了，她给我讲了我转正后的待遇，什么期权还要公积金啥啥啥的，然后讲了工资多少多少，其实工资是有点超乎我预期的。她讲完之后，我真的笑了，真的开心了，我忍不住笑了起来。她问：开心吗？我一直点头。或许这是对努力之后最好的回报吧！那一刻真的，心里有太多说不出来，打心地的开心。</p>\n<p>拿到校招offer我还是坚持学习吧，只是强度没有之前那样强了，但是依然坚持每天要学习。现在我觉得每天每周过得生活都特别的充实吧，我们不是996。公司9点上班，弹性打卡9个小时，也就是说早上9点钟打卡，下午6点钟就可以走了，但是大部分人并不是6点钟走。现在自己每天早上都会比较期盼去公司，因为每次做需求，我都并不把他当做我的“工作”在做，而我认为那是我的兴趣爱好。我喜欢敲代码的感觉，我喜欢那种自己去设计思路想法，最后打磨出来产品的过程。而我们做出的成果会是被几百万用户所使用，肩上也有一种责任感吧。然后也带来了成就感，比如公司的宣传片或者展示公告大牌上面印着app的应用界面图，会看到里面有一部分是我做得，我是多么的开心呀。一次室友的朋友过来了，我们聊着天，后来聊到它妈妈也在用我们做得app，它给我说它妈妈怎么怎么这个App，我说啊，这里就是我做的呀。哇！厉害咯。我对工作保持乐观态度，因为我可以向厉害的前辈们请教问题，向他们学习，我每天都感觉自己有收获，所以在公司让我感觉过得很开心，没有太大的压力，每天都在进步。</p>\n<p>当然回到家了，我也有该做的事，我也有我的兴趣，大概每天7.30左右下班回家，回到家快8.30了。我也有自己追求，我在学日语，打算能在明年去一趟日本，感受一下不同的文化。日语学累了，我会继续学习相关专业的书籍，或者写写字，我比较喜欢写字，虽然没有很飘逸炫酷，但是我觉得写完之后看起来特别的舒服，这也算是一种成就感把，大概学到10.30收拾洗漱，大概11点左右上床了，我会继续看一些相关的书籍，比如最近在看《红楼梦》，厚厚的一本，渐渐地书签也跑到了中间的位置吧。</p>\n<p>至于周末，我可能比较放松吧，周末我会学着去做做菜，不再想吃外卖了，真的难吃且贵。</p>\n<p>有时候也会去绿城主场看看绿城踢球吧，虽然心里支持的四川队，但是远在他乡没有办法了。</p>\n<p>最后附上自己毕业答辩后拍的照片，算是对自己充实的大学生活的怀念吧。</p>\n<p>总之，我觉得自己每天都过得很充实吧，很热爱自己的生活。</p>\n<h2 id=\"愿每一个你们的生活都过得幸福。\"><a href=\"#愿每一个你们的生活都过得幸福。\" class=\"headerlink\" title=\"愿每一个你们的生活都过得幸福。\"></a>愿每一个你们的生活都过得幸福。</h2>","cover":null,"images":[],"content":"<p>原帖：<a href=\"https://www.zhihu.com/question/307640916/answer/686748493\">https://www.zhihu.com/question/307640916/answer/686748493</a><br>95后，毕业半年，你过得好吗？<br>亲爱的95后，毕业两年，你过得怎么样了？充实或是空虚，甜蜜还是苦涩，热爱生活还是生无可恋，期待写下你的故事。</p>\n<p>96年 刚参加完学校的毕业答辩回来，离毕业也不远了吧。从去年暑假开始就在杭州实习了，最开始是做php后端，后来转到了安卓开发。实习了差不多快一年了，就要成“资深实习生”了。说实话我感觉我过得很充实吧，依然热爱生活。实习期间租房+伙食费+路费，如果不干别的什么事，一个月请假天数在两三天的话，每个月的生活是过得还算是比较舒服的，不太愁。实习之后就第一个月问家里要了一下房租和押金，以及驾校的学费。可以说完全独立了吧。拿到公司的offer是10几k，还是蛮期待拿毕业证转正的时候吧：<br>96年 刚参加完学校的毕业答辩回来，离毕业也不远了吧。从去年暑假开始就在杭州实习了，最开始是做php后端，后来转到了安卓开发。实习了差不多快一年了，就要成“资深实习生”了。说实话我感觉我过得很充实吧，依然热爱生活。实习期间租房+伙食费+路费，如果不干别的什么事，一个月请假天数在两三天的话，每个月的生活是过得还算是比较舒服的，不太愁。实习之后就第一个月问家里要了一下房租和押金，以及驾校的学费。可以说完全独立了吧。拿到公司的offer是10几k，还是蛮期待拿毕业证转正的时候吧。</p>\n<p>在这里我好想讲讲近一年的实习生活，过得日子也算是充满酸甜苦辣吧。从刚开始从公司实习开始讲吧：当时的我好像什么都会，php也会、python、java、安卓啥都会一样，经过被阿里面试打击后，可以看此帖子：<a href=\"https://www.zhihu.com/question/268713348/answer/352195054\">https://www.zhihu.com/question/268713348/answer/352195054</a></p>\n<p>我稍微收敛了一点了吧，最后进入了杭州一家互联网公司，刚开始是干php的，干了一个多月一点，感觉并没有学到多少东西，做的业务比较多，因为我属于“实习”的状态吧，安排的任务也比较少，所以每天的日子过得也很“悠闲”，每天干完就回家了，大概下午六点多就走了……这前面的php实习期间算是伏笔吧。之后由于刚好公司内部有个安卓实习的位置，好像是没有招到合适的吧，最开始面试的时候说了我什么都会，所以有幸被调到了安卓组里面。我发现好像每天的需求做起来还是那么简单，所以每天依然走得特别早吧，还有点沾沾自喜的样子，然而回到家并没有继续学习相关知识，要不就和女朋友（ broken up.）漫步钱塘江边，要么就是回到家里写写字看看其他类型的书，反正过得很舒服吧。</p>\n<p>直到有一天我被“伤自尊”了，一度自我感觉良好的我被组内的同事叫去看一个问题，我看了很久也看不出来，因为很多Java基础我都有些快忘了吧，基础不太扎实，我对代码的深度理解也有问题，我只停留在用的阶段，我不懂其原理，我只会使用，我连他们的源码都没有看过。</p>\n<p>后来被他鞭策道：你现在确实很厉害，比我当时刚出大学的时候厉害多了，但是我觉得我一点比你做的好，那就是我一直坚持在学习。你每天回去那么早没有学习，你在做什么？你现在对你自己的定位有些问题，现在你虽然觉得这些需求能做，但是你知道这些需求都是最简单的，工作难度都是最低的，我们为什么不把那些高难的任务给你？是因为你现在能力还不够，现在给你简单任务就是想让你多一些时间去学习，让你尽早能够跟上团队的步伐。实话给你说：你很菜！你真的很菜……你师傅可能不太好给你讲所以我才给你讲这些，如果你现在的状态，你永远只能做那些最简单的任务，可能连之后的校招offer都拿不到，就算侥幸8月份能拿到校招offer，也许你之后能侥幸转正，但是你不坚持学习的话迟早会被行业淘汰……</p>\n<p>这位前辈的话一直在我脑海里面印象深刻，我是一个不服输的人，在被鞭策后，我真的不服气，我也不认输，当时他叫我周末会去看一看”EventBus”的源码，然后周一向他汇报一下看的结果。周末连续两天都在看其源码，说实话看起来真的很痛苦，因为自己以前都是直接用，不会去关心它内部的逻辑，但是依然坚持看了两天，做了很多笔记，把它内部实现逻辑也搞明白了。忐忑不安地等到了周一，我向他汇报，我给他讲述了内部原理以及源码解读，他给我提了几个问题，我答上了一半多一点，我正沾沾自喜时，他给我说：如果给你这次评价满分一百分的话，我最多给你打20分。</p>\n<p>**！！！！20分，我的天！**我当时一下子整个人就不好了，甚至都想去反驳他了，可是他之后给我讲得东西，让我打消了这个念头，我确实菜。我确实认识到了自己的不足，对源代码的解读真的还不够，Java基础也不太扎实，包括我的师傅也这样认为，我是一个不服输的人，不服气。我向我师傅请教了，大概给自己定了一个短期的学习计划：先把Java基础过一遍，再过一遍Android基础过一把，再开始去理解安卓深度的东西。从此开始，我感觉我开始暴走了。</p>\n<p>我每天都背一两本书回去学习，在地铁上有时候位置空我也会拿出来继续学习，偶尔还是会找女朋友去玩，但是当我11点钟回到家，我还是会拿出书来继续学习。然后第二天我会和我的师傅讲我昨天学了什么，然后讲出我的疑问。我的师傅真的是一个很耐心的人，他会给我仔细地讲解，包括平时的问题，如果我向组内请教问：1+1等于几？ 他们会告诉我等于2。然而我的师傅会告诉我 加法口诀表，甚至是乘法口诀表。那时候我每天都不曾忘记学习，每天都会去研究，那一段时间我真的压力很大，经常性的失眠，心跳特别快，后面也去看过一次医生说是“心悸”。当然那也是在压力下人做出的一些极端反应，所幸的是我坚持了过来。八月中，HR把我叫了过去，我还以为她又要批判我了，因为最开始被团队的人给鞭策了之后，她也找过我谈话了：你如果还继续现在的状态，可能之后的校招offer都不会发给你。这一次不一样了，她给我讲了我转正后的待遇，什么期权还要公积金啥啥啥的，然后讲了工资多少多少，其实工资是有点超乎我预期的。她讲完之后，我真的笑了，真的开心了，我忍不住笑了起来。她问：开心吗？我一直点头。或许这是对努力之后最好的回报吧！那一刻真的，心里有太多说不出来，打心地的开心。</p>\n<p>拿到校招offer我还是坚持学习吧，只是强度没有之前那样强了，但是依然坚持每天要学习。现在我觉得每天每周过得生活都特别的充实吧，我们不是996。公司9点上班，弹性打卡9个小时，也就是说早上9点钟打卡，下午6点钟就可以走了，但是大部分人并不是6点钟走。现在自己每天早上都会比较期盼去公司，因为每次做需求，我都并不把他当做我的“工作”在做，而我认为那是我的兴趣爱好。我喜欢敲代码的感觉，我喜欢那种自己去设计思路想法，最后打磨出来产品的过程。而我们做出的成果会是被几百万用户所使用，肩上也有一种责任感吧。然后也带来了成就感，比如公司的宣传片或者展示公告大牌上面印着app的应用界面图，会看到里面有一部分是我做得，我是多么的开心呀。一次室友的朋友过来了，我们聊着天，后来聊到它妈妈也在用我们做得app，它给我说它妈妈怎么怎么这个App，我说啊，这里就是我做的呀。哇！厉害咯。我对工作保持乐观态度，因为我可以向厉害的前辈们请教问题，向他们学习，我每天都感觉自己有收获，所以在公司让我感觉过得很开心，没有太大的压力，每天都在进步。</p>\n<p>当然回到家了，我也有该做的事，我也有我的兴趣，大概每天7.30左右下班回家，回到家快8.30了。我也有自己追求，我在学日语，打算能在明年去一趟日本，感受一下不同的文化。日语学累了，我会继续学习相关专业的书籍，或者写写字，我比较喜欢写字，虽然没有很飘逸炫酷，但是我觉得写完之后看起来特别的舒服，这也算是一种成就感把，大概学到10.30收拾洗漱，大概11点左右上床了，我会继续看一些相关的书籍，比如最近在看《红楼梦》，厚厚的一本，渐渐地书签也跑到了中间的位置吧。</p>\n<p>至于周末，我可能比较放松吧，周末我会学着去做做菜，不再想吃外卖了，真的难吃且贵。</p>\n<p>有时候也会去绿城主场看看绿城踢球吧，虽然心里支持的四川队，但是远在他乡没有办法了。</p>\n<p>最后附上自己毕业答辩后拍的照片，算是对自己充实的大学生活的怀念吧。</p>\n<p>总之，我觉得自己每天都过得很充实吧，很热爱自己的生活。</p>\n<h2 id=\"愿每一个你们的生活都过得幸福。\"><a href=\"#愿每一个你们的生活都过得幸福。\" class=\"headerlink\" title=\"愿每一个你们的生活都过得幸福。\"></a>愿每一个你们的生活都过得幸福。</h2>","categories":[{"name":"思考总结","slug":"thinking","api":"api/categories/thinking.json"}],"tags":[{"name":"知乎","slug":"zhihu","api":"api/tags/zhihu.json"}],"api":"api/posts/2019/05/20/95后的你们毕业半年过得还好么？.json"},{"title":"基于Volley框架的返回数据的范型处理","slug":"基于Volley框架的返回数据的范型处理","date":"2019-05-13T06:56:00.000Z","updated":"2025-05-20T11:46:57.000Z","comments":true,"url":"2019/05/13/基于Volley框架的返回数据的范型处理/","excerpt":"<p>在平时最普通的Volley的网络请求中，我们StringRequest是这样请求网络数据的：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">StringRequest</span> <span class=\"variable\">stringRequest</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">StringRequest</span>(<span class=\"string\">&quot;http://www.baidu.com&quot;</span>,</span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">Response</span>.Listener&lt;String&gt;() &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">onResponse</span><span class=\"params\">(String response)</span> &#123;</span><br><span class=\"line\">                Log.d(<span class=\"string\">&quot;TAG&quot;</span>, response);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;, <span class=\"keyword\">new</span> <span class=\"title class_\">Response</span>.ErrorListener() &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">onErrorResponse</span><span class=\"params\">(VolleyError error)</span> &#123;</span><br><span class=\"line\">        Log.e(<span class=\"string\">&quot;TAG&quot;</span>, error.getMessage(), error);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>注意在onResponse的时候是拿到的string类型，拿到string后对其再进行相关的解析，我们是否是可以对其直接封装然后拿到具体想要类型的model数据结构呢？所以对其网络请求架构进行一次封装，到达如下效果：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">GetGoodDetailByGidRequest</span> <span class=\"variable\">getGoodDetailByGidRequest</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">GetGoodDetailByGidRequest</span>(mCouponId,</span><br><span class=\"line\">              <span class=\"keyword\">new</span> <span class=\"title class_\">RequestListener</span>&lt;List&lt;CouponModel&gt;&gt;() &#123;</span><br><span class=\"line\">                  <span class=\"meta\">@Override</span></span><br><span class=\"line\">                  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">onSuccess</span><span class=\"params\">(List&lt;CouponModel&gt; result)</span> &#123;</span><br><span class=\"line\">                  &#125;</span><br><span class=\"line\">                  <span class=\"meta\">@Override</span></span><br><span class=\"line\">                  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">onError</span><span class=\"params\">(Exception e)</span> &#123;</span><br><span class=\"line\">                      e.printStackTrace();</span><br><span class=\"line\">                      stopLoadingDialog();</span><br><span class=\"line\">                  &#125;</span><br><span class=\"line\">              &#125;);</span><br></pre></td></tr></table></figure>\n<p>这里我们在构造Request的时候指定了返回数据的类型，这样的话就方便了我们在写业务的时候直接使用解析好的数据结构，具体如何做到的呢？</p>\n<p><strong>一、让每个Request基于一个带有范型请求类</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">class</span> <span class=\"title class_\">BaseApiRequest</span>&lt;T&gt;  </span><br></pre></td></tr></table></figure>\n<p>这里的T就是目标请求期望的model类<br>在具体实现的时候继承基类，并指定返回类型，下面是一个例子：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">GetGoodDetailByGidRequest</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">BaseApiRequest</span>&lt;List&lt;CouponModel&gt;&gt; &#123;</span><br><span class=\"line\">   \t<span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">String</span> <span class=\"variable\">url</span> <span class=\"operator\">=</span> CURL.GoodDetailURL;</span><br><span class=\"line\">   \t<span class=\"keyword\">public</span> <span class=\"title function_\">GetGoodDetailByGidRequest</span><span class=\"params\">(String goodId, RequestListener&lt;List&lt;CouponModel&gt;&gt; requestListener)</span> &#123;</span><br><span class=\"line\">       \t\t<span class=\"built_in\">super</span>(requestListener);</span><br><span class=\"line\">       \t\t<span class=\"built_in\">this</span>.mUrlParams.put(<span class=\"string\">&quot;id&quot;</span>, goodId);</span><br><span class=\"line\">   \t&#125;</span><br><span class=\"line\">   \t<span class=\"meta\">@Override</span></span><br><span class=\"line\">   \t<span class=\"keyword\">public</span> String <span class=\"title function_\">getBaseUrl</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">       \t\t<span class=\"keyword\">return</span> url;</span><br><span class=\"line\">  \t\t &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>二、在基类中构造网络请求</strong>\t</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">protected</span> StringRequest <span class=\"title function_\">getStringRequest</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">     <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">StringRequest</span>(requestMethod, getRequestUrl(),</span><br><span class=\"line\">             response -&gt; parseJson(response),</span><br><span class=\"line\">             error -&gt; requestListener.onError(error)) &#123;</span><br><span class=\"line\">         <span class=\"meta\">@Override</span></span><br><span class=\"line\">         <span class=\"keyword\">protected</span> Map&lt;String, String&gt; <span class=\"title function_\">getParams</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">             <span class=\"keyword\">return</span> mEntityParams;</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">     &#125;;</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n<p>在此处实现可以看到Request在基类中进行，然后分别处理返回结果</p>\n<p><strong>三、对返回结果进行解析</strong>\t</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">parseJson</span><span class=\"params\">(String response)</span> &#123;</span><br><span class=\"line\">      <span class=\"type\">int</span> <span class=\"variable\">responseCode</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">      <span class=\"type\">int</span> <span class=\"variable\">errorCode</span> <span class=\"operator\">=</span> <span class=\"number\">400</span>;</span><br><span class=\"line\">      <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">          <span class=\"type\">JSONObject</span> <span class=\"variable\">jsonObject</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">JSONObject</span>(response);</span><br><span class=\"line\"></span><br><span class=\"line\">          <span class=\"type\">String</span> <span class=\"variable\">resultString</span> <span class=\"operator\">=</span> jsonObject.getString(<span class=\"string\">&quot;data&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">          <span class=\"keyword\">if</span> (jsonObject.has(<span class=\"string\">&quot;code&quot;</span>)) &#123;</span><br><span class=\"line\">              responseCode = jsonObject.getInt(<span class=\"string\">&quot;code&quot;</span>);</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">          <span class=\"keyword\">if</span> (jsonObject.has(<span class=\"string\">&quot;error&quot;</span>)) &#123;</span><br><span class=\"line\">              errorCode = jsonObject.getInt(<span class=\"string\">&quot;error&quot;</span>);</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">          <span class=\"keyword\">if</span> (responseCode == <span class=\"number\">200</span> || errorCode == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">              <span class=\"keyword\">if</span> (!TextUtils.isEmpty(response)) &#123;</span><br><span class=\"line\">                  <span class=\"type\">Type</span> <span class=\"variable\">type</span> <span class=\"operator\">=</span> getTType(requestListener.getClass());</span><br><span class=\"line\">                  <span class=\"comment\">//泛型是实体或者List等类型</span></span><br><span class=\"line\">                  <span class=\"type\">T</span> <span class=\"variable\">t</span> <span class=\"operator\">=</span> JsonUtils.fromJson(resultString, type);</span><br><span class=\"line\">                  requestListener.onSuccess(t);</span><br><span class=\"line\">                  <span class=\"keyword\">return</span>;</span><br><span class=\"line\">              &#125;</span><br><span class=\"line\">              ToastUtils.showToast(<span class=\"string\">&quot;Data is empty!&quot;</span>);</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">          ToastUtils.showToast(<span class=\"string\">&quot;Response code is error.&quot;</span>);</span><br><span class=\"line\">          requestListener.onError(<span class=\"keyword\">new</span> <span class=\"title class_\">ParseError</span>());</span><br><span class=\"line\">      &#125; <span class=\"keyword\">catch</span> (JSONException e) &#123;</span><br><span class=\"line\">          ToastUtils.showToast(e.toString());</span><br><span class=\"line\">          e.printStackTrace();</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<p>这里是最关键的一步，由于和后端约定好相关返回字段，那么只需要解析字段中目标model的数据，其中比较重要的是这段代码</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">\t<span class=\"type\">Type</span> <span class=\"variable\">type</span> <span class=\"operator\">=</span> getTType(requestListener.getClass());</span><br><span class=\"line\">    <span class=\"comment\">//泛型是实体或者List等类型</span></span><br><span class=\"line\">     <span class=\"type\">T</span> <span class=\"variable\">t</span> <span class=\"operator\">=</span> JsonUtils.fromJson(resultString, type);</span><br><span class=\"line\">     requestListener.onSuccess(t);</span><br><span class=\"line\">```\t </span><br><span class=\"line\">通过封装好的 JsonUtils将String转化为对应的model类型，我们知道json转实体对象的时候，需要指明其类type，那这里的type是如何获取到的呢？</span><br><span class=\"line\"></span><br><span class=\"line\">其中getTType ()的具体实现为：</span><br><span class=\"line\"> ```java</span><br><span class=\"line\">     <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Type <span class=\"title function_\">getTType</span><span class=\"params\">(Class&lt;?&gt; clazz)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//以Type的形式返回本类直接实现的接口.</span></span><br><span class=\"line\">        Type[] types = clazz.getGenericInterfaces();</span><br><span class=\"line\">        clazz.getInterfaces();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (types.length &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//返回表示此类型实际类型参数的 Type 对象的数组</span></span><br><span class=\"line\">            Type[] interfacesTypes = ((ParameterizedType) types[<span class=\"number\">0</span>]).getActualTypeArguments();</span><br><span class=\"line\">            <span class=\"keyword\">return</span> interfacesTypes[<span class=\"number\">0</span>];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>通过次方法能够获取到请求实现中所指明的请求类型，其中getGenericInterfaces等相关原理可以阅读：<a href=\"https://my.oschina.net/617669559/blog/3012228\">https://my.oschina.net/617669559/blog/3012228</a></p>\n<p>所以对于\t</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">GetGoodDetailByGidRequest</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">BaseApiRequest</span>&lt;List&lt;CouponModel&gt;&gt;</span><br></pre></td></tr></table></figure>\n<p>那么获取到的就是List<CouponModel>类型</p>\n<p><strong>四、通过Listener回调相关解析结果</strong>\t</p>\n<p>拿到解析好的result并回调给构造Request方法中的listener使用</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">T</span> <span class=\"variable\">t</span> <span class=\"operator\">=</span> JsonUtils.fromJson(resultString, type);</span><br><span class=\"line\">requestListener.onSuccess(t);</span><br></pre></td></tr></table></figure>\n<p>这样对整个网络请求后的返回数据直接进行解析方便多了。</p>\n<p><strong>总结：</strong></p>\n<p>1、本文最主要是对基本Request类进行改造，以达到不需要每次重复写解析返回的String数据</p>\n<p>2、在获取目标的类的类型的时候，主要是去获取基类中的“T”类型</p>\n<p>3、设计不仅适用用Volley同样适用于其他类似的网络请求框架</p>\n","cover":null,"images":[],"content":"<p>在平时最普通的Volley的网络请求中，我们StringRequest是这样请求网络数据的：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">StringRequest</span> <span class=\"variable\">stringRequest</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">StringRequest</span>(<span class=\"string\">&quot;http://www.baidu.com&quot;</span>,</span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">Response</span>.Listener&lt;String&gt;() &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">onResponse</span><span class=\"params\">(String response)</span> &#123;</span><br><span class=\"line\">                Log.d(<span class=\"string\">&quot;TAG&quot;</span>, response);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;, <span class=\"keyword\">new</span> <span class=\"title class_\">Response</span>.ErrorListener() &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">onErrorResponse</span><span class=\"params\">(VolleyError error)</span> &#123;</span><br><span class=\"line\">        Log.e(<span class=\"string\">&quot;TAG&quot;</span>, error.getMessage(), error);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>注意在onResponse的时候是拿到的string类型，拿到string后对其再进行相关的解析，我们是否是可以对其直接封装然后拿到具体想要类型的model数据结构呢？所以对其网络请求架构进行一次封装，到达如下效果：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">GetGoodDetailByGidRequest</span> <span class=\"variable\">getGoodDetailByGidRequest</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">GetGoodDetailByGidRequest</span>(mCouponId,</span><br><span class=\"line\">              <span class=\"keyword\">new</span> <span class=\"title class_\">RequestListener</span>&lt;List&lt;CouponModel&gt;&gt;() &#123;</span><br><span class=\"line\">                  <span class=\"meta\">@Override</span></span><br><span class=\"line\">                  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">onSuccess</span><span class=\"params\">(List&lt;CouponModel&gt; result)</span> &#123;</span><br><span class=\"line\">                  &#125;</span><br><span class=\"line\">                  <span class=\"meta\">@Override</span></span><br><span class=\"line\">                  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">onError</span><span class=\"params\">(Exception e)</span> &#123;</span><br><span class=\"line\">                      e.printStackTrace();</span><br><span class=\"line\">                      stopLoadingDialog();</span><br><span class=\"line\">                  &#125;</span><br><span class=\"line\">              &#125;);</span><br></pre></td></tr></table></figure>\n<p>这里我们在构造Request的时候指定了返回数据的类型，这样的话就方便了我们在写业务的时候直接使用解析好的数据结构，具体如何做到的呢？</p>\n<p><strong>一、让每个Request基于一个带有范型请求类</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">class</span> <span class=\"title class_\">BaseApiRequest</span>&lt;T&gt;  </span><br></pre></td></tr></table></figure>\n<p>这里的T就是目标请求期望的model类<br>在具体实现的时候继承基类，并指定返回类型，下面是一个例子：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">GetGoodDetailByGidRequest</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">BaseApiRequest</span>&lt;List&lt;CouponModel&gt;&gt; &#123;</span><br><span class=\"line\">   \t<span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">String</span> <span class=\"variable\">url</span> <span class=\"operator\">=</span> CURL.GoodDetailURL;</span><br><span class=\"line\">   \t<span class=\"keyword\">public</span> <span class=\"title function_\">GetGoodDetailByGidRequest</span><span class=\"params\">(String goodId, RequestListener&lt;List&lt;CouponModel&gt;&gt; requestListener)</span> &#123;</span><br><span class=\"line\">       \t\t<span class=\"built_in\">super</span>(requestListener);</span><br><span class=\"line\">       \t\t<span class=\"built_in\">this</span>.mUrlParams.put(<span class=\"string\">&quot;id&quot;</span>, goodId);</span><br><span class=\"line\">   \t&#125;</span><br><span class=\"line\">   \t<span class=\"meta\">@Override</span></span><br><span class=\"line\">   \t<span class=\"keyword\">public</span> String <span class=\"title function_\">getBaseUrl</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">       \t\t<span class=\"keyword\">return</span> url;</span><br><span class=\"line\">  \t\t &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>二、在基类中构造网络请求</strong>\t</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">protected</span> StringRequest <span class=\"title function_\">getStringRequest</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">     <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">StringRequest</span>(requestMethod, getRequestUrl(),</span><br><span class=\"line\">             response -&gt; parseJson(response),</span><br><span class=\"line\">             error -&gt; requestListener.onError(error)) &#123;</span><br><span class=\"line\">         <span class=\"meta\">@Override</span></span><br><span class=\"line\">         <span class=\"keyword\">protected</span> Map&lt;String, String&gt; <span class=\"title function_\">getParams</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">             <span class=\"keyword\">return</span> mEntityParams;</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">     &#125;;</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n<p>在此处实现可以看到Request在基类中进行，然后分别处理返回结果</p>\n<p><strong>三、对返回结果进行解析</strong>\t</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">parseJson</span><span class=\"params\">(String response)</span> &#123;</span><br><span class=\"line\">      <span class=\"type\">int</span> <span class=\"variable\">responseCode</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">      <span class=\"type\">int</span> <span class=\"variable\">errorCode</span> <span class=\"operator\">=</span> <span class=\"number\">400</span>;</span><br><span class=\"line\">      <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">          <span class=\"type\">JSONObject</span> <span class=\"variable\">jsonObject</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">JSONObject</span>(response);</span><br><span class=\"line\"></span><br><span class=\"line\">          <span class=\"type\">String</span> <span class=\"variable\">resultString</span> <span class=\"operator\">=</span> jsonObject.getString(<span class=\"string\">&quot;data&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">          <span class=\"keyword\">if</span> (jsonObject.has(<span class=\"string\">&quot;code&quot;</span>)) &#123;</span><br><span class=\"line\">              responseCode = jsonObject.getInt(<span class=\"string\">&quot;code&quot;</span>);</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">          <span class=\"keyword\">if</span> (jsonObject.has(<span class=\"string\">&quot;error&quot;</span>)) &#123;</span><br><span class=\"line\">              errorCode = jsonObject.getInt(<span class=\"string\">&quot;error&quot;</span>);</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">          <span class=\"keyword\">if</span> (responseCode == <span class=\"number\">200</span> || errorCode == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">              <span class=\"keyword\">if</span> (!TextUtils.isEmpty(response)) &#123;</span><br><span class=\"line\">                  <span class=\"type\">Type</span> <span class=\"variable\">type</span> <span class=\"operator\">=</span> getTType(requestListener.getClass());</span><br><span class=\"line\">                  <span class=\"comment\">//泛型是实体或者List等类型</span></span><br><span class=\"line\">                  <span class=\"type\">T</span> <span class=\"variable\">t</span> <span class=\"operator\">=</span> JsonUtils.fromJson(resultString, type);</span><br><span class=\"line\">                  requestListener.onSuccess(t);</span><br><span class=\"line\">                  <span class=\"keyword\">return</span>;</span><br><span class=\"line\">              &#125;</span><br><span class=\"line\">              ToastUtils.showToast(<span class=\"string\">&quot;Data is empty!&quot;</span>);</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">          ToastUtils.showToast(<span class=\"string\">&quot;Response code is error.&quot;</span>);</span><br><span class=\"line\">          requestListener.onError(<span class=\"keyword\">new</span> <span class=\"title class_\">ParseError</span>());</span><br><span class=\"line\">      &#125; <span class=\"keyword\">catch</span> (JSONException e) &#123;</span><br><span class=\"line\">          ToastUtils.showToast(e.toString());</span><br><span class=\"line\">          e.printStackTrace();</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<p>这里是最关键的一步，由于和后端约定好相关返回字段，那么只需要解析字段中目标model的数据，其中比较重要的是这段代码</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">\t<span class=\"type\">Type</span> <span class=\"variable\">type</span> <span class=\"operator\">=</span> getTType(requestListener.getClass());</span><br><span class=\"line\">    <span class=\"comment\">//泛型是实体或者List等类型</span></span><br><span class=\"line\">     <span class=\"type\">T</span> <span class=\"variable\">t</span> <span class=\"operator\">=</span> JsonUtils.fromJson(resultString, type);</span><br><span class=\"line\">     requestListener.onSuccess(t);</span><br><span class=\"line\">```\t </span><br><span class=\"line\">通过封装好的 JsonUtils将String转化为对应的model类型，我们知道json转实体对象的时候，需要指明其类type，那这里的type是如何获取到的呢？</span><br><span class=\"line\"></span><br><span class=\"line\">其中getTType ()的具体实现为：</span><br><span class=\"line\"> ```java</span><br><span class=\"line\">     <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Type <span class=\"title function_\">getTType</span><span class=\"params\">(Class&lt;?&gt; clazz)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//以Type的形式返回本类直接实现的接口.</span></span><br><span class=\"line\">        Type[] types = clazz.getGenericInterfaces();</span><br><span class=\"line\">        clazz.getInterfaces();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (types.length &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//返回表示此类型实际类型参数的 Type 对象的数组</span></span><br><span class=\"line\">            Type[] interfacesTypes = ((ParameterizedType) types[<span class=\"number\">0</span>]).getActualTypeArguments();</span><br><span class=\"line\">            <span class=\"keyword\">return</span> interfacesTypes[<span class=\"number\">0</span>];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>通过次方法能够获取到请求实现中所指明的请求类型，其中getGenericInterfaces等相关原理可以阅读：<a href=\"https://my.oschina.net/617669559/blog/3012228\">https://my.oschina.net/617669559/blog/3012228</a></p>\n<p>所以对于\t</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">GetGoodDetailByGidRequest</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">BaseApiRequest</span>&lt;List&lt;CouponModel&gt;&gt;</span><br></pre></td></tr></table></figure>\n<p>那么获取到的就是List<CouponModel>类型</p>\n<p><strong>四、通过Listener回调相关解析结果</strong>\t</p>\n<p>拿到解析好的result并回调给构造Request方法中的listener使用</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">T</span> <span class=\"variable\">t</span> <span class=\"operator\">=</span> JsonUtils.fromJson(resultString, type);</span><br><span class=\"line\">requestListener.onSuccess(t);</span><br></pre></td></tr></table></figure>\n<p>这样对整个网络请求后的返回数据直接进行解析方便多了。</p>\n<p><strong>总结：</strong></p>\n<p>1、本文最主要是对基本Request类进行改造，以达到不需要每次重复写解析返回的String数据</p>\n<p>2、在获取目标的类的类型的时候，主要是去获取基类中的“T”类型</p>\n<p>3、设计不仅适用用Volley同样适用于其他类似的网络请求框架</p>\n","categories":[{"name":"技术文章","slug":"technology","api":"api/categories/technology.json"}],"tags":[{"name":"安卓","slug":"Android","api":"api/tags/Android.json"}],"api":"api/posts/2019/05/13/基于Volley框架的返回数据的范型处理.json"},{"title":"Java反射中getGenericInterfaces和getInterfaces的解读","slug":"My-Java反射中getGenericInterfaces和getInterfaces的解读","date":"2019-05-05T11:12:00.000Z","updated":"2025-05-20T11:46:57.000Z","comments":true,"url":"2019/05/05/My-Java反射中getGenericInterfaces和getInterfaces的解读/","excerpt":"<p>今天在做解析网络请求后得到的数据的转化的时候用到了：getGenericInterfaces这个方法。<br> <figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">\t</span><br><span class=\"line\"> <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">  * 获取回调接口中 T 的具体类型</span></span><br><span class=\"line\"><span class=\"comment\">  *</span></span><br><span class=\"line\"><span class=\"comment\">  * <span class=\"doctag\">@param</span> clazz</span></span><br><span class=\"line\"><span class=\"comment\">  * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\">   <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Type <span class=\"title function_\">getTType</span><span class=\"params\">(Class clazz)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//以Type的形式返回本类直接实现的接口.</span></span><br><span class=\"line\">    Type[] types = clazz.getGenericInterfaces();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (types.length &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//返回表示此类型实际类型参数的 Type 对象的数组</span></span><br><span class=\"line\">        Type[] interfacesTypes = ((ParameterizedType) types[<span class=\"number\">0</span>]).getActualTypeArguments();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> interfacesTypes[<span class=\"number\">0</span>];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\t\n\t\n\t</p>\n<p>其中回调接口为：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"title class_\">RequestListener</span> &lt;&gt; () &#123;</span><br><span class=\"line\">     <span class=\"meta\">@Override</span></span><br><span class=\"line\">     <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">onSuccess</span> <span class=\"params\">(List result)</span>&#123;</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">     <span class=\"comment\">//在解析数据的时候这样操作，目的是为了对所有返回的数据进行数据转化为所指定的类型：</span></span><br><span class=\"line\"></span><br><span class=\"line\">     <span class=\"type\">Type</span> <span class=\"variable\">type</span> <span class=\"operator\">=</span> getTType(requestListener.getClass());</span><br><span class=\"line\">     <span class=\"comment\">//泛型是实体或者List等类型</span></span><br><span class=\"line\">     <span class=\"type\">T</span> <span class=\"variable\">t</span> <span class=\"operator\">=</span> JsonUtils.fromJson(resultString, type);</span><br><span class=\"line\">     requestListener.onSuccess(t);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>类RequestListener为：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">RequestListener</span> &#123;</span><br><span class=\"line\">   \t<span class=\"keyword\">void</span> <span class=\"title function_\">onSuccess</span><span class=\"params\">(T result)</span>;</span><br><span class=\"line\">   \t<span class=\"keyword\">void</span> <span class=\"title function_\">onError</span><span class=\"params\">(Exception e)</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>使用Gson进行json的解析，T fromJson(String json, Type typeOfT);那么怎么才能获取到RequestListener中的的类型呢？<br>于是我们从接口获取参数化类型处理。</p>\n<p>官方文档解释</p>\n<p>getGenericInterfaces：</p>\n<blockquote>\n<p>Returns the {@code Type}s representing the interfaces directly implemented by the class or interface represented by this object.释意：返回表示由此对象表示的类或接口直接实现的接口的{@code Type}。</p>\n</blockquote>\n<p>getInterfaces：</p>\n<blockquote>\n<p>Determines the interfaces implemented by the class or interface represented by this object.<br> 释意：返回由此对象表示的类或接口实现的接口。</p>\n</blockquote>\n<p>从解释上面来看出来了，差异在于“接口实现的接口的Type”，接下来用具体示例来解释区别</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Food</span>&#123;</span><br><span class=\"line\">    String foodName;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">Eat</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">void</span> <span class=\"title function_\">eat</span><span class=\"params\">(String things)</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">Run</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Dog</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Eat</span>,Run&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span> &#123; &#125;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">eat</span><span class=\"params\">(String things)</span> &#123; &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">Class</span> <span class=\"variable\">clazz</span> <span class=\"operator\">=</span> Dog.class;</span><br><span class=\"line\">    Type[] genericInterfaces = clazz.getGenericInterfaces();</span><br><span class=\"line\">    Class[] interfaces = clazz.getInterfaces();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<pre><code>运行结果\n&#123;% qnimg 245442107557694aef0f07c25be0740187c.jpg %&#125;\n</code></pre>\n<p>我们可以看到，clazz.getGenericInterfaces()与clazz.getInterfaces()并没有任何差异。因为 并没有：“实现的接口的Type”</p>\n<p>接下来看另一段代码,我们对Eat接口改造一下，增加一个参数化类型</p>\n<pre class=\" language-language-java\"><code class=\"language-language-java\">    private class Food&#123;\n        String foodName;\n    &#125;\n    private interface Eat&#123;\n        void eat(T things);\n    &#125;\n    private interface Run&#123;\n        void run();\n    &#125;\n\n    private class Dog implements Eat,Run&#123;\n        @Override\n        public void run() &#123; &#125;\n        @Override\n        public void eat(Food things) &#123; &#125;\n    &#125;\n    private void main() &#123;\n        Class clazz = Dog.class;\n        Type[] genericInterfaces = clazz.getGenericInterfaces();\n        Class[] interfaces = clazz.getInterfaces();\n    &#125;\n</code></pre>\n<pre><code>运行结果：\n</code></pre>\n<img src=\"https://cdn.julis.wang/blog/img/1e8dd5258232de0b459be594f9793283c0a.jpg\">","cover":null,"images":["https://cdn.julis.wang/blog/img/1e8dd5258232de0b459be594f9793283c0a.jpg"],"content":"<p>今天在做解析网络请求后得到的数据的转化的时候用到了：getGenericInterfaces这个方法。<br> <figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">\t</span><br><span class=\"line\"> <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">  * 获取回调接口中 T 的具体类型</span></span><br><span class=\"line\"><span class=\"comment\">  *</span></span><br><span class=\"line\"><span class=\"comment\">  * <span class=\"doctag\">@param</span> clazz</span></span><br><span class=\"line\"><span class=\"comment\">  * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\">   <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Type <span class=\"title function_\">getTType</span><span class=\"params\">(Class clazz)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//以Type的形式返回本类直接实现的接口.</span></span><br><span class=\"line\">    Type[] types = clazz.getGenericInterfaces();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (types.length &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//返回表示此类型实际类型参数的 Type 对象的数组</span></span><br><span class=\"line\">        Type[] interfacesTypes = ((ParameterizedType) types[<span class=\"number\">0</span>]).getActualTypeArguments();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> interfacesTypes[<span class=\"number\">0</span>];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\t\n\t\n\t</p>\n<p>其中回调接口为：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"title class_\">RequestListener</span> &lt;&gt; () &#123;</span><br><span class=\"line\">     <span class=\"meta\">@Override</span></span><br><span class=\"line\">     <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">onSuccess</span> <span class=\"params\">(List result)</span>&#123;</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">     <span class=\"comment\">//在解析数据的时候这样操作，目的是为了对所有返回的数据进行数据转化为所指定的类型：</span></span><br><span class=\"line\"></span><br><span class=\"line\">     <span class=\"type\">Type</span> <span class=\"variable\">type</span> <span class=\"operator\">=</span> getTType(requestListener.getClass());</span><br><span class=\"line\">     <span class=\"comment\">//泛型是实体或者List等类型</span></span><br><span class=\"line\">     <span class=\"type\">T</span> <span class=\"variable\">t</span> <span class=\"operator\">=</span> JsonUtils.fromJson(resultString, type);</span><br><span class=\"line\">     requestListener.onSuccess(t);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>类RequestListener为：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">RequestListener</span> &#123;</span><br><span class=\"line\">   \t<span class=\"keyword\">void</span> <span class=\"title function_\">onSuccess</span><span class=\"params\">(T result)</span>;</span><br><span class=\"line\">   \t<span class=\"keyword\">void</span> <span class=\"title function_\">onError</span><span class=\"params\">(Exception e)</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>使用Gson进行json的解析，T fromJson(String json, Type typeOfT);那么怎么才能获取到RequestListener中的的类型呢？<br>于是我们从接口获取参数化类型处理。</p>\n<p>官方文档解释</p>\n<p>getGenericInterfaces：</p>\n<blockquote>\n<p>Returns the {@code Type}s representing the interfaces directly implemented by the class or interface represented by this object.释意：返回表示由此对象表示的类或接口直接实现的接口的{@code Type}。</p>\n</blockquote>\n<p>getInterfaces：</p>\n<blockquote>\n<p>Determines the interfaces implemented by the class or interface represented by this object.<br> 释意：返回由此对象表示的类或接口实现的接口。</p>\n</blockquote>\n<p>从解释上面来看出来了，差异在于“接口实现的接口的Type”，接下来用具体示例来解释区别</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Food</span>&#123;</span><br><span class=\"line\">    String foodName;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">Eat</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">void</span> <span class=\"title function_\">eat</span><span class=\"params\">(String things)</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">Run</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Dog</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Eat</span>,Run&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span> &#123; &#125;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">eat</span><span class=\"params\">(String things)</span> &#123; &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">Class</span> <span class=\"variable\">clazz</span> <span class=\"operator\">=</span> Dog.class;</span><br><span class=\"line\">    Type[] genericInterfaces = clazz.getGenericInterfaces();</span><br><span class=\"line\">    Class[] interfaces = clazz.getInterfaces();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<pre><code>运行结果\n&#123;% qnimg 245442107557694aef0f07c25be0740187c.jpg %&#125;\n</code></pre>\n<p>我们可以看到，clazz.getGenericInterfaces()与clazz.getInterfaces()并没有任何差异。因为 并没有：“实现的接口的Type”</p>\n<p>接下来看另一段代码,我们对Eat接口改造一下，增加一个参数化类型</p>\n<pre class=\" language-language-java\"><code class=\"language-language-java\">    private class Food&#123;\n        String foodName;\n    &#125;\n    private interface Eat&#123;\n        void eat(T things);\n    &#125;\n    private interface Run&#123;\n        void run();\n    &#125;\n\n    private class Dog implements Eat,Run&#123;\n        @Override\n        public void run() &#123; &#125;\n        @Override\n        public void eat(Food things) &#123; &#125;\n    &#125;\n    private void main() &#123;\n        Class clazz = Dog.class;\n        Type[] genericInterfaces = clazz.getGenericInterfaces();\n        Class[] interfaces = clazz.getInterfaces();\n    &#125;\n</code></pre>\n<pre><code>运行结果：\n</code></pre>\n<img src=\"https://cdn.julis.wang/blog/img/1e8dd5258232de0b459be594f9793283c0a.jpg\">","categories":[{"name":"技术文章","slug":"technology","api":"api/categories/technology.json"}],"tags":[{"name":"网络","slug":"网络","api":"api/tags/网络.json"}],"api":"api/posts/2019/05/05/My-Java反射中getGenericInterfaces和getInterfaces的解读.json"}],"info":{"type":"archive","year":2019,"month":5}},"api":"api/archives/2019/05/page.1.json"}