{"data":{"index":1,"total":1,"posts":[{"title":"RecyclerView自定义LayoutManager从0到1实践","slug":"自定义LayoutManager从0到1实践","date":"2023-10-31T11:19:00.000Z","updated":"2025-05-20T11:46:57.000Z","comments":true,"url":"2023/10/31/自定义LayoutManager从0到1实践/","excerpt":"<p>此前大部分涉及到 RecyclerView 页面的 LayoutManager基本上用系统提供的 LinearLayoutManager 、GridLayoutManager 就能解决，但在一些特殊场景上还是需要我们自定义  LayoutManager。之前基本上没有自己写过，在网上看各种源码各种文章，刚开始花了好多时间去理解整体流程，因为它们都给我一种非常非常复杂的感觉，包括相关的博客文章也是。经过一段时间摸索，也慢慢能理解为什么要那么复杂了，这的确不是特别容易入门。所以对整体的流程进行了一个拆解，尽量原子化一点，对自己学习的一个总结，也希望能帮助到一部分人能对  LayoutManager 入门。</p>\n<p>本文最终实现一个简单的 LinearLayoutManager（只支持 VERTICAL）方向，适合对 LayoutManager 整体流程的学习与理解，整体代码分为多个文件，每个文件都是对前一段代码的补充，方便理解，整体项目源码已提交 Github: <a href=\"https://github.com/VomPom/LayoutManagerGradually\">LayoutManagerGradually</a>，代码里面写了很多很多注释，如果不想浪费时间，可以直接看代码运行，跳过这篇文章，把每一个 LayoutManager 都跑一下体验结合代码看看。</p>\n<h2 id=\"自定义-LayoutManager-的必要元素\"><a href=\"#自定义-LayoutManager-的必要元素\" class=\"headerlink\" title=\"自定义 LayoutManager 的必要元素\"></a>自定义 LayoutManager 的必要元素</h2><ul>\n<li><p>继承 <code>RecyclerView.LayoutManager</code> 并实现 <code>generateDefaultLayoutParams() </code>方法</p>\n</li>\n<li><p>重写<code>onLayoutChildren</code> 第一次数据填充的时候数据添加</p>\n</li>\n<li><p>重写 <code>canScrollHorizontally()</code> 和<code>canScrollVertically()</code>方法设定支持滑动的方向</p>\n</li>\n<li><p>重写 <code>scrollHorizontallyBy()</code>和<code>scrollVerticallyBy()</code>方法，在滑动的时候对屏幕以外的 View 进行回收，以及填充即将滑动进入屏幕范围内的 View 进行填充</p>\n</li>\n<li><p>重写 <code>scrollToPosition()</code>和<code>smoothScrollToPosition()</code>方法支持</p>\n</li>\n</ul>\n<p>其中<code>onLayoutChildren</code> 和 <code>scrollHorizontallyBy/scrollVerticallyBy</code> 是最核心且最复杂的方法，这里稍微拎出来讲一下</p>\n<h3 id=\"onLayoutChildren\"><a href=\"#onLayoutChildren\" class=\"headerlink\" title=\"onLayoutChildren\"></a>onLayoutChildren</h3><p>这个方法类似于自定义 ViewGroup 的 onLayout() 方法，RecyclerView 的 LayoutManager.onLayoutChildren 在以下几个时机会被触发：</p>\n<ul>\n<li>当 <code>RecyclerView</code> 首次附加到窗口时</li>\n<li>当<code>Adapter</code>  的数据集发生变化</li>\n<li>当 <code>RecyclerView</code> 被 执行 <code>RequetLayout</code>的时候</li>\n<li>当 <code>LayoutManager</code> 发生变化时</li>\n</ul>\n<h3 id=\"scrollHorizontallyBy-scrollVerticallyBy\"><a href=\"#scrollHorizontallyBy-scrollVerticallyBy\" class=\"headerlink\" title=\"scrollHorizontallyBy&#x2F;scrollVerticallyBy\"></a>scrollHorizontallyBy&#x2F;scrollVerticallyBy</h3><p>方法的主要作用包括：</p>\n<ol>\n<li><p>更新 ItemView 的位置：根据传入的垂直滚动距离（dy 参数），更新子视图在屏幕上的位置。通常调用 <code>offsetChildrenVertical</code> 方法。</p>\n</li>\n<li><p>回收不可见的 ItemView：在滚动过程中，一些 ItemView 可能会离开屏幕，变得不可见。<code>scrollVerticallyBy</code> 方法需要负责回收这些子视图并将它们放入回收池，以便稍后复用。</p>\n</li>\n<li><p>添加新的 ItemView：在滚动过程中，新的 ItemView 可能需要显示在屏幕上。<code>scrollVerticallyBy</code> 方法需要从回收池中获取可复用的视图并将它们添加到屏幕上。这通常涉及到调用 <code>RecyclerView.Recycler</code> 的 <code>getViewForPosition</code> 方法。</p>\n</li>\n<li><p>返回实际滚动距离：由于 ItemView 的数量有限，滚动可能会受到限制。例如，当滚动到列表顶部或底部时，滚动可能会停止。在这种情况下，实际滚动的距离可能会小于传入的 <code>dy</code> 参数。<code>scrollVerticallyBy</code> 方法需要返回实际滚动的距离，以便 <code>RecyclerView</code> 可以正确地更新滚动条和触发滚动事件。</p>\n</li>\n</ol>\n<p>概念就简单讲这么多， talk is cheap show me the code，直接看代码理解会比较深刻</p>\n<h2 id=\"逐步实现\"><a href=\"#逐步实现\" class=\"headerlink\" title=\"逐步实现\"></a>逐步实现</h2><p>要实现一个可用的 LayoutManger 通常我们需要实现以下流程</p>\n<ul>\n<li>数据填充并且只需要填充屏幕范围内的 ItemView</li>\n<li>回收掉屏幕以外的 ItemView</li>\n<li>屏幕外 ItemView 再回到屏幕后，需要重新填充</li>\n<li>对滑动边界边界进行处理</li>\n<li>对 scrollToPosition 和 smoothScrollToPosition进行支持</li>\n</ul>\n<p>我们不用一上来就实现最终的效果，而是一步一步来，看看 LayoutManger 是怎么渐渐地变化，最终能跑起来的。</p>\n<h3 id=\"0-最简单的-LayoutManager\"><a href=\"#0-最简单的-LayoutManager\" class=\"headerlink\" title=\"0 最简单的 LayoutManager\"></a>0 最简单的 LayoutManager</h3><p>代码查看：<a href=\"https://github.com/VomPom/LayoutManagerGradually/tree/main/layoutmanager/src/main/java/com/julis/layoutmanager/series/MostSimpleLayoutManager.kt\">MostSimpleLayoutManager</a>，我们关注 <code>onLayoutChildren</code> 方法:</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onLayoutChildren</span><span class=\"params\">(recycler: <span class=\"type\">RecyclerView</span>.<span class=\"type\">Recycler</span>, state: <span class=\"type\">RecyclerView</span>.<span class=\"type\">State</span>?)</span></span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 垂直方向的偏移量</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> offsetTop = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"comment\">// 实际业务中最好不要这样一次性加载所有的数据，这里只是最简单地演示一下整体是如何工作的</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (itemIndex <span class=\"keyword\">in</span> <span class=\"number\">0</span> until itemCount) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 从适配器获取与给定位置关联的视图</span></span><br><span class=\"line\">        <span class=\"keyword\">val</span> itemView = recycler.getViewForPosition(itemIndex)</span><br><span class=\"line\">        <span class=\"comment\">// 将视图添加到 RecyclerView 中</span></span><br><span class=\"line\">        addView(itemView)</span><br><span class=\"line\">        <span class=\"comment\">// 测量并布局视图</span></span><br><span class=\"line\">        measureChildWithMargins(itemView, <span class=\"number\">0</span>, <span class=\"number\">0</span>)</span><br><span class=\"line\">        <span class=\"comment\">// 拿到宽高（包括ItemDecoration）</span></span><br><span class=\"line\">        <span class=\"keyword\">val</span> width = getDecoratedMeasuredWidth(itemView)</span><br><span class=\"line\">        <span class=\"keyword\">val</span> height = getDecoratedMeasuredHeight(itemView)</span><br><span class=\"line\">        <span class=\"comment\">// 对要添加的子 View 进行布局</span></span><br><span class=\"line\">        layoutDecorated(itemView, <span class=\"number\">0</span>, offsetTop, width, offsetTop + height)</span><br><span class=\"line\">        offsetTop += height</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面的代码主要演示了，如何利用<code>addView</code> <code>layoutDecorated</code>等方法，将 ItemView 添加到 RecyclerView 上。代码可见是 将所有的 ItemView（即使它在屏幕上不可见）一次性全部加载到了 RecyclerView上， 这里一般不这么做，只是这里这里只是最简单地演示一下整体是如何工作的。</p>\n<p>运行在手机上能看到这样的效果：Item数据已经被全部添加到界面上了，并且各个方向的滑动都支持。</p>\n<img src=\"https://cdn.julis.wang/blog/img/layoutmanager_gradually_0.gif?imageView2/2/w/300\">\n<h3 id=\"1-更合理的数据添加方式\"><a href=\"#1-更合理的数据添加方式\" class=\"headerlink\" title=\"1 更合理的数据添加方式\"></a>1 更合理的数据添加方式</h3><p>代码查看：<a href=\"https://github.com/VomPom/LayoutManagerGradually/tree/main/layoutmanager/src/main/java/com/julis/layoutmanager/series/LinearLayoutManager1\">LinearLayoutManager1.kt</a></p>\n<p>对最开始的代码进行优化，只在屏幕范围内的区域进行数据的添加，这样就不需要一次性将所有数据就添加上去，如果 Adapter 的 ItemCount 足够巨大，for all addView 的话，很容易就 OOM。</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onLayoutChildren</span><span class=\"params\">(recycler: <span class=\"type\">RecyclerView</span>.<span class=\"type\">Recycler</span>, state: <span class=\"type\">RecyclerView</span>.<span class=\"type\">State</span>)</span></span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 垂直方向上的的空间大小</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> remainSpace = height - paddingTop</span><br><span class=\"line\">    <span class=\"comment\">//垂直方向的偏移量</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> offsetTop = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> currentPosition = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (remainSpace &gt; <span class=\"number\">0</span> &amp;&amp; currentPosition &lt; state.itemCount) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 从适配器获取与给定位置关联的视图</span></span><br><span class=\"line\">        <span class=\"keyword\">val</span> itemView = recycler.getViewForPosition(currentPosition)</span><br><span class=\"line\">        <span class=\"comment\">// 将视图添加到 RecyclerView 中</span></span><br><span class=\"line\">        addView(itemView)</span><br><span class=\"line\">        <span class=\"comment\">// 测量并布局视图</span></span><br><span class=\"line\">        measureChildWithMargins(itemView, <span class=\"number\">0</span>, <span class=\"number\">0</span>)</span><br><span class=\"line\">        <span class=\"comment\">// 拿到宽高（包括ItemDecoration）</span></span><br><span class=\"line\">        <span class=\"keyword\">val</span> itemWidth = getDecoratedMeasuredWidth(itemView)</span><br><span class=\"line\">        <span class=\"keyword\">val</span> itemHeight = getDecoratedMeasuredHeight(itemView)</span><br><span class=\"line\">        <span class=\"comment\">// 对要添加的子 View 进行布局</span></span><br><span class=\"line\">        layoutDecorated(itemView, <span class=\"number\">0</span>, offsetTop, itemWidth, offsetTop + itemHeight)</span><br><span class=\"line\">        offsetTop += itemHeight</span><br><span class=\"line\">        currentPosition++</span><br><span class=\"line\">        <span class=\"comment\">// 可用空间减少</span></span><br><span class=\"line\">        remainSpace -= itemHeight</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"2-对屏幕外的View回收\"><a href=\"#2-对屏幕外的View回收\" class=\"headerlink\" title=\"2 对屏幕外的View回收\"></a>2 对屏幕外的View回收</h3><p>代码查看：<a href=\"https://github.com/VomPom/LayoutManagerGradually/tree/main/layoutmanager/src/main/java/com/julis/layoutmanager/series/LinearLayoutManager2.kt\">LinearLayoutManager2</a></p>\n<p>RecylerView 没有 recycler 怎么行呢？当 RecylerView 的 ItemView 滑出屏幕后我们需要对齐进行回收，实现的话需要在 <code>scrollVerticallyBy</code>中，比较复杂的逻辑就是怎么去判断：ItemView 在屏幕以外，最后利用：<code>removeAndRecycleView</code>方法进行回收</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">scrollVerticallyBy</span><span class=\"params\">(dy: <span class=\"type\">Int</span>, recycler: <span class=\"type\">RecyclerView</span>.<span class=\"type\">Recycler</span>, state: <span class=\"type\">RecyclerView</span>.<span class=\"type\">State</span>?)</span></span>: <span class=\"built_in\">Int</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 在这里处理上下的滚动逻辑，dy 表示滚动的距离</span></span><br><span class=\"line\">      <span class=\"comment\">// 平移所有子视图</span></span><br><span class=\"line\">      offsetChildrenVertical(-dy)</span><br><span class=\"line\">      <span class=\"comment\">// 如果实际滚动距离与 dy 相同，返回 dy；如果未滚动，返回 0</span></span><br><span class=\"line\">      recycleInvisibleView(dy, recycler)</span><br><span class=\"line\">      <span class=\"keyword\">return</span> dy</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 回收掉在界面上看不到的 ItemView</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> dy</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> recycler</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">recycleInvisibleView</span><span class=\"params\">(dy: <span class=\"type\">Int</span>, recycler: <span class=\"type\">RecyclerView</span>.<span class=\"type\">Recycler</span>)</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">val</span> totalSpace = orientationHelper.totalSpace</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 将要回收View的集合</span></span><br><span class=\"line\">    <span class=\"keyword\">val</span> recycleViews = hashSetOf&lt;View&gt;()</span><br><span class=\"line\">    <span class=\"comment\">// 从下往上滑</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (dy &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (i <span class=\"keyword\">in</span> <span class=\"number\">0</span> until childCount) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">val</span> child = getChildAt(i)!!</span><br><span class=\"line\">            <span class=\"comment\">// 从下往上滑从最上面的 item 开始计算</span></span><br><span class=\"line\">            <span class=\"keyword\">val</span> top = getDecoratedTop(child)</span><br><span class=\"line\">            <span class=\"comment\">// 判断最顶部的 item 是否已经完全不可见，如何可见，那说明底下的 item 也是可见</span></span><br><span class=\"line\">            <span class=\"keyword\">val</span> height = top - getDecoratedBottom(child)</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (height - top &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">break</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            recycleViews.add(child)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (dy &lt; <span class=\"number\">0</span>) &#123;   <span class=\"comment\">// 从上往下滑</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (i <span class=\"keyword\">in</span> childCount - <span class=\"number\">1</span> downTo <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">val</span> child = getChildAt(i)!!</span><br><span class=\"line\">            <span class=\"comment\">// 从上往下滑从最底部的 item 开始计算</span></span><br><span class=\"line\">            <span class=\"keyword\">val</span> bottom = getDecoratedBottom(child)</span><br><span class=\"line\">            <span class=\"comment\">// 判断最底部的 item 是否已经完全不可见，如何可见，那说明上面的 item 也是可见</span></span><br><span class=\"line\">            <span class=\"keyword\">val</span> height = bottom - getDecoratedTop(child)</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (bottom - totalSpace &lt; height) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">break</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            recycleViews.add(child)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 真正把 View 移除掉的逻辑</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (view <span class=\"keyword\">in</span> recycleViews) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// [removeAndRecycleView]</span></span><br><span class=\"line\">        <span class=\"comment\">// 用于从视图层次结构中删除某个视图，并将其资源回收，以便在需要时重新利用</span></span><br><span class=\"line\">        removeAndRecycleView(view, recycler)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    recycleViews.clear()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>运行在手机上能看到这样的效果：滑出屏幕外的ItemView 被回收掉了</p>\n<img src=\"https://cdn.julis.wang/blog/img/layoutmanager_gradually_2.gif?imageView2/2/w/300\">\n\n<h3 id=\"3-向上滑动的时View的填充\"><a href=\"#3-向上滑动的时View的填充\" class=\"headerlink\" title=\"3 向上滑动的时View的填充\"></a>3 向上滑动的时View的填充</h3><p>代码查看：<a href=\"https://github.com/VomPom/LayoutManagerGradually/tree/main/layoutmanager/src/main/java/com/julis/layoutmanager/series/LinearLayoutManager3.kt\">LinearLayoutManager3</a></p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">scrollVerticallyBy</span><span class=\"params\">(dy: <span class=\"type\">Int</span>, recycler: <span class=\"type\">RecyclerView</span>.<span class=\"type\">Recycler</span>, state: <span class=\"type\">RecyclerView</span>.<span class=\"type\">State</span>?)</span></span>: <span class=\"built_in\">Int</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 填充 view</span></span><br><span class=\"line\">    fillView(dy, recycler)</span><br><span class=\"line\">    <span class=\"comment\">// 移动 view</span></span><br><span class=\"line\">    offsetChildrenVertical(-dy)</span><br><span class=\"line\">    <span class=\"comment\">// 回收 View</span></span><br><span class=\"line\">    recycleInvisibleView(dy, recycler)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> dy</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 填充重新进入屏幕内的 ItemView</span></span><br><span class=\"line\"><span class=\"comment\"> *     getChildCount():childCount-&gt; 当前屏幕内RecyclerView展示的 ItemView 数量</span></span><br><span class=\"line\"><span class=\"comment\"> *     getItemCount():itemCount-&gt; 最大的 ItemView 数量，也就是 Adapter 传递的数据的数量</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">fillView</span><span class=\"params\">(dy: <span class=\"type\">Int</span>, recycler: <span class=\"type\">RecyclerView</span>.<span class=\"type\">Recycler</span>)</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">val</span> verticalSpace = orientationVerticalHelper.totalSpace</span><br><span class=\"line\">    <span class=\"keyword\">var</span> remainSpace = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> nextFillPosition = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"comment\">//垂直方向的偏移量</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> offsetTop = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> offsetLeft = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"comment\">// 从下往上滑，那么需要向底部添加数据</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (dy &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">val</span> anchorView = getChildAt(childCount - <span class=\"number\">1</span>) ?: <span class=\"keyword\">return</span></span><br><span class=\"line\">        <span class=\"keyword\">val</span> anchorPosition = getPosition(anchorView)</span><br><span class=\"line\">        <span class=\"keyword\">val</span> anchorBottom = getDecoratedBottom(anchorView)</span><br><span class=\"line\">        <span class=\"keyword\">val</span> anchorLeft = getDecoratedLeft(anchorView)</span><br><span class=\"line\">        remainSpace = verticalSpace - anchorBottom</span><br><span class=\"line\">        <span class=\"comment\">// 垂直可用的数据为&lt;0，意外着这时候屏幕底部的位置刚好在最底部的 ItemView 上，还需要向上滑动一点点...我们才能添加 View</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (remainSpace &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        nextFillPosition = anchorPosition + <span class=\"number\">1</span></span><br><span class=\"line\">        offsetTop = anchorBottom</span><br><span class=\"line\">        offsetLeft = anchorLeft</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (nextFillPosition &gt;= itemCount) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (dy &lt; <span class=\"number\">0</span>) &#123;  <span class=\"comment\">// 从上往下滑，那么需要向顶部添加数据</span></span><br><span class=\"line\">        <span class=\"comment\">//no-op 暂时不实现从上往下滑的底部数据填充</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (remainSpace &gt; <span class=\"number\">0</span> &amp;&amp; nextFillPosition &lt; itemCount) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 从适配器获取与给定位置关联的视图</span></span><br><span class=\"line\">        <span class=\"keyword\">val</span> itemView = recycler.getViewForPosition(nextFillPosition)</span><br><span class=\"line\">        <span class=\"comment\">// 将视图添加到 RecyclerView 中</span></span><br><span class=\"line\">        addView(itemView)</span><br><span class=\"line\">        <span class=\"comment\">// 测量并布局视图</span></span><br><span class=\"line\">        measureChildWithMargins(itemView, <span class=\"number\">0</span>, <span class=\"number\">0</span>)</span><br><span class=\"line\">        <span class=\"comment\">// 拿到宽高（包括ItemDecoration）</span></span><br><span class=\"line\">        <span class=\"keyword\">val</span> itemWidth = getDecoratedMeasuredWidth(itemView)</span><br><span class=\"line\">        <span class=\"keyword\">val</span> itemHeight = getDecoratedMeasuredHeight(itemView)</span><br><span class=\"line\">        <span class=\"comment\">// 对要添加的子 View 进行布局，相比onLayoutChildren 里面的实现添加了：offsetLeft（因为我们没有禁止掉 左右的滑动）</span></span><br><span class=\"line\">        <span class=\"comment\">// 试着把 offsetLeft 改成0，也就是最原始的样子，然后左右上下滑滑，你会有意外收获</span></span><br><span class=\"line\">        layoutDecorated(itemView, offsetLeft, offsetTop, itemWidth + offsetLeft, offsetTop + itemHeight)</span><br><span class=\"line\">        offsetTop += itemHeight</span><br><span class=\"line\">        nextFillPosition++</span><br><span class=\"line\">        <span class=\"comment\">// 可用空间减少</span></span><br><span class=\"line\">        remainSpace -= itemHeight</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>运行在手机上能看到这样的效果：向上滑动的时候，底部陆续有元素填充，但向下滑动的时候没有填充数据</p>\n<img src=\"https://cdn.julis.wang/blog/img/layoutmanager_gradually_3.gif?imageView2/2/w/300\">\n<h3 id=\"4-两个方向的View填充\"><a href=\"#4-两个方向的View填充\" class=\"headerlink\" title=\"4 两个方向的View填充\"></a>4 两个方向的View填充</h3><p>代码查看：<a href=\"https://github.com/VomPom/LayoutManagerGradually/tree/main/layoutmanager/src/main/java/com/julis/layoutmanager/series/LinearLayoutManager4.kt\">LinearLayoutManager4</a></p>\n<p>补齐从上往下滑之后添加的逻辑</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">fillView</span><span class=\"params\">(dy: <span class=\"type\">Int</span>, recycler: <span class=\"type\">RecyclerView</span>.<span class=\"type\">Recycler</span>)</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">val</span> verticalSpace = orientationVerticalHelper.totalSpace</span><br><span class=\"line\">    <span class=\"keyword\">var</span> remainSpace = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> nextFillPosition = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"comment\">//垂直方向的偏移量</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> offsetTop = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> offsetLeft = <span class=\"number\">0</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 从下往上滑，那么需要向底部添加数据</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (dy &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        ……</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (dy &lt; <span class=\"number\">0</span>) &#123;  <span class=\"comment\">// 从上往下滑，那么需要向顶部添加数据</span></span><br><span class=\"line\">        <span class=\"keyword\">val</span> anchorView = getChildAt(<span class=\"number\">0</span>) ?: <span class=\"keyword\">return</span></span><br><span class=\"line\">        <span class=\"keyword\">val</span> anchorPosition = getPosition(anchorView)</span><br><span class=\"line\">        <span class=\"keyword\">val</span> anchorTop = getDecoratedTop(anchorView)</span><br><span class=\"line\">        offsetLeft = getDecoratedLeft(anchorView)</span><br><span class=\"line\">        remainSpace = anchorTop</span><br><span class=\"line\">        <span class=\"comment\">// 垂直可用的数据为&lt;0，意外着这时候屏幕顶部的位置刚好在最底部的 ItemView 上，还需要向下滑动一点点...我们才能添加 View</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (anchorTop &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        nextFillPosition = anchorPosition - <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (nextFillPosition &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">val</span> itemHeight = getDecoratedMeasuredHeight(anchorView)</span><br><span class=\"line\">        <span class=\"comment\">// 新的布局的itemView 的顶部位置应该以 anchorTop - itemHeight 开始</span></span><br><span class=\"line\">        offsetTop = anchorTop - itemHeight</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (remainSpace &gt; <span class=\"number\">0</span> &amp;&amp;</span><br><span class=\"line\">        ((nextFillPosition &lt; itemCount) &amp;&amp; (nextFillPosition &gt;= <span class=\"number\">0</span>))</span><br><span class=\"line\">    ) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 从适配器获取与给定位置关联的视图</span></span><br><span class=\"line\">        <span class=\"keyword\">val</span> itemView = recycler.getViewForPosition(nextFillPosition)</span><br><span class=\"line\">        <span class=\"comment\">// 将视图添加到 RecyclerView 中k，从顶部添加的话，需要加到最前的位置</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (dy &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            addView(itemView)</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            addView(itemView, <span class=\"number\">0</span>)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        ……</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (dy &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            offsetTop += itemHeight</span><br><span class=\"line\">            nextFillPosition++</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            offsetTop -= itemHeight</span><br><span class=\"line\">            nextFillPosition--</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 可用空间减少</span></span><br><span class=\"line\">        remainSpace -= itemHeight</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>运行在手机上能看到这样的效果：向上或者滑动的时候，底部陆续都有元素填充</p>\n<img src=\"https://cdn.julis.wang/blog/img/layoutmanager_gradually_4.gif?imageView2/2/w/300\">\n<h3 id=\"5-对顶部和底部滑动边界处理\"><a href=\"#5-对顶部和底部滑动边界处理\" class=\"headerlink\" title=\"5 对顶部和底部滑动边界处理\"></a>5 对顶部和底部滑动边界处理</h3><p>代码查看：<a href=\"https://github.com/VomPom/LayoutManagerGradually/tree/main/layoutmanager/src/main/java/com/julis/layoutmanager/series/LinearLayoutManager5.kt\">LinearLayoutManager5</a></p>\n<p>对于前面的实现会发现会：不停地下滑或者上滑会留出来巨大的空白。这里对填充 View 的逻辑进行改造，需要进行边界检测。</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">scrollVerticallyBy</span><span class=\"params\">(dy: <span class=\"type\">Int</span>, recycler: <span class=\"type\">RecyclerView</span>.<span class=\"type\">Recycler</span>, state: <span class=\"type\">RecyclerView</span>.<span class=\"type\">State</span>?)</span></span>: <span class=\"built_in\">Int</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 填充 view</span></span><br><span class=\"line\">    <span class=\"keyword\">val</span> adjustedDy = fillView(dy, recycler)</span><br><span class=\"line\">    <span class=\"comment\">// 移动 view</span></span><br><span class=\"line\">    offsetChildrenVertical(-adjustedDy)</span><br><span class=\"line\">    <span class=\"comment\">// 回收 View</span></span><br><span class=\"line\">    recycleInvisibleView(adjustedDy, recycler)</span><br><span class=\"line\">    <span class=\"comment\">// 由于需要对边界进行限制，所以需要对原始的 dy 进行修正，这里不再直接返回 dy</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> adjustedDy</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>这里的整体注释我写在了代码里面，可以看图稍微理解一下，以向上滑动为例：假设这一次滑动的距离非常非常大(想象成10000像素)，如果直接滑动的话，我们有50个元素，每个元素高度100像素，最大高度也只有50x100&#x3D;5000，那么滑动后一定会留下大量空区域。需要对当前传入的这 10000 像素做调整：只给到可滑动的最大距离，如果不能滑动了就返回0。</p>\n<img src=\"https://cdn.julis.wang/blog/img/5_scroll_limit.png\">\n<p>运行在手机上能看到这样的效果：向上或者滑动的时候，达到最大的位置时候是不能再滑动的。</p>\n<img src=\"https://cdn.julis.wang/blog/img/layoutmanager_gradually_5.gif?imageView2/2/w/300\">\n<h3 id=\"6-实现-scrollToPosition\"><a href=\"#6-实现-scrollToPosition\" class=\"headerlink\" title=\"6 实现 scrollToPosition\"></a>6 实现 scrollToPosition</h3><p>代码查看：<a href=\"https://github.com/VomPom/LayoutManagerGradually/tree/main/layoutmanager/src/main/java/com/julis/layoutmanager/series/LinearLayoutManager6.kt\">LinearLayoutManager6</a></p>\n<p>到这里这个 LinearLayoutManager 看着已经能正常运行了，但一般还需要支持<code>scrollToPosition</code> 和 <code>smoothScrollToPositio</code></p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">var</span> mPendingScrollPosition = RecyclerView.NO_POSITION</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">scrollToPosition</span><span class=\"params\">(position: <span class=\"type\">Int</span>)</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>.scrollToPosition(position)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (position &lt; <span class=\"number\">0</span> || position &gt;= itemCount) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    mPendingScrollPosition = position</span><br><span class=\"line\">    requestLayout()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onLayoutChildren</span><span class=\"params\">(recycler: <span class=\"type\">RecyclerView</span>.<span class=\"type\">Recycler</span>, state: <span class=\"type\">RecyclerView</span>.<span class=\"type\">State</span>)</span></span> &#123;</span><br><span class=\"line\">    ……</span><br><span class=\"line\">    <span class=\"keyword\">var</span> currentPosition = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mPendingScrollPosition != RecyclerView.NO_POSITION) &#123;</span><br><span class=\"line\">        currentPosition = mPendingScrollPosition</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (remainSpace &gt; <span class=\"number\">0</span> &amp;&amp; currentPosition &lt; state.itemCount) &#123;</span><br><span class=\"line\">      …… <span class=\"comment\">// 填充View 的逻辑</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>scrollToPosition</code> 的实现比较简单，如上代码所示：在 <code>scrollToPosition</code>  的时候记录一次目标position，再 requestLayout 一波，还记得之前有提到过：<code>onLayoutChildren</code> 会在 <code>requestLayout</code> 的时候调用一次，于是再将<code>onLayoutChildren</code>逻辑改写，不再从第0个元素开始，而是从目标位置进行布局。</p>\n<p>运行在手机上能看到这样的效果：点击 scrollTo30 将会滑动到 第30个位置。</p>\n<img src=\"https://cdn.julis.wang/blog/img/layoutmanager_gradually_6.gif?imageView2/2/w/300\">\n<h3 id=\"7-实现-smoothScrollToPosition\"><a href=\"#7-实现-smoothScrollToPosition\" class=\"headerlink\" title=\"7 实现 smoothScrollToPosition\"></a>7 实现 smoothScrollToPosition</h3><p>代码查看：<a href=\"https://github.com/VomPom/LayoutManagerGradually/tree/main/layoutmanager/src/main/java/com/julis/layoutmanager/series/LinearLayoutManager7.kt\">LinearLayoutManager7</a>  </p>\n<p>要实现自定义的 smoothScrollToPosition 动画效果，这一块如果要完全自己实现的话比较复杂，可以直接使用系统提供的 LinearSmoothScroller改造,也可以继承 RecyclerView.SmoothScroller 自定义，也可以完全不使用 SmoothScroller， 照着 SmoothScroller 的实现使用类似 ValueAnimator 自定义动画，添加动画 UpdateListener，在 onAnimationUpdate 的时候动态计算布局从而实现滑动动画,这里拿 LinearSmoothScroller 举例:</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">smoothScrollToPosition</span><span class=\"params\">(</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">    recyclerView: <span class=\"type\">RecyclerView</span>,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">    state: <span class=\"type\">RecyclerView</span>.<span class=\"type\">State</span>,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">    position: <span class=\"type\">Int</span></span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">)</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (position &gt;= itemCount || position &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">val</span> scroller: LinearSmoothScroller = <span class=\"keyword\">object</span> : LinearSmoothScroller(recyclerView.context) &#123;</span><br><span class=\"line\">        <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">         * 这个方法用于计算滚动到目标位置所需的滚动向量。滚动向量是一个二维向量，包含水平和垂直方向上的滚动距离</span></span><br><span class=\"line\"><span class=\"comment\">         *</span></span><br><span class=\"line\"><span class=\"comment\">         * <span class=\"doctag\">@param</span> targetPosition 滑动的目标位置</span></span><br><span class=\"line\"><span class=\"comment\">         * <span class=\"doctag\">@return</span>  返回一个 PointF 对象，表示滚动向量。</span></span><br><span class=\"line\"><span class=\"comment\">         *              PointF.x 表示水平方向上的滚动距离，</span></span><br><span class=\"line\"><span class=\"comment\">         *              PointF.y 表示垂直方向上的滚动距离</span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\">        <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">computeScrollVectorForPosition</span><span class=\"params\">(targetPosition: <span class=\"type\">Int</span>)</span></span>: PointF &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 查找到屏幕里显示的第 1 个元素与</span></span><br><span class=\"line\">            <span class=\"keyword\">val</span> firstChildPos = getPosition(getChildAt(<span class=\"number\">0</span>)!!)</span><br><span class=\"line\">            <span class=\"keyword\">val</span> direction = <span class=\"keyword\">if</span> (targetPosition &lt; firstChildPos) -<span class=\"number\">1</span> <span class=\"keyword\">else</span> <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"comment\">// x 左右滑动，由于我们只实现了垂直的滑动，所以 x方向为0即可</span></span><br><span class=\"line\">            <span class=\"comment\">// 整数代表正向移动，负数代表反向移动，这里的数值大小不重要，源码里面最终都会 normalize 归一化处理</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> PointF(<span class=\"number\">0f</span>, direction.toFloat())</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">         * 计算每像素速度</span></span><br><span class=\"line\"><span class=\"comment\">         *</span></span><br><span class=\"line\"><span class=\"comment\">         * <span class=\"doctag\">@param</span> displayMetrics</span></span><br><span class=\"line\"><span class=\"comment\">         * <span class=\"doctag\">@return</span> 返回每一像素的耗时，单位ms，假设返回值是1.0 代表着：1ms 内会滑动 1像素，1s会滑动1000像素</span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\">        <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">calculateSpeedPerPixel</span><span class=\"params\">(displayMetrics: <span class=\"type\">DisplayMetrics</span>?)</span></span>: <span class=\"built_in\">Float</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">super</span>.calculateSpeedPerPixel(displayMetrics)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">         * 滑动速度的插值（实现滑动速度随着滑动时间的变化）</span></span><br><span class=\"line\"><span class=\"comment\">         *</span></span><br><span class=\"line\"><span class=\"comment\">         * <span class=\"doctag\">@param</span> dx</span></span><br><span class=\"line\"><span class=\"comment\">         * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\">        <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">calculateTimeForDeceleration</span><span class=\"params\">(dx: <span class=\"type\">Int</span>)</span></span>: <span class=\"built_in\">Int</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">super</span>.calculateTimeForDeceleration(dx)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 很多方法可以使用，不再一一列举</span></span><br><span class=\"line\">        <span class=\"comment\">// ...</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    scroller.targetPosition = position</span><br><span class=\"line\">    <span class=\"comment\">// 执行默认动画的逻辑</span></span><br><span class=\"line\">    startSmoothScroll(scroller)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>运行在手机上能看到这样的效果：点击 smoothScrollTo30 将会有个动画效果滑动到第30个位置。</p>\n<img src=\"https://cdn.julis.wang/blog/img/layoutmanager_gradually_7.gif?imageView2/2/w/300\">\n<p>以上基本上一个自定义 LayoutManager 的雏形就已经完成了，虽然只实现了一个方向的滑动，但是其原理都是一样的，剩下的就是各种细节的打磨了，可以加各种自己想要的效果，比如：指定位置 放大一定的系数，或者更炫酷的滑动动画…</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>本文主要整理了自定义 LayoutManager 的必要元素，以及其核心方法 scrollHorizontallyBy&#x2F;scrollVerticallyBy、onLayoutChildren 的作用与调用时机，接下对实现一个简单的 LinearLayoutManger 进行逻辑拆解，从最简单的不滑动回收和填充以及不含滑动边界检测，到最终一个具备基本功能的 LayoutManger</p>\n<p>源码：<a href=\"https://github.com/VomPom/LayoutManagerGradually\">https://github.com/VomPom/LayoutManagerGradually</a></p>\n<p>参考：</p>\n<p><a href=\"https://juejin.cn/post/6870770285247725581?searchId=202310181005138A6D82B1DEE9C47A9797#heading-23\">《看完这篇文章你还不会自定义LayoutManager，我吃X！》</a></p>\n<p><a href=\"https://github.com/MycroftWong/FlowLayoutManager/blob/master/LayoutManager%E5%88%86%E6%9E%90%E4%B8%8E%E5%AE%9E%E8%B7%B5.md\">《&#x2F;LayoutManager分析与实践》</a></p>\n<p><a href=\"https://wiresareobsolete.com/2014/09/building-a-recyclerview-layoutmanager-part-1/\">Building a RecyclerView LayoutManager – Part 1</a></p>\n","cover":null,"images":["https://cdn.julis.wang/blog/img/layoutmanager_gradually_0.gif?imageView2/2/w/300","https://cdn.julis.wang/blog/img/layoutmanager_gradually_2.gif?imageView2/2/w/300","https://cdn.julis.wang/blog/img/layoutmanager_gradually_3.gif?imageView2/2/w/300","https://cdn.julis.wang/blog/img/layoutmanager_gradually_4.gif?imageView2/2/w/300","https://cdn.julis.wang/blog/img/5_scroll_limit.png","https://cdn.julis.wang/blog/img/layoutmanager_gradually_5.gif?imageView2/2/w/300","https://cdn.julis.wang/blog/img/layoutmanager_gradually_6.gif?imageView2/2/w/300","https://cdn.julis.wang/blog/img/layoutmanager_gradually_7.gif?imageView2/2/w/300"],"content":"<p>此前大部分涉及到 RecyclerView 页面的 LayoutManager基本上用系统提供的 LinearLayoutManager 、GridLayoutManager 就能解决，但在一些特殊场景上还是需要我们自定义  LayoutManager。之前基本上没有自己写过，在网上看各种源码各种文章，刚开始花了好多时间去理解整体流程，因为它们都给我一种非常非常复杂的感觉，包括相关的博客文章也是。经过一段时间摸索，也慢慢能理解为什么要那么复杂了，这的确不是特别容易入门。所以对整体的流程进行了一个拆解，尽量原子化一点，对自己学习的一个总结，也希望能帮助到一部分人能对  LayoutManager 入门。</p>\n<p>本文最终实现一个简单的 LinearLayoutManager（只支持 VERTICAL）方向，适合对 LayoutManager 整体流程的学习与理解，整体代码分为多个文件，每个文件都是对前一段代码的补充，方便理解，整体项目源码已提交 Github: <a href=\"https://github.com/VomPom/LayoutManagerGradually\">LayoutManagerGradually</a>，代码里面写了很多很多注释，如果不想浪费时间，可以直接看代码运行，跳过这篇文章，把每一个 LayoutManager 都跑一下体验结合代码看看。</p>\n<h2 id=\"自定义-LayoutManager-的必要元素\"><a href=\"#自定义-LayoutManager-的必要元素\" class=\"headerlink\" title=\"自定义 LayoutManager 的必要元素\"></a>自定义 LayoutManager 的必要元素</h2><ul>\n<li><p>继承 <code>RecyclerView.LayoutManager</code> 并实现 <code>generateDefaultLayoutParams() </code>方法</p>\n</li>\n<li><p>重写<code>onLayoutChildren</code> 第一次数据填充的时候数据添加</p>\n</li>\n<li><p>重写 <code>canScrollHorizontally()</code> 和<code>canScrollVertically()</code>方法设定支持滑动的方向</p>\n</li>\n<li><p>重写 <code>scrollHorizontallyBy()</code>和<code>scrollVerticallyBy()</code>方法，在滑动的时候对屏幕以外的 View 进行回收，以及填充即将滑动进入屏幕范围内的 View 进行填充</p>\n</li>\n<li><p>重写 <code>scrollToPosition()</code>和<code>smoothScrollToPosition()</code>方法支持</p>\n</li>\n</ul>\n<p>其中<code>onLayoutChildren</code> 和 <code>scrollHorizontallyBy/scrollVerticallyBy</code> 是最核心且最复杂的方法，这里稍微拎出来讲一下</p>\n<h3 id=\"onLayoutChildren\"><a href=\"#onLayoutChildren\" class=\"headerlink\" title=\"onLayoutChildren\"></a>onLayoutChildren</h3><p>这个方法类似于自定义 ViewGroup 的 onLayout() 方法，RecyclerView 的 LayoutManager.onLayoutChildren 在以下几个时机会被触发：</p>\n<ul>\n<li>当 <code>RecyclerView</code> 首次附加到窗口时</li>\n<li>当<code>Adapter</code>  的数据集发生变化</li>\n<li>当 <code>RecyclerView</code> 被 执行 <code>RequetLayout</code>的时候</li>\n<li>当 <code>LayoutManager</code> 发生变化时</li>\n</ul>\n<h3 id=\"scrollHorizontallyBy-scrollVerticallyBy\"><a href=\"#scrollHorizontallyBy-scrollVerticallyBy\" class=\"headerlink\" title=\"scrollHorizontallyBy&#x2F;scrollVerticallyBy\"></a>scrollHorizontallyBy&#x2F;scrollVerticallyBy</h3><p>方法的主要作用包括：</p>\n<ol>\n<li><p>更新 ItemView 的位置：根据传入的垂直滚动距离（dy 参数），更新子视图在屏幕上的位置。通常调用 <code>offsetChildrenVertical</code> 方法。</p>\n</li>\n<li><p>回收不可见的 ItemView：在滚动过程中，一些 ItemView 可能会离开屏幕，变得不可见。<code>scrollVerticallyBy</code> 方法需要负责回收这些子视图并将它们放入回收池，以便稍后复用。</p>\n</li>\n<li><p>添加新的 ItemView：在滚动过程中，新的 ItemView 可能需要显示在屏幕上。<code>scrollVerticallyBy</code> 方法需要从回收池中获取可复用的视图并将它们添加到屏幕上。这通常涉及到调用 <code>RecyclerView.Recycler</code> 的 <code>getViewForPosition</code> 方法。</p>\n</li>\n<li><p>返回实际滚动距离：由于 ItemView 的数量有限，滚动可能会受到限制。例如，当滚动到列表顶部或底部时，滚动可能会停止。在这种情况下，实际滚动的距离可能会小于传入的 <code>dy</code> 参数。<code>scrollVerticallyBy</code> 方法需要返回实际滚动的距离，以便 <code>RecyclerView</code> 可以正确地更新滚动条和触发滚动事件。</p>\n</li>\n</ol>\n<p>概念就简单讲这么多， talk is cheap show me the code，直接看代码理解会比较深刻</p>\n<h2 id=\"逐步实现\"><a href=\"#逐步实现\" class=\"headerlink\" title=\"逐步实现\"></a>逐步实现</h2><p>要实现一个可用的 LayoutManger 通常我们需要实现以下流程</p>\n<ul>\n<li>数据填充并且只需要填充屏幕范围内的 ItemView</li>\n<li>回收掉屏幕以外的 ItemView</li>\n<li>屏幕外 ItemView 再回到屏幕后，需要重新填充</li>\n<li>对滑动边界边界进行处理</li>\n<li>对 scrollToPosition 和 smoothScrollToPosition进行支持</li>\n</ul>\n<p>我们不用一上来就实现最终的效果，而是一步一步来，看看 LayoutManger 是怎么渐渐地变化，最终能跑起来的。</p>\n<h3 id=\"0-最简单的-LayoutManager\"><a href=\"#0-最简单的-LayoutManager\" class=\"headerlink\" title=\"0 最简单的 LayoutManager\"></a>0 最简单的 LayoutManager</h3><p>代码查看：<a href=\"https://github.com/VomPom/LayoutManagerGradually/tree/main/layoutmanager/src/main/java/com/julis/layoutmanager/series/MostSimpleLayoutManager.kt\">MostSimpleLayoutManager</a>，我们关注 <code>onLayoutChildren</code> 方法:</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onLayoutChildren</span><span class=\"params\">(recycler: <span class=\"type\">RecyclerView</span>.<span class=\"type\">Recycler</span>, state: <span class=\"type\">RecyclerView</span>.<span class=\"type\">State</span>?)</span></span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 垂直方向的偏移量</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> offsetTop = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"comment\">// 实际业务中最好不要这样一次性加载所有的数据，这里只是最简单地演示一下整体是如何工作的</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (itemIndex <span class=\"keyword\">in</span> <span class=\"number\">0</span> until itemCount) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 从适配器获取与给定位置关联的视图</span></span><br><span class=\"line\">        <span class=\"keyword\">val</span> itemView = recycler.getViewForPosition(itemIndex)</span><br><span class=\"line\">        <span class=\"comment\">// 将视图添加到 RecyclerView 中</span></span><br><span class=\"line\">        addView(itemView)</span><br><span class=\"line\">        <span class=\"comment\">// 测量并布局视图</span></span><br><span class=\"line\">        measureChildWithMargins(itemView, <span class=\"number\">0</span>, <span class=\"number\">0</span>)</span><br><span class=\"line\">        <span class=\"comment\">// 拿到宽高（包括ItemDecoration）</span></span><br><span class=\"line\">        <span class=\"keyword\">val</span> width = getDecoratedMeasuredWidth(itemView)</span><br><span class=\"line\">        <span class=\"keyword\">val</span> height = getDecoratedMeasuredHeight(itemView)</span><br><span class=\"line\">        <span class=\"comment\">// 对要添加的子 View 进行布局</span></span><br><span class=\"line\">        layoutDecorated(itemView, <span class=\"number\">0</span>, offsetTop, width, offsetTop + height)</span><br><span class=\"line\">        offsetTop += height</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面的代码主要演示了，如何利用<code>addView</code> <code>layoutDecorated</code>等方法，将 ItemView 添加到 RecyclerView 上。代码可见是 将所有的 ItemView（即使它在屏幕上不可见）一次性全部加载到了 RecyclerView上， 这里一般不这么做，只是这里这里只是最简单地演示一下整体是如何工作的。</p>\n<p>运行在手机上能看到这样的效果：Item数据已经被全部添加到界面上了，并且各个方向的滑动都支持。</p>\n<img src=\"https://cdn.julis.wang/blog/img/layoutmanager_gradually_0.gif?imageView2/2/w/300\">\n<h3 id=\"1-更合理的数据添加方式\"><a href=\"#1-更合理的数据添加方式\" class=\"headerlink\" title=\"1 更合理的数据添加方式\"></a>1 更合理的数据添加方式</h3><p>代码查看：<a href=\"https://github.com/VomPom/LayoutManagerGradually/tree/main/layoutmanager/src/main/java/com/julis/layoutmanager/series/LinearLayoutManager1\">LinearLayoutManager1.kt</a></p>\n<p>对最开始的代码进行优化，只在屏幕范围内的区域进行数据的添加，这样就不需要一次性将所有数据就添加上去，如果 Adapter 的 ItemCount 足够巨大，for all addView 的话，很容易就 OOM。</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onLayoutChildren</span><span class=\"params\">(recycler: <span class=\"type\">RecyclerView</span>.<span class=\"type\">Recycler</span>, state: <span class=\"type\">RecyclerView</span>.<span class=\"type\">State</span>)</span></span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 垂直方向上的的空间大小</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> remainSpace = height - paddingTop</span><br><span class=\"line\">    <span class=\"comment\">//垂直方向的偏移量</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> offsetTop = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> currentPosition = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (remainSpace &gt; <span class=\"number\">0</span> &amp;&amp; currentPosition &lt; state.itemCount) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 从适配器获取与给定位置关联的视图</span></span><br><span class=\"line\">        <span class=\"keyword\">val</span> itemView = recycler.getViewForPosition(currentPosition)</span><br><span class=\"line\">        <span class=\"comment\">// 将视图添加到 RecyclerView 中</span></span><br><span class=\"line\">        addView(itemView)</span><br><span class=\"line\">        <span class=\"comment\">// 测量并布局视图</span></span><br><span class=\"line\">        measureChildWithMargins(itemView, <span class=\"number\">0</span>, <span class=\"number\">0</span>)</span><br><span class=\"line\">        <span class=\"comment\">// 拿到宽高（包括ItemDecoration）</span></span><br><span class=\"line\">        <span class=\"keyword\">val</span> itemWidth = getDecoratedMeasuredWidth(itemView)</span><br><span class=\"line\">        <span class=\"keyword\">val</span> itemHeight = getDecoratedMeasuredHeight(itemView)</span><br><span class=\"line\">        <span class=\"comment\">// 对要添加的子 View 进行布局</span></span><br><span class=\"line\">        layoutDecorated(itemView, <span class=\"number\">0</span>, offsetTop, itemWidth, offsetTop + itemHeight)</span><br><span class=\"line\">        offsetTop += itemHeight</span><br><span class=\"line\">        currentPosition++</span><br><span class=\"line\">        <span class=\"comment\">// 可用空间减少</span></span><br><span class=\"line\">        remainSpace -= itemHeight</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"2-对屏幕外的View回收\"><a href=\"#2-对屏幕外的View回收\" class=\"headerlink\" title=\"2 对屏幕外的View回收\"></a>2 对屏幕外的View回收</h3><p>代码查看：<a href=\"https://github.com/VomPom/LayoutManagerGradually/tree/main/layoutmanager/src/main/java/com/julis/layoutmanager/series/LinearLayoutManager2.kt\">LinearLayoutManager2</a></p>\n<p>RecylerView 没有 recycler 怎么行呢？当 RecylerView 的 ItemView 滑出屏幕后我们需要对齐进行回收，实现的话需要在 <code>scrollVerticallyBy</code>中，比较复杂的逻辑就是怎么去判断：ItemView 在屏幕以外，最后利用：<code>removeAndRecycleView</code>方法进行回收</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">scrollVerticallyBy</span><span class=\"params\">(dy: <span class=\"type\">Int</span>, recycler: <span class=\"type\">RecyclerView</span>.<span class=\"type\">Recycler</span>, state: <span class=\"type\">RecyclerView</span>.<span class=\"type\">State</span>?)</span></span>: <span class=\"built_in\">Int</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 在这里处理上下的滚动逻辑，dy 表示滚动的距离</span></span><br><span class=\"line\">      <span class=\"comment\">// 平移所有子视图</span></span><br><span class=\"line\">      offsetChildrenVertical(-dy)</span><br><span class=\"line\">      <span class=\"comment\">// 如果实际滚动距离与 dy 相同，返回 dy；如果未滚动，返回 0</span></span><br><span class=\"line\">      recycleInvisibleView(dy, recycler)</span><br><span class=\"line\">      <span class=\"keyword\">return</span> dy</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 回收掉在界面上看不到的 ItemView</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> dy</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> recycler</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">recycleInvisibleView</span><span class=\"params\">(dy: <span class=\"type\">Int</span>, recycler: <span class=\"type\">RecyclerView</span>.<span class=\"type\">Recycler</span>)</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">val</span> totalSpace = orientationHelper.totalSpace</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 将要回收View的集合</span></span><br><span class=\"line\">    <span class=\"keyword\">val</span> recycleViews = hashSetOf&lt;View&gt;()</span><br><span class=\"line\">    <span class=\"comment\">// 从下往上滑</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (dy &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (i <span class=\"keyword\">in</span> <span class=\"number\">0</span> until childCount) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">val</span> child = getChildAt(i)!!</span><br><span class=\"line\">            <span class=\"comment\">// 从下往上滑从最上面的 item 开始计算</span></span><br><span class=\"line\">            <span class=\"keyword\">val</span> top = getDecoratedTop(child)</span><br><span class=\"line\">            <span class=\"comment\">// 判断最顶部的 item 是否已经完全不可见，如何可见，那说明底下的 item 也是可见</span></span><br><span class=\"line\">            <span class=\"keyword\">val</span> height = top - getDecoratedBottom(child)</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (height - top &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">break</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            recycleViews.add(child)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (dy &lt; <span class=\"number\">0</span>) &#123;   <span class=\"comment\">// 从上往下滑</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (i <span class=\"keyword\">in</span> childCount - <span class=\"number\">1</span> downTo <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">val</span> child = getChildAt(i)!!</span><br><span class=\"line\">            <span class=\"comment\">// 从上往下滑从最底部的 item 开始计算</span></span><br><span class=\"line\">            <span class=\"keyword\">val</span> bottom = getDecoratedBottom(child)</span><br><span class=\"line\">            <span class=\"comment\">// 判断最底部的 item 是否已经完全不可见，如何可见，那说明上面的 item 也是可见</span></span><br><span class=\"line\">            <span class=\"keyword\">val</span> height = bottom - getDecoratedTop(child)</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (bottom - totalSpace &lt; height) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">break</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            recycleViews.add(child)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 真正把 View 移除掉的逻辑</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (view <span class=\"keyword\">in</span> recycleViews) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// [removeAndRecycleView]</span></span><br><span class=\"line\">        <span class=\"comment\">// 用于从视图层次结构中删除某个视图，并将其资源回收，以便在需要时重新利用</span></span><br><span class=\"line\">        removeAndRecycleView(view, recycler)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    recycleViews.clear()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>运行在手机上能看到这样的效果：滑出屏幕外的ItemView 被回收掉了</p>\n<img src=\"https://cdn.julis.wang/blog/img/layoutmanager_gradually_2.gif?imageView2/2/w/300\">\n\n<h3 id=\"3-向上滑动的时View的填充\"><a href=\"#3-向上滑动的时View的填充\" class=\"headerlink\" title=\"3 向上滑动的时View的填充\"></a>3 向上滑动的时View的填充</h3><p>代码查看：<a href=\"https://github.com/VomPom/LayoutManagerGradually/tree/main/layoutmanager/src/main/java/com/julis/layoutmanager/series/LinearLayoutManager3.kt\">LinearLayoutManager3</a></p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">scrollVerticallyBy</span><span class=\"params\">(dy: <span class=\"type\">Int</span>, recycler: <span class=\"type\">RecyclerView</span>.<span class=\"type\">Recycler</span>, state: <span class=\"type\">RecyclerView</span>.<span class=\"type\">State</span>?)</span></span>: <span class=\"built_in\">Int</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 填充 view</span></span><br><span class=\"line\">    fillView(dy, recycler)</span><br><span class=\"line\">    <span class=\"comment\">// 移动 view</span></span><br><span class=\"line\">    offsetChildrenVertical(-dy)</span><br><span class=\"line\">    <span class=\"comment\">// 回收 View</span></span><br><span class=\"line\">    recycleInvisibleView(dy, recycler)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> dy</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 填充重新进入屏幕内的 ItemView</span></span><br><span class=\"line\"><span class=\"comment\"> *     getChildCount():childCount-&gt; 当前屏幕内RecyclerView展示的 ItemView 数量</span></span><br><span class=\"line\"><span class=\"comment\"> *     getItemCount():itemCount-&gt; 最大的 ItemView 数量，也就是 Adapter 传递的数据的数量</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">fillView</span><span class=\"params\">(dy: <span class=\"type\">Int</span>, recycler: <span class=\"type\">RecyclerView</span>.<span class=\"type\">Recycler</span>)</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">val</span> verticalSpace = orientationVerticalHelper.totalSpace</span><br><span class=\"line\">    <span class=\"keyword\">var</span> remainSpace = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> nextFillPosition = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"comment\">//垂直方向的偏移量</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> offsetTop = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> offsetLeft = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"comment\">// 从下往上滑，那么需要向底部添加数据</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (dy &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">val</span> anchorView = getChildAt(childCount - <span class=\"number\">1</span>) ?: <span class=\"keyword\">return</span></span><br><span class=\"line\">        <span class=\"keyword\">val</span> anchorPosition = getPosition(anchorView)</span><br><span class=\"line\">        <span class=\"keyword\">val</span> anchorBottom = getDecoratedBottom(anchorView)</span><br><span class=\"line\">        <span class=\"keyword\">val</span> anchorLeft = getDecoratedLeft(anchorView)</span><br><span class=\"line\">        remainSpace = verticalSpace - anchorBottom</span><br><span class=\"line\">        <span class=\"comment\">// 垂直可用的数据为&lt;0，意外着这时候屏幕底部的位置刚好在最底部的 ItemView 上，还需要向上滑动一点点...我们才能添加 View</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (remainSpace &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        nextFillPosition = anchorPosition + <span class=\"number\">1</span></span><br><span class=\"line\">        offsetTop = anchorBottom</span><br><span class=\"line\">        offsetLeft = anchorLeft</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (nextFillPosition &gt;= itemCount) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (dy &lt; <span class=\"number\">0</span>) &#123;  <span class=\"comment\">// 从上往下滑，那么需要向顶部添加数据</span></span><br><span class=\"line\">        <span class=\"comment\">//no-op 暂时不实现从上往下滑的底部数据填充</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (remainSpace &gt; <span class=\"number\">0</span> &amp;&amp; nextFillPosition &lt; itemCount) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 从适配器获取与给定位置关联的视图</span></span><br><span class=\"line\">        <span class=\"keyword\">val</span> itemView = recycler.getViewForPosition(nextFillPosition)</span><br><span class=\"line\">        <span class=\"comment\">// 将视图添加到 RecyclerView 中</span></span><br><span class=\"line\">        addView(itemView)</span><br><span class=\"line\">        <span class=\"comment\">// 测量并布局视图</span></span><br><span class=\"line\">        measureChildWithMargins(itemView, <span class=\"number\">0</span>, <span class=\"number\">0</span>)</span><br><span class=\"line\">        <span class=\"comment\">// 拿到宽高（包括ItemDecoration）</span></span><br><span class=\"line\">        <span class=\"keyword\">val</span> itemWidth = getDecoratedMeasuredWidth(itemView)</span><br><span class=\"line\">        <span class=\"keyword\">val</span> itemHeight = getDecoratedMeasuredHeight(itemView)</span><br><span class=\"line\">        <span class=\"comment\">// 对要添加的子 View 进行布局，相比onLayoutChildren 里面的实现添加了：offsetLeft（因为我们没有禁止掉 左右的滑动）</span></span><br><span class=\"line\">        <span class=\"comment\">// 试着把 offsetLeft 改成0，也就是最原始的样子，然后左右上下滑滑，你会有意外收获</span></span><br><span class=\"line\">        layoutDecorated(itemView, offsetLeft, offsetTop, itemWidth + offsetLeft, offsetTop + itemHeight)</span><br><span class=\"line\">        offsetTop += itemHeight</span><br><span class=\"line\">        nextFillPosition++</span><br><span class=\"line\">        <span class=\"comment\">// 可用空间减少</span></span><br><span class=\"line\">        remainSpace -= itemHeight</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>运行在手机上能看到这样的效果：向上滑动的时候，底部陆续有元素填充，但向下滑动的时候没有填充数据</p>\n<img src=\"https://cdn.julis.wang/blog/img/layoutmanager_gradually_3.gif?imageView2/2/w/300\">\n<h3 id=\"4-两个方向的View填充\"><a href=\"#4-两个方向的View填充\" class=\"headerlink\" title=\"4 两个方向的View填充\"></a>4 两个方向的View填充</h3><p>代码查看：<a href=\"https://github.com/VomPom/LayoutManagerGradually/tree/main/layoutmanager/src/main/java/com/julis/layoutmanager/series/LinearLayoutManager4.kt\">LinearLayoutManager4</a></p>\n<p>补齐从上往下滑之后添加的逻辑</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">fillView</span><span class=\"params\">(dy: <span class=\"type\">Int</span>, recycler: <span class=\"type\">RecyclerView</span>.<span class=\"type\">Recycler</span>)</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">val</span> verticalSpace = orientationVerticalHelper.totalSpace</span><br><span class=\"line\">    <span class=\"keyword\">var</span> remainSpace = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> nextFillPosition = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"comment\">//垂直方向的偏移量</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> offsetTop = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> offsetLeft = <span class=\"number\">0</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 从下往上滑，那么需要向底部添加数据</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (dy &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        ……</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (dy &lt; <span class=\"number\">0</span>) &#123;  <span class=\"comment\">// 从上往下滑，那么需要向顶部添加数据</span></span><br><span class=\"line\">        <span class=\"keyword\">val</span> anchorView = getChildAt(<span class=\"number\">0</span>) ?: <span class=\"keyword\">return</span></span><br><span class=\"line\">        <span class=\"keyword\">val</span> anchorPosition = getPosition(anchorView)</span><br><span class=\"line\">        <span class=\"keyword\">val</span> anchorTop = getDecoratedTop(anchorView)</span><br><span class=\"line\">        offsetLeft = getDecoratedLeft(anchorView)</span><br><span class=\"line\">        remainSpace = anchorTop</span><br><span class=\"line\">        <span class=\"comment\">// 垂直可用的数据为&lt;0，意外着这时候屏幕顶部的位置刚好在最底部的 ItemView 上，还需要向下滑动一点点...我们才能添加 View</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (anchorTop &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        nextFillPosition = anchorPosition - <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (nextFillPosition &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">val</span> itemHeight = getDecoratedMeasuredHeight(anchorView)</span><br><span class=\"line\">        <span class=\"comment\">// 新的布局的itemView 的顶部位置应该以 anchorTop - itemHeight 开始</span></span><br><span class=\"line\">        offsetTop = anchorTop - itemHeight</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (remainSpace &gt; <span class=\"number\">0</span> &amp;&amp;</span><br><span class=\"line\">        ((nextFillPosition &lt; itemCount) &amp;&amp; (nextFillPosition &gt;= <span class=\"number\">0</span>))</span><br><span class=\"line\">    ) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 从适配器获取与给定位置关联的视图</span></span><br><span class=\"line\">        <span class=\"keyword\">val</span> itemView = recycler.getViewForPosition(nextFillPosition)</span><br><span class=\"line\">        <span class=\"comment\">// 将视图添加到 RecyclerView 中k，从顶部添加的话，需要加到最前的位置</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (dy &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            addView(itemView)</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            addView(itemView, <span class=\"number\">0</span>)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        ……</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (dy &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            offsetTop += itemHeight</span><br><span class=\"line\">            nextFillPosition++</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            offsetTop -= itemHeight</span><br><span class=\"line\">            nextFillPosition--</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 可用空间减少</span></span><br><span class=\"line\">        remainSpace -= itemHeight</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>运行在手机上能看到这样的效果：向上或者滑动的时候，底部陆续都有元素填充</p>\n<img src=\"https://cdn.julis.wang/blog/img/layoutmanager_gradually_4.gif?imageView2/2/w/300\">\n<h3 id=\"5-对顶部和底部滑动边界处理\"><a href=\"#5-对顶部和底部滑动边界处理\" class=\"headerlink\" title=\"5 对顶部和底部滑动边界处理\"></a>5 对顶部和底部滑动边界处理</h3><p>代码查看：<a href=\"https://github.com/VomPom/LayoutManagerGradually/tree/main/layoutmanager/src/main/java/com/julis/layoutmanager/series/LinearLayoutManager5.kt\">LinearLayoutManager5</a></p>\n<p>对于前面的实现会发现会：不停地下滑或者上滑会留出来巨大的空白。这里对填充 View 的逻辑进行改造，需要进行边界检测。</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">scrollVerticallyBy</span><span class=\"params\">(dy: <span class=\"type\">Int</span>, recycler: <span class=\"type\">RecyclerView</span>.<span class=\"type\">Recycler</span>, state: <span class=\"type\">RecyclerView</span>.<span class=\"type\">State</span>?)</span></span>: <span class=\"built_in\">Int</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 填充 view</span></span><br><span class=\"line\">    <span class=\"keyword\">val</span> adjustedDy = fillView(dy, recycler)</span><br><span class=\"line\">    <span class=\"comment\">// 移动 view</span></span><br><span class=\"line\">    offsetChildrenVertical(-adjustedDy)</span><br><span class=\"line\">    <span class=\"comment\">// 回收 View</span></span><br><span class=\"line\">    recycleInvisibleView(adjustedDy, recycler)</span><br><span class=\"line\">    <span class=\"comment\">// 由于需要对边界进行限制，所以需要对原始的 dy 进行修正，这里不再直接返回 dy</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> adjustedDy</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>这里的整体注释我写在了代码里面，可以看图稍微理解一下，以向上滑动为例：假设这一次滑动的距离非常非常大(想象成10000像素)，如果直接滑动的话，我们有50个元素，每个元素高度100像素，最大高度也只有50x100&#x3D;5000，那么滑动后一定会留下大量空区域。需要对当前传入的这 10000 像素做调整：只给到可滑动的最大距离，如果不能滑动了就返回0。</p>\n<img src=\"https://cdn.julis.wang/blog/img/5_scroll_limit.png\">\n<p>运行在手机上能看到这样的效果：向上或者滑动的时候，达到最大的位置时候是不能再滑动的。</p>\n<img src=\"https://cdn.julis.wang/blog/img/layoutmanager_gradually_5.gif?imageView2/2/w/300\">\n<h3 id=\"6-实现-scrollToPosition\"><a href=\"#6-实现-scrollToPosition\" class=\"headerlink\" title=\"6 实现 scrollToPosition\"></a>6 实现 scrollToPosition</h3><p>代码查看：<a href=\"https://github.com/VomPom/LayoutManagerGradually/tree/main/layoutmanager/src/main/java/com/julis/layoutmanager/series/LinearLayoutManager6.kt\">LinearLayoutManager6</a></p>\n<p>到这里这个 LinearLayoutManager 看着已经能正常运行了，但一般还需要支持<code>scrollToPosition</code> 和 <code>smoothScrollToPositio</code></p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">var</span> mPendingScrollPosition = RecyclerView.NO_POSITION</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">scrollToPosition</span><span class=\"params\">(position: <span class=\"type\">Int</span>)</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>.scrollToPosition(position)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (position &lt; <span class=\"number\">0</span> || position &gt;= itemCount) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    mPendingScrollPosition = position</span><br><span class=\"line\">    requestLayout()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onLayoutChildren</span><span class=\"params\">(recycler: <span class=\"type\">RecyclerView</span>.<span class=\"type\">Recycler</span>, state: <span class=\"type\">RecyclerView</span>.<span class=\"type\">State</span>)</span></span> &#123;</span><br><span class=\"line\">    ……</span><br><span class=\"line\">    <span class=\"keyword\">var</span> currentPosition = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mPendingScrollPosition != RecyclerView.NO_POSITION) &#123;</span><br><span class=\"line\">        currentPosition = mPendingScrollPosition</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (remainSpace &gt; <span class=\"number\">0</span> &amp;&amp; currentPosition &lt; state.itemCount) &#123;</span><br><span class=\"line\">      …… <span class=\"comment\">// 填充View 的逻辑</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>scrollToPosition</code> 的实现比较简单，如上代码所示：在 <code>scrollToPosition</code>  的时候记录一次目标position，再 requestLayout 一波，还记得之前有提到过：<code>onLayoutChildren</code> 会在 <code>requestLayout</code> 的时候调用一次，于是再将<code>onLayoutChildren</code>逻辑改写，不再从第0个元素开始，而是从目标位置进行布局。</p>\n<p>运行在手机上能看到这样的效果：点击 scrollTo30 将会滑动到 第30个位置。</p>\n<img src=\"https://cdn.julis.wang/blog/img/layoutmanager_gradually_6.gif?imageView2/2/w/300\">\n<h3 id=\"7-实现-smoothScrollToPosition\"><a href=\"#7-实现-smoothScrollToPosition\" class=\"headerlink\" title=\"7 实现 smoothScrollToPosition\"></a>7 实现 smoothScrollToPosition</h3><p>代码查看：<a href=\"https://github.com/VomPom/LayoutManagerGradually/tree/main/layoutmanager/src/main/java/com/julis/layoutmanager/series/LinearLayoutManager7.kt\">LinearLayoutManager7</a>  </p>\n<p>要实现自定义的 smoothScrollToPosition 动画效果，这一块如果要完全自己实现的话比较复杂，可以直接使用系统提供的 LinearSmoothScroller改造,也可以继承 RecyclerView.SmoothScroller 自定义，也可以完全不使用 SmoothScroller， 照着 SmoothScroller 的实现使用类似 ValueAnimator 自定义动画，添加动画 UpdateListener，在 onAnimationUpdate 的时候动态计算布局从而实现滑动动画,这里拿 LinearSmoothScroller 举例:</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">smoothScrollToPosition</span><span class=\"params\">(</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">    recyclerView: <span class=\"type\">RecyclerView</span>,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">    state: <span class=\"type\">RecyclerView</span>.<span class=\"type\">State</span>,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">    position: <span class=\"type\">Int</span></span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">)</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (position &gt;= itemCount || position &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">val</span> scroller: LinearSmoothScroller = <span class=\"keyword\">object</span> : LinearSmoothScroller(recyclerView.context) &#123;</span><br><span class=\"line\">        <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">         * 这个方法用于计算滚动到目标位置所需的滚动向量。滚动向量是一个二维向量，包含水平和垂直方向上的滚动距离</span></span><br><span class=\"line\"><span class=\"comment\">         *</span></span><br><span class=\"line\"><span class=\"comment\">         * <span class=\"doctag\">@param</span> targetPosition 滑动的目标位置</span></span><br><span class=\"line\"><span class=\"comment\">         * <span class=\"doctag\">@return</span>  返回一个 PointF 对象，表示滚动向量。</span></span><br><span class=\"line\"><span class=\"comment\">         *              PointF.x 表示水平方向上的滚动距离，</span></span><br><span class=\"line\"><span class=\"comment\">         *              PointF.y 表示垂直方向上的滚动距离</span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\">        <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">computeScrollVectorForPosition</span><span class=\"params\">(targetPosition: <span class=\"type\">Int</span>)</span></span>: PointF &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 查找到屏幕里显示的第 1 个元素与</span></span><br><span class=\"line\">            <span class=\"keyword\">val</span> firstChildPos = getPosition(getChildAt(<span class=\"number\">0</span>)!!)</span><br><span class=\"line\">            <span class=\"keyword\">val</span> direction = <span class=\"keyword\">if</span> (targetPosition &lt; firstChildPos) -<span class=\"number\">1</span> <span class=\"keyword\">else</span> <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"comment\">// x 左右滑动，由于我们只实现了垂直的滑动，所以 x方向为0即可</span></span><br><span class=\"line\">            <span class=\"comment\">// 整数代表正向移动，负数代表反向移动，这里的数值大小不重要，源码里面最终都会 normalize 归一化处理</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> PointF(<span class=\"number\">0f</span>, direction.toFloat())</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">         * 计算每像素速度</span></span><br><span class=\"line\"><span class=\"comment\">         *</span></span><br><span class=\"line\"><span class=\"comment\">         * <span class=\"doctag\">@param</span> displayMetrics</span></span><br><span class=\"line\"><span class=\"comment\">         * <span class=\"doctag\">@return</span> 返回每一像素的耗时，单位ms，假设返回值是1.0 代表着：1ms 内会滑动 1像素，1s会滑动1000像素</span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\">        <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">calculateSpeedPerPixel</span><span class=\"params\">(displayMetrics: <span class=\"type\">DisplayMetrics</span>?)</span></span>: <span class=\"built_in\">Float</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">super</span>.calculateSpeedPerPixel(displayMetrics)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">         * 滑动速度的插值（实现滑动速度随着滑动时间的变化）</span></span><br><span class=\"line\"><span class=\"comment\">         *</span></span><br><span class=\"line\"><span class=\"comment\">         * <span class=\"doctag\">@param</span> dx</span></span><br><span class=\"line\"><span class=\"comment\">         * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\">        <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">calculateTimeForDeceleration</span><span class=\"params\">(dx: <span class=\"type\">Int</span>)</span></span>: <span class=\"built_in\">Int</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">super</span>.calculateTimeForDeceleration(dx)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 很多方法可以使用，不再一一列举</span></span><br><span class=\"line\">        <span class=\"comment\">// ...</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    scroller.targetPosition = position</span><br><span class=\"line\">    <span class=\"comment\">// 执行默认动画的逻辑</span></span><br><span class=\"line\">    startSmoothScroll(scroller)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>运行在手机上能看到这样的效果：点击 smoothScrollTo30 将会有个动画效果滑动到第30个位置。</p>\n<img src=\"https://cdn.julis.wang/blog/img/layoutmanager_gradually_7.gif?imageView2/2/w/300\">\n<p>以上基本上一个自定义 LayoutManager 的雏形就已经完成了，虽然只实现了一个方向的滑动，但是其原理都是一样的，剩下的就是各种细节的打磨了，可以加各种自己想要的效果，比如：指定位置 放大一定的系数，或者更炫酷的滑动动画…</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>本文主要整理了自定义 LayoutManager 的必要元素，以及其核心方法 scrollHorizontallyBy&#x2F;scrollVerticallyBy、onLayoutChildren 的作用与调用时机，接下对实现一个简单的 LinearLayoutManger 进行逻辑拆解，从最简单的不滑动回收和填充以及不含滑动边界检测，到最终一个具备基本功能的 LayoutManger</p>\n<p>源码：<a href=\"https://github.com/VomPom/LayoutManagerGradually\">https://github.com/VomPom/LayoutManagerGradually</a></p>\n<p>参考：</p>\n<p><a href=\"https://juejin.cn/post/6870770285247725581?searchId=202310181005138A6D82B1DEE9C47A9797#heading-23\">《看完这篇文章你还不会自定义LayoutManager，我吃X！》</a></p>\n<p><a href=\"https://github.com/MycroftWong/FlowLayoutManager/blob/master/LayoutManager%E5%88%86%E6%9E%90%E4%B8%8E%E5%AE%9E%E8%B7%B5.md\">《&#x2F;LayoutManager分析与实践》</a></p>\n<p><a href=\"https://wiresareobsolete.com/2014/09/building-a-recyclerview-layoutmanager-part-1/\">Building a RecyclerView LayoutManager – Part 1</a></p>\n","categories":[],"tags":[{"name":"技术文章","slug":"technology","api":"api/tags/technology.json"}],"api":"api/posts/2023/10/31/自定义LayoutManager从0到1实践.json"},{"title":"Android 基于 J2V8 运行 JavasScript  实践","slug":"Android-J2V8-实践","date":"2023-09-30T13:11:00.000Z","updated":"2025-05-20T11:46:57.000Z","comments":true,"url":"2023/09/30/Android-J2V8-实践/","excerpt":"<p>V8 引擎是由 Google 开源的 JavaScript 引擎，Chrome 就是基于 V8 开发，V8 是跨平台的，J2V8 基于 V8 进行开发，使得 js 代码能够在 Android 平台上脱离 WebView 运行。目前，也有很多关于 Android J2V8 的文章，不过讲解不是特别细（可能也是我太菜了，看完了之后，依然遇到很多问题），自己在调研的过程中遇到很多坑，所以这里记录一下，本文主要记录整个 J2V8 框架的使用方法，以及一些坑。</p>\n<h2 id=\"一、Webpack-打包\"><a href=\"#一、Webpack-打包\" class=\"headerlink\" title=\"一、Webpack 打包\"></a>一、Webpack 打包</h2><p>通常业务逻辑的 js 文件是有多个的，我们需要借助一些打包工具将多个文件打包成一个 js 文件供 J2V8 使用，我们可以使用 Gulp、Webpack、Browserify，本文主要讲 Webpack 的使用。<br>主要流程如下：</p>\n<p><strong>编写基础逻辑并通过 <code>module.exports</code> 对外部提供</strong></p>\n<p><strong>编写 <code>index.js</code> 入口文件</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\">...</span><br><span class=\"line\"><span class=\"variable language_\">module</span>.<span class=\"property\">exports</span> = &#123;</span><br><span class=\"line\">  simpleFunc, complexFunc</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>** 编写<code>webpack.config</code>打包配置**</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"variable language_\">module</span>.<span class=\"property\">exports</span> = &#123;</span><br><span class=\"line\">  <span class=\"attr\">entry</span>: <span class=\"string\">&#x27;./src/example/index.js&#x27;</span>,</span><br><span class=\"line\">  <span class=\"attr\">output</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">library</span>: <span class=\"string\">&#x27;libExample&#x27;</span>,                 <span class=\"comment\">// j2v8 加载该lib</span></span><br><span class=\"line\">    <span class=\"attr\">path</span>: path.<span class=\"title function_\">resolve</span>(__dirname, <span class=\"string\">&#x27;dist&#x27;</span>),</span><br><span class=\"line\">    <span class=\"attr\">filename</span>: <span class=\"string\">&#x27;example.js&#x27;</span>,                <span class=\"comment\">// 导出指定命名的 js 文件 </span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  ...</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p><strong>执行 <code>webpack</code> 打包命令</strong></p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">./node_modules/.bin/webpack --config webpack.config.js</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"二、运行-JavaScript\"><a href=\"#二、运行-JavaScript\" class=\"headerlink\" title=\"二、运行 JavaScript\"></a>二、运行 JavaScript</h2><p>到这里我们已经有一份通过 Webpack 打包好的 js 文件了，要在 j2v8 中运行 JavaScript 文件，使用以下步骤：</p>\n<p><strong>1、创建一个 V8 实例</strong></p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"code\"><pre><span class=\"line\">V8 v8 = V8.createV8Runtime();</span><br></pre></td></tr></table></figure>\n<p><strong>2、读取 JavaScript 文件</strong></p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> scriptStr = String(Files.readAllBytes(Paths.<span class=\"keyword\">get</span>(<span class=\"string\">&quot;example.js&quot;</span>)))</span><br></pre></td></tr></table></figure>\n<p><strong>3、在 V8 实例中执行 JavaScript 代码</strong></p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"code\"><pre><span class=\"line\">v8.executeScript(scriptStr);</span><br></pre></td></tr></table></figure>\n<p>这一步已经让整个 js 文件运行起来，但我们还不能调用我们的方法</p>\n<p><strong>4、读取指定模块</strong></p>\n<p>由于是通过 Webpack 打包，在 Webpack 的 <code>output.library</code> 配置，选项用于将打包后的代码作为一个库(library)暴露出去，以便其他应用程序或模块可以使用它。</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> rootLib =v8.getObject(libName); <span class=\"comment\">// 这里的 libName 就是 output.library 配置的名字</span></span><br></pre></td></tr></table></figure>\n<p>如果是访问模块的导出对象中的子对象，那么继续：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> subLib =rootLib.getObject(subLibName); <span class=\"comment\">// 这里的 subLibName 是 index 文件中 module.exports 里面的模块名</span></span><br></pre></td></tr></table></figure>\n<p> 如果子对象还有子对象，继续<code>.getObject</code> 即可</p>\n<p><strong>5、运行指定方法</strong></p>\n<p>接下来就简单了，直接通过如下方法执行 js 中的指定方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">executeVoidFunction</span><span class=\"params\">(String name, V8Array parameters)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> String <span class=\"title function_\">executeStringFunction</span><span class=\"params\">(String name, V8Array parameters)</span> </span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"type\">double</span> <span class=\"title function_\">executeDoubleFunction</span><span class=\"params\">(String name, V8Array parameters)</span> </span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">executeIntegerFunction</span><span class=\"params\">(String name, V8Array parameters)</span></span><br><span class=\"line\">……</span><br></pre></td></tr></table></figure>\n\n<p><code>V8Object</code> 提供了很多数据格式调用，不过都差不多，主要是在返回值那里帮你实现了数据的转化，如果不想用转化好的格式，希望自己来操作的话，使用<code>public V8Object executeObjectFunction() </code> 拿到返回值，自己去转化即可</p>\n<p><strong>6、释放资源</strong></p>\n<p>由于 V8 运行消耗较多的资源，执行结束的时候要将在过程中创建的所有的资源释放，避免导致内存泄漏。<br>V8提供了close方法，如果只使用 v8.close() 进行释放，或者未关闭过程中有用到 v8 runtime 的变量都会报如下错误，正确的做法是将所有资源进行关闭。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">java.lang.IllegalStateException: <span class=\"number\">3</span> Object(s) still exist in runtime</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"三、进阶\"><a href=\"#三、进阶\" class=\"headerlink\" title=\"三、进阶\"></a>三、进阶</h2><p>通过以上的方式已经能执行很多逻辑了，但在实践过过程中发现：如何 js 的返回值是 Promise 的话不会等到最终的结果给我们，而是直接返回了一个 Promise 对象，以及看不到 <code>console.log</code> 打印的日志…… 诸如此类的问题需要解决，这里主要讲讲这两种方法的实现。</p>\n<p><strong>注册 Native 插件</strong></p>\n<p>J2V8 是一个基于 V8 引擎的 Java 库，它允许在 Java 中执行 JavaScript 代码。由于 J2V8 是在 Java 中运行的，它没有直接访问浏览器或控制台的能力，因此无法直接使用 console.log 函数来输出日志，总结 <strong>J2V8 不能实现以下功能：</strong></p>\n<blockquote>\n<ul>\n<li>浏览器 API：j2v8 是在 Java 中运行的，因此无法直接访问浏览器 API，如 DOM、BOM 等。这意味着 j2v8 无法直接操作网页内容、处理事件等</li>\n<li>文件系统访问：j2v8 在 Java 中运行，无法直接访问文件系统。如果需要访问文件系统，需要使用 Java 提供的文件操作 API。</li>\n<li>定时器：JavaScript 中有多种定时器函数，如 setTimeout、setInterval 等，可以在指定时间后执行代码。但 j2v8 无法实现这些定时器函数，因为它无法直接访问系统的计时器。</li>\n<li>Web Worker：Web Worker 是 JavaScript 中的一个特殊对象，可以在后台线程中执行代码，以避免阻塞主线程。但 j2v8 无法实现 Web Worker，因为它无法直接访问操作系统的线程。</li>\n<li>Node.js API：j2v8 主要是为了在 Java 中执行浏览器端的 JavaScript 代码而设计的，因此无法直接访问 Node.js API。如果需要在 Java 中执行 Node.js 代码，可以考虑使用 Nashorn 等其他工具。</li>\n</ul>\n</blockquote>\n<p>这里是 <code>console.log</code>的一个简单实现：</p>\n<p><code>V8Object</code> 是 J2V8 中的一个类，它代表了一个 JavaScript 对象，对于 <code>console.log</code> 我们可以将 <code>console</code> 看作一个对象，其有一个叫 <code>log</code> 的方法，要实现在 js 中打印日志到 Android Studio 控制台，如下即可：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">ConsolePlugin</span> &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    fun <span class=\"title function_\">log</span><span class=\"params\">(message: Any)</span> &#123;</span><br><span class=\"line\">        Log.d(<span class=\"string\">&quot;ConsolePlugin&quot;</span>, message.toString())</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    fun <span class=\"title function_\">register</span><span class=\"params\">(v8: V8)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">val</span> <span class=\"variable\">v8Console</span> <span class=\"operator\">=</span> V8Object(v8)</span><br><span class=\"line\">        <span class=\"comment\">// 第一个 log 表示 在 Java 中该方法的名字，第二个 log 表示在 JavaScript 中调用的名字 </span></span><br><span class=\"line\">        v8Console.registerJavaMethod(<span class=\"built_in\">this</span>, <span class=\"string\">&quot;log&quot;</span>, <span class=\"string\">&quot;log&quot;</span>, arrayOf&lt;Class&lt;*&gt;&gt;(Any::class.java))</span><br><span class=\"line\">        v8Console.setWeak()</span><br><span class=\"line\">        <span class=\"comment\">// 将含有叫&quot;log&quot;方法的一个对象加到运行环境中，该对象被命名为 &quot;console&quot;</span></span><br><span class=\"line\">        v8.add(<span class=\"string\">&quot;console&quot;</span>, v8Console)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">ConsolePlugin().register(v8)</span><br></pre></td></tr></table></figure>\n\n<p>具体代码可参考:<a href=\"https://github.com/VomPom/J2V8_tutorial\">J2V8_tutorial</a></p>\n<h4 id=\"执行返回值是-Promise-类型的方法\"><a href=\"#执行返回值是-Promise-类型的方法\" class=\"headerlink\" title=\"执行返回值是 Promise 类型的方法\"></a>执行返回值是 Promise 类型的方法</h4><p>之前将的方法调用都是返回数据为基础类型，由于在 Java&#x2F;kotlin 中没有<code>Promise</code>类型的方法，所以对于 <code>Promise</code> 方法我们需要进行一些特殊处理，我们通过使用 <code>CountDownLatch</code> 可以来实现一个 “异步变同步” 的操作，我们需要考虑的是如何接受到 <code>resolve</code> <code>rejcet</code>的调用，js 中 Promise 的方法使用如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"title class_\">PromiseMethod</span>().<span class=\"title function_\">then</span>(<span class=\"function\">(<span class=\"params\">result</span>)=&gt;</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// success got result</span></span><br><span class=\"line\">  &#125;).<span class=\"title function_\">catch</span>(<span class=\"function\">(<span class=\"params\">e</span>)=&gt;</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// error...</span></span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>在 J2V8中一样的实现</p>\n<p><strong>获取返回的 Promise 对象</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">val</span> <span class=\"variable\">promiseObj</span> <span class=\"operator\">=</span> v8.executeFunction(functionName, v8Array) as V8Object</span><br></pre></td></tr></table></figure>\n<p>**执行 Promise 对象的 then 和 catch 方法 **</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">jsPromise.apply &#123;</span><br><span class=\"line\">        <span class=\"type\">val</span> <span class=\"variable\">onResolveParameter</span> <span class=\"operator\">=</span> V8Array(v8).push(onResolve)</span><br><span class=\"line\">        <span class=\"type\">val</span> <span class=\"variable\">onRejectParameter</span> <span class=\"operator\">=</span> V8Array(v8).push(onReject)</span><br><span class=\"line\">        executeVoidFunction(<span class=\"string\">&quot;then&quot;</span>, onResolveParameter)</span><br><span class=\"line\">        executeVoidFunction(<span class=\"string\">&quot;catch&quot;</span>, onRejectParameter)</span><br><span class=\"line\">        ....</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n<p>其中 onResolve</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">val</span> <span class=\"variable\">onResolve</span> <span class=\"operator\">=</span> V8Function(jsRuntime) &#123; receiver, parameters -&gt;</span><br><span class=\"line\">        ……</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n<p>具体代码可参考:<a href=\"https://github.com/VomPom/J2V8_tutorial\">J2V8_tutorial</a></p>\n<h2 id=\"四、总结\"><a href=\"#四、总结\" class=\"headerlink\" title=\"四、总结\"></a>四、总结</h2><p>以上基本上能解决大部分 Android 调用 js的代码逻辑了，这里对整体执行的流程进行一个总结</p>\n<p>1、通过 webpack 对多个 .js 文件打包<br>2、初始化 V8 环境并加载 .js 文件<br>3、注册 Java 方法，供 js 进行调用<br>4、读取指定的模板<br>5、执行目标 js 方法，并释放 v8 执行过程中产生的资源</p>\n<h3 id=\"踩过的一些坑\"><a href=\"#踩过的一些坑\" class=\"headerlink\" title=\"踩过的一些坑\"></a>踩过的一些坑</h3><p>1、<code>java.lang.UnsupportedOperationException: StartNodeJS Not Supported.</code></p>\n<p>这个库有一个 <code>NodeJS.createNodeJS()</code>方法，以为是完美结合 NodeJs 的，查了下不太支持 Android，不过也有人提出解决方法：<a href=\"https://stackoverflow.com/questions/42574824/how-to-use-nodejs-in-android-using-j2v8\">https://stackoverflow.com/questions/42574824/how-to-use-nodejs-in-android-using-j2v8</a></p>\n<p>2、<code>java.lang.IllegalStateException: 3 Object(s) still exist in runtime</code></p>\n<p>这是调用 &#96;v8.close&#96;&#96; 总是会遇到的问题，一定需要确保使用了 v8 Runtime 过程变量有被释放掉，可能有时候不知道具体哪个变量没有被释放</p>\n<p>3、<code>setTimeout、setInterval</code> 无效</p>\n<p>这是我最开始遇到的问题，简单想着“既然能执行js代码，那 setTimeout、setInterval 这些方法都是 js 最普通的方法应该没问题吧”，如果有一些平时在 js 很常见的操作如果无法执行，最好 check 一下 J2V8 是否支持</p>\n<p>4、Undefined 相关</p>\n<p>虽然源码里面通过了一个 Undefined 的类，但是不能直接使用，如果方法返回的 Undefined，通过 <code>V8Object</code> 的 <code>isUndefined()</code> 去判断</p>\n<h3 id=\"引用\"><a href=\"#引用\" class=\"headerlink\" title=\"引用\"></a>引用</h3><p>[1]J2V8 <a href=\"https://eclipsesource.com/blogs/tutorials/getting-started-with-j2v8/\">https://eclipsesource.com/blogs/tutorials/getting-started-with-j2v8/</a></p>\n<p>[2] Registering Java Callbacks with J2V8 <a href=\"https://eclipsesource.com/blogs/2015/06/06/registering-java-callbacks-with-j2v8/\">https://eclipsesource.com/blogs/2015/06/06/registering-java-callbacks-with-j2v8/</a></p>\n<p>[3] Simple JS in Node.js <a href=\"https://yenhuang.gitbooks.io/android-development-note/content/wrap-js-library/simple-js-with-nodejs.html\">https://yenhuang.gitbooks.io/android-development-note/content/wrap-js-library/simple-js-with-nodejs.html</a></p>\n","cover":null,"images":[],"content":"<p>V8 引擎是由 Google 开源的 JavaScript 引擎，Chrome 就是基于 V8 开发，V8 是跨平台的，J2V8 基于 V8 进行开发，使得 js 代码能够在 Android 平台上脱离 WebView 运行。目前，也有很多关于 Android J2V8 的文章，不过讲解不是特别细（可能也是我太菜了，看完了之后，依然遇到很多问题），自己在调研的过程中遇到很多坑，所以这里记录一下，本文主要记录整个 J2V8 框架的使用方法，以及一些坑。</p>\n<h2 id=\"一、Webpack-打包\"><a href=\"#一、Webpack-打包\" class=\"headerlink\" title=\"一、Webpack 打包\"></a>一、Webpack 打包</h2><p>通常业务逻辑的 js 文件是有多个的，我们需要借助一些打包工具将多个文件打包成一个 js 文件供 J2V8 使用，我们可以使用 Gulp、Webpack、Browserify，本文主要讲 Webpack 的使用。<br>主要流程如下：</p>\n<p><strong>编写基础逻辑并通过 <code>module.exports</code> 对外部提供</strong></p>\n<p><strong>编写 <code>index.js</code> 入口文件</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\">...</span><br><span class=\"line\"><span class=\"variable language_\">module</span>.<span class=\"property\">exports</span> = &#123;</span><br><span class=\"line\">  simpleFunc, complexFunc</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>** 编写<code>webpack.config</code>打包配置**</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"variable language_\">module</span>.<span class=\"property\">exports</span> = &#123;</span><br><span class=\"line\">  <span class=\"attr\">entry</span>: <span class=\"string\">&#x27;./src/example/index.js&#x27;</span>,</span><br><span class=\"line\">  <span class=\"attr\">output</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">library</span>: <span class=\"string\">&#x27;libExample&#x27;</span>,                 <span class=\"comment\">// j2v8 加载该lib</span></span><br><span class=\"line\">    <span class=\"attr\">path</span>: path.<span class=\"title function_\">resolve</span>(__dirname, <span class=\"string\">&#x27;dist&#x27;</span>),</span><br><span class=\"line\">    <span class=\"attr\">filename</span>: <span class=\"string\">&#x27;example.js&#x27;</span>,                <span class=\"comment\">// 导出指定命名的 js 文件 </span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  ...</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p><strong>执行 <code>webpack</code> 打包命令</strong></p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">./node_modules/.bin/webpack --config webpack.config.js</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"二、运行-JavaScript\"><a href=\"#二、运行-JavaScript\" class=\"headerlink\" title=\"二、运行 JavaScript\"></a>二、运行 JavaScript</h2><p>到这里我们已经有一份通过 Webpack 打包好的 js 文件了，要在 j2v8 中运行 JavaScript 文件，使用以下步骤：</p>\n<p><strong>1、创建一个 V8 实例</strong></p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"code\"><pre><span class=\"line\">V8 v8 = V8.createV8Runtime();</span><br></pre></td></tr></table></figure>\n<p><strong>2、读取 JavaScript 文件</strong></p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> scriptStr = String(Files.readAllBytes(Paths.<span class=\"keyword\">get</span>(<span class=\"string\">&quot;example.js&quot;</span>)))</span><br></pre></td></tr></table></figure>\n<p><strong>3、在 V8 实例中执行 JavaScript 代码</strong></p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"code\"><pre><span class=\"line\">v8.executeScript(scriptStr);</span><br></pre></td></tr></table></figure>\n<p>这一步已经让整个 js 文件运行起来，但我们还不能调用我们的方法</p>\n<p><strong>4、读取指定模块</strong></p>\n<p>由于是通过 Webpack 打包，在 Webpack 的 <code>output.library</code> 配置，选项用于将打包后的代码作为一个库(library)暴露出去，以便其他应用程序或模块可以使用它。</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> rootLib =v8.getObject(libName); <span class=\"comment\">// 这里的 libName 就是 output.library 配置的名字</span></span><br></pre></td></tr></table></figure>\n<p>如果是访问模块的导出对象中的子对象，那么继续：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> subLib =rootLib.getObject(subLibName); <span class=\"comment\">// 这里的 subLibName 是 index 文件中 module.exports 里面的模块名</span></span><br></pre></td></tr></table></figure>\n<p> 如果子对象还有子对象，继续<code>.getObject</code> 即可</p>\n<p><strong>5、运行指定方法</strong></p>\n<p>接下来就简单了，直接通过如下方法执行 js 中的指定方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">executeVoidFunction</span><span class=\"params\">(String name, V8Array parameters)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> String <span class=\"title function_\">executeStringFunction</span><span class=\"params\">(String name, V8Array parameters)</span> </span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"type\">double</span> <span class=\"title function_\">executeDoubleFunction</span><span class=\"params\">(String name, V8Array parameters)</span> </span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">executeIntegerFunction</span><span class=\"params\">(String name, V8Array parameters)</span></span><br><span class=\"line\">……</span><br></pre></td></tr></table></figure>\n\n<p><code>V8Object</code> 提供了很多数据格式调用，不过都差不多，主要是在返回值那里帮你实现了数据的转化，如果不想用转化好的格式，希望自己来操作的话，使用<code>public V8Object executeObjectFunction() </code> 拿到返回值，自己去转化即可</p>\n<p><strong>6、释放资源</strong></p>\n<p>由于 V8 运行消耗较多的资源，执行结束的时候要将在过程中创建的所有的资源释放，避免导致内存泄漏。<br>V8提供了close方法，如果只使用 v8.close() 进行释放，或者未关闭过程中有用到 v8 runtime 的变量都会报如下错误，正确的做法是将所有资源进行关闭。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">java.lang.IllegalStateException: <span class=\"number\">3</span> Object(s) still exist in runtime</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"三、进阶\"><a href=\"#三、进阶\" class=\"headerlink\" title=\"三、进阶\"></a>三、进阶</h2><p>通过以上的方式已经能执行很多逻辑了，但在实践过过程中发现：如何 js 的返回值是 Promise 的话不会等到最终的结果给我们，而是直接返回了一个 Promise 对象，以及看不到 <code>console.log</code> 打印的日志…… 诸如此类的问题需要解决，这里主要讲讲这两种方法的实现。</p>\n<p><strong>注册 Native 插件</strong></p>\n<p>J2V8 是一个基于 V8 引擎的 Java 库，它允许在 Java 中执行 JavaScript 代码。由于 J2V8 是在 Java 中运行的，它没有直接访问浏览器或控制台的能力，因此无法直接使用 console.log 函数来输出日志，总结 <strong>J2V8 不能实现以下功能：</strong></p>\n<blockquote>\n<ul>\n<li>浏览器 API：j2v8 是在 Java 中运行的，因此无法直接访问浏览器 API，如 DOM、BOM 等。这意味着 j2v8 无法直接操作网页内容、处理事件等</li>\n<li>文件系统访问：j2v8 在 Java 中运行，无法直接访问文件系统。如果需要访问文件系统，需要使用 Java 提供的文件操作 API。</li>\n<li>定时器：JavaScript 中有多种定时器函数，如 setTimeout、setInterval 等，可以在指定时间后执行代码。但 j2v8 无法实现这些定时器函数，因为它无法直接访问系统的计时器。</li>\n<li>Web Worker：Web Worker 是 JavaScript 中的一个特殊对象，可以在后台线程中执行代码，以避免阻塞主线程。但 j2v8 无法实现 Web Worker，因为它无法直接访问操作系统的线程。</li>\n<li>Node.js API：j2v8 主要是为了在 Java 中执行浏览器端的 JavaScript 代码而设计的，因此无法直接访问 Node.js API。如果需要在 Java 中执行 Node.js 代码，可以考虑使用 Nashorn 等其他工具。</li>\n</ul>\n</blockquote>\n<p>这里是 <code>console.log</code>的一个简单实现：</p>\n<p><code>V8Object</code> 是 J2V8 中的一个类，它代表了一个 JavaScript 对象，对于 <code>console.log</code> 我们可以将 <code>console</code> 看作一个对象，其有一个叫 <code>log</code> 的方法，要实现在 js 中打印日志到 Android Studio 控制台，如下即可：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">ConsolePlugin</span> &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    fun <span class=\"title function_\">log</span><span class=\"params\">(message: Any)</span> &#123;</span><br><span class=\"line\">        Log.d(<span class=\"string\">&quot;ConsolePlugin&quot;</span>, message.toString())</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    fun <span class=\"title function_\">register</span><span class=\"params\">(v8: V8)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">val</span> <span class=\"variable\">v8Console</span> <span class=\"operator\">=</span> V8Object(v8)</span><br><span class=\"line\">        <span class=\"comment\">// 第一个 log 表示 在 Java 中该方法的名字，第二个 log 表示在 JavaScript 中调用的名字 </span></span><br><span class=\"line\">        v8Console.registerJavaMethod(<span class=\"built_in\">this</span>, <span class=\"string\">&quot;log&quot;</span>, <span class=\"string\">&quot;log&quot;</span>, arrayOf&lt;Class&lt;*&gt;&gt;(Any::class.java))</span><br><span class=\"line\">        v8Console.setWeak()</span><br><span class=\"line\">        <span class=\"comment\">// 将含有叫&quot;log&quot;方法的一个对象加到运行环境中，该对象被命名为 &quot;console&quot;</span></span><br><span class=\"line\">        v8.add(<span class=\"string\">&quot;console&quot;</span>, v8Console)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">ConsolePlugin().register(v8)</span><br></pre></td></tr></table></figure>\n\n<p>具体代码可参考:<a href=\"https://github.com/VomPom/J2V8_tutorial\">J2V8_tutorial</a></p>\n<h4 id=\"执行返回值是-Promise-类型的方法\"><a href=\"#执行返回值是-Promise-类型的方法\" class=\"headerlink\" title=\"执行返回值是 Promise 类型的方法\"></a>执行返回值是 Promise 类型的方法</h4><p>之前将的方法调用都是返回数据为基础类型，由于在 Java&#x2F;kotlin 中没有<code>Promise</code>类型的方法，所以对于 <code>Promise</code> 方法我们需要进行一些特殊处理，我们通过使用 <code>CountDownLatch</code> 可以来实现一个 “异步变同步” 的操作，我们需要考虑的是如何接受到 <code>resolve</code> <code>rejcet</code>的调用，js 中 Promise 的方法使用如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"title class_\">PromiseMethod</span>().<span class=\"title function_\">then</span>(<span class=\"function\">(<span class=\"params\">result</span>)=&gt;</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// success got result</span></span><br><span class=\"line\">  &#125;).<span class=\"title function_\">catch</span>(<span class=\"function\">(<span class=\"params\">e</span>)=&gt;</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// error...</span></span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>在 J2V8中一样的实现</p>\n<p><strong>获取返回的 Promise 对象</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">val</span> <span class=\"variable\">promiseObj</span> <span class=\"operator\">=</span> v8.executeFunction(functionName, v8Array) as V8Object</span><br></pre></td></tr></table></figure>\n<p>**执行 Promise 对象的 then 和 catch 方法 **</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">jsPromise.apply &#123;</span><br><span class=\"line\">        <span class=\"type\">val</span> <span class=\"variable\">onResolveParameter</span> <span class=\"operator\">=</span> V8Array(v8).push(onResolve)</span><br><span class=\"line\">        <span class=\"type\">val</span> <span class=\"variable\">onRejectParameter</span> <span class=\"operator\">=</span> V8Array(v8).push(onReject)</span><br><span class=\"line\">        executeVoidFunction(<span class=\"string\">&quot;then&quot;</span>, onResolveParameter)</span><br><span class=\"line\">        executeVoidFunction(<span class=\"string\">&quot;catch&quot;</span>, onRejectParameter)</span><br><span class=\"line\">        ....</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n<p>其中 onResolve</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">val</span> <span class=\"variable\">onResolve</span> <span class=\"operator\">=</span> V8Function(jsRuntime) &#123; receiver, parameters -&gt;</span><br><span class=\"line\">        ……</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n<p>具体代码可参考:<a href=\"https://github.com/VomPom/J2V8_tutorial\">J2V8_tutorial</a></p>\n<h2 id=\"四、总结\"><a href=\"#四、总结\" class=\"headerlink\" title=\"四、总结\"></a>四、总结</h2><p>以上基本上能解决大部分 Android 调用 js的代码逻辑了，这里对整体执行的流程进行一个总结</p>\n<p>1、通过 webpack 对多个 .js 文件打包<br>2、初始化 V8 环境并加载 .js 文件<br>3、注册 Java 方法，供 js 进行调用<br>4、读取指定的模板<br>5、执行目标 js 方法，并释放 v8 执行过程中产生的资源</p>\n<h3 id=\"踩过的一些坑\"><a href=\"#踩过的一些坑\" class=\"headerlink\" title=\"踩过的一些坑\"></a>踩过的一些坑</h3><p>1、<code>java.lang.UnsupportedOperationException: StartNodeJS Not Supported.</code></p>\n<p>这个库有一个 <code>NodeJS.createNodeJS()</code>方法，以为是完美结合 NodeJs 的，查了下不太支持 Android，不过也有人提出解决方法：<a href=\"https://stackoverflow.com/questions/42574824/how-to-use-nodejs-in-android-using-j2v8\">https://stackoverflow.com/questions/42574824/how-to-use-nodejs-in-android-using-j2v8</a></p>\n<p>2、<code>java.lang.IllegalStateException: 3 Object(s) still exist in runtime</code></p>\n<p>这是调用 &#96;v8.close&#96;&#96; 总是会遇到的问题，一定需要确保使用了 v8 Runtime 过程变量有被释放掉，可能有时候不知道具体哪个变量没有被释放</p>\n<p>3、<code>setTimeout、setInterval</code> 无效</p>\n<p>这是我最开始遇到的问题，简单想着“既然能执行js代码，那 setTimeout、setInterval 这些方法都是 js 最普通的方法应该没问题吧”，如果有一些平时在 js 很常见的操作如果无法执行，最好 check 一下 J2V8 是否支持</p>\n<p>4、Undefined 相关</p>\n<p>虽然源码里面通过了一个 Undefined 的类，但是不能直接使用，如果方法返回的 Undefined，通过 <code>V8Object</code> 的 <code>isUndefined()</code> 去判断</p>\n<h3 id=\"引用\"><a href=\"#引用\" class=\"headerlink\" title=\"引用\"></a>引用</h3><p>[1]J2V8 <a href=\"https://eclipsesource.com/blogs/tutorials/getting-started-with-j2v8/\">https://eclipsesource.com/blogs/tutorials/getting-started-with-j2v8/</a></p>\n<p>[2] Registering Java Callbacks with J2V8 <a href=\"https://eclipsesource.com/blogs/2015/06/06/registering-java-callbacks-with-j2v8/\">https://eclipsesource.com/blogs/2015/06/06/registering-java-callbacks-with-j2v8/</a></p>\n<p>[3] Simple JS in Node.js <a href=\"https://yenhuang.gitbooks.io/android-development-note/content/wrap-js-library/simple-js-with-nodejs.html\">https://yenhuang.gitbooks.io/android-development-note/content/wrap-js-library/simple-js-with-nodejs.html</a></p>\n","categories":[{"name":"技术文章","slug":"technology","api":"api/categories/technology.json"}],"tags":[{"name":"JavaScript","slug":"JavaScript","api":"api/tags/JavaScript.json"}],"api":"api/posts/2023/09/30/Android-J2V8-实践.json"},{"title":"（转）OpenGL黑屏及渲染不出来的常见原因总结","slug":"（转）OpenGL黑屏及渲染不出来的常见原因总结","date":"2023-01-15T04:18:00.000Z","updated":"2025-05-20T11:46:57.000Z","comments":true,"url":"2023/01/15/（转）OpenGL黑屏及渲染不出来的常见原因总结/","excerpt":"<p>最近在做 Unitiy 与原生渲染相关的研究学习，对于OpenGL这块自己也是接触不多，有很多的坑需要自己去踩，做的过程中遇到最多的问题是：<strong>渲染黑屏</strong> 在掘金上搜到这篇文章<a href=\"https://juejin.cn/post/6844903910742687751\">《OpenGL黑屏及渲染不出来的常见原因总结》</a>很不错，于是记录转载过来，方便日后学习以及问题排查。</p>\n<p>原文链接：<br><a href=\"https://juejin.cn/post/6844903910742687751\">https://juejin.cn/post/6844903910742687751</a></p>\n<h2 id=\"原文\"><a href=\"#原文\" class=\"headerlink\" title=\"原文\"></a>原文</h2><p>做OpenGL开发的同学，想必一定碰到过黑屏的问题，特别是刚接触OpenGL的同学，可能会觉得黑屏问题让人相当头疼，因为OpenGL的查错没有一般编程时那么简单，我们通常是利用glGetError()这个API来获取错误码，但这个方法获取的错误是调用这个方法时，已经产生的错误，它有可能是很久之前产生的，这样查越来还是比较不方便的，而且，有些黑屏以及渲染不出来的情况下，glGetError()也不会报任何错。</p>\n<p>在给大家总结常见的黑屏原因之前，我们先来铺垫一下基础知识，其实屏幕也是一块frame buffer，但它比较特殊，是0号<code>frame buffer</code>，我们如果自己申请frame buffer的话，得到的id是大于0的。那么frame buffer它就会有自己的颜色，如果不特意设置的话，它就是黑色的，因此如果我们渲染操作未正确执行，什么也没渲染出来，自然看到了底色的黑色。</p>\n<p>我们也可以通过<code>glClearColor()+glClear()</code>来设置消除颜色及执行消除操作，来将一个frame buffer清成某种颜色。因此，如果你将frame buffer清成了别的颜色，但其它渲染操作未正确执行，你有可能也不是黑屏，而是你设置的消除颜色，这里也一并总结了，统成为黑屏，同时也包括其它一些不正确的情形。<br>如果不是渲染到屏幕上，是渲染到一个离屏的frame buffer上，同样也会遇到各种黑掉或者渲染不出来的情况，有些原因会同时导致上屏和离屏都黑，有些只影响其中一种情况。</p>\n<p>下面给大家总结一下：</p>\n<ul>\n<li><strong>调用线程的Context不正确</strong></li>\n</ul>\n<p>OpenGL的API在调用时需要有正确的上下文，在Android中称为<code>EGL Context</code>，IOS中是<code>EAGL Context</code>，其它平台有其它平台的叫法，但原理类似。一个线程需要跟EGL Context绑定才能正确使用OpenGL的API，否则调用不会有任何效果，具体可参考我的一篇文章：<a href=\"https://juejin.cn/post/6844903858380996616\">《OpenGL ES 高级进阶：EGL及GL线程》</a>。</p>\n<blockquote>\n<p>【转载注】这也是我碰到的第一个坑，因为从 Unity 调用到 Android 侧的时候，gl渲染环境没有在一个地方。我花了很大的精力去排查前面shader相关的渲染问题，一直没有注意这个问题，所以浪费了大量时间。我个人认为这个问题需要像使用一门新语言的时候要先确保它能打印出”Hello World”一样，是整个流程的前提。</p>\n</blockquote>\n<ul>\n<li><strong>GL Program不正确</strong></li>\n</ul>\n<p>OpenGL渲染需要通过GL Program，它就是一个程序，和我们的普通程序是一个道理，只不过它是运行在GPU上的，如果它不正确了，那自然就渲染不出正确的结果，常见的不正确原因为shader编译失败，通常是因为语法错误，可以用glGetShaderInfoLog()来在编译之后查看相关shader信息，以及在Link后用glGetProgramInfoLog()查看相关program信息，如果得到的信息为空，则说明没有错。</p>\n<ul>\n<li><strong>没有use program</strong></li>\n</ul>\n<p>渲染前需要通过glUseProgran设置本次渲染所用的program，如果未设置则无法执行到对应的shader，自然无法渲染出来。</p>\n<ul>\n<li><strong>未调用glDrawXXX()</strong></li>\n</ul>\n<p>要渲染出来东西，必须调用glDrawXXX()，一般很少出现没调的情况，一般都是低级失误，最好也排查一下。</p>\n<p>对于底层是多buffer实现的surface，渲染后未进行swap buffer<br>常见的是双buffer，此时有一个back buffer和一个front buffer，front buffer是正在显存的这个，back buffer是正在渲染的，如果draw call后没有swap buffer，那back buffer不会呈现出来，因此渲染不出来，这里是特定上屏，如果渲染不是要上屏，则无需考虑这个问题。</p>\n<ul>\n<li><strong>frame buffer的attachment不正确</strong></li>\n</ul>\n<p>在离屏渲染情况下，当我们要渲染到一个frame buffer上，这个frame buffer必须正确绑定了attachment，否则相当于frame buffer是个空壳，它没有任何可用于承载渲染结果的空间。</p>\n<ul>\n<li><strong>顶点attribute值设置错误</strong></li>\n</ul>\n<p>顶点关系到渲染到什么位置，如果设置错误导致渲染的位置在可视范围之外，那么就看不到了，这里的范围是什么呢？如果直接用NDC坐标渲染，那就是-1~1,如果是用世界坐标来渲染，那就要看具体设置的投影矩阵，详细原理可参考我的另一篇文章《OpenGL 3D渲染技术：坐标系及矩阵变换》。</p>\n<p>attribute未启用<br>我们通过想要设置一个attribute的值，需要获取这个attribute的location，并通过glVertexAttribPointer()给它设置值，但别忘了需要使用glGetAttribLocation()来启用这个location，不然设置了也没有用，默认是不启用的。</p>\n<ul>\n<li><strong>VAO&#x2F;VBO未绑定或者绑定错误</strong></li>\n</ul>\n<p>如果是用VAO&#x2F;VBO的方式渲染，在渲染前要绑定正确的VAO&#x2F;VBO，否则等于没指定或者指定错了顶点，就渲染不出来了。</p>\n<ul>\n<li><strong>VAO&#x2F;VBO方式渲染之后未重置，后面接着用非VAO&#x2F;VBO方式渲染</strong></li>\n</ul>\n<p>在用VAO&#x2F;VBO方式渲染之后如果未重置，那么顶点绑定的还是VAO&#x2F;VBO指定的顶点，此时如果再用普通的glVertexAttribPointer()的方式指定顶点渲染，那用法上会冲突，因为VAO&#x2F;VBO的方式要求glVertexAttribPointer()函数不指定顶点数据，而普通用法中glVertexAttribPointer()又要指定顶点数据，此时容易造成顶点混乱，渲染结果不正确。</p>\n<p>View Port设置错误<br>View Port即视口，可以理解成我们通过一个窗口去看见OpenGL世界坐标系里渲染的景物，就像我们通过窗口看到室外的景物一样，如果这个窗口没设置或者设置不正确，也会导致看不到东西，一般情况下，我们会将它设置为surface的大小，这样渲染出来的东西就刚好填满这个surface。</p>\n<ul>\n<li><strong>没有渲染到0号frame buffer</strong></li>\n</ul>\n<p>有时候渲染操作有很多步，想做完这些步骤后，再将做好的结果显示的屏幕上，这时就会用一些frame buffer来做离屏渲染，但在最后一步渲染到屏幕上时，需要将frame buffer绑定回0号，才能上屏。</p>\n<ul>\n<li><strong>渲染了一个不正确的纹理</strong></li>\n</ul>\n<p>例如我们希望对一个纹理做一些处理然后渲染出来，但如果这个纹理本身是不正确的，例如前面的步骤出了一些错，导致给过来的纹理id不正确，比如是0，或者纹理id是正确的，但这个纹理是全黑的或者空的，也会导致黑屏。</p>\n<ul>\n<li><strong>glDrawXXX()方法传递的顶点数不正确</strong></li>\n</ul>\n<p>我们在调用glDrawXXX()，会设置顶点数组的开始位置和数量，如果设置不正确，导致传递的顶点是0个，也会导致渲染不出来任何东西。</p>\n<ul>\n<li><strong>顶点buffer的position不正确</strong></li>\n</ul>\n<p>这一点主要是针对java及kotlin，glVertexAttribPointer()接受数据时是通过一个buffer，而我们往buffer是put数据后，buffer的position会相应地往后移动，因此在调用glVertexAttribPointer()之前，记得将position设回到0，否则它将从末尾开始取数据，当然就取不到了。</p>\n<ul>\n<li><strong>面剔除的原因</strong></li>\n</ul>\n<p>如果开启了cull face，那么会按你指定的cull方式来剔除指定顶点旋转顺序的三角面片，如果视线方向看过去的刚好被剔除了，自然就看不见了。</p>\n<ul>\n<li><strong>未开启颜色混合渲染了有透明度的纹理</strong></li>\n</ul>\n<p>OpenGL默认是不开启颜色混合的，这会导致透明的部分通常会被渲染成黑色，而不是透出下面的颜色，具体可以参数我的一篇文章：《OpenGL ES 高级进阶：颜色混合》。</p>\n<p>作者：程序员kenney</p>\n<p>链接：<a href=\"https://juejin.cn/post/6844903910742687751\">https://juejin.cn/post/6844903910742687751</a></p>\n<p>来源：稀土掘金</p>\n","cover":null,"images":[],"content":"<p>最近在做 Unitiy 与原生渲染相关的研究学习，对于OpenGL这块自己也是接触不多，有很多的坑需要自己去踩，做的过程中遇到最多的问题是：<strong>渲染黑屏</strong> 在掘金上搜到这篇文章<a href=\"https://juejin.cn/post/6844903910742687751\">《OpenGL黑屏及渲染不出来的常见原因总结》</a>很不错，于是记录转载过来，方便日后学习以及问题排查。</p>\n<p>原文链接：<br><a href=\"https://juejin.cn/post/6844903910742687751\">https://juejin.cn/post/6844903910742687751</a></p>\n<h2 id=\"原文\"><a href=\"#原文\" class=\"headerlink\" title=\"原文\"></a>原文</h2><p>做OpenGL开发的同学，想必一定碰到过黑屏的问题，特别是刚接触OpenGL的同学，可能会觉得黑屏问题让人相当头疼，因为OpenGL的查错没有一般编程时那么简单，我们通常是利用glGetError()这个API来获取错误码，但这个方法获取的错误是调用这个方法时，已经产生的错误，它有可能是很久之前产生的，这样查越来还是比较不方便的，而且，有些黑屏以及渲染不出来的情况下，glGetError()也不会报任何错。</p>\n<p>在给大家总结常见的黑屏原因之前，我们先来铺垫一下基础知识，其实屏幕也是一块frame buffer，但它比较特殊，是0号<code>frame buffer</code>，我们如果自己申请frame buffer的话，得到的id是大于0的。那么frame buffer它就会有自己的颜色，如果不特意设置的话，它就是黑色的，因此如果我们渲染操作未正确执行，什么也没渲染出来，自然看到了底色的黑色。</p>\n<p>我们也可以通过<code>glClearColor()+glClear()</code>来设置消除颜色及执行消除操作，来将一个frame buffer清成某种颜色。因此，如果你将frame buffer清成了别的颜色，但其它渲染操作未正确执行，你有可能也不是黑屏，而是你设置的消除颜色，这里也一并总结了，统成为黑屏，同时也包括其它一些不正确的情形。<br>如果不是渲染到屏幕上，是渲染到一个离屏的frame buffer上，同样也会遇到各种黑掉或者渲染不出来的情况，有些原因会同时导致上屏和离屏都黑，有些只影响其中一种情况。</p>\n<p>下面给大家总结一下：</p>\n<ul>\n<li><strong>调用线程的Context不正确</strong></li>\n</ul>\n<p>OpenGL的API在调用时需要有正确的上下文，在Android中称为<code>EGL Context</code>，IOS中是<code>EAGL Context</code>，其它平台有其它平台的叫法，但原理类似。一个线程需要跟EGL Context绑定才能正确使用OpenGL的API，否则调用不会有任何效果，具体可参考我的一篇文章：<a href=\"https://juejin.cn/post/6844903858380996616\">《OpenGL ES 高级进阶：EGL及GL线程》</a>。</p>\n<blockquote>\n<p>【转载注】这也是我碰到的第一个坑，因为从 Unity 调用到 Android 侧的时候，gl渲染环境没有在一个地方。我花了很大的精力去排查前面shader相关的渲染问题，一直没有注意这个问题，所以浪费了大量时间。我个人认为这个问题需要像使用一门新语言的时候要先确保它能打印出”Hello World”一样，是整个流程的前提。</p>\n</blockquote>\n<ul>\n<li><strong>GL Program不正确</strong></li>\n</ul>\n<p>OpenGL渲染需要通过GL Program，它就是一个程序，和我们的普通程序是一个道理，只不过它是运行在GPU上的，如果它不正确了，那自然就渲染不出正确的结果，常见的不正确原因为shader编译失败，通常是因为语法错误，可以用glGetShaderInfoLog()来在编译之后查看相关shader信息，以及在Link后用glGetProgramInfoLog()查看相关program信息，如果得到的信息为空，则说明没有错。</p>\n<ul>\n<li><strong>没有use program</strong></li>\n</ul>\n<p>渲染前需要通过glUseProgran设置本次渲染所用的program，如果未设置则无法执行到对应的shader，自然无法渲染出来。</p>\n<ul>\n<li><strong>未调用glDrawXXX()</strong></li>\n</ul>\n<p>要渲染出来东西，必须调用glDrawXXX()，一般很少出现没调的情况，一般都是低级失误，最好也排查一下。</p>\n<p>对于底层是多buffer实现的surface，渲染后未进行swap buffer<br>常见的是双buffer，此时有一个back buffer和一个front buffer，front buffer是正在显存的这个，back buffer是正在渲染的，如果draw call后没有swap buffer，那back buffer不会呈现出来，因此渲染不出来，这里是特定上屏，如果渲染不是要上屏，则无需考虑这个问题。</p>\n<ul>\n<li><strong>frame buffer的attachment不正确</strong></li>\n</ul>\n<p>在离屏渲染情况下，当我们要渲染到一个frame buffer上，这个frame buffer必须正确绑定了attachment，否则相当于frame buffer是个空壳，它没有任何可用于承载渲染结果的空间。</p>\n<ul>\n<li><strong>顶点attribute值设置错误</strong></li>\n</ul>\n<p>顶点关系到渲染到什么位置，如果设置错误导致渲染的位置在可视范围之外，那么就看不到了，这里的范围是什么呢？如果直接用NDC坐标渲染，那就是-1~1,如果是用世界坐标来渲染，那就要看具体设置的投影矩阵，详细原理可参考我的另一篇文章《OpenGL 3D渲染技术：坐标系及矩阵变换》。</p>\n<p>attribute未启用<br>我们通过想要设置一个attribute的值，需要获取这个attribute的location，并通过glVertexAttribPointer()给它设置值，但别忘了需要使用glGetAttribLocation()来启用这个location，不然设置了也没有用，默认是不启用的。</p>\n<ul>\n<li><strong>VAO&#x2F;VBO未绑定或者绑定错误</strong></li>\n</ul>\n<p>如果是用VAO&#x2F;VBO的方式渲染，在渲染前要绑定正确的VAO&#x2F;VBO，否则等于没指定或者指定错了顶点，就渲染不出来了。</p>\n<ul>\n<li><strong>VAO&#x2F;VBO方式渲染之后未重置，后面接着用非VAO&#x2F;VBO方式渲染</strong></li>\n</ul>\n<p>在用VAO&#x2F;VBO方式渲染之后如果未重置，那么顶点绑定的还是VAO&#x2F;VBO指定的顶点，此时如果再用普通的glVertexAttribPointer()的方式指定顶点渲染，那用法上会冲突，因为VAO&#x2F;VBO的方式要求glVertexAttribPointer()函数不指定顶点数据，而普通用法中glVertexAttribPointer()又要指定顶点数据，此时容易造成顶点混乱，渲染结果不正确。</p>\n<p>View Port设置错误<br>View Port即视口，可以理解成我们通过一个窗口去看见OpenGL世界坐标系里渲染的景物，就像我们通过窗口看到室外的景物一样，如果这个窗口没设置或者设置不正确，也会导致看不到东西，一般情况下，我们会将它设置为surface的大小，这样渲染出来的东西就刚好填满这个surface。</p>\n<ul>\n<li><strong>没有渲染到0号frame buffer</strong></li>\n</ul>\n<p>有时候渲染操作有很多步，想做完这些步骤后，再将做好的结果显示的屏幕上，这时就会用一些frame buffer来做离屏渲染，但在最后一步渲染到屏幕上时，需要将frame buffer绑定回0号，才能上屏。</p>\n<ul>\n<li><strong>渲染了一个不正确的纹理</strong></li>\n</ul>\n<p>例如我们希望对一个纹理做一些处理然后渲染出来，但如果这个纹理本身是不正确的，例如前面的步骤出了一些错，导致给过来的纹理id不正确，比如是0，或者纹理id是正确的，但这个纹理是全黑的或者空的，也会导致黑屏。</p>\n<ul>\n<li><strong>glDrawXXX()方法传递的顶点数不正确</strong></li>\n</ul>\n<p>我们在调用glDrawXXX()，会设置顶点数组的开始位置和数量，如果设置不正确，导致传递的顶点是0个，也会导致渲染不出来任何东西。</p>\n<ul>\n<li><strong>顶点buffer的position不正确</strong></li>\n</ul>\n<p>这一点主要是针对java及kotlin，glVertexAttribPointer()接受数据时是通过一个buffer，而我们往buffer是put数据后，buffer的position会相应地往后移动，因此在调用glVertexAttribPointer()之前，记得将position设回到0，否则它将从末尾开始取数据，当然就取不到了。</p>\n<ul>\n<li><strong>面剔除的原因</strong></li>\n</ul>\n<p>如果开启了cull face，那么会按你指定的cull方式来剔除指定顶点旋转顺序的三角面片，如果视线方向看过去的刚好被剔除了，自然就看不见了。</p>\n<ul>\n<li><strong>未开启颜色混合渲染了有透明度的纹理</strong></li>\n</ul>\n<p>OpenGL默认是不开启颜色混合的，这会导致透明的部分通常会被渲染成黑色，而不是透出下面的颜色，具体可以参数我的一篇文章：《OpenGL ES 高级进阶：颜色混合》。</p>\n<p>作者：程序员kenney</p>\n<p>链接：<a href=\"https://juejin.cn/post/6844903910742687751\">https://juejin.cn/post/6844903910742687751</a></p>\n<p>来源：稀土掘金</p>\n","categories":[{"name":"技术文章","slug":"technology","api":"api/categories/technology.json"}],"tags":[{"name":"OpenGL","slug":"OpenGL","api":"api/tags/OpenGL.json"}],"api":"api/posts/2023/01/15/（转）OpenGL黑屏及渲染不出来的常见原因总结.json"},{"title":"FFmpeg.so 编译总结","slug":"FFmpeg-so-编译整理","date":"2023-01-09T02:36:00.000Z","updated":"2025-05-20T11:46:57.000Z","comments":true,"url":"2023/01/09/FFmpeg-so-编译整理/","excerpt":"<p>此前项目一直使用的 FFmpeg.so 是我从其他团队项目中直接复制过来的，但原来的项目团队不再维护这个库，其中 x264 模块由于一些版权问题需要剔除，所以需要自己重新编译。在编译的过程中踩了很多坑，以及编译 congfigure 有太多的配置，如何减少整体编译出来的大小也是需要花点精力的，本文主要记录编译流程以及相关配置介绍。</p>\n<h2 id=\"编译介绍\"><a href=\"#编译介绍\" class=\"headerlink\" title=\"编译介绍\"></a>编译介绍</h2><p>自己编译主要参考<a href=\"https://github.com/Timdk857/Android-Architecture-knowledge-2-/blob/master/Android%20%E9%9F%B3%E8%A7%86%E9%A2%91%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97/Android-%E9%9F%B3%E8%A7%86%E9%A2%91%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97-(%E5%9B%9B)-%E4%B8%80%E9%94%AE%E7%BC%96%E8%AF%91-32-64-%E4%BD%8D-FFmpeg-4-2-2.md\">《一键编译32_64位FFmpeg.4.2.2》</a>，最开始的时候自己一直在 Mac M1 上编译，各种流程也是一比一复刻，但是仍然会有各种问题出现，最常见的就是：</p>\n<blockquote>\n<p>aarch64-linux-android21-clang is unable to create an executable file.<br>C compiler test failed.</p>\n</blockquote>\n<p>我反复检查了自己的 NDK 的配置，确保是正确的，文章也有提及处理方式，但是尝试下来都无效，在网上搜了一大篇解决方式，也都无效。不过我看他们很多都是用 Linux 系统进行的编译，遂改为使用 Linux 编译，再重新尝试，似乎没有那些个奇奇怪怪的错误了，也打出了最终的包，最后的 so 大小也符合要求。</p>\n<h3 id=\"编译环境\"><a href=\"#编译环境\" class=\"headerlink\" title=\"编译环境\"></a>编译环境</h3><ul>\n<li>CentOS 7</li>\n<li><a href=\"https://ffmpeg.org/releases/ffmpeg-4.2.2.tar.bz2\">ffmpeg-4.2.2</a></li>\n<li><a href=\"https://github.com/android/ndk/wiki/Unsupported-Downloads\">android-ndk-r20b-linux-x86_64.zip</a></li>\n</ul>\n<h3 id=\"编译脚本\"><a href=\"#编译脚本\" class=\"headerlink\" title=\"编译脚本\"></a>编译脚本</h3><p>这是我的一份编译脚本，我的需求是进行本地视频抽帧，所以不需要像滤镜、编码、音频相关的配置，只需要视频解码相关的配置，具体配置在下一节有讲解。</p>\n<figure class=\"highlight powershell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#!/bin/bash</span></span><br><span class=\"line\">export NDK=.../android<span class=\"literal\">-ndk-r20b</span></span><br><span class=\"line\">TOOLCHAIN=<span class=\"variable\">$NDK</span>/toolchains/llvm/prebuilt/linux<span class=\"literal\">-x86_64</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">build_android</span></span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">./configure \\ </span><br><span class=\"line\"><span class=\"literal\">--prefix</span>=<span class=\"variable\">$PREFIX</span> \\ </span><br><span class=\"line\"><span class=\"literal\">--enable-neon</span> \\ </span><br><span class=\"line\"><span class=\"literal\">--disable-x86asm</span> \\ </span><br><span class=\"line\"><span class=\"literal\">--disable-hwaccels</span> \\ </span><br><span class=\"line\"><span class=\"literal\">--disable-gpl</span> \\ </span><br><span class=\"line\"><span class=\"literal\">--disable-nonfree</span> \\ </span><br><span class=\"line\"><span class=\"literal\">--disable-version3</span> \\ </span><br><span class=\"line\"><span class=\"literal\">--disable-postproc</span> \\ </span><br><span class=\"line\"><span class=\"literal\">--disable-bsfs</span> \\ </span><br><span class=\"line\"><span class=\"literal\">--disable-protocols</span> \\ </span><br><span class=\"line\"><span class=\"literal\">--enable-protocol</span>=file \\ </span><br><span class=\"line\"><span class=\"literal\">--disable-indevs</span> \\ </span><br><span class=\"line\"><span class=\"literal\">--disable-outdevs</span> \\ </span><br><span class=\"line\"><span class=\"literal\">--disable-debug</span> \\ </span><br><span class=\"line\"><span class=\"literal\">--enable-small</span> \\ </span><br><span class=\"line\"><span class=\"literal\">--enable-jni</span> \\ </span><br><span class=\"line\"><span class=\"literal\">--disable-mediacodec</span> \\ </span><br><span class=\"line\"><span class=\"literal\">--disable-decoder</span>=h264_mediacodec \\ </span><br><span class=\"line\"><span class=\"literal\">--enable-swscale</span> \\ </span><br><span class=\"line\"><span class=\"literal\">--enable-static</span> \\ </span><br><span class=\"line\"><span class=\"literal\">--disable-shared</span> \\ </span><br><span class=\"line\"><span class=\"literal\">--disable-filters</span> \\ </span><br><span class=\"line\"><span class=\"literal\">--disable-avfilter</span> \\ </span><br><span class=\"line\"><span class=\"literal\">--disable-encoders</span> \\ </span><br><span class=\"line\"><span class=\"literal\">--disable-muxers</span> \\ </span><br><span class=\"line\"><span class=\"literal\">--disable-demuxers</span> \\ </span><br><span class=\"line\"><span class=\"literal\">--enable-demuxer</span>=avi \\ </span><br><span class=\"line\"><span class=\"literal\">--enable-demuxer</span>=flv \\ </span><br><span class=\"line\"><span class=\"literal\">--enable-demuxer</span>=h261 \\ </span><br><span class=\"line\"><span class=\"literal\">--enable-demuxer</span>=h263 \\ </span><br><span class=\"line\"><span class=\"literal\">--enable-demuxer</span>=h264 \\ </span><br><span class=\"line\"><span class=\"literal\">--enable-demuxer</span>=hevc \\ </span><br><span class=\"line\"><span class=\"literal\">--enable-demuxer</span>=mov \\ </span><br><span class=\"line\"><span class=\"literal\">--enable-demuxer</span>=m4v \\ </span><br><span class=\"line\"><span class=\"literal\">--disable-decoders</span> \\ </span><br><span class=\"line\"><span class=\"literal\">--enable-decoder</span>=h263 \\ </span><br><span class=\"line\"><span class=\"literal\">--enable-decoder</span>=h263i \\ </span><br><span class=\"line\"><span class=\"literal\">--enable-decoder</span>=h263p \\ </span><br><span class=\"line\"><span class=\"literal\">--enable-decoder</span>=h264 \\ </span><br><span class=\"line\"><span class=\"literal\">--enable-decoder</span>=hevc \\ </span><br><span class=\"line\"><span class=\"literal\">--enable-decoder</span>=flv \\ </span><br><span class=\"line\"><span class=\"literal\">--enable-decoder</span>=mpeg4 \\ </span><br><span class=\"line\"><span class=\"literal\">--disable-parsers</span> \\ </span><br><span class=\"line\"><span class=\"literal\">--enable-parser</span>=h264 \\ </span><br><span class=\"line\"><span class=\"literal\">--enable-parser</span>=h261 \\ </span><br><span class=\"line\"><span class=\"literal\">--enable-parser</span>=h263 \\ </span><br><span class=\"line\"><span class=\"literal\">--enable-parser</span>=mpeg4video \\ </span><br><span class=\"line\"><span class=\"literal\">--enable-parser</span>=mpegvideo \\ </span><br><span class=\"line\"><span class=\"literal\">--disable-htmlpages</span> \\ </span><br><span class=\"line\"><span class=\"literal\">--disable-manpages</span> \\ </span><br><span class=\"line\"><span class=\"literal\">--disable-podpages</span> \\ </span><br><span class=\"line\"><span class=\"literal\">--disable-txtpages</span> \\ </span><br><span class=\"line\"><span class=\"literal\">--disable-vaapi</span> \\ </span><br><span class=\"line\"><span class=\"literal\">--disable-v4l2-m2m</span> \\ </span><br><span class=\"line\"><span class=\"literal\">--disable-nvdec</span> \\ </span><br><span class=\"line\"><span class=\"literal\">--disable-nvenc</span> \\ </span><br><span class=\"line\"><span class=\"literal\">--disable-ffnvcodec</span> \\ </span><br><span class=\"line\"><span class=\"literal\">--disable-dxva2</span> \\ </span><br><span class=\"line\"><span class=\"literal\">--disable-d3d11va</span> \\ </span><br><span class=\"line\"><span class=\"literal\">--disable-cuvid</span> \\ </span><br><span class=\"line\"><span class=\"literal\">--disable-cuda-llvm</span> \\ </span><br><span class=\"line\"><span class=\"literal\">--disable-cuda-nvcc</span> \\ </span><br><span class=\"line\"><span class=\"literal\">--disable-audiotoolbox</span> \\ </span><br><span class=\"line\"><span class=\"literal\">--disable-amf</span> \\ </span><br><span class=\"line\"><span class=\"literal\">--disable-iconv</span> \\ </span><br><span class=\"line\"><span class=\"literal\">--disable-libxcb</span> \\ </span><br><span class=\"line\"><span class=\"literal\">--disable-libxcb-shm</span> \\ </span><br><span class=\"line\"><span class=\"literal\">--disable-libxcb-xfixes</span> \\ </span><br><span class=\"line\"><span class=\"literal\">--disable-libxcb-shape</span> \\ </span><br><span class=\"line\"><span class=\"literal\">--disable-lzma</span> \\ </span><br><span class=\"line\"><span class=\"literal\">--disable-sdl2</span> \\ </span><br><span class=\"line\"><span class=\"literal\">--disable-securetransport</span> \\ </span><br><span class=\"line\"><span class=\"literal\">--disable-xlib</span> \\ </span><br><span class=\"line\"><span class=\"literal\">--disable-zlib</span> \\ </span><br><span class=\"line\"><span class=\"literal\">--disable-programs</span> \\ </span><br><span class=\"line\"><span class=\"literal\">--disable-ffmpeg</span> \\ </span><br><span class=\"line\"><span class=\"literal\">--disable-ffplay</span> \\ </span><br><span class=\"line\"><span class=\"literal\">--disable-ffprobe</span> \\ </span><br><span class=\"line\"><span class=\"literal\">--disable-avdevice</span> \\ </span><br><span class=\"line\"><span class=\"literal\">--disable-symver</span> \\ </span><br><span class=\"line\"><span class=\"literal\">--cross-prefix</span>=<span class=\"variable\">$CROSS_PREFIX</span> \\ </span><br><span class=\"line\"><span class=\"literal\">--target-os</span>=android \\ </span><br><span class=\"line\"><span class=\"literal\">--arch</span>=<span class=\"variable\">$ARCH</span> \\ </span><br><span class=\"line\"><span class=\"literal\">--cpu</span>=<span class=\"variable\">$CPU</span> \\ </span><br><span class=\"line\"><span class=\"literal\">--cc</span>=<span class=\"variable\">$CC</span> \\ </span><br><span class=\"line\"><span class=\"literal\">--cxx</span>=<span class=\"variable\">$CXX</span> \\ </span><br><span class=\"line\"><span class=\"literal\">--enable-cross-compile</span> \\ </span><br><span class=\"line\"><span class=\"literal\">--sysroot</span>=<span class=\"variable\">$SYSROOT</span> \\ </span><br><span class=\"line\"><span class=\"literal\">--extra-cflags</span>=<span class=\"string\">&quot;-Os -fpic <span class=\"variable\">$OPTIMIZE_CFLAGS</span>&quot;</span> \\ </span><br><span class=\"line\"><span class=\"literal\">--extra-ldflags</span>=<span class=\"string\">&quot;<span class=\"variable\">$ADDI_LDFLAGS</span>&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">make clean</span><br><span class=\"line\">make <span class=\"literal\">-j16</span></span><br><span class=\"line\">make install</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#arm64-v8a</span></span><br><span class=\"line\">ARCH=arm64</span><br><span class=\"line\">CPU=armv8<span class=\"literal\">-a</span></span><br><span class=\"line\">API=<span class=\"number\">21</span></span><br><span class=\"line\">CC=<span class=\"variable\">$TOOLCHAIN</span>/bin/aarch64<span class=\"literal\">-linux-android</span><span class=\"variable\">$API</span><span class=\"literal\">-clang</span></span><br><span class=\"line\">CXX=<span class=\"variable\">$TOOLCHAIN</span>/bin/aarch64<span class=\"literal\">-linux-android</span><span class=\"variable\">$API</span><span class=\"literal\">-clang</span>++</span><br><span class=\"line\">SYSROOT=<span class=\"variable\">$NDK</span>/toolchains/llvm/prebuilt/linux<span class=\"literal\">-x86_64</span>/sysroot</span><br><span class=\"line\">CROSS_PREFIX=<span class=\"variable\">$TOOLCHAIN</span>/bin/aarch64<span class=\"literal\">-linux-android-</span></span><br><span class=\"line\">PREFIX=<span class=\"variable\">$</span>(<span class=\"built_in\">pwd</span>)/android/<span class=\"variable\">$CPU</span></span><br><span class=\"line\">OPTIMIZE_CFLAGS=<span class=\"string\">&quot;-march=<span class=\"variable\">$CPU</span>&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">build_android</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#armv7-a</span></span><br><span class=\"line\">ARCH=arm</span><br><span class=\"line\">CPU=armv7<span class=\"literal\">-a</span></span><br><span class=\"line\">API=<span class=\"number\">21</span></span><br><span class=\"line\">CC=<span class=\"variable\">$TOOLCHAIN</span>/bin/armv7a<span class=\"literal\">-linux-androideabi</span><span class=\"variable\">$API</span><span class=\"literal\">-clang</span></span><br><span class=\"line\">CXX=<span class=\"variable\">$TOOLCHAIN</span>/bin/armv7a<span class=\"literal\">-linux-androideabi</span><span class=\"variable\">$API</span><span class=\"literal\">-clang</span>++</span><br><span class=\"line\">SYSROOT=<span class=\"variable\">$NDK</span>/toolchains/llvm/prebuilt/linux<span class=\"literal\">-x86_64</span>/sysroot</span><br><span class=\"line\">CROSS_PREFIX=<span class=\"variable\">$TOOLCHAIN</span>/bin/arm<span class=\"literal\">-linux-androideabi-</span></span><br><span class=\"line\">PREFIX=<span class=\"variable\">$</span>(<span class=\"built_in\">pwd</span>)/android/<span class=\"variable\">$CPU</span></span><br><span class=\"line\">OPTIMIZE_CFLAGS=<span class=\"string\">&quot;-mfloat-abi=softfp -mfpu=vfp -marm -march=<span class=\"variable\">$CPU</span> &quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">build_android</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"配置介绍\"><a href=\"#配置介绍\" class=\"headerlink\" title=\"配置介绍\"></a>配置介绍</h2><p>通过执行 <code>./configure --help</code> 能得到所有的配置选项，整个配置也非常好理解，通过 list-xxx 可以知道有哪些子选项，然后再通过 <code>--disable-xxx</code>,或者 <code>--enable-xxx</code> 进行关闭或者打开。以解码为例：</p>\n<figure class=\"highlight powershell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"literal\">--disable-decoders</span>       <span class=\"comment\"># 先关闭所有的解码器</span></span><br><span class=\"line\"><span class=\"literal\">--enable-decoder</span>=flv     <span class=\"comment\"># 然后只打开flv、mpeg4 的支持</span></span><br><span class=\"line\"><span class=\"literal\">--enable-decoder</span>=mpeg4 </span><br></pre></td></tr></table></figure>\n<p>对于<code>--enable-decoder=xxx</code>中的xxx可以通过 <code>./configure --list-decoders</code> 进行查看，同理 <code>encoders</code> <code>demuxers</code> <code>muxers</code> 等都是类似的处理，通过 <code>--help</code> 可以通过 <code>list--xxx</code> 查看不同功能的可以支持的配置，主要有以下：</p>\n<figure class=\"highlight powershell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"literal\">--list-decoders</span>          show all available decoders</span><br><span class=\"line\"><span class=\"literal\">--list-encoders</span>          show all available encoders</span><br><span class=\"line\"><span class=\"literal\">--list-hwaccels</span>          show all available hardware accelerators</span><br><span class=\"line\"><span class=\"literal\">--list-demuxers</span>          show all available demuxers</span><br><span class=\"line\"><span class=\"literal\">--list-muxers</span>            show all available muxers</span><br><span class=\"line\"><span class=\"literal\">--list-parsers</span>           show all available parsers</span><br><span class=\"line\"><span class=\"literal\">--list-protocols</span>         show all available protocols</span><br><span class=\"line\"><span class=\"literal\">--list-bsfs</span>              show all available bitstream filters</span><br><span class=\"line\"><span class=\"literal\">--list-indevs</span>            show all available input devices</span><br><span class=\"line\"><span class=\"literal\">--list-outdevs</span>           show all available output devices</span><br><span class=\"line\"><span class=\"literal\">--list-filters</span>           show all available filters</span><br></pre></td></tr></table></figure>\n\n<p>其他的配置就是一些实际性的开关配置，列一些常用的配置：</p>\n<p>配置产物为静态库(.a)或者动态库(.so)</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">--enable-static         do not build static libraries [no]</span><br><span class=\"line\">--enable-shared         build shared libraries [no]</span><br></pre></td></tr></table></figure>\n\n<p>配置减少包大小</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">--enable-small           optimize for size instead of speed</span><br></pre></td></tr></table></figure>\n\n<p><code>--enable-small</code> 的配置项，其实是在config.h里声称了CONFIG_SMALL选项，然后代码内根据CONFIG_SMALL做了一些调整，比如某些string类型就被省掉了，还有一些内置生成的table, 体积也被裁减掉了，用速度换体积。比如这里：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">if</span> CONFIG_SMALL</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> CRC_TABLE_SIZE 257</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">else</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> CRC_TABLE_SIZE 1024</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span></span></span><br></pre></td></tr></table></figure>\n\n<p>配置FFmpeg协议，由于我们使用本地文件，需要再加一个： <code>--enable-protocol=file</code>，要不然解码会报协议相关错误</p>\n<figure class=\"highlight powershell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"literal\">--disable-protocols</span>      disable all protocols</span><br></pre></td></tr></table></figure>\n\n<p>我们只需要在代码中使用 FFmpeg，所以直接禁用命令行工具</p>\n<figure class=\"highlight powershell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"literal\">--disable-programs</span>       <span class=\"keyword\">do</span> not build command line programs</span><br><span class=\"line\"><span class=\"literal\">--disable-ffmpeg</span>         disable ffmpeg build</span><br><span class=\"line\"><span class=\"literal\">--disable-ffplay</span>         disable ffplay build</span><br><span class=\"line\"><span class=\"literal\">--disable-ffprobe</span>        disable ffprobe build</span><br></pre></td></tr></table></figure>\n\n<p>还有几个比较重要的就是，主要是</p>\n<figure class=\"highlight powershell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"literal\">--disable-avdevice</span>       disable libavdevice build</span><br><span class=\"line\"><span class=\"literal\">--disable-swresample</span>     disable libswresample build</span><br><span class=\"line\"><span class=\"literal\">--disable-swscale</span>        disable libswscale build</span><br><span class=\"line\"><span class=\"literal\">--disable-postproc</span>       disable libpostproc build</span><br><span class=\"line\"><span class=\"literal\">--disable-avfilter</span>       disable libavfilter build</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"编译遇见的坑\"><a href=\"#编译遇见的坑\" class=\"headerlink\" title=\"编译遇见的坑\"></a>编译遇见的坑</h2><p><strong>1、aarch64-linux-android21-clang is unable to create an executable file.<br>C compiler test failed.</strong></p>\n<p>这个问题是困扰我最久的，按照解决方法：<br>原因 1： FFmpeg 4.2.2 版本默认使用了 clang 进行编译<br>解决：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">//1\\. 修改 configure 文件</span><br><span class=\"line\">vim configure</span><br><span class=\"line\">//2\\. 把 默认的 clang 修改为 gcc</span><br><span class=\"line\">if test &quot;$target_os&quot; = android; then</span><br><span class=\"line\">   # cc_default=&quot;clang&quot;</span><br><span class=\"line\">\t\t cc_default=&quot;gcc&quot;</span><br><span class=\"line\">fi</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>原因2，检查路径是否正确，主要是 NDK 的位置，以及不同 NDK 相关库可能存在一定的丢失。</p>\n<p>这个问题我在 macOS 上未解决，<strong>换用 CentOS 没有出现过这个编译问题</strong>。</p>\n<p><strong>2、 编译包大小一直不变</strong></p>\n<p>最开始我正常编译的时候发现怎么改配置，最后的包大小都没有发生变化，但是命令行里面各种流程又是在走，最终也有产物。这里一定要关注在执行了编译脚本之后，查看最开始的日志，看看具体是一些什么错，这里日志会刷得很快，如果包大小一直没有发生变化的话，可以执行完之后快速停止，看看是什么错。一般就是<code>C compiler test failed.</code> 或者找不到你的配置，改对即可。正常编译，会在开始后列出你的编译配置。</p>\n<p><strong>3、x86asm 相关的问题</strong></p>\n<p>编译的时候遇到一些 x86asm 的错，按照文章所说即可</p>\n","cover":null,"images":[],"content":"<p>此前项目一直使用的 FFmpeg.so 是我从其他团队项目中直接复制过来的，但原来的项目团队不再维护这个库，其中 x264 模块由于一些版权问题需要剔除，所以需要自己重新编译。在编译的过程中踩了很多坑，以及编译 congfigure 有太多的配置，如何减少整体编译出来的大小也是需要花点精力的，本文主要记录编译流程以及相关配置介绍。</p>\n<h2 id=\"编译介绍\"><a href=\"#编译介绍\" class=\"headerlink\" title=\"编译介绍\"></a>编译介绍</h2><p>自己编译主要参考<a href=\"https://github.com/Timdk857/Android-Architecture-knowledge-2-/blob/master/Android%20%E9%9F%B3%E8%A7%86%E9%A2%91%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97/Android-%E9%9F%B3%E8%A7%86%E9%A2%91%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97-(%E5%9B%9B)-%E4%B8%80%E9%94%AE%E7%BC%96%E8%AF%91-32-64-%E4%BD%8D-FFmpeg-4-2-2.md\">《一键编译32_64位FFmpeg.4.2.2》</a>，最开始的时候自己一直在 Mac M1 上编译，各种流程也是一比一复刻，但是仍然会有各种问题出现，最常见的就是：</p>\n<blockquote>\n<p>aarch64-linux-android21-clang is unable to create an executable file.<br>C compiler test failed.</p>\n</blockquote>\n<p>我反复检查了自己的 NDK 的配置，确保是正确的，文章也有提及处理方式，但是尝试下来都无效，在网上搜了一大篇解决方式，也都无效。不过我看他们很多都是用 Linux 系统进行的编译，遂改为使用 Linux 编译，再重新尝试，似乎没有那些个奇奇怪怪的错误了，也打出了最终的包，最后的 so 大小也符合要求。</p>\n<h3 id=\"编译环境\"><a href=\"#编译环境\" class=\"headerlink\" title=\"编译环境\"></a>编译环境</h3><ul>\n<li>CentOS 7</li>\n<li><a href=\"https://ffmpeg.org/releases/ffmpeg-4.2.2.tar.bz2\">ffmpeg-4.2.2</a></li>\n<li><a href=\"https://github.com/android/ndk/wiki/Unsupported-Downloads\">android-ndk-r20b-linux-x86_64.zip</a></li>\n</ul>\n<h3 id=\"编译脚本\"><a href=\"#编译脚本\" class=\"headerlink\" title=\"编译脚本\"></a>编译脚本</h3><p>这是我的一份编译脚本，我的需求是进行本地视频抽帧，所以不需要像滤镜、编码、音频相关的配置，只需要视频解码相关的配置，具体配置在下一节有讲解。</p>\n<figure class=\"highlight powershell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#!/bin/bash</span></span><br><span class=\"line\">export NDK=.../android<span class=\"literal\">-ndk-r20b</span></span><br><span class=\"line\">TOOLCHAIN=<span class=\"variable\">$NDK</span>/toolchains/llvm/prebuilt/linux<span class=\"literal\">-x86_64</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">build_android</span></span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">./configure \\ </span><br><span class=\"line\"><span class=\"literal\">--prefix</span>=<span class=\"variable\">$PREFIX</span> \\ </span><br><span class=\"line\"><span class=\"literal\">--enable-neon</span> \\ </span><br><span class=\"line\"><span class=\"literal\">--disable-x86asm</span> \\ </span><br><span class=\"line\"><span class=\"literal\">--disable-hwaccels</span> \\ </span><br><span class=\"line\"><span class=\"literal\">--disable-gpl</span> \\ </span><br><span class=\"line\"><span class=\"literal\">--disable-nonfree</span> \\ </span><br><span class=\"line\"><span class=\"literal\">--disable-version3</span> \\ </span><br><span class=\"line\"><span class=\"literal\">--disable-postproc</span> \\ </span><br><span class=\"line\"><span class=\"literal\">--disable-bsfs</span> \\ </span><br><span class=\"line\"><span class=\"literal\">--disable-protocols</span> \\ </span><br><span class=\"line\"><span class=\"literal\">--enable-protocol</span>=file \\ </span><br><span class=\"line\"><span class=\"literal\">--disable-indevs</span> \\ </span><br><span class=\"line\"><span class=\"literal\">--disable-outdevs</span> \\ </span><br><span class=\"line\"><span class=\"literal\">--disable-debug</span> \\ </span><br><span class=\"line\"><span class=\"literal\">--enable-small</span> \\ </span><br><span class=\"line\"><span class=\"literal\">--enable-jni</span> \\ </span><br><span class=\"line\"><span class=\"literal\">--disable-mediacodec</span> \\ </span><br><span class=\"line\"><span class=\"literal\">--disable-decoder</span>=h264_mediacodec \\ </span><br><span class=\"line\"><span class=\"literal\">--enable-swscale</span> \\ </span><br><span class=\"line\"><span class=\"literal\">--enable-static</span> \\ </span><br><span class=\"line\"><span class=\"literal\">--disable-shared</span> \\ </span><br><span class=\"line\"><span class=\"literal\">--disable-filters</span> \\ </span><br><span class=\"line\"><span class=\"literal\">--disable-avfilter</span> \\ </span><br><span class=\"line\"><span class=\"literal\">--disable-encoders</span> \\ </span><br><span class=\"line\"><span class=\"literal\">--disable-muxers</span> \\ </span><br><span class=\"line\"><span class=\"literal\">--disable-demuxers</span> \\ </span><br><span class=\"line\"><span class=\"literal\">--enable-demuxer</span>=avi \\ </span><br><span class=\"line\"><span class=\"literal\">--enable-demuxer</span>=flv \\ </span><br><span class=\"line\"><span class=\"literal\">--enable-demuxer</span>=h261 \\ </span><br><span class=\"line\"><span class=\"literal\">--enable-demuxer</span>=h263 \\ </span><br><span class=\"line\"><span class=\"literal\">--enable-demuxer</span>=h264 \\ </span><br><span class=\"line\"><span class=\"literal\">--enable-demuxer</span>=hevc \\ </span><br><span class=\"line\"><span class=\"literal\">--enable-demuxer</span>=mov \\ </span><br><span class=\"line\"><span class=\"literal\">--enable-demuxer</span>=m4v \\ </span><br><span class=\"line\"><span class=\"literal\">--disable-decoders</span> \\ </span><br><span class=\"line\"><span class=\"literal\">--enable-decoder</span>=h263 \\ </span><br><span class=\"line\"><span class=\"literal\">--enable-decoder</span>=h263i \\ </span><br><span class=\"line\"><span class=\"literal\">--enable-decoder</span>=h263p \\ </span><br><span class=\"line\"><span class=\"literal\">--enable-decoder</span>=h264 \\ </span><br><span class=\"line\"><span class=\"literal\">--enable-decoder</span>=hevc \\ </span><br><span class=\"line\"><span class=\"literal\">--enable-decoder</span>=flv \\ </span><br><span class=\"line\"><span class=\"literal\">--enable-decoder</span>=mpeg4 \\ </span><br><span class=\"line\"><span class=\"literal\">--disable-parsers</span> \\ </span><br><span class=\"line\"><span class=\"literal\">--enable-parser</span>=h264 \\ </span><br><span class=\"line\"><span class=\"literal\">--enable-parser</span>=h261 \\ </span><br><span class=\"line\"><span class=\"literal\">--enable-parser</span>=h263 \\ </span><br><span class=\"line\"><span class=\"literal\">--enable-parser</span>=mpeg4video \\ </span><br><span class=\"line\"><span class=\"literal\">--enable-parser</span>=mpegvideo \\ </span><br><span class=\"line\"><span class=\"literal\">--disable-htmlpages</span> \\ </span><br><span class=\"line\"><span class=\"literal\">--disable-manpages</span> \\ </span><br><span class=\"line\"><span class=\"literal\">--disable-podpages</span> \\ </span><br><span class=\"line\"><span class=\"literal\">--disable-txtpages</span> \\ </span><br><span class=\"line\"><span class=\"literal\">--disable-vaapi</span> \\ </span><br><span class=\"line\"><span class=\"literal\">--disable-v4l2-m2m</span> \\ </span><br><span class=\"line\"><span class=\"literal\">--disable-nvdec</span> \\ </span><br><span class=\"line\"><span class=\"literal\">--disable-nvenc</span> \\ </span><br><span class=\"line\"><span class=\"literal\">--disable-ffnvcodec</span> \\ </span><br><span class=\"line\"><span class=\"literal\">--disable-dxva2</span> \\ </span><br><span class=\"line\"><span class=\"literal\">--disable-d3d11va</span> \\ </span><br><span class=\"line\"><span class=\"literal\">--disable-cuvid</span> \\ </span><br><span class=\"line\"><span class=\"literal\">--disable-cuda-llvm</span> \\ </span><br><span class=\"line\"><span class=\"literal\">--disable-cuda-nvcc</span> \\ </span><br><span class=\"line\"><span class=\"literal\">--disable-audiotoolbox</span> \\ </span><br><span class=\"line\"><span class=\"literal\">--disable-amf</span> \\ </span><br><span class=\"line\"><span class=\"literal\">--disable-iconv</span> \\ </span><br><span class=\"line\"><span class=\"literal\">--disable-libxcb</span> \\ </span><br><span class=\"line\"><span class=\"literal\">--disable-libxcb-shm</span> \\ </span><br><span class=\"line\"><span class=\"literal\">--disable-libxcb-xfixes</span> \\ </span><br><span class=\"line\"><span class=\"literal\">--disable-libxcb-shape</span> \\ </span><br><span class=\"line\"><span class=\"literal\">--disable-lzma</span> \\ </span><br><span class=\"line\"><span class=\"literal\">--disable-sdl2</span> \\ </span><br><span class=\"line\"><span class=\"literal\">--disable-securetransport</span> \\ </span><br><span class=\"line\"><span class=\"literal\">--disable-xlib</span> \\ </span><br><span class=\"line\"><span class=\"literal\">--disable-zlib</span> \\ </span><br><span class=\"line\"><span class=\"literal\">--disable-programs</span> \\ </span><br><span class=\"line\"><span class=\"literal\">--disable-ffmpeg</span> \\ </span><br><span class=\"line\"><span class=\"literal\">--disable-ffplay</span> \\ </span><br><span class=\"line\"><span class=\"literal\">--disable-ffprobe</span> \\ </span><br><span class=\"line\"><span class=\"literal\">--disable-avdevice</span> \\ </span><br><span class=\"line\"><span class=\"literal\">--disable-symver</span> \\ </span><br><span class=\"line\"><span class=\"literal\">--cross-prefix</span>=<span class=\"variable\">$CROSS_PREFIX</span> \\ </span><br><span class=\"line\"><span class=\"literal\">--target-os</span>=android \\ </span><br><span class=\"line\"><span class=\"literal\">--arch</span>=<span class=\"variable\">$ARCH</span> \\ </span><br><span class=\"line\"><span class=\"literal\">--cpu</span>=<span class=\"variable\">$CPU</span> \\ </span><br><span class=\"line\"><span class=\"literal\">--cc</span>=<span class=\"variable\">$CC</span> \\ </span><br><span class=\"line\"><span class=\"literal\">--cxx</span>=<span class=\"variable\">$CXX</span> \\ </span><br><span class=\"line\"><span class=\"literal\">--enable-cross-compile</span> \\ </span><br><span class=\"line\"><span class=\"literal\">--sysroot</span>=<span class=\"variable\">$SYSROOT</span> \\ </span><br><span class=\"line\"><span class=\"literal\">--extra-cflags</span>=<span class=\"string\">&quot;-Os -fpic <span class=\"variable\">$OPTIMIZE_CFLAGS</span>&quot;</span> \\ </span><br><span class=\"line\"><span class=\"literal\">--extra-ldflags</span>=<span class=\"string\">&quot;<span class=\"variable\">$ADDI_LDFLAGS</span>&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">make clean</span><br><span class=\"line\">make <span class=\"literal\">-j16</span></span><br><span class=\"line\">make install</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#arm64-v8a</span></span><br><span class=\"line\">ARCH=arm64</span><br><span class=\"line\">CPU=armv8<span class=\"literal\">-a</span></span><br><span class=\"line\">API=<span class=\"number\">21</span></span><br><span class=\"line\">CC=<span class=\"variable\">$TOOLCHAIN</span>/bin/aarch64<span class=\"literal\">-linux-android</span><span class=\"variable\">$API</span><span class=\"literal\">-clang</span></span><br><span class=\"line\">CXX=<span class=\"variable\">$TOOLCHAIN</span>/bin/aarch64<span class=\"literal\">-linux-android</span><span class=\"variable\">$API</span><span class=\"literal\">-clang</span>++</span><br><span class=\"line\">SYSROOT=<span class=\"variable\">$NDK</span>/toolchains/llvm/prebuilt/linux<span class=\"literal\">-x86_64</span>/sysroot</span><br><span class=\"line\">CROSS_PREFIX=<span class=\"variable\">$TOOLCHAIN</span>/bin/aarch64<span class=\"literal\">-linux-android-</span></span><br><span class=\"line\">PREFIX=<span class=\"variable\">$</span>(<span class=\"built_in\">pwd</span>)/android/<span class=\"variable\">$CPU</span></span><br><span class=\"line\">OPTIMIZE_CFLAGS=<span class=\"string\">&quot;-march=<span class=\"variable\">$CPU</span>&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">build_android</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#armv7-a</span></span><br><span class=\"line\">ARCH=arm</span><br><span class=\"line\">CPU=armv7<span class=\"literal\">-a</span></span><br><span class=\"line\">API=<span class=\"number\">21</span></span><br><span class=\"line\">CC=<span class=\"variable\">$TOOLCHAIN</span>/bin/armv7a<span class=\"literal\">-linux-androideabi</span><span class=\"variable\">$API</span><span class=\"literal\">-clang</span></span><br><span class=\"line\">CXX=<span class=\"variable\">$TOOLCHAIN</span>/bin/armv7a<span class=\"literal\">-linux-androideabi</span><span class=\"variable\">$API</span><span class=\"literal\">-clang</span>++</span><br><span class=\"line\">SYSROOT=<span class=\"variable\">$NDK</span>/toolchains/llvm/prebuilt/linux<span class=\"literal\">-x86_64</span>/sysroot</span><br><span class=\"line\">CROSS_PREFIX=<span class=\"variable\">$TOOLCHAIN</span>/bin/arm<span class=\"literal\">-linux-androideabi-</span></span><br><span class=\"line\">PREFIX=<span class=\"variable\">$</span>(<span class=\"built_in\">pwd</span>)/android/<span class=\"variable\">$CPU</span></span><br><span class=\"line\">OPTIMIZE_CFLAGS=<span class=\"string\">&quot;-mfloat-abi=softfp -mfpu=vfp -marm -march=<span class=\"variable\">$CPU</span> &quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">build_android</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"配置介绍\"><a href=\"#配置介绍\" class=\"headerlink\" title=\"配置介绍\"></a>配置介绍</h2><p>通过执行 <code>./configure --help</code> 能得到所有的配置选项，整个配置也非常好理解，通过 list-xxx 可以知道有哪些子选项，然后再通过 <code>--disable-xxx</code>,或者 <code>--enable-xxx</code> 进行关闭或者打开。以解码为例：</p>\n<figure class=\"highlight powershell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"literal\">--disable-decoders</span>       <span class=\"comment\"># 先关闭所有的解码器</span></span><br><span class=\"line\"><span class=\"literal\">--enable-decoder</span>=flv     <span class=\"comment\"># 然后只打开flv、mpeg4 的支持</span></span><br><span class=\"line\"><span class=\"literal\">--enable-decoder</span>=mpeg4 </span><br></pre></td></tr></table></figure>\n<p>对于<code>--enable-decoder=xxx</code>中的xxx可以通过 <code>./configure --list-decoders</code> 进行查看，同理 <code>encoders</code> <code>demuxers</code> <code>muxers</code> 等都是类似的处理，通过 <code>--help</code> 可以通过 <code>list--xxx</code> 查看不同功能的可以支持的配置，主要有以下：</p>\n<figure class=\"highlight powershell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"literal\">--list-decoders</span>          show all available decoders</span><br><span class=\"line\"><span class=\"literal\">--list-encoders</span>          show all available encoders</span><br><span class=\"line\"><span class=\"literal\">--list-hwaccels</span>          show all available hardware accelerators</span><br><span class=\"line\"><span class=\"literal\">--list-demuxers</span>          show all available demuxers</span><br><span class=\"line\"><span class=\"literal\">--list-muxers</span>            show all available muxers</span><br><span class=\"line\"><span class=\"literal\">--list-parsers</span>           show all available parsers</span><br><span class=\"line\"><span class=\"literal\">--list-protocols</span>         show all available protocols</span><br><span class=\"line\"><span class=\"literal\">--list-bsfs</span>              show all available bitstream filters</span><br><span class=\"line\"><span class=\"literal\">--list-indevs</span>            show all available input devices</span><br><span class=\"line\"><span class=\"literal\">--list-outdevs</span>           show all available output devices</span><br><span class=\"line\"><span class=\"literal\">--list-filters</span>           show all available filters</span><br></pre></td></tr></table></figure>\n\n<p>其他的配置就是一些实际性的开关配置，列一些常用的配置：</p>\n<p>配置产物为静态库(.a)或者动态库(.so)</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">--enable-static         do not build static libraries [no]</span><br><span class=\"line\">--enable-shared         build shared libraries [no]</span><br></pre></td></tr></table></figure>\n\n<p>配置减少包大小</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">--enable-small           optimize for size instead of speed</span><br></pre></td></tr></table></figure>\n\n<p><code>--enable-small</code> 的配置项，其实是在config.h里声称了CONFIG_SMALL选项，然后代码内根据CONFIG_SMALL做了一些调整，比如某些string类型就被省掉了，还有一些内置生成的table, 体积也被裁减掉了，用速度换体积。比如这里：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">if</span> CONFIG_SMALL</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> CRC_TABLE_SIZE 257</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">else</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> CRC_TABLE_SIZE 1024</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span></span></span><br></pre></td></tr></table></figure>\n\n<p>配置FFmpeg协议，由于我们使用本地文件，需要再加一个： <code>--enable-protocol=file</code>，要不然解码会报协议相关错误</p>\n<figure class=\"highlight powershell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"literal\">--disable-protocols</span>      disable all protocols</span><br></pre></td></tr></table></figure>\n\n<p>我们只需要在代码中使用 FFmpeg，所以直接禁用命令行工具</p>\n<figure class=\"highlight powershell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"literal\">--disable-programs</span>       <span class=\"keyword\">do</span> not build command line programs</span><br><span class=\"line\"><span class=\"literal\">--disable-ffmpeg</span>         disable ffmpeg build</span><br><span class=\"line\"><span class=\"literal\">--disable-ffplay</span>         disable ffplay build</span><br><span class=\"line\"><span class=\"literal\">--disable-ffprobe</span>        disable ffprobe build</span><br></pre></td></tr></table></figure>\n\n<p>还有几个比较重要的就是，主要是</p>\n<figure class=\"highlight powershell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"literal\">--disable-avdevice</span>       disable libavdevice build</span><br><span class=\"line\"><span class=\"literal\">--disable-swresample</span>     disable libswresample build</span><br><span class=\"line\"><span class=\"literal\">--disable-swscale</span>        disable libswscale build</span><br><span class=\"line\"><span class=\"literal\">--disable-postproc</span>       disable libpostproc build</span><br><span class=\"line\"><span class=\"literal\">--disable-avfilter</span>       disable libavfilter build</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"编译遇见的坑\"><a href=\"#编译遇见的坑\" class=\"headerlink\" title=\"编译遇见的坑\"></a>编译遇见的坑</h2><p><strong>1、aarch64-linux-android21-clang is unable to create an executable file.<br>C compiler test failed.</strong></p>\n<p>这个问题是困扰我最久的，按照解决方法：<br>原因 1： FFmpeg 4.2.2 版本默认使用了 clang 进行编译<br>解决：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">//1\\. 修改 configure 文件</span><br><span class=\"line\">vim configure</span><br><span class=\"line\">//2\\. 把 默认的 clang 修改为 gcc</span><br><span class=\"line\">if test &quot;$target_os&quot; = android; then</span><br><span class=\"line\">   # cc_default=&quot;clang&quot;</span><br><span class=\"line\">\t\t cc_default=&quot;gcc&quot;</span><br><span class=\"line\">fi</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>原因2，检查路径是否正确，主要是 NDK 的位置，以及不同 NDK 相关库可能存在一定的丢失。</p>\n<p>这个问题我在 macOS 上未解决，<strong>换用 CentOS 没有出现过这个编译问题</strong>。</p>\n<p><strong>2、 编译包大小一直不变</strong></p>\n<p>最开始我正常编译的时候发现怎么改配置，最后的包大小都没有发生变化，但是命令行里面各种流程又是在走，最终也有产物。这里一定要关注在执行了编译脚本之后，查看最开始的日志，看看具体是一些什么错，这里日志会刷得很快，如果包大小一直没有发生变化的话，可以执行完之后快速停止，看看是什么错。一般就是<code>C compiler test failed.</code> 或者找不到你的配置，改对即可。正常编译，会在开始后列出你的编译配置。</p>\n<p><strong>3、x86asm 相关的问题</strong></p>\n<p>编译的时候遇到一些 x86asm 的错，按照文章所说即可</p>\n","categories":[],"tags":[{"name":"FFmpeg","slug":"FFmpeg","api":"api/tags/FFmpeg.json"}],"api":"api/posts/2023/01/09/FFmpeg-so-编译整理.json"}],"info":{"type":"archive","year":2023}},"api":"api/archives/2023/page.1.json"}