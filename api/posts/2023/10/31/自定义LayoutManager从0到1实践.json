{"data":{"title":"RecyclerView自定义LayoutManager从0到1实践","slug":"自定义LayoutManager从0到1实践","description":"","date":"2023-10-31T11:19:00.000Z","updated":"2025-05-20T11:46:57.000Z","language":"zh-CN","comments":true,"url":"2023/10/31/自定义LayoutManager从0到1实践/","cover":null,"images":[],"content":"<p>此前大部分涉及到 RecyclerView 页面的 LayoutManager基本上用系统提供的 LinearLayoutManager 、GridLayoutManager 就能解决，但在一些特殊场景上还是需要我们自定义  LayoutManager。之前基本上没有自己写过，在网上看各种源码各种文章，刚开始花了好多时间去理解整体流程，因为它们都给我一种非常非常复杂的感觉，包括相关的博客文章也是。经过一段时间摸索，也慢慢能理解为什么要那么复杂了，这的确不是特别容易入门。所以对整体的流程进行了一个拆解，尽量原子化一点，对自己学习的一个总结，也希望能帮助到一部分人能对  LayoutManager 入门。</p>\n<p>本文最终实现一个简单的 LinearLayoutManager（只支持 VERTICAL）方向，适合对 LayoutManager 整体流程的学习与理解，整体代码分为多个文件，每个文件都是对前一段代码的补充，方便理解，整体项目源码已提交 Github: <a href=\"https://github.com/VomPom/LayoutManagerGradually\">LayoutManagerGradually</a>，代码里面写了很多很多注释，如果不想浪费时间，可以直接看代码运行，跳过这篇文章，把每一个 LayoutManager 都跑一下体验结合代码看看。</p>\n<h2 id=\"自定义-LayoutManager-的必要元素\"><a href=\"#自定义-LayoutManager-的必要元素\" class=\"headerlink\" title=\"自定义 LayoutManager 的必要元素\"></a>自定义 LayoutManager 的必要元素</h2><ul>\n<li><p>继承 <code>RecyclerView.LayoutManager</code> 并实现 <code>generateDefaultLayoutParams()</code>方法</p>\n</li>\n<li><p>重写<code>onLayoutChildren</code> 第一次数据填充的时候数据添加</p>\n</li>\n<li><p>重写 <code>canScrollHorizontally()</code> 和<code>canScrollVertically()</code>方法设定支持滑动的方向</p>\n</li>\n<li><p>重写 <code>scrollHorizontallyBy()</code>和<code>scrollVerticallyBy()</code>方法，在滑动的时候对屏幕以外的 View 进行回收，以及填充即将滑动进入屏幕范围内的 View 进行填充</p>\n</li>\n<li><p>重写 <code>scrollToPosition()</code>和<code>smoothScrollToPosition()</code>方法支持</p>\n</li>\n</ul>\n<p>其中<code>onLayoutChildren</code> 和 <code>scrollHorizontallyBy/scrollVerticallyBy</code> 是最核心且最复杂的方法，这里稍微拎出来讲一下</p>\n<h3 id=\"onLayoutChildren\"><a href=\"#onLayoutChildren\" class=\"headerlink\" title=\"onLayoutChildren\"></a>onLayoutChildren</h3><p>这个方法类似于自定义 ViewGroup 的 onLayout() 方法，RecyclerView 的 LayoutManager.onLayoutChildren 在以下几个时机会被触发：</p>\n<ul>\n<li>当 <code>RecyclerView</code> 首次附加到窗口时</li>\n<li>当<code>Adapter</code>  的数据集发生变化</li>\n<li>当 <code>RecyclerView</code> 被 执行 <code>RequetLayout</code>的时候</li>\n<li>当 <code>LayoutManager</code> 发生变化时</li>\n</ul>\n<h3 id=\"scrollHorizontallyBy-scrollVerticallyBy\"><a href=\"#scrollHorizontallyBy-scrollVerticallyBy\" class=\"headerlink\" title=\"scrollHorizontallyBy/scrollVerticallyBy\"></a>scrollHorizontallyBy/scrollVerticallyBy</h3><p>方法的主要作用包括：</p>\n<ol>\n<li><p>更新 ItemView 的位置：根据传入的垂直滚动距离（dy 参数），更新子视图在屏幕上的位置。通常调用 <code>offsetChildrenVertical</code> 方法。</p>\n</li>\n<li><p>回收不可见的 ItemView：在滚动过程中，一些 ItemView 可能会离开屏幕，变得不可见。<code>scrollVerticallyBy</code> 方法需要负责回收这些子视图并将它们放入回收池，以便稍后复用。</p>\n</li>\n<li><p>添加新的 ItemView：在滚动过程中，新的 ItemView 可能需要显示在屏幕上。<code>scrollVerticallyBy</code> 方法需要从回收池中获取可复用的视图并将它们添加到屏幕上。这通常涉及到调用 <code>RecyclerView.Recycler</code> 的 <code>getViewForPosition</code> 方法。</p>\n</li>\n<li><p>返回实际滚动距离：由于 ItemView 的数量有限，滚动可能会受到限制。例如，当滚动到列表顶部或底部时，滚动可能会停止。在这种情况下，实际滚动的距离可能会小于传入的 <code>dy</code> 参数。<code>scrollVerticallyBy</code> 方法需要返回实际滚动的距离，以便 <code>RecyclerView</code> 可以正确地更新滚动条和触发滚动事件。</p>\n</li>\n</ol>\n<p>概念就简单讲这么多， talk is cheap show me the code，直接看代码理解会比较深刻</p>\n<h2 id=\"逐步实现\"><a href=\"#逐步实现\" class=\"headerlink\" title=\"逐步实现\"></a>逐步实现</h2><p>要实现一个可用的 LayoutManger 通常我们需要实现以下流程</p>\n<ul>\n<li>数据填充并且只需要填充屏幕范围内的 ItemView</li>\n<li>回收掉屏幕以外的 ItemView</li>\n<li>屏幕外 ItemView 再回到屏幕后，需要重新填充</li>\n<li>对滑动边界边界进行处理</li>\n<li>对 scrollToPosition 和 smoothScrollToPosition进行支持</li>\n</ul>\n<p>我们不用一上来就实现最终的效果，而是一步一步来，看看 LayoutManger 是怎么渐渐地变化，最终能跑起来的。</p>\n<h3 id=\"0-最简单的-LayoutManager\"><a href=\"#0-最简单的-LayoutManager\" class=\"headerlink\" title=\"0 最简单的 LayoutManager\"></a>0 最简单的 LayoutManager</h3><p>代码查看：<a href=\"https://github.com/VomPom/LayoutManagerGradually/tree/main/layoutmanager/src/main/java/com/julis/layoutmanager/series/MostSimpleLayoutManager.kt\">MostSimpleLayoutManager</a>，我们关注 <code>onLayoutChildren</code> 方法:</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onLayoutChildren</span><span class=\"params\">(recycler: <span class=\"type\">RecyclerView</span>.<span class=\"type\">Recycler</span>, state: <span class=\"type\">RecyclerView</span>.<span class=\"type\">State</span>?)</span></span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 垂直方向的偏移量</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> offsetTop = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"comment\">// 实际业务中最好不要这样一次性加载所有的数据，这里只是最简单地演示一下整体是如何工作的</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (itemIndex <span class=\"keyword\">in</span> <span class=\"number\">0</span> until itemCount) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 从适配器获取与给定位置关联的视图</span></span><br><span class=\"line\">        <span class=\"keyword\">val</span> itemView = recycler.getViewForPosition(itemIndex)</span><br><span class=\"line\">        <span class=\"comment\">// 将视图添加到 RecyclerView 中</span></span><br><span class=\"line\">        addView(itemView)</span><br><span class=\"line\">        <span class=\"comment\">// 测量并布局视图</span></span><br><span class=\"line\">        measureChildWithMargins(itemView, <span class=\"number\">0</span>, <span class=\"number\">0</span>)</span><br><span class=\"line\">        <span class=\"comment\">// 拿到宽高（包括ItemDecoration）</span></span><br><span class=\"line\">        <span class=\"keyword\">val</span> width = getDecoratedMeasuredWidth(itemView)</span><br><span class=\"line\">        <span class=\"keyword\">val</span> height = getDecoratedMeasuredHeight(itemView)</span><br><span class=\"line\">        <span class=\"comment\">// 对要添加的子 View 进行布局</span></span><br><span class=\"line\">        layoutDecorated(itemView, <span class=\"number\">0</span>, offsetTop, width, offsetTop + height)</span><br><span class=\"line\">        offsetTop += height</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面的代码主要演示了，如何利用<code>addView</code> <code>layoutDecorated</code>等方法，将 ItemView 添加到 RecyclerView 上。代码可见是 将所有的 ItemView（即使它在屏幕上不可见）一次性全部加载到了 RecyclerView上， 这里一般不这么做，只是这里这里只是最简单地演示一下整体是如何工作的。</p>\n<p>运行在手机上能看到这样的效果：Item数据已经被全部添加到界面上了，并且各个方向的滑动都支持。</p>\n<img src=\"https://cdn.julis.wang/blog/img/layoutmanager_gradually_0.gif?imageView2/2/w/300\">\n<h3 id=\"1-更合理的数据添加方式\"><a href=\"#1-更合理的数据添加方式\" class=\"headerlink\" title=\"1 更合理的数据添加方式\"></a>1 更合理的数据添加方式</h3><p>代码查看：<a href=\"https://github.com/VomPom/LayoutManagerGradually/tree/main/layoutmanager/src/main/java/com/julis/layoutmanager/series/LinearLayoutManager1\">LinearLayoutManager1.kt</a></p>\n<p>对最开始的代码进行优化，只在屏幕范围内的区域进行数据的添加，这样就不需要一次性将所有数据就添加上去，如果 Adapter 的 ItemCount 足够巨大，for all addView 的话，很容易就 OOM。</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onLayoutChildren</span><span class=\"params\">(recycler: <span class=\"type\">RecyclerView</span>.<span class=\"type\">Recycler</span>, state: <span class=\"type\">RecyclerView</span>.<span class=\"type\">State</span>)</span></span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 垂直方向上的的空间大小</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> remainSpace = height - paddingTop</span><br><span class=\"line\">    <span class=\"comment\">//垂直方向的偏移量</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> offsetTop = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> currentPosition = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (remainSpace &gt; <span class=\"number\">0</span> &amp;&amp; currentPosition &lt; state.itemCount) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 从适配器获取与给定位置关联的视图</span></span><br><span class=\"line\">        <span class=\"keyword\">val</span> itemView = recycler.getViewForPosition(currentPosition)</span><br><span class=\"line\">        <span class=\"comment\">// 将视图添加到 RecyclerView 中</span></span><br><span class=\"line\">        addView(itemView)</span><br><span class=\"line\">        <span class=\"comment\">// 测量并布局视图</span></span><br><span class=\"line\">        measureChildWithMargins(itemView, <span class=\"number\">0</span>, <span class=\"number\">0</span>)</span><br><span class=\"line\">        <span class=\"comment\">// 拿到宽高（包括ItemDecoration）</span></span><br><span class=\"line\">        <span class=\"keyword\">val</span> itemWidth = getDecoratedMeasuredWidth(itemView)</span><br><span class=\"line\">        <span class=\"keyword\">val</span> itemHeight = getDecoratedMeasuredHeight(itemView)</span><br><span class=\"line\">        <span class=\"comment\">// 对要添加的子 View 进行布局</span></span><br><span class=\"line\">        layoutDecorated(itemView, <span class=\"number\">0</span>, offsetTop, itemWidth, offsetTop + itemHeight)</span><br><span class=\"line\">        offsetTop += itemHeight</span><br><span class=\"line\">        currentPosition++</span><br><span class=\"line\">        <span class=\"comment\">// 可用空间减少</span></span><br><span class=\"line\">        remainSpace -= itemHeight</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-对屏幕外的View回收\"><a href=\"#2-对屏幕外的View回收\" class=\"headerlink\" title=\"2 对屏幕外的View回收\"></a>2 对屏幕外的View回收</h3><p>代码查看：<a href=\"https://github.com/VomPom/LayoutManagerGradually/tree/main/layoutmanager/src/main/java/com/julis/layoutmanager/series/LinearLayoutManager2.kt\">LinearLayoutManager2</a></p>\n<p>RecylerView 没有 recycler 怎么行呢？当 RecylerView 的 ItemView 滑出屏幕后我们需要对齐进行回收，实现的话需要在 <code>scrollVerticallyBy</code>中，比较复杂的逻辑就是怎么去判断：ItemView 在屏幕以外，最后利用：<code>removeAndRecycleView</code>方法进行回收</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">scrollVerticallyBy</span><span class=\"params\">(dy: <span class=\"type\">Int</span>, recycler: <span class=\"type\">RecyclerView</span>.<span class=\"type\">Recycler</span>, state: <span class=\"type\">RecyclerView</span>.<span class=\"type\">State</span>?)</span></span>: <span class=\"built_in\">Int</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 在这里处理上下的滚动逻辑，dy 表示滚动的距离</span></span><br><span class=\"line\">      <span class=\"comment\">// 平移所有子视图</span></span><br><span class=\"line\">      offsetChildrenVertical(-dy)</span><br><span class=\"line\">      <span class=\"comment\">// 如果实际滚动距离与 dy 相同，返回 dy；如果未滚动，返回 0</span></span><br><span class=\"line\">      recycleInvisibleView(dy, recycler)</span><br><span class=\"line\">      <span class=\"keyword\">return</span> dy</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 回收掉在界面上看不到的 ItemView</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> dy</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> recycler</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">recycleInvisibleView</span><span class=\"params\">(dy: <span class=\"type\">Int</span>, recycler: <span class=\"type\">RecyclerView</span>.<span class=\"type\">Recycler</span>)</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">val</span> totalSpace = orientationHelper.totalSpace</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 将要回收View的集合</span></span><br><span class=\"line\">    <span class=\"keyword\">val</span> recycleViews = hashSetOf&lt;View&gt;()</span><br><span class=\"line\">    <span class=\"comment\">// 从下往上滑</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (dy &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (i <span class=\"keyword\">in</span> <span class=\"number\">0</span> until childCount) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">val</span> child = getChildAt(i)!!</span><br><span class=\"line\">            <span class=\"comment\">// 从下往上滑从最上面的 item 开始计算</span></span><br><span class=\"line\">            <span class=\"keyword\">val</span> top = getDecoratedTop(child)</span><br><span class=\"line\">            <span class=\"comment\">// 判断最顶部的 item 是否已经完全不可见，如何可见，那说明底下的 item 也是可见</span></span><br><span class=\"line\">            <span class=\"keyword\">val</span> height = top - getDecoratedBottom(child)</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (height - top &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">break</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            recycleViews.add(child)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (dy &lt; <span class=\"number\">0</span>) &#123;   <span class=\"comment\">// 从上往下滑</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (i <span class=\"keyword\">in</span> childCount - <span class=\"number\">1</span> downTo <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">val</span> child = getChildAt(i)!!</span><br><span class=\"line\">            <span class=\"comment\">// 从上往下滑从最底部的 item 开始计算</span></span><br><span class=\"line\">            <span class=\"keyword\">val</span> bottom = getDecoratedBottom(child)</span><br><span class=\"line\">            <span class=\"comment\">// 判断最底部的 item 是否已经完全不可见，如何可见，那说明上面的 item 也是可见</span></span><br><span class=\"line\">            <span class=\"keyword\">val</span> height = bottom - getDecoratedTop(child)</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (bottom - totalSpace &lt; height) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">break</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            recycleViews.add(child)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 真正把 View 移除掉的逻辑</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (view <span class=\"keyword\">in</span> recycleViews) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// [removeAndRecycleView]</span></span><br><span class=\"line\">        <span class=\"comment\">// 用于从视图层次结构中删除某个视图，并将其资源回收，以便在需要时重新利用</span></span><br><span class=\"line\">        removeAndRecycleView(view, recycler)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    recycleViews.clear()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>运行在手机上能看到这样的效果：滑出屏幕外的ItemView 被回收掉了</p>\n<img src=\"https://cdn.julis.wang/blog/img/layoutmanager_gradually_2.gif?imageView2/2/w/300\">\n<h3 id=\"3-向上滑动的时View的填充\"><a href=\"#3-向上滑动的时View的填充\" class=\"headerlink\" title=\"3 向上滑动的时View的填充\"></a>3 向上滑动的时View的填充</h3><p>代码查看：<a href=\"https://github.com/VomPom/LayoutManagerGradually/tree/main/layoutmanager/src/main/java/com/julis/layoutmanager/series/LinearLayoutManager3.kt\">LinearLayoutManager3</a></p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">scrollVerticallyBy</span><span class=\"params\">(dy: <span class=\"type\">Int</span>, recycler: <span class=\"type\">RecyclerView</span>.<span class=\"type\">Recycler</span>, state: <span class=\"type\">RecyclerView</span>.<span class=\"type\">State</span>?)</span></span>: <span class=\"built_in\">Int</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 填充 view</span></span><br><span class=\"line\">    fillView(dy, recycler)</span><br><span class=\"line\">    <span class=\"comment\">// 移动 view</span></span><br><span class=\"line\">    offsetChildrenVertical(-dy)</span><br><span class=\"line\">    <span class=\"comment\">// 回收 View</span></span><br><span class=\"line\">    recycleInvisibleView(dy, recycler)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> dy</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 填充重新进入屏幕内的 ItemView</span></span><br><span class=\"line\"><span class=\"comment\"> *     getChildCount():childCount-&gt; 当前屏幕内RecyclerView展示的 ItemView 数量</span></span><br><span class=\"line\"><span class=\"comment\"> *     getItemCount():itemCount-&gt; 最大的 ItemView 数量，也就是 Adapter 传递的数据的数量</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">fillView</span><span class=\"params\">(dy: <span class=\"type\">Int</span>, recycler: <span class=\"type\">RecyclerView</span>.<span class=\"type\">Recycler</span>)</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">val</span> verticalSpace = orientationVerticalHelper.totalSpace</span><br><span class=\"line\">    <span class=\"keyword\">var</span> remainSpace = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> nextFillPosition = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"comment\">//垂直方向的偏移量</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> offsetTop = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> offsetLeft = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"comment\">// 从下往上滑，那么需要向底部添加数据</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (dy &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">val</span> anchorView = getChildAt(childCount - <span class=\"number\">1</span>) ?: <span class=\"keyword\">return</span></span><br><span class=\"line\">        <span class=\"keyword\">val</span> anchorPosition = getPosition(anchorView)</span><br><span class=\"line\">        <span class=\"keyword\">val</span> anchorBottom = getDecoratedBottom(anchorView)</span><br><span class=\"line\">        <span class=\"keyword\">val</span> anchorLeft = getDecoratedLeft(anchorView)</span><br><span class=\"line\">        remainSpace = verticalSpace - anchorBottom</span><br><span class=\"line\">        <span class=\"comment\">// 垂直可用的数据为&lt;0，意外着这时候屏幕底部的位置刚好在最底部的 ItemView 上，还需要向上滑动一点点...我们才能添加 View</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (remainSpace &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        nextFillPosition = anchorPosition + <span class=\"number\">1</span></span><br><span class=\"line\">        offsetTop = anchorBottom</span><br><span class=\"line\">        offsetLeft = anchorLeft</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (nextFillPosition &gt;= itemCount) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (dy &lt; <span class=\"number\">0</span>) &#123;  <span class=\"comment\">// 从上往下滑，那么需要向顶部添加数据</span></span><br><span class=\"line\">        <span class=\"comment\">//no-op 暂时不实现从上往下滑的底部数据填充</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (remainSpace &gt; <span class=\"number\">0</span> &amp;&amp; nextFillPosition &lt; itemCount) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 从适配器获取与给定位置关联的视图</span></span><br><span class=\"line\">        <span class=\"keyword\">val</span> itemView = recycler.getViewForPosition(nextFillPosition)</span><br><span class=\"line\">        <span class=\"comment\">// 将视图添加到 RecyclerView 中</span></span><br><span class=\"line\">        addView(itemView)</span><br><span class=\"line\">        <span class=\"comment\">// 测量并布局视图</span></span><br><span class=\"line\">        measureChildWithMargins(itemView, <span class=\"number\">0</span>, <span class=\"number\">0</span>)</span><br><span class=\"line\">        <span class=\"comment\">// 拿到宽高（包括ItemDecoration）</span></span><br><span class=\"line\">        <span class=\"keyword\">val</span> itemWidth = getDecoratedMeasuredWidth(itemView)</span><br><span class=\"line\">        <span class=\"keyword\">val</span> itemHeight = getDecoratedMeasuredHeight(itemView)</span><br><span class=\"line\">        <span class=\"comment\">// 对要添加的子 View 进行布局，相比onLayoutChildren 里面的实现添加了：offsetLeft（因为我们没有禁止掉 左右的滑动）</span></span><br><span class=\"line\">        <span class=\"comment\">// 试着把 offsetLeft 改成0，也就是最原始的样子，然后左右上下滑滑，你会有意外收获</span></span><br><span class=\"line\">        layoutDecorated(itemView, offsetLeft, offsetTop, itemWidth + offsetLeft, offsetTop + itemHeight)</span><br><span class=\"line\">        offsetTop += itemHeight</span><br><span class=\"line\">        nextFillPosition++</span><br><span class=\"line\">        <span class=\"comment\">// 可用空间减少</span></span><br><span class=\"line\">        remainSpace -= itemHeight</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>运行在手机上能看到这样的效果：向上滑动的时候，底部陆续有元素填充，但向下滑动的时候没有填充数据</p>\n<img src=\"https://cdn.julis.wang/blog/img/layoutmanager_gradually_3.gif?imageView2/2/w/300\">\n<h3 id=\"4-两个方向的View填充\"><a href=\"#4-两个方向的View填充\" class=\"headerlink\" title=\"4 两个方向的View填充\"></a>4 两个方向的View填充</h3><p>代码查看：<a href=\"https://github.com/VomPom/LayoutManagerGradually/tree/main/layoutmanager/src/main/java/com/julis/layoutmanager/series/LinearLayoutManager4.kt\">LinearLayoutManager4</a></p>\n<p>补齐从上往下滑之后添加的逻辑</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">fillView</span><span class=\"params\">(dy: <span class=\"type\">Int</span>, recycler: <span class=\"type\">RecyclerView</span>.<span class=\"type\">Recycler</span>)</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">val</span> verticalSpace = orientationVerticalHelper.totalSpace</span><br><span class=\"line\">    <span class=\"keyword\">var</span> remainSpace = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> nextFillPosition = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"comment\">//垂直方向的偏移量</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> offsetTop = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> offsetLeft = <span class=\"number\">0</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 从下往上滑，那么需要向底部添加数据</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (dy &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        ……</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (dy &lt; <span class=\"number\">0</span>) &#123;  <span class=\"comment\">// 从上往下滑，那么需要向顶部添加数据</span></span><br><span class=\"line\">        <span class=\"keyword\">val</span> anchorView = getChildAt(<span class=\"number\">0</span>) ?: <span class=\"keyword\">return</span></span><br><span class=\"line\">        <span class=\"keyword\">val</span> anchorPosition = getPosition(anchorView)</span><br><span class=\"line\">        <span class=\"keyword\">val</span> anchorTop = getDecoratedTop(anchorView)</span><br><span class=\"line\">        offsetLeft = getDecoratedLeft(anchorView)</span><br><span class=\"line\">        remainSpace = anchorTop</span><br><span class=\"line\">        <span class=\"comment\">// 垂直可用的数据为&lt;0，意外着这时候屏幕顶部的位置刚好在最底部的 ItemView 上，还需要向下滑动一点点...我们才能添加 View</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (anchorTop &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        nextFillPosition = anchorPosition - <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (nextFillPosition &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">val</span> itemHeight = getDecoratedMeasuredHeight(anchorView)</span><br><span class=\"line\">        <span class=\"comment\">// 新的布局的itemView 的顶部位置应该以 anchorTop - itemHeight 开始</span></span><br><span class=\"line\">        offsetTop = anchorTop - itemHeight</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (remainSpace &gt; <span class=\"number\">0</span> &amp;&amp;</span><br><span class=\"line\">        ((nextFillPosition &lt; itemCount) &amp;&amp; (nextFillPosition &gt;= <span class=\"number\">0</span>))</span><br><span class=\"line\">    ) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 从适配器获取与给定位置关联的视图</span></span><br><span class=\"line\">        <span class=\"keyword\">val</span> itemView = recycler.getViewForPosition(nextFillPosition)</span><br><span class=\"line\">        <span class=\"comment\">// 将视图添加到 RecyclerView 中k，从顶部添加的话，需要加到最前的位置</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (dy &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            addView(itemView)</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            addView(itemView, <span class=\"number\">0</span>)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        ……</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (dy &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            offsetTop += itemHeight</span><br><span class=\"line\">            nextFillPosition++</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            offsetTop -= itemHeight</span><br><span class=\"line\">            nextFillPosition--</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 可用空间减少</span></span><br><span class=\"line\">        remainSpace -= itemHeight</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>运行在手机上能看到这样的效果：向上或者滑动的时候，底部陆续都有元素填充</p>\n<img src=\"https://cdn.julis.wang/blog/img/layoutmanager_gradually_4.gif?imageView2/2/w/300\">\n<h3 id=\"5-对顶部和底部滑动边界处理\"><a href=\"#5-对顶部和底部滑动边界处理\" class=\"headerlink\" title=\"5 对顶部和底部滑动边界处理\"></a>5 对顶部和底部滑动边界处理</h3><p>代码查看：<a href=\"https://github.com/VomPom/LayoutManagerGradually/tree/main/layoutmanager/src/main/java/com/julis/layoutmanager/series/LinearLayoutManager5.kt\">LinearLayoutManager5</a></p>\n<p>对于前面的实现会发现会：不停地下滑或者上滑会留出来巨大的空白。这里对填充 View 的逻辑进行改造，需要进行边界检测。</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">scrollVerticallyBy</span><span class=\"params\">(dy: <span class=\"type\">Int</span>, recycler: <span class=\"type\">RecyclerView</span>.<span class=\"type\">Recycler</span>, state: <span class=\"type\">RecyclerView</span>.<span class=\"type\">State</span>?)</span></span>: <span class=\"built_in\">Int</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 填充 view</span></span><br><span class=\"line\">    <span class=\"keyword\">val</span> adjustedDy = fillView(dy, recycler)</span><br><span class=\"line\">    <span class=\"comment\">// 移动 view</span></span><br><span class=\"line\">    offsetChildrenVertical(-adjustedDy)</span><br><span class=\"line\">    <span class=\"comment\">// 回收 View</span></span><br><span class=\"line\">    recycleInvisibleView(adjustedDy, recycler)</span><br><span class=\"line\">    <span class=\"comment\">// 由于需要对边界进行限制，所以需要对原始的 dy 进行修正，这里不再直接返回 dy</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> adjustedDy</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>这里的整体注释我写在了代码里面，可以看图稍微理解一下，以向上滑动为例：假设这一次滑动的距离非常非常大(想象成10000像素)，如果直接滑动的话，我们有50个元素，每个元素高度100像素，最大高度也只有50x100=5000，那么滑动后一定会留下大量空区域。需要对当前传入的这 10000 像素做调整：只给到可滑动的最大距离，如果不能滑动了就返回0。</p>\n<img src=\"https://cdn.julis.wang/blog/img/5_scroll_limit.png\">\n<p>运行在手机上能看到这样的效果：向上或者滑动的时候，达到最大的位置时候是不能再滑动的。</p>\n<img src=\"https://cdn.julis.wang/blog/img/layoutmanager_gradually_5.gif?imageView2/2/w/300\">\n<h3 id=\"6-实现-scrollToPosition\"><a href=\"#6-实现-scrollToPosition\" class=\"headerlink\" title=\"6 实现 scrollToPosition\"></a>6 实现 scrollToPosition</h3><p>代码查看：<a href=\"https://github.com/VomPom/LayoutManagerGradually/tree/main/layoutmanager/src/main/java/com/julis/layoutmanager/series/LinearLayoutManager6.kt\">LinearLayoutManager6</a></p>\n<p>到这里这个 LinearLayoutManager 看着已经能正常运行了，但一般还需要支持<code>scrollToPosition</code> 和 <code>smoothScrollToPositio</code></p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">var</span> mPendingScrollPosition = RecyclerView.NO_POSITION</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">scrollToPosition</span><span class=\"params\">(position: <span class=\"type\">Int</span>)</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>.scrollToPosition(position)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (position &lt; <span class=\"number\">0</span> || position &gt;= itemCount) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    mPendingScrollPosition = position</span><br><span class=\"line\">    requestLayout()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onLayoutChildren</span><span class=\"params\">(recycler: <span class=\"type\">RecyclerView</span>.<span class=\"type\">Recycler</span>, state: <span class=\"type\">RecyclerView</span>.<span class=\"type\">State</span>)</span></span> &#123;</span><br><span class=\"line\">    ……</span><br><span class=\"line\">    <span class=\"keyword\">var</span> currentPosition = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mPendingScrollPosition != RecyclerView.NO_POSITION) &#123;</span><br><span class=\"line\">        currentPosition = mPendingScrollPosition</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (remainSpace &gt; <span class=\"number\">0</span> &amp;&amp; currentPosition &lt; state.itemCount) &#123;</span><br><span class=\"line\">      …… <span class=\"comment\">// 填充View 的逻辑</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>scrollToPosition</code> 的实现比较简单，如上代码所示：在 <code>scrollToPosition</code>  的时候记录一次目标position，再 requestLayout 一波，还记得之前有提到过：<code>onLayoutChildren</code> 会在 <code>requestLayout</code> 的时候调用一次，于是再将<code>onLayoutChildren</code>逻辑改写，不再从第0个元素开始，而是从目标位置进行布局。</p>\n<p>运行在手机上能看到这样的效果：点击 scrollTo30 将会滑动到 第30个位置。</p>\n<img src=\"https://cdn.julis.wang/blog/img/layoutmanager_gradually_6.gif?imageView2/2/w/300\">\n<h3 id=\"7-实现-smoothScrollToPosition\"><a href=\"#7-实现-smoothScrollToPosition\" class=\"headerlink\" title=\"7 实现 smoothScrollToPosition\"></a>7 实现 smoothScrollToPosition</h3><p>代码查看：<a href=\"https://github.com/VomPom/LayoutManagerGradually/tree/main/layoutmanager/src/main/java/com/julis/layoutmanager/series/LinearLayoutManager7.kt\">LinearLayoutManager7</a>  </p>\n<p>要实现自定义的 smoothScrollToPosition 动画效果，这一块如果要完全自己实现的话比较复杂，可以直接使用系统提供的 LinearSmoothScroller改造,也可以继承 RecyclerView.SmoothScroller 自定义，也可以完全不使用 SmoothScroller， 照着 SmoothScroller 的实现使用类似 ValueAnimator 自定义动画，添加动画 UpdateListener，在 onAnimationUpdate 的时候动态计算布局从而实现滑动动画,这里拿 LinearSmoothScroller 举例:</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">smoothScrollToPosition</span><span class=\"params\">(</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">    recyclerView: <span class=\"type\">RecyclerView</span>,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">    state: <span class=\"type\">RecyclerView</span>.<span class=\"type\">State</span>,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">    position: <span class=\"type\">Int</span></span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">)</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (position &gt;= itemCount || position &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">val</span> scroller: LinearSmoothScroller = <span class=\"keyword\">object</span> : LinearSmoothScroller(recyclerView.context) &#123;</span><br><span class=\"line\">        <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">         * 这个方法用于计算滚动到目标位置所需的滚动向量。滚动向量是一个二维向量，包含水平和垂直方向上的滚动距离</span></span><br><span class=\"line\"><span class=\"comment\">         *</span></span><br><span class=\"line\"><span class=\"comment\">         * <span class=\"doctag\">@param</span> targetPosition 滑动的目标位置</span></span><br><span class=\"line\"><span class=\"comment\">         * <span class=\"doctag\">@return</span>  返回一个 PointF 对象，表示滚动向量。</span></span><br><span class=\"line\"><span class=\"comment\">         *              PointF.x 表示水平方向上的滚动距离，</span></span><br><span class=\"line\"><span class=\"comment\">         *              PointF.y 表示垂直方向上的滚动距离</span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\">        <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">computeScrollVectorForPosition</span><span class=\"params\">(targetPosition: <span class=\"type\">Int</span>)</span></span>: PointF &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 查找到屏幕里显示的第 1 个元素与</span></span><br><span class=\"line\">            <span class=\"keyword\">val</span> firstChildPos = getPosition(getChildAt(<span class=\"number\">0</span>)!!)</span><br><span class=\"line\">            <span class=\"keyword\">val</span> direction = <span class=\"keyword\">if</span> (targetPosition &lt; firstChildPos) -<span class=\"number\">1</span> <span class=\"keyword\">else</span> <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"comment\">// x 左右滑动，由于我们只实现了垂直的滑动，所以 x方向为0即可</span></span><br><span class=\"line\">            <span class=\"comment\">// 整数代表正向移动，负数代表反向移动，这里的数值大小不重要，源码里面最终都会 normalize 归一化处理</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> PointF(<span class=\"number\">0f</span>, direction.toFloat())</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">         * 计算每像素速度</span></span><br><span class=\"line\"><span class=\"comment\">         *</span></span><br><span class=\"line\"><span class=\"comment\">         * <span class=\"doctag\">@param</span> displayMetrics</span></span><br><span class=\"line\"><span class=\"comment\">         * <span class=\"doctag\">@return</span> 返回每一像素的耗时，单位ms，假设返回值是1.0 代表着：1ms 内会滑动 1像素，1s会滑动1000像素</span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\">        <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">calculateSpeedPerPixel</span><span class=\"params\">(displayMetrics: <span class=\"type\">DisplayMetrics</span>?)</span></span>: <span class=\"built_in\">Float</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">super</span>.calculateSpeedPerPixel(displayMetrics)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">         * 滑动速度的插值（实现滑动速度随着滑动时间的变化）</span></span><br><span class=\"line\"><span class=\"comment\">         *</span></span><br><span class=\"line\"><span class=\"comment\">         * <span class=\"doctag\">@param</span> dx</span></span><br><span class=\"line\"><span class=\"comment\">         * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\">        <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">calculateTimeForDeceleration</span><span class=\"params\">(dx: <span class=\"type\">Int</span>)</span></span>: <span class=\"built_in\">Int</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">super</span>.calculateTimeForDeceleration(dx)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 很多方法可以使用，不再一一列举</span></span><br><span class=\"line\">        <span class=\"comment\">// ...</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    scroller.targetPosition = position</span><br><span class=\"line\">    <span class=\"comment\">// 执行默认动画的逻辑</span></span><br><span class=\"line\">    startSmoothScroll(scroller)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>运行在手机上能看到这样的效果：点击 smoothScrollTo30 将会有个动画效果滑动到第30个位置。</p>\n<img src=\"https://cdn.julis.wang/blog/img/layoutmanager_gradually_7.gif?imageView2/2/w/300\">\n<p>以上基本上一个自定义 LayoutManager 的雏形就已经完成了，虽然只实现了一个方向的滑动，但是其原理都是一样的，剩下的就是各种细节的打磨了，可以加各种自己想要的效果，比如：指定位置 放大一定的系数，或者更炫酷的滑动动画…</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>本文主要整理了自定义 LayoutManager 的必要元素，以及其核心方法 scrollHorizontallyBy/scrollVerticallyBy、onLayoutChildren 的作用与调用时机，接下对实现一个简单的 LinearLayoutManger 进行逻辑拆解，从最简单的不滑动回收和填充以及不含滑动边界检测，到最终一个具备基本功能的 LayoutManger</p>\n<p>源码：<a href=\"https://github.com/VomPom/LayoutManagerGradually\">https://github.com/VomPom/LayoutManagerGradually</a></p>\n<p>参考：</p>\n<p><a href=\"https://juejin.cn/post/6870770285247725581?searchId=202310181005138A6D82B1DEE9C47A9797#heading-23\">《看完这篇文章你还不会自定义LayoutManager，我吃X！》</a></p>\n<p><a href=\"https://github.com/MycroftWong/FlowLayoutManager/blob/master/LayoutManager%E5%88%86%E6%9E%90%E4%B8%8E%E5%AE%9E%E8%B7%B5.md\">《/LayoutManager分析与实践》</a></p>\n<p><a href=\"https://wiresareobsolete.com/2014/09/building-a-recyclerview-layoutmanager-part-1/\">Building a RecyclerView LayoutManager – Part 1</a></p>\n","raw":"title: RecyclerView自定义LayoutManager从0到1实践\nauthor: 落叶挽歌\ntags:\n  - 技术文章\ncategories: []\ndate: 2023-10-31 19:19:00\n---\n此前大部分涉及到 RecyclerView 页面的 LayoutManager基本上用系统提供的 LinearLayoutManager 、GridLayoutManager 就能解决，但在一些特殊场景上还是需要我们自定义  LayoutManager。之前基本上没有自己写过，在网上看各种源码各种文章，刚开始花了好多时间去理解整体流程，因为它们都给我一种非常非常复杂的感觉，包括相关的博客文章也是。经过一段时间摸索，也慢慢能理解为什么要那么复杂了，这的确不是特别容易入门。所以对整体的流程进行了一个拆解，尽量原子化一点，对自己学习的一个总结，也希望能帮助到一部分人能对  LayoutManager 入门。\n\n本文最终实现一个简单的 LinearLayoutManager（只支持 VERTICAL）方向，适合对 LayoutManager 整体流程的学习与理解，整体代码分为多个文件，每个文件都是对前一段代码的补充，方便理解，整体项目源码已提交 Github: [LayoutManagerGradually](https://github.com/VomPom/LayoutManagerGradually)，代码里面写了很多很多注释，如果不想浪费时间，可以直接看代码运行，跳过这篇文章，把每一个 LayoutManager 都跑一下体验结合代码看看。\n\n## 自定义 LayoutManager 的必要元素\n\n- 继承 `RecyclerView.LayoutManager` 并实现 `generateDefaultLayoutParams() `方法\n\n- 重写`onLayoutChildren` 第一次数据填充的时候数据添加\n\n- 重写 `canScrollHorizontally()` 和` canScrollVertically() `方法设定支持滑动的方向\n- 重写 `scrollHorizontallyBy()`和`scrollVerticallyBy()`方法，在滑动的时候对屏幕以外的 View 进行回收，以及填充即将滑动进入屏幕范围内的 View 进行填充\n\n- 重写 `scrollToPosition()`和`smoothScrollToPosition()`方法支持\n\n\n其中`onLayoutChildren` 和 `scrollHorizontallyBy/scrollVerticallyBy` 是最核心且最复杂的方法，这里稍微拎出来讲一下\n\n### onLayoutChildren\n\n这个方法类似于自定义 ViewGroup 的 onLayout() 方法，RecyclerView 的 LayoutManager.onLayoutChildren 在以下几个时机会被触发：\n\n- 当 `RecyclerView` 首次附加到窗口时\n- 当`Adapter`  的数据集发生变化\n- 当 `RecyclerView` 被 执行 `RequetLayout`的时候\n- 当 `LayoutManager` 发生变化时\n\n### scrollHorizontallyBy/scrollVerticallyBy\n\n方法的主要作用包括：\n\n1. 更新 ItemView 的位置：根据传入的垂直滚动距离（dy 参数），更新子视图在屏幕上的位置。通常调用 `offsetChildrenVertical` 方法。\n\n2. 回收不可见的 ItemView：在滚动过程中，一些 ItemView 可能会离开屏幕，变得不可见。`scrollVerticallyBy` 方法需要负责回收这些子视图并将它们放入回收池，以便稍后复用。\n\n3. 添加新的 ItemView：在滚动过程中，新的 ItemView 可能需要显示在屏幕上。`scrollVerticallyBy` 方法需要从回收池中获取可复用的视图并将它们添加到屏幕上。这通常涉及到调用 `RecyclerView.Recycler` 的 `getViewForPosition` 方法。\n\n4. 返回实际滚动距离：由于 ItemView 的数量有限，滚动可能会受到限制。例如，当滚动到列表顶部或底部时，滚动可能会停止。在这种情况下，实际滚动的距离可能会小于传入的 `dy` 参数。`scrollVerticallyBy` 方法需要返回实际滚动的距离，以便 `RecyclerView` 可以正确地更新滚动条和触发滚动事件。\n\n   \n\n概念就简单讲这么多， talk is cheap show me the code，直接看代码理解会比较深刻\n\n\n\n## 逐步实现\n\n要实现一个可用的 LayoutManger 通常我们需要实现以下流程\n\n- 数据填充并且只需要填充屏幕范围内的 ItemView\n- 回收掉屏幕以外的 ItemView\n- 屏幕外 ItemView 再回到屏幕后，需要重新填充\n- 对滑动边界边界进行处理\n- 对 scrollToPosition 和 smoothScrollToPosition进行支持\n\n\n\n我们不用一上来就实现最终的效果，而是一步一步来，看看 LayoutManger 是怎么渐渐地变化，最终能跑起来的。\n\n### 0 最简单的 LayoutManager\n\n代码查看：[MostSimpleLayoutManager](https://github.com/VomPom/LayoutManagerGradually/tree/main/layoutmanager/src/main/java/com/julis/layoutmanager/series/MostSimpleLayoutManager.kt)，我们关注 `onLayoutChildren` 方法:\n\n```kotlin\noverride fun onLayoutChildren(recycler: RecyclerView.Recycler, state: RecyclerView.State?) {\n    // 垂直方向的偏移量\n    var offsetTop = 0\n    // 实际业务中最好不要这样一次性加载所有的数据，这里只是最简单地演示一下整体是如何工作的\n    for (itemIndex in 0 until itemCount) {\n        // 从适配器获取与给定位置关联的视图\n        val itemView = recycler.getViewForPosition(itemIndex)\n        // 将视图添加到 RecyclerView 中\n        addView(itemView)\n        // 测量并布局视图\n        measureChildWithMargins(itemView, 0, 0)\n        // 拿到宽高（包括ItemDecoration）\n        val width = getDecoratedMeasuredWidth(itemView)\n        val height = getDecoratedMeasuredHeight(itemView)\n        // 对要添加的子 View 进行布局\n        layoutDecorated(itemView, 0, offsetTop, width, offsetTop + height)\n        offsetTop += height\n    }\n}\n```\n\n上面的代码主要演示了，如何利用`addView` `layoutDecorated`等方法，将 ItemView 添加到 RecyclerView 上。代码可见是 将所有的 ItemView（即使它在屏幕上不可见）一次性全部加载到了 RecyclerView上， 这里一般不这么做，只是这里这里只是最简单地演示一下整体是如何工作的。\n\n运行在手机上能看到这样的效果：Item数据已经被全部添加到界面上了，并且各个方向的滑动都支持。\n\n\n{% qnimg layoutmanager_gradually_0.gif extend:?imageView2/2/w/300 %}\n### 1 更合理的数据添加方式\n\n代码查看：[LinearLayoutManager1.kt](https://github.com/VomPom/LayoutManagerGradually/tree/main/layoutmanager/src/main/java/com/julis/layoutmanager/series/LinearLayoutManager1)\n\n对最开始的代码进行优化，只在屏幕范围内的区域进行数据的添加，这样就不需要一次性将所有数据就添加上去，如果 Adapter 的 ItemCount 足够巨大，for all addView 的话，很容易就 OOM。\n\n```kotlin\noverride fun onLayoutChildren(recycler: RecyclerView.Recycler, state: RecyclerView.State) {\n    // 垂直方向上的的空间大小\n    var remainSpace = height - paddingTop\n    //垂直方向的偏移量\n    var offsetTop = 0\n    var currentPosition = 0\n    while (remainSpace > 0 && currentPosition < state.itemCount) {\n        // 从适配器获取与给定位置关联的视图\n        val itemView = recycler.getViewForPosition(currentPosition)\n        // 将视图添加到 RecyclerView 中\n        addView(itemView)\n        // 测量并布局视图\n        measureChildWithMargins(itemView, 0, 0)\n        // 拿到宽高（包括ItemDecoration）\n        val itemWidth = getDecoratedMeasuredWidth(itemView)\n        val itemHeight = getDecoratedMeasuredHeight(itemView)\n        // 对要添加的子 View 进行布局\n        layoutDecorated(itemView, 0, offsetTop, itemWidth, offsetTop + itemHeight)\n        offsetTop += itemHeight\n        currentPosition++\n        // 可用空间减少\n        remainSpace -= itemHeight\n    }\n}\n```\n\n\n\n### 2 对屏幕外的View回收\n\n代码查看：[LinearLayoutManager2](https://github.com/VomPom/LayoutManagerGradually/tree/main/layoutmanager/src/main/java/com/julis/layoutmanager/series/LinearLayoutManager2.kt)\n\nRecylerView 没有 recycler 怎么行呢？当 RecylerView 的 ItemView 滑出屏幕后我们需要对齐进行回收，实现的话需要在 `scrollVerticallyBy`中，比较复杂的逻辑就是怎么去判断：ItemView 在屏幕以外，最后利用：`removeAndRecycleView`方法进行回收\n\n```kotlin\noverride fun scrollVerticallyBy(dy: Int, recycler: RecyclerView.Recycler, state: RecyclerView.State?): Int {\n      // 在这里处理上下的滚动逻辑，dy 表示滚动的距离\n      // 平移所有子视图\n      offsetChildrenVertical(-dy)\n      // 如果实际滚动距离与 dy 相同，返回 dy；如果未滚动，返回 0\n      recycleInvisibleView(dy, recycler)\n      return dy\n}\n\n/**\n * 回收掉在界面上看不到的 ItemView\n *\n * @param dy\n * @param recycler\n */\nprivate fun recycleInvisibleView(dy: Int, recycler: RecyclerView.Recycler) {\n    val totalSpace = orientationHelper.totalSpace\n\n    // 将要回收View的集合\n    val recycleViews = hashSetOf<View>()\n    // 从下往上滑\n    if (dy > 0) {\n        for (i in 0 until childCount) {\n            val child = getChildAt(i)!!\n            // 从下往上滑从最上面的 item 开始计算\n            val top = getDecoratedTop(child)\n            // 判断最顶部的 item 是否已经完全不可见，如何可见，那说明底下的 item 也是可见\n            val height = top - getDecoratedBottom(child)\n            if (height - top < 0) {\n                break\n            }\n            recycleViews.add(child)\n        }\n    } else if (dy < 0) {   // 从上往下滑\n        for (i in childCount - 1 downTo 0) {\n            val child = getChildAt(i)!!\n            // 从上往下滑从最底部的 item 开始计算\n            val bottom = getDecoratedBottom(child)\n            // 判断最底部的 item 是否已经完全不可见，如何可见，那说明上面的 item 也是可见\n            val height = bottom - getDecoratedTop(child)\n            if (bottom - totalSpace < height) {\n                break\n            }\n            recycleViews.add(child)\n        }\n    }\n\n    // 真正把 View 移除掉的逻辑\n    for (view in recycleViews) {\n        // [removeAndRecycleView]\n        // 用于从视图层次结构中删除某个视图，并将其资源回收，以便在需要时重新利用\n        removeAndRecycleView(view, recycler)\n    }\n    recycleViews.clear()\n}\n```\n\n运行在手机上能看到这样的效果：滑出屏幕外的ItemView 被回收掉了\n\n{% qnimg layoutmanager_gradually_2.gif extend:?imageView2/2/w/300 %}\n\n### 3 向上滑动的时View的填充\n\n代码查看：[LinearLayoutManager3](https://github.com/VomPom/LayoutManagerGradually/tree/main/layoutmanager/src/main/java/com/julis/layoutmanager/series/LinearLayoutManager3.kt)\n\n```kotlin\noverride fun scrollVerticallyBy(dy: Int, recycler: RecyclerView.Recycler, state: RecyclerView.State?): Int {\n    // 填充 view\n    fillView(dy, recycler)\n    // 移动 view\n    offsetChildrenVertical(-dy)\n    // 回收 View\n    recycleInvisibleView(dy, recycler)\n    return dy\n}\n\n/**\n * 填充重新进入屏幕内的 ItemView\n *     getChildCount():childCount-> 当前屏幕内RecyclerView展示的 ItemView 数量\n *     getItemCount():itemCount-> 最大的 ItemView 数量，也就是 Adapter 传递的数据的数量\n */\nprivate fun fillView(dy: Int, recycler: RecyclerView.Recycler) {\n    val verticalSpace = orientationVerticalHelper.totalSpace\n    var remainSpace = 0\n    var nextFillPosition = 0\n    //垂直方向的偏移量\n    var offsetTop = 0\n    var offsetLeft = 0\n    // 从下往上滑，那么需要向底部添加数据\n    if (dy > 0) {\n        val anchorView = getChildAt(childCount - 1) ?: return\n        val anchorPosition = getPosition(anchorView)\n        val anchorBottom = getDecoratedBottom(anchorView)\n        val anchorLeft = getDecoratedLeft(anchorView)\n        remainSpace = verticalSpace - anchorBottom\n        // 垂直可用的数据为<0，意外着这时候屏幕底部的位置刚好在最底部的 ItemView 上，还需要向上滑动一点点...我们才能添加 View\n        if (remainSpace < 0) {\n            return\n        }\n        nextFillPosition = anchorPosition + 1\n        offsetTop = anchorBottom\n        offsetLeft = anchorLeft\n        if (nextFillPosition >= itemCount) {\n            return\n        }\n    } else if (dy < 0) {  // 从上往下滑，那么需要向顶部添加数据\n        //no-op 暂时不实现从上往下滑的底部数据填充\n    }\n\n    while (remainSpace > 0 && nextFillPosition < itemCount) {\n        // 从适配器获取与给定位置关联的视图\n        val itemView = recycler.getViewForPosition(nextFillPosition)\n        // 将视图添加到 RecyclerView 中\n        addView(itemView)\n        // 测量并布局视图\n        measureChildWithMargins(itemView, 0, 0)\n        // 拿到宽高（包括ItemDecoration）\n        val itemWidth = getDecoratedMeasuredWidth(itemView)\n        val itemHeight = getDecoratedMeasuredHeight(itemView)\n        // 对要添加的子 View 进行布局，相比onLayoutChildren 里面的实现添加了：offsetLeft（因为我们没有禁止掉 左右的滑动）\n        // 试着把 offsetLeft 改成0，也就是最原始的样子，然后左右上下滑滑，你会有意外收获\n        layoutDecorated(itemView, offsetLeft, offsetTop, itemWidth + offsetLeft, offsetTop + itemHeight)\n        offsetTop += itemHeight\n        nextFillPosition++\n        // 可用空间减少\n        remainSpace -= itemHeight\n    }\n}\n```\n\n运行在手机上能看到这样的效果：向上滑动的时候，底部陆续有元素填充，但向下滑动的时候没有填充数据\n\n{% qnimg layoutmanager_gradually_3.gif extend:?imageView2/2/w/300 %}\n### 4 两个方向的View填充\n\n代码查看：[LinearLayoutManager4](https://github.com/VomPom/LayoutManagerGradually/tree/main/layoutmanager/src/main/java/com/julis/layoutmanager/series/LinearLayoutManager4.kt)\n\n补齐从上往下滑之后添加的逻辑\n\n```kotlin\nprivate fun fillView(dy: Int, recycler: RecyclerView.Recycler) {\n    val verticalSpace = orientationVerticalHelper.totalSpace\n    var remainSpace = 0\n    var nextFillPosition = 0\n    //垂直方向的偏移量\n    var offsetTop = 0\n    var offsetLeft = 0\n\n    // 从下往上滑，那么需要向底部添加数据\n    if (dy > 0) {\n        ……\n    } else if (dy < 0) {  // 从上往下滑，那么需要向顶部添加数据\n        val anchorView = getChildAt(0) ?: return\n        val anchorPosition = getPosition(anchorView)\n        val anchorTop = getDecoratedTop(anchorView)\n        offsetLeft = getDecoratedLeft(anchorView)\n        remainSpace = anchorTop\n        // 垂直可用的数据为<0，意外着这时候屏幕顶部的位置刚好在最底部的 ItemView 上，还需要向下滑动一点点...我们才能添加 View\n        if (anchorTop < 0) {\n            return\n        }\n        nextFillPosition = anchorPosition - 1\n        if (nextFillPosition < 0) {\n            return\n        }\n        val itemHeight = getDecoratedMeasuredHeight(anchorView)\n        // 新的布局的itemView 的顶部位置应该以 anchorTop - itemHeight 开始\n        offsetTop = anchorTop - itemHeight\n    }\n\n    while (remainSpace > 0 &&\n        ((nextFillPosition < itemCount) && (nextFillPosition >= 0))\n    ) {\n        // 从适配器获取与给定位置关联的视图\n        val itemView = recycler.getViewForPosition(nextFillPosition)\n        // 将视图添加到 RecyclerView 中k，从顶部添加的话，需要加到最前的位置\n        if (dy > 0) {\n            addView(itemView)\n        } else {\n            addView(itemView, 0)\n        }\n        ……\n        if (dy > 0) {\n            offsetTop += itemHeight\n            nextFillPosition++\n        } else {\n            offsetTop -= itemHeight\n            nextFillPosition--\n        }\n        // 可用空间减少\n        remainSpace -= itemHeight\n    }\n```\n\n\n\n运行在手机上能看到这样的效果：向上或者滑动的时候，底部陆续都有元素填充\n\n{% qnimg layoutmanager_gradually_4.gif extend:?imageView2/2/w/300 %}\n### 5 对顶部和底部滑动边界处理\n\n代码查看：[LinearLayoutManager5](https://github.com/VomPom/LayoutManagerGradually/tree/main/layoutmanager/src/main/java/com/julis/layoutmanager/series/LinearLayoutManager5.kt)\n\n对于前面的实现会发现会：不停地下滑或者上滑会留出来巨大的空白。这里对填充 View 的逻辑进行改造，需要进行边界检测。\n\n```kotlin\noverride fun scrollVerticallyBy(dy: Int, recycler: RecyclerView.Recycler, state: RecyclerView.State?): Int {\n    // 填充 view\n    val adjustedDy = fillView(dy, recycler)\n    // 移动 view\n    offsetChildrenVertical(-adjustedDy)\n    // 回收 View\n    recycleInvisibleView(adjustedDy, recycler)\n    // 由于需要对边界进行限制，所以需要对原始的 dy 进行修正，这里不再直接返回 dy\n    return adjustedDy\n}\n\n```\n\n这里的整体注释我写在了代码里面，可以看图稍微理解一下，以向上滑动为例：假设这一次滑动的距离非常非常大(想象成10000像素)，如果直接滑动的话，我们有50个元素，每个元素高度100像素，最大高度也只有50x100=5000，那么滑动后一定会留下大量空区域。需要对当前传入的这 10000 像素做调整：只给到可滑动的最大距离，如果不能滑动了就返回0。\n\n{% qnimg 5_scroll_limit.png %}\n运行在手机上能看到这样的效果：向上或者滑动的时候，达到最大的位置时候是不能再滑动的。\n\n\n{% qnimg layoutmanager_gradually_5.gif extend:?imageView2/2/w/300 %}\n### 6 实现 scrollToPosition\n\n代码查看：[LinearLayoutManager6](https://github.com/VomPom/LayoutManagerGradually/tree/main/layoutmanager/src/main/java/com/julis/layoutmanager/series/LinearLayoutManager6.kt)\n\n到这里这个 LinearLayoutManager 看着已经能正常运行了，但一般还需要支持`scrollToPosition` 和 `smoothScrollToPositio`\n\n\n\n```kotlin\nprivate var mPendingScrollPosition = RecyclerView.NO_POSITION\n\noverride fun scrollToPosition(position: Int) {\n    super.scrollToPosition(position)\n    if (position < 0 || position >= itemCount) {\n        return\n    }\n    mPendingScrollPosition = position\n    requestLayout()\n}\n\noverride fun onLayoutChildren(recycler: RecyclerView.Recycler, state: RecyclerView.State) {\n    ……\n    var currentPosition = 0\n    if (mPendingScrollPosition != RecyclerView.NO_POSITION) {\n        currentPosition = mPendingScrollPosition\n    }\n\n    while (remainSpace > 0 && currentPosition < state.itemCount) {\n      …… // 填充View 的逻辑\n    }\n}\n```\n\n`scrollToPosition` 的实现比较简单，如上代码所示：在 `scrollToPosition`  的时候记录一次目标position，再 requestLayout 一波，还记得之前有提到过：`onLayoutChildren` 会在 `requestLayout` 的时候调用一次，于是再将`onLayoutChildren`逻辑改写，不再从第0个元素开始，而是从目标位置进行布局。\n\n\n\n运行在手机上能看到这样的效果：点击 scrollTo30 将会滑动到 第30个位置。\n\n\n{% qnimg layoutmanager_gradually_6.gif extend:?imageView2/2/w/300 %}\n### 7 实现 smoothScrollToPosition\n\n代码查看：[LinearLayoutManager7](https://github.com/VomPom/LayoutManagerGradually/tree/main/layoutmanager/src/main/java/com/julis/layoutmanager/series/LinearLayoutManager7.kt)  \n\n要实现自定义的 smoothScrollToPosition 动画效果，这一块如果要完全自己实现的话比较复杂，可以直接使用系统提供的 LinearSmoothScroller改造,也可以继承 RecyclerView.SmoothScroller 自定义，也可以完全不使用 SmoothScroller， 照着 SmoothScroller 的实现使用类似 ValueAnimator 自定义动画，添加动画 UpdateListener，在 onAnimationUpdate 的时候动态计算布局从而实现滑动动画,这里拿 LinearSmoothScroller 举例:\n\n\n\n```kotlin\noverride fun smoothScrollToPosition(\n    recyclerView: RecyclerView,\n    state: RecyclerView.State,\n    position: Int\n) {\n    if (position >= itemCount || position < 0) {\n        return\n    }\n\n    val scroller: LinearSmoothScroller = object : LinearSmoothScroller(recyclerView.context) {\n        /**\n         * 这个方法用于计算滚动到目标位置所需的滚动向量。滚动向量是一个二维向量，包含水平和垂直方向上的滚动距离\n         *\n         * @param targetPosition 滑动的目标位置\n         * @return  返回一个 PointF 对象，表示滚动向量。\n         *              PointF.x 表示水平方向上的滚动距离，\n         *              PointF.y 表示垂直方向上的滚动距离\n         */\n        override fun computeScrollVectorForPosition(targetPosition: Int): PointF {\n            // 查找到屏幕里显示的第 1 个元素与\n            val firstChildPos = getPosition(getChildAt(0)!!)\n            val direction = if (targetPosition < firstChildPos) -1 else 1\n            // x 左右滑动，由于我们只实现了垂直的滑动，所以 x方向为0即可\n            // 整数代表正向移动，负数代表反向移动，这里的数值大小不重要，源码里面最终都会 normalize 归一化处理\n            return PointF(0f, direction.toFloat())\n        }\n\n        /**\n         * 计算每像素速度\n         *\n         * @param displayMetrics\n         * @return 返回每一像素的耗时，单位ms，假设返回值是1.0 代表着：1ms 内会滑动 1像素，1s会滑动1000像素\n         */\n        override fun calculateSpeedPerPixel(displayMetrics: DisplayMetrics?): Float {\n            return super.calculateSpeedPerPixel(displayMetrics)\n        }\n\n        /**\n         * 滑动速度的插值（实现滑动速度随着滑动时间的变化）\n         *\n         * @param dx\n         * @return\n         */\n        override fun calculateTimeForDeceleration(dx: Int): Int {\n            return super.calculateTimeForDeceleration(dx)\n        }\n        // 很多方法可以使用，不再一一列举\n        // ...\n    }\n    scroller.targetPosition = position\n    // 执行默认动画的逻辑\n    startSmoothScroll(scroller)\n}\n```\n\n运行在手机上能看到这样的效果：点击 smoothScrollTo30 将会有个动画效果滑动到第30个位置。\n\n\n{% qnimg layoutmanager_gradually_7.gif extend:?imageView2/2/w/300 %}\n以上基本上一个自定义 LayoutManager 的雏形就已经完成了，虽然只实现了一个方向的滑动，但是其原理都是一样的，剩下的就是各种细节的打磨了，可以加各种自己想要的效果，比如：指定位置 放大一定的系数，或者更炫酷的滑动动画…\n\n## 总结\n\n本文主要整理了自定义 LayoutManager 的必要元素，以及其核心方法 scrollHorizontallyBy/scrollVerticallyBy、onLayoutChildren 的作用与调用时机，接下对实现一个简单的 LinearLayoutManger 进行逻辑拆解，从最简单的不滑动回收和填充以及不含滑动边界检测，到最终一个具备基本功能的 LayoutManger\n\n源码：https://github.com/VomPom/LayoutManagerGradually\n\n参考：\n\n[《看完这篇文章你还不会自定义LayoutManager，我吃X！》](https://juejin.cn/post/6870770285247725581?searchId=202310181005138A6D82B1DEE9C47A9797#heading-23)\n\n[《/LayoutManager分析与实践》](https://github.com/MycroftWong/FlowLayoutManager/blob/master/LayoutManager%E5%88%86%E6%9E%90%E4%B8%8E%E5%AE%9E%E8%B7%B5.md)\n\n[Building a RecyclerView LayoutManager – Part 1](https://wiresareobsolete.com/2014/09/building-a-recyclerview-layoutmanager-part-1/)\n","categories":[],"tags":[{"name":"技术文章","api":"api/tags/technology.json"}]},"api":"api/posts/2023/10/31/自定义LayoutManager从0到1实践.json"}