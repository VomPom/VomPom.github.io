{"data":{"index":5,"total":8,"posts":[{"title":"Http缓存机制","slug":"Http缓存机制","date":"2020-04-20T03:45:00.000Z","updated":"2025-05-20T11:46:57.000Z","comments":true,"url":"2020/04/20/Http缓存机制/","excerpt":"<p>最近有接触到Http缓存机制的问题，自己进行一个总结。</p>\n<p>浏览器加载一个页面的缓存流程如下：1. 浏览器先根据Http Header信息来判断是否命中<strong>强缓存</strong>。如果命中则直接加载本地缓存中的资源，并不会将请求发送到服务器。<br> 2. 如果未命中强缓存，则浏览器会将资源加载请求发送到服务器。服务器来判断浏览器本地缓存是否失效。若可以使用，则服务器并不会返回资源信息，浏览器继续从缓存加载资源，虽然与强缓存加载的是“同一份缓存”，但是由于流程与性质不一样，我们把它叫做<strong>协商缓存</strong>。<br> 3. 如果未命中<strong>协商缓存</strong>，则服务器会将完整的资源返回给浏览器，浏览器加载新资源，并更新缓存。</p>\n<p><strong>强缓存</strong>：不会向服务器发送请求,直接从本地缓存中读取资源返回<strong>200</strong>的状态码。</p>\n<p>from memory cache一般脚本、字体、图片会存在内存当中 </p>\n<p>from disk cache一般非脚本会存在磁盘当中，如css等 </p>\n<p><strong>协商缓存</strong>：向服务器发送请求,服务器根据请求中的Header的字段判断是否命中协商缓存,如果命中,则返回<strong>304</strong>状态码并带上新的响应头通知浏览器从缓存中读取资源</p>\n<p>与之相关的字段为：<br>强缓存：<strong>cache-control、expires</strong><br>协商缓存：<strong>Last-Modified&#x2F;if-Modified-Since、Etag&#x2F;if-None-Match.</strong></p>\n<p>其实整个缓存机制也就是围绕着这几个字段所展开</p>\n<h2 id=\"二、强缓存流程\"><a href=\"#二、强缓存流程\" class=\"headerlink\" title=\"二、强缓存流程\"></a>二、强缓存流程</h2><p>强缓存是由Http的Response Header中的<strong>Expires</strong>或者<strong>Cache-Control</strong>两个字段来控制的，用来表示资源的缓存时间。如果Cache-control与expires同时存在的话，Cache-control的优先级高于expires。</p>\n<h4 id=\"Expires\"><a href=\"#Expires\" class=\"headerlink\" title=\"Expires\"></a>Expires</h4><p>是一个http1.0提出的概念，它描述的是一个绝对时间，由服务端返回</p>\n<blockquote>\n<p><code>expires: Mon, 11 Jun 2029 08:34:12 GMT</code></p>\n</blockquote>\n<h4 id=\"Cache-Control\"><a href=\"#Cache-Control\" class=\"headerlink\" title=\"Cache-Control\"></a>Cache-Control</h4><p>Catche-control是http1.1提出的概念，优先级高于expires，描述的是一个相对时间</p>\n<blockquote>\n<p><code>cache-control: max-age=315360000</code></p>\n</blockquote>\n<p>除了max-age外，cache-control还有其他几个参数：<br><strong>-no-cache</strong>：不使用本地缓存。需要使用缓存协商，先与服务器确认返回的响应是否被更改，如果之前的响应中存在ETag，那么请求的时候会与服务端验证，如果资源未被更改，则可以避免重新下载。<br><strong>-no-store</strong>：直接禁止浏览器缓存数据，每次用户请求该资源，都会向服务器发送一个请求，每次都会下载完整的资源。<br><strong>-public</strong>：可以被所有的用户缓存，包括终端用户和CDN等中间代理服务器。<br><strong>-private</strong>：只能被终端用户的浏览器缓存，不允许CDN等中继缓存服务器对其缓存。</p>\n<p>如过Cache-Control和Expires条件都不满足，也就是说：像cache-control的字段为-no-cache和-no-store以及max-age不满足条件或者当前时间大于Expires的时间的时候，那么强缓存是没有被命中的，接下来要继续进行协商缓存的流程。</p>\n<h2 id=\"三、协商缓存流程\"><a href=\"#三、协商缓存流程\" class=\"headerlink\" title=\"三、协商缓存流程\"></a>三、协商缓存流程</h2><p>协商缓存相对于强缓存流程就复杂一点了，主要通过：<strong>Last-Modified&#x2F;If-Modified-Since</strong>和<strong>ETag&#x2F;If-None-Match</strong>来控制。Etag是服务器自动生成或者由开发者生成的对应资源在服务器端的唯一标识符，能够更加准确的控制缓存。Last-Modified与ETag是可以一起使用的，服务器会优先验证ETag，一致的情况下，才会继续比对Last-Modified，最后才决定是否返回<strong>304</strong>。</p>\n<h4 id=\"Last-Modified-If-Modified-Since\"><a href=\"#Last-Modified-If-Modified-Since\" class=\"headerlink\" title=\"Last-Modified&#x2F;If-Modified-Since\"></a>Last-Modified&#x2F;If-Modified-Since</h4><p>Last-Modified 表示本地文件最后修改日期，浏览器会在Request Header加上If-Modified-Since（上次返回的Last-Modified的值），询问服务器在该日期后资源是否有更新，有更新的话就会将新的资源发送回来。</p>\n<p>但是单纯使用Last-Modified 会有以下问题：</p>\n<ol>\n<li><p>Last-Modified标注的最后修改只能精确到秒级，如果某些文件在1秒钟以内，被修改多次的话，它将不能准确标注文件的修改时间</p>\n</li>\n<li><p>如果某些文件会被定期生成，当有时内容并没有任何变化，但Last-Modified却改变了，导致文件没法使用缓存</p>\n</li>\n<li><p>有可能存在服务器没有准确获取文件修改时间，或者与代理服务器时间不一致等情形</p>\n</li>\n</ol>\n<p>所以在HTTP&#x2F;1.1的时候加入了ETag&#x2F;If-None-Match来解决这些问题，因而ETag的优先级高于Last-Modified。</p>\n<h4 id=\"ETag-If-None-Match\"><a href=\"#ETag-If-None-Match\" class=\"headerlink\" title=\"ETag&#x2F;If-None-Match\"></a>ETag&#x2F;If-None-Match</h4><p>ETag可以保证每一个资源是唯一的，资源变化都会导致ETag变化。ETag值的变更则说明资源状态已经被修改。服务器根据浏览器上发送的If-None-Match值来判断是否命中缓存。</p>\n<p>If-None-Match的header会将上次返回的Etag发送给服务器，询问该资源的Etag是否有更新，有变动就会发送新的资源回来.</p>\n<p>Etag是服务器自动生成或者由开发者生成的对应资源在服务器端的唯一标识符，能够更加准确的控制缓存。<strong>Last-Modified与ETag是可以一起使用的，服务器会优先验证ETag，一致的情况下，才会继续比对Last-Modified，最后才决定是否返回304。</strong></p>\n<h2 id=\"四、总结\"><a href=\"#四、总结\" class=\"headerlink\" title=\"四、总结\"></a>四、总结</h2><p>一、由于HTTP一直在发展，所以对于HTTP的缓存字段也变得越来越复杂，其实我们很清晰的可以知道Expires与Last-Modified&#x2F;If-Modified-Since是Http&#x2F;1.0时代的产物。 Cache-Control与ETag&#x2F;If-None-Match是HTTP&#x2F;1.1为解决HTTP&#x2F;1.0新增出来的字段，这样对比去记忆理解起来，其实缓存机制也就变得很好理解了。</p>\n<p>二、对于第一次请求（肯定是没有任何缓存的），那么直接向服务器请求资源并将下载好的资源进行缓存，为下一次请求做缓存准备。</p>\n<p>三、对于第二次之后的请求，那么本地是有缓存的，那么先通过cache-control的规则判断（对于Http1.0还是Expires）来判断本地缓存是否过期，如果没过期，那么直接使用。如果过期了，就再判断Etag（具体流程可以参考：<a href=\"https://blog.csdn.net/kikikind/article/details/6266101\">Etag与HTTP缓存机制</a>），通过发送If-None-Match（也就是上次存入的Tag的值），服务器进行一个决策判断返回200还是304。之前有说到，Last-Modified与ETag是可以一起使用的，服务器会优先验证ETag，也就是Etag不存在或者其他情况那么会使用Last-Modified来进行判断，通过向服务器发送If-Modified-Since，然后服务器进行一次决策。</p>\n<p>看流程图可能一下子就明白了：</p>\n<p><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWFnZXMyMDE4LmNuYmxvZ3MuY29tL2Jsb2cvOTQwODg0LzIwMTgwNC85NDA4ODQtMjAxODA0MjMxNDE5NTE3MzUtOTEyNjk5MjEzLnBuZw?x-oss-process=image/format,png\"></p>\n<p>参考：</p>\n<p><a href=\"https://www.jianshu.com/p/19c2e397e22a\">https://www.cnblogs.com/ranyonsue/p/8918908.html</a><br><a href=\"https://www.jianshu.com/p/19c2e397e22a\">https://www.jianshu.com/p/19c2e397e22a</a></p>\n","cover":null,"images":["https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWFnZXMyMDE4LmNuYmxvZ3MuY29tL2Jsb2cvOTQwODg0LzIwMTgwNC85NDA4ODQtMjAxODA0MjMxNDE5NTE3MzUtOTEyNjk5MjEzLnBuZw?x-oss-process=image/format,png"],"content":"<p>最近有接触到Http缓存机制的问题，自己进行一个总结。</p>\n<p>浏览器加载一个页面的缓存流程如下：1. 浏览器先根据Http Header信息来判断是否命中<strong>强缓存</strong>。如果命中则直接加载本地缓存中的资源，并不会将请求发送到服务器。<br> 2. 如果未命中强缓存，则浏览器会将资源加载请求发送到服务器。服务器来判断浏览器本地缓存是否失效。若可以使用，则服务器并不会返回资源信息，浏览器继续从缓存加载资源，虽然与强缓存加载的是“同一份缓存”，但是由于流程与性质不一样，我们把它叫做<strong>协商缓存</strong>。<br> 3. 如果未命中<strong>协商缓存</strong>，则服务器会将完整的资源返回给浏览器，浏览器加载新资源，并更新缓存。</p>\n<p><strong>强缓存</strong>：不会向服务器发送请求,直接从本地缓存中读取资源返回<strong>200</strong>的状态码。</p>\n<p>from memory cache一般脚本、字体、图片会存在内存当中 </p>\n<p>from disk cache一般非脚本会存在磁盘当中，如css等 </p>\n<p><strong>协商缓存</strong>：向服务器发送请求,服务器根据请求中的Header的字段判断是否命中协商缓存,如果命中,则返回<strong>304</strong>状态码并带上新的响应头通知浏览器从缓存中读取资源</p>\n<p>与之相关的字段为：<br>强缓存：<strong>cache-control、expires</strong><br>协商缓存：<strong>Last-Modified&#x2F;if-Modified-Since、Etag&#x2F;if-None-Match.</strong></p>\n<p>其实整个缓存机制也就是围绕着这几个字段所展开</p>\n<h2 id=\"二、强缓存流程\"><a href=\"#二、强缓存流程\" class=\"headerlink\" title=\"二、强缓存流程\"></a>二、强缓存流程</h2><p>强缓存是由Http的Response Header中的<strong>Expires</strong>或者<strong>Cache-Control</strong>两个字段来控制的，用来表示资源的缓存时间。如果Cache-control与expires同时存在的话，Cache-control的优先级高于expires。</p>\n<h4 id=\"Expires\"><a href=\"#Expires\" class=\"headerlink\" title=\"Expires\"></a>Expires</h4><p>是一个http1.0提出的概念，它描述的是一个绝对时间，由服务端返回</p>\n<blockquote>\n<p><code>expires: Mon, 11 Jun 2029 08:34:12 GMT</code></p>\n</blockquote>\n<h4 id=\"Cache-Control\"><a href=\"#Cache-Control\" class=\"headerlink\" title=\"Cache-Control\"></a>Cache-Control</h4><p>Catche-control是http1.1提出的概念，优先级高于expires，描述的是一个相对时间</p>\n<blockquote>\n<p><code>cache-control: max-age=315360000</code></p>\n</blockquote>\n<p>除了max-age外，cache-control还有其他几个参数：<br><strong>-no-cache</strong>：不使用本地缓存。需要使用缓存协商，先与服务器确认返回的响应是否被更改，如果之前的响应中存在ETag，那么请求的时候会与服务端验证，如果资源未被更改，则可以避免重新下载。<br><strong>-no-store</strong>：直接禁止浏览器缓存数据，每次用户请求该资源，都会向服务器发送一个请求，每次都会下载完整的资源。<br><strong>-public</strong>：可以被所有的用户缓存，包括终端用户和CDN等中间代理服务器。<br><strong>-private</strong>：只能被终端用户的浏览器缓存，不允许CDN等中继缓存服务器对其缓存。</p>\n<p>如过Cache-Control和Expires条件都不满足，也就是说：像cache-control的字段为-no-cache和-no-store以及max-age不满足条件或者当前时间大于Expires的时间的时候，那么强缓存是没有被命中的，接下来要继续进行协商缓存的流程。</p>\n<h2 id=\"三、协商缓存流程\"><a href=\"#三、协商缓存流程\" class=\"headerlink\" title=\"三、协商缓存流程\"></a>三、协商缓存流程</h2><p>协商缓存相对于强缓存流程就复杂一点了，主要通过：<strong>Last-Modified&#x2F;If-Modified-Since</strong>和<strong>ETag&#x2F;If-None-Match</strong>来控制。Etag是服务器自动生成或者由开发者生成的对应资源在服务器端的唯一标识符，能够更加准确的控制缓存。Last-Modified与ETag是可以一起使用的，服务器会优先验证ETag，一致的情况下，才会继续比对Last-Modified，最后才决定是否返回<strong>304</strong>。</p>\n<h4 id=\"Last-Modified-If-Modified-Since\"><a href=\"#Last-Modified-If-Modified-Since\" class=\"headerlink\" title=\"Last-Modified&#x2F;If-Modified-Since\"></a>Last-Modified&#x2F;If-Modified-Since</h4><p>Last-Modified 表示本地文件最后修改日期，浏览器会在Request Header加上If-Modified-Since（上次返回的Last-Modified的值），询问服务器在该日期后资源是否有更新，有更新的话就会将新的资源发送回来。</p>\n<p>但是单纯使用Last-Modified 会有以下问题：</p>\n<ol>\n<li><p>Last-Modified标注的最后修改只能精确到秒级，如果某些文件在1秒钟以内，被修改多次的话，它将不能准确标注文件的修改时间</p>\n</li>\n<li><p>如果某些文件会被定期生成，当有时内容并没有任何变化，但Last-Modified却改变了，导致文件没法使用缓存</p>\n</li>\n<li><p>有可能存在服务器没有准确获取文件修改时间，或者与代理服务器时间不一致等情形</p>\n</li>\n</ol>\n<p>所以在HTTP&#x2F;1.1的时候加入了ETag&#x2F;If-None-Match来解决这些问题，因而ETag的优先级高于Last-Modified。</p>\n<h4 id=\"ETag-If-None-Match\"><a href=\"#ETag-If-None-Match\" class=\"headerlink\" title=\"ETag&#x2F;If-None-Match\"></a>ETag&#x2F;If-None-Match</h4><p>ETag可以保证每一个资源是唯一的，资源变化都会导致ETag变化。ETag值的变更则说明资源状态已经被修改。服务器根据浏览器上发送的If-None-Match值来判断是否命中缓存。</p>\n<p>If-None-Match的header会将上次返回的Etag发送给服务器，询问该资源的Etag是否有更新，有变动就会发送新的资源回来.</p>\n<p>Etag是服务器自动生成或者由开发者生成的对应资源在服务器端的唯一标识符，能够更加准确的控制缓存。<strong>Last-Modified与ETag是可以一起使用的，服务器会优先验证ETag，一致的情况下，才会继续比对Last-Modified，最后才决定是否返回304。</strong></p>\n<h2 id=\"四、总结\"><a href=\"#四、总结\" class=\"headerlink\" title=\"四、总结\"></a>四、总结</h2><p>一、由于HTTP一直在发展，所以对于HTTP的缓存字段也变得越来越复杂，其实我们很清晰的可以知道Expires与Last-Modified&#x2F;If-Modified-Since是Http&#x2F;1.0时代的产物。 Cache-Control与ETag&#x2F;If-None-Match是HTTP&#x2F;1.1为解决HTTP&#x2F;1.0新增出来的字段，这样对比去记忆理解起来，其实缓存机制也就变得很好理解了。</p>\n<p>二、对于第一次请求（肯定是没有任何缓存的），那么直接向服务器请求资源并将下载好的资源进行缓存，为下一次请求做缓存准备。</p>\n<p>三、对于第二次之后的请求，那么本地是有缓存的，那么先通过cache-control的规则判断（对于Http1.0还是Expires）来判断本地缓存是否过期，如果没过期，那么直接使用。如果过期了，就再判断Etag（具体流程可以参考：<a href=\"https://blog.csdn.net/kikikind/article/details/6266101\">Etag与HTTP缓存机制</a>），通过发送If-None-Match（也就是上次存入的Tag的值），服务器进行一个决策判断返回200还是304。之前有说到，Last-Modified与ETag是可以一起使用的，服务器会优先验证ETag，也就是Etag不存在或者其他情况那么会使用Last-Modified来进行判断，通过向服务器发送If-Modified-Since，然后服务器进行一次决策。</p>\n<p>看流程图可能一下子就明白了：</p>\n<p><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWFnZXMyMDE4LmNuYmxvZ3MuY29tL2Jsb2cvOTQwODg0LzIwMTgwNC85NDA4ODQtMjAxODA0MjMxNDE5NTE3MzUtOTEyNjk5MjEzLnBuZw?x-oss-process=image/format,png\"></p>\n<p>参考：</p>\n<p><a href=\"https://www.jianshu.com/p/19c2e397e22a\">https://www.cnblogs.com/ranyonsue/p/8918908.html</a><br><a href=\"https://www.jianshu.com/p/19c2e397e22a\">https://www.jianshu.com/p/19c2e397e22a</a></p>\n","categories":[{"name":"技术文章","slug":"technology","api":"api/categories/technology.json"}],"tags":[{"name":"Http","slug":"Http","api":"api/tags/Http.json"}],"api":"api/posts/2020/04/20/Http缓存机制.json"},{"title":"诗歌-《再见》","slug":"诗歌-《再见》","date":"2020-03-29T11:43:00.000Z","updated":"2025-05-20T11:46:57.000Z","comments":true,"url":"2020/03/29/诗歌-《再见》/","excerpt":"<p>再见<br>是离时的伤感<br>静静地来了<br>悄悄地离开<br>伤感的是那<br>来时的晴天白云<br>离时的栉风沐雨</p>\n<p>再见<br>是离时的不舍<br>多少日夜兼程<br>多少风雨无阻<br>不舍的是那<br>专研执著的精神<br>是那昔时的人儿</p>\n<p>再见<br>是对君的怀念<br>念与君时的如沐春风<br>怀与君时的意气风发<br>看烛烬月半沉<br>听蛩噪院已深<br>心悦君兮君可知？</p>\n<p>再见<br>只是为了下次更好的见</p>\n<p>あなたに会えて嬉しい<br>私の名前はジュルリス</p>\n<p>NICE TO MEET U.<br>I AM JU1IS.</p>\n","cover":null,"images":[],"content":"<p>再见<br>是离时的伤感<br>静静地来了<br>悄悄地离开<br>伤感的是那<br>来时的晴天白云<br>离时的栉风沐雨</p>\n<p>再见<br>是离时的不舍<br>多少日夜兼程<br>多少风雨无阻<br>不舍的是那<br>专研执著的精神<br>是那昔时的人儿</p>\n<p>再见<br>是对君的怀念<br>念与君时的如沐春风<br>怀与君时的意气风发<br>看烛烬月半沉<br>听蛩噪院已深<br>心悦君兮君可知？</p>\n<p>再见<br>只是为了下次更好的见</p>\n<p>あなたに会えて嬉しい<br>私の名前はジュルリス</p>\n<p>NICE TO MEET U.<br>I AM JU1IS.</p>\n","categories":[{"name":"生活感想","slug":"life","api":"api/categories/life.json"}],"tags":[{"name":"诗歌","slug":"诗歌","api":"api/tags/诗歌.json"}],"api":"api/posts/2020/03/29/诗歌-《再见》.json"},{"title":"哈夫曼树与编码","slug":"数据结构-哈夫曼Huffman树","date":"2020-03-24T01:38:00.000Z","updated":"2025-05-20T11:46:57.000Z","comments":true,"url":"2020/03/24/数据结构-哈夫曼Huffman树/","excerpt":"<p><strong>哈夫曼树定义：</strong></p>\n<blockquote>\n<p>给定N个权值作为N个叶子结点，构造一棵二叉树，若该树的带权路径长度达到最小，称这样的二叉树为最优二叉树，也称为哈夫曼树(Huffman<br>Tree)。哈夫曼树是带权路径长度最短的树，权值较大的结点离根较近。</p>\n</blockquote>\n<p>例：在数据通信中，需要将传送的文字转换成二进制的字符串，用0，1码的不同排列来表示字符。例如，需传送的报文为“AFTER DATA EAR ARE ART AREA”，这里用到的字符集为“A，E，R，T，F，D”，各字母出现的次数为{8，4，5，3，1，1}。现要求为这些字母设计编码。要区别6个字母，最简单的二进制编码方式是等长编码，固定采用3位二进制，可分别用000、001、010、011、100、101对“A，E，R，T，F，D”进行编码发送，当对方接收报文时再按照三位一分进行译码。显然编码的长度取决报文中不同字符的个数。</p>\n<h2 id=\"哈夫曼树创建方法\"><a href=\"#哈夫曼树创建方法\" class=\"headerlink\" title=\"哈夫曼树创建方法\"></a>哈夫曼树创建方法</h2><p>摘自：<a href=\"https://blog.csdn.net/FX677588/article/details/70767446\">《详细图解哈夫曼Huffman编码树》</a></p>\n<h3 id=\"2-1-初始队列\"><a href=\"#2-1-初始队列\" class=\"headerlink\" title=\"2.1 初始队列\"></a>2.1 初始队列</h3><p>　　我们按出现频率高低将其放入一个优先级队列中，从左到右依次为频率逐渐增加。\n　</p>\n<img src=\"https://cdn.julis.wang/blog/img/20200319094704131.png\">\n<p>　　下面我们需要将这个队列转换成哈夫曼二叉树，哈夫曼二叉树是一颗带权重的二叉树，权重是由队列中每个字符出现的次数所决定的。并且哈夫曼二叉树始终保证权重越大的字符出现在越高的地方。</p>\n<h3 id=\"2-2-第一步合并\"><a href=\"#2-2-第一步合并\" class=\"headerlink\" title=\"2.2 第一步合并\"></a>2.2 第一步合并</h3><p>　　首先我们从左到右进行合并，依次构建二叉树。第一步取前两个字符u和r来构造初始二叉树，第一个字符作为左节点，第二个元素作为右节点，然后两个元素相加作为新空元素，并且两者权重相加作为新元素的权重。\n　　</p>\n<img src=\"https://cdn.julis.wang/blog/img/20200319094810712.png\">\n\n<p>　　同理，新元素可以和字符i再合并，如下：</p>\n<img src=\"https://cdn.julis.wang/blog/img/20200319094824181.png\">\n\n<h3 id=\"2-3-重新调整队列\"><a href=\"#2-3-重新调整队列\" class=\"headerlink\" title=\"2.3 重新调整队列\"></a>2.3 重新调整队列</h3><p>　　上图新元素权重相加后结果是变大了，需要对权重进行重新排序。\n　　</p>\n<img src=\"https://cdn.julis.wang/blog/img/20200319094841561.png\">\n<p>　　然后再依次从左到右合并，每合并一次则进行一次队列重新排序调整。如下：</p>\n<img src=\"https://cdn.julis.wang/blog/img/2020031909485354.png\">\n<p>　　经过多步操作之后，得到以下的哈夫曼二叉树结构，也就是一个带有权重的二叉树：</p>\n<img src=\"https://cdn.julis.wang/blog/img/20200319094902609.png\">\n\n<h3 id=\"2-4-哈夫曼编码\"><a href=\"#2-4-哈夫曼编码\" class=\"headerlink\" title=\"2.4 哈夫曼编码\"></a>2.4 哈夫曼编码</h3><p>　　有了上面带权重的二叉树之后，我们就可以进行编码了。我们把二叉树分支中左边的支路编码为0，右边分支表示为1，如下图：\n　</p>\n<img src=\"https://cdn.julis.wang/blog/img/20200319094918382.png\">\n<p>　　这样依次遍历这颗二叉树就可以获取得到所有字符的编码了。例如：‘ ’的编码为10，‘l’的编码为00，‘u’的编码为11100等等。经过这个编码设置之后我们可以发现，出现频率越高的字符越会在上层，这样它的编码越短；出现频率越低的字符越会在下层，编码越短。经过这样的设计，最终整个文本存储空间才会最大化的缩减。<br>　　最终我们可以得到下面这张编码表：</p>\n<img src=\"https://cdn.julis.wang/blog/img/20200319094927897.png\">\n\n<h3 id=\"2-5-字符串编码\"><a href=\"#2-5-字符串编码\" class=\"headerlink\" title=\"2.5 字符串编码\"></a>2.5 字符串编码</h3><p>　　有了上面的编码表之后，”we will we will r u”这句重新进行编码就可以得到很大的压缩，编码表示为：01 110 10 01 1111 00 00 10 01 110 10 01 1111 00 00 10 11101 10 11100。这样最终我们只需50位内存，比原ASCII码表示节约了2&#x2F;3空间，效果还是很理想的。当然现实中不是简单这样表示的，还需要考虑很多问题。</p>\n<h2 id=\"三、哈夫曼编码的压缩与解压\"><a href=\"#三、哈夫曼编码的压缩与解压\" class=\"headerlink\" title=\"三、哈夫曼编码的压缩与解压\"></a>三、哈夫曼编码的压缩与解压</h2><p>1、使用IO流逐字节读取文档。用一个数组（0~255,下标表示ASCII码）来保存不同字符出现的次数<br>2、建一个节点类，保存节点对象的信息。将数组每一位表示的字符和出现频次存入创建的节点，把所有节点存入一个链表。<br>3、根据节点存储的频次值，对链表进行从小到大排序<br>4、从链表中取出并删除最小的两个节点，创建一个他们的父节点，父节点不存字符，值为那两个节点的和，把那两个节点分别作为其左子节点和右子节点，最后把这个父节点存入链表。再次排序，取出并删除最小的两个节点，生成父节点，再存入…以此类推，最终生成一棵哈夫曼树。<br>5、对哈夫曼树进行遍历，使得叶子结点获得相应编码，同时把字符和它对应的哈夫曼编码存入HashMap</p>\n<h2 id=\"四、疑问\"><a href=\"#四、疑问\" class=\"headerlink\" title=\"四、疑问\"></a>四、疑问</h2><h3 id=\"4-1对于字符频率相等的情况\"><a href=\"#4-1对于字符频率相等的情况\" class=\"headerlink\" title=\"4.1对于字符频率相等的情况\"></a>4.1对于字符频率相等的情况</h3><p>我们在构建哈夫曼树的时候在想，如果我们的字符出现的频率相等的情况，那哈夫曼树岂不是很糟？<br>我们假设原来字符串长度为N，那么对于普通的ASCII编码得到的长度为8N，如果利用哈夫曼编码，对于每一个字符，最大的长度不会超过8层树因为ASCII编码总共只有2^8个字符，也就是说最极端的情况：一个文件中所有字符串中出现256个字符且重复次数是一样的，但这仍然对原来的文本有进行过压缩（毕竟出现次数相等的话，构造的哈夫曼树在8层之前还是有数据的，那些数据的位数&lt;8）最终的编码数一定是会&lt;8N</p>\n<h3 id=\"4-2解码冲突问题\"><a href=\"#4-2解码冲突问题\" class=\"headerlink\" title=\"4.2解码冲突问题\"></a>4.2解码冲突问题</h3><p>我们在解压遍历哈夫曼的时候，最终的编码不会冲突么？举例：上面我们得到得最终的编码是<br>01 110 10 01 1111 00 00 10 01 110 10 01 1111 00 00 10 11101 10 11100但是在实际的压缩中我们不会有分隔符最终的情况将会是：<br>0111010 0111110000100111010011111000010111011011100<br>于是我们怎么知道：前面的01是一个编码，为什那么0111就是一个编码呢？也就是说01是0111的前缀 。其实我们从这张图就能看出来：对于上述的字符串一定不会存在一个叫0111的编码，因为“w”字母代表的01已经没有子节点。其实中也可以看出一些区域是空着的比如：11、111、111、1110 没有数据，其实这都是满足了哈夫曼树的 <strong>左起字串不冲突原则</strong></p>\n<img src=\"https://cdn.julis.wang/blog/img/20200319094918382.png\">\n\n\n\n","cover":null,"images":["https://cdn.julis.wang/blog/img/20200319094704131.png","https://cdn.julis.wang/blog/img/20200319094810712.png","https://cdn.julis.wang/blog/img/20200319094824181.png","https://cdn.julis.wang/blog/img/20200319094841561.png","https://cdn.julis.wang/blog/img/2020031909485354.png","https://cdn.julis.wang/blog/img/20200319094902609.png","https://cdn.julis.wang/blog/img/20200319094918382.png","https://cdn.julis.wang/blog/img/20200319094927897.png"],"content":"<p><strong>哈夫曼树定义：</strong></p>\n<blockquote>\n<p>给定N个权值作为N个叶子结点，构造一棵二叉树，若该树的带权路径长度达到最小，称这样的二叉树为最优二叉树，也称为哈夫曼树(Huffman<br>Tree)。哈夫曼树是带权路径长度最短的树，权值较大的结点离根较近。</p>\n</blockquote>\n<p>例：在数据通信中，需要将传送的文字转换成二进制的字符串，用0，1码的不同排列来表示字符。例如，需传送的报文为“AFTER DATA EAR ARE ART AREA”，这里用到的字符集为“A，E，R，T，F，D”，各字母出现的次数为{8，4，5，3，1，1}。现要求为这些字母设计编码。要区别6个字母，最简单的二进制编码方式是等长编码，固定采用3位二进制，可分别用000、001、010、011、100、101对“A，E，R，T，F，D”进行编码发送，当对方接收报文时再按照三位一分进行译码。显然编码的长度取决报文中不同字符的个数。</p>\n<h2 id=\"哈夫曼树创建方法\"><a href=\"#哈夫曼树创建方法\" class=\"headerlink\" title=\"哈夫曼树创建方法\"></a>哈夫曼树创建方法</h2><p>摘自：<a href=\"https://blog.csdn.net/FX677588/article/details/70767446\">《详细图解哈夫曼Huffman编码树》</a></p>\n<h3 id=\"2-1-初始队列\"><a href=\"#2-1-初始队列\" class=\"headerlink\" title=\"2.1 初始队列\"></a>2.1 初始队列</h3><p>　　我们按出现频率高低将其放入一个优先级队列中，从左到右依次为频率逐渐增加。\n　</p>\n<img src=\"https://cdn.julis.wang/blog/img/20200319094704131.png\">\n<p>　　下面我们需要将这个队列转换成哈夫曼二叉树，哈夫曼二叉树是一颗带权重的二叉树，权重是由队列中每个字符出现的次数所决定的。并且哈夫曼二叉树始终保证权重越大的字符出现在越高的地方。</p>\n<h3 id=\"2-2-第一步合并\"><a href=\"#2-2-第一步合并\" class=\"headerlink\" title=\"2.2 第一步合并\"></a>2.2 第一步合并</h3><p>　　首先我们从左到右进行合并，依次构建二叉树。第一步取前两个字符u和r来构造初始二叉树，第一个字符作为左节点，第二个元素作为右节点，然后两个元素相加作为新空元素，并且两者权重相加作为新元素的权重。\n　　</p>\n<img src=\"https://cdn.julis.wang/blog/img/20200319094810712.png\">\n\n<p>　　同理，新元素可以和字符i再合并，如下：</p>\n<img src=\"https://cdn.julis.wang/blog/img/20200319094824181.png\">\n\n<h3 id=\"2-3-重新调整队列\"><a href=\"#2-3-重新调整队列\" class=\"headerlink\" title=\"2.3 重新调整队列\"></a>2.3 重新调整队列</h3><p>　　上图新元素权重相加后结果是变大了，需要对权重进行重新排序。\n　　</p>\n<img src=\"https://cdn.julis.wang/blog/img/20200319094841561.png\">\n<p>　　然后再依次从左到右合并，每合并一次则进行一次队列重新排序调整。如下：</p>\n<img src=\"https://cdn.julis.wang/blog/img/2020031909485354.png\">\n<p>　　经过多步操作之后，得到以下的哈夫曼二叉树结构，也就是一个带有权重的二叉树：</p>\n<img src=\"https://cdn.julis.wang/blog/img/20200319094902609.png\">\n\n<h3 id=\"2-4-哈夫曼编码\"><a href=\"#2-4-哈夫曼编码\" class=\"headerlink\" title=\"2.4 哈夫曼编码\"></a>2.4 哈夫曼编码</h3><p>　　有了上面带权重的二叉树之后，我们就可以进行编码了。我们把二叉树分支中左边的支路编码为0，右边分支表示为1，如下图：\n　</p>\n<img src=\"https://cdn.julis.wang/blog/img/20200319094918382.png\">\n<p>　　这样依次遍历这颗二叉树就可以获取得到所有字符的编码了。例如：‘ ’的编码为10，‘l’的编码为00，‘u’的编码为11100等等。经过这个编码设置之后我们可以发现，出现频率越高的字符越会在上层，这样它的编码越短；出现频率越低的字符越会在下层，编码越短。经过这样的设计，最终整个文本存储空间才会最大化的缩减。<br>　　最终我们可以得到下面这张编码表：</p>\n<img src=\"https://cdn.julis.wang/blog/img/20200319094927897.png\">\n\n<h3 id=\"2-5-字符串编码\"><a href=\"#2-5-字符串编码\" class=\"headerlink\" title=\"2.5 字符串编码\"></a>2.5 字符串编码</h3><p>　　有了上面的编码表之后，”we will we will r u”这句重新进行编码就可以得到很大的压缩，编码表示为：01 110 10 01 1111 00 00 10 01 110 10 01 1111 00 00 10 11101 10 11100。这样最终我们只需50位内存，比原ASCII码表示节约了2&#x2F;3空间，效果还是很理想的。当然现实中不是简单这样表示的，还需要考虑很多问题。</p>\n<h2 id=\"三、哈夫曼编码的压缩与解压\"><a href=\"#三、哈夫曼编码的压缩与解压\" class=\"headerlink\" title=\"三、哈夫曼编码的压缩与解压\"></a>三、哈夫曼编码的压缩与解压</h2><p>1、使用IO流逐字节读取文档。用一个数组（0~255,下标表示ASCII码）来保存不同字符出现的次数<br>2、建一个节点类，保存节点对象的信息。将数组每一位表示的字符和出现频次存入创建的节点，把所有节点存入一个链表。<br>3、根据节点存储的频次值，对链表进行从小到大排序<br>4、从链表中取出并删除最小的两个节点，创建一个他们的父节点，父节点不存字符，值为那两个节点的和，把那两个节点分别作为其左子节点和右子节点，最后把这个父节点存入链表。再次排序，取出并删除最小的两个节点，生成父节点，再存入…以此类推，最终生成一棵哈夫曼树。<br>5、对哈夫曼树进行遍历，使得叶子结点获得相应编码，同时把字符和它对应的哈夫曼编码存入HashMap</p>\n<h2 id=\"四、疑问\"><a href=\"#四、疑问\" class=\"headerlink\" title=\"四、疑问\"></a>四、疑问</h2><h3 id=\"4-1对于字符频率相等的情况\"><a href=\"#4-1对于字符频率相等的情况\" class=\"headerlink\" title=\"4.1对于字符频率相等的情况\"></a>4.1对于字符频率相等的情况</h3><p>我们在构建哈夫曼树的时候在想，如果我们的字符出现的频率相等的情况，那哈夫曼树岂不是很糟？<br>我们假设原来字符串长度为N，那么对于普通的ASCII编码得到的长度为8N，如果利用哈夫曼编码，对于每一个字符，最大的长度不会超过8层树因为ASCII编码总共只有2^8个字符，也就是说最极端的情况：一个文件中所有字符串中出现256个字符且重复次数是一样的，但这仍然对原来的文本有进行过压缩（毕竟出现次数相等的话，构造的哈夫曼树在8层之前还是有数据的，那些数据的位数&lt;8）最终的编码数一定是会&lt;8N</p>\n<h3 id=\"4-2解码冲突问题\"><a href=\"#4-2解码冲突问题\" class=\"headerlink\" title=\"4.2解码冲突问题\"></a>4.2解码冲突问题</h3><p>我们在解压遍历哈夫曼的时候，最终的编码不会冲突么？举例：上面我们得到得最终的编码是<br>01 110 10 01 1111 00 00 10 01 110 10 01 1111 00 00 10 11101 10 11100但是在实际的压缩中我们不会有分隔符最终的情况将会是：<br>0111010 0111110000100111010011111000010111011011100<br>于是我们怎么知道：前面的01是一个编码，为什那么0111就是一个编码呢？也就是说01是0111的前缀 。其实我们从这张图就能看出来：对于上述的字符串一定不会存在一个叫0111的编码，因为“w”字母代表的01已经没有子节点。其实中也可以看出一些区域是空着的比如：11、111、111、1110 没有数据，其实这都是满足了哈夫曼树的 <strong>左起字串不冲突原则</strong></p>\n<img src=\"https://cdn.julis.wang/blog/img/20200319094918382.png\">\n\n\n\n","categories":[{"name":"算法研究","slug":"算法研究","api":"api/categories/算法研究.json"}],"tags":[{"name":"技术文章","slug":"technology","api":"api/tags/technology.json"}],"api":"api/posts/2020/03/24/数据结构-哈夫曼Huffman树.json"},{"title":"《寄生虫》观后感","slug":"《寄生虫》观后感","date":"2020-03-22T13:22:00.000Z","updated":"2025-05-20T11:46:57.000Z","comments":true,"url":"2020/03/22/《寄生虫》观后感/","excerpt":"<p>这个周末总共看了三部电影：《无人生还》《吹哨人》《寄生虫》，前两部看完之后并没有太多的触动，倒是寄生虫看得人实在是过瘾，整个电影的剧情发展，以及想要表达出来镜头语音都做到了极致，以及让人能够思索很久很久的电影余味，配得上所获得的无数奖项。</p>\n<p>电影最后以欢乐的party变为残忍的凶案为结局，很多电影中过场看得人是瞠目结舌。极力推荐大家去欣赏一下这部电影，剧作节奏，镜头语言，剧本钩子绝对不会让你失望。</p>\n<p>整部电影都围绕着电影名“寄生虫”展开，我们来看一下什么是“寄生虫”。“寄生虫”百科解释道：寄生虫（parasite）指具有致病性的低等真核生物，可作为病原体，也可作为媒介传播疾病。寄生虫特征为在宿主或寄主（host）体内或附着于体外以获取维持其生存、发育或者繁殖所需的营养或者庇护的一切生物。在这一段的解释中:  低等、寄生、生存 是其中的关键词，也是整部电影的关键词。</p>\n<p>电影中何为“低等”？或者说是相对而言的低等，电影中的低等则是活在社会底层的一家人-不大的屋子住在一家四口人，靠着折叠披萨盒子生存，上网需要到脏乱差的厕所最里面去蹭别人家的网。而高等则是富豪社长所在的家庭-著名建筑家设计的别墅里的家庭，专门的司机、保姆等。</p>\n<p>电影中的“寄生”，有两种情况：一是主角家庭利用一系列的欺骗手段，从而“寄生”在富豪家里，他们一家人虽然也生活在别墅里，吃一样的食物，睡一样的床，但是他们就像是房间里的蟑螂，一旦主人回来了，就立马躲起来，但蟑螂并不是每次都能藏得那么好的，一旦被发现后果不堪设想。二是原本看起来一切正常的“前保姆”与丈夫偷偷居住在别墅地下道四年，在主角家庭一家人到来之前，虽然他丈夫住在很阴暗的地下室里，但是他们过得很知足。</p>\n<p>那么生存呢？一切的生物活动都是为了生存和繁衍，这就将上述两个关键词结合在了一起，三者：两者低等寄生，一者高等宿主体。三者的关系则构成了：高等对低等、低等对低等。在影片的高潮部分表现得淋漓尽致：在富有家庭为儿子举办的生日宴上，意外再次发生。后来的低等“寄生”为了斩草除根掉以前的“寄生”，巩固自己一家的“寄生虫”地位，便决心要下到地下室里面斩草除根，但是却因为意外，而将原来的寄生虫家庭的男方放了出来，基宇被自己带的谋杀凶器砸得头破血流，失去理智的男人冲向了草坪，将刀子插进了基婷的胸口，场面再度混乱。而这时候富豪的儿子只是吓晕了过去，而贫穷的父亲的儿子头破血流，女儿已经中刀血流不止，经过一波血拼，都倒下了。富人真正关心的并不是贫穷人子女的生死，只是一味地关注着自己晕倒的儿子，并且表现出对低等的嫌弃，父亲最后一丝自尊心被打破，一刀扎进了富人的身体……</p>\n<p>再回到电影最初看，一家人生活在简简单单地家庭里靠着手工过生活，但是日子过得很开心，一起围坐在桌子旁喝啤酒，他们不用去担心明天，只考虑活在当下。当儿子得到那一份还不错的家教，后来女儿也去家教，都有一部分很不错的收入，有一定的能力开始开始下馆子，渐渐地一家人都想要更“好”的生活，开始依附于富人家里，从而一步步铤而走险，时时提心吊胆，当到最后深陷泥潭的时候，儿子问：我们下一步的计划是什么？父亲答：没有计划的计划是最安全的。或许这时候他们想要过得是安心的生活吧，但已经回不去了，欲望以及使他们沉沦。</p>\n<p>引用评论：欲望本身是没有错误的，适度的欲望甚至可以让你变得积极向上，但是过度的欲望则会将你拖进地狱。天堂和地狱之间，大概也就是一念之隔。寄生虫如果能够安守本分过好自己的“寄生”生活，或许影片就会是另外的结局，但因为欲望，寄生虫往往都想要做主人，但殊不知，寄生虫失去了主人，便也离死亡不远了。</p>\n<p>明天又是新的一周，加油吧！咱们的生活还是很美好的，敲敲代码、喝喝茶、打打麻将还是挺舒服的哈</p>\n","cover":null,"images":[],"content":"<p>这个周末总共看了三部电影：《无人生还》《吹哨人》《寄生虫》，前两部看完之后并没有太多的触动，倒是寄生虫看得人实在是过瘾，整个电影的剧情发展，以及想要表达出来镜头语音都做到了极致，以及让人能够思索很久很久的电影余味，配得上所获得的无数奖项。</p>\n<p>电影最后以欢乐的party变为残忍的凶案为结局，很多电影中过场看得人是瞠目结舌。极力推荐大家去欣赏一下这部电影，剧作节奏，镜头语言，剧本钩子绝对不会让你失望。</p>\n<p>整部电影都围绕着电影名“寄生虫”展开，我们来看一下什么是“寄生虫”。“寄生虫”百科解释道：寄生虫（parasite）指具有致病性的低等真核生物，可作为病原体，也可作为媒介传播疾病。寄生虫特征为在宿主或寄主（host）体内或附着于体外以获取维持其生存、发育或者繁殖所需的营养或者庇护的一切生物。在这一段的解释中:  低等、寄生、生存 是其中的关键词，也是整部电影的关键词。</p>\n<p>电影中何为“低等”？或者说是相对而言的低等，电影中的低等则是活在社会底层的一家人-不大的屋子住在一家四口人，靠着折叠披萨盒子生存，上网需要到脏乱差的厕所最里面去蹭别人家的网。而高等则是富豪社长所在的家庭-著名建筑家设计的别墅里的家庭，专门的司机、保姆等。</p>\n<p>电影中的“寄生”，有两种情况：一是主角家庭利用一系列的欺骗手段，从而“寄生”在富豪家里，他们一家人虽然也生活在别墅里，吃一样的食物，睡一样的床，但是他们就像是房间里的蟑螂，一旦主人回来了，就立马躲起来，但蟑螂并不是每次都能藏得那么好的，一旦被发现后果不堪设想。二是原本看起来一切正常的“前保姆”与丈夫偷偷居住在别墅地下道四年，在主角家庭一家人到来之前，虽然他丈夫住在很阴暗的地下室里，但是他们过得很知足。</p>\n<p>那么生存呢？一切的生物活动都是为了生存和繁衍，这就将上述两个关键词结合在了一起，三者：两者低等寄生，一者高等宿主体。三者的关系则构成了：高等对低等、低等对低等。在影片的高潮部分表现得淋漓尽致：在富有家庭为儿子举办的生日宴上，意外再次发生。后来的低等“寄生”为了斩草除根掉以前的“寄生”，巩固自己一家的“寄生虫”地位，便决心要下到地下室里面斩草除根，但是却因为意外，而将原来的寄生虫家庭的男方放了出来，基宇被自己带的谋杀凶器砸得头破血流，失去理智的男人冲向了草坪，将刀子插进了基婷的胸口，场面再度混乱。而这时候富豪的儿子只是吓晕了过去，而贫穷的父亲的儿子头破血流，女儿已经中刀血流不止，经过一波血拼，都倒下了。富人真正关心的并不是贫穷人子女的生死，只是一味地关注着自己晕倒的儿子，并且表现出对低等的嫌弃，父亲最后一丝自尊心被打破，一刀扎进了富人的身体……</p>\n<p>再回到电影最初看，一家人生活在简简单单地家庭里靠着手工过生活，但是日子过得很开心，一起围坐在桌子旁喝啤酒，他们不用去担心明天，只考虑活在当下。当儿子得到那一份还不错的家教，后来女儿也去家教，都有一部分很不错的收入，有一定的能力开始开始下馆子，渐渐地一家人都想要更“好”的生活，开始依附于富人家里，从而一步步铤而走险，时时提心吊胆，当到最后深陷泥潭的时候，儿子问：我们下一步的计划是什么？父亲答：没有计划的计划是最安全的。或许这时候他们想要过得是安心的生活吧，但已经回不去了，欲望以及使他们沉沦。</p>\n<p>引用评论：欲望本身是没有错误的，适度的欲望甚至可以让你变得积极向上，但是过度的欲望则会将你拖进地狱。天堂和地狱之间，大概也就是一念之隔。寄生虫如果能够安守本分过好自己的“寄生”生活，或许影片就会是另外的结局，但因为欲望，寄生虫往往都想要做主人，但殊不知，寄生虫失去了主人，便也离死亡不远了。</p>\n<p>明天又是新的一周，加油吧！咱们的生活还是很美好的，敲敲代码、喝喝茶、打打麻将还是挺舒服的哈</p>\n","categories":[{"name":"读书电影","slug":"movie","api":"api/categories/movie.json"}],"tags":[{"name":"省","slug":"thinking","api":"api/tags/thinking.json"}],"api":"api/posts/2020/03/22/《寄生虫》观后感.json"},{"title":"（转）Https之HTTPS 的证书","slug":"Https之HTTPS-的证书","date":"2020-03-04T02:44:00.000Z","updated":"2025-05-20T11:46:57.000Z","comments":true,"url":"2020/03/04/Https之HTTPS-的证书/","excerpt":"<p>转自：<a href=\"https://mp.weixin.qq.com/s/ibwNtDc2zd2tdhMN7iROJw\">https://mp.weixin.qq.com/s/ibwNtDc2zd2tdhMN7iROJw</a><br>作者：<a href=\"https://open.youtu.qq.com/#/open\">腾讯优图实验室</a>   来源：<a href=\"https://mp.weixin.qq.com/s/ibwNtDc2zd2tdhMN7iROJw\">腾讯技术工程</a></p>\n<h2 id=\"1、-证书是什么？\"><a href=\"#1、-证书是什么？\" class=\"headerlink\" title=\"1、 证书是什么？\"></a><strong>1、 证书是什么？</strong></h2><p>解释这个问题之前，先看几个关键词：<strong>CA，CA 机构，数字证书，数字签名，（证书）指纹，(CA)证书，HTTPS 证书，SSL&#x2F;TLS 证书</strong>。</p>\n<p>理一理上面这些关键词之间的关系：</p>\n<p><strong>CA，CA 机构</strong>：机构&#x2F;组织概念。</p>\n<p><strong>数字证书，(CA)证书，HTTPS 证书，SSL&#x2F;TLS 证书</strong>：CA 签发的数字证书。</p>\n<p><strong>数字签名，（证书）指纹</strong>：CA 签发的证书的内容之一，一段加密的密文。</p>\n<p>智库百科对数字证书的解释是：</p>\n<blockquote>\n<p>数字证书也称公开密钥证书，是指用于电子信息活动中电子文件行为主体的验证和证明，并可实现电子文件保密性和完整性的电子数据。数字证书是一个经证书认证中心（Certification<br>Authority，简称 CA）发行的文件。</p>\n</blockquote>\n<p>数字证书包含有行为主体信息和证书认证机构的数字签名。数字签名是指以电子形式存在，可依附在电子文件中用于辨识电子文件的签署者及表示对该电子文件内容负责所使用的电子数字标识。</p>\n<p>抓重点：<strong>数字证书用于主体身份验证。</strong></p>\n<p>首先，<strong>数字证书&#x3D;主体信息+数字签名。</strong></p>\n<p>Windows 下，我们可以在 Chrome 浏览器上点击地址栏的“锁”标记后会出现下拉框，接着点击“证书”即可看到通过 HTTPS 访问该服务器时的数字证书。具体操作如下：</p>\n<img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly9zMS41MWN0by5jb20vb3NzLzIwMjAwMi8yNy8zMjUzNjFhMDc1NzFmZDE3N2M4YjBhMzcyM2Y1YzBmMS5wbmc?x-oss-process=image/format,png\" width=\"40%\"/>\n\n\n<ul>\n<li>证书“常规”页面，是关于该证书的一个笼统介绍，包括签发该证书的 CA 机构、该证书绑定的域名（颁发给）、证书有效期。</li>\n<li>证书“详细信息”页面，以键值对形式展示了这张证书的完整内容。（后文将详细介绍证书内容）</li>\n<li>证书的“证书路径”，以层级结构展示了从该证书绑定的域名一直到根证书的路径，这就是证书链。（后文会展开介绍证书链）</li>\n</ul>\n<p><strong>主体的必要信息</strong>：版本(version)、序列号(serialNumber)、签名算法(signatureAlgorithm)、颁发者(issuer)、有效期(validity)、使用者(subject)、公钥信息(subjectPublicKeyInfo)</p>\n<p>主体的扩展信息(extension)：如密钥标识符、证书策略等</p>\n<p>数字签名(signature)，也称指纹</p>\n<p>抽象为下图：<br><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly9zNS41MWN0by5jb20vb3NzLzIwMjAwMi8yNy9jNGIyNzAxMjY5MmMyNWI4NTYxOWEwMTdmMmMxNTE4Zi5qcGctd2hfNjAweC1zXzM3MzQxNzQwMjguanBn?x-oss-process=image/format,png\" width=\"40%\"/></p>\n<h2 id=\"2、-为什么是数字证书呢？\"><a href=\"#2、-为什么是数字证书呢？\" class=\"headerlink\" title=\"2、 为什么是数字证书呢？\"></a><strong>2、 为什么是数字证书呢？</strong></h2><p>HTTPS 已经对通信数据进行了加密，为什么还要验证身份？说好的“人与人之间最基本的信任呢？”</p>\n<p>这还不是因为各路黑客、骇客们总是在制造各种攻击吗？其中一个大名鼎鼎的中间人攻击（Man-In-The-Middle Attack，MITM 攻击），简单的讲，“中间人”在客户端和服务端都不知情的情况下，夹在双方之间窃听甚至篡改通信信息，过程见下图（图引自《HTTPS 中间人攻击实践（原理·实践）》）：</p>\n<p><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly9zMi41MWN0by5jb20vb3NzLzIwMjAwMi8yNy9hZjM2OGQ1NTMxZWVlMGY4YmVkNzZiMzZjMmM3ODM5YS5qcGctd2hfNjAweC1zXzg4NTk5MDkzNy5qcGc?x-oss-process=image/format,png\"><br>在 HTTPS 的握手阶段，一端向对端发送请求，对端返回自己的公钥；而一端未验证对方的身份和公钥，直接协商密钥。“中间人”看到了这个漏洞，夹在中间截获了对端的公钥，替换成了自己的公钥。正是这步“拿错了公钥”或者说“信错了对端”，使得 HTTPS 为加密（密钥协商的非对称加密和通信数据的对称加密）所做的努力全部泡汤。</p>\n<p>可见，在 HTTPS 中，“确保对端身份正确”即“确保拿到的公钥正确”，而在网络通信中所谓的“身份”，一般指的是通信一端的域名、IP 地址甚至是Mac 地址。所以，数字证书同时包含了通信一端的身份信息和公钥信息。</p>\n<p>但是数字证书会在网络中传输（由被要求验证身份的一端通过网络传给另一端），这就意味着证书也可能会被窃取篡改。这个时候权威的 CA 机构就出马了，他想了个办法：<strong>加了一个“防伪标识”— 数字签名</strong>。具体做法如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">signature = RSA(PriKey_CA, Hash(message))</span><br></pre></td></tr></table></figure>\n\n<p>这里啰嗦几句：数字签名生成过程是首先对原文作哈希，把一段不定长的文本映射成固定长度的字符空间，接着再用 CA 机构的私钥对这段定长字符做加密。大大提高了整体的运算效率。</p>\n<h2 id=\"3-证书是怎么工作的？\"><a href=\"#3-证书是怎么工作的？\" class=\"headerlink\" title=\"3 证书是怎么工作的？\"></a><strong>3 证书是怎么工作的？</strong></h2><p>要了解证书是怎么做“身份验证”，即“防冒充”，得从 2 个角度来说明：</p>\n<p><strong>申请证书，即需要被验证身份的一端，需要申请一份能够验证自己身份的证书<br>验证证书，即需要验证对方身份的一端，拿到证书后验证对端的身份</strong></p>\n<p>请注意，这里有一个前提：<strong>这张证书必须是由权威 CA 机构颁发的，且尚在有效期内；或者是一张信任的私人证书。</strong></p>\n<p><strong>申请证书</strong></p>\n<p>CA 机构和证书的分类本文不讨论，推荐阅读《细说 CA 和证书》，这里我们讨论正规权威 CA 机构签发的证书，至于是 DV、OV 还是 EV，只是安全强度问题，工作原理是一样的。</p>\n<p>总结申请证书的过程：用户向 CA 机构提交自己的信息（如域名）和公钥（用户自己生成的非对称加密公钥，用于 TLS 握手阶段和另一端协商密钥用），CA 机构生成数字证书，如下图：</p>\n<p><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly9zNC41MWN0by5jb20vb3NzLzIwMjAwMi8yNy9lZTAwNzljNjc5ZDRiMmFkMzU4OWZkYjFhYTljOTRlOS5qcGctd2hfNjAweC1zXzI4ODM4MTIzNDcuanBn?x-oss-process=image/format,png\"><br><strong>验证证书</strong></p>\n<p>收到对端发过来的证书，执行证书申请的“逆过程”即可，总结如下图：<br><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly9zMy41MWN0by5jb20vb3NzLzIwMjAwMi8yNy83ZGNlNGVmM2M2NTVlNzgxOWUwZjQwNWI3Yzk2OTY4Ny5qcGctd2hfNjAweC1zXzEyNjMwOTQwNDQuanBn?x-oss-process=image/format,png\"></p>\n<p>接受证书的一端先对除数签名的其他部分做一次相同的哈希算法（证书中指明了哈希算法），得到这段文本的哈希映射，记作 H1；获取 CA 机构的公钥对数字签名属性做解码，得到了 CA 机构计算出的哈希映射，记作 H2。对比 H1 和 H2 两个字符串是否严格相等，若是，代表该证书的信息未被篡改，证书有效；否则，证书内容被篡改，证书无效。</p>\n<p>若证书有效，接受端会再进行对端的身份校验（验证域名），若身份验证通过，接收端会拿证书上的公钥（也是对端自己生产的非对称加密公钥）加密接下来整个 TLS 握手阶段的信息之后，发送给对端。</p>\n<p>这个过程中有一个问题：<strong>CA 机构的公钥怎么获取？</strong></p>\n<p>回答：<strong>提前内置</strong>。</p>\n<p>众所周知，操作系统和浏览器在软件安装阶段会在其特定目录下放置一堆的证书。如 Windows 的根证书管理在 certmgr 下：</p>\n<p><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly9zNS41MWN0by5jb20vb3NzLzIwMjAwMi8yNy8xZjNmZDMyNzQ0NTQ5ZjFiYmJmNzhkZDUxOTU0MmZjMC5qcGctd2hfNjAweC1zXzE3MjQwODczOTUuanBn?x-oss-process=image/format,png\"><br>这些证书都有个特点：权威 CA 机构发布的根证书（Root Certificate）。根证书有几个特点：</p>\n<p><strong>没有上层机构再为其本身作数字签名</strong></p>\n<p><strong>证书上的公钥即为 CA 机构发布的公钥</strong></p>\n<p><strong>权威 CA 机构的自签证书</strong></p>\n<p>而这些根证书会跟很多软件，包括操作系统、浏览器一起被安装到用户设备上。即使没有被提前安装好，这些根证书也可以在 CA 机构的官网上获取得到。</p>\n<p>目前全球大型权威 CA 机构有 Symantec、GeoTrust、Comodo 以及 RapidSSL 等，并且这些机构颁发的 SSL 数字证书，在市场的占有率是非常的高。（节选自《SSL 证书颁发机构有哪些》）</p>\n<p>本地被内置了这么多的根证书，那要怎么知道我这份证书应该要用哪一个根证书来验证呢？</p>\n<p>回答：<strong>证书信任链</strong>。</p>\n<p>在信任链上有 3 类证书：<strong>根证书，中介证书和用户证书</strong>。根证书前文已有说明，用户证书就是对端发过来的证书，或者说是用户向权威 CA 机构绑定了自己身份（主要指域名）和自己公钥的证书。中介证书可以理解由权威 CA 机构委派的代理机构签发的数字证书，推荐阅读《What is an intermediate certificate?》。中介证书或者说是中介机构的存在是为了保证根证书的密钥的安全性。</p>\n<p>细心的同学仔细看一看 certmgr 会发现有一个分类是“中间证书颁发机构”，这里存放的就是中介证书。用户证书绝大多数是通过权威的 CA 机构的代理中介机构颁发。</p>\n<p>这么来说，根据对端发来的用户证书寻找对应的根证书岂不是更困难了？</p>\n<p>自问自答：这是一个在树形数据结构中，从叶子节点搜索根节点的过程，直接一个最原始的深搜（DFS）不就可以了嘛？举例说明，如下图（引自Wikipedia-Chain of trust）：<br><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly9zNS41MWN0by5jb20vb3NzLzIwMjAwMi8yNy9lZGI0YjkwZWI0NGQzMjkyNDYwNGJiZDEzNzNiZjViZS5qcGctd2hfNjAweC1zXzM2MzkzNTg1MTkuanBn?x-oss-process=image/format,png\" alt=\"在这里插入图片描述\"></p>\n<p>从用户证书开始。</p>\n<p>记“Issuer”字段的值为 i1，搜索本地证书，寻找由“Subject”为 i1 的证书。</p>\n<p>若没有找到，结束返回证书无效；否则，跳到步骤 4)。</p>\n<p>判断该证书的 Issuer 值是否等于 Subject 值。</p>\n<p>若是，则该证书是根证书，结束返回该证书；否则跳到步骤 6)。</p>\n<p>以该证书开始，跳转 2)（继续搜索）。</p>\n<p>更多关于信任链的知识点，推荐阅读《What is the SSL Certificate Chain?》</p>\n<h2 id=\"4、证书怎么样？\"><a href=\"#4、证书怎么样？\" class=\"headerlink\" title=\"4、证书怎么样？\"></a>4、证书怎么样？</h2><p>相信不少同学或多或少接触过证书文件，比如.pem、.crt、.cer、.key 等，于是问题就来了：</p>\n<p>“为什么有这么多不同后缀名的证书啊？他们有什么联系和区别？”</p>\n<p>回答这个问题要从 3 个层面来分析：</p>\n<p><strong>证书标准</strong></p>\n<p><strong>证书编码格式</strong></p>\n<p><strong>文件扩展名</strong></p>\n<p><strong>证书标准</strong></p>\n<p>数字证书的格式普遍采用的是 X.509 国际标准，维基百科对于 X.509 解释如下：</p>\n<blockquote>\n<p>X.509 是密码学里公钥证书的格式标准。X.509 证书已应用在包括 TLS&#x2F;SSL<br>在内的众多网络协议里，同时它也用在很多非在线应用场景里，比如电子签名服务。X.509<br>证书里含有公钥、身份信息（比如网络主机名，组织的名称或个体名称等）和签名信息（可以是证书签发机构 CA<br>的签名，也可以是自签名）。对于一份经由可信的证书签发机构签名或者可以通过其它方式验证的证书，证书的拥有者就可以用证书及相应的私钥来创建安全的通信，对文档进行数字签名。</p>\n</blockquote>\n<p>X.509 是 ITU-T 标准化部门基于他们之前的 ASN.1 定义的一套证书标准。</p>\n<p><strong>证书的编码格式</strong></p>\n<p>X.509 标准的证书文件具有不同的编码格式：PEM 和 DER。</p>\n<ul>\n<li>PEM</li>\n</ul>\n<p>PEM，全称 Privacy Enhanced Mail，以文本格式存储，以 —–BEGIN<br>XXX—–开头、—–END XXX—–结尾，中间内容是 BASE64 编码数据。其文本内容大概如下：</p>\n<p>html —–BEGIN CERTIFICATE—– Base64编码过的证书数据 —–END CERTIFICATE—–</p>\n<p>通常，PEM 格式可以存储公钥、私钥、证书签名请求等数据。查看 PEM 格式证书的信息一般采用如下命令：</p>\n<p>openssl x509 -in xxx.pem -text -noout<br>Apache 和 Nginx 服务器偏向于使用这种编码格式.</p>\n<ul>\n<li>DER</li>\n</ul>\n<p>DER，全称 Distinguished Encoding Rules，以二进制存储，因此文件结构无法直接预览，只能通过如下命令查看：</p>\n<p>html openssl x509 -in xxx.der -inform der -text -noout</p>\n<p>DER 格式也可以存储公钥、私钥、证书签名请求等数据。Java 和 Windows 应用偏向于使用这种编码格式。</p>\n<p>当然同一 X.509 证书的不同编码之间可以互相转换：</p>\n<ul>\n<li>PEM 转为 DER：</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">openssl x509 -in xxx.pem -outform der -out xxx.der</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>DER 转为 PEM：</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">openssl x509 -in xxx.der -inform der -outform pem -out xxx.pem</span><br></pre></td></tr></table></figure>\n\n<p><strong>文件扩展名</strong></p>\n<p>不同的扩展名可以分为以下几类：</p>\n<ul>\n<li>证书：</li>\n</ul>\n<p>存放数字证书，X.509 标准，格式可能是 PEM 或 DER。.crt、.cer</p>\n<ul>\n<li>密钥：</li>\n</ul>\n<p>用来存放一个 RSA 公钥或私钥，这类文件不是 X.509 标准，但是是 PEM 或 DER 格式。后缀名有.key。</p>\n<ul>\n<li>证书+密钥：</li>\n</ul>\n<p>可同时存放证书和 RSA 公钥&#x2F;.pem、.der、.p12</p>\n<ul>\n<li>证书请求：</li>\n</ul>\n<p>并不是证书，而是证书签名请求。csr</p>\n","cover":null,"images":["https://imgconvert.csdnimg.cn/aHR0cHM6Ly9zMS41MWN0by5jb20vb3NzLzIwMjAwMi8yNy8zMjUzNjFhMDc1NzFmZDE3N2M4YjBhMzcyM2Y1YzBmMS5wbmc?x-oss-process=image/format,png","https://imgconvert.csdnimg.cn/aHR0cHM6Ly9zNS41MWN0by5jb20vb3NzLzIwMjAwMi8yNy9jNGIyNzAxMjY5MmMyNWI4NTYxOWEwMTdmMmMxNTE4Zi5qcGctd2hfNjAweC1zXzM3MzQxNzQwMjguanBn?x-oss-process=image/format,png","https://imgconvert.csdnimg.cn/aHR0cHM6Ly9zMi41MWN0by5jb20vb3NzLzIwMjAwMi8yNy9hZjM2OGQ1NTMxZWVlMGY4YmVkNzZiMzZjMmM3ODM5YS5qcGctd2hfNjAweC1zXzg4NTk5MDkzNy5qcGc?x-oss-process=image/format,png","https://imgconvert.csdnimg.cn/aHR0cHM6Ly9zNC41MWN0by5jb20vb3NzLzIwMjAwMi8yNy9lZTAwNzljNjc5ZDRiMmFkMzU4OWZkYjFhYTljOTRlOS5qcGctd2hfNjAweC1zXzI4ODM4MTIzNDcuanBn?x-oss-process=image/format,png","https://imgconvert.csdnimg.cn/aHR0cHM6Ly9zMy41MWN0by5jb20vb3NzLzIwMjAwMi8yNy83ZGNlNGVmM2M2NTVlNzgxOWUwZjQwNWI3Yzk2OTY4Ny5qcGctd2hfNjAweC1zXzEyNjMwOTQwNDQuanBn?x-oss-process=image/format,png","https://imgconvert.csdnimg.cn/aHR0cHM6Ly9zNS41MWN0by5jb20vb3NzLzIwMjAwMi8yNy8xZjNmZDMyNzQ0NTQ5ZjFiYmJmNzhkZDUxOTU0MmZjMC5qcGctd2hfNjAweC1zXzE3MjQwODczOTUuanBn?x-oss-process=image/format,png","https://imgconvert.csdnimg.cn/aHR0cHM6Ly9zNS41MWN0by5jb20vb3NzLzIwMjAwMi8yNy9lZGI0YjkwZWI0NGQzMjkyNDYwNGJiZDEzNzNiZjViZS5qcGctd2hfNjAweC1zXzM2MzkzNTg1MTkuanBn?x-oss-process=image/format,png"],"content":"<p>转自：<a href=\"https://mp.weixin.qq.com/s/ibwNtDc2zd2tdhMN7iROJw\">https://mp.weixin.qq.com/s/ibwNtDc2zd2tdhMN7iROJw</a><br>作者：<a href=\"https://open.youtu.qq.com/#/open\">腾讯优图实验室</a>   来源：<a href=\"https://mp.weixin.qq.com/s/ibwNtDc2zd2tdhMN7iROJw\">腾讯技术工程</a></p>\n<h2 id=\"1、-证书是什么？\"><a href=\"#1、-证书是什么？\" class=\"headerlink\" title=\"1、 证书是什么？\"></a><strong>1、 证书是什么？</strong></h2><p>解释这个问题之前，先看几个关键词：<strong>CA，CA 机构，数字证书，数字签名，（证书）指纹，(CA)证书，HTTPS 证书，SSL&#x2F;TLS 证书</strong>。</p>\n<p>理一理上面这些关键词之间的关系：</p>\n<p><strong>CA，CA 机构</strong>：机构&#x2F;组织概念。</p>\n<p><strong>数字证书，(CA)证书，HTTPS 证书，SSL&#x2F;TLS 证书</strong>：CA 签发的数字证书。</p>\n<p><strong>数字签名，（证书）指纹</strong>：CA 签发的证书的内容之一，一段加密的密文。</p>\n<p>智库百科对数字证书的解释是：</p>\n<blockquote>\n<p>数字证书也称公开密钥证书，是指用于电子信息活动中电子文件行为主体的验证和证明，并可实现电子文件保密性和完整性的电子数据。数字证书是一个经证书认证中心（Certification<br>Authority，简称 CA）发行的文件。</p>\n</blockquote>\n<p>数字证书包含有行为主体信息和证书认证机构的数字签名。数字签名是指以电子形式存在，可依附在电子文件中用于辨识电子文件的签署者及表示对该电子文件内容负责所使用的电子数字标识。</p>\n<p>抓重点：<strong>数字证书用于主体身份验证。</strong></p>\n<p>首先，<strong>数字证书&#x3D;主体信息+数字签名。</strong></p>\n<p>Windows 下，我们可以在 Chrome 浏览器上点击地址栏的“锁”标记后会出现下拉框，接着点击“证书”即可看到通过 HTTPS 访问该服务器时的数字证书。具体操作如下：</p>\n<img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly9zMS41MWN0by5jb20vb3NzLzIwMjAwMi8yNy8zMjUzNjFhMDc1NzFmZDE3N2M4YjBhMzcyM2Y1YzBmMS5wbmc?x-oss-process=image/format,png\" width=\"40%\"/>\n\n\n<ul>\n<li>证书“常规”页面，是关于该证书的一个笼统介绍，包括签发该证书的 CA 机构、该证书绑定的域名（颁发给）、证书有效期。</li>\n<li>证书“详细信息”页面，以键值对形式展示了这张证书的完整内容。（后文将详细介绍证书内容）</li>\n<li>证书的“证书路径”，以层级结构展示了从该证书绑定的域名一直到根证书的路径，这就是证书链。（后文会展开介绍证书链）</li>\n</ul>\n<p><strong>主体的必要信息</strong>：版本(version)、序列号(serialNumber)、签名算法(signatureAlgorithm)、颁发者(issuer)、有效期(validity)、使用者(subject)、公钥信息(subjectPublicKeyInfo)</p>\n<p>主体的扩展信息(extension)：如密钥标识符、证书策略等</p>\n<p>数字签名(signature)，也称指纹</p>\n<p>抽象为下图：<br><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly9zNS41MWN0by5jb20vb3NzLzIwMjAwMi8yNy9jNGIyNzAxMjY5MmMyNWI4NTYxOWEwMTdmMmMxNTE4Zi5qcGctd2hfNjAweC1zXzM3MzQxNzQwMjguanBn?x-oss-process=image/format,png\" width=\"40%\"/></p>\n<h2 id=\"2、-为什么是数字证书呢？\"><a href=\"#2、-为什么是数字证书呢？\" class=\"headerlink\" title=\"2、 为什么是数字证书呢？\"></a><strong>2、 为什么是数字证书呢？</strong></h2><p>HTTPS 已经对通信数据进行了加密，为什么还要验证身份？说好的“人与人之间最基本的信任呢？”</p>\n<p>这还不是因为各路黑客、骇客们总是在制造各种攻击吗？其中一个大名鼎鼎的中间人攻击（Man-In-The-Middle Attack，MITM 攻击），简单的讲，“中间人”在客户端和服务端都不知情的情况下，夹在双方之间窃听甚至篡改通信信息，过程见下图（图引自《HTTPS 中间人攻击实践（原理·实践）》）：</p>\n<p><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly9zMi41MWN0by5jb20vb3NzLzIwMjAwMi8yNy9hZjM2OGQ1NTMxZWVlMGY4YmVkNzZiMzZjMmM3ODM5YS5qcGctd2hfNjAweC1zXzg4NTk5MDkzNy5qcGc?x-oss-process=image/format,png\"><br>在 HTTPS 的握手阶段，一端向对端发送请求，对端返回自己的公钥；而一端未验证对方的身份和公钥，直接协商密钥。“中间人”看到了这个漏洞，夹在中间截获了对端的公钥，替换成了自己的公钥。正是这步“拿错了公钥”或者说“信错了对端”，使得 HTTPS 为加密（密钥协商的非对称加密和通信数据的对称加密）所做的努力全部泡汤。</p>\n<p>可见，在 HTTPS 中，“确保对端身份正确”即“确保拿到的公钥正确”，而在网络通信中所谓的“身份”，一般指的是通信一端的域名、IP 地址甚至是Mac 地址。所以，数字证书同时包含了通信一端的身份信息和公钥信息。</p>\n<p>但是数字证书会在网络中传输（由被要求验证身份的一端通过网络传给另一端），这就意味着证书也可能会被窃取篡改。这个时候权威的 CA 机构就出马了，他想了个办法：<strong>加了一个“防伪标识”— 数字签名</strong>。具体做法如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">signature = RSA(PriKey_CA, Hash(message))</span><br></pre></td></tr></table></figure>\n\n<p>这里啰嗦几句：数字签名生成过程是首先对原文作哈希，把一段不定长的文本映射成固定长度的字符空间，接着再用 CA 机构的私钥对这段定长字符做加密。大大提高了整体的运算效率。</p>\n<h2 id=\"3-证书是怎么工作的？\"><a href=\"#3-证书是怎么工作的？\" class=\"headerlink\" title=\"3 证书是怎么工作的？\"></a><strong>3 证书是怎么工作的？</strong></h2><p>要了解证书是怎么做“身份验证”，即“防冒充”，得从 2 个角度来说明：</p>\n<p><strong>申请证书，即需要被验证身份的一端，需要申请一份能够验证自己身份的证书<br>验证证书，即需要验证对方身份的一端，拿到证书后验证对端的身份</strong></p>\n<p>请注意，这里有一个前提：<strong>这张证书必须是由权威 CA 机构颁发的，且尚在有效期内；或者是一张信任的私人证书。</strong></p>\n<p><strong>申请证书</strong></p>\n<p>CA 机构和证书的分类本文不讨论，推荐阅读《细说 CA 和证书》，这里我们讨论正规权威 CA 机构签发的证书，至于是 DV、OV 还是 EV，只是安全强度问题，工作原理是一样的。</p>\n<p>总结申请证书的过程：用户向 CA 机构提交自己的信息（如域名）和公钥（用户自己生成的非对称加密公钥，用于 TLS 握手阶段和另一端协商密钥用），CA 机构生成数字证书，如下图：</p>\n<p><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly9zNC41MWN0by5jb20vb3NzLzIwMjAwMi8yNy9lZTAwNzljNjc5ZDRiMmFkMzU4OWZkYjFhYTljOTRlOS5qcGctd2hfNjAweC1zXzI4ODM4MTIzNDcuanBn?x-oss-process=image/format,png\"><br><strong>验证证书</strong></p>\n<p>收到对端发过来的证书，执行证书申请的“逆过程”即可，总结如下图：<br><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly9zMy41MWN0by5jb20vb3NzLzIwMjAwMi8yNy83ZGNlNGVmM2M2NTVlNzgxOWUwZjQwNWI3Yzk2OTY4Ny5qcGctd2hfNjAweC1zXzEyNjMwOTQwNDQuanBn?x-oss-process=image/format,png\"></p>\n<p>接受证书的一端先对除数签名的其他部分做一次相同的哈希算法（证书中指明了哈希算法），得到这段文本的哈希映射，记作 H1；获取 CA 机构的公钥对数字签名属性做解码，得到了 CA 机构计算出的哈希映射，记作 H2。对比 H1 和 H2 两个字符串是否严格相等，若是，代表该证书的信息未被篡改，证书有效；否则，证书内容被篡改，证书无效。</p>\n<p>若证书有效，接受端会再进行对端的身份校验（验证域名），若身份验证通过，接收端会拿证书上的公钥（也是对端自己生产的非对称加密公钥）加密接下来整个 TLS 握手阶段的信息之后，发送给对端。</p>\n<p>这个过程中有一个问题：<strong>CA 机构的公钥怎么获取？</strong></p>\n<p>回答：<strong>提前内置</strong>。</p>\n<p>众所周知，操作系统和浏览器在软件安装阶段会在其特定目录下放置一堆的证书。如 Windows 的根证书管理在 certmgr 下：</p>\n<p><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly9zNS41MWN0by5jb20vb3NzLzIwMjAwMi8yNy8xZjNmZDMyNzQ0NTQ5ZjFiYmJmNzhkZDUxOTU0MmZjMC5qcGctd2hfNjAweC1zXzE3MjQwODczOTUuanBn?x-oss-process=image/format,png\"><br>这些证书都有个特点：权威 CA 机构发布的根证书（Root Certificate）。根证书有几个特点：</p>\n<p><strong>没有上层机构再为其本身作数字签名</strong></p>\n<p><strong>证书上的公钥即为 CA 机构发布的公钥</strong></p>\n<p><strong>权威 CA 机构的自签证书</strong></p>\n<p>而这些根证书会跟很多软件，包括操作系统、浏览器一起被安装到用户设备上。即使没有被提前安装好，这些根证书也可以在 CA 机构的官网上获取得到。</p>\n<p>目前全球大型权威 CA 机构有 Symantec、GeoTrust、Comodo 以及 RapidSSL 等，并且这些机构颁发的 SSL 数字证书，在市场的占有率是非常的高。（节选自《SSL 证书颁发机构有哪些》）</p>\n<p>本地被内置了这么多的根证书，那要怎么知道我这份证书应该要用哪一个根证书来验证呢？</p>\n<p>回答：<strong>证书信任链</strong>。</p>\n<p>在信任链上有 3 类证书：<strong>根证书，中介证书和用户证书</strong>。根证书前文已有说明，用户证书就是对端发过来的证书，或者说是用户向权威 CA 机构绑定了自己身份（主要指域名）和自己公钥的证书。中介证书可以理解由权威 CA 机构委派的代理机构签发的数字证书，推荐阅读《What is an intermediate certificate?》。中介证书或者说是中介机构的存在是为了保证根证书的密钥的安全性。</p>\n<p>细心的同学仔细看一看 certmgr 会发现有一个分类是“中间证书颁发机构”，这里存放的就是中介证书。用户证书绝大多数是通过权威的 CA 机构的代理中介机构颁发。</p>\n<p>这么来说，根据对端发来的用户证书寻找对应的根证书岂不是更困难了？</p>\n<p>自问自答：这是一个在树形数据结构中，从叶子节点搜索根节点的过程，直接一个最原始的深搜（DFS）不就可以了嘛？举例说明，如下图（引自Wikipedia-Chain of trust）：<br><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly9zNS41MWN0by5jb20vb3NzLzIwMjAwMi8yNy9lZGI0YjkwZWI0NGQzMjkyNDYwNGJiZDEzNzNiZjViZS5qcGctd2hfNjAweC1zXzM2MzkzNTg1MTkuanBn?x-oss-process=image/format,png\" alt=\"在这里插入图片描述\"></p>\n<p>从用户证书开始。</p>\n<p>记“Issuer”字段的值为 i1，搜索本地证书，寻找由“Subject”为 i1 的证书。</p>\n<p>若没有找到，结束返回证书无效；否则，跳到步骤 4)。</p>\n<p>判断该证书的 Issuer 值是否等于 Subject 值。</p>\n<p>若是，则该证书是根证书，结束返回该证书；否则跳到步骤 6)。</p>\n<p>以该证书开始，跳转 2)（继续搜索）。</p>\n<p>更多关于信任链的知识点，推荐阅读《What is the SSL Certificate Chain?》</p>\n<h2 id=\"4、证书怎么样？\"><a href=\"#4、证书怎么样？\" class=\"headerlink\" title=\"4、证书怎么样？\"></a>4、证书怎么样？</h2><p>相信不少同学或多或少接触过证书文件，比如.pem、.crt、.cer、.key 等，于是问题就来了：</p>\n<p>“为什么有这么多不同后缀名的证书啊？他们有什么联系和区别？”</p>\n<p>回答这个问题要从 3 个层面来分析：</p>\n<p><strong>证书标准</strong></p>\n<p><strong>证书编码格式</strong></p>\n<p><strong>文件扩展名</strong></p>\n<p><strong>证书标准</strong></p>\n<p>数字证书的格式普遍采用的是 X.509 国际标准，维基百科对于 X.509 解释如下：</p>\n<blockquote>\n<p>X.509 是密码学里公钥证书的格式标准。X.509 证书已应用在包括 TLS&#x2F;SSL<br>在内的众多网络协议里，同时它也用在很多非在线应用场景里，比如电子签名服务。X.509<br>证书里含有公钥、身份信息（比如网络主机名，组织的名称或个体名称等）和签名信息（可以是证书签发机构 CA<br>的签名，也可以是自签名）。对于一份经由可信的证书签发机构签名或者可以通过其它方式验证的证书，证书的拥有者就可以用证书及相应的私钥来创建安全的通信，对文档进行数字签名。</p>\n</blockquote>\n<p>X.509 是 ITU-T 标准化部门基于他们之前的 ASN.1 定义的一套证书标准。</p>\n<p><strong>证书的编码格式</strong></p>\n<p>X.509 标准的证书文件具有不同的编码格式：PEM 和 DER。</p>\n<ul>\n<li>PEM</li>\n</ul>\n<p>PEM，全称 Privacy Enhanced Mail，以文本格式存储，以 —–BEGIN<br>XXX—–开头、—–END XXX—–结尾，中间内容是 BASE64 编码数据。其文本内容大概如下：</p>\n<p>html —–BEGIN CERTIFICATE—– Base64编码过的证书数据 —–END CERTIFICATE—–</p>\n<p>通常，PEM 格式可以存储公钥、私钥、证书签名请求等数据。查看 PEM 格式证书的信息一般采用如下命令：</p>\n<p>openssl x509 -in xxx.pem -text -noout<br>Apache 和 Nginx 服务器偏向于使用这种编码格式.</p>\n<ul>\n<li>DER</li>\n</ul>\n<p>DER，全称 Distinguished Encoding Rules，以二进制存储，因此文件结构无法直接预览，只能通过如下命令查看：</p>\n<p>html openssl x509 -in xxx.der -inform der -text -noout</p>\n<p>DER 格式也可以存储公钥、私钥、证书签名请求等数据。Java 和 Windows 应用偏向于使用这种编码格式。</p>\n<p>当然同一 X.509 证书的不同编码之间可以互相转换：</p>\n<ul>\n<li>PEM 转为 DER：</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">openssl x509 -in xxx.pem -outform der -out xxx.der</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>DER 转为 PEM：</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">openssl x509 -in xxx.der -inform der -outform pem -out xxx.pem</span><br></pre></td></tr></table></figure>\n\n<p><strong>文件扩展名</strong></p>\n<p>不同的扩展名可以分为以下几类：</p>\n<ul>\n<li>证书：</li>\n</ul>\n<p>存放数字证书，X.509 标准，格式可能是 PEM 或 DER。.crt、.cer</p>\n<ul>\n<li>密钥：</li>\n</ul>\n<p>用来存放一个 RSA 公钥或私钥，这类文件不是 X.509 标准，但是是 PEM 或 DER 格式。后缀名有.key。</p>\n<ul>\n<li>证书+密钥：</li>\n</ul>\n<p>可同时存放证书和 RSA 公钥&#x2F;.pem、.der、.p12</p>\n<ul>\n<li>证书请求：</li>\n</ul>\n<p>并不是证书，而是证书签名请求。csr</p>\n","categories":[],"tags":[{"name":"Https","slug":"Https","api":"api/tags/Https.json"}],"api":"api/posts/2020/03/04/Https之HTTPS-的证书.json"},{"title":"想统计自己总共提交了多少行代码？","slug":"想统计自己总共提交了多少行代码？","date":"2020-03-02T03:01:00.000Z","updated":"2025-05-20T11:46:57.000Z","comments":true,"url":"2020/03/02/想统计自己总共提交了多少行代码？/","excerpt":"<p>作为一名程序员，我们很想知道自己到底提交了多少行代码到远程仓库，有没有什么工具能够帮我们统计自己写过的代码行数呢？答案是有的。</p>\n<p>这是本次实现的最终效果:</p>\n<img width=\"60%\" src=\"https://cdn.julis.wang/blog/img/20200301170230101.png\">\n\n<h2 id=\"统计代码行数的方式\"><a href=\"#统计代码行数的方式\" class=\"headerlink\" title=\"统计代码行数的方式\"></a>统计代码行数的方式</h2><p>对于代码提交行数统计，通过git 的系统命令就能做到，如下代码所示</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">git <span class=\"built_in\">log</span> --author=<span class=\"string\">&#x27;username&#x27;</span> --pretty=tformat: --numstat | awk <span class=\"string\">&#x27;</span></span><br><span class=\"line\"><span class=\"string\">    &#123;add += $1; subs += $2; loc += $1 - $2 &#125; END &#123; printf &quot;添加了%s,删除了%s,合计%s\\n&quot;, add, subs, loc &#125;&#x27;</span> -</span><br><span class=\"line\">\t</span><br></pre></td></tr></table></figure>\n\n<p>只需要在如下命令输入自己的username就行了，效果如图所示·</p>\n<img src=\"https://cdn.julis.wang/blog/img/20200301170616289.png\">\n\n<p>但是有的人由于环境原因，为了区分一些环境，比如办公司叫：username.office 在家的电脑上叫做: user.home 诸如此类，难道得手动一个一个统计么？当然不行了。</p>\n<p>众所周知，由于工程项目变得更越来越大，拆库也说见不鲜，于是自己的代码分布不同的项目工程，我们想要利用git的统计命令的话就有点吃力了，需要一个一个地进入相应目录进行命令输入？当然不行了。</p>\n<p>今天自己写了一份脚本主要用于统计分布在某个文件夹下所有的代码提交行数，git开源地址：<a href=\"https://github.com/VomPom/ForFun\">https://github.com/VomPom/ForFun</a>源码如下</p>\n<p>如何使用？</p>\n<p>0、将自己需要统计的项目文件目录整理到一个文件夹</p>\n<p>1、讲users_name换成自己的的用户名</p>\n<p>2、由于文件夹下可能有一些例外的不需要统计，添加该文件夹名</p>\n<p>3、讲该shell脚本移动到某个名录下</p>\n<p>4、最后利用 sh codeLine.sh 执行命令</p>\n<img width=\"60%\" src=\"https://cdn.julis.wang/blog/img/20200301171856190.png\">\n<img width=\"60%\" src=\"https://cdn.julis.wang/blog/img/20200301172119336.png\">\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">########################################################</span></span><br><span class=\"line\"><span class=\"comment\">#</span></span><br><span class=\"line\"><span class=\"comment\"># Created by https://julis.wang on 2020/02/28</span></span><br><span class=\"line\"><span class=\"comment\">#</span></span><br><span class=\"line\"><span class=\"comment\"># Description : 统计代码提交行数</span></span><br><span class=\"line\"><span class=\"comment\">#</span></span><br><span class=\"line\"><span class=\"comment\">########################################################</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#!/bin/bash</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#这里添加你的git常用用户名。考虑到每个人的账号可能有很多个，所以定义成数组</span></span><br><span class=\"line\">users_name=(<span class=\"string\">&quot;julis&quot;</span> <span class=\"string\">&quot;julis.wang&quot;</span> <span class=\"string\">&quot;julis.wang.hp&quot;</span>)      </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#过滤一些不需要去遍历的文件夹</span></span><br><span class=\"line\">filter_path=(<span class=\"string\">&quot;Backend&quot;</span> <span class=\"string\">&quot;test&quot;</span> <span class=\"string\">&quot;sdk&quot;</span> <span class=\"string\">&quot;fork&quot;</span> <span class=\"string\">&quot;ArProject&quot;</span>)     </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">########################################################</span></span><br><span class=\"line\"><span class=\"comment\"># 以下代码不需动                       </span></span><br><span class=\"line\"><span class=\"comment\">########################################################</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">export</span> index=0             \t\t\t<span class=\"comment\">#记录当前的位置</span></span><br><span class=\"line\"><span class=\"built_in\">export</span> add_line_count=0             <span class=\"comment\">#添加的line总行数</span></span><br><span class=\"line\"><span class=\"built_in\">export</span> remove_line_count=0          <span class=\"comment\">#删除的总行数</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">export</span> array_git_repositories=()    <span class=\"comment\">#用于记录仓库名</span></span><br><span class=\"line\"><span class=\"built_in\">export</span> add_code=()                  <span class=\"comment\">#记录所有用户对某个库的添加的行数</span></span><br><span class=\"line\"><span class=\"built_in\">export</span> remove_code=()               <span class=\"comment\">#记录所有用户对某个库的删除的行数</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#判断是否需要过滤该目录</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"function\"><span class=\"title\">is_fileter_dir</span></span>() &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"string\">&quot;<span class=\"variable\">$&#123;!filter_path[@]&#125;</span>&quot;</span>; <span class=\"keyword\">do</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> [ <span class=\"variable\">$1</span> == <span class=\"string\">&quot;<span class=\"variable\">$&#123;filter_path[$i]&#125;</span>&quot;</span> ]; <span class=\"keyword\">then</span></span><br><span class=\"line\">\t\t\t<span class=\"built_in\">return</span> 1</span><br><span class=\"line\">\t\t<span class=\"keyword\">fi</span></span><br><span class=\"line\">\t<span class=\"keyword\">done</span></span><br><span class=\"line\">\t<span class=\"built_in\">return</span> 0</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">#对命令执行的返回值进行数据切割</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"function\"><span class=\"title\">get_add_remove_count</span></span>() &#123;</span><br><span class=\"line\">\tstring=<span class=\"variable\">$1</span></span><br><span class=\"line\">\tarray=(<span class=\"variable\">$&#123;string//,/ &#125;</span>)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> [ ! <span class=\"variable\">$&#123;array[0]&#125;</span> ]; <span class=\"keyword\">then</span></span><br><span class=\"line\">  \t\tadd_line=0</span><br><span class=\"line\">\t<span class=\"keyword\">else</span></span><br><span class=\"line\">  \t\tadd_line=<span class=\"variable\">$&#123;array[0]&#125;</span></span><br><span class=\"line\">\t<span class=\"keyword\">fi</span></span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> [ ! <span class=\"variable\">$&#123;array[1]&#125;</span> ]; <span class=\"keyword\">then</span></span><br><span class=\"line\">  \t\tremove_line=0</span><br><span class=\"line\">\t<span class=\"keyword\">else</span></span><br><span class=\"line\">  \t\tremove_line=<span class=\"variable\">$&#123;array[1]&#125;</span></span><br><span class=\"line\">\t<span class=\"keyword\">fi</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> [ ! <span class=\"variable\">$&#123;add_code[$index]&#125;</span> ]; <span class=\"keyword\">then</span></span><br><span class=\"line\">  \t\tadd_code[<span class=\"variable\">$index</span>]=0</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"keyword\">fi</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> [ ! <span class=\"variable\">$&#123;remove_code[$index]&#125;</span> ]; <span class=\"keyword\">then</span></span><br><span class=\"line\">  \t\tremove_code[<span class=\"variable\">$index</span>]=0</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"keyword\">fi</span></span><br><span class=\"line\">\tremove_code[<span class=\"variable\">$index</span>]=`<span class=\"built_in\">expr</span> <span class=\"variable\">$&#123;remove_code[$index]&#125;</span> + <span class=\"variable\">$remove_line</span>`</span><br><span class=\"line\">\tadd_code[<span class=\"variable\">$index</span>]=`<span class=\"built_in\">expr</span> <span class=\"variable\">$&#123;add_code[$index]&#125;</span> + <span class=\"variable\">$add_line</span>`</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">echo</span> <span class=\"string\">&quot;用户&quot;</span><span class=\"variable\">$2</span><span class=\"string\">&quot;添加了=&quot;</span><span class=\"variable\">$add_line</span><span class=\"string\">&quot;行 删除了&quot;</span><span class=\"variable\">$add_line</span><span class=\"string\">&quot;行&quot;</span></span><br><span class=\"line\">\t</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">#获取该用户在该文件夹下的提交代码数</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"function\"><span class=\"title\">get_user_line</span></span>() &#123;</span><br><span class=\"line\">\t<span class=\"comment\"># output分别去接收 该文件夹下的提交以及删除行数</span></span><br><span class=\"line\">\toutput=$(git <span class=\"built_in\">log</span> --author=<span class=\"variable\">$&#123;1&#125;</span> --pretty=tformat: --numstat | awk <span class=\"string\">&#x27;</span></span><br><span class=\"line\"><span class=\"string\">    &#123;add += $1; subs += $2; loc += $1 - $2 &#125; END &#123; printf &quot;添加了%s,删除了%s,合计%s\\n&quot;, add, subs, loc &#125;&#x27;</span> -)</span><br><span class=\"line\">\tget_add_remove_count <span class=\"variable\">$output</span> <span class=\"variable\">$&#123;1&#125;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#遍历每个用户名</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"function\"><span class=\"title\">trans_every_user</span></span>() &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"string\">&quot;<span class=\"variable\">$&#123;!users_name[@]&#125;</span>&quot;</span>; <span class=\"keyword\">do</span></span><br><span class=\"line\">\t\tget_user_line <span class=\"string\">&quot;<span class=\"variable\">$&#123;users_name[$i]&#125;</span>&quot;</span></span><br><span class=\"line\">\t<span class=\"keyword\">done</span></span><br><span class=\"line\">\t<span class=\"built_in\">cd</span> ..</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 整体流程，从文件夹出发</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> path <span class=\"keyword\">in</span> `<span class=\"built_in\">ls</span> -l $(<span class=\"built_in\">dirname</span> <span class=\"variable\">$0</span>)|awk -F <span class=\"string\">&quot; &quot;</span> <span class=\"string\">&#x27;&#123;print $9&#125;&#x27;</span>`</span><br><span class=\"line\"><span class=\"keyword\">do</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> [ -d <span class=\"variable\">$path</span> ]</span><br><span class=\"line\">    <span class=\"keyword\">then</span></span><br><span class=\"line\">        is_fileter_dir <span class=\"variable\">$path</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> [ $? == 1 ]</span><br><span class=\"line\">        <span class=\"keyword\">then</span></span><br><span class=\"line\">            <span class=\"built_in\">echo</span> <span class=\"string\">&quot;&lt;=========过滤了【&quot;</span><span class=\"variable\">$path</span><span class=\"string\">&quot;】======&gt;&quot;</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">            <span class=\"built_in\">echo</span> <span class=\"string\">&quot;&lt;=========获取【&quot;</span><span class=\"variable\">$path</span><span class=\"string\">&quot;】的Git代码提交数据======&gt;&quot;</span></span><br><span class=\"line\">\t\t\tindex=<span class=\"variable\">$&#123;#array_git_repositories[@]&#125;</span> <span class=\"comment\">#用于记录当前在第几个文件夹下处理</span></span><br><span class=\"line\">            array_git_repositories=(<span class=\"variable\">$&#123;array_git_repositories[@]&#125;</span> <span class=\"variable\">$path</span>)</span><br><span class=\"line\">\t\t\t</span><br><span class=\"line\">            <span class=\"built_in\">cd</span> <span class=\"variable\">$path</span></span><br><span class=\"line\">            trans_every_user</span><br><span class=\"line\">        <span class=\"keyword\">fi</span></span><br><span class=\"line\">    <span class=\"keyword\">fi</span></span><br><span class=\"line\"><span class=\"keyword\">done</span></span><br><span class=\"line\">all_add_line=0</span><br><span class=\"line\">all_remove_line=0</span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&#x27;===============================================================================&#x27;</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&quot;                  本次共统计了【&quot;</span><span class=\"variable\">$&#123;#array_git_repositories[@]&#125;</span><span class=\"string\">&quot;】个仓库   by julis.wang      &quot;</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&#x27;===============================================================================&#x27;</span></span><br><span class=\"line\"><span class=\"built_in\">printf</span> <span class=\"string\">&quot;%-30s %10s %10s %10s\\n&quot;</span> <span class=\"string\">&quot;Folder&quot;</span> <span class=\"string\">&quot;Add&quot;</span> <span class=\"string\">&quot;Remove&quot;</span> <span class=\"string\">&quot;All&quot;</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&#x27;-------------------------------------------------------------------------------&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> ((i=<span class=\"number\">0</span>;i&lt;<span class=\"variable\">$&#123;#array_git_repositories[@]&#125;</span>;i++))</span><br><span class=\"line\"><span class=\"keyword\">do</span></span><br><span class=\"line\">\tall_add_line=`<span class=\"built_in\">expr</span> <span class=\"variable\">$all_add_line</span> + <span class=\"variable\">$&#123;add_code[$i]&#125;</span>`</span><br><span class=\"line\">\tall_remove_line=`<span class=\"built_in\">expr</span> <span class=\"variable\">$all_remove_line</span> + <span class=\"variable\">$&#123;remove_code[$i]&#125;</span>`</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span> <span class=\"string\">&quot;%-30s %10s %10s %10s\\n&quot;</span> <span class=\"variable\">$&#123;array_git_repositories[$i]&#125;</span> <span class=\"variable\">$&#123;add_code[$i]&#125;</span> <span class=\"variable\">$&#123;remove_code[$i]&#125;</span> `<span class=\"built_in\">expr</span> <span class=\"variable\">$&#123;add_code[$i]&#125;</span> - <span class=\"variable\">$&#123;remove_code[$i]&#125;</span>`</span><br><span class=\"line\"><span class=\"keyword\">done</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&#x27;-------------------------------------------------------------------------------&#x27;</span></span><br><span class=\"line\"><span class=\"built_in\">printf</span> <span class=\"string\">&quot;%-30s %10s %10s %10s\\n&quot;</span> <span class=\"string\">&quot;Total&quot;</span> <span class=\"variable\">$all_add_line</span> <span class=\"variable\">$all_remove_line</span> `<span class=\"built_in\">expr</span> <span class=\"variable\">$all_add_line</span> - <span class=\"variable\">$all_remove_line</span>`</span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&#x27;===============================================================================&#x27;</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>写在最后：<br>由于本人不太擅长编写shell脚本，所有其中的代码实现方式可能比较粗糙，望理解。</p>\n","cover":null,"images":["https://cdn.julis.wang/blog/img/20200301170230101.png","https://cdn.julis.wang/blog/img/20200301170616289.png","https://cdn.julis.wang/blog/img/20200301171856190.png","https://cdn.julis.wang/blog/img/20200301172119336.png"],"content":"<p>作为一名程序员，我们很想知道自己到底提交了多少行代码到远程仓库，有没有什么工具能够帮我们统计自己写过的代码行数呢？答案是有的。</p>\n<p>这是本次实现的最终效果:</p>\n<img width=\"60%\" src=\"https://cdn.julis.wang/blog/img/20200301170230101.png\">\n\n<h2 id=\"统计代码行数的方式\"><a href=\"#统计代码行数的方式\" class=\"headerlink\" title=\"统计代码行数的方式\"></a>统计代码行数的方式</h2><p>对于代码提交行数统计，通过git 的系统命令就能做到，如下代码所示</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">git <span class=\"built_in\">log</span> --author=<span class=\"string\">&#x27;username&#x27;</span> --pretty=tformat: --numstat | awk <span class=\"string\">&#x27;</span></span><br><span class=\"line\"><span class=\"string\">    &#123;add += $1; subs += $2; loc += $1 - $2 &#125; END &#123; printf &quot;添加了%s,删除了%s,合计%s\\n&quot;, add, subs, loc &#125;&#x27;</span> -</span><br><span class=\"line\">\t</span><br></pre></td></tr></table></figure>\n\n<p>只需要在如下命令输入自己的username就行了，效果如图所示·</p>\n<img src=\"https://cdn.julis.wang/blog/img/20200301170616289.png\">\n\n<p>但是有的人由于环境原因，为了区分一些环境，比如办公司叫：username.office 在家的电脑上叫做: user.home 诸如此类，难道得手动一个一个统计么？当然不行了。</p>\n<p>众所周知，由于工程项目变得更越来越大，拆库也说见不鲜，于是自己的代码分布不同的项目工程，我们想要利用git的统计命令的话就有点吃力了，需要一个一个地进入相应目录进行命令输入？当然不行了。</p>\n<p>今天自己写了一份脚本主要用于统计分布在某个文件夹下所有的代码提交行数，git开源地址：<a href=\"https://github.com/VomPom/ForFun\">https://github.com/VomPom/ForFun</a>源码如下</p>\n<p>如何使用？</p>\n<p>0、将自己需要统计的项目文件目录整理到一个文件夹</p>\n<p>1、讲users_name换成自己的的用户名</p>\n<p>2、由于文件夹下可能有一些例外的不需要统计，添加该文件夹名</p>\n<p>3、讲该shell脚本移动到某个名录下</p>\n<p>4、最后利用 sh codeLine.sh 执行命令</p>\n<img width=\"60%\" src=\"https://cdn.julis.wang/blog/img/20200301171856190.png\">\n<img width=\"60%\" src=\"https://cdn.julis.wang/blog/img/20200301172119336.png\">\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">########################################################</span></span><br><span class=\"line\"><span class=\"comment\">#</span></span><br><span class=\"line\"><span class=\"comment\"># Created by https://julis.wang on 2020/02/28</span></span><br><span class=\"line\"><span class=\"comment\">#</span></span><br><span class=\"line\"><span class=\"comment\"># Description : 统计代码提交行数</span></span><br><span class=\"line\"><span class=\"comment\">#</span></span><br><span class=\"line\"><span class=\"comment\">########################################################</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#!/bin/bash</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#这里添加你的git常用用户名。考虑到每个人的账号可能有很多个，所以定义成数组</span></span><br><span class=\"line\">users_name=(<span class=\"string\">&quot;julis&quot;</span> <span class=\"string\">&quot;julis.wang&quot;</span> <span class=\"string\">&quot;julis.wang.hp&quot;</span>)      </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#过滤一些不需要去遍历的文件夹</span></span><br><span class=\"line\">filter_path=(<span class=\"string\">&quot;Backend&quot;</span> <span class=\"string\">&quot;test&quot;</span> <span class=\"string\">&quot;sdk&quot;</span> <span class=\"string\">&quot;fork&quot;</span> <span class=\"string\">&quot;ArProject&quot;</span>)     </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">########################################################</span></span><br><span class=\"line\"><span class=\"comment\"># 以下代码不需动                       </span></span><br><span class=\"line\"><span class=\"comment\">########################################################</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">export</span> index=0             \t\t\t<span class=\"comment\">#记录当前的位置</span></span><br><span class=\"line\"><span class=\"built_in\">export</span> add_line_count=0             <span class=\"comment\">#添加的line总行数</span></span><br><span class=\"line\"><span class=\"built_in\">export</span> remove_line_count=0          <span class=\"comment\">#删除的总行数</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">export</span> array_git_repositories=()    <span class=\"comment\">#用于记录仓库名</span></span><br><span class=\"line\"><span class=\"built_in\">export</span> add_code=()                  <span class=\"comment\">#记录所有用户对某个库的添加的行数</span></span><br><span class=\"line\"><span class=\"built_in\">export</span> remove_code=()               <span class=\"comment\">#记录所有用户对某个库的删除的行数</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#判断是否需要过滤该目录</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"function\"><span class=\"title\">is_fileter_dir</span></span>() &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"string\">&quot;<span class=\"variable\">$&#123;!filter_path[@]&#125;</span>&quot;</span>; <span class=\"keyword\">do</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> [ <span class=\"variable\">$1</span> == <span class=\"string\">&quot;<span class=\"variable\">$&#123;filter_path[$i]&#125;</span>&quot;</span> ]; <span class=\"keyword\">then</span></span><br><span class=\"line\">\t\t\t<span class=\"built_in\">return</span> 1</span><br><span class=\"line\">\t\t<span class=\"keyword\">fi</span></span><br><span class=\"line\">\t<span class=\"keyword\">done</span></span><br><span class=\"line\">\t<span class=\"built_in\">return</span> 0</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">#对命令执行的返回值进行数据切割</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"function\"><span class=\"title\">get_add_remove_count</span></span>() &#123;</span><br><span class=\"line\">\tstring=<span class=\"variable\">$1</span></span><br><span class=\"line\">\tarray=(<span class=\"variable\">$&#123;string//,/ &#125;</span>)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> [ ! <span class=\"variable\">$&#123;array[0]&#125;</span> ]; <span class=\"keyword\">then</span></span><br><span class=\"line\">  \t\tadd_line=0</span><br><span class=\"line\">\t<span class=\"keyword\">else</span></span><br><span class=\"line\">  \t\tadd_line=<span class=\"variable\">$&#123;array[0]&#125;</span></span><br><span class=\"line\">\t<span class=\"keyword\">fi</span></span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> [ ! <span class=\"variable\">$&#123;array[1]&#125;</span> ]; <span class=\"keyword\">then</span></span><br><span class=\"line\">  \t\tremove_line=0</span><br><span class=\"line\">\t<span class=\"keyword\">else</span></span><br><span class=\"line\">  \t\tremove_line=<span class=\"variable\">$&#123;array[1]&#125;</span></span><br><span class=\"line\">\t<span class=\"keyword\">fi</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> [ ! <span class=\"variable\">$&#123;add_code[$index]&#125;</span> ]; <span class=\"keyword\">then</span></span><br><span class=\"line\">  \t\tadd_code[<span class=\"variable\">$index</span>]=0</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"keyword\">fi</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> [ ! <span class=\"variable\">$&#123;remove_code[$index]&#125;</span> ]; <span class=\"keyword\">then</span></span><br><span class=\"line\">  \t\tremove_code[<span class=\"variable\">$index</span>]=0</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"keyword\">fi</span></span><br><span class=\"line\">\tremove_code[<span class=\"variable\">$index</span>]=`<span class=\"built_in\">expr</span> <span class=\"variable\">$&#123;remove_code[$index]&#125;</span> + <span class=\"variable\">$remove_line</span>`</span><br><span class=\"line\">\tadd_code[<span class=\"variable\">$index</span>]=`<span class=\"built_in\">expr</span> <span class=\"variable\">$&#123;add_code[$index]&#125;</span> + <span class=\"variable\">$add_line</span>`</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">echo</span> <span class=\"string\">&quot;用户&quot;</span><span class=\"variable\">$2</span><span class=\"string\">&quot;添加了=&quot;</span><span class=\"variable\">$add_line</span><span class=\"string\">&quot;行 删除了&quot;</span><span class=\"variable\">$add_line</span><span class=\"string\">&quot;行&quot;</span></span><br><span class=\"line\">\t</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">#获取该用户在该文件夹下的提交代码数</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"function\"><span class=\"title\">get_user_line</span></span>() &#123;</span><br><span class=\"line\">\t<span class=\"comment\"># output分别去接收 该文件夹下的提交以及删除行数</span></span><br><span class=\"line\">\toutput=$(git <span class=\"built_in\">log</span> --author=<span class=\"variable\">$&#123;1&#125;</span> --pretty=tformat: --numstat | awk <span class=\"string\">&#x27;</span></span><br><span class=\"line\"><span class=\"string\">    &#123;add += $1; subs += $2; loc += $1 - $2 &#125; END &#123; printf &quot;添加了%s,删除了%s,合计%s\\n&quot;, add, subs, loc &#125;&#x27;</span> -)</span><br><span class=\"line\">\tget_add_remove_count <span class=\"variable\">$output</span> <span class=\"variable\">$&#123;1&#125;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#遍历每个用户名</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"function\"><span class=\"title\">trans_every_user</span></span>() &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"string\">&quot;<span class=\"variable\">$&#123;!users_name[@]&#125;</span>&quot;</span>; <span class=\"keyword\">do</span></span><br><span class=\"line\">\t\tget_user_line <span class=\"string\">&quot;<span class=\"variable\">$&#123;users_name[$i]&#125;</span>&quot;</span></span><br><span class=\"line\">\t<span class=\"keyword\">done</span></span><br><span class=\"line\">\t<span class=\"built_in\">cd</span> ..</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 整体流程，从文件夹出发</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> path <span class=\"keyword\">in</span> `<span class=\"built_in\">ls</span> -l $(<span class=\"built_in\">dirname</span> <span class=\"variable\">$0</span>)|awk -F <span class=\"string\">&quot; &quot;</span> <span class=\"string\">&#x27;&#123;print $9&#125;&#x27;</span>`</span><br><span class=\"line\"><span class=\"keyword\">do</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> [ -d <span class=\"variable\">$path</span> ]</span><br><span class=\"line\">    <span class=\"keyword\">then</span></span><br><span class=\"line\">        is_fileter_dir <span class=\"variable\">$path</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> [ $? == 1 ]</span><br><span class=\"line\">        <span class=\"keyword\">then</span></span><br><span class=\"line\">            <span class=\"built_in\">echo</span> <span class=\"string\">&quot;&lt;=========过滤了【&quot;</span><span class=\"variable\">$path</span><span class=\"string\">&quot;】======&gt;&quot;</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">            <span class=\"built_in\">echo</span> <span class=\"string\">&quot;&lt;=========获取【&quot;</span><span class=\"variable\">$path</span><span class=\"string\">&quot;】的Git代码提交数据======&gt;&quot;</span></span><br><span class=\"line\">\t\t\tindex=<span class=\"variable\">$&#123;#array_git_repositories[@]&#125;</span> <span class=\"comment\">#用于记录当前在第几个文件夹下处理</span></span><br><span class=\"line\">            array_git_repositories=(<span class=\"variable\">$&#123;array_git_repositories[@]&#125;</span> <span class=\"variable\">$path</span>)</span><br><span class=\"line\">\t\t\t</span><br><span class=\"line\">            <span class=\"built_in\">cd</span> <span class=\"variable\">$path</span></span><br><span class=\"line\">            trans_every_user</span><br><span class=\"line\">        <span class=\"keyword\">fi</span></span><br><span class=\"line\">    <span class=\"keyword\">fi</span></span><br><span class=\"line\"><span class=\"keyword\">done</span></span><br><span class=\"line\">all_add_line=0</span><br><span class=\"line\">all_remove_line=0</span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&#x27;===============================================================================&#x27;</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&quot;                  本次共统计了【&quot;</span><span class=\"variable\">$&#123;#array_git_repositories[@]&#125;</span><span class=\"string\">&quot;】个仓库   by julis.wang      &quot;</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&#x27;===============================================================================&#x27;</span></span><br><span class=\"line\"><span class=\"built_in\">printf</span> <span class=\"string\">&quot;%-30s %10s %10s %10s\\n&quot;</span> <span class=\"string\">&quot;Folder&quot;</span> <span class=\"string\">&quot;Add&quot;</span> <span class=\"string\">&quot;Remove&quot;</span> <span class=\"string\">&quot;All&quot;</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&#x27;-------------------------------------------------------------------------------&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> ((i=<span class=\"number\">0</span>;i&lt;<span class=\"variable\">$&#123;#array_git_repositories[@]&#125;</span>;i++))</span><br><span class=\"line\"><span class=\"keyword\">do</span></span><br><span class=\"line\">\tall_add_line=`<span class=\"built_in\">expr</span> <span class=\"variable\">$all_add_line</span> + <span class=\"variable\">$&#123;add_code[$i]&#125;</span>`</span><br><span class=\"line\">\tall_remove_line=`<span class=\"built_in\">expr</span> <span class=\"variable\">$all_remove_line</span> + <span class=\"variable\">$&#123;remove_code[$i]&#125;</span>`</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span> <span class=\"string\">&quot;%-30s %10s %10s %10s\\n&quot;</span> <span class=\"variable\">$&#123;array_git_repositories[$i]&#125;</span> <span class=\"variable\">$&#123;add_code[$i]&#125;</span> <span class=\"variable\">$&#123;remove_code[$i]&#125;</span> `<span class=\"built_in\">expr</span> <span class=\"variable\">$&#123;add_code[$i]&#125;</span> - <span class=\"variable\">$&#123;remove_code[$i]&#125;</span>`</span><br><span class=\"line\"><span class=\"keyword\">done</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&#x27;-------------------------------------------------------------------------------&#x27;</span></span><br><span class=\"line\"><span class=\"built_in\">printf</span> <span class=\"string\">&quot;%-30s %10s %10s %10s\\n&quot;</span> <span class=\"string\">&quot;Total&quot;</span> <span class=\"variable\">$all_add_line</span> <span class=\"variable\">$all_remove_line</span> `<span class=\"built_in\">expr</span> <span class=\"variable\">$all_add_line</span> - <span class=\"variable\">$all_remove_line</span>`</span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&#x27;===============================================================================&#x27;</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>写在最后：<br>由于本人不太擅长编写shell脚本，所有其中的代码实现方式可能比较粗糙，望理解。</p>\n","categories":[{"name":"技术文章","slug":"technology","api":"api/categories/technology.json"}],"tags":[{"name":"Shell","slug":"Shell","api":"api/tags/Shell.json"}],"api":"api/posts/2020/03/02/想统计自己总共提交了多少行代码？.json"},{"title":"致二零一九","slug":"致二零一九","date":"2019-12-31T15:59:00.000Z","updated":"2025-05-20T11:46:57.000Z","comments":true,"url":"2019/12/31/致二零一九/","excerpt":"<p>   告别了二零一九，迎来了二零二零，”二零二零”真的是一个很陌生的词，邓小平在四十年前提出的口号：“全面建设成小康社会”，而如今已经到了这个节点，我与大多数人一样，其实都对“小康”没有一个很明确的理解，亦不知道现在是否可以定义为“小康社会”。然而这并不重要，这并不是我该去研究探索的实物，毕竟人人都有自己的“小康”目标。<br>  已经挥手告别了二零一九，在此做一个年度的总结吧。</p>\n<p>  二零一九或许给人最大的改变，那就是身份的改变吧，结束了长达十六年的学校学生的身份，成为了一名社会人，也拥有了自己的职业称呼–Android开发工程师。很荣幸，我选择了我自己所感兴趣的行业进行了就业，在初高中就萌发出来的对于编程相关的兴趣，是我从事此行业的动力，我并不感到厌倦；也很荣幸，我加入了一家很不错的的公司，并没有像其他互联网公司进行压榨的“996”，也没有无休止地加班，跟随了一个很不错的师傅，教会了我很多很多……我很感激；也很荣幸，我不再是一名学生，但是我也并没有忘记学习，今年学习了很多，也读了很多书：</p>\n<p>二零一九我完成了一次毕业旅行，至今依然还能记得青岛“静听海浪拍岸，坐看海天一色”，烟台那种天际辽阔无垠感。也与朋友去了趟武汉，感受到了武汉的生机活力。望明年能够去更多的城市去体会更多的不同。</p>\n<p>二零一九我依然完成了很多自己的年初设置的目标：</p>\n<p>1、坚持写日记</p>\n<p>2、去现场看五场足球比赛</p>\n<p>3、学习一门外语（日语）</p>\n<p>4、技术博客数不少于10篇</p>\n<p>5、体重控制在70kg以内</p>\n<p>6、看至少十部电影</p>\n<p>……</p>\n<p>时间的流逝带来了很多的东西，也让人丢掉了很多东西。几个月前，我买了一个ps4游戏机，希望找回童年那时的那种快乐，可是很难……我并不能静下心来去做这样一件事，也没有那种儿时花大精力去探索去钻研游戏的各个细节，一个游戏能重复玩个很多遍也不腻味。儿时面对着黑白电视机，像素点十分明显的游戏能够没日没夜的玩着，甚至到了吃饭也不愿意去，即便现在拥有了更华丽更丰富的画面，更好的游戏体验，可是它也并没有一局短暂的Dota游戏带来快感更划算。难道是说游戏不好玩么？不是的，是那颗心已经没有了吧……</p>\n<p>二零一九，一直是一个人，发现自己变得更自卑些了，亦或是害怕了。害怕去打破那样的宁静，害怕自己不够优秀。总是低着头，甚至不敢抬头看一眼，可我也很想抬起头来，也期待着”只愿君心似我心，定不负相思意”。</p>\n<p>然而生活总是要继续的吧，还有很多很多的美好等着自己。</p>\n<p>二零二零，又是一个新的年代，望向远方吧！</p>\n","cover":null,"images":[],"content":"<p>   告别了二零一九，迎来了二零二零，”二零二零”真的是一个很陌生的词，邓小平在四十年前提出的口号：“全面建设成小康社会”，而如今已经到了这个节点，我与大多数人一样，其实都对“小康”没有一个很明确的理解，亦不知道现在是否可以定义为“小康社会”。然而这并不重要，这并不是我该去研究探索的实物，毕竟人人都有自己的“小康”目标。<br>  已经挥手告别了二零一九，在此做一个年度的总结吧。</p>\n<p>  二零一九或许给人最大的改变，那就是身份的改变吧，结束了长达十六年的学校学生的身份，成为了一名社会人，也拥有了自己的职业称呼–Android开发工程师。很荣幸，我选择了我自己所感兴趣的行业进行了就业，在初高中就萌发出来的对于编程相关的兴趣，是我从事此行业的动力，我并不感到厌倦；也很荣幸，我加入了一家很不错的的公司，并没有像其他互联网公司进行压榨的“996”，也没有无休止地加班，跟随了一个很不错的师傅，教会了我很多很多……我很感激；也很荣幸，我不再是一名学生，但是我也并没有忘记学习，今年学习了很多，也读了很多书：</p>\n<p>二零一九我完成了一次毕业旅行，至今依然还能记得青岛“静听海浪拍岸，坐看海天一色”，烟台那种天际辽阔无垠感。也与朋友去了趟武汉，感受到了武汉的生机活力。望明年能够去更多的城市去体会更多的不同。</p>\n<p>二零一九我依然完成了很多自己的年初设置的目标：</p>\n<p>1、坚持写日记</p>\n<p>2、去现场看五场足球比赛</p>\n<p>3、学习一门外语（日语）</p>\n<p>4、技术博客数不少于10篇</p>\n<p>5、体重控制在70kg以内</p>\n<p>6、看至少十部电影</p>\n<p>……</p>\n<p>时间的流逝带来了很多的东西，也让人丢掉了很多东西。几个月前，我买了一个ps4游戏机，希望找回童年那时的那种快乐，可是很难……我并不能静下心来去做这样一件事，也没有那种儿时花大精力去探索去钻研游戏的各个细节，一个游戏能重复玩个很多遍也不腻味。儿时面对着黑白电视机，像素点十分明显的游戏能够没日没夜的玩着，甚至到了吃饭也不愿意去，即便现在拥有了更华丽更丰富的画面，更好的游戏体验，可是它也并没有一局短暂的Dota游戏带来快感更划算。难道是说游戏不好玩么？不是的，是那颗心已经没有了吧……</p>\n<p>二零一九，一直是一个人，发现自己变得更自卑些了，亦或是害怕了。害怕去打破那样的宁静，害怕自己不够优秀。总是低着头，甚至不敢抬头看一眼，可我也很想抬起头来，也期待着”只愿君心似我心，定不负相思意”。</p>\n<p>然而生活总是要继续的吧，还有很多很多的美好等着自己。</p>\n<p>二零二零，又是一个新的年代，望向远方吧！</p>\n","categories":[{"name":"生活感想","slug":"life","api":"api/categories/life.json"}],"tags":[{"name":"省","slug":"thinking","api":"api/tags/thinking.json"}],"api":"api/posts/2019/12/31/致二零一九.json"},{"title":"从奶酪夹心饼干生产中来学习Android 中的gradle构建","slug":"从奶酪夹心饼干生产中来学习Android-中的gradle","date":"2019-12-18T11:48:00.000Z","updated":"2025-05-20T11:46:57.000Z","comments":true,"url":"2019/12/18/从奶酪夹心饼干生产中来学习Android-中的gradle/","excerpt":"<p>最近终于有机会做一些关于Android plugin相关的东西，之前虽然有学习过<code>《Android 权威指南》</code>一书，但是并没有进行一个实战操作，都是一些理论相关的学习。最近做了一个plugin主要是为了提取class文件里面的注解信息然后讲起搜集并上传。在实践中回过头发现很多知识都已经遗忘，所以本文对相关一些比较核心的知识进行一个回顾与梳理。</p>\n<h2 id=\"一、Gradle概述\"><a href=\"#一、Gradle概述\" class=\"headerlink\" title=\"一、Gradle概述\"></a>一、Gradle概述</h2><img src=\"https://cdn.julis.wang/blog/img/20191218190829347.png\">\n\n<p>在Android开发中，Gradle是每个开发者都会接触的，Gradle 是一个非常优秀的项目构建工具。这是大家都知道的，但是又有啥用呢？</p>\n<p>最开始的时候很难理解gradle到底是干什么的，相关知识都比较离散，所以很多东西没有串起来，从而导致理解起来比较困难。</p>\n<p>我自己总结就是：<strong>Gradle是一个构建工具，它存在的目的是产生一套“流水线”，对于安卓开发而言这个流水线就是从本地的编写代码以及资源整合到最终生成的产品过程。</strong></p>\n<p>用一个很形象的例子举例，我们现在要生产一包奶酪夹心饼干，于是我们得定义一个生产顺序：先让有的地方去生成饼干，有的地方生成出来奶酪，之后再让两块饼干夹着一块奶酪，最后再将它们装进一个小包装袋里面。</p>\n<p>另一种情况：如果我想在奶酪中加一点果酱，那么我们不需要重新建立一套生产线，只需要在两块饼干与奶酪结合的过程中修改一下加入果酱的流程。</p>\n<p>再另一种情况：如果我生产出来的奶酪夹心饼干不需要包装，那只需要在最后一个步骤让它另外走一条线路，毕竟没有包装的又不是不能吃，对吧？</p>\n<img src=\"https://cdn.julis.wang/blog/img/20191218143302953.png\">\n<p>如上图所示，我们定义了三种流程，每种流程最后的产出物是不一样的，因为流程的“<strong>初始化</strong>”的东西是不一样的以及过程中的“<strong>配置</strong>”，所以“<strong>执行</strong>”的时候就不一样。</p>\n<p>对比我们安卓开发：本地的Java文件以及资源文件就是对应的饼干以及奶酪，最终生成的面向用户的apk文件就是包装好的奶酪夹心饼干。</p>\n<p>如果我们想打Debug包，那么就像是一个散装的饼干，我们能自己用用，但是还不能面向用户，如果想打Release包那么就是最终的产品形态能直接面向用户。</p>\n<p>上面的例子讲得比较长，其实主要想让更多人能够更好地去理解gradle的用处。</p>\n<p>当我们每次点击Android Studio的 run运行按钮之后，会看到控制台输出一大堆相关日志，例如下图所示：</p>\n<img width=\"60%\" src=\"https://cdn.julis.wang/blog/img/20191218110343253.png\">\n\n<p>其实这些都是系统为我们封装好的一些task<br>点击 run 按钮，就相当于执行了一次 Gradle Task，一般来说，是Task <code>assembleDebug</code>或者Task <code>assembleRelease</code></p>\n<p>Gradle是目前Android主流的构建工具，无论通过命令行还是通过AndroidStudio来build，最终都是通过Gradle来实现的。以及Android领域的探索已经越来越深，不少技术领域如插件化、热修复、构建系统等都对Gradle有相关的需要。</p>\n<h2 id=\"二、Groovy\"><a href=\"#二、Groovy\" class=\"headerlink\" title=\"二、Groovy\"></a>二、Groovy</h2><p>知道了Gradle的用处之后，我们很形象的知道Gradle是为了去产生一个流水线。那这个流水线是利用什么做到的呢？对于奶酪饼干生产的工厂他们是不同的车间机械工具直接的逻辑组装。而对于Gradle则是利用<code>groovy</code>语言编写出来的相关脚本从而来进行一个编译相关的配置。这里不再具体描述groovy语言的具体用法，这里我列举出来几个自己认为比较重要的几个技术点。</p>\n<p><strong>1、Closure（闭包）</strong><br><code>闭包</code>是的groovy语言具有，而Java语言不具有的特性，有人说Lambda表达式就是闭包，但是两则还是有一定的差异的，有兴趣的同学可以去看看这篇<a href=\"https://editor.csdn.net/md/?articleId=102466814\">Java中Lambda表达式解析</a></p>\n<p>定义闭的语意 ：</p>\n<blockquote>\n<p><strong>{ [closureParameters -&gt; ] statements }</strong></p>\n</blockquote>\n<p>其中<code>[closureParameters-&gt;]</code>代表参数，多参数用逗号分割，用<code>-&gt;</code>隔开参数与内容，没有参数可以不写<code>-&gt;</code>例如我们精彩在.gradle文件里面看到这样的内容：</p>\n<img src=\"https://cdn.julis.wang/blog/img/20191218150133412.png\">\n\n<p>其中<code>projcet</code>就是<code>[closureParameters-&gt;]</code>，<code>-&gt;</code>之后的<code>respositories</code>就是statements，对于这段代码而言，statements里面又是一个闭包，如果改写成Java的样子就更形象了：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> <span class=\"title function_\">subprojercts</span><span class=\"params\">(Project projct)</span> &#123;</span><br><span class=\"line\">\tdoSomething....</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<p><strong>2、方法的输入参数优化</strong><br>groovy中定义的函数，如果至少有一个参数，在调用的时候可以省略括号。比如这样</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">def <span class=\"title function_\">func</span><span class=\"params\">(String a)</span>&#123;</span><br><span class=\"line\">  println(a)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">func &#x27;hello&#x27;</span><br></pre></td></tr></table></figure>\n<p>在gradle有大量省略括号调用函数的例子，比如</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">defaultConfig &#123;</span><br><span class=\"line\">        minSdkVersion rootProject.ext.minSdkVersion</span><br><span class=\"line\">        targetSdkVersion rootProject.targetSdkVersion</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>比如这里minSdkVersion 和 targetSdkVersion 其实就是调用了两个函数,传入了不同的参数，在AndroidStudio里面可以点进去查看函数实现</p>\n<p>当然如果某个函数没有参数，那就不能省略括号，否则会当成一个变量使用</p>\n<p><strong>3、类的Property</strong></p>\n<p>如果类的成员变量没有加任何权限访问，则称为<code>Property</code>, 否则是<code>Field</code>，filed和Java中的成员变量相同，但是<code>Property</code>的话，它是一个private field和getter setter的集合，也就是说groovy会自动生成getter setter方法，因此在类外面的代码，都是会透明的调用getter和setter方法。</p>\n<p><strong>4、Trait</strong></p>\n<p>特性使用关键字 trait 声明，可以拥有普通成员和抽象成员。例如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">trait MessageHandler &#123;</span><br><span class=\"line\">    <span class=\"comment\">//  属性</span></span><br><span class=\"line\">    <span class=\"type\">int</span> minLenght</span><br><span class=\"line\">    <span class=\"comment\">//  方法</span></span><br><span class=\"line\">    <span class=\"comment\">//  普通方法</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span> <span class=\"title function_\">echo</span><span class=\"params\">(String msg)</span> &#123;</span><br><span class=\"line\">        println(msg)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//  抽象方法</span></span><br><span class=\"line\">    <span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title function_\">show</span><span class=\"params\">(String msg)</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">trait AnotherMessageHandler &#123;</span><br><span class=\"line\">    <span class=\"comment\">//  抽象方法</span></span><br><span class=\"line\">    <span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title function_\">show</span><span class=\"params\">(String msg)</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Message</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">AnotherMessageHandler</span>, MessageHandler &#123;</span><br><span class=\"line\">.......</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Groovy 中特质本质上是运行时对接口的实现，所以其方法的访问控制符只支持 public 和 private。从代码的书写可以看出来<code>trait</code>又像java中的<code>abstract</code>类又像<code>interface</code>。<br>说他像<code>interface</code>是因为从编写上看就是使用了<code>implements</code>关键字，但是接口又不能使用普通方法。说他像抽象类，因为其内部使用了<code>abstract</code>定义抽象方法。但是它又能<code>implements</code>多个，而达到“多继承”的特性。因此它不是接口，也不是抽象类，它是 <code>trait</code>。</p>\n<h2 id=\"三、Gradle的依赖\"><a href=\"#三、Gradle的依赖\" class=\"headerlink\" title=\"三、Gradle的依赖\"></a>三、Gradle的依赖</h2><p>我们继续回到上面奶酪夹心饼干的生产上面，在产出奶酪夹心饼干之前，我们需要分别生产好单独的饼干与奶酪。假如我们的饼干原料有很多种，姑且我们叫他饼干v1，饼干v2……饼干vn ，奶酪也有很多种，我们叫它奶酪v1，奶酪v2……奶酪vn。那这么多种具体生产起来就应该有相关的选择，在Android开发中各种库都被单独抽了出来，只需要单独声明出来需要用哪个库即可。</p>\n<p>我们平时看的的<code>dependencies</code>如下所示</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">dependencies &#123;</span><br><span class=\"line\">    implementation <span class=\"title function_\">fileTree</span><span class=\"params\">(dir: <span class=\"string\">&#x27;libs&#x27;</span>, include: [<span class=\"string\">&#x27;*.jar&#x27;</span>])</span></span><br><span class=\"line\">    implementation <span class=\"string\">&#x27;com.android.support:appcompat-v7:28.0.0&#x27;</span></span><br><span class=\"line\">    implementation <span class=\"string\">&#x27;com.victor:lib:1.0.4&#x27;</span></span><br><span class=\"line\">    api <span class=\"string\">&#x27;com.android.support:recyclerview-v7:28.0.0&#x27;</span></span><br><span class=\"line\">    implementation <span class=\"string\">&#x27;com.google.code.gson:gson:2.8.6&#x27;</span></span><br><span class=\"line\">    implementation(<span class=\"string\">&#x27;com.wanjian:sak:0.1.0&#x27;</span>) &#123;</span><br><span class=\"line\">        exclude group: <span class=\"string\">&#x27;com.android.support&#x27;</span>, <span class=\"keyword\">module</span>: <span class=\"string\">&#x27;appcompat-v7&#x27;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>1、依赖配置</strong><br>Gradle依赖的配置中主要使用以下关键字，摘自<a href=\"https://developer.android.com/studio/build/dependencies?hl=zh-cn\">谷歌官方Gradle文档-&gt;添加编译依赖项</a></p>\n<p><strong>implementation</strong><br>Gradle 会将依赖项添加到编译类路径，并将依赖项打包到编译输出。不过，当您的模块配置 implementation 依赖项时，会让 Gradle 了解您不希望该模块在编译时将该依赖项泄露给其他模块。也就是说，其他模块只有在运行时才能使用该依赖项。</p>\n<p><strong>api</strong><br>Gradle 会将依赖项添加到编译类路径和编译输出。当一个模块包含 api 依赖项时，会让 Gradle 了解该模块要以传递方式将该依赖项导出到其他模块，以便这些模块在运行时和编译时都可以使用该依赖项</p>\n<p><strong>annotationProcessor</strong><br>要添加对作为注解处理器的库的依赖关系，您必须使用 annotationProcessor 配置将其添加到注解处理器类路径。这是因为，使用此配置可以将编译类路径与注解处理器类路径分开，从而提高编译性能。如果 Gradle 在编译类路径上找到注解处理器，则会禁用避免编译功能，这样会对编译时间产生负面影响（Gradle 5.0 及更高版本会忽略在编译类路径上找到的注解处理器）。</p>\n<p><strong>2、依赖的传递与冲突</strong><br>\t在Maven仓库中，构件通过POM（一种XML文件）来描述相关信息以及传递性依赖。Gradle 可以通过分析该文件获取获取所以依赖以及依赖的依赖和依赖的依赖的依赖，为了更加直观的表述，可以通过下面的输出结果了解。\n\t</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">+--- com.github.hotchemi:permissionsdispatcher:<span class=\"number\">2.2</span><span class=\"number\">.0</span></span><br><span class=\"line\">|    \\--- com.android.support:support-v4:<span class=\"number\">23.1</span><span class=\"number\">.1</span> -&gt; <span class=\"number\">28.0</span><span class=\"number\">.0</span></span><br><span class=\"line\">|         +--- com.android.support:support-compat:<span class=\"number\">28.0</span><span class=\"number\">.0</span></span><br><span class=\"line\">|         |    +--- com.android.support:support-annotations:<span class=\"number\">28.0</span><span class=\"number\">.0</span></span><br><span class=\"line\">|         |    +--- com.android.support:collections:<span class=\"number\">28.0</span><span class=\"number\">.0</span></span><br><span class=\"line\">|         |    |    \\--- com.android.support:support-annotations:<span class=\"number\">28.0</span><span class=\"number\">.0</span></span><br><span class=\"line\">|         |    +--- android.arch.lifecycle:runtime:<span class=\"number\">1.1</span><span class=\"number\">.1</span></span><br><span class=\"line\">|         |    |    +--- android.arch.lifecycle:common:<span class=\"number\">1.1</span><span class=\"number\">.1</span></span><br><span class=\"line\">|         |    |    |    \\--- com.android.support:support-annotations:<span class=\"number\">26.1</span><span class=\"number\">.0</span> -&gt; <span class=\"number\">28.0</span><span class=\"number\">.0</span></span><br><span class=\"line\">|         |    |    +--- android.arch.core:common:<span class=\"number\">1.1</span><span class=\"number\">.1</span></span><br><span class=\"line\">|         |    |    |    \\--- com.android.support:support-annotations:<span class=\"number\">26.1</span><span class=\"number\">.0</span> -&gt; <span class=\"number\">28.0</span><span class=\"number\">.0</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>我依赖hotchemi:permissionsdispatcher这个库，而它内部又陆陆续续地依赖了后面的一大堆。借助Gradle的传递性依赖特性，你无需再你的脚本中把这些依赖都声明一遍，你只需要简单的一行，Gradle便会帮你将传递性依赖一起下载下来。</p>\n<p>然而问题来了这里面依赖了：<code>android.arch.core:common:1.1.1</code>  而我本地其他地方又使用了<code>android.arch.core:common:1.0.0</code>老版本。那我该如何去做这件事呢？</p>\n<p>于是便有了如下关键词：<br><strong>exclude<br>force<br>transitive</strong></p>\n<p>具体作用如下代码所示</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">implementation (<span class=\"string\">&#x27;com.google.code.gson:gson:2.8.6&#x27;</span>) &#123;</span><br><span class=\"line\">    force = <span class=\"literal\">true</span> <span class=\"comment\">//强制使用这个版本的库</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">implementation (<span class=\"string\">&#x27;de.hdodenhof:circleimageview:3.0.1&#x27;</span>) &#123;</span><br><span class=\"line\">    transitive = <span class=\"literal\">true</span> <span class=\"comment\">//防止向外暴露</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">implementation(<span class=\"string\">&#x27;com.wanjian:sak:0.1.0&#x27;</span>) &#123;</span><br><span class=\"line\">    exclude group: <span class=\"string\">&#x27;com.android.support&#x27;</span>, <span class=\"keyword\">module</span>: <span class=\"string\">&#x27;appcompat-v7&#x27;</span> <span class=\"comment\">//排除里面不需要的库</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"四、Gradle的Task构建与执行\"><a href=\"#四、Gradle的Task构建与执行\" class=\"headerlink\" title=\"四、Gradle的Task构建与执行\"></a>四、Gradle的Task构建与执行</h2><p>再回到生产饼干的例子上面来，最开始我们定义了一些流程，然后再让机器以该流程去执行。</p>\n<p>比如先准备两块饼干再与奶酪进行加工生成夹心饼干，最后再加入包装。这是一条正确的流水，我们不可能让加入包装在加工生成夹心饼干之前。于是我们得定义一些约束，让其有正确的执行顺序。或者我们像加入果酱，那么就应该对原始的流程进行一些添加。</p>\n<p>对于Gradle中，我们以Task为单位，类比生产奶酪饼干，生成饼干是一个专门的Task，生成奶酪也是一个专门的Task，加工成夹心也是一个Task……对于Android开发，将java文件编译为class，再到最后的dex生成都是Task</p>\n<p>在Task的构建与执行中主要分为三个流程：</p>\n<p><strong>初始化（Initialization）</strong><br>settings.gradle确定参与构建的module<br>为每个module创建Project对象实例</p>\n<p><strong>配置（Configuration ）</strong><br>build.gradle脚本执行，配置对应project实例<br>创建有向无环图<br>通过finalizedBy指定后续<br>通过must&#x2F;shouldRunAfter约束执行顺序</p>\n<p><strong>执行（Execution ）</strong><br>根据关系图执行task<br>监听器</p>\n<p>主要流程如图所示（图片摘自<a href=\"https://www.jianshu.com/p/0acdb31eef2d\">https://www.jianshu.com/p/0acdb31eef2d</a>）：</p>\n<img src=\"https://cdn.julis.wang/blog/img/20191218190105218.png\">\n\n<h2 id=\"五、Gradle插件\"><a href=\"#五、Gradle插件\" class=\"headerlink\" title=\"五、Gradle插件\"></a>五、Gradle插件</h2><p>继续奶酪夹心饼干的故事，如果夹心饼干模样规规矩矩没有花纹，岂不是很low？于是工厂专门研发了一款能让饼干产生纹路的机器，并在加工成夹心饼干之前将纹路印到饼干上面去，假如这台机器我们把它叫做“印花纹机”，是一个能从整个生产流程中独立的出来的机器，这台“印花纹机”也能用在生产其他的饼干上。</p>\n<p>对应在我们的Android开发中，在构建流程中我们抽离出来一些功能，将其独立开来，这就是plugin，这里不再讲解plugin的编写相关操作，可以参考<a href=\"https://juejin.im/post/5cc5929bf265da036706b350\">Gradle 自定义 plugin</a></p>\n<p><strong>1、插件分类</strong></p>\n<p><strong>脚本插件</strong><br>顾名思义，如下图所示我们将对应的插件脚本中加入相关插件的逻辑，如下图所示，“other.gradle”便是一个插件</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">apply from: <span class=\"string\">&#x27;other.gradle&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>二进制插件</strong><br>二进制插件就是实现了 org.gradle.api.Plugin 接口的插件，每个 Java Gradle 插件都有一个 plugin id，可以通过如下方式使用一个 Java 插件：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">apply plugin : <span class=\"string\">&#x27;maven&#x27;</span></span><br></pre></td></tr></table></figure>\n<p>通过上述代码就将 Java 插件应用到我们的项目中了，其中 <code>maven</code> 是 Java 插件的 plugin id，对于 Gradle 自带的核心插件都有唯一的 plugin id</p>\n<p><strong>2、打包方式</strong><br>\t\t\t<br><strong>build script</strong><br>在插件分类中我们提到有<code>apply from: &#39;other.gradle&#39;</code> 其中<code>other.gradle</code>就是一个打包好的build script</p>\n<p><strong>buildSrc</strong><br>将插件写在工程根目录下的buildSrc目录下，这样可以在多个模块之间复用该插件。<br>buildSrc是Gradle在项目中配置自定义插件的默认目录，但它并不是标准的Android工程目录，所以使用这种方式需要我们事先手动创建一个buildSrc目录</p>\n<img width=\"60%\" src=\"https://cdn.julis.wang/blog/img/20191218194223783.png\">\n\n<p><strong>独立项目</strong>\t<br>创建独立的插件项目具有更强的灵活性，能让更多的工程使用这个插件，但流程也会相对复杂一点.这里不再具体讲解，可以参考<a href=\"https://juejin.im/post/5cc5929bf265da036706b350\">Gradle 自定义 plugin</a></p>\n<p>参考资料：</p>\n<p><a href=\"https://www.jianshu.com/p/6dc2074480b8\">https://www.jianshu.com/p/6dc2074480b8</a><br><a href=\"https://www.jianshu.com/p/bcaf9a269d96\">https://www.jianshu.com/p/bcaf9a269d96</a><br><a href=\"https://juejin.im/entry/59918304518825489151732d\">https://juejin.im/entry/59918304518825489151732d</a><br><a href=\"https://www.jianshu.com/p/0acdb31eef2d\">https://www.jianshu.com/p/0acdb31eef2d</a><br><a href=\"https://juejin.im/post/5cc5929bf265da036706b350\">https://juejin.im/post/5cc5929bf265da036706b350</a><br><a href=\"https://doc.yonyoucloud.com/doc/wiki/project/GradleUserGuide-Wiki/gradle_plugins/binary_plugins.html\">https://doc.yonyoucloud.com/doc/wiki/project/GradleUserGuide-Wiki/gradle_plugins/binary_plugins.html</a></p>\n","cover":null,"images":["https://cdn.julis.wang/blog/img/20191218190829347.png","https://cdn.julis.wang/blog/img/20191218143302953.png","https://cdn.julis.wang/blog/img/20191218110343253.png","https://cdn.julis.wang/blog/img/20191218150133412.png","https://cdn.julis.wang/blog/img/20191218190105218.png","https://cdn.julis.wang/blog/img/20191218194223783.png"],"content":"<p>最近终于有机会做一些关于Android plugin相关的东西，之前虽然有学习过<code>《Android 权威指南》</code>一书，但是并没有进行一个实战操作，都是一些理论相关的学习。最近做了一个plugin主要是为了提取class文件里面的注解信息然后讲起搜集并上传。在实践中回过头发现很多知识都已经遗忘，所以本文对相关一些比较核心的知识进行一个回顾与梳理。</p>\n<h2 id=\"一、Gradle概述\"><a href=\"#一、Gradle概述\" class=\"headerlink\" title=\"一、Gradle概述\"></a>一、Gradle概述</h2><img src=\"https://cdn.julis.wang/blog/img/20191218190829347.png\">\n\n<p>在Android开发中，Gradle是每个开发者都会接触的，Gradle 是一个非常优秀的项目构建工具。这是大家都知道的，但是又有啥用呢？</p>\n<p>最开始的时候很难理解gradle到底是干什么的，相关知识都比较离散，所以很多东西没有串起来，从而导致理解起来比较困难。</p>\n<p>我自己总结就是：<strong>Gradle是一个构建工具，它存在的目的是产生一套“流水线”，对于安卓开发而言这个流水线就是从本地的编写代码以及资源整合到最终生成的产品过程。</strong></p>\n<p>用一个很形象的例子举例，我们现在要生产一包奶酪夹心饼干，于是我们得定义一个生产顺序：先让有的地方去生成饼干，有的地方生成出来奶酪，之后再让两块饼干夹着一块奶酪，最后再将它们装进一个小包装袋里面。</p>\n<p>另一种情况：如果我想在奶酪中加一点果酱，那么我们不需要重新建立一套生产线，只需要在两块饼干与奶酪结合的过程中修改一下加入果酱的流程。</p>\n<p>再另一种情况：如果我生产出来的奶酪夹心饼干不需要包装，那只需要在最后一个步骤让它另外走一条线路，毕竟没有包装的又不是不能吃，对吧？</p>\n<img src=\"https://cdn.julis.wang/blog/img/20191218143302953.png\">\n<p>如上图所示，我们定义了三种流程，每种流程最后的产出物是不一样的，因为流程的“<strong>初始化</strong>”的东西是不一样的以及过程中的“<strong>配置</strong>”，所以“<strong>执行</strong>”的时候就不一样。</p>\n<p>对比我们安卓开发：本地的Java文件以及资源文件就是对应的饼干以及奶酪，最终生成的面向用户的apk文件就是包装好的奶酪夹心饼干。</p>\n<p>如果我们想打Debug包，那么就像是一个散装的饼干，我们能自己用用，但是还不能面向用户，如果想打Release包那么就是最终的产品形态能直接面向用户。</p>\n<p>上面的例子讲得比较长，其实主要想让更多人能够更好地去理解gradle的用处。</p>\n<p>当我们每次点击Android Studio的 run运行按钮之后，会看到控制台输出一大堆相关日志，例如下图所示：</p>\n<img width=\"60%\" src=\"https://cdn.julis.wang/blog/img/20191218110343253.png\">\n\n<p>其实这些都是系统为我们封装好的一些task<br>点击 run 按钮，就相当于执行了一次 Gradle Task，一般来说，是Task <code>assembleDebug</code>或者Task <code>assembleRelease</code></p>\n<p>Gradle是目前Android主流的构建工具，无论通过命令行还是通过AndroidStudio来build，最终都是通过Gradle来实现的。以及Android领域的探索已经越来越深，不少技术领域如插件化、热修复、构建系统等都对Gradle有相关的需要。</p>\n<h2 id=\"二、Groovy\"><a href=\"#二、Groovy\" class=\"headerlink\" title=\"二、Groovy\"></a>二、Groovy</h2><p>知道了Gradle的用处之后，我们很形象的知道Gradle是为了去产生一个流水线。那这个流水线是利用什么做到的呢？对于奶酪饼干生产的工厂他们是不同的车间机械工具直接的逻辑组装。而对于Gradle则是利用<code>groovy</code>语言编写出来的相关脚本从而来进行一个编译相关的配置。这里不再具体描述groovy语言的具体用法，这里我列举出来几个自己认为比较重要的几个技术点。</p>\n<p><strong>1、Closure（闭包）</strong><br><code>闭包</code>是的groovy语言具有，而Java语言不具有的特性，有人说Lambda表达式就是闭包，但是两则还是有一定的差异的，有兴趣的同学可以去看看这篇<a href=\"https://editor.csdn.net/md/?articleId=102466814\">Java中Lambda表达式解析</a></p>\n<p>定义闭的语意 ：</p>\n<blockquote>\n<p><strong>{ [closureParameters -&gt; ] statements }</strong></p>\n</blockquote>\n<p>其中<code>[closureParameters-&gt;]</code>代表参数，多参数用逗号分割，用<code>-&gt;</code>隔开参数与内容，没有参数可以不写<code>-&gt;</code>例如我们精彩在.gradle文件里面看到这样的内容：</p>\n<img src=\"https://cdn.julis.wang/blog/img/20191218150133412.png\">\n\n<p>其中<code>projcet</code>就是<code>[closureParameters-&gt;]</code>，<code>-&gt;</code>之后的<code>respositories</code>就是statements，对于这段代码而言，statements里面又是一个闭包，如果改写成Java的样子就更形象了：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> <span class=\"title function_\">subprojercts</span><span class=\"params\">(Project projct)</span> &#123;</span><br><span class=\"line\">\tdoSomething....</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<p><strong>2、方法的输入参数优化</strong><br>groovy中定义的函数，如果至少有一个参数，在调用的时候可以省略括号。比如这样</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">def <span class=\"title function_\">func</span><span class=\"params\">(String a)</span>&#123;</span><br><span class=\"line\">  println(a)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">func &#x27;hello&#x27;</span><br></pre></td></tr></table></figure>\n<p>在gradle有大量省略括号调用函数的例子，比如</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">defaultConfig &#123;</span><br><span class=\"line\">        minSdkVersion rootProject.ext.minSdkVersion</span><br><span class=\"line\">        targetSdkVersion rootProject.targetSdkVersion</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>比如这里minSdkVersion 和 targetSdkVersion 其实就是调用了两个函数,传入了不同的参数，在AndroidStudio里面可以点进去查看函数实现</p>\n<p>当然如果某个函数没有参数，那就不能省略括号，否则会当成一个变量使用</p>\n<p><strong>3、类的Property</strong></p>\n<p>如果类的成员变量没有加任何权限访问，则称为<code>Property</code>, 否则是<code>Field</code>，filed和Java中的成员变量相同，但是<code>Property</code>的话，它是一个private field和getter setter的集合，也就是说groovy会自动生成getter setter方法，因此在类外面的代码，都是会透明的调用getter和setter方法。</p>\n<p><strong>4、Trait</strong></p>\n<p>特性使用关键字 trait 声明，可以拥有普通成员和抽象成员。例如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">trait MessageHandler &#123;</span><br><span class=\"line\">    <span class=\"comment\">//  属性</span></span><br><span class=\"line\">    <span class=\"type\">int</span> minLenght</span><br><span class=\"line\">    <span class=\"comment\">//  方法</span></span><br><span class=\"line\">    <span class=\"comment\">//  普通方法</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span> <span class=\"title function_\">echo</span><span class=\"params\">(String msg)</span> &#123;</span><br><span class=\"line\">        println(msg)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//  抽象方法</span></span><br><span class=\"line\">    <span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title function_\">show</span><span class=\"params\">(String msg)</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">trait AnotherMessageHandler &#123;</span><br><span class=\"line\">    <span class=\"comment\">//  抽象方法</span></span><br><span class=\"line\">    <span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title function_\">show</span><span class=\"params\">(String msg)</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Message</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">AnotherMessageHandler</span>, MessageHandler &#123;</span><br><span class=\"line\">.......</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Groovy 中特质本质上是运行时对接口的实现，所以其方法的访问控制符只支持 public 和 private。从代码的书写可以看出来<code>trait</code>又像java中的<code>abstract</code>类又像<code>interface</code>。<br>说他像<code>interface</code>是因为从编写上看就是使用了<code>implements</code>关键字，但是接口又不能使用普通方法。说他像抽象类，因为其内部使用了<code>abstract</code>定义抽象方法。但是它又能<code>implements</code>多个，而达到“多继承”的特性。因此它不是接口，也不是抽象类，它是 <code>trait</code>。</p>\n<h2 id=\"三、Gradle的依赖\"><a href=\"#三、Gradle的依赖\" class=\"headerlink\" title=\"三、Gradle的依赖\"></a>三、Gradle的依赖</h2><p>我们继续回到上面奶酪夹心饼干的生产上面，在产出奶酪夹心饼干之前，我们需要分别生产好单独的饼干与奶酪。假如我们的饼干原料有很多种，姑且我们叫他饼干v1，饼干v2……饼干vn ，奶酪也有很多种，我们叫它奶酪v1，奶酪v2……奶酪vn。那这么多种具体生产起来就应该有相关的选择，在Android开发中各种库都被单独抽了出来，只需要单独声明出来需要用哪个库即可。</p>\n<p>我们平时看的的<code>dependencies</code>如下所示</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">dependencies &#123;</span><br><span class=\"line\">    implementation <span class=\"title function_\">fileTree</span><span class=\"params\">(dir: <span class=\"string\">&#x27;libs&#x27;</span>, include: [<span class=\"string\">&#x27;*.jar&#x27;</span>])</span></span><br><span class=\"line\">    implementation <span class=\"string\">&#x27;com.android.support:appcompat-v7:28.0.0&#x27;</span></span><br><span class=\"line\">    implementation <span class=\"string\">&#x27;com.victor:lib:1.0.4&#x27;</span></span><br><span class=\"line\">    api <span class=\"string\">&#x27;com.android.support:recyclerview-v7:28.0.0&#x27;</span></span><br><span class=\"line\">    implementation <span class=\"string\">&#x27;com.google.code.gson:gson:2.8.6&#x27;</span></span><br><span class=\"line\">    implementation(<span class=\"string\">&#x27;com.wanjian:sak:0.1.0&#x27;</span>) &#123;</span><br><span class=\"line\">        exclude group: <span class=\"string\">&#x27;com.android.support&#x27;</span>, <span class=\"keyword\">module</span>: <span class=\"string\">&#x27;appcompat-v7&#x27;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>1、依赖配置</strong><br>Gradle依赖的配置中主要使用以下关键字，摘自<a href=\"https://developer.android.com/studio/build/dependencies?hl=zh-cn\">谷歌官方Gradle文档-&gt;添加编译依赖项</a></p>\n<p><strong>implementation</strong><br>Gradle 会将依赖项添加到编译类路径，并将依赖项打包到编译输出。不过，当您的模块配置 implementation 依赖项时，会让 Gradle 了解您不希望该模块在编译时将该依赖项泄露给其他模块。也就是说，其他模块只有在运行时才能使用该依赖项。</p>\n<p><strong>api</strong><br>Gradle 会将依赖项添加到编译类路径和编译输出。当一个模块包含 api 依赖项时，会让 Gradle 了解该模块要以传递方式将该依赖项导出到其他模块，以便这些模块在运行时和编译时都可以使用该依赖项</p>\n<p><strong>annotationProcessor</strong><br>要添加对作为注解处理器的库的依赖关系，您必须使用 annotationProcessor 配置将其添加到注解处理器类路径。这是因为，使用此配置可以将编译类路径与注解处理器类路径分开，从而提高编译性能。如果 Gradle 在编译类路径上找到注解处理器，则会禁用避免编译功能，这样会对编译时间产生负面影响（Gradle 5.0 及更高版本会忽略在编译类路径上找到的注解处理器）。</p>\n<p><strong>2、依赖的传递与冲突</strong><br>\t在Maven仓库中，构件通过POM（一种XML文件）来描述相关信息以及传递性依赖。Gradle 可以通过分析该文件获取获取所以依赖以及依赖的依赖和依赖的依赖的依赖，为了更加直观的表述，可以通过下面的输出结果了解。\n\t</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">+--- com.github.hotchemi:permissionsdispatcher:<span class=\"number\">2.2</span><span class=\"number\">.0</span></span><br><span class=\"line\">|    \\--- com.android.support:support-v4:<span class=\"number\">23.1</span><span class=\"number\">.1</span> -&gt; <span class=\"number\">28.0</span><span class=\"number\">.0</span></span><br><span class=\"line\">|         +--- com.android.support:support-compat:<span class=\"number\">28.0</span><span class=\"number\">.0</span></span><br><span class=\"line\">|         |    +--- com.android.support:support-annotations:<span class=\"number\">28.0</span><span class=\"number\">.0</span></span><br><span class=\"line\">|         |    +--- com.android.support:collections:<span class=\"number\">28.0</span><span class=\"number\">.0</span></span><br><span class=\"line\">|         |    |    \\--- com.android.support:support-annotations:<span class=\"number\">28.0</span><span class=\"number\">.0</span></span><br><span class=\"line\">|         |    +--- android.arch.lifecycle:runtime:<span class=\"number\">1.1</span><span class=\"number\">.1</span></span><br><span class=\"line\">|         |    |    +--- android.arch.lifecycle:common:<span class=\"number\">1.1</span><span class=\"number\">.1</span></span><br><span class=\"line\">|         |    |    |    \\--- com.android.support:support-annotations:<span class=\"number\">26.1</span><span class=\"number\">.0</span> -&gt; <span class=\"number\">28.0</span><span class=\"number\">.0</span></span><br><span class=\"line\">|         |    |    +--- android.arch.core:common:<span class=\"number\">1.1</span><span class=\"number\">.1</span></span><br><span class=\"line\">|         |    |    |    \\--- com.android.support:support-annotations:<span class=\"number\">26.1</span><span class=\"number\">.0</span> -&gt; <span class=\"number\">28.0</span><span class=\"number\">.0</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>我依赖hotchemi:permissionsdispatcher这个库，而它内部又陆陆续续地依赖了后面的一大堆。借助Gradle的传递性依赖特性，你无需再你的脚本中把这些依赖都声明一遍，你只需要简单的一行，Gradle便会帮你将传递性依赖一起下载下来。</p>\n<p>然而问题来了这里面依赖了：<code>android.arch.core:common:1.1.1</code>  而我本地其他地方又使用了<code>android.arch.core:common:1.0.0</code>老版本。那我该如何去做这件事呢？</p>\n<p>于是便有了如下关键词：<br><strong>exclude<br>force<br>transitive</strong></p>\n<p>具体作用如下代码所示</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">implementation (<span class=\"string\">&#x27;com.google.code.gson:gson:2.8.6&#x27;</span>) &#123;</span><br><span class=\"line\">    force = <span class=\"literal\">true</span> <span class=\"comment\">//强制使用这个版本的库</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">implementation (<span class=\"string\">&#x27;de.hdodenhof:circleimageview:3.0.1&#x27;</span>) &#123;</span><br><span class=\"line\">    transitive = <span class=\"literal\">true</span> <span class=\"comment\">//防止向外暴露</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">implementation(<span class=\"string\">&#x27;com.wanjian:sak:0.1.0&#x27;</span>) &#123;</span><br><span class=\"line\">    exclude group: <span class=\"string\">&#x27;com.android.support&#x27;</span>, <span class=\"keyword\">module</span>: <span class=\"string\">&#x27;appcompat-v7&#x27;</span> <span class=\"comment\">//排除里面不需要的库</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"四、Gradle的Task构建与执行\"><a href=\"#四、Gradle的Task构建与执行\" class=\"headerlink\" title=\"四、Gradle的Task构建与执行\"></a>四、Gradle的Task构建与执行</h2><p>再回到生产饼干的例子上面来，最开始我们定义了一些流程，然后再让机器以该流程去执行。</p>\n<p>比如先准备两块饼干再与奶酪进行加工生成夹心饼干，最后再加入包装。这是一条正确的流水，我们不可能让加入包装在加工生成夹心饼干之前。于是我们得定义一些约束，让其有正确的执行顺序。或者我们像加入果酱，那么就应该对原始的流程进行一些添加。</p>\n<p>对于Gradle中，我们以Task为单位，类比生产奶酪饼干，生成饼干是一个专门的Task，生成奶酪也是一个专门的Task，加工成夹心也是一个Task……对于Android开发，将java文件编译为class，再到最后的dex生成都是Task</p>\n<p>在Task的构建与执行中主要分为三个流程：</p>\n<p><strong>初始化（Initialization）</strong><br>settings.gradle确定参与构建的module<br>为每个module创建Project对象实例</p>\n<p><strong>配置（Configuration ）</strong><br>build.gradle脚本执行，配置对应project实例<br>创建有向无环图<br>通过finalizedBy指定后续<br>通过must&#x2F;shouldRunAfter约束执行顺序</p>\n<p><strong>执行（Execution ）</strong><br>根据关系图执行task<br>监听器</p>\n<p>主要流程如图所示（图片摘自<a href=\"https://www.jianshu.com/p/0acdb31eef2d\">https://www.jianshu.com/p/0acdb31eef2d</a>）：</p>\n<img src=\"https://cdn.julis.wang/blog/img/20191218190105218.png\">\n\n<h2 id=\"五、Gradle插件\"><a href=\"#五、Gradle插件\" class=\"headerlink\" title=\"五、Gradle插件\"></a>五、Gradle插件</h2><p>继续奶酪夹心饼干的故事，如果夹心饼干模样规规矩矩没有花纹，岂不是很low？于是工厂专门研发了一款能让饼干产生纹路的机器，并在加工成夹心饼干之前将纹路印到饼干上面去，假如这台机器我们把它叫做“印花纹机”，是一个能从整个生产流程中独立的出来的机器，这台“印花纹机”也能用在生产其他的饼干上。</p>\n<p>对应在我们的Android开发中，在构建流程中我们抽离出来一些功能，将其独立开来，这就是plugin，这里不再讲解plugin的编写相关操作，可以参考<a href=\"https://juejin.im/post/5cc5929bf265da036706b350\">Gradle 自定义 plugin</a></p>\n<p><strong>1、插件分类</strong></p>\n<p><strong>脚本插件</strong><br>顾名思义，如下图所示我们将对应的插件脚本中加入相关插件的逻辑，如下图所示，“other.gradle”便是一个插件</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">apply from: <span class=\"string\">&#x27;other.gradle&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>二进制插件</strong><br>二进制插件就是实现了 org.gradle.api.Plugin 接口的插件，每个 Java Gradle 插件都有一个 plugin id，可以通过如下方式使用一个 Java 插件：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">apply plugin : <span class=\"string\">&#x27;maven&#x27;</span></span><br></pre></td></tr></table></figure>\n<p>通过上述代码就将 Java 插件应用到我们的项目中了，其中 <code>maven</code> 是 Java 插件的 plugin id，对于 Gradle 自带的核心插件都有唯一的 plugin id</p>\n<p><strong>2、打包方式</strong><br>\t\t\t<br><strong>build script</strong><br>在插件分类中我们提到有<code>apply from: &#39;other.gradle&#39;</code> 其中<code>other.gradle</code>就是一个打包好的build script</p>\n<p><strong>buildSrc</strong><br>将插件写在工程根目录下的buildSrc目录下，这样可以在多个模块之间复用该插件。<br>buildSrc是Gradle在项目中配置自定义插件的默认目录，但它并不是标准的Android工程目录，所以使用这种方式需要我们事先手动创建一个buildSrc目录</p>\n<img width=\"60%\" src=\"https://cdn.julis.wang/blog/img/20191218194223783.png\">\n\n<p><strong>独立项目</strong>\t<br>创建独立的插件项目具有更强的灵活性，能让更多的工程使用这个插件，但流程也会相对复杂一点.这里不再具体讲解，可以参考<a href=\"https://juejin.im/post/5cc5929bf265da036706b350\">Gradle 自定义 plugin</a></p>\n<p>参考资料：</p>\n<p><a href=\"https://www.jianshu.com/p/6dc2074480b8\">https://www.jianshu.com/p/6dc2074480b8</a><br><a href=\"https://www.jianshu.com/p/bcaf9a269d96\">https://www.jianshu.com/p/bcaf9a269d96</a><br><a href=\"https://juejin.im/entry/59918304518825489151732d\">https://juejin.im/entry/59918304518825489151732d</a><br><a href=\"https://www.jianshu.com/p/0acdb31eef2d\">https://www.jianshu.com/p/0acdb31eef2d</a><br><a href=\"https://juejin.im/post/5cc5929bf265da036706b350\">https://juejin.im/post/5cc5929bf265da036706b350</a><br><a href=\"https://doc.yonyoucloud.com/doc/wiki/project/GradleUserGuide-Wiki/gradle_plugins/binary_plugins.html\">https://doc.yonyoucloud.com/doc/wiki/project/GradleUserGuide-Wiki/gradle_plugins/binary_plugins.html</a></p>\n","categories":[{"name":"技术文章","slug":"technology","api":"api/categories/technology.json"}],"tags":[{"name":"Android","slug":"Android","api":"api/tags/Android.json"}],"api":"api/posts/2019/12/18/从奶酪夹心饼干生产中来学习Android-中的gradle.json"},{"title":"一款快速生成安卓shape的插件--NoCodeShape","slug":"一款快速生成Android-shape的插件-NoCodeShape","date":"2019-11-27T08:06:00.000Z","updated":"2025-05-20T11:46:57.000Z","comments":true,"url":"2019/11/27/一款快速生成Android-shape的插件-NoCodeShape/","excerpt":"<p>NoCodeShape 是一个能可视化界面操作生成Android中Shape.xml的Android Studio插件。对于新手能更好的去接受Android中相对应的属性，对于资深程序员则能简化操作，快速生成shape.xml。项目已经开源 <a href=\"https://github.com/VomPom/NoCodeShape\">NoCodeShape</a></p>\n<h1 id=\"二、NoCodeShape使用方法\"><a href=\"#二、NoCodeShape使用方法\" class=\"headerlink\" title=\"二、NoCodeShape使用方法\"></a>二、NoCodeShape使用方法</h1><h2 id=\"1-下载和安装\"><a href=\"#1-下载和安装\" class=\"headerlink\" title=\"1. 下载和安装\"></a>1. 下载和安装</h2><p>同一般的Android Studio插件下载一样，可以直接<code>Preferences-&gt;Plugins</code> 搜索 <code>NoCodeShape</code>搜索出来结果直接安装再重启即可。</p>\n<img width=\"60%\" src=\"https://cdn.julis.wang/blog/img/20191126190001658.png\">\n<p>也可以去jetbrains插件管理的官网下载各个版本的插件<br><a href=\"https://plugins.jetbrains.com/plugin/13325-nocodeshape/versions\">https://plugins.jetbrains.com/plugin/13325-nocodeshape/versions</a><br>然后<code>Preferences-&gt;Plugins</code> 再Install plugins from disk从本地安装</p>\n<h2 id=\"2-如何使用\"><a href=\"#2-如何使用\" class=\"headerlink\" title=\"2. 如何使用\"></a>2. 如何使用</h2><p>在新建一个shape.xml文件后，右键选择NoCodeShape或者直接按快捷键Common+U</p>\n<img src=\"https://cdn.julis.wang/blog/img/20191126192542676.png\">\n<p>然后选择自己想要的属性，随着点击事件的进行会生成相关xml代码，并在Android Studio右边有对应的shape形状的展示。如果对应shape.xml有相关属性，NoCodeShape也会生成对应shape.xml属性的操作界面，非常方便。<br>示例：</p>\n<img src=\"https://cdn.julis.wang/blog/img/20191126192336117.gif\">\n<h1 id=\"三、实现原理\"><a href=\"#三、实现原理\" class=\"headerlink\" title=\"三、实现原理\"></a>三、实现原理</h1><p>实现原理总体来说并不复杂，主要是界面相关操作逻辑比较繁琐。</p>\n<p>对于新生成的一个shape.xml来说只需要弹出一个新的操作界面，用户只需要点击对应模块的属性即可。项目使用了<code>单例模式+Bulider建造者模式</code>去管理各个Shape属性，分别生成 <code>Shape、Solid、Corners、Stroke、Gradient</code>的单例，其内部拥有一个Builder用来去承各类型的具体属性。</p>\n<p>  通过界面的操作，对其内部的<code>Builder</code>进行数据的填充，最后在完成各类操作后，将各类型中的Builder中的所有属性提取出并生成一份完整的xml字符串并将其粘贴到Android Studio的操作界面上。</p>\n<p>实现主要分为两大类：</p>\n<h2 id=\"1-拼接生成xml字符串\"><a href=\"#1-拼接生成xml字符串\" class=\"headerlink\" title=\"1. 拼接生成xml字符串\"></a>1. 拼接生成xml字符串</h2><p>字符串拼接算是其中最复杂的部分，一是各shape的类型拥有较多数据，其中一些属性有逻辑存在性，二是生成最终Android Studio的xml字符串的时候格式存在比较多的处理。对于各类属性都继承于<code>BaseXml</code>，其内部拥有一个静态内部<code>Builder</code>类，以相对简单的Solid类来举例，如下所示：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Solid</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">BaseXml</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Builder builder;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"type\">Solid</span> <span class=\"variable\">instance</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Solid <span class=\"title function_\">getInstance</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (instance == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            builder = <span class=\"keyword\">new</span> <span class=\"title class_\">Builder</span>();</span><br><span class=\"line\">            instance = <span class=\"keyword\">new</span> <span class=\"title class_\">Solid</span>();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\"> <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Builder</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">BaseBuilder</span> &#123;</span><br><span class=\"line\">        String color;</span><br><span class=\"line\">        String colorValue;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">setColor</span><span class=\"params\">(String color)</span> &#123;</span><br><span class=\"line\">            <span class=\"built_in\">this</span>.colorValue = color;</span><br><span class=\"line\">            <span class=\"built_in\">this</span>.color = getAttrWithOutUnitStr(<span class=\"string\">&quot;color&quot;</span>, color);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"keyword\">public</span> String <span class=\"title function_\">getBuilderString</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> StringUtils.getString(color);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">clearData</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">            StringUtils.clearObjectData(<span class=\"built_in\">this</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">analysisAttribute</span><span class=\"params\">(Attributes attributes)</span> &#123;</span><br><span class=\"line\">            Solid.getInstance().setChecked(<span class=\"literal\">true</span>);</span><br><span class=\"line\">            setColor(attributes.getValue(<span class=\"string\">&quot;android:color&quot;</span>));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>其类继承于抽象类BaseXml，代码如下所示：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">class</span> <span class=\"title class_\">BaseXml</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">boolean</span> <span class=\"variable\">isChecked</span> <span class=\"operator\">=</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">getCloser</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot; /&gt;&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">getStartTag</span><span class=\"params\">()</span> &#123; </span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">generateXmlString</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">protected</span> String <span class=\"title function_\">getLineFeedString</span><span class=\"params\">()</span> &#123; </span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;\\n&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">isChecked</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> isChecked;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> BaseXml <span class=\"title function_\">setChecked</span><span class=\"params\">(<span class=\"type\">boolean</span> checked)</span> &#123;</span><br><span class=\"line\">        isChecked = checked;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>抽象类提取出来在字符串拼接阶段，各类型常用的基本操作，例如：返回“&lt;solid”这类的开始标签，” &#x2F;&gt;”结束标签等</p>\n<p>其内部<code>BaseXml</code>拥有对应类拥有的所有属性的常用操作，其继承与抽象类<code>BaseBuilder</code>，代码如下所示</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">class</span> <span class=\"title class_\">BaseBuilder</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> String <span class=\"title function_\">getBuilderString</span><span class=\"params\">()</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title function_\">clearData</span><span class=\"params\">()</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title function_\">analysisAttribute</span><span class=\"params\">(Attributes attributes)</span>;</span><br><span class=\"line\">    <span class=\"keyword\">protected</span> <span class=\"keyword\">final</span> String <span class=\"title function_\">getAttrWithUnitStr</span><span class=\"params\">(String attributeType, String value)</span> &#123;</span><br><span class=\"line\">        String unit;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (TextUtils.isEmpty(value)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"string\">&quot;&quot;</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (value.contains(<span class=\"string\">&quot;px&quot;</span>) || value.contains(<span class=\"string\">&quot;dp&quot;</span>)) &#123;</span><br><span class=\"line\">            unit = <span class=\"string\">&quot;&quot;</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            unit = DefaultData.UNIT;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;android:&quot;</span> + attributeType + <span class=\"string\">&quot;=\\&quot;&quot;</span> + value + unit + <span class=\"string\">&quot;\\&quot;&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">protected</span> <span class=\"keyword\">final</span> String <span class=\"title function_\">getAttrWithOutUnitStr</span><span class=\"params\">(String attributeType, String value)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (TextUtils.isEmpty(value)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"string\">&quot;&quot;</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;android:&quot;</span> + attributeType + <span class=\"string\">&quot;=\\&quot;&quot;</span> + value + <span class=\"string\">&quot;\\&quot;&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">protected</span> <span class=\"keyword\">final</span> String <span class=\"title function_\">getValueOutUnit</span><span class=\"params\">(String value)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (TextUtils.isEmpty(value)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> value;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> value.replace(<span class=\"string\">&quot;dp&quot;</span>, <span class=\"string\">&quot;&quot;</span>).replace(<span class=\"string\">&quot;px&quot;</span>, <span class=\"string\">&quot;&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>BaseBuilder内部封装了一些属性的常用操作，例如生成：<code>android:color=&quot;#FFFFFF&quot;</code>这样的字符串，获取是否带有单位的字串等。<br>并提供三个抽象方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> String <span class=\"title function_\">getBuilderString</span><span class=\"params\">()</span>; <span class=\"comment\">//获取Builder中所有属性拼接好的字符串</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title function_\">clearData</span><span class=\"params\">()</span>; <span class=\"comment\">//清空Builder内部属性值</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title function_\">analysisAttribute</span><span class=\"params\">(Attributes attributes)</span>; <span class=\"comment\">//分析xml数据中的值，这个在第二大点“将原有shape.xml字符串转化为对应操作界面”中将会讲到</span></span><br></pre></td></tr></table></figure>\n\n<p>以上是基本数据的构造，在最后在控件交互的地方会调用<code>CommonAction</code>类的<code>refreshAndWriteData</code>：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">abstract</span> <span class=\"keyword\">class</span> <span class=\"title class_\">CommonAction</span> &#123;</span><br><span class=\"line\">    JComponent component;</span><br><span class=\"line\">    NoShapeDialog noShapeDialog;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">void</span> <span class=\"title function_\">refreshAndWriteData</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        NoCodeShapeAction.callWriteData();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>最后会调用基本的Action中的<code>writeData()</code>方法，其具体逻辑为</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">    * 数据写入xml文件</span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">   <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">writeData</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">       <span class=\"keyword\">final</span> <span class=\"type\">Document</span> <span class=\"variable\">document</span> <span class=\"operator\">=</span> FileDocumentManager.getInstance().getDocument(file);</span><br><span class=\"line\">       <span class=\"keyword\">if</span> (document == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">           <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">               <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Exception</span>(<span class=\"string\">&quot;Document对象为空&quot;</span>);</span><br><span class=\"line\">           &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">               e.printStackTrace();</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">           <span class=\"keyword\">return</span>;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       <span class=\"keyword\">new</span> <span class=\"title class_\">WriteCommandAction</span>.Simple(project) &#123;</span><br><span class=\"line\">           <span class=\"meta\">@Override</span></span><br><span class=\"line\">           <span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">               document.setText(XMLString.getInstance().generateXmlString());</span><br><span class=\"line\">               <span class=\"comment\">//formatCode();</span></span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">       &#125;.execute();</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>利用<code>XMLString.getInstance().generateXmlString()</code>获取各操作类型的所有属性将其拼接为一份完整的shape.xml文件的字段，最后调用插件系统的相关命令将字符串粘贴在系统对应的输入框中。</p>\n<h2 id=\"2-将原有shape-xml字符串转化为对应操作界面\"><a href=\"#2-将原有shape-xml字符串转化为对应操作界面\" class=\"headerlink\" title=\"2. 将原有shape.xml字符串转化为对应操作界面\"></a>2. 将原有shape.xml字符串转化为对应操作界面</h2><p>上面已经讲述类如何拼接生成xml字符串并将其粘贴到Android Studio界面上，此外NoCodeShape不仅支持新生成的shape.xml，同样也支持对旧shape.xml进行修改的能力。与第一步相比较主要多了一步读取Android Studio xml文档并将其转化为对应操作界面的过程。其主要是在操作界面初始化之前执行了如下方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">initSax</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">       <span class=\"type\">String</span> <span class=\"variable\">text</span> <span class=\"operator\">=</span> FileDocumentManager.getInstance().getDocument(file).getText();</span><br><span class=\"line\">       <span class=\"type\">ShapeSaxHandler</span> <span class=\"variable\">handler</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ShapeSaxHandler</span>();</span><br><span class=\"line\">       <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">           handler.createViewList(text);</span><br><span class=\"line\">       &#125; <span class=\"keyword\">catch</span> (ParserConfigurationException e) &#123;</span><br><span class=\"line\">           e.printStackTrace();</span><br><span class=\"line\">       &#125; <span class=\"keyword\">catch</span> (SAXException e) &#123;</span><br><span class=\"line\">           e.printStackTrace();</span><br><span class=\"line\">       &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">           e.printStackTrace();</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n<p>利用ShapeSaxHandler去解析xml里面的元素，参考了<a href=\"https://github.com/laobie/FindViewByMe\">FindViewByMe</a>的解析原理。</p>\n<p>具体操作逻辑如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">createViewList</span><span class=\"params\">(String string)</span> <span class=\"keyword\">throws</span> ParserConfigurationException, SAXException, IOException &#123;</span><br><span class=\"line\">      <span class=\"type\">InputStream</span> <span class=\"variable\">xmlStream</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ByteArrayInputStream</span>(string.getBytes(<span class=\"string\">&quot;UTF-8&quot;</span>));</span><br><span class=\"line\">      <span class=\"type\">SAXParserFactory</span> <span class=\"variable\">factory</span> <span class=\"operator\">=</span> SAXParserFactory.newInstance();</span><br><span class=\"line\">      <span class=\"type\">SAXParser</span> <span class=\"variable\">parser</span> <span class=\"operator\">=</span> factory.newSAXParser();</span><br><span class=\"line\">      parser.parse(xmlStream, <span class=\"built_in\">this</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">startDocument</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> SAXException &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (shapePartList == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">          shapePartList = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;ShapePart&gt;();</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">startElement</span><span class=\"params\">(String uri, String localName, String qName, Attributes attributes)</span> <span class=\"keyword\">throws</span> SAXException &#123;</span><br><span class=\"line\">      <span class=\"keyword\">switch</span> (qName) &#123;</span><br><span class=\"line\">          <span class=\"keyword\">case</span> <span class=\"string\">&quot;shape&quot;</span>:</span><br><span class=\"line\">              Shape.getInstance().getBuilder().analysisAttribute(attributes);</span><br><span class=\"line\">              <span class=\"keyword\">break</span>;</span><br><span class=\"line\">          <span class=\"keyword\">case</span> <span class=\"string\">&quot;stroke&quot;</span>:</span><br><span class=\"line\">              Stroke.getInstance().getBuilder().analysisAttribute(attributes);</span><br><span class=\"line\">              <span class=\"keyword\">break</span>;</span><br><span class=\"line\">          <span class=\"keyword\">case</span> <span class=\"string\">&quot;solid&quot;</span>:</span><br><span class=\"line\">             Solid.getInstance().getBuilder().analysisAttribute(attributes);</span><br><span class=\"line\">              <span class=\"keyword\">break</span>;</span><br><span class=\"line\">          <span class=\"keyword\">case</span> <span class=\"string\">&quot;gradient&quot;</span>:</span><br><span class=\"line\">              Gradient.getInstance().getBuilder().analysisAttribute(attributes);</span><br><span class=\"line\">              <span class=\"keyword\">break</span>;</span><br><span class=\"line\">          <span class=\"keyword\">case</span> <span class=\"string\">&quot;corners&quot;</span>:</span><br><span class=\"line\">              Corners.getInstance().getBuilder().analysisAttribute(attributes);</span><br><span class=\"line\">              <span class=\"keyword\">break</span>;</span><br><span class=\"line\">          <span class=\"keyword\">default</span>:</span><br><span class=\"line\">              <span class=\"keyword\">break</span>;</span><br><span class=\"line\">      &#125;</span><br></pre></td></tr></table></figure>\n<p>逻辑其实很清楚，主要对startTag的判断，然后通过调用 <code>public abstract void analysisAttribute(Attributes attributes);</code>的方法对相应的 类型的Buidler进行一个赋值操作。</p>\n<p>以Stroke为例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">analysisAttribute</span><span class=\"params\">(Attributes attributes)</span> &#123;</span><br><span class=\"line\">            Stroke.getInstance().setChecked(<span class=\"literal\">true</span>);</span><br><span class=\"line\">            setColor(attributes.getValue(<span class=\"string\">&quot;android:color&quot;</span>));</span><br><span class=\"line\">            setDashGap(attributes.getValue(<span class=\"string\">&quot;android:dashGap&quot;</span>));</span><br><span class=\"line\">            setWidth(attributes.getValue(<span class=\"string\">&quot;android:width&quot;</span>));</span><br><span class=\"line\">            setDashWidth(attributes.getValue(<span class=\"string\">&quot;android:dashWidth&quot;</span>));</span><br><span class=\"line\">        &#125;</span><br></pre></td></tr></table></figure>\n<p>主要是获取到其中的属性，并对初始化的界面进行一些操作(例如选中或者赋值相关操作)。</p>\n<h1 id=\"四、总结\"><a href=\"#四、总结\" class=\"headerlink\" title=\"四、总结\"></a>四、总结</h1><p>这个插件算是自己第一次做一个相对较实用的插件，都是利用工作的空闲事件进行编写，前前后后进行了将近一个月，其中收获颇多，但也踩过了各种各样的坑。在开发过程中由于相关文档较少，通过阅读官方文档还是有点小吃力，不过一步步还是走了下来，自己也得到了成长。其中坑也都添平了，但由于一些基础技术的欠缺，比如对Java GUI界面编程不太熟悉，导致开发过程中有很大一段时间都在跟界面作对，因此后面有机会将去深入了解Java的界面编程，争取能够将页面交互能够做到更好。</p>\n<p>另外由于自身开发精力的原因，不能将插件做到完美，目前插件中还有如下几个问题：</p>\n<p>1、Gradient中对应相关逻辑还需要再优化<br>2、还未支持Size跟Pading（从自身所处环境考虑用得较少，所以暂未支持）<br>3、对于颜色选择器默认打开后不支持对本地颜色字符串处理<br>4、存在大量的界面操作逻辑代码，需要优化</p>\n<p>最后，希望大家能在使用过程中提出相关的意见或建议，也欢迎能一起加入到开发中，从而能将该插件做得更加完美。</p>\n<p>项目地址：</p>\n<p><a href=\"https://github.com/VomPom/NoCodeShape\">https://github.com/VomPom/NoCodeShape</a></p>\n","cover":null,"images":["https://cdn.julis.wang/blog/img/20191126190001658.png","https://cdn.julis.wang/blog/img/20191126192542676.png","https://cdn.julis.wang/blog/img/20191126192336117.gif"],"content":"<p>NoCodeShape 是一个能可视化界面操作生成Android中Shape.xml的Android Studio插件。对于新手能更好的去接受Android中相对应的属性，对于资深程序员则能简化操作，快速生成shape.xml。项目已经开源 <a href=\"https://github.com/VomPom/NoCodeShape\">NoCodeShape</a></p>\n<h1 id=\"二、NoCodeShape使用方法\"><a href=\"#二、NoCodeShape使用方法\" class=\"headerlink\" title=\"二、NoCodeShape使用方法\"></a>二、NoCodeShape使用方法</h1><h2 id=\"1-下载和安装\"><a href=\"#1-下载和安装\" class=\"headerlink\" title=\"1. 下载和安装\"></a>1. 下载和安装</h2><p>同一般的Android Studio插件下载一样，可以直接<code>Preferences-&gt;Plugins</code> 搜索 <code>NoCodeShape</code>搜索出来结果直接安装再重启即可。</p>\n<img width=\"60%\" src=\"https://cdn.julis.wang/blog/img/20191126190001658.png\">\n<p>也可以去jetbrains插件管理的官网下载各个版本的插件<br><a href=\"https://plugins.jetbrains.com/plugin/13325-nocodeshape/versions\">https://plugins.jetbrains.com/plugin/13325-nocodeshape/versions</a><br>然后<code>Preferences-&gt;Plugins</code> 再Install plugins from disk从本地安装</p>\n<h2 id=\"2-如何使用\"><a href=\"#2-如何使用\" class=\"headerlink\" title=\"2. 如何使用\"></a>2. 如何使用</h2><p>在新建一个shape.xml文件后，右键选择NoCodeShape或者直接按快捷键Common+U</p>\n<img src=\"https://cdn.julis.wang/blog/img/20191126192542676.png\">\n<p>然后选择自己想要的属性，随着点击事件的进行会生成相关xml代码，并在Android Studio右边有对应的shape形状的展示。如果对应shape.xml有相关属性，NoCodeShape也会生成对应shape.xml属性的操作界面，非常方便。<br>示例：</p>\n<img src=\"https://cdn.julis.wang/blog/img/20191126192336117.gif\">\n<h1 id=\"三、实现原理\"><a href=\"#三、实现原理\" class=\"headerlink\" title=\"三、实现原理\"></a>三、实现原理</h1><p>实现原理总体来说并不复杂，主要是界面相关操作逻辑比较繁琐。</p>\n<p>对于新生成的一个shape.xml来说只需要弹出一个新的操作界面，用户只需要点击对应模块的属性即可。项目使用了<code>单例模式+Bulider建造者模式</code>去管理各个Shape属性，分别生成 <code>Shape、Solid、Corners、Stroke、Gradient</code>的单例，其内部拥有一个Builder用来去承各类型的具体属性。</p>\n<p>  通过界面的操作，对其内部的<code>Builder</code>进行数据的填充，最后在完成各类操作后，将各类型中的Builder中的所有属性提取出并生成一份完整的xml字符串并将其粘贴到Android Studio的操作界面上。</p>\n<p>实现主要分为两大类：</p>\n<h2 id=\"1-拼接生成xml字符串\"><a href=\"#1-拼接生成xml字符串\" class=\"headerlink\" title=\"1. 拼接生成xml字符串\"></a>1. 拼接生成xml字符串</h2><p>字符串拼接算是其中最复杂的部分，一是各shape的类型拥有较多数据，其中一些属性有逻辑存在性，二是生成最终Android Studio的xml字符串的时候格式存在比较多的处理。对于各类属性都继承于<code>BaseXml</code>，其内部拥有一个静态内部<code>Builder</code>类，以相对简单的Solid类来举例，如下所示：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Solid</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">BaseXml</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Builder builder;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"type\">Solid</span> <span class=\"variable\">instance</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Solid <span class=\"title function_\">getInstance</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (instance == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            builder = <span class=\"keyword\">new</span> <span class=\"title class_\">Builder</span>();</span><br><span class=\"line\">            instance = <span class=\"keyword\">new</span> <span class=\"title class_\">Solid</span>();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\"> <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Builder</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">BaseBuilder</span> &#123;</span><br><span class=\"line\">        String color;</span><br><span class=\"line\">        String colorValue;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">setColor</span><span class=\"params\">(String color)</span> &#123;</span><br><span class=\"line\">            <span class=\"built_in\">this</span>.colorValue = color;</span><br><span class=\"line\">            <span class=\"built_in\">this</span>.color = getAttrWithOutUnitStr(<span class=\"string\">&quot;color&quot;</span>, color);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"keyword\">public</span> String <span class=\"title function_\">getBuilderString</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> StringUtils.getString(color);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">clearData</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">            StringUtils.clearObjectData(<span class=\"built_in\">this</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">analysisAttribute</span><span class=\"params\">(Attributes attributes)</span> &#123;</span><br><span class=\"line\">            Solid.getInstance().setChecked(<span class=\"literal\">true</span>);</span><br><span class=\"line\">            setColor(attributes.getValue(<span class=\"string\">&quot;android:color&quot;</span>));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>其类继承于抽象类BaseXml，代码如下所示：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">class</span> <span class=\"title class_\">BaseXml</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">boolean</span> <span class=\"variable\">isChecked</span> <span class=\"operator\">=</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">getCloser</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot; /&gt;&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">getStartTag</span><span class=\"params\">()</span> &#123; </span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">generateXmlString</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">protected</span> String <span class=\"title function_\">getLineFeedString</span><span class=\"params\">()</span> &#123; </span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;\\n&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">isChecked</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> isChecked;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> BaseXml <span class=\"title function_\">setChecked</span><span class=\"params\">(<span class=\"type\">boolean</span> checked)</span> &#123;</span><br><span class=\"line\">        isChecked = checked;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>抽象类提取出来在字符串拼接阶段，各类型常用的基本操作，例如：返回“&lt;solid”这类的开始标签，” &#x2F;&gt;”结束标签等</p>\n<p>其内部<code>BaseXml</code>拥有对应类拥有的所有属性的常用操作，其继承与抽象类<code>BaseBuilder</code>，代码如下所示</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">class</span> <span class=\"title class_\">BaseBuilder</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> String <span class=\"title function_\">getBuilderString</span><span class=\"params\">()</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title function_\">clearData</span><span class=\"params\">()</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title function_\">analysisAttribute</span><span class=\"params\">(Attributes attributes)</span>;</span><br><span class=\"line\">    <span class=\"keyword\">protected</span> <span class=\"keyword\">final</span> String <span class=\"title function_\">getAttrWithUnitStr</span><span class=\"params\">(String attributeType, String value)</span> &#123;</span><br><span class=\"line\">        String unit;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (TextUtils.isEmpty(value)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"string\">&quot;&quot;</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (value.contains(<span class=\"string\">&quot;px&quot;</span>) || value.contains(<span class=\"string\">&quot;dp&quot;</span>)) &#123;</span><br><span class=\"line\">            unit = <span class=\"string\">&quot;&quot;</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            unit = DefaultData.UNIT;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;android:&quot;</span> + attributeType + <span class=\"string\">&quot;=\\&quot;&quot;</span> + value + unit + <span class=\"string\">&quot;\\&quot;&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">protected</span> <span class=\"keyword\">final</span> String <span class=\"title function_\">getAttrWithOutUnitStr</span><span class=\"params\">(String attributeType, String value)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (TextUtils.isEmpty(value)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"string\">&quot;&quot;</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;android:&quot;</span> + attributeType + <span class=\"string\">&quot;=\\&quot;&quot;</span> + value + <span class=\"string\">&quot;\\&quot;&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">protected</span> <span class=\"keyword\">final</span> String <span class=\"title function_\">getValueOutUnit</span><span class=\"params\">(String value)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (TextUtils.isEmpty(value)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> value;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> value.replace(<span class=\"string\">&quot;dp&quot;</span>, <span class=\"string\">&quot;&quot;</span>).replace(<span class=\"string\">&quot;px&quot;</span>, <span class=\"string\">&quot;&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>BaseBuilder内部封装了一些属性的常用操作，例如生成：<code>android:color=&quot;#FFFFFF&quot;</code>这样的字符串，获取是否带有单位的字串等。<br>并提供三个抽象方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> String <span class=\"title function_\">getBuilderString</span><span class=\"params\">()</span>; <span class=\"comment\">//获取Builder中所有属性拼接好的字符串</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title function_\">clearData</span><span class=\"params\">()</span>; <span class=\"comment\">//清空Builder内部属性值</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title function_\">analysisAttribute</span><span class=\"params\">(Attributes attributes)</span>; <span class=\"comment\">//分析xml数据中的值，这个在第二大点“将原有shape.xml字符串转化为对应操作界面”中将会讲到</span></span><br></pre></td></tr></table></figure>\n\n<p>以上是基本数据的构造，在最后在控件交互的地方会调用<code>CommonAction</code>类的<code>refreshAndWriteData</code>：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">abstract</span> <span class=\"keyword\">class</span> <span class=\"title class_\">CommonAction</span> &#123;</span><br><span class=\"line\">    JComponent component;</span><br><span class=\"line\">    NoShapeDialog noShapeDialog;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">void</span> <span class=\"title function_\">refreshAndWriteData</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        NoCodeShapeAction.callWriteData();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>最后会调用基本的Action中的<code>writeData()</code>方法，其具体逻辑为</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">    * 数据写入xml文件</span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">   <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">writeData</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">       <span class=\"keyword\">final</span> <span class=\"type\">Document</span> <span class=\"variable\">document</span> <span class=\"operator\">=</span> FileDocumentManager.getInstance().getDocument(file);</span><br><span class=\"line\">       <span class=\"keyword\">if</span> (document == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">           <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">               <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Exception</span>(<span class=\"string\">&quot;Document对象为空&quot;</span>);</span><br><span class=\"line\">           &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">               e.printStackTrace();</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">           <span class=\"keyword\">return</span>;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       <span class=\"keyword\">new</span> <span class=\"title class_\">WriteCommandAction</span>.Simple(project) &#123;</span><br><span class=\"line\">           <span class=\"meta\">@Override</span></span><br><span class=\"line\">           <span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">               document.setText(XMLString.getInstance().generateXmlString());</span><br><span class=\"line\">               <span class=\"comment\">//formatCode();</span></span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">       &#125;.execute();</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>利用<code>XMLString.getInstance().generateXmlString()</code>获取各操作类型的所有属性将其拼接为一份完整的shape.xml文件的字段，最后调用插件系统的相关命令将字符串粘贴在系统对应的输入框中。</p>\n<h2 id=\"2-将原有shape-xml字符串转化为对应操作界面\"><a href=\"#2-将原有shape-xml字符串转化为对应操作界面\" class=\"headerlink\" title=\"2. 将原有shape.xml字符串转化为对应操作界面\"></a>2. 将原有shape.xml字符串转化为对应操作界面</h2><p>上面已经讲述类如何拼接生成xml字符串并将其粘贴到Android Studio界面上，此外NoCodeShape不仅支持新生成的shape.xml，同样也支持对旧shape.xml进行修改的能力。与第一步相比较主要多了一步读取Android Studio xml文档并将其转化为对应操作界面的过程。其主要是在操作界面初始化之前执行了如下方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">initSax</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">       <span class=\"type\">String</span> <span class=\"variable\">text</span> <span class=\"operator\">=</span> FileDocumentManager.getInstance().getDocument(file).getText();</span><br><span class=\"line\">       <span class=\"type\">ShapeSaxHandler</span> <span class=\"variable\">handler</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ShapeSaxHandler</span>();</span><br><span class=\"line\">       <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">           handler.createViewList(text);</span><br><span class=\"line\">       &#125; <span class=\"keyword\">catch</span> (ParserConfigurationException e) &#123;</span><br><span class=\"line\">           e.printStackTrace();</span><br><span class=\"line\">       &#125; <span class=\"keyword\">catch</span> (SAXException e) &#123;</span><br><span class=\"line\">           e.printStackTrace();</span><br><span class=\"line\">       &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">           e.printStackTrace();</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n<p>利用ShapeSaxHandler去解析xml里面的元素，参考了<a href=\"https://github.com/laobie/FindViewByMe\">FindViewByMe</a>的解析原理。</p>\n<p>具体操作逻辑如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">createViewList</span><span class=\"params\">(String string)</span> <span class=\"keyword\">throws</span> ParserConfigurationException, SAXException, IOException &#123;</span><br><span class=\"line\">      <span class=\"type\">InputStream</span> <span class=\"variable\">xmlStream</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ByteArrayInputStream</span>(string.getBytes(<span class=\"string\">&quot;UTF-8&quot;</span>));</span><br><span class=\"line\">      <span class=\"type\">SAXParserFactory</span> <span class=\"variable\">factory</span> <span class=\"operator\">=</span> SAXParserFactory.newInstance();</span><br><span class=\"line\">      <span class=\"type\">SAXParser</span> <span class=\"variable\">parser</span> <span class=\"operator\">=</span> factory.newSAXParser();</span><br><span class=\"line\">      parser.parse(xmlStream, <span class=\"built_in\">this</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">startDocument</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> SAXException &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (shapePartList == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">          shapePartList = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;ShapePart&gt;();</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">startElement</span><span class=\"params\">(String uri, String localName, String qName, Attributes attributes)</span> <span class=\"keyword\">throws</span> SAXException &#123;</span><br><span class=\"line\">      <span class=\"keyword\">switch</span> (qName) &#123;</span><br><span class=\"line\">          <span class=\"keyword\">case</span> <span class=\"string\">&quot;shape&quot;</span>:</span><br><span class=\"line\">              Shape.getInstance().getBuilder().analysisAttribute(attributes);</span><br><span class=\"line\">              <span class=\"keyword\">break</span>;</span><br><span class=\"line\">          <span class=\"keyword\">case</span> <span class=\"string\">&quot;stroke&quot;</span>:</span><br><span class=\"line\">              Stroke.getInstance().getBuilder().analysisAttribute(attributes);</span><br><span class=\"line\">              <span class=\"keyword\">break</span>;</span><br><span class=\"line\">          <span class=\"keyword\">case</span> <span class=\"string\">&quot;solid&quot;</span>:</span><br><span class=\"line\">             Solid.getInstance().getBuilder().analysisAttribute(attributes);</span><br><span class=\"line\">              <span class=\"keyword\">break</span>;</span><br><span class=\"line\">          <span class=\"keyword\">case</span> <span class=\"string\">&quot;gradient&quot;</span>:</span><br><span class=\"line\">              Gradient.getInstance().getBuilder().analysisAttribute(attributes);</span><br><span class=\"line\">              <span class=\"keyword\">break</span>;</span><br><span class=\"line\">          <span class=\"keyword\">case</span> <span class=\"string\">&quot;corners&quot;</span>:</span><br><span class=\"line\">              Corners.getInstance().getBuilder().analysisAttribute(attributes);</span><br><span class=\"line\">              <span class=\"keyword\">break</span>;</span><br><span class=\"line\">          <span class=\"keyword\">default</span>:</span><br><span class=\"line\">              <span class=\"keyword\">break</span>;</span><br><span class=\"line\">      &#125;</span><br></pre></td></tr></table></figure>\n<p>逻辑其实很清楚，主要对startTag的判断，然后通过调用 <code>public abstract void analysisAttribute(Attributes attributes);</code>的方法对相应的 类型的Buidler进行一个赋值操作。</p>\n<p>以Stroke为例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">analysisAttribute</span><span class=\"params\">(Attributes attributes)</span> &#123;</span><br><span class=\"line\">            Stroke.getInstance().setChecked(<span class=\"literal\">true</span>);</span><br><span class=\"line\">            setColor(attributes.getValue(<span class=\"string\">&quot;android:color&quot;</span>));</span><br><span class=\"line\">            setDashGap(attributes.getValue(<span class=\"string\">&quot;android:dashGap&quot;</span>));</span><br><span class=\"line\">            setWidth(attributes.getValue(<span class=\"string\">&quot;android:width&quot;</span>));</span><br><span class=\"line\">            setDashWidth(attributes.getValue(<span class=\"string\">&quot;android:dashWidth&quot;</span>));</span><br><span class=\"line\">        &#125;</span><br></pre></td></tr></table></figure>\n<p>主要是获取到其中的属性，并对初始化的界面进行一些操作(例如选中或者赋值相关操作)。</p>\n<h1 id=\"四、总结\"><a href=\"#四、总结\" class=\"headerlink\" title=\"四、总结\"></a>四、总结</h1><p>这个插件算是自己第一次做一个相对较实用的插件，都是利用工作的空闲事件进行编写，前前后后进行了将近一个月，其中收获颇多，但也踩过了各种各样的坑。在开发过程中由于相关文档较少，通过阅读官方文档还是有点小吃力，不过一步步还是走了下来，自己也得到了成长。其中坑也都添平了，但由于一些基础技术的欠缺，比如对Java GUI界面编程不太熟悉，导致开发过程中有很大一段时间都在跟界面作对，因此后面有机会将去深入了解Java的界面编程，争取能够将页面交互能够做到更好。</p>\n<p>另外由于自身开发精力的原因，不能将插件做到完美，目前插件中还有如下几个问题：</p>\n<p>1、Gradient中对应相关逻辑还需要再优化<br>2、还未支持Size跟Pading（从自身所处环境考虑用得较少，所以暂未支持）<br>3、对于颜色选择器默认打开后不支持对本地颜色字符串处理<br>4、存在大量的界面操作逻辑代码，需要优化</p>\n<p>最后，希望大家能在使用过程中提出相关的意见或建议，也欢迎能一起加入到开发中，从而能将该插件做得更加完美。</p>\n<p>项目地址：</p>\n<p><a href=\"https://github.com/VomPom/NoCodeShape\">https://github.com/VomPom/NoCodeShape</a></p>\n","categories":[{"name":"技术文章","slug":"technology","api":"api/categories/technology.json"}],"tags":[{"name":"插件","slug":"插件","api":"api/tags/插件.json"}],"api":"api/posts/2019/11/27/一款快速生成Android-shape的插件-NoCodeShape.json"},{"title":"Java中的Reference解析","slug":"Java四种引用","date":"2019-10-30T11:45:00.000Z","updated":"2025-05-20T11:46:57.000Z","comments":true,"url":"2019/10/30/Java四种引用/","excerpt":"<p>Java执行GC判断对象是否存活有两种方式其中一种是<strong>引用计数</strong>。</p>\n<p><strong>引用计数</strong>：Java堆中每一个对象都有一个引用计数属性，引用每新增1次计数加1，引用每释放1次计数减1。</p>\n<p>在JDK 1.2以前的版本中，若一个对象不被任何变量引用，那么程序就无法再使用这个对象。也就是说，只有对象处于(reachable)可达状态，程序才能使用它。</p>\n<p>从JDK 1.2版本开始，对象的引用被划分为4种级别，从而使程序能更加灵活地控制对象的生命周期。这4种级别由高到低依次为：<code>强引用、软引用、弱引用和虚引用</code>，本文主要讲解各个引用的用途以及引用队列的作用。</p>\n<h2 id=\"1、强引用（StrongReference）\"><a href=\"#1、强引用（StrongReference）\" class=\"headerlink\" title=\"1、强引用（StrongReference）\"></a>1、强引用（StrongReference）</h2><p>强引用指的是程序代码中普遍存在的，类似如下代码</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">Object</span> <span class=\"variable\">object</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Object</span>();</span><br></pre></td></tr></table></figure>\n<p><em><strong>当内存空间不足时，只要强引用还在，Java虚拟机会抛出OutOfMemoryError错误，使程序异常终止，也不会靠回收强引用的对象来解决内存不足的问题。</strong></em></p>\n<p>如果强引用对象不使用时，需要弱化从而使GC能够回收，如下所示：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">object = <span class=\"literal\">null</span>;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2、软引用（SoftReference）\"><a href=\"#2、软引用（SoftReference）\" class=\"headerlink\" title=\"2、软引用（SoftReference）\"></a>2、软引用（SoftReference）</h2><p><em><strong>软引用是用来描述一些有用但并不是必需的对象。对于软引用关联着的对象，在系统将要发生内存溢出异常之前，将会把这些对象列进回首范围之中进行第二次回收。如果这次回收还没有足够的内存，才会抛出内存溢出异常。</strong></em></p>\n<p>这一点可以很好地用来解决OOM的问题，并且这个特性很适合用来实现缓存：比如网页缓存、图片缓存等，软引用可用来实现内存敏感的高速缓存。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 强引用</span></span><br><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">strongReference</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">String</span>(<span class=\"string\">&quot;abc&quot;</span>);</span><br><span class=\"line\"><span class=\"comment\">// 软引用</span></span><br><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">str</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">String</span>(<span class=\"string\">&quot;abc&quot;</span>);</span><br><span class=\"line\">SoftReference&lt;String&gt; softReference = <span class=\"keyword\">new</span> <span class=\"title class_\">SoftReference</span>&lt;String&gt;(str);</span><br></pre></td></tr></table></figure>\n\n<p>软引用可以和一个引用队列(ReferenceQueue)联合使用。如果软引用所引用对象被垃圾回收，JAVA虚拟机就会把这个软引用加入到与之关联的引用队列中。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">ReferenceQueue&lt;String&gt; referenceQueue = <span class=\"keyword\">new</span> <span class=\"title class_\">ReferenceQueue</span>&lt;&gt;();</span><br><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">str</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">String</span>(<span class=\"string\">&quot;abc&quot;</span>);</span><br><span class=\"line\">SoftReference&lt;String&gt; softReference = <span class=\"keyword\">new</span> <span class=\"title class_\">SoftReference</span>&lt;&gt;(str, referenceQueue);</span><br><span class=\"line\">str = <span class=\"literal\">null</span>;</span><br><span class=\"line\"><span class=\"comment\">// Notify GC</span></span><br><span class=\"line\">System.gc();</span><br><span class=\"line\">System.out.println(softReference.get()); <span class=\"comment\">// abc</span></span><br><span class=\"line\">Reference&lt;? <span class=\"keyword\">extends</span> <span class=\"title class_\">String</span>&gt; reference = referenceQueue.poll();</span><br><span class=\"line\">System.out.println(reference); <span class=\"comment\">//null</span></span><br></pre></td></tr></table></figure>\n\n<p>注意：软引用对象是在jvm内存不够的时候才会被回收，我们调用System.gc()方法只是起通知作用，JVM什么时候扫描回收对象是JVM自己的状态决定的。就算扫描到软引用对象也不一定会回收它，只有内存不够的时候才会回收。</p>\n<p>当内存不足时，JVM首先将软引用中的对象引用置为<code>null</code>，然后通知垃圾回收器进行回收：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span>(JVM内存不足) &#123;</span><br><span class=\"line\">     <span class=\"comment\">// 将软引用中的对象引用置为null</span></span><br><span class=\"line\">     str = <span class=\"literal\">null</span>;</span><br><span class=\"line\">     <span class=\"comment\">// 通知垃圾回收器进行回收</span></span><br><span class=\"line\">     System.gc();</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n<p>也就是说，垃圾收集线程会在虚拟机抛出<code>OutOfMemoryError</code>之前回收软引用对象，而且虚拟机会尽可能优先回收长时间闲置不用的软引用对象。对那些刚构建的或刚使用过的较新的软对象会被虚拟机尽可能保留，这就是引入引用队列ReferenceQueue的原因，后面会具体讲解。</p>\n<h2 id=\"3、弱引用（WeakReference）\"><a href=\"#3、弱引用（WeakReference）\" class=\"headerlink\" title=\"3、弱引用（WeakReference）\"></a>3、弱引用（WeakReference）</h2><p><em><strong>弱引用也是用来描述非必需对象的，但是它的强度比软引用更弱一些，被弱引用关联的<br>对象只能生存到下一次垃圾收集发生之前。当垃圾收集器工作时，无论当前内存是否足够，<br>都会回收掉只被弱引用关联的对象。</strong></em></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">str</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">String</span>(<span class=\"string\">&quot;abc&quot;</span>);</span><br><span class=\"line\">WeakReference&lt;String&gt; weakReference = <span class=\"keyword\">new</span> <span class=\"title class_\">WeakReference</span>&lt;&gt;(str);</span><br><span class=\"line\">str = <span class=\"literal\">null</span>;</span><br></pre></td></tr></table></figure>\n<p>复制代码JVM首先将软引用中的对象引用置为null，然后通知垃圾回收器进行回收：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">str = <span class=\"literal\">null</span>;</span><br><span class=\"line\">System.gc();</span><br></pre></td></tr></table></figure>\n\n<p>注意：如果一个对象是偶尔(很少)的使用，并且希望在使用时随时就能获取到，但又不想影响此对象的垃圾收集，那么你应该用Weak Reference来记住此对象。</p>\n<p>下面的代码会让一个弱引用再次变为一个强引用：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">str</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">String</span>(<span class=\"string\">&quot;abc&quot;</span>);</span><br><span class=\"line\">WeakReference&lt;String&gt; weakReference = <span class=\"keyword\">new</span> <span class=\"title class_\">WeakReference</span>&lt;&gt;(str);</span><br><span class=\"line\"><span class=\"comment\">// 弱引用转强引用</span></span><br><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">strongReference</span> <span class=\"operator\">=</span> weakReference.get();</span><br></pre></td></tr></table></figure>\n\n<p>同样，弱引用可以和一个引用队列(ReferenceQueue)联合使用，如果弱引用所引用的对象被垃圾回收，Java虚拟机就会把这个弱引用加入到与之关联的引用队列中。</p>\n<h2 id=\"4、虚引用（PhantomReference）\"><a href=\"#4、虚引用（PhantomReference）\" class=\"headerlink\" title=\"4、虚引用（PhantomReference）\"></a>4、虚引用（PhantomReference）</h2><p><em><strong>虚引用也称为幽灵引用或者幻影引用，它是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生命周期构成影响，也无法通过虚引用获得一个对象实例。</strong></em></p>\n<p>虚引用主要用来<strong>跟踪对象被垃圾回收器回收的活动</strong>，虚引用与软引用和弱引用的一个区别在于：</p>\n<blockquote>\n<p>虚引用必须和引用队列(ReferenceQueue)联合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">str</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">String</span>(<span class=\"string\">&quot;abc&quot;</span>);</span><br><span class=\"line\"><span class=\"type\">ReferenceQueue</span> <span class=\"variable\">queue</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ReferenceQueue</span>();</span><br><span class=\"line\"><span class=\"comment\">// 创建虚引用，要求必须与一个引用队列关联</span></span><br><span class=\"line\"><span class=\"type\">PhantomReference</span> <span class=\"variable\">pr</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">PhantomReference</span>(str, queue);</span><br></pre></td></tr></table></figure>\n<p>程序可以通过判断引用队列中是否已经加入了虚引用，来了解被引用的对象是否将要进行垃圾回收。如果程序发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动。</p>\n<h2 id=\"5、引用队列（ReferenceQueue）\"><a href=\"#5、引用队列（ReferenceQueue）\" class=\"headerlink\" title=\"5、引用队列（ReferenceQueue）\"></a>5、引用队列（ReferenceQueue）</h2><p>在前面软引用、弱引用和虚引用都有讲到引用队列，那引用队列具体是做什么的呢？<br>官方对于引用队列类的注释是：</p>\n<blockquote>\n<p> Reference queues, to which registered reference objects are appended by the garbage collector after the appropriate reachability changes are detected.<br> 译为：引用队列是将垃圾收集器在监测到适当的可达性更改后将已注册的引用对象添加到该队列。</p>\n</blockquote>\n<p>对于软引用和弱引用和虚引用，我们希望当一个对象被gc掉的时候通知用户线程，进行额外的处理时，就需要使用引用队列了。<code>ReferenceQueue</code>即这样的一个对象，当一个obj被gc掉之后，其相应的包装类，即ref对象会被放入queue中。我们可以从queue中获取到相应的对象信息，同时进行额外的处理。比如反向操作，数据清理等。</p>\n<p>查看源码发现ReferenceQueue的代码结构并不复杂，从源码上看，实际上ReferenceQueue只是名义上的引用队列，它只保存了Reference链表的头(head)节点，并且提供了队列出队入队删除操作，而Reference实际上本身提供单向链表的功能，也就是说Reference通过成员属性next构建单向链表，而链表的操作是委托给ReferenceQueue完成。详细参考：<a href=\"https://www.throwable.club/2019/02/16/java-reference/#ReferenceQueue\">深入理解JDK中的Reference原理和源码实现</a></p>\n<img src=\"https://cdn.julis.wang/blog/img/20191030191550407.png\">\n<h2 id=\"6、总结\"><a href=\"#6、总结\" class=\"headerlink\" title=\"6、总结\"></a>6、总结</h2><p>1、Java中四种引用的级别和强度由高到低依次为：<code>强引用 -&gt; 软引用 -&gt; 弱引用 -&gt; 虚引用</code></p>\n<p>2、ReferenceQueue引用队列用来记录被回收的引用为用户线程做额外操作作铺垫</p>\n<p>3、对各种引用回收时间、用途、生成时间作总结：</p>\n<img src=\"https://cdn.julis.wang/blog/img/78afb9b4d86f5feef01ac947f96baee331c.jpg\">\n<p>参考：</p>\n<p>1、《深入理解Java虚拟机》</p>\n<p>2、<a href=\"https://www.throwable.club/2019/02/16/java-reference/#ReferenceQueue\">深入理解JDK中的Reference原理和源码实现</a></p>\n<p>3、<a href=\"https://juejin.im/post/5b82c02df265da436152f5ad\">理解Java的强引用、软引用、弱引用和虚引用</a></p>\n","cover":null,"images":["https://cdn.julis.wang/blog/img/20191030191550407.png","https://cdn.julis.wang/blog/img/78afb9b4d86f5feef01ac947f96baee331c.jpg"],"content":"<p>Java执行GC判断对象是否存活有两种方式其中一种是<strong>引用计数</strong>。</p>\n<p><strong>引用计数</strong>：Java堆中每一个对象都有一个引用计数属性，引用每新增1次计数加1，引用每释放1次计数减1。</p>\n<p>在JDK 1.2以前的版本中，若一个对象不被任何变量引用，那么程序就无法再使用这个对象。也就是说，只有对象处于(reachable)可达状态，程序才能使用它。</p>\n<p>从JDK 1.2版本开始，对象的引用被划分为4种级别，从而使程序能更加灵活地控制对象的生命周期。这4种级别由高到低依次为：<code>强引用、软引用、弱引用和虚引用</code>，本文主要讲解各个引用的用途以及引用队列的作用。</p>\n<h2 id=\"1、强引用（StrongReference）\"><a href=\"#1、强引用（StrongReference）\" class=\"headerlink\" title=\"1、强引用（StrongReference）\"></a>1、强引用（StrongReference）</h2><p>强引用指的是程序代码中普遍存在的，类似如下代码</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">Object</span> <span class=\"variable\">object</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Object</span>();</span><br></pre></td></tr></table></figure>\n<p><em><strong>当内存空间不足时，只要强引用还在，Java虚拟机会抛出OutOfMemoryError错误，使程序异常终止，也不会靠回收强引用的对象来解决内存不足的问题。</strong></em></p>\n<p>如果强引用对象不使用时，需要弱化从而使GC能够回收，如下所示：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">object = <span class=\"literal\">null</span>;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2、软引用（SoftReference）\"><a href=\"#2、软引用（SoftReference）\" class=\"headerlink\" title=\"2、软引用（SoftReference）\"></a>2、软引用（SoftReference）</h2><p><em><strong>软引用是用来描述一些有用但并不是必需的对象。对于软引用关联着的对象，在系统将要发生内存溢出异常之前，将会把这些对象列进回首范围之中进行第二次回收。如果这次回收还没有足够的内存，才会抛出内存溢出异常。</strong></em></p>\n<p>这一点可以很好地用来解决OOM的问题，并且这个特性很适合用来实现缓存：比如网页缓存、图片缓存等，软引用可用来实现内存敏感的高速缓存。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 强引用</span></span><br><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">strongReference</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">String</span>(<span class=\"string\">&quot;abc&quot;</span>);</span><br><span class=\"line\"><span class=\"comment\">// 软引用</span></span><br><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">str</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">String</span>(<span class=\"string\">&quot;abc&quot;</span>);</span><br><span class=\"line\">SoftReference&lt;String&gt; softReference = <span class=\"keyword\">new</span> <span class=\"title class_\">SoftReference</span>&lt;String&gt;(str);</span><br></pre></td></tr></table></figure>\n\n<p>软引用可以和一个引用队列(ReferenceQueue)联合使用。如果软引用所引用对象被垃圾回收，JAVA虚拟机就会把这个软引用加入到与之关联的引用队列中。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">ReferenceQueue&lt;String&gt; referenceQueue = <span class=\"keyword\">new</span> <span class=\"title class_\">ReferenceQueue</span>&lt;&gt;();</span><br><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">str</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">String</span>(<span class=\"string\">&quot;abc&quot;</span>);</span><br><span class=\"line\">SoftReference&lt;String&gt; softReference = <span class=\"keyword\">new</span> <span class=\"title class_\">SoftReference</span>&lt;&gt;(str, referenceQueue);</span><br><span class=\"line\">str = <span class=\"literal\">null</span>;</span><br><span class=\"line\"><span class=\"comment\">// Notify GC</span></span><br><span class=\"line\">System.gc();</span><br><span class=\"line\">System.out.println(softReference.get()); <span class=\"comment\">// abc</span></span><br><span class=\"line\">Reference&lt;? <span class=\"keyword\">extends</span> <span class=\"title class_\">String</span>&gt; reference = referenceQueue.poll();</span><br><span class=\"line\">System.out.println(reference); <span class=\"comment\">//null</span></span><br></pre></td></tr></table></figure>\n\n<p>注意：软引用对象是在jvm内存不够的时候才会被回收，我们调用System.gc()方法只是起通知作用，JVM什么时候扫描回收对象是JVM自己的状态决定的。就算扫描到软引用对象也不一定会回收它，只有内存不够的时候才会回收。</p>\n<p>当内存不足时，JVM首先将软引用中的对象引用置为<code>null</code>，然后通知垃圾回收器进行回收：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span>(JVM内存不足) &#123;</span><br><span class=\"line\">     <span class=\"comment\">// 将软引用中的对象引用置为null</span></span><br><span class=\"line\">     str = <span class=\"literal\">null</span>;</span><br><span class=\"line\">     <span class=\"comment\">// 通知垃圾回收器进行回收</span></span><br><span class=\"line\">     System.gc();</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n<p>也就是说，垃圾收集线程会在虚拟机抛出<code>OutOfMemoryError</code>之前回收软引用对象，而且虚拟机会尽可能优先回收长时间闲置不用的软引用对象。对那些刚构建的或刚使用过的较新的软对象会被虚拟机尽可能保留，这就是引入引用队列ReferenceQueue的原因，后面会具体讲解。</p>\n<h2 id=\"3、弱引用（WeakReference）\"><a href=\"#3、弱引用（WeakReference）\" class=\"headerlink\" title=\"3、弱引用（WeakReference）\"></a>3、弱引用（WeakReference）</h2><p><em><strong>弱引用也是用来描述非必需对象的，但是它的强度比软引用更弱一些，被弱引用关联的<br>对象只能生存到下一次垃圾收集发生之前。当垃圾收集器工作时，无论当前内存是否足够，<br>都会回收掉只被弱引用关联的对象。</strong></em></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">str</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">String</span>(<span class=\"string\">&quot;abc&quot;</span>);</span><br><span class=\"line\">WeakReference&lt;String&gt; weakReference = <span class=\"keyword\">new</span> <span class=\"title class_\">WeakReference</span>&lt;&gt;(str);</span><br><span class=\"line\">str = <span class=\"literal\">null</span>;</span><br></pre></td></tr></table></figure>\n<p>复制代码JVM首先将软引用中的对象引用置为null，然后通知垃圾回收器进行回收：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">str = <span class=\"literal\">null</span>;</span><br><span class=\"line\">System.gc();</span><br></pre></td></tr></table></figure>\n\n<p>注意：如果一个对象是偶尔(很少)的使用，并且希望在使用时随时就能获取到，但又不想影响此对象的垃圾收集，那么你应该用Weak Reference来记住此对象。</p>\n<p>下面的代码会让一个弱引用再次变为一个强引用：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">str</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">String</span>(<span class=\"string\">&quot;abc&quot;</span>);</span><br><span class=\"line\">WeakReference&lt;String&gt; weakReference = <span class=\"keyword\">new</span> <span class=\"title class_\">WeakReference</span>&lt;&gt;(str);</span><br><span class=\"line\"><span class=\"comment\">// 弱引用转强引用</span></span><br><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">strongReference</span> <span class=\"operator\">=</span> weakReference.get();</span><br></pre></td></tr></table></figure>\n\n<p>同样，弱引用可以和一个引用队列(ReferenceQueue)联合使用，如果弱引用所引用的对象被垃圾回收，Java虚拟机就会把这个弱引用加入到与之关联的引用队列中。</p>\n<h2 id=\"4、虚引用（PhantomReference）\"><a href=\"#4、虚引用（PhantomReference）\" class=\"headerlink\" title=\"4、虚引用（PhantomReference）\"></a>4、虚引用（PhantomReference）</h2><p><em><strong>虚引用也称为幽灵引用或者幻影引用，它是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生命周期构成影响，也无法通过虚引用获得一个对象实例。</strong></em></p>\n<p>虚引用主要用来<strong>跟踪对象被垃圾回收器回收的活动</strong>，虚引用与软引用和弱引用的一个区别在于：</p>\n<blockquote>\n<p>虚引用必须和引用队列(ReferenceQueue)联合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">str</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">String</span>(<span class=\"string\">&quot;abc&quot;</span>);</span><br><span class=\"line\"><span class=\"type\">ReferenceQueue</span> <span class=\"variable\">queue</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ReferenceQueue</span>();</span><br><span class=\"line\"><span class=\"comment\">// 创建虚引用，要求必须与一个引用队列关联</span></span><br><span class=\"line\"><span class=\"type\">PhantomReference</span> <span class=\"variable\">pr</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">PhantomReference</span>(str, queue);</span><br></pre></td></tr></table></figure>\n<p>程序可以通过判断引用队列中是否已经加入了虚引用，来了解被引用的对象是否将要进行垃圾回收。如果程序发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动。</p>\n<h2 id=\"5、引用队列（ReferenceQueue）\"><a href=\"#5、引用队列（ReferenceQueue）\" class=\"headerlink\" title=\"5、引用队列（ReferenceQueue）\"></a>5、引用队列（ReferenceQueue）</h2><p>在前面软引用、弱引用和虚引用都有讲到引用队列，那引用队列具体是做什么的呢？<br>官方对于引用队列类的注释是：</p>\n<blockquote>\n<p> Reference queues, to which registered reference objects are appended by the garbage collector after the appropriate reachability changes are detected.<br> 译为：引用队列是将垃圾收集器在监测到适当的可达性更改后将已注册的引用对象添加到该队列。</p>\n</blockquote>\n<p>对于软引用和弱引用和虚引用，我们希望当一个对象被gc掉的时候通知用户线程，进行额外的处理时，就需要使用引用队列了。<code>ReferenceQueue</code>即这样的一个对象，当一个obj被gc掉之后，其相应的包装类，即ref对象会被放入queue中。我们可以从queue中获取到相应的对象信息，同时进行额外的处理。比如反向操作，数据清理等。</p>\n<p>查看源码发现ReferenceQueue的代码结构并不复杂，从源码上看，实际上ReferenceQueue只是名义上的引用队列，它只保存了Reference链表的头(head)节点，并且提供了队列出队入队删除操作，而Reference实际上本身提供单向链表的功能，也就是说Reference通过成员属性next构建单向链表，而链表的操作是委托给ReferenceQueue完成。详细参考：<a href=\"https://www.throwable.club/2019/02/16/java-reference/#ReferenceQueue\">深入理解JDK中的Reference原理和源码实现</a></p>\n<img src=\"https://cdn.julis.wang/blog/img/20191030191550407.png\">\n<h2 id=\"6、总结\"><a href=\"#6、总结\" class=\"headerlink\" title=\"6、总结\"></a>6、总结</h2><p>1、Java中四种引用的级别和强度由高到低依次为：<code>强引用 -&gt; 软引用 -&gt; 弱引用 -&gt; 虚引用</code></p>\n<p>2、ReferenceQueue引用队列用来记录被回收的引用为用户线程做额外操作作铺垫</p>\n<p>3、对各种引用回收时间、用途、生成时间作总结：</p>\n<img src=\"https://cdn.julis.wang/blog/img/78afb9b4d86f5feef01ac947f96baee331c.jpg\">\n<p>参考：</p>\n<p>1、《深入理解Java虚拟机》</p>\n<p>2、<a href=\"https://www.throwable.club/2019/02/16/java-reference/#ReferenceQueue\">深入理解JDK中的Reference原理和源码实现</a></p>\n<p>3、<a href=\"https://juejin.im/post/5b82c02df265da436152f5ad\">理解Java的强引用、软引用、弱引用和虚引用</a></p>\n","categories":[{"name":"技术文章","slug":"technology","api":"api/categories/technology.json"}],"tags":[{"name":"Java","slug":"java","api":"api/tags/java.json"}],"api":"api/posts/2019/10/30/Java四种引用.json"}],"info":{"type":"index"}},"api":"api/posts/page.5.json"}