{"data":{"index":6,"total":8,"posts":[{"title":"(转)算法之优先队列 PriorityQueue解决Top K 问题","slug":"算法之优先队列-PriorityQueue解决Top-K-问题","date":"2019-10-10T01:51:00.000Z","updated":"2025-05-20T11:46:57.000Z","comments":true,"url":"2019/10/10/算法之优先队列-PriorityQueue解决Top-K-问题/","excerpt":"<p>转自：<a href=\"https://www.jianshu.com/p/a4a1984fc4ff\">https://www.jianshu.com/p/a4a1984fc4ff</a></p>\n<p>解决方法：<br>维护一个大小为 K 的小顶堆，依次将数据放入堆中，当堆的大小满了的时候，只需要将堆顶元素与下一个数比较：如果大于堆顶元素，则将当前的堆顶元素抛弃，并将该元素插入堆中。遍历完全部数据，Top K 的元素也自然都在堆里面了。</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/8807674-d32bc53ef9cadc8d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/770/format/webp\"></p>\n<p>当然，如果是求前 K 个最小的数，只需要改为大顶堆即可</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/8807674-e67fb606d0f5766a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/776/format/webp\"></p>\n<p> 将数据插入堆  95 大于 20，进行替换 95 下沉，维持小顶堆<br>对于海量数据，我们不需要一次性将全部数据取出来，可以一次只取一部分，因为我们只需要将数据一个个拿来与堆顶比较。</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/8807674-15eac9a1c7fb75e2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/788/format/webp\"></p>\n<p>另外还有一个优势就是对于动态数组，我们可以一直都维护一个 K 大小的小顶堆，当有数据被添加到集合中时，我们就直接拿它与堆顶的元素对比。这样，无论任何时候需要查询当前的前 K 大数据，我们都可以里立刻返回给他。</p>\n<p>整个操作中，遍历数组需要 O(n) 的时间复杂度，一次堆化操作需要 O(logK)，加起来就是 O(nlogK) 的复杂度，换个角度来看，如果 K 远小于 n 的话， O(nlogK) 其实就接近于 O(n) 了，甚至会更快，因此也是十分高效的。</p>\n<p>最后，对于 Java，我们可以直接使用优先队列 PriorityQueue 来实现一个小顶堆，这里给个代码：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">public static List&lt;Integer&gt; solutionByHeap(int[] input, int k) &#123;</span><br><span class=\"line\">        List&lt;Integer&gt; list = new ArrayList&lt;&gt;();</span><br><span class=\"line\">        if (k &gt; input.length || k == 0) &#123;</span><br><span class=\"line\">            return list;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        Queue&lt;Integer&gt; queue = new PriorityQueue&lt;&gt;();</span><br><span class=\"line\">        for (int num : input) &#123;</span><br><span class=\"line\">            if (queue.size() &lt; k) &#123;</span><br><span class=\"line\">                queue.add(num);</span><br><span class=\"line\">            &#125; else if (queue.peek() &lt; num) &#123;</span><br><span class=\"line\">                queue.poll();</span><br><span class=\"line\">                queue.add(num);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        while (k-- &gt; 0) &#123;</span><br><span class=\"line\">            list.add(queue.poll());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return list;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>","cover":null,"images":["https://upload-images.jianshu.io/upload_images/8807674-d32bc53ef9cadc8d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/770/format/webp","https://upload-images.jianshu.io/upload_images/8807674-e67fb606d0f5766a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/776/format/webp","https://upload-images.jianshu.io/upload_images/8807674-15eac9a1c7fb75e2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/788/format/webp"],"content":"<p>转自：<a href=\"https://www.jianshu.com/p/a4a1984fc4ff\">https://www.jianshu.com/p/a4a1984fc4ff</a></p>\n<p>解决方法：<br>维护一个大小为 K 的小顶堆，依次将数据放入堆中，当堆的大小满了的时候，只需要将堆顶元素与下一个数比较：如果大于堆顶元素，则将当前的堆顶元素抛弃，并将该元素插入堆中。遍历完全部数据，Top K 的元素也自然都在堆里面了。</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/8807674-d32bc53ef9cadc8d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/770/format/webp\"></p>\n<p>当然，如果是求前 K 个最小的数，只需要改为大顶堆即可</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/8807674-e67fb606d0f5766a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/776/format/webp\"></p>\n<p> 将数据插入堆  95 大于 20，进行替换 95 下沉，维持小顶堆<br>对于海量数据，我们不需要一次性将全部数据取出来，可以一次只取一部分，因为我们只需要将数据一个个拿来与堆顶比较。</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/8807674-15eac9a1c7fb75e2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/788/format/webp\"></p>\n<p>另外还有一个优势就是对于动态数组，我们可以一直都维护一个 K 大小的小顶堆，当有数据被添加到集合中时，我们就直接拿它与堆顶的元素对比。这样，无论任何时候需要查询当前的前 K 大数据，我们都可以里立刻返回给他。</p>\n<p>整个操作中，遍历数组需要 O(n) 的时间复杂度，一次堆化操作需要 O(logK)，加起来就是 O(nlogK) 的复杂度，换个角度来看，如果 K 远小于 n 的话， O(nlogK) 其实就接近于 O(n) 了，甚至会更快，因此也是十分高效的。</p>\n<p>最后，对于 Java，我们可以直接使用优先队列 PriorityQueue 来实现一个小顶堆，这里给个代码：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">public static List&lt;Integer&gt; solutionByHeap(int[] input, int k) &#123;</span><br><span class=\"line\">        List&lt;Integer&gt; list = new ArrayList&lt;&gt;();</span><br><span class=\"line\">        if (k &gt; input.length || k == 0) &#123;</span><br><span class=\"line\">            return list;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        Queue&lt;Integer&gt; queue = new PriorityQueue&lt;&gt;();</span><br><span class=\"line\">        for (int num : input) &#123;</span><br><span class=\"line\">            if (queue.size() &lt; k) &#123;</span><br><span class=\"line\">                queue.add(num);</span><br><span class=\"line\">            &#125; else if (queue.peek() &lt; num) &#123;</span><br><span class=\"line\">                queue.poll();</span><br><span class=\"line\">                queue.add(num);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        while (k-- &gt; 0) &#123;</span><br><span class=\"line\">            list.add(queue.poll());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return list;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>","categories":[{"name":"算法研究","slug":"算法研究","api":"api/categories/算法研究.json"}],"tags":[{"name":"算法","slug":"algorithm","api":"api/tags/algorithm.json"}],"api":"api/posts/2019/10/10/算法之优先队列-PriorityQueue解决Top-K-问题.json"},{"title":"Java中Lambda表达式解析","slug":"Java中Lambda表达式解析","date":"2019-10-09T10:55:00.000Z","updated":"2025-05-20T11:46:57.000Z","comments":true,"url":"2019/10/09/Java中Lambda表达式解析/","excerpt":"<p>在大部分开发者看来，Lambda 表达式只是一种语法糖，简化了书写匿名内部类的写法。实际上Lambda表达式并不仅仅是匿名内部类的语法糖，JVM内部是通过invokedynamic指令来实现Lambda表达式的，与内部类的实现有很大的差异。本文主要记录lambda的实现原理。</p>\n<h2 id=\"一、函数式接口\"><a href=\"#一、函数式接口\" class=\"headerlink\" title=\"一、函数式接口\"></a><strong>一、函数式接口</strong></h2><p>众所周知Javascript具有一个强大的特性：<strong>闭包</strong>。Java中最接近闭包概念的东西就是lambda表达式了，而Lambda为Java添加了缺失函数式编程的特点。所以什么是函数是接口呢？</p>\n<p>函数式接口需满足以下两个条件：</p>\n<ol>\n<li>它是接口</li>\n<li>这个接口<strong>有且仅有一个抽象方法</strong></li>\n</ol>\n<p>例如我们常用的：Runnable、View.OnClickListener、Comparable等都是函数式接口，因为它们都只有一个方法，而且都是抽象的。虽然只有一个抽象方法，是不是就意味着只能有一个方法呢？实际并不是，虽然有且仅有一个抽象方法，但是可以有多个非抽象方法的接口。</p>\n<p>嗯？！Java接口中难道还可以定义非抽象方法么？平时我们的接口大概长这样：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">IdiomSubmitListener</span> &#123;</span><br><span class=\"line\">   \t<span class=\"keyword\">void</span> <span class=\"title function_\">verifyResult</span><span class=\"params\">(String result)</span>;</span><br><span class=\"line\">   \t<span class=\"keyword\">void</span> <span class=\"title function_\">onSuceess</span><span class=\"params\">()</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>那接口的非抽象方法是啥？原来在JDK 1.8 对于接口而言具有以下新特性：<br><strong>接口可以定义非抽象方法，但必须使用default或者staic关键字来修饰</strong><br>具体细节点可以参考 <a href=\"https://blog.csdn.net/austral/article/details/53402476\">JAVA 8新特性 允许接口定义非抽象方法 快速入门案例</a></p>\n<p>如果一个接口符合函数式接口的定义，那么我们就可以在该接口上面声明FunctionalInterface注解，用来表示该接口是一个函数式接口，并按照函数式接口的规范在编译的时候对该接口进行检查。</p>\n<p>当然如果某个接口只有一个抽象方法，但我们并没有给该接口声明FunctionalInterface注解，那么编译器依旧会将该接口看做是函数式接口。</p>\n<p>那Lambda表达式跟函数式接口又有什么关联呢？<br>在JDK 1.8中，Lambda表达式是对象，而不是函数，它们必须依附于一类特别的对象类型–函数式接口。</p>\n<p>因此可以说 在JDK 1.8中，Lambda表达式就是一个函数式接口的实例。<br><strong>所以如果一个实例是函数式接口的实例，那么该对象就可以用Lambda表达式来表示</strong></p>\n<h2 id=\"二、Lambda表达式与匿名内部类\"><a href=\"#二、Lambda表达式与匿名内部类\" class=\"headerlink\" title=\"二、Lambda表达式与匿名内部类\"></a><strong>二、Lambda表达式与匿名内部类</strong></h2><p>我们知道代码IDE如果是在JDK1.8的环境下，使用匿名内部类作为一个参数传入到方法中，编译器会提示我们：<code>Anonymous new Runnable() can be replaced with lambda</code>，匿名内部类XXX可以替换为lambda表达式。</p>\n<p>如下所示，匿名内部类 Runnable是一个函数式接口的实例，所以我们可以用lambda表达式来将之替换，从而将代码变得更加简洁。<br><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly9vc2NpbWcub3NjaGluYS5uZXQvb3NjbmV0Lzc4YzgxZWMyZjkzMmE5MDhmOTcxM2NiZGM5ODRkOGFhMWI2LmpwZw?x-oss-process=image/format,png\"></p>\n<img src=\"https://cdn.julis.wang/blog/img/20191009170329915.png\">\n<p>那么我们是否就认为：Lambda表达式只是为匿名内部类中提供的一种语法糖，他们有什么区别呢？底层原理是完全一样的呢？</p>\n<p>他们主要区别如下：</p>\n<p>1、关键字this。匿名内部类的this指向匿名类，而Lambda表达式的this指向被Lambda包围的外部类</p>\n<p>2、编译方式。Java编译器将Lambda表达式编译成类的私有方法，使用Java7的invokedynamic字节码动态绑定这个方法。而匿名内部类将编译成<strong>外部类$数字编号</strong>的新类。这也造成第1点关键字this指向不同地方的原因。</p>\n<h2 id=\"三、Lambda实现原理\"><a href=\"#三、Lambda实现原理\" class=\"headerlink\" title=\"三、Lambda实现原理\"></a><strong>三、Lambda实现原理</strong></h2><p>我们知道如果使用匿名内部类，编译期间会生成一个外部类$数字编号的类，如图所示：</p>\n<img src=\"https://cdn.julis.wang/blog/img/20191009172403269.png\">\n\n<p>而如果使用Lambda表达式进行编译后并没有生成新类。</p>\n<img src=\"https://cdn.julis.wang/blog/img/20191009172455212.png\">\n<p>我们对Lambda表达式生成的class文件使用：javap -p -v Test.class 进行反编译生成如下内容，为便于观察，删除了一些无用内容</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">wang</span>.julis.jwbase.basecompact.Test</span><br><span class=\"line\"></span><br><span class=\"line\">Constant pool:</span><br><span class=\"line\">   #<span class=\"number\">1</span> = Methodref          #<span class=\"number\">9.</span>#<span class=\"number\">18</span>         <span class=\"comment\">// java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> wang.julis.jwbase.basecompact.Test();</span><br><span class=\"line\">    descriptor: ()V</span><br><span class=\"line\">    flags: (<span class=\"number\">0x0001</span>) ACC_PUBLIC</span><br><span class=\"line\">    Code:</span><br><span class=\"line\">      stack=<span class=\"number\">1</span>, locals=<span class=\"number\">1</span>, args_size=<span class=\"number\">1</span></span><br><span class=\"line\">         <span class=\"number\">0</span>: aload_0</span><br><span class=\"line\">         <span class=\"number\">1</span>: invokespecial #<span class=\"number\">1</span>                  <span class=\"comment\">// Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class=\"line\">         <span class=\"number\">4</span>: <span class=\"keyword\">return</span></span><br><span class=\"line\">      LineNumberTable:</span><br><span class=\"line\">        line <span class=\"number\">12</span>: <span class=\"number\">0</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">testLambda</span><span class=\"params\">()</span>;</span><br><span class=\"line\">    descriptor: ()V</span><br><span class=\"line\">    flags: (<span class=\"number\">0x0002</span>) ACC_PRIVATE</span><br><span class=\"line\">    Code:</span><br><span class=\"line\">      stack=<span class=\"number\">3</span>, locals=<span class=\"number\">1</span>, args_size=<span class=\"number\">1</span></span><br><span class=\"line\">         <span class=\"number\">0</span>: <span class=\"keyword\">new</span>           #<span class=\"number\">2</span>                  <span class=\"comment\">// class java/lang/Thread</span></span><br><span class=\"line\">         <span class=\"number\">3</span>: dup</span><br><span class=\"line\">         <span class=\"number\">4</span>: invokedynamic #<span class=\"number\">3</span>,  <span class=\"number\">0</span>              <span class=\"comment\">// InvokeDynamic #0:run:()Ljava/lang/Runnable;</span></span><br><span class=\"line\">         <span class=\"number\">9</span>: invokespecial #<span class=\"number\">4</span>                  <span class=\"comment\">// Method java/lang/Thread.&quot;&lt;init&gt;&quot;:(Ljava/lang/Runnable;)V</span></span><br><span class=\"line\">        <span class=\"number\">12</span>: pop</span><br><span class=\"line\">        <span class=\"number\">13</span>: <span class=\"keyword\">return</span></span><br><span class=\"line\">      LineNumberTable:</span><br><span class=\"line\">        line <span class=\"number\">14</span>: <span class=\"number\">0</span></span><br><span class=\"line\">        line <span class=\"number\">18</span>: <span class=\"number\">13</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> lambda$testLambda$<span class=\"number\">0</span>();</span><br><span class=\"line\">    descriptor: ()V</span><br><span class=\"line\">    flags: (<span class=\"number\">0x100a</span>) ACC_PRIVATE, ACC_STATIC, ACC_SYNTHETIC</span><br><span class=\"line\">    Code:</span><br><span class=\"line\">      stack=<span class=\"number\">2</span>, locals=<span class=\"number\">0</span>, args_size=<span class=\"number\">0</span></span><br><span class=\"line\">         <span class=\"number\">0</span>: getstatic     #<span class=\"number\">5</span>                  <span class=\"comment\">// Field java/lang/System.out:Ljava/io/PrintStream;</span></span><br><span class=\"line\">         <span class=\"number\">3</span>: ldc           #<span class=\"number\">6</span>                  <span class=\"comment\">// String lambda</span></span><br><span class=\"line\">         <span class=\"number\">5</span>: invokevirtual #<span class=\"number\">7</span>                  <span class=\"comment\">// Method java/io/PrintStream.println:(Ljava/lang/String;)V</span></span><br><span class=\"line\">         <span class=\"number\">8</span>: <span class=\"keyword\">return</span></span><br><span class=\"line\">      LineNumberTable:</span><br><span class=\"line\">        line <span class=\"number\">15</span>: <span class=\"number\">0</span></span><br><span class=\"line\">        line <span class=\"number\">16</span>: <span class=\"number\">8</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">SourceFile: <span class=\"string\">&quot;Test.java&quot;</span></span><br><span class=\"line\">InnerClasses:</span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> #<span class=\"number\">50</span>= #<span class=\"number\">49</span> of #<span class=\"number\">53</span>;    <span class=\"comment\">// Lookup=class java/lang/invoke/MethodHandles$Lookup of class java/lang/invoke/MethodHandles</span></span><br><span class=\"line\">BootstrapMethods:</span><br><span class=\"line\">  <span class=\"number\">0</span>: #<span class=\"number\">21</span> REF_invokeStatic java/lang/invoke/LambdaMetafactory.metafactory:(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite;</span><br><span class=\"line\">    Method arguments:</span><br><span class=\"line\">      #<span class=\"number\">22</span> ()V</span><br><span class=\"line\">      #<span class=\"number\">23</span> REF_invokeStatic wang/julis/jwbase/basecompact/Test.lambda$testLambda$<span class=\"number\">0</span>:()V</span><br><span class=\"line\">      #<span class=\"number\">22</span> ()V</span><br></pre></td></tr></table></figure>\n<p>从反编译的结果我们可以看到：</p>\n<p>1、编译期间自动生成私有静态类<code>lambda$testLambda$0</code>而这里面就就是lambda的具体实现逻辑</p>\n<p>2、使用invokedynamic去执行lambda表达式 关于invokedynamic命令具体细节可以参考： <a href=\"https://time.geekbang.org/column/article/12564\">08 | JVM是怎么实现invokedynamic的？（上）</a></p>\n<p>3、lambda表达式编译后并没有生成外部类$数字编号的类</p>\n<h2 id=\"总结：\"><a href=\"#总结：\" class=\"headerlink\" title=\"总结：\"></a>总结：</h2><p>1、函数式接口：有且仅有一个抽象方法，可以用非抽象方法1.8后支持</p>\n<p>2、匿名内部类的this指向匿名类，而Lambda表达式的this指向被Lambda包围的外部类</p>\n<p>3、lambda表达式编译后不会生成外部类$数字编号的类</p>\n<p>4、Java编译器将Lambda表达式编译成类的私有方法，使用Java7的invokedynamic字节码动态绑定这个方法。</p>\n<p>参考：<br>1、《深入探索Android热修复技术原理》2.3.8章节<br>2、<a href=\"https://blog.csdn.net/zw19910924/article/details/75907348\">Java8 lambda表达式、函数式接口、方法引用</a></p>\n","cover":null,"images":["https://imgconvert.csdnimg.cn/aHR0cHM6Ly9vc2NpbWcub3NjaGluYS5uZXQvb3NjbmV0Lzc4YzgxZWMyZjkzMmE5MDhmOTcxM2NiZGM5ODRkOGFhMWI2LmpwZw?x-oss-process=image/format,png","https://cdn.julis.wang/blog/img/20191009170329915.png","https://cdn.julis.wang/blog/img/20191009172403269.png","https://cdn.julis.wang/blog/img/20191009172455212.png"],"content":"<p>在大部分开发者看来，Lambda 表达式只是一种语法糖，简化了书写匿名内部类的写法。实际上Lambda表达式并不仅仅是匿名内部类的语法糖，JVM内部是通过invokedynamic指令来实现Lambda表达式的，与内部类的实现有很大的差异。本文主要记录lambda的实现原理。</p>\n<h2 id=\"一、函数式接口\"><a href=\"#一、函数式接口\" class=\"headerlink\" title=\"一、函数式接口\"></a><strong>一、函数式接口</strong></h2><p>众所周知Javascript具有一个强大的特性：<strong>闭包</strong>。Java中最接近闭包概念的东西就是lambda表达式了，而Lambda为Java添加了缺失函数式编程的特点。所以什么是函数是接口呢？</p>\n<p>函数式接口需满足以下两个条件：</p>\n<ol>\n<li>它是接口</li>\n<li>这个接口<strong>有且仅有一个抽象方法</strong></li>\n</ol>\n<p>例如我们常用的：Runnable、View.OnClickListener、Comparable等都是函数式接口，因为它们都只有一个方法，而且都是抽象的。虽然只有一个抽象方法，是不是就意味着只能有一个方法呢？实际并不是，虽然有且仅有一个抽象方法，但是可以有多个非抽象方法的接口。</p>\n<p>嗯？！Java接口中难道还可以定义非抽象方法么？平时我们的接口大概长这样：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">IdiomSubmitListener</span> &#123;</span><br><span class=\"line\">   \t<span class=\"keyword\">void</span> <span class=\"title function_\">verifyResult</span><span class=\"params\">(String result)</span>;</span><br><span class=\"line\">   \t<span class=\"keyword\">void</span> <span class=\"title function_\">onSuceess</span><span class=\"params\">()</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>那接口的非抽象方法是啥？原来在JDK 1.8 对于接口而言具有以下新特性：<br><strong>接口可以定义非抽象方法，但必须使用default或者staic关键字来修饰</strong><br>具体细节点可以参考 <a href=\"https://blog.csdn.net/austral/article/details/53402476\">JAVA 8新特性 允许接口定义非抽象方法 快速入门案例</a></p>\n<p>如果一个接口符合函数式接口的定义，那么我们就可以在该接口上面声明FunctionalInterface注解，用来表示该接口是一个函数式接口，并按照函数式接口的规范在编译的时候对该接口进行检查。</p>\n<p>当然如果某个接口只有一个抽象方法，但我们并没有给该接口声明FunctionalInterface注解，那么编译器依旧会将该接口看做是函数式接口。</p>\n<p>那Lambda表达式跟函数式接口又有什么关联呢？<br>在JDK 1.8中，Lambda表达式是对象，而不是函数，它们必须依附于一类特别的对象类型–函数式接口。</p>\n<p>因此可以说 在JDK 1.8中，Lambda表达式就是一个函数式接口的实例。<br><strong>所以如果一个实例是函数式接口的实例，那么该对象就可以用Lambda表达式来表示</strong></p>\n<h2 id=\"二、Lambda表达式与匿名内部类\"><a href=\"#二、Lambda表达式与匿名内部类\" class=\"headerlink\" title=\"二、Lambda表达式与匿名内部类\"></a><strong>二、Lambda表达式与匿名内部类</strong></h2><p>我们知道代码IDE如果是在JDK1.8的环境下，使用匿名内部类作为一个参数传入到方法中，编译器会提示我们：<code>Anonymous new Runnable() can be replaced with lambda</code>，匿名内部类XXX可以替换为lambda表达式。</p>\n<p>如下所示，匿名内部类 Runnable是一个函数式接口的实例，所以我们可以用lambda表达式来将之替换，从而将代码变得更加简洁。<br><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly9vc2NpbWcub3NjaGluYS5uZXQvb3NjbmV0Lzc4YzgxZWMyZjkzMmE5MDhmOTcxM2NiZGM5ODRkOGFhMWI2LmpwZw?x-oss-process=image/format,png\"></p>\n<img src=\"https://cdn.julis.wang/blog/img/20191009170329915.png\">\n<p>那么我们是否就认为：Lambda表达式只是为匿名内部类中提供的一种语法糖，他们有什么区别呢？底层原理是完全一样的呢？</p>\n<p>他们主要区别如下：</p>\n<p>1、关键字this。匿名内部类的this指向匿名类，而Lambda表达式的this指向被Lambda包围的外部类</p>\n<p>2、编译方式。Java编译器将Lambda表达式编译成类的私有方法，使用Java7的invokedynamic字节码动态绑定这个方法。而匿名内部类将编译成<strong>外部类$数字编号</strong>的新类。这也造成第1点关键字this指向不同地方的原因。</p>\n<h2 id=\"三、Lambda实现原理\"><a href=\"#三、Lambda实现原理\" class=\"headerlink\" title=\"三、Lambda实现原理\"></a><strong>三、Lambda实现原理</strong></h2><p>我们知道如果使用匿名内部类，编译期间会生成一个外部类$数字编号的类，如图所示：</p>\n<img src=\"https://cdn.julis.wang/blog/img/20191009172403269.png\">\n\n<p>而如果使用Lambda表达式进行编译后并没有生成新类。</p>\n<img src=\"https://cdn.julis.wang/blog/img/20191009172455212.png\">\n<p>我们对Lambda表达式生成的class文件使用：javap -p -v Test.class 进行反编译生成如下内容，为便于观察，删除了一些无用内容</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">wang</span>.julis.jwbase.basecompact.Test</span><br><span class=\"line\"></span><br><span class=\"line\">Constant pool:</span><br><span class=\"line\">   #<span class=\"number\">1</span> = Methodref          #<span class=\"number\">9.</span>#<span class=\"number\">18</span>         <span class=\"comment\">// java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> wang.julis.jwbase.basecompact.Test();</span><br><span class=\"line\">    descriptor: ()V</span><br><span class=\"line\">    flags: (<span class=\"number\">0x0001</span>) ACC_PUBLIC</span><br><span class=\"line\">    Code:</span><br><span class=\"line\">      stack=<span class=\"number\">1</span>, locals=<span class=\"number\">1</span>, args_size=<span class=\"number\">1</span></span><br><span class=\"line\">         <span class=\"number\">0</span>: aload_0</span><br><span class=\"line\">         <span class=\"number\">1</span>: invokespecial #<span class=\"number\">1</span>                  <span class=\"comment\">// Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class=\"line\">         <span class=\"number\">4</span>: <span class=\"keyword\">return</span></span><br><span class=\"line\">      LineNumberTable:</span><br><span class=\"line\">        line <span class=\"number\">12</span>: <span class=\"number\">0</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">testLambda</span><span class=\"params\">()</span>;</span><br><span class=\"line\">    descriptor: ()V</span><br><span class=\"line\">    flags: (<span class=\"number\">0x0002</span>) ACC_PRIVATE</span><br><span class=\"line\">    Code:</span><br><span class=\"line\">      stack=<span class=\"number\">3</span>, locals=<span class=\"number\">1</span>, args_size=<span class=\"number\">1</span></span><br><span class=\"line\">         <span class=\"number\">0</span>: <span class=\"keyword\">new</span>           #<span class=\"number\">2</span>                  <span class=\"comment\">// class java/lang/Thread</span></span><br><span class=\"line\">         <span class=\"number\">3</span>: dup</span><br><span class=\"line\">         <span class=\"number\">4</span>: invokedynamic #<span class=\"number\">3</span>,  <span class=\"number\">0</span>              <span class=\"comment\">// InvokeDynamic #0:run:()Ljava/lang/Runnable;</span></span><br><span class=\"line\">         <span class=\"number\">9</span>: invokespecial #<span class=\"number\">4</span>                  <span class=\"comment\">// Method java/lang/Thread.&quot;&lt;init&gt;&quot;:(Ljava/lang/Runnable;)V</span></span><br><span class=\"line\">        <span class=\"number\">12</span>: pop</span><br><span class=\"line\">        <span class=\"number\">13</span>: <span class=\"keyword\">return</span></span><br><span class=\"line\">      LineNumberTable:</span><br><span class=\"line\">        line <span class=\"number\">14</span>: <span class=\"number\">0</span></span><br><span class=\"line\">        line <span class=\"number\">18</span>: <span class=\"number\">13</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> lambda$testLambda$<span class=\"number\">0</span>();</span><br><span class=\"line\">    descriptor: ()V</span><br><span class=\"line\">    flags: (<span class=\"number\">0x100a</span>) ACC_PRIVATE, ACC_STATIC, ACC_SYNTHETIC</span><br><span class=\"line\">    Code:</span><br><span class=\"line\">      stack=<span class=\"number\">2</span>, locals=<span class=\"number\">0</span>, args_size=<span class=\"number\">0</span></span><br><span class=\"line\">         <span class=\"number\">0</span>: getstatic     #<span class=\"number\">5</span>                  <span class=\"comment\">// Field java/lang/System.out:Ljava/io/PrintStream;</span></span><br><span class=\"line\">         <span class=\"number\">3</span>: ldc           #<span class=\"number\">6</span>                  <span class=\"comment\">// String lambda</span></span><br><span class=\"line\">         <span class=\"number\">5</span>: invokevirtual #<span class=\"number\">7</span>                  <span class=\"comment\">// Method java/io/PrintStream.println:(Ljava/lang/String;)V</span></span><br><span class=\"line\">         <span class=\"number\">8</span>: <span class=\"keyword\">return</span></span><br><span class=\"line\">      LineNumberTable:</span><br><span class=\"line\">        line <span class=\"number\">15</span>: <span class=\"number\">0</span></span><br><span class=\"line\">        line <span class=\"number\">16</span>: <span class=\"number\">8</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">SourceFile: <span class=\"string\">&quot;Test.java&quot;</span></span><br><span class=\"line\">InnerClasses:</span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> #<span class=\"number\">50</span>= #<span class=\"number\">49</span> of #<span class=\"number\">53</span>;    <span class=\"comment\">// Lookup=class java/lang/invoke/MethodHandles$Lookup of class java/lang/invoke/MethodHandles</span></span><br><span class=\"line\">BootstrapMethods:</span><br><span class=\"line\">  <span class=\"number\">0</span>: #<span class=\"number\">21</span> REF_invokeStatic java/lang/invoke/LambdaMetafactory.metafactory:(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite;</span><br><span class=\"line\">    Method arguments:</span><br><span class=\"line\">      #<span class=\"number\">22</span> ()V</span><br><span class=\"line\">      #<span class=\"number\">23</span> REF_invokeStatic wang/julis/jwbase/basecompact/Test.lambda$testLambda$<span class=\"number\">0</span>:()V</span><br><span class=\"line\">      #<span class=\"number\">22</span> ()V</span><br></pre></td></tr></table></figure>\n<p>从反编译的结果我们可以看到：</p>\n<p>1、编译期间自动生成私有静态类<code>lambda$testLambda$0</code>而这里面就就是lambda的具体实现逻辑</p>\n<p>2、使用invokedynamic去执行lambda表达式 关于invokedynamic命令具体细节可以参考： <a href=\"https://time.geekbang.org/column/article/12564\">08 | JVM是怎么实现invokedynamic的？（上）</a></p>\n<p>3、lambda表达式编译后并没有生成外部类$数字编号的类</p>\n<h2 id=\"总结：\"><a href=\"#总结：\" class=\"headerlink\" title=\"总结：\"></a>总结：</h2><p>1、函数式接口：有且仅有一个抽象方法，可以用非抽象方法1.8后支持</p>\n<p>2、匿名内部类的this指向匿名类，而Lambda表达式的this指向被Lambda包围的外部类</p>\n<p>3、lambda表达式编译后不会生成外部类$数字编号的类</p>\n<p>4、Java编译器将Lambda表达式编译成类的私有方法，使用Java7的invokedynamic字节码动态绑定这个方法。</p>\n<p>参考：<br>1、《深入探索Android热修复技术原理》2.3.8章节<br>2、<a href=\"https://blog.csdn.net/zw19910924/article/details/75907348\">Java8 lambda表达式、函数式接口、方法引用</a></p>\n","categories":[{"name":"技术文章","slug":"technology","api":"api/categories/technology.json"}],"tags":[{"name":"Java","slug":"java","api":"api/tags/java.json"}],"api":"api/posts/2019/10/09/Java中Lambda表达式解析.json"},{"title":"观《百鸟朝凤》有感","slug":"观《百鸟朝凤》有感","date":"2019-09-07T18:16:00.000Z","updated":"2025-05-20T11:46:57.000Z","comments":true,"url":"2019/09/08/观《百鸟朝凤》有感/","excerpt":"<p>此刻子时，在朋友的推荐下看完了整部《百鸟朝凤》，看完之后我立马起身来打开电脑，心中思绪万千，准备写下来记录下来。自我观看了这么多电影以来，头一次是如此的触动，头一次留下来这样的眼泪，记得上一次很有感触还是因为《忠犬八公的故事》，那次泪水到了眼角，我忍住了，没有掉下来。这部电影实在是让我太感动了，我的泪水憋不下去了，源源不断地从眼眶里面流出来。我捂着自己的嘴巴，我怕自己嚎啕大哭起来，不停地抽泣。对一代匠人的崇敬之情，当然也让我想起来那个人……</p>\n<p>   他已经离我六年之余，从离开他之后，我的梦大部分都是关于他，梦中的情节很多都是让我感觉他躲起来了，然后又出现再了我的面前。每次梦醒，思前想后，万端交集，竟不能复寐，他便是我的爷爷-兴武老大人。</p>\n<p>   关于他的记忆开始慢慢变得模糊，有很多事情都已经忘记，但又有很多我根本不能忘记。影片中的焦师傅，爷爷的形象简直和他一模一样，都一样抽着大烟，瘦弱的身躯，头顶的中间光秃秃的，走路总是半佝偻着腰，但是眼神又是那么的坚毅。他们都对传统文化有着独特的情感，我的爷爷也算是一个匠人，他是一名竹匠（“四川话叫 mie匠”），他只告诉过我，那个年代他们靠卖竹制的东西（大抵是一些席子、竹帘、晒席之类的东西）过日子，每天都帮着各种编织，才养活了包括我爸在内的五个子女。家中很多东西，也都是竹子做的。在我小的时候，我记得基本上我们整个村，每家每户都有一片属于自家的竹林，它不仅能提供我们编制各种东西的原材料，也能提供做饭生火的材料。在我现在看来，它更能提供那种接近大自然的方式。每当夜里，如果有阵阵微风，竹林中便会的竹叶洒洒作响的声音，我也很久没有听到这种声音了。</p>\n<p>   如果我看到我的爷爷拿着一把弯刀去后院，那我一定知道他应该是要去砍竹子，只听哐哐哐一阵声，竹子便倒了下来，他会剔除掉竹子的枝丫，以及顶部较为脆弱细小的部分。然后用取当中的一节，再用刀将其剖开，根据所做的东西的不同，会将竹子的圆分成不同的等分。然后会做一个比较难得的操作，具体用文字表达我也不知道该用什么术语去说，就是将竹子外层坚韧的部分与内部相分离，分离后的竹条厚度均匀。这便是编制前的准备阶段，对于编制一些特殊的物品，竹条可能还会经过一些其他一些操作才能继续编制。</p>\n<p>   为了编一个撮箕或者簸箕，爷爷可能会花上一整天的时间，弯腰在地一点一点的编织着。我经常在旁边看着，我可能也想去尝试，但一不下心手就会因为竹子的锋利而流血。而爷爷的手并不一样，我记得他的手上有很多老茧，手指头也特别的硬，我感觉他的手就像带了一个硬皮手套一样，这都是岁月留下来的痕迹吧。他总是给我讲他们过去的故事，也会给我讲解人生大道理。他给我讲梁山伯与祝英台的故事，他也给我讲毛泽东，他也讲以前文化大革命的故事……讲以前生活是多么的不容易，他们遭受了多少苦，我都还记得。爷爷编织好的竹制品真的很精致耐用，家里现在也还留着一些当时他编好的东西。我觉得那都是艺术品，都是源于一个人对生活的热爱以及对匠人的诠释吧。</p>\n<p>   后来搬家了，原先家里的那片竹林离我们有一些距离，我爸想把它们都挖了卖掉，因为现在我们不需要那么多竹子了。我爷爷当然不允许啊！卖掉？直接就跟我爸翻脸。在我看来，那片竹林可能承载了太多爷爷的记忆吧，太多的舍不得。但爷爷去世之后，那片竹林还是被移除掉了，实在痛惜。我后悔没有跟我的爷爷学这些编制技术，我爸会一些，但是我认为他只是一个半吊子，和爷爷做的东西比起来实在是差太多了。我爸曾说：“现在谁还做那些啊？有钱我们可以买。”，对于他的话我有反驳过。买来的那些都是些没有被注入感情的废铜烂铁吧，与爷爷的东西差太远了。或许真的因为时代的发展吧，这些东西渐渐地都被淘汰掉了，但我认为这些都是才是真正应该被传承下来的，不仅仅是因为这一门技术，更多的那一份精神吧。是用钱买不来的，机器造不来的。</p>\n<p>   《百鸟朝凤》这部电影令人肃然起敬，质朴的人物形象，体现出来了当代中国传统文化的潦倒与窘境，传承不是说说而已，是每一个中国人应该有的责任。在现代多元文化的冲击下，更多人的失去了对精神的追求和向往，取而代之的是短暂的愉悦刺激以及碎片化的东西。<br>我们的生活其实可以更有内涵……</p>\n<p>困了，就写这么多吧，讲了一些乱七八糟的东西，懂得人自然懂吧。</p>\n<p>晚安~</p>\n<p><img src=\"https://pica.zhimg.com/70/fca270cbac1c48fb0f343fa336c23b3a_1440w.avis?source=172ae18b&biz_tag=Post\"></p>\n","cover":null,"images":["https://pica.zhimg.com/70/fca270cbac1c48fb0f343fa336c23b3a_1440w.avis?source=172ae18b&biz_tag=Post"],"content":"<p>此刻子时，在朋友的推荐下看完了整部《百鸟朝凤》，看完之后我立马起身来打开电脑，心中思绪万千，准备写下来记录下来。自我观看了这么多电影以来，头一次是如此的触动，头一次留下来这样的眼泪，记得上一次很有感触还是因为《忠犬八公的故事》，那次泪水到了眼角，我忍住了，没有掉下来。这部电影实在是让我太感动了，我的泪水憋不下去了，源源不断地从眼眶里面流出来。我捂着自己的嘴巴，我怕自己嚎啕大哭起来，不停地抽泣。对一代匠人的崇敬之情，当然也让我想起来那个人……</p>\n<p>   他已经离我六年之余，从离开他之后，我的梦大部分都是关于他，梦中的情节很多都是让我感觉他躲起来了，然后又出现再了我的面前。每次梦醒，思前想后，万端交集，竟不能复寐，他便是我的爷爷-兴武老大人。</p>\n<p>   关于他的记忆开始慢慢变得模糊，有很多事情都已经忘记，但又有很多我根本不能忘记。影片中的焦师傅，爷爷的形象简直和他一模一样，都一样抽着大烟，瘦弱的身躯，头顶的中间光秃秃的，走路总是半佝偻着腰，但是眼神又是那么的坚毅。他们都对传统文化有着独特的情感，我的爷爷也算是一个匠人，他是一名竹匠（“四川话叫 mie匠”），他只告诉过我，那个年代他们靠卖竹制的东西（大抵是一些席子、竹帘、晒席之类的东西）过日子，每天都帮着各种编织，才养活了包括我爸在内的五个子女。家中很多东西，也都是竹子做的。在我小的时候，我记得基本上我们整个村，每家每户都有一片属于自家的竹林，它不仅能提供我们编制各种东西的原材料，也能提供做饭生火的材料。在我现在看来，它更能提供那种接近大自然的方式。每当夜里，如果有阵阵微风，竹林中便会的竹叶洒洒作响的声音，我也很久没有听到这种声音了。</p>\n<p>   如果我看到我的爷爷拿着一把弯刀去后院，那我一定知道他应该是要去砍竹子，只听哐哐哐一阵声，竹子便倒了下来，他会剔除掉竹子的枝丫，以及顶部较为脆弱细小的部分。然后用取当中的一节，再用刀将其剖开，根据所做的东西的不同，会将竹子的圆分成不同的等分。然后会做一个比较难得的操作，具体用文字表达我也不知道该用什么术语去说，就是将竹子外层坚韧的部分与内部相分离，分离后的竹条厚度均匀。这便是编制前的准备阶段，对于编制一些特殊的物品，竹条可能还会经过一些其他一些操作才能继续编制。</p>\n<p>   为了编一个撮箕或者簸箕，爷爷可能会花上一整天的时间，弯腰在地一点一点的编织着。我经常在旁边看着，我可能也想去尝试，但一不下心手就会因为竹子的锋利而流血。而爷爷的手并不一样，我记得他的手上有很多老茧，手指头也特别的硬，我感觉他的手就像带了一个硬皮手套一样，这都是岁月留下来的痕迹吧。他总是给我讲他们过去的故事，也会给我讲解人生大道理。他给我讲梁山伯与祝英台的故事，他也给我讲毛泽东，他也讲以前文化大革命的故事……讲以前生活是多么的不容易，他们遭受了多少苦，我都还记得。爷爷编织好的竹制品真的很精致耐用，家里现在也还留着一些当时他编好的东西。我觉得那都是艺术品，都是源于一个人对生活的热爱以及对匠人的诠释吧。</p>\n<p>   后来搬家了，原先家里的那片竹林离我们有一些距离，我爸想把它们都挖了卖掉，因为现在我们不需要那么多竹子了。我爷爷当然不允许啊！卖掉？直接就跟我爸翻脸。在我看来，那片竹林可能承载了太多爷爷的记忆吧，太多的舍不得。但爷爷去世之后，那片竹林还是被移除掉了，实在痛惜。我后悔没有跟我的爷爷学这些编制技术，我爸会一些，但是我认为他只是一个半吊子，和爷爷做的东西比起来实在是差太多了。我爸曾说：“现在谁还做那些啊？有钱我们可以买。”，对于他的话我有反驳过。买来的那些都是些没有被注入感情的废铜烂铁吧，与爷爷的东西差太远了。或许真的因为时代的发展吧，这些东西渐渐地都被淘汰掉了，但我认为这些都是才是真正应该被传承下来的，不仅仅是因为这一门技术，更多的那一份精神吧。是用钱买不来的，机器造不来的。</p>\n<p>   《百鸟朝凤》这部电影令人肃然起敬，质朴的人物形象，体现出来了当代中国传统文化的潦倒与窘境，传承不是说说而已，是每一个中国人应该有的责任。在现代多元文化的冲击下，更多人的失去了对精神的追求和向往，取而代之的是短暂的愉悦刺激以及碎片化的东西。<br>我们的生活其实可以更有内涵……</p>\n<p>困了，就写这么多吧，讲了一些乱七八糟的东西，懂得人自然懂吧。</p>\n<p>晚安~</p>\n<p><img src=\"https://pica.zhimg.com/70/fca270cbac1c48fb0f343fa336c23b3a_1440w.avis?source=172ae18b&biz_tag=Post\"></p>\n","categories":[{"name":"读书电影","slug":"movie","api":"api/categories/movie.json"}],"tags":[{"name":"省","slug":"thinking","api":"api/tags/thinking.json"}],"api":"api/posts/2019/09/08/观《百鸟朝凤》有感.json"},{"title":"Android骨架屏效果的实现与原理解析","slug":"Android骨架屏效果的实现与原理解析","date":"2019-09-04T09:50:00.000Z","updated":"2025-05-20T11:46:57.000Z","comments":true,"url":"2019/09/04/Android骨架屏效果的实现与原理解析/","excerpt":"<p>大家在使用淘宝的时候，如下图所示有遇到这样的效果，其会只展示一部分骨架大致图，等数据加载完毕之后再展示真正的页面数据。与菊花图相比起来，这样的实现能更好的提升用户的体验，这种效果称做：Skeleton Screen Loading，中文叫做<strong>骨架屏</strong>，本文主要记录其实现过程。</p>\n<h2 id=\"1、骨架屏的实现方式\"><a href=\"#1、骨架屏的实现方式\" class=\"headerlink\" title=\"1、骨架屏的实现方式\"></a>1、骨架屏的实现方式</h2><img src=\"https://cdn.julis.wang/blog/img/b911cd8e3eba7fdc4bea89ad6cb07bf4a7d.png\">\n<p>在现在主流的骨架屏实现效果中有两种方式：</p>\n<ul>\n<li><p>通过View或者Adapter的替换来实现骨架屏效果。可以参考<a href=\"https://github.com/sharish/ShimmerRecyclerView\">ShimmerRecyclerView</a>、<a href=\"https://github.com/ethanhua/Skeleton\">Skeleton</a>及<a href=\"https://github.com/willowtreeapps/spruce-android\">spruce-android</a>。</p>\n</li>\n<li><p>自定义一个View来对布局中的View进行一层包裹，当加载数据时则根据View来绘制骨架，否则显示正常UI，参考<a href=\"https://github.com/rasoulmiri/Skeleton\">Skeleton Android</a>。</p>\n</li>\n</ul>\n<p>这些开源库中，自己比较喜欢今天<strong>Skeleton</strong>这个开源库，总结了有如下一些优缺点：</p>\n<p><strong>优点：</strong></p>\n<ol>\n<li>代码方案实现及使用方式简单，通过替换View和Adapter实现效果，使用Builder设计模式来构造。</li>\n<li>代码耦合程度不高。没有复杂的设计模式，使得代码结构清晰明了。</li>\n<li>骨架屏的效果使用相对于较灵活，可以对整个布局实现骨架屏效果，也可以对单一View实现骨架屏效果。</li>\n</ol>\n<p><strong>缺点：</strong></p>\n<ol>\n<li>需要对每个骨架屏效果单独写一套xml布局。</li>\n<li>使用的removeView和addView对 原有布局的view进行替换，存在一定的风险性</li>\n<li>必须清晰的知道所bind的View类型，存在一定的类型转化问题。</li>\n<li>依赖了shimmerlayout第三方库</li>\n</ol>\n<h2 id=\"2、Skeleton解读\"><a href=\"#2、Skeleton解读\" class=\"headerlink\" title=\"2、Skeleton解读\"></a>2、Skeleton解读</h2><p><strong>一、Skeleton的使用方式</strong></p>\n<p>展示骨架屏效果：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">View</span> <span class=\"variable\">rootView</span> <span class=\"operator\">=</span> findViewById(R.id.rootView);</span><br><span class=\"line\">skeletonScreen = Skeleton.bind(rootView)</span><br><span class=\"line\">           .load(R.layout.activity_view_skeleton)<span class=\"comment\">//骨架屏UI</span></span><br><span class=\"line\">           .duration(<span class=\"number\">1000</span>)<span class=\"comment\">//动画时间，以毫秒为单位</span></span><br><span class=\"line\">           .shimmer(<span class=\"literal\">true</span>)<span class=\"comment\">//是否开启动画</span></span><br><span class=\"line\">           .color(R.color.shimmer_color)<span class=\"comment\">//shimmer的颜色</span></span><br><span class=\"line\">           .angle(<span class=\"number\">30</span>)<span class=\"comment\">//shimmer的倾斜角度</span></span><br><span class=\"line\">           .show();</span><br></pre></td></tr></table></figure>\n<p>关闭骨架屏效果并展示原有View：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">skeletonScreen.hide()</span><br></pre></td></tr></table></figure>\n\n<p><strong>流程：</strong></p>\n<p> <strong>1. 选择需要替换的目标view<br> 2. 将骨架效果xml与目标view进行绑定<br> 3. 添加一些效果属性，比如：动画时间、是否开启展示动画、动画颜色等<br> 4. 在合适的实际关闭骨架屏效果</strong></p>\n<p><strong>二、Skeleton源码实现</strong></p>\n<p>Skeleton提供两个绑定方法，分别绑定普通View与RecyclerView，分别返回对应的Builder</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Skeleton</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> RecyclerViewSkeletonScreen.Builder <span class=\"title function_\">bind</span><span class=\"params\">(RecyclerView recyclerView)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">RecyclerViewSkeletonScreen</span>.Builder(recyclerView);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> ViewSkeletonScreen.Builder <span class=\"title function_\">bind</span><span class=\"params\">(View view)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ViewSkeletonScreen</span>.Builder(view);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们首先来看看如何实现与普通View绑定，构造方法中传入目标View，并对shimmer动画效果设置默认的颜色，在Builder里面我们可以看到各种相关参数的设定。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"title function_\">Builder</span><span class=\"params\">(View view)</span> &#123;</span><br><span class=\"line\">\t<span class=\"built_in\">this</span>.mView = view;</span><br><span class=\"line\">\t<span class=\"built_in\">this</span>.mShimmerColor = ContextCompat.getColor(mView.getContext(), R.color.shimmer_color);</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<p>接下来再到show的步骤，主要实现还是由ViewSkeletonScreen来实现</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> ViewSkeletonScreen <span class=\"title function_\">show</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">ViewSkeletonScreen</span> <span class=\"variable\">skeletonScreen</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ViewSkeletonScreen</span>(<span class=\"built_in\">this</span>);</span><br><span class=\"line\">    skeletonScreen.show();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> skeletonScreen;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>其中ViewSkeletonScreen与绑定的RecyclerViewSkeletonScreen都实现了SkeletonScreen接口，SkeletonScreen有两个接口方法分别是   </p>\n<pre><code>void show();\nvoid hide();\n</code></pre>\n<p>对于ViewSkeletonScreen.show()进入源码，这里出现一个比较重要的类<code>ViewReplacer</code>，等下再进行解析，通过show的源码清楚的知道逻辑：<br><strong>1、生成骨架效果View<br>2、利用生成的View替换目标View。</strong><br>其中生成骨架效果View阶段主要还是通过LayoutInflater去加载传入mSkeletonResID</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">show</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">       <span class=\"type\">View</span> <span class=\"variable\">skeletonLoadingView</span> <span class=\"operator\">=</span> generateSkeletonLoadingView();</span><br><span class=\"line\">       <span class=\"keyword\">if</span> (skeletonLoadingView != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">           mViewReplacer.replace(skeletonLoadingView);</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n<p>接下来主要讲解ViewReplacer类，其构造方法传入目标View</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"title function_\">ViewReplacer</span><span class=\"params\">(View sourceView)</span> &#123;</span><br><span class=\"line\">     mSourceView = sourceView;</span><br><span class=\"line\">     mSourceViewLayoutParams = mSourceView.getLayoutParams();</span><br><span class=\"line\">     mCurrentView = mSourceView;</span><br><span class=\"line\">     mSourceViewId = mSourceView.getId();</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n<p>其比较重要的方法有两个：<code>replace()</code> 和 <code>restore()</code> 这两个方法分别为SkeletonScreen 的show()和hide()的最终实现，首先看<code>replace()</code>方法，有两个方法重载，分别传入<code>targetViewResID</code>或者<code>targetView</code>，最终还是会走到<code>replace(View targetView)</code>中。<br>其主要逻辑为：</p>\n<p> <strong>1. 判断所替换的View和骨架屏效果View是否为同一个View<br> 2. remove掉在父布局中的目标View<br> 3. 将骨架屏效果View添加到目标View的父布局中</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">replace</span><span class=\"params\">(<span class=\"type\">int</span> targetViewResID)</span> &#123;</span><br><span class=\"line\">       <span class=\"keyword\">if</span> (mTargetViewResID == targetViewResID) &#123;</span><br><span class=\"line\">           <span class=\"keyword\">return</span>;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       <span class=\"keyword\">if</span> (init()) &#123;</span><br><span class=\"line\">           mTargetViewResID = targetViewResID;</span><br><span class=\"line\">           replace(LayoutInflater.from(mSourceView.getContext()).inflate(mTargetViewResID, mSourceParentView, <span class=\"literal\">false</span>));</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">replace</span><span class=\"params\">(View targetView)</span> &#123;</span><br><span class=\"line\">       <span class=\"keyword\">if</span> (mCurrentView == targetView) &#123;</span><br><span class=\"line\">           <span class=\"keyword\">return</span>;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       <span class=\"keyword\">if</span> (targetView.getParent() != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">           ((ViewGroup) targetView.getParent()).removeView(targetView);</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       <span class=\"keyword\">if</span> (init()) &#123;</span><br><span class=\"line\">           mTargetView = targetView;</span><br><span class=\"line\">           mSourceParentView.removeView(mCurrentView);</span><br><span class=\"line\">           mTargetView.setId(mSourceViewId);</span><br><span class=\"line\">           mSourceParentView.addView(mTargetView, mSourceViewIndexInParent, mSourceViewLayoutParams);</span><br><span class=\"line\">           mCurrentView = mTargetView;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n\n<p>在执行添加到目标View的父布局中，有执行一个init方法，主要做两件事：</p>\n<p> <strong>1. 获取目标View的父View<br> 2. 找到目标View在父View 中的位置索引，为之后添加骨架屏View到父View中做铺垫</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"type\">boolean</span> <span class=\"title function_\">init</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">     <span class=\"keyword\">if</span> (mSourceParentView == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">         mSourceParentView = (ViewGroup) mSourceView.getParent();</span><br><span class=\"line\">         <span class=\"keyword\">if</span> (mSourceParentView == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">             Log.e(TAG, <span class=\"string\">&quot;the source view have not attach to any view&quot;</span>);</span><br><span class=\"line\">             <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">         <span class=\"type\">int</span> <span class=\"variable\">count</span> <span class=\"operator\">=</span> mSourceParentView.getChildCount();</span><br><span class=\"line\">         <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">index</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; index &lt; count; index++) &#123;</span><br><span class=\"line\">             <span class=\"keyword\">if</span> (mSourceView == mSourceParentView.getChildAt(index)) &#123;</span><br><span class=\"line\">                 mSourceViewIndexInParent = index;</span><br><span class=\"line\">                 <span class=\"keyword\">break</span>;</span><br><span class=\"line\">             &#125;</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">     <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n<p>至此对普通View的骨架屏效果实现流程已经完全梳理完成，那对于<code>RecyclerView</code>呢？其实两者实现逻辑差不多，主要有两个差异：</p>\n<ol>\n<li>在<code>RecyclerViewSkeletonScreen</code>的Builder中，相比ViewSkeletonScreen多了一个adapter()方法，传入目标<code>RecyclerView</code>的<code>Adapter</code></li>\n<li>在show的时候对目标<code>RecyclerView</code>的adapter进行替换，使用骨架屏效果的adapter。hide的时候恢复为原先的Adapter</li>\n</ol>\n<h2 id=\"3、总结\"><a href=\"#3、总结\" class=\"headerlink\" title=\"3、总结\"></a>3、总结</h2><ol>\n<li>Skeleton的原理主要是通过替换目标View和RecyclerView的Adapter</li>\n<li>在Skeleton的使用过程中最需要关心的两个问题是：show()和hide()的时机</li>\n<li>对于整个页面的骨架屏效果实现，个人推荐在布局中添加一个全屏的空View盖在原先内容上</li>\n<li>注意一些异常情况下的hide()，要不然整个页面就“假死”状态了。</li>\n</ol>\n<p>参考：<br><a href=\"https://juejin.im/post/5c789a4ce51d457c042d3b31\">https://juejin.im/post/5c789a4ce51d457c042d3b31</a></p>\n","cover":null,"images":["https://cdn.julis.wang/blog/img/b911cd8e3eba7fdc4bea89ad6cb07bf4a7d.png"],"content":"<p>大家在使用淘宝的时候，如下图所示有遇到这样的效果，其会只展示一部分骨架大致图，等数据加载完毕之后再展示真正的页面数据。与菊花图相比起来，这样的实现能更好的提升用户的体验，这种效果称做：Skeleton Screen Loading，中文叫做<strong>骨架屏</strong>，本文主要记录其实现过程。</p>\n<h2 id=\"1、骨架屏的实现方式\"><a href=\"#1、骨架屏的实现方式\" class=\"headerlink\" title=\"1、骨架屏的实现方式\"></a>1、骨架屏的实现方式</h2><img src=\"https://cdn.julis.wang/blog/img/b911cd8e3eba7fdc4bea89ad6cb07bf4a7d.png\">\n<p>在现在主流的骨架屏实现效果中有两种方式：</p>\n<ul>\n<li><p>通过View或者Adapter的替换来实现骨架屏效果。可以参考<a href=\"https://github.com/sharish/ShimmerRecyclerView\">ShimmerRecyclerView</a>、<a href=\"https://github.com/ethanhua/Skeleton\">Skeleton</a>及<a href=\"https://github.com/willowtreeapps/spruce-android\">spruce-android</a>。</p>\n</li>\n<li><p>自定义一个View来对布局中的View进行一层包裹，当加载数据时则根据View来绘制骨架，否则显示正常UI，参考<a href=\"https://github.com/rasoulmiri/Skeleton\">Skeleton Android</a>。</p>\n</li>\n</ul>\n<p>这些开源库中，自己比较喜欢今天<strong>Skeleton</strong>这个开源库，总结了有如下一些优缺点：</p>\n<p><strong>优点：</strong></p>\n<ol>\n<li>代码方案实现及使用方式简单，通过替换View和Adapter实现效果，使用Builder设计模式来构造。</li>\n<li>代码耦合程度不高。没有复杂的设计模式，使得代码结构清晰明了。</li>\n<li>骨架屏的效果使用相对于较灵活，可以对整个布局实现骨架屏效果，也可以对单一View实现骨架屏效果。</li>\n</ol>\n<p><strong>缺点：</strong></p>\n<ol>\n<li>需要对每个骨架屏效果单独写一套xml布局。</li>\n<li>使用的removeView和addView对 原有布局的view进行替换，存在一定的风险性</li>\n<li>必须清晰的知道所bind的View类型，存在一定的类型转化问题。</li>\n<li>依赖了shimmerlayout第三方库</li>\n</ol>\n<h2 id=\"2、Skeleton解读\"><a href=\"#2、Skeleton解读\" class=\"headerlink\" title=\"2、Skeleton解读\"></a>2、Skeleton解读</h2><p><strong>一、Skeleton的使用方式</strong></p>\n<p>展示骨架屏效果：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">View</span> <span class=\"variable\">rootView</span> <span class=\"operator\">=</span> findViewById(R.id.rootView);</span><br><span class=\"line\">skeletonScreen = Skeleton.bind(rootView)</span><br><span class=\"line\">           .load(R.layout.activity_view_skeleton)<span class=\"comment\">//骨架屏UI</span></span><br><span class=\"line\">           .duration(<span class=\"number\">1000</span>)<span class=\"comment\">//动画时间，以毫秒为单位</span></span><br><span class=\"line\">           .shimmer(<span class=\"literal\">true</span>)<span class=\"comment\">//是否开启动画</span></span><br><span class=\"line\">           .color(R.color.shimmer_color)<span class=\"comment\">//shimmer的颜色</span></span><br><span class=\"line\">           .angle(<span class=\"number\">30</span>)<span class=\"comment\">//shimmer的倾斜角度</span></span><br><span class=\"line\">           .show();</span><br></pre></td></tr></table></figure>\n<p>关闭骨架屏效果并展示原有View：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">skeletonScreen.hide()</span><br></pre></td></tr></table></figure>\n\n<p><strong>流程：</strong></p>\n<p> <strong>1. 选择需要替换的目标view<br> 2. 将骨架效果xml与目标view进行绑定<br> 3. 添加一些效果属性，比如：动画时间、是否开启展示动画、动画颜色等<br> 4. 在合适的实际关闭骨架屏效果</strong></p>\n<p><strong>二、Skeleton源码实现</strong></p>\n<p>Skeleton提供两个绑定方法，分别绑定普通View与RecyclerView，分别返回对应的Builder</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Skeleton</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> RecyclerViewSkeletonScreen.Builder <span class=\"title function_\">bind</span><span class=\"params\">(RecyclerView recyclerView)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">RecyclerViewSkeletonScreen</span>.Builder(recyclerView);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> ViewSkeletonScreen.Builder <span class=\"title function_\">bind</span><span class=\"params\">(View view)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ViewSkeletonScreen</span>.Builder(view);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们首先来看看如何实现与普通View绑定，构造方法中传入目标View，并对shimmer动画效果设置默认的颜色，在Builder里面我们可以看到各种相关参数的设定。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"title function_\">Builder</span><span class=\"params\">(View view)</span> &#123;</span><br><span class=\"line\">\t<span class=\"built_in\">this</span>.mView = view;</span><br><span class=\"line\">\t<span class=\"built_in\">this</span>.mShimmerColor = ContextCompat.getColor(mView.getContext(), R.color.shimmer_color);</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<p>接下来再到show的步骤，主要实现还是由ViewSkeletonScreen来实现</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> ViewSkeletonScreen <span class=\"title function_\">show</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">ViewSkeletonScreen</span> <span class=\"variable\">skeletonScreen</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ViewSkeletonScreen</span>(<span class=\"built_in\">this</span>);</span><br><span class=\"line\">    skeletonScreen.show();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> skeletonScreen;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>其中ViewSkeletonScreen与绑定的RecyclerViewSkeletonScreen都实现了SkeletonScreen接口，SkeletonScreen有两个接口方法分别是   </p>\n<pre><code>void show();\nvoid hide();\n</code></pre>\n<p>对于ViewSkeletonScreen.show()进入源码，这里出现一个比较重要的类<code>ViewReplacer</code>，等下再进行解析，通过show的源码清楚的知道逻辑：<br><strong>1、生成骨架效果View<br>2、利用生成的View替换目标View。</strong><br>其中生成骨架效果View阶段主要还是通过LayoutInflater去加载传入mSkeletonResID</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">show</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">       <span class=\"type\">View</span> <span class=\"variable\">skeletonLoadingView</span> <span class=\"operator\">=</span> generateSkeletonLoadingView();</span><br><span class=\"line\">       <span class=\"keyword\">if</span> (skeletonLoadingView != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">           mViewReplacer.replace(skeletonLoadingView);</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n<p>接下来主要讲解ViewReplacer类，其构造方法传入目标View</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"title function_\">ViewReplacer</span><span class=\"params\">(View sourceView)</span> &#123;</span><br><span class=\"line\">     mSourceView = sourceView;</span><br><span class=\"line\">     mSourceViewLayoutParams = mSourceView.getLayoutParams();</span><br><span class=\"line\">     mCurrentView = mSourceView;</span><br><span class=\"line\">     mSourceViewId = mSourceView.getId();</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n<p>其比较重要的方法有两个：<code>replace()</code> 和 <code>restore()</code> 这两个方法分别为SkeletonScreen 的show()和hide()的最终实现，首先看<code>replace()</code>方法，有两个方法重载，分别传入<code>targetViewResID</code>或者<code>targetView</code>，最终还是会走到<code>replace(View targetView)</code>中。<br>其主要逻辑为：</p>\n<p> <strong>1. 判断所替换的View和骨架屏效果View是否为同一个View<br> 2. remove掉在父布局中的目标View<br> 3. 将骨架屏效果View添加到目标View的父布局中</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">replace</span><span class=\"params\">(<span class=\"type\">int</span> targetViewResID)</span> &#123;</span><br><span class=\"line\">       <span class=\"keyword\">if</span> (mTargetViewResID == targetViewResID) &#123;</span><br><span class=\"line\">           <span class=\"keyword\">return</span>;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       <span class=\"keyword\">if</span> (init()) &#123;</span><br><span class=\"line\">           mTargetViewResID = targetViewResID;</span><br><span class=\"line\">           replace(LayoutInflater.from(mSourceView.getContext()).inflate(mTargetViewResID, mSourceParentView, <span class=\"literal\">false</span>));</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">replace</span><span class=\"params\">(View targetView)</span> &#123;</span><br><span class=\"line\">       <span class=\"keyword\">if</span> (mCurrentView == targetView) &#123;</span><br><span class=\"line\">           <span class=\"keyword\">return</span>;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       <span class=\"keyword\">if</span> (targetView.getParent() != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">           ((ViewGroup) targetView.getParent()).removeView(targetView);</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       <span class=\"keyword\">if</span> (init()) &#123;</span><br><span class=\"line\">           mTargetView = targetView;</span><br><span class=\"line\">           mSourceParentView.removeView(mCurrentView);</span><br><span class=\"line\">           mTargetView.setId(mSourceViewId);</span><br><span class=\"line\">           mSourceParentView.addView(mTargetView, mSourceViewIndexInParent, mSourceViewLayoutParams);</span><br><span class=\"line\">           mCurrentView = mTargetView;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n\n<p>在执行添加到目标View的父布局中，有执行一个init方法，主要做两件事：</p>\n<p> <strong>1. 获取目标View的父View<br> 2. 找到目标View在父View 中的位置索引，为之后添加骨架屏View到父View中做铺垫</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"type\">boolean</span> <span class=\"title function_\">init</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">     <span class=\"keyword\">if</span> (mSourceParentView == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">         mSourceParentView = (ViewGroup) mSourceView.getParent();</span><br><span class=\"line\">         <span class=\"keyword\">if</span> (mSourceParentView == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">             Log.e(TAG, <span class=\"string\">&quot;the source view have not attach to any view&quot;</span>);</span><br><span class=\"line\">             <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">         <span class=\"type\">int</span> <span class=\"variable\">count</span> <span class=\"operator\">=</span> mSourceParentView.getChildCount();</span><br><span class=\"line\">         <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">index</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; index &lt; count; index++) &#123;</span><br><span class=\"line\">             <span class=\"keyword\">if</span> (mSourceView == mSourceParentView.getChildAt(index)) &#123;</span><br><span class=\"line\">                 mSourceViewIndexInParent = index;</span><br><span class=\"line\">                 <span class=\"keyword\">break</span>;</span><br><span class=\"line\">             &#125;</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">     <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n<p>至此对普通View的骨架屏效果实现流程已经完全梳理完成，那对于<code>RecyclerView</code>呢？其实两者实现逻辑差不多，主要有两个差异：</p>\n<ol>\n<li>在<code>RecyclerViewSkeletonScreen</code>的Builder中，相比ViewSkeletonScreen多了一个adapter()方法，传入目标<code>RecyclerView</code>的<code>Adapter</code></li>\n<li>在show的时候对目标<code>RecyclerView</code>的adapter进行替换，使用骨架屏效果的adapter。hide的时候恢复为原先的Adapter</li>\n</ol>\n<h2 id=\"3、总结\"><a href=\"#3、总结\" class=\"headerlink\" title=\"3、总结\"></a>3、总结</h2><ol>\n<li>Skeleton的原理主要是通过替换目标View和RecyclerView的Adapter</li>\n<li>在Skeleton的使用过程中最需要关心的两个问题是：show()和hide()的时机</li>\n<li>对于整个页面的骨架屏效果实现，个人推荐在布局中添加一个全屏的空View盖在原先内容上</li>\n<li>注意一些异常情况下的hide()，要不然整个页面就“假死”状态了。</li>\n</ol>\n<p>参考：<br><a href=\"https://juejin.im/post/5c789a4ce51d457c042d3b31\">https://juejin.im/post/5c789a4ce51d457c042d3b31</a></p>\n","categories":[{"name":"技术文章","slug":"technology","api":"api/categories/technology.json"}],"tags":[{"name":"Android","slug":"Android","api":"api/tags/Android.json"}],"api":"api/posts/2019/09/04/Android骨架屏效果的实现与原理解析.json"},{"title":"Android 插件化之ClassLoader","slug":"Android-插件化之ClassLoader","date":"2019-08-26T08:47:00.000Z","updated":"2025-05-20T11:46:57.000Z","comments":true,"url":"2019/08/26/Android-插件化之ClassLoader/","excerpt":"<p><strong>插件化要解决的三个核心问题：类加载、资源加载、组件生命周期管理。</strong></p>\n<p>在Android插件化中其原理实际是 Java ClassLoader的原理，此博文主要对Android插件化中类加载中的DexClassLoader做总结，便于之后对Android插件化的理解学习。</p>\n<p>Android的Dalvik虚拟机和Java虚拟机的运行原理相同都是将对应的java类加载在内存中运行。而Java虚拟机是加载class文件，也可以将一段二进制流通过defineClass方法生产Class进行加载。Dalvik虚拟机加载的dex文件。dex文件是Android对与Class文件做的优化，以便于提高手机的性能。可以想象dex为class文件的一个压缩文件。dex在Android中的加载和class在jvm中的相同都是基于双亲委派模型，都是调用ClassLoader的loadClass方法加载类。</p>\n<h2 id=\"1、DexClassLoader和PathClassLoader区别\"><a href=\"#1、DexClassLoader和PathClassLoader区别\" class=\"headerlink\" title=\"1、DexClassLoader和PathClassLoader区别\"></a><strong>1、DexClassLoader和PathClassLoader区别</strong></h2><p>Android 也有自己的 ClassLoader，分为 <code>DexClassLoader</code>和<code>PathClassLoader</code>，这两者有什么区别和关联呢？</p>\n<p>阅读源码可以看到两者的构造方法分别为：</p>\n<pre><code>public class PathClassLoader extends BaseDexClassLoader &#123;\n    public PathClassLoader(String dexPath, ClassLoader parent) &#123;\n        super(dexPath, null, null, parent);\n    &#125;\n    public PathClassLoader(String dexPath, String libraryPath,\n            ClassLoader parent) &#123;\n        super(dexPath, null, libraryPath, parent);\n    &#125;\n&#125;\n\npublic class DexClassLoader extends BaseDexClassLoader &#123;\n    public DexClassLoader(String dexPath, String optimizedDirectory,\n            String libraryPath, ClassLoader parent) &#123;\n        super(dexPath, new File(optimizedDirectory), libraryPath, parent);\n    &#125;\n&#125;\n</code></pre>\n<p>可以发现<code>DexClassLoader</code> 比 <code>PathClassLoader</code> 多一个参数<code>String optimizedDirectory</code>，那这个参数具体做什么的呢？继续查看源码我们可以知道<code>optimizedDirectory</code>是用来缓存我们需要加载的dex文件的，并创建一个<code>DexFile</code>对象，如果它为null，那么会直接使用dex文件原有的路径来创建DexFile 对象，其具体体现在如下代码区域：</p>\n<pre><code>private static DexFile loadDexFile(File file, File optimizedDirectory)\n        throws IOException &#123;\n    if (optimizedDirectory == null) &#123;\n        return new DexFile(file);\n    &#125; else &#123;\n        String optimizedPath = optimizedPathFor(file, optimizedDirectory);\n        return DexFile.loadDex(file.getPath(), optimizedPath, 0);\n    &#125;\n&#125;\n</code></pre>\n<p>因此两者区别在于 <code>PathClassLoader</code> 不能直接从 zip 包中得到 dex，因此只支持直接操作 dex 文件或者已经安装过的 apk。而 <code>DexClassLoader</code> 可以加载外部的 apk、jar 或 dex文件，并且会在指定的 outpath 路径存放其 dex 文件。所以在插件化中我们使用<code>DexClassLoader</code>来加载class的，接下来讲解<code>DexClassLoader</code>的用法。</p>\n<h2 id=\"2、DexClassLoader用法\"><a href=\"#2、DexClassLoader用法\" class=\"headerlink\" title=\"2、DexClassLoader用法\"></a><strong>2、DexClassLoader用法</strong></h2><p>其构造方法为：</p>\n<pre><code>DexClassLoader(\n\tString dexPath, \n\t\tString optimizedDirectory, \n\tString librarySearchPath,\n \tClassLoader parent)\n</code></pre>\n<p><code>dexPath</code>:被解压的apk路径，不能为空。<br><code>optimizedDirectory</code>：解压后的.dex文件的存储路径，不能为空。这个路径强烈建议使用应用程序的私有路径，不要放到sdcard上，否则代码容易被注入攻击。<br><code>libraryPath</code>：os库的存放路径，可以为空，若有os库，必须填写。<br><code>parent</code>：父亲加载器，一般为context.getClassLoader(),使用当前上下文的类加载器。</p>\n<p>接下来讲解具体使用流程：</p>\n<p>1、新建一个名为plugin的project，其中新建一个<code>Bean</code>类，只有一个方法<code>getName()</code>返回一个字符串“My App”，然后对plugin这个工程打包为apk，将apk放在主工程的asser目录中。</p>\n<img src=\"https://cdn.julis.wang/blog/img/20190827104738557.png\">\n<p>2、构造Classloader</p>\n<pre><code>  File extractFile = getFileStreamPath(&quot;app-debug.apk&quot;);\n  String dexPath = extractFile.getPath();\n  File fileRelease = getDir(&quot;dex&quot;, 0);\n  ClassLoader classLoader = new DexClassLoader(dexPath, fileRelease.getAbsolutePath(), null, getClassLoader());\n</code></pre>\n<p>3、利用构造好的Classloader反射调用插件类中的方法</p>\n<pre><code>  Class mLoadClassBean;\n  try &#123;\n        mLoadClassBean = classLoader.loadClass(&quot;com.example.plugin.Bean&quot;);\n        Object beanObject = mLoadClassBean.newInstance();\n        Method getNameMethod = mLoadClassBean.getMethod(&quot;getName&quot;);\n        getNameMethod.setAccessible(true);\n        String name = (String) getNameMethod.invoke(beanObject);\n        Log.e(&quot;julis&quot;, name);\n    &#125; catch(Exception e) &#123;\n        e.printStackTrace();\n    &#125;\n    \n</code></pre>\n<p>成功打印出结果：</p>\n<img src=\"https://cdn.julis.wang/blog/img/20190827143354781.png\">\n<p>参考：</p>\n<p><a href=\"https://www.jianshu.com/p/4b4f1fa6633c\">https://www.jianshu.com/p/4b4f1fa6633c</a></p>\n<p><a href=\"https://www.jianshu.com/p/53aa2de20cf8\">https://www.jianshu.com/p/53aa2de20cf8</a></p>\n<p><a href=\"https://cloud.tencent.com/developer/article/1071815\">https://cloud.tencent.com/developer/article/1071815</a></p>\n","cover":null,"images":["https://cdn.julis.wang/blog/img/20190827104738557.png","https://cdn.julis.wang/blog/img/20190827143354781.png"],"content":"<p><strong>插件化要解决的三个核心问题：类加载、资源加载、组件生命周期管理。</strong></p>\n<p>在Android插件化中其原理实际是 Java ClassLoader的原理，此博文主要对Android插件化中类加载中的DexClassLoader做总结，便于之后对Android插件化的理解学习。</p>\n<p>Android的Dalvik虚拟机和Java虚拟机的运行原理相同都是将对应的java类加载在内存中运行。而Java虚拟机是加载class文件，也可以将一段二进制流通过defineClass方法生产Class进行加载。Dalvik虚拟机加载的dex文件。dex文件是Android对与Class文件做的优化，以便于提高手机的性能。可以想象dex为class文件的一个压缩文件。dex在Android中的加载和class在jvm中的相同都是基于双亲委派模型，都是调用ClassLoader的loadClass方法加载类。</p>\n<h2 id=\"1、DexClassLoader和PathClassLoader区别\"><a href=\"#1、DexClassLoader和PathClassLoader区别\" class=\"headerlink\" title=\"1、DexClassLoader和PathClassLoader区别\"></a><strong>1、DexClassLoader和PathClassLoader区别</strong></h2><p>Android 也有自己的 ClassLoader，分为 <code>DexClassLoader</code>和<code>PathClassLoader</code>，这两者有什么区别和关联呢？</p>\n<p>阅读源码可以看到两者的构造方法分别为：</p>\n<pre><code>public class PathClassLoader extends BaseDexClassLoader &#123;\n    public PathClassLoader(String dexPath, ClassLoader parent) &#123;\n        super(dexPath, null, null, parent);\n    &#125;\n    public PathClassLoader(String dexPath, String libraryPath,\n            ClassLoader parent) &#123;\n        super(dexPath, null, libraryPath, parent);\n    &#125;\n&#125;\n\npublic class DexClassLoader extends BaseDexClassLoader &#123;\n    public DexClassLoader(String dexPath, String optimizedDirectory,\n            String libraryPath, ClassLoader parent) &#123;\n        super(dexPath, new File(optimizedDirectory), libraryPath, parent);\n    &#125;\n&#125;\n</code></pre>\n<p>可以发现<code>DexClassLoader</code> 比 <code>PathClassLoader</code> 多一个参数<code>String optimizedDirectory</code>，那这个参数具体做什么的呢？继续查看源码我们可以知道<code>optimizedDirectory</code>是用来缓存我们需要加载的dex文件的，并创建一个<code>DexFile</code>对象，如果它为null，那么会直接使用dex文件原有的路径来创建DexFile 对象，其具体体现在如下代码区域：</p>\n<pre><code>private static DexFile loadDexFile(File file, File optimizedDirectory)\n        throws IOException &#123;\n    if (optimizedDirectory == null) &#123;\n        return new DexFile(file);\n    &#125; else &#123;\n        String optimizedPath = optimizedPathFor(file, optimizedDirectory);\n        return DexFile.loadDex(file.getPath(), optimizedPath, 0);\n    &#125;\n&#125;\n</code></pre>\n<p>因此两者区别在于 <code>PathClassLoader</code> 不能直接从 zip 包中得到 dex，因此只支持直接操作 dex 文件或者已经安装过的 apk。而 <code>DexClassLoader</code> 可以加载外部的 apk、jar 或 dex文件，并且会在指定的 outpath 路径存放其 dex 文件。所以在插件化中我们使用<code>DexClassLoader</code>来加载class的，接下来讲解<code>DexClassLoader</code>的用法。</p>\n<h2 id=\"2、DexClassLoader用法\"><a href=\"#2、DexClassLoader用法\" class=\"headerlink\" title=\"2、DexClassLoader用法\"></a><strong>2、DexClassLoader用法</strong></h2><p>其构造方法为：</p>\n<pre><code>DexClassLoader(\n\tString dexPath, \n\t\tString optimizedDirectory, \n\tString librarySearchPath,\n \tClassLoader parent)\n</code></pre>\n<p><code>dexPath</code>:被解压的apk路径，不能为空。<br><code>optimizedDirectory</code>：解压后的.dex文件的存储路径，不能为空。这个路径强烈建议使用应用程序的私有路径，不要放到sdcard上，否则代码容易被注入攻击。<br><code>libraryPath</code>：os库的存放路径，可以为空，若有os库，必须填写。<br><code>parent</code>：父亲加载器，一般为context.getClassLoader(),使用当前上下文的类加载器。</p>\n<p>接下来讲解具体使用流程：</p>\n<p>1、新建一个名为plugin的project，其中新建一个<code>Bean</code>类，只有一个方法<code>getName()</code>返回一个字符串“My App”，然后对plugin这个工程打包为apk，将apk放在主工程的asser目录中。</p>\n<img src=\"https://cdn.julis.wang/blog/img/20190827104738557.png\">\n<p>2、构造Classloader</p>\n<pre><code>  File extractFile = getFileStreamPath(&quot;app-debug.apk&quot;);\n  String dexPath = extractFile.getPath();\n  File fileRelease = getDir(&quot;dex&quot;, 0);\n  ClassLoader classLoader = new DexClassLoader(dexPath, fileRelease.getAbsolutePath(), null, getClassLoader());\n</code></pre>\n<p>3、利用构造好的Classloader反射调用插件类中的方法</p>\n<pre><code>  Class mLoadClassBean;\n  try &#123;\n        mLoadClassBean = classLoader.loadClass(&quot;com.example.plugin.Bean&quot;);\n        Object beanObject = mLoadClassBean.newInstance();\n        Method getNameMethod = mLoadClassBean.getMethod(&quot;getName&quot;);\n        getNameMethod.setAccessible(true);\n        String name = (String) getNameMethod.invoke(beanObject);\n        Log.e(&quot;julis&quot;, name);\n    &#125; catch(Exception e) &#123;\n        e.printStackTrace();\n    &#125;\n    \n</code></pre>\n<p>成功打印出结果：</p>\n<img src=\"https://cdn.julis.wang/blog/img/20190827143354781.png\">\n<p>参考：</p>\n<p><a href=\"https://www.jianshu.com/p/4b4f1fa6633c\">https://www.jianshu.com/p/4b4f1fa6633c</a></p>\n<p><a href=\"https://www.jianshu.com/p/53aa2de20cf8\">https://www.jianshu.com/p/53aa2de20cf8</a></p>\n<p><a href=\"https://cloud.tencent.com/developer/article/1071815\">https://cloud.tencent.com/developer/article/1071815</a></p>\n","categories":[{"name":"技术文章","slug":"technology","api":"api/categories/technology.json"}],"tags":[{"name":"插件化","slug":"plugins","api":"api/tags/plugins.json"}],"api":"api/posts/2019/08/26/Android-插件化之ClassLoader.json"},{"title":"忙碌中求生活-记录23岁生日","slug":"★省★忙碌中求生活","date":"2019-07-13T11:36:00.000Z","updated":"2025-05-20T11:46:57.000Z","comments":true,"url":"2019/07/13/★省★忙碌中求生活/","excerpt":"<p>此时周六晚七点半，刚吃了一碗自己做的番茄鸡蛋面，将浸泡了很久的银耳原料装入了电饭煲内，静待熟时。回到自己的房间，窗外不断传来来往的车轱辘声，好像在告诉我他们很忙吧。看到书桌上的日历，还沉浸在六月份，我可能也很忙吧，都忘记将它带入七月份。</p>\n<p>来杭州一年有余，从一名大三学生暑假实习，到大四学生实习，再到应届毕业生签订转正合同，从而成为一名正式的“社会人儿”。时间过得真的很快吧，一周周一下子就没有了。进入了七月份，明显感觉比之前更忙了，或者说是因为自己身份的转变，导致肩上的责任变得不太一样了吧。因为工作节奏的改变，有时候也变得有些麻木吧，日记有时候总会忘记写，写字这件事感觉也变得有些奢侈起来，日语学习的节奏好像变得慢了起来。但是时间的脚步并不因为你的忙碌而停下来。</p>\n<p>我最近在读《时间简史》，讲述了从认知革命到农业革命再到人类文化的融合统一再到科学革命，作者用通俗的话语讲完了整个人类历史，真的很值得阅读。其中有一章节引发了我的思考，作者认为：农业革命是史上最大的骗局。因为在长达250万里里人类都靠狩猎或者采集果实为生，而到大约一万年前全然改变，从日升到日落，人类忙着对植物的培育，一心认为这样就能得到更多的水果、谷物和肉类，使得人类生活能够变得更加容易。然而事实上是人变得越来越辛苦。人类每次决定多做一点事情（比如用锄头来耕地，而不是直接将种子撒在地里面），我们认为这样没错，这样会使我们的收成更好一点，有了更好的收成，就不用更多地去担心荒年的问题了，不用挨饿了。工作努力一点，生活也能过得好一点。不过这都是理想的状态。</p>\n<p>人们确实工作得更努力也更辛苦，但没想到大家的孩子也更多了，人口慢慢地增加了，所得到的食物也就变得少了，生存压力也就更大了，资源也开始变得稀缺，而引发各种低问题。可是为什么他们不赶快放弃农耕回到原始的采集社会？原因在于，所有的改变都是必须点滴积累，经过许多代，才能改变社会，等到那个时候，已经没有人记得过去的生活方式和现在有什么不一样了，也没得选了。采用了农耕生活，村落的人口从100人到了110人，难道会有10个人自愿挨饿，好让其他人回到过去的美好时光？但这已经无法回头。于是人类付出了更多，但得到的却变得没有以前那样多。</p>\n<p>我们都各自为生活变得轻松而努力，但是事实上我们过得并不轻松。人的欲望永远也满足不了，今天拥有了这个，明天还想拥有更好的。现在，我们随手可以发送一条信息，传到地球另一方，而他立马能够回你。我们确实省下了很多时间和麻烦，但生活真的更轻松了么？我们以为省了时间，然而我们其实是把生活的步调调成了过去的10倍，于是我们整天忙忙碌碌、焦躁不安。</p>\n<p>这是原书作者对农业革命是史上最大的骗局的论证吧，我再赞同不过了。每每与我的爸妈打电话，我都会有很大的感触，他们总是在忙碌，他们每天都在拼命的挣钱，可是日子真的好起来了么？生活真的轻松了么？不久前，在家族微信群里面，我妈拍了一张我爸的照片放在群里，我爸双手背后，露出一脸笑意，背景好像是他们住那里的一个普通的建筑吧。想表现出: 你看我和你妈在玩，我们多开心啊。 当我看到这张照片的时候，我心里五谷杂粮。</p>\n<p>一方面是 我看到我爸的头发，愈发的白了，白了大多半了。记得上一次有这感触的时候，还是我大二的时候，那次我从学校回家，他到车站来接我，我坐他后面，我发现他的白头已经有很多很多了，那时我差点哭了出来。爸妈真的老了，可我还没有给他们带来好的生活，我曾告诉他们说：等我实习你们就回家吧，不要工作了，我能养活我自己，以后也能养活你们。可是他们并不，他们还是在工作，烈日下，每每打电话跟我说太阳是有多么多大温度是有多么高，我心里都很难受。可是他们总会说一句话：“这都是为了你以后更轻松一点”。此时我却不知道该说些什么。</p>\n<p>另一方面是 我看着我妈拍的那张照片，真的很糊，不是我妈不会拍照，也不是她眼神不好，真的是她的手机像素不好。我的爸妈，辛苦了大半辈子，其实也有很多积蓄了，虽然没有大城市里的那样多，但在老家里也算是稍微有一些钱的，可是他们却舍不得给自己多花一分钱，能将就用则用。每次电话，我都给他们讲让他们对自己好一点，我说 你们到底挣钱是为了做什么？给他们讲了很多道理，可是他们也总是会一句：“这都是为了你以后更轻松一点”。而我也只能强忍着，因为我现在还没有足够的能力，心里暗暗发誓：我会让他们过上轻松地日子。</p>\n<p>我其实一直都在思考一个问题：人到底活在这个世界上是为了什么？科学家无法解释，这是一个哲学问题，没有人知道正确的答案。我们只是沧海中的一粟，如果掀不起波浪，那么就好好感受海的浩瀚吧。忙忙碌碌，短视频以及直播的崛起，可能真的是因为都市生活节奏变得太快，于是都在夹缝中去寻找那一丝丝快感，其实可以做的很多吧，摘自网上“试着每天自己为自己做美味的饭菜，试着经常联络一下家人好友，试着拾起丢下很久的小说，试着用心养一颗植物，试着在空气清新的清晨去跑步，试着约一下自己暗恋已久的女孩…”。看看足球比赛，看看电影，多出去走走，再忙也不要忘记生活吧。</p>\n<p>快九点了，删删写写，也不道该放一些什么在日志上，那就这样吧。<br>祝自己二十三岁生日快乐 </p>\n<p>记录两张此时自己二十三岁的照片，没出门没刮胡子没收拾，一张沧桑一张微笑，生活亦如此吧。</p>\n<p>xxx.jpg</p>\n<p>—-二零一九年六月十一</p>\n","cover":null,"images":[],"content":"<p>此时周六晚七点半，刚吃了一碗自己做的番茄鸡蛋面，将浸泡了很久的银耳原料装入了电饭煲内，静待熟时。回到自己的房间，窗外不断传来来往的车轱辘声，好像在告诉我他们很忙吧。看到书桌上的日历，还沉浸在六月份，我可能也很忙吧，都忘记将它带入七月份。</p>\n<p>来杭州一年有余，从一名大三学生暑假实习，到大四学生实习，再到应届毕业生签订转正合同，从而成为一名正式的“社会人儿”。时间过得真的很快吧，一周周一下子就没有了。进入了七月份，明显感觉比之前更忙了，或者说是因为自己身份的转变，导致肩上的责任变得不太一样了吧。因为工作节奏的改变，有时候也变得有些麻木吧，日记有时候总会忘记写，写字这件事感觉也变得有些奢侈起来，日语学习的节奏好像变得慢了起来。但是时间的脚步并不因为你的忙碌而停下来。</p>\n<p>我最近在读《时间简史》，讲述了从认知革命到农业革命再到人类文化的融合统一再到科学革命，作者用通俗的话语讲完了整个人类历史，真的很值得阅读。其中有一章节引发了我的思考，作者认为：农业革命是史上最大的骗局。因为在长达250万里里人类都靠狩猎或者采集果实为生，而到大约一万年前全然改变，从日升到日落，人类忙着对植物的培育，一心认为这样就能得到更多的水果、谷物和肉类，使得人类生活能够变得更加容易。然而事实上是人变得越来越辛苦。人类每次决定多做一点事情（比如用锄头来耕地，而不是直接将种子撒在地里面），我们认为这样没错，这样会使我们的收成更好一点，有了更好的收成，就不用更多地去担心荒年的问题了，不用挨饿了。工作努力一点，生活也能过得好一点。不过这都是理想的状态。</p>\n<p>人们确实工作得更努力也更辛苦，但没想到大家的孩子也更多了，人口慢慢地增加了，所得到的食物也就变得少了，生存压力也就更大了，资源也开始变得稀缺，而引发各种低问题。可是为什么他们不赶快放弃农耕回到原始的采集社会？原因在于，所有的改变都是必须点滴积累，经过许多代，才能改变社会，等到那个时候，已经没有人记得过去的生活方式和现在有什么不一样了，也没得选了。采用了农耕生活，村落的人口从100人到了110人，难道会有10个人自愿挨饿，好让其他人回到过去的美好时光？但这已经无法回头。于是人类付出了更多，但得到的却变得没有以前那样多。</p>\n<p>我们都各自为生活变得轻松而努力，但是事实上我们过得并不轻松。人的欲望永远也满足不了，今天拥有了这个，明天还想拥有更好的。现在，我们随手可以发送一条信息，传到地球另一方，而他立马能够回你。我们确实省下了很多时间和麻烦，但生活真的更轻松了么？我们以为省了时间，然而我们其实是把生活的步调调成了过去的10倍，于是我们整天忙忙碌碌、焦躁不安。</p>\n<p>这是原书作者对农业革命是史上最大的骗局的论证吧，我再赞同不过了。每每与我的爸妈打电话，我都会有很大的感触，他们总是在忙碌，他们每天都在拼命的挣钱，可是日子真的好起来了么？生活真的轻松了么？不久前，在家族微信群里面，我妈拍了一张我爸的照片放在群里，我爸双手背后，露出一脸笑意，背景好像是他们住那里的一个普通的建筑吧。想表现出: 你看我和你妈在玩，我们多开心啊。 当我看到这张照片的时候，我心里五谷杂粮。</p>\n<p>一方面是 我看到我爸的头发，愈发的白了，白了大多半了。记得上一次有这感触的时候，还是我大二的时候，那次我从学校回家，他到车站来接我，我坐他后面，我发现他的白头已经有很多很多了，那时我差点哭了出来。爸妈真的老了，可我还没有给他们带来好的生活，我曾告诉他们说：等我实习你们就回家吧，不要工作了，我能养活我自己，以后也能养活你们。可是他们并不，他们还是在工作，烈日下，每每打电话跟我说太阳是有多么多大温度是有多么高，我心里都很难受。可是他们总会说一句话：“这都是为了你以后更轻松一点”。此时我却不知道该说些什么。</p>\n<p>另一方面是 我看着我妈拍的那张照片，真的很糊，不是我妈不会拍照，也不是她眼神不好，真的是她的手机像素不好。我的爸妈，辛苦了大半辈子，其实也有很多积蓄了，虽然没有大城市里的那样多，但在老家里也算是稍微有一些钱的，可是他们却舍不得给自己多花一分钱，能将就用则用。每次电话，我都给他们讲让他们对自己好一点，我说 你们到底挣钱是为了做什么？给他们讲了很多道理，可是他们也总是会一句：“这都是为了你以后更轻松一点”。而我也只能强忍着，因为我现在还没有足够的能力，心里暗暗发誓：我会让他们过上轻松地日子。</p>\n<p>我其实一直都在思考一个问题：人到底活在这个世界上是为了什么？科学家无法解释，这是一个哲学问题，没有人知道正确的答案。我们只是沧海中的一粟，如果掀不起波浪，那么就好好感受海的浩瀚吧。忙忙碌碌，短视频以及直播的崛起，可能真的是因为都市生活节奏变得太快，于是都在夹缝中去寻找那一丝丝快感，其实可以做的很多吧，摘自网上“试着每天自己为自己做美味的饭菜，试着经常联络一下家人好友，试着拾起丢下很久的小说，试着用心养一颗植物，试着在空气清新的清晨去跑步，试着约一下自己暗恋已久的女孩…”。看看足球比赛，看看电影，多出去走走，再忙也不要忘记生活吧。</p>\n<p>快九点了，删删写写，也不道该放一些什么在日志上，那就这样吧。<br>祝自己二十三岁生日快乐 </p>\n<p>记录两张此时自己二十三岁的照片，没出门没刮胡子没收拾，一张沧桑一张微笑，生活亦如此吧。</p>\n<p>xxx.jpg</p>\n<p>—-二零一九年六月十一</p>\n","categories":[{"name":"生活感想","slug":"life","api":"api/categories/life.json"}],"tags":[{"name":"生活","slug":"life","api":"api/tags/life.json"}],"api":"api/posts/2019/07/13/★省★忙碌中求生活.json"},{"title":"单例模式的设计","slug":"单例模式的设计","date":"2019-07-09T01:56:00.000Z","updated":"2025-05-20T11:46:57.000Z","comments":true,"url":"2019/07/09/单例模式的设计/","excerpt":"<p>原文回答于知乎(<a href=\"https://www.zhihu.com/question/277243683/answer/392772061\">如何把一段简单的代码变复杂？ - 落叶挽歌的回答</a>)</p>\n<p>我们都知道单例模式很简单，大概是这样：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//单线程单例模式实现</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Singleton</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Singleton instance=<span class=\"literal\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Singleton <span class=\"title function_\">getInstance</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(<span class=\"literal\">null</span>==instance)&#123;</span><br><span class=\"line\">            instance = <span class=\"keyword\">new</span> <span class=\"title class_\">Singleton</span>();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>但是呢，在多线程条件下getInstance()并不是一个原子操作。由于代码没有使用任何同步机制，因此该线程可能会出现线程交错的情形：在instance还是null的时候，如果两个线程同时执行到 if(null&#x3D;&#x3D;instance)那么会创建两个实例，从而违背了初衷。于是通过简单加锁来解决这种问题：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//简单加锁实现单例模式</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Singleton</span>  &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Singleton instance=<span class=\"literal\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Singleton <span class=\"title function_\">getInstance</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span> (Singleton.class)&#123;<span class=\"comment\">//加入synchronized同步</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(<span class=\"literal\">null</span>==instance)&#123;</span><br><span class=\"line\">                instance = <span class=\"keyword\">new</span> <span class=\"title class_\">Singleton</span>();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这种方式实现单例模式固然安全，但意味着每次调用 getInstance()都会申请锁，为了避免开销，我们想到了另一种办法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//基于双重检查锁定的错误单例模式实现</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Singleton</span>  &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Singleton instance=<span class=\"literal\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Singleton <span class=\"title function_\">getInstance</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(<span class=\"literal\">null</span>==instance)&#123;<span class=\"comment\">//先检查是否为null，再执行之上的代码</span></span><br><span class=\"line\">            <span class=\"keyword\">synchronized</span> (Singleton.class)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(<span class=\"literal\">null</span>==instance)&#123;</span><br><span class=\"line\">                    instance = <span class=\"keyword\">new</span> <span class=\"title class_\">Singleton</span>();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>通过这种方法，虽然第一次检查对变量instance的访问没有加锁从而使竞态仍然可能存在，它似乎避免了锁的开销又保障了线程的安全。然后对 instance &#x3D; new Singleton();进行伪代码独立子操作：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">obj=allocate(Singleton.class);<span class=\"comment\">//1、分配对象所需的存储空间</span></span><br><span class=\"line\">invokeConstructor(obj);<span class=\"comment\">//2、初始化obj的引用对象</span></span><br><span class=\"line\">instance=obj;<span class=\"comment\">//3、将对象引用写入共享变量</span></span><br></pre></td></tr></table></figure>\n<p>由于重排序的规则，临界区内的操作可以再临界区内重排序，因此JIT编译器可能将上述子操作重排序为：1-&gt;3-&gt;2，即在初始化对象之前将对象引用写入实例变量instace。由于锁对有序性的保障是有条件的，而操作1读取intance变量的时候并没有加锁，因此重排序是对1操作是有影响的：该线程可能看到一个未初始化（或者为初始化完毕）的实例，即intance不为null。于是该线程直接就直接返回这个instance变量所引用的实例，而实例可能是未初始化完毕的，这就是可能导致程序出错。明白问题的原因之后，解决方法也不难想到了：<strong>只需将instance变量加入volatile修饰则可</strong>。于是代码变成：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//基于双重检查锁定的正确单例模式实现</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Singleton</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">volatile</span> Singleton instance=<span class=\"literal\">null</span>;<span class=\"comment\">//加入volatile修饰</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Singleton <span class=\"title function_\">getInstance</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(<span class=\"literal\">null</span>==instance)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">synchronized</span> (Singleton.class)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(<span class=\"literal\">null</span>==instance)&#123;</span><br><span class=\"line\">                    instance = <span class=\"keyword\">new</span> <span class=\"title class_\">Singleton</span>();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>到此为止，才正确实现安全的“单例模式”。</p>\n<p>参考：《黄文海-Java多线程编程实战指南（核心篇）》</p>\n","cover":null,"images":[],"content":"<p>原文回答于知乎(<a href=\"https://www.zhihu.com/question/277243683/answer/392772061\">如何把一段简单的代码变复杂？ - 落叶挽歌的回答</a>)</p>\n<p>我们都知道单例模式很简单，大概是这样：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//单线程单例模式实现</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Singleton</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Singleton instance=<span class=\"literal\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Singleton <span class=\"title function_\">getInstance</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(<span class=\"literal\">null</span>==instance)&#123;</span><br><span class=\"line\">            instance = <span class=\"keyword\">new</span> <span class=\"title class_\">Singleton</span>();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>但是呢，在多线程条件下getInstance()并不是一个原子操作。由于代码没有使用任何同步机制，因此该线程可能会出现线程交错的情形：在instance还是null的时候，如果两个线程同时执行到 if(null&#x3D;&#x3D;instance)那么会创建两个实例，从而违背了初衷。于是通过简单加锁来解决这种问题：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//简单加锁实现单例模式</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Singleton</span>  &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Singleton instance=<span class=\"literal\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Singleton <span class=\"title function_\">getInstance</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span> (Singleton.class)&#123;<span class=\"comment\">//加入synchronized同步</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(<span class=\"literal\">null</span>==instance)&#123;</span><br><span class=\"line\">                instance = <span class=\"keyword\">new</span> <span class=\"title class_\">Singleton</span>();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这种方式实现单例模式固然安全，但意味着每次调用 getInstance()都会申请锁，为了避免开销，我们想到了另一种办法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//基于双重检查锁定的错误单例模式实现</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Singleton</span>  &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Singleton instance=<span class=\"literal\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Singleton <span class=\"title function_\">getInstance</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(<span class=\"literal\">null</span>==instance)&#123;<span class=\"comment\">//先检查是否为null，再执行之上的代码</span></span><br><span class=\"line\">            <span class=\"keyword\">synchronized</span> (Singleton.class)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(<span class=\"literal\">null</span>==instance)&#123;</span><br><span class=\"line\">                    instance = <span class=\"keyword\">new</span> <span class=\"title class_\">Singleton</span>();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>通过这种方法，虽然第一次检查对变量instance的访问没有加锁从而使竞态仍然可能存在，它似乎避免了锁的开销又保障了线程的安全。然后对 instance &#x3D; new Singleton();进行伪代码独立子操作：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">obj=allocate(Singleton.class);<span class=\"comment\">//1、分配对象所需的存储空间</span></span><br><span class=\"line\">invokeConstructor(obj);<span class=\"comment\">//2、初始化obj的引用对象</span></span><br><span class=\"line\">instance=obj;<span class=\"comment\">//3、将对象引用写入共享变量</span></span><br></pre></td></tr></table></figure>\n<p>由于重排序的规则，临界区内的操作可以再临界区内重排序，因此JIT编译器可能将上述子操作重排序为：1-&gt;3-&gt;2，即在初始化对象之前将对象引用写入实例变量instace。由于锁对有序性的保障是有条件的，而操作1读取intance变量的时候并没有加锁，因此重排序是对1操作是有影响的：该线程可能看到一个未初始化（或者为初始化完毕）的实例，即intance不为null。于是该线程直接就直接返回这个instance变量所引用的实例，而实例可能是未初始化完毕的，这就是可能导致程序出错。明白问题的原因之后，解决方法也不难想到了：<strong>只需将instance变量加入volatile修饰则可</strong>。于是代码变成：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//基于双重检查锁定的正确单例模式实现</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Singleton</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">volatile</span> Singleton instance=<span class=\"literal\">null</span>;<span class=\"comment\">//加入volatile修饰</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Singleton <span class=\"title function_\">getInstance</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(<span class=\"literal\">null</span>==instance)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">synchronized</span> (Singleton.class)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(<span class=\"literal\">null</span>==instance)&#123;</span><br><span class=\"line\">                    instance = <span class=\"keyword\">new</span> <span class=\"title class_\">Singleton</span>();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>到此为止，才正确实现安全的“单例模式”。</p>\n<p>参考：《黄文海-Java多线程编程实战指南（核心篇）》</p>\n","categories":[{"name":"技术文章","slug":"technology","api":"api/categories/technology.json"}],"tags":[{"name":"设计模式","slug":"design","api":"api/tags/design.json"}],"api":"api/posts/2019/07/09/单例模式的设计.json"},{"title":"Android监听截屏事件之媒体读取的探索","slug":"Android监听截屏事件之媒体读取的探索","date":"2019-07-02T09:58:00.000Z","updated":"2025-05-20T11:46:57.000Z","comments":true,"url":"2019/07/02/Android监听截屏事件之媒体读取的探索/","excerpt":"<p>最近做了一个需求：监听用户截屏，然后生成相关海报。<br>参考了<a href=\"https://blog.csdn.net/xietansheng/article/details/52692163\" title=\"Android 截屏事件监听\">Android 截屏事件监听</a>的文章，大致思路是：</p>\n<p>1、利用ContentObserver用来监听指定Uri的所有资源变化,当媒体库中有相关图片新增的时候，则发送相关的通知。</p>\n<p>2、得到回调的Uri后，借助ContentResolver在媒体数据库中查询最后一条数据</p>\n<p>3、对数据做一些过滤。比如短时间重复截屏的情况以及其他App也插入了媒体文件等情况做处理。</p>\n<p>不过有一些适配性的问题：</p>\n<p>1、截屏后读取文件数据库后获取到件的绝对路径后，利用“screenshot”等关键字判断是否是截屏图片，并不能适配所有手机截屏的命名规则，以及其他应用同时间产生带有“screenshot”等关键词的文件也会有问题。</p>\n<p>2、在某些型号手机中(现遇到Vivo)从数据库中读取的文件并不是获取到的最新的截屏文件，而且其他目录的文件，这里就有些难以理解了，所以今天取探究一下媒体数据库的读取。</p>\n<p>其中ContentObserver如下代码所示：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">   * 媒体内容观察者(观察媒体数据库的改变)</span></span><br><span class=\"line\"><span class=\"comment\">   */</span></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">class</span> <span class=\"title class_\">MediaContentObserver</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">ContentObserver</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">private</span> Uri mContentUri;</span><br><span class=\"line\">      <span class=\"keyword\">public</span> <span class=\"title function_\">MediaContentObserver</span><span class=\"params\">(Uri contentUri, Handler handler)</span> &#123;</span><br><span class=\"line\">          <span class=\"built_in\">super</span>(handler);</span><br><span class=\"line\">          mContentUri = contentUri;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      [<span class=\"meta\">@Override</span>](https:<span class=\"comment\">//my.oschina.net/u/1162528)</span></span><br><span class=\"line\">      <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">onChange</span><span class=\"params\">(<span class=\"type\">boolean</span> selfChange)</span> &#123;</span><br><span class=\"line\">          <span class=\"built_in\">super</span>.onChange(selfChange);</span><br><span class=\"line\">          handleMediaContentChange(mContentUri);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<p>其中获取最后一次更新的媒体文件时的代码(为便于查看 删除了判空处理代码)：<br> <figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">\t<span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">    * 处理媒体数据库的内容改变</span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">   <span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">handleMediaContentChange</span><span class=\"params\">(Uri contentUri)</span> &#123;</span><br><span class=\"line\">       <span class=\"type\">Cursor</span> <span class=\"variable\">cursor</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">       <span class=\"comment\">/** 读取媒体数据库时需要读取的列 */</span></span><br><span class=\"line\">       <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String[] MEDIA_PROJECTIONS =  &#123;</span><br><span class=\"line\">           MediaStore.Images.ImageColumns.DATA,</span><br><span class=\"line\">           MediaStore.Images.ImageColumns.DATE_TAKEN &#125;;</span><br><span class=\"line\">       <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">           <span class=\"comment\">// 数据改变时查询数据库中最后加入的一条数据</span></span><br><span class=\"line\">           cursor = mContext.getContentResolver().query(</span><br><span class=\"line\">                   contentUri,</span><br><span class=\"line\">                    MEDIA_PROJECTIONS,</span><br><span class=\"line\">                   <span class=\"literal\">null</span>,</span><br><span class=\"line\">                   <span class=\"literal\">null</span>,</span><br><span class=\"line\">                   MediaStore.Images.ImageColumns.DATE_ADDED + <span class=\"string\">&quot; desc limit 1&quot;</span></span><br><span class=\"line\">           );</span><br><span class=\"line\">           <span class=\"comment\">// 获取各列的索引</span></span><br><span class=\"line\">           <span class=\"type\">int</span> <span class=\"variable\">dataIndex</span> <span class=\"operator\">=</span> cursor.getColumnIndex(MediaStore.Images.ImageColumns.DATA);</span><br><span class=\"line\">           <span class=\"type\">int</span> <span class=\"variable\">dateTakenIndex</span> <span class=\"operator\">=</span> cursor.getColumnIndex(MediaStore.Images.ImageColumns.DATE_TAKEN);</span><br><span class=\"line\"></span><br><span class=\"line\">           <span class=\"comment\">// 获取行数据</span></span><br><span class=\"line\">           <span class=\"type\">String</span> <span class=\"variable\">data</span> <span class=\"operator\">=</span> cursor.getString(dataIndex);</span><br><span class=\"line\">           <span class=\"type\">long</span> <span class=\"variable\">dateTaken</span> <span class=\"operator\">=</span> cursor.getLong(dateTakenIndex);</span><br><span class=\"line\"></span><br><span class=\"line\">           <span class=\"comment\">// 处理获取到的第一行数据</span></span><br><span class=\"line\">           handleMediaRowData(data, dateTaken);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>这次的目的主要探究的是从数据库获取相关信息的过程</p>\n<p><strong>1、Android 的多媒体如何存储？</strong></p>\n<p>Android的多媒体文件主要存储在 &#x2F;data&#x2F;data&#x2F;com.android.providers.media&#x2F;databases 目录下，该目录下有连个db文件：</p>\n<p>内部存储数据库文件：internal.db</p>\n<p>存储卡数据库：external-XXXX.db</p>\n<p>媒体文件的操作主要是围绕着这两个数据库来进行，这两个数据库的结构是一样的。</p>\n<p>这两个数据库包含这些表：<br>album_art 、audio 、search 、album_info 、audio_genres、 searchhelpertitle、albums、 audio_genres_map、 thumbnails、<br>android_metadata、 audio_meta、 video、artist_info 、audio_playlists 、videothumbnails、artists 、audio_playlists_map、<br>artists_albums_map 、images</p>\n<p><strong>2、表的结构</strong><br>对于Images表：主要存储images信息。表结构如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">CREATE TABLE <span class=\"title function_\">images</span> <span class=\"params\">(</span></span><br><span class=\"line\"><span class=\"params\">   _id INTEGER PRIMARY KEY, </span></span><br><span class=\"line\"><span class=\"params\">   _data TEXT,</span></span><br><span class=\"line\"><span class=\"params\">   _size INTEGER,</span></span><br><span class=\"line\"><span class=\"params\">   _display_name TEXT,</span></span><br><span class=\"line\"><span class=\"params\">   mime_type TEXT,</span></span><br><span class=\"line\"><span class=\"params\">   title TEXT, </span></span><br><span class=\"line\"><span class=\"params\">   date_added INTEGER, </span></span><br><span class=\"line\"><span class=\"params\">   date_modified INTEGER,</span></span><br><span class=\"line\"><span class=\"params\">   description TEXT,</span></span><br><span class=\"line\"><span class=\"params\">   picasa_id TEXT,</span></span><br><span class=\"line\"><span class=\"params\">   isprivate INTEGER,</span></span><br><span class=\"line\"><span class=\"params\">   latitude DOUBLE, </span></span><br><span class=\"line\"><span class=\"params\">   longitude DOUBLE, </span></span><br><span class=\"line\"><span class=\"params\">   datetaken INTEGER, </span></span><br><span class=\"line\"><span class=\"params\">   orientation INTEGER, </span></span><br><span class=\"line\"><span class=\"params\">   mini_thumb_magic INTEGER, </span></span><br><span class=\"line\"><span class=\"params\">   bucket_id TEXT, </span></span><br><span class=\"line\"><span class=\"params\">   bucket_display_name TEXT )</span>;</span><br></pre></td></tr></table></figure>\n\n<p>各字段所表示意思，如图所示：</p>\n<img src=\"https://cdn.julis.wang/blog/img/2eb1be5d3ece2831fa9ca6d00678bf520a7.jpg\">\n\n<p><em>图片来自：<a href=\"https://blog.csdn.net/love_xsq/article/details/50387747\" title=\"Android MediaProvider数据库模式说明\">Android MediaProvider数据库模式说明</a></em></p>\n<p>所以在截屏监听数据的时候所读取的数据库返回值，分别为：</p>\n<p>_data  :图片据对路径</p>\n<p>datetaken：取子EXIF照片拍摄事件，空的话为文件修改时间</p>\n<pre><code>  private static final String[] MEDIA_PROJECTIONS =  &#123;\n        MediaStore.Images.ImageColumns.DATA,\n        MediaStore.Images.ImageColumns.DATE_TAKEN &#125;;\n</code></pre>\n<p>在查询过程中构造的数据库代码为：</p>\n<pre><code>public final Cursor query (Uri uri, \n\tString[] projection,\n\tString selection, \n\tString[] selectionArgs, \n\tString sortOrder)\n</code></pre>\n<p>&#96;<br>其中对应的构造参数官方解释为：</p>\n<blockquote>\n<p>uri\tThe URI, using the content:&#x2F;&#x2F; scheme, for the content to retrieve.</p>\n</blockquote>\n<blockquote>\n<p>projection\tA list of which columns to return. Passing null will return all columns, which is inefficient.  </p>\n</blockquote>\n<blockquote>\n<p>selection\tA filter declaring which rows to return, formatted as an SQL WHERE clause (excluding the WHERE itself). Passing null will return all rows for the given URI.</p>\n</blockquote>\n<blockquote>\n<p>selectionArgs\tYou may include ?s in selection, which will be replaced by the values from selectionArgs, in the order that they appear in the selection. The values will be bound as Strings.</p>\n</blockquote>\n<blockquote>\n<p>sortOrder\tHow to order the rows, formatted as an SQL ORDER BY clause (excluding the ORDER BY itself). Passing null will use the default sort order, which may be unordered.</p>\n</blockquote>\n<hr>\n<p>所以参数依次为：<br>所要查找的目标、所要的返回值、条件限制(类似sql中where)、匹配项、排序规则</p>\n<p>所以这里的查询就显而易见了：获取最新图片数据库下data和datatoken列的数据</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">cursor = mContext.getContentResolver().query(</span><br><span class=\"line\">                 contentUri,</span><br><span class=\"line\">                 MEDIA_PROJECTIONS,</span><br><span class=\"line\">                 <span class=\"literal\">null</span>,</span><br><span class=\"line\">                 <span class=\"literal\">null</span>,</span><br><span class=\"line\">                 MediaStore.Images.ImageColumns.DATE_ADDED + <span class=\"string\">&quot; desc limit 1&quot;</span></span><br><span class=\"line\">         );</span><br></pre></td></tr></table></figure>\n<p>然而…并不能解释vivo手机为什么查找出来不是最新截图的图片的问题</p>\n","cover":null,"images":["https://cdn.julis.wang/blog/img/2eb1be5d3ece2831fa9ca6d00678bf520a7.jpg"],"content":"<p>最近做了一个需求：监听用户截屏，然后生成相关海报。<br>参考了<a href=\"https://blog.csdn.net/xietansheng/article/details/52692163\" title=\"Android 截屏事件监听\">Android 截屏事件监听</a>的文章，大致思路是：</p>\n<p>1、利用ContentObserver用来监听指定Uri的所有资源变化,当媒体库中有相关图片新增的时候，则发送相关的通知。</p>\n<p>2、得到回调的Uri后，借助ContentResolver在媒体数据库中查询最后一条数据</p>\n<p>3、对数据做一些过滤。比如短时间重复截屏的情况以及其他App也插入了媒体文件等情况做处理。</p>\n<p>不过有一些适配性的问题：</p>\n<p>1、截屏后读取文件数据库后获取到件的绝对路径后，利用“screenshot”等关键字判断是否是截屏图片，并不能适配所有手机截屏的命名规则，以及其他应用同时间产生带有“screenshot”等关键词的文件也会有问题。</p>\n<p>2、在某些型号手机中(现遇到Vivo)从数据库中读取的文件并不是获取到的最新的截屏文件，而且其他目录的文件，这里就有些难以理解了，所以今天取探究一下媒体数据库的读取。</p>\n<p>其中ContentObserver如下代码所示：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">   * 媒体内容观察者(观察媒体数据库的改变)</span></span><br><span class=\"line\"><span class=\"comment\">   */</span></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">class</span> <span class=\"title class_\">MediaContentObserver</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">ContentObserver</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">private</span> Uri mContentUri;</span><br><span class=\"line\">      <span class=\"keyword\">public</span> <span class=\"title function_\">MediaContentObserver</span><span class=\"params\">(Uri contentUri, Handler handler)</span> &#123;</span><br><span class=\"line\">          <span class=\"built_in\">super</span>(handler);</span><br><span class=\"line\">          mContentUri = contentUri;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      [<span class=\"meta\">@Override</span>](https:<span class=\"comment\">//my.oschina.net/u/1162528)</span></span><br><span class=\"line\">      <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">onChange</span><span class=\"params\">(<span class=\"type\">boolean</span> selfChange)</span> &#123;</span><br><span class=\"line\">          <span class=\"built_in\">super</span>.onChange(selfChange);</span><br><span class=\"line\">          handleMediaContentChange(mContentUri);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<p>其中获取最后一次更新的媒体文件时的代码(为便于查看 删除了判空处理代码)：<br> <figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">\t<span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">    * 处理媒体数据库的内容改变</span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">   <span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">handleMediaContentChange</span><span class=\"params\">(Uri contentUri)</span> &#123;</span><br><span class=\"line\">       <span class=\"type\">Cursor</span> <span class=\"variable\">cursor</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">       <span class=\"comment\">/** 读取媒体数据库时需要读取的列 */</span></span><br><span class=\"line\">       <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String[] MEDIA_PROJECTIONS =  &#123;</span><br><span class=\"line\">           MediaStore.Images.ImageColumns.DATA,</span><br><span class=\"line\">           MediaStore.Images.ImageColumns.DATE_TAKEN &#125;;</span><br><span class=\"line\">       <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">           <span class=\"comment\">// 数据改变时查询数据库中最后加入的一条数据</span></span><br><span class=\"line\">           cursor = mContext.getContentResolver().query(</span><br><span class=\"line\">                   contentUri,</span><br><span class=\"line\">                    MEDIA_PROJECTIONS,</span><br><span class=\"line\">                   <span class=\"literal\">null</span>,</span><br><span class=\"line\">                   <span class=\"literal\">null</span>,</span><br><span class=\"line\">                   MediaStore.Images.ImageColumns.DATE_ADDED + <span class=\"string\">&quot; desc limit 1&quot;</span></span><br><span class=\"line\">           );</span><br><span class=\"line\">           <span class=\"comment\">// 获取各列的索引</span></span><br><span class=\"line\">           <span class=\"type\">int</span> <span class=\"variable\">dataIndex</span> <span class=\"operator\">=</span> cursor.getColumnIndex(MediaStore.Images.ImageColumns.DATA);</span><br><span class=\"line\">           <span class=\"type\">int</span> <span class=\"variable\">dateTakenIndex</span> <span class=\"operator\">=</span> cursor.getColumnIndex(MediaStore.Images.ImageColumns.DATE_TAKEN);</span><br><span class=\"line\"></span><br><span class=\"line\">           <span class=\"comment\">// 获取行数据</span></span><br><span class=\"line\">           <span class=\"type\">String</span> <span class=\"variable\">data</span> <span class=\"operator\">=</span> cursor.getString(dataIndex);</span><br><span class=\"line\">           <span class=\"type\">long</span> <span class=\"variable\">dateTaken</span> <span class=\"operator\">=</span> cursor.getLong(dateTakenIndex);</span><br><span class=\"line\"></span><br><span class=\"line\">           <span class=\"comment\">// 处理获取到的第一行数据</span></span><br><span class=\"line\">           handleMediaRowData(data, dateTaken);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>这次的目的主要探究的是从数据库获取相关信息的过程</p>\n<p><strong>1、Android 的多媒体如何存储？</strong></p>\n<p>Android的多媒体文件主要存储在 &#x2F;data&#x2F;data&#x2F;com.android.providers.media&#x2F;databases 目录下，该目录下有连个db文件：</p>\n<p>内部存储数据库文件：internal.db</p>\n<p>存储卡数据库：external-XXXX.db</p>\n<p>媒体文件的操作主要是围绕着这两个数据库来进行，这两个数据库的结构是一样的。</p>\n<p>这两个数据库包含这些表：<br>album_art 、audio 、search 、album_info 、audio_genres、 searchhelpertitle、albums、 audio_genres_map、 thumbnails、<br>android_metadata、 audio_meta、 video、artist_info 、audio_playlists 、videothumbnails、artists 、audio_playlists_map、<br>artists_albums_map 、images</p>\n<p><strong>2、表的结构</strong><br>对于Images表：主要存储images信息。表结构如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">CREATE TABLE <span class=\"title function_\">images</span> <span class=\"params\">(</span></span><br><span class=\"line\"><span class=\"params\">   _id INTEGER PRIMARY KEY, </span></span><br><span class=\"line\"><span class=\"params\">   _data TEXT,</span></span><br><span class=\"line\"><span class=\"params\">   _size INTEGER,</span></span><br><span class=\"line\"><span class=\"params\">   _display_name TEXT,</span></span><br><span class=\"line\"><span class=\"params\">   mime_type TEXT,</span></span><br><span class=\"line\"><span class=\"params\">   title TEXT, </span></span><br><span class=\"line\"><span class=\"params\">   date_added INTEGER, </span></span><br><span class=\"line\"><span class=\"params\">   date_modified INTEGER,</span></span><br><span class=\"line\"><span class=\"params\">   description TEXT,</span></span><br><span class=\"line\"><span class=\"params\">   picasa_id TEXT,</span></span><br><span class=\"line\"><span class=\"params\">   isprivate INTEGER,</span></span><br><span class=\"line\"><span class=\"params\">   latitude DOUBLE, </span></span><br><span class=\"line\"><span class=\"params\">   longitude DOUBLE, </span></span><br><span class=\"line\"><span class=\"params\">   datetaken INTEGER, </span></span><br><span class=\"line\"><span class=\"params\">   orientation INTEGER, </span></span><br><span class=\"line\"><span class=\"params\">   mini_thumb_magic INTEGER, </span></span><br><span class=\"line\"><span class=\"params\">   bucket_id TEXT, </span></span><br><span class=\"line\"><span class=\"params\">   bucket_display_name TEXT )</span>;</span><br></pre></td></tr></table></figure>\n\n<p>各字段所表示意思，如图所示：</p>\n<img src=\"https://cdn.julis.wang/blog/img/2eb1be5d3ece2831fa9ca6d00678bf520a7.jpg\">\n\n<p><em>图片来自：<a href=\"https://blog.csdn.net/love_xsq/article/details/50387747\" title=\"Android MediaProvider数据库模式说明\">Android MediaProvider数据库模式说明</a></em></p>\n<p>所以在截屏监听数据的时候所读取的数据库返回值，分别为：</p>\n<p>_data  :图片据对路径</p>\n<p>datetaken：取子EXIF照片拍摄事件，空的话为文件修改时间</p>\n<pre><code>  private static final String[] MEDIA_PROJECTIONS =  &#123;\n        MediaStore.Images.ImageColumns.DATA,\n        MediaStore.Images.ImageColumns.DATE_TAKEN &#125;;\n</code></pre>\n<p>在查询过程中构造的数据库代码为：</p>\n<pre><code>public final Cursor query (Uri uri, \n\tString[] projection,\n\tString selection, \n\tString[] selectionArgs, \n\tString sortOrder)\n</code></pre>\n<p>&#96;<br>其中对应的构造参数官方解释为：</p>\n<blockquote>\n<p>uri\tThe URI, using the content:&#x2F;&#x2F; scheme, for the content to retrieve.</p>\n</blockquote>\n<blockquote>\n<p>projection\tA list of which columns to return. Passing null will return all columns, which is inefficient.  </p>\n</blockquote>\n<blockquote>\n<p>selection\tA filter declaring which rows to return, formatted as an SQL WHERE clause (excluding the WHERE itself). Passing null will return all rows for the given URI.</p>\n</blockquote>\n<blockquote>\n<p>selectionArgs\tYou may include ?s in selection, which will be replaced by the values from selectionArgs, in the order that they appear in the selection. The values will be bound as Strings.</p>\n</blockquote>\n<blockquote>\n<p>sortOrder\tHow to order the rows, formatted as an SQL ORDER BY clause (excluding the ORDER BY itself). Passing null will use the default sort order, which may be unordered.</p>\n</blockquote>\n<hr>\n<p>所以参数依次为：<br>所要查找的目标、所要的返回值、条件限制(类似sql中where)、匹配项、排序规则</p>\n<p>所以这里的查询就显而易见了：获取最新图片数据库下data和datatoken列的数据</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">cursor = mContext.getContentResolver().query(</span><br><span class=\"line\">                 contentUri,</span><br><span class=\"line\">                 MEDIA_PROJECTIONS,</span><br><span class=\"line\">                 <span class=\"literal\">null</span>,</span><br><span class=\"line\">                 <span class=\"literal\">null</span>,</span><br><span class=\"line\">                 MediaStore.Images.ImageColumns.DATE_ADDED + <span class=\"string\">&quot; desc limit 1&quot;</span></span><br><span class=\"line\">         );</span><br></pre></td></tr></table></figure>\n<p>然而…并不能解释vivo手机为什么查找出来不是最新截图的图片的问题</p>\n","categories":[{"name":"技术文章","slug":"technology","api":"api/categories/technology.json"}],"tags":[{"name":"安卓","slug":"Android","api":"api/tags/Android.json"}],"api":"api/posts/2019/07/02/Android监听截屏事件之媒体读取的探索.json"},{"title":"Android在子线程中创建Handler为什么会抛出异常？","slug":"Android在子线程中创建Handler为什么会抛出异常？","date":"2019-06-24T09:27:00.000Z","updated":"2025-05-20T11:46:57.000Z","comments":true,"url":"2019/06/24/Android在子线程中创建Handler为什么会抛出异常？/","excerpt":"<p>复习一下消息机制，如下代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>() &#123;</span><br><span class=\"line\">           <span class=\"type\">Handler</span> <span class=\"variable\">handler</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">           [<span class=\"meta\">@Override</span>](https:<span class=\"comment\">//my.oschina.net/u/1162528)</span></span><br><span class=\"line\">           <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">               handler = <span class=\"keyword\">new</span> <span class=\"title class_\">Handler</span>();</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">       &#125;.start();</span><br></pre></td></tr></table></figure>\n<p>如果执行会抛出异常：</p>\n<blockquote>\n<p>Can’t create handler inside thread Thread.currentThread() that has not called Looper.prepare()</p>\n</blockquote>\n<p>这是为什么呢？</p>\n<p>我们进入Handler的构造方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"> <span class=\"keyword\">public</span> <span class=\"title function_\">Handler</span><span class=\"params\">(Callback callback, <span class=\"type\">boolean</span> async)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (FIND_POTENTIAL_LEAKS) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> Class&lt;? <span class=\"keyword\">extends</span> <span class=\"title class_\">Handler</span>&gt; klass = getClass();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((klass.isAnonymousClass() || klass.isMemberClass() || klass.isLocalClass()) &amp;&amp;</span><br><span class=\"line\">                (klass.getModifiers() &amp; Modifier.STATIC) == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            Log.w(TAG, <span class=\"string\">&quot;The following Handler class should be static or leaks might occur: &quot;</span> +</span><br><span class=\"line\">                klass.getCanonicalName());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    mLooper = Looper.myLooper();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mLooper == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">RuntimeException</span>(</span><br><span class=\"line\">            <span class=\"string\">&quot;Can&#x27;t create handler inside thread &quot;</span> + Thread.currentThread()</span><br><span class=\"line\">                    + <span class=\"string\">&quot; that has not called Looper.prepare()&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    mQueue = mLooper.mQueue;</span><br><span class=\"line\">    mCallback = callback;</span><br><span class=\"line\">    mAsynchronous = async;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>从上面的代码我们很清新的可以知道mLooper  为null,那么就会抛出这样的异常，那么mLooper 为什么会为空呢？这是因为在线程中的Looper还未被创建，所以在Looper.myLooper()中sThreadLocal.get()就会返回null。</p>\n<p>我们知道 Handler的作用是处理消息，将消息传递给MessageQueue，而MessageQueue存在于Looper中，如果没有Looper那么就没有MessageQueue，所以创建Handler时，Looper不能够为空。</p>\n<p>所以以上代码可以进行一个修改：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">test</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>() &#123;</span><br><span class=\"line\">        <span class=\"type\">Handler</span> <span class=\"variable\">handler</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">        [<span class=\"meta\">@Override</span>](https:<span class=\"comment\">//my.oschina.net/u/1162528)</span></span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">            Looper.prepare();</span><br><span class=\"line\">            handler = <span class=\"keyword\">new</span> <span class=\"title class_\">Handler</span>();</span><br><span class=\"line\">            Looper.loop();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;.start();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>其中     Looper.prepare();为当前线程创建Looper并绑定在ThreadLocal中<br>    Looper.loop();执行消息循环，这样子 Handler就能够正常工作了。\n\t\n\t</p>\n","cover":null,"images":[],"content":"<p>复习一下消息机制，如下代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>() &#123;</span><br><span class=\"line\">           <span class=\"type\">Handler</span> <span class=\"variable\">handler</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">           [<span class=\"meta\">@Override</span>](https:<span class=\"comment\">//my.oschina.net/u/1162528)</span></span><br><span class=\"line\">           <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">               handler = <span class=\"keyword\">new</span> <span class=\"title class_\">Handler</span>();</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">       &#125;.start();</span><br></pre></td></tr></table></figure>\n<p>如果执行会抛出异常：</p>\n<blockquote>\n<p>Can’t create handler inside thread Thread.currentThread() that has not called Looper.prepare()</p>\n</blockquote>\n<p>这是为什么呢？</p>\n<p>我们进入Handler的构造方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"> <span class=\"keyword\">public</span> <span class=\"title function_\">Handler</span><span class=\"params\">(Callback callback, <span class=\"type\">boolean</span> async)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (FIND_POTENTIAL_LEAKS) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> Class&lt;? <span class=\"keyword\">extends</span> <span class=\"title class_\">Handler</span>&gt; klass = getClass();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((klass.isAnonymousClass() || klass.isMemberClass() || klass.isLocalClass()) &amp;&amp;</span><br><span class=\"line\">                (klass.getModifiers() &amp; Modifier.STATIC) == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            Log.w(TAG, <span class=\"string\">&quot;The following Handler class should be static or leaks might occur: &quot;</span> +</span><br><span class=\"line\">                klass.getCanonicalName());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    mLooper = Looper.myLooper();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mLooper == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">RuntimeException</span>(</span><br><span class=\"line\">            <span class=\"string\">&quot;Can&#x27;t create handler inside thread &quot;</span> + Thread.currentThread()</span><br><span class=\"line\">                    + <span class=\"string\">&quot; that has not called Looper.prepare()&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    mQueue = mLooper.mQueue;</span><br><span class=\"line\">    mCallback = callback;</span><br><span class=\"line\">    mAsynchronous = async;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>从上面的代码我们很清新的可以知道mLooper  为null,那么就会抛出这样的异常，那么mLooper 为什么会为空呢？这是因为在线程中的Looper还未被创建，所以在Looper.myLooper()中sThreadLocal.get()就会返回null。</p>\n<p>我们知道 Handler的作用是处理消息，将消息传递给MessageQueue，而MessageQueue存在于Looper中，如果没有Looper那么就没有MessageQueue，所以创建Handler时，Looper不能够为空。</p>\n<p>所以以上代码可以进行一个修改：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">test</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>() &#123;</span><br><span class=\"line\">        <span class=\"type\">Handler</span> <span class=\"variable\">handler</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">        [<span class=\"meta\">@Override</span>](https:<span class=\"comment\">//my.oschina.net/u/1162528)</span></span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">            Looper.prepare();</span><br><span class=\"line\">            handler = <span class=\"keyword\">new</span> <span class=\"title class_\">Handler</span>();</span><br><span class=\"line\">            Looper.loop();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;.start();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>其中     Looper.prepare();为当前线程创建Looper并绑定在ThreadLocal中<br>    Looper.loop();执行消息循环，这样子 Handler就能够正常工作了。\n\t\n\t</p>\n","categories":[{"name":"技术文章","slug":"technology","api":"api/categories/technology.json"}],"tags":[{"name":"安卓","slug":"Android","api":"api/tags/Android.json"}],"api":"api/posts/2019/06/24/Android在子线程中创建Handler为什么会抛出异常？.json"},{"title":"写在我即将毕业旅行前","slug":"写在毕业之际旅行前","date":"2019-06-04T11:24:00.000Z","updated":"2025-05-20T11:46:57.000Z","comments":true,"url":"2019/06/04/写在毕业之际旅行前/","excerpt":"<p>忙碌的一天，又要到下班的时候了，一天好似很忙，其实回过头来仔细想想，一天好像并没有做太多的事情，然而确实是这样子度过一天了，就像我们的青春岁月，看样子并没有经历什么，但它就这样匆匆过去了，亦忧伤，亦憧憬。</p>\n<p>还有两周就要回校参加毕业典礼了，向公司请了十天假，算上端午以及周末，大概有半个多月属于自己的日子吧，也算是大学最后一点还是以学生身份存在的时间了。早在几个月前我都在筹划这次出去游玩了，因为我想出去走走，想出去看看。纵观整个大学生涯，自己也算是去了不少地方了，屋子里车票、机票已经收纳了一沓了。看着每一张车票的起点与终点以及行程时间，还能想起那时候发生过的事，或许有些事还在记忆里面，或许可能存在我的日记里面，或许我什么也记不得了。</p>\n<p>**2015年8月15日 绵阳-上海：**距离大学开学还有一个月了，父亲陪我度过了整个高三，待我拿到通知书后，我与父亲来到上海。父亲是一个节俭的人，买了绿皮车，将近两千多公里的路程，三十多个小时的行程，脚没有办法舒展开，时间长了别的难受。当看到那些没有座位的那些人要不停地给过路人让路的时候，我觉得自己也挺幸运的，至少我还有一个属于自己的位置，不需要为别人让路。在这煎熬的行程中，我并没有去抱怨，我只是一直在想，我以后一定要努力，一定不会让我和我父亲再受这样的遭遇。</p>\n<p><strong>2015年9月14日 上海-温州</strong>：马上就要大学开学了。离开了父母，将一个人去面对新的生活了，路过杭州的时候，车窗外一片开阔的平原，让我看到极具江南特色的景象：鳞次栉比的房屋伴着小河流，来来往往的车辆川流不息，很憧憬那样“小桥流水人家”的生活，这大概是对杭州的第一印象吧。</p>\n<p>**2016年1月22日 温州-成都：**大学寒假第一次回家，运气很好，我和同学抢到了卧铺票，有了一个较舒服的乘车环境。与我通行的还有很多大学川籍同学，因此一路上也变得并不孤独，时而和他们“摆龙门阵”，累了就回床铺上面去休息一下，我记得我当时带了一本《浪潮之巅》。</p>\n<p>**2017年7月18日 温州-太原：**第一次坐飞机，带着许多憧憬出发，但让人失望的是我错过了那一天的飞机，原本安排的好好的行程，一下子把我的计划打乱了。这时候我真的很迷茫，我不知道该去哪里，我也不知道该做什么，整个脑子是一片空白，在街上走走，最后回学校见到了精神支柱。然后去了太原平遥古城，喜欢太原老大爷那种街边悠然下着象棋的生活。</p>\n<p>**2017年7月10日 嘉兴-福州：**又是一次暑假，我去嘉兴看望我爸，然后我爸他们提议去福州找我的大姑爷家玩，这一次我和我的父亲快吵了一架，因为我想让他买一张动车票，可父亲执着的只买绿皮车票，他觉得能节约钱，可是我觉得时间才是最重要的，那时候我没有一点收入，我说服不了他，绿皮车从晚上八点开到第二天早上八点，整个一晚我没有怎么睡，感慨太多，我也告诉我自己要努力。当时也写过一篇随笔：<a href=\"http://julis.wang/2017/07/10/2018%E5%B9%B4710%E9%9A%8F%E7%AC%94-%E4%BA%8E%E5%98%89%E5%85%B4-%E7%A6%8F%E5%B7%9E%E5%88%97%E8%BD%A6/\" title=\"2017年710随笔 于嘉兴-福州列车\">2017年710随笔 于嘉兴-福州列车</a></p>\n<p>**2017年9月02日 温州-杭州：**这一次算是第一次以异地恋的身份去见了那时喜欢的人，一路忐忑。记得那时候带的是一本《小王子》，但是感觉没有看太懂，好像过了天真的年纪，已经看不太明白小王子的天真了。</p>\n<p><strong>2018年8月23日 杭州-太原：</strong> 或许真的是和太原有缘分，时隔一年再次去太原，这次我并没有错过，过了一年，变得成熟些了，这时候我已经在参加实习了。这次是代表整个学校唯一一只队伍进电子商务全国总决赛，压力与动力并存吧。</p>\n<p>**2019年2月14日 德阳-成都：**这是最近一次从家出发去杭州在成都中转，在德阳站中因为高铁晚点，我遇到了一个女孩子，或许这是读大学以后认识的第一个非本大学的四川女孩子吧，或许是缘分，我和她是同一辆车，在德阳到成都只有短短半个小时的行车时间，居然车晚点将近两个小时，于是和她就聊啊、聊啊，从小学说到初中高中，从高中说到大学，再从大学说到实习。原来她也和我一样是大四的学生，原来我和她大学同学是初中高中同学，真的是缘分吧。第一次是多么的希望列车晚点的时间能够再长一点。只可惜，我本将心照明月，奈何明月照沟渠。</p>\n<p>……</p>\n<p><strong>2019年6月10日 杭州-青岛、烟台、威海、大连？</strong>  或许是在被公司同事的鼓励下：现在有时间多出去玩玩吧，实习一天也没有多少钱，等以后正式工作了，有钱也没有时间了，趁现在，多出去走走吧。感谢芳姐姐对我的支助，让我有机会去计划这次旅行。</p>\n<p>这一次，我是第一次一个人的旅行，我想在这炎热的夏天里，走出屋子，踏上行程。去坐一次轮渡、我还想再使用学生证享受一次学生特权、然后去看看海、去吹吹风、去看看更多的天空、去认识的人并说：“很高兴认识你”。也算是对整个大学青春岁月画上一个句号吧。<br>那接下来的一路上又会发生什么故事呢？</p>\n<p>最后以王小波的《黄金时代》结尾吧：<strong>那一天我二十一岁，在我一生的黄金时代，我有好多奢望。我想爱，想吃，还想在一瞬间变成天上半明半暗的云，后来我才知道，生活就是个缓慢受锤的过程，人一天天老下去，奢望也一天天消逝，最后变得像挨了锤的牛一样。可是我过二十一岁生日时没有预见到这一点。我觉得自己会永远生猛下去，什么也锤不了我。</strong></p>\n<p>我还年轻，我还可以到处走走，我还有很多想要去憧憬的、盼望的……</p>\n<p>–于2019.06.04 7:24 即将下班回家</p>\n","cover":null,"images":[],"content":"<p>忙碌的一天，又要到下班的时候了，一天好似很忙，其实回过头来仔细想想，一天好像并没有做太多的事情，然而确实是这样子度过一天了，就像我们的青春岁月，看样子并没有经历什么，但它就这样匆匆过去了，亦忧伤，亦憧憬。</p>\n<p>还有两周就要回校参加毕业典礼了，向公司请了十天假，算上端午以及周末，大概有半个多月属于自己的日子吧，也算是大学最后一点还是以学生身份存在的时间了。早在几个月前我都在筹划这次出去游玩了，因为我想出去走走，想出去看看。纵观整个大学生涯，自己也算是去了不少地方了，屋子里车票、机票已经收纳了一沓了。看着每一张车票的起点与终点以及行程时间，还能想起那时候发生过的事，或许有些事还在记忆里面，或许可能存在我的日记里面，或许我什么也记不得了。</p>\n<p>**2015年8月15日 绵阳-上海：**距离大学开学还有一个月了，父亲陪我度过了整个高三，待我拿到通知书后，我与父亲来到上海。父亲是一个节俭的人，买了绿皮车，将近两千多公里的路程，三十多个小时的行程，脚没有办法舒展开，时间长了别的难受。当看到那些没有座位的那些人要不停地给过路人让路的时候，我觉得自己也挺幸运的，至少我还有一个属于自己的位置，不需要为别人让路。在这煎熬的行程中，我并没有去抱怨，我只是一直在想，我以后一定要努力，一定不会让我和我父亲再受这样的遭遇。</p>\n<p><strong>2015年9月14日 上海-温州</strong>：马上就要大学开学了。离开了父母，将一个人去面对新的生活了，路过杭州的时候，车窗外一片开阔的平原，让我看到极具江南特色的景象：鳞次栉比的房屋伴着小河流，来来往往的车辆川流不息，很憧憬那样“小桥流水人家”的生活，这大概是对杭州的第一印象吧。</p>\n<p>**2016年1月22日 温州-成都：**大学寒假第一次回家，运气很好，我和同学抢到了卧铺票，有了一个较舒服的乘车环境。与我通行的还有很多大学川籍同学，因此一路上也变得并不孤独，时而和他们“摆龙门阵”，累了就回床铺上面去休息一下，我记得我当时带了一本《浪潮之巅》。</p>\n<p>**2017年7月18日 温州-太原：**第一次坐飞机，带着许多憧憬出发，但让人失望的是我错过了那一天的飞机，原本安排的好好的行程，一下子把我的计划打乱了。这时候我真的很迷茫，我不知道该去哪里，我也不知道该做什么，整个脑子是一片空白，在街上走走，最后回学校见到了精神支柱。然后去了太原平遥古城，喜欢太原老大爷那种街边悠然下着象棋的生活。</p>\n<p>**2017年7月10日 嘉兴-福州：**又是一次暑假，我去嘉兴看望我爸，然后我爸他们提议去福州找我的大姑爷家玩，这一次我和我的父亲快吵了一架，因为我想让他买一张动车票，可父亲执着的只买绿皮车票，他觉得能节约钱，可是我觉得时间才是最重要的，那时候我没有一点收入，我说服不了他，绿皮车从晚上八点开到第二天早上八点，整个一晚我没有怎么睡，感慨太多，我也告诉我自己要努力。当时也写过一篇随笔：<a href=\"http://julis.wang/2017/07/10/2018%E5%B9%B4710%E9%9A%8F%E7%AC%94-%E4%BA%8E%E5%98%89%E5%85%B4-%E7%A6%8F%E5%B7%9E%E5%88%97%E8%BD%A6/\" title=\"2017年710随笔 于嘉兴-福州列车\">2017年710随笔 于嘉兴-福州列车</a></p>\n<p>**2017年9月02日 温州-杭州：**这一次算是第一次以异地恋的身份去见了那时喜欢的人，一路忐忑。记得那时候带的是一本《小王子》，但是感觉没有看太懂，好像过了天真的年纪，已经看不太明白小王子的天真了。</p>\n<p><strong>2018年8月23日 杭州-太原：</strong> 或许真的是和太原有缘分，时隔一年再次去太原，这次我并没有错过，过了一年，变得成熟些了，这时候我已经在参加实习了。这次是代表整个学校唯一一只队伍进电子商务全国总决赛，压力与动力并存吧。</p>\n<p>**2019年2月14日 德阳-成都：**这是最近一次从家出发去杭州在成都中转，在德阳站中因为高铁晚点，我遇到了一个女孩子，或许这是读大学以后认识的第一个非本大学的四川女孩子吧，或许是缘分，我和她是同一辆车，在德阳到成都只有短短半个小时的行车时间，居然车晚点将近两个小时，于是和她就聊啊、聊啊，从小学说到初中高中，从高中说到大学，再从大学说到实习。原来她也和我一样是大四的学生，原来我和她大学同学是初中高中同学，真的是缘分吧。第一次是多么的希望列车晚点的时间能够再长一点。只可惜，我本将心照明月，奈何明月照沟渠。</p>\n<p>……</p>\n<p><strong>2019年6月10日 杭州-青岛、烟台、威海、大连？</strong>  或许是在被公司同事的鼓励下：现在有时间多出去玩玩吧，实习一天也没有多少钱，等以后正式工作了，有钱也没有时间了，趁现在，多出去走走吧。感谢芳姐姐对我的支助，让我有机会去计划这次旅行。</p>\n<p>这一次，我是第一次一个人的旅行，我想在这炎热的夏天里，走出屋子，踏上行程。去坐一次轮渡、我还想再使用学生证享受一次学生特权、然后去看看海、去吹吹风、去看看更多的天空、去认识的人并说：“很高兴认识你”。也算是对整个大学青春岁月画上一个句号吧。<br>那接下来的一路上又会发生什么故事呢？</p>\n<p>最后以王小波的《黄金时代》结尾吧：<strong>那一天我二十一岁，在我一生的黄金时代，我有好多奢望。我想爱，想吃，还想在一瞬间变成天上半明半暗的云，后来我才知道，生活就是个缓慢受锤的过程，人一天天老下去，奢望也一天天消逝，最后变得像挨了锤的牛一样。可是我过二十一岁生日时没有预见到这一点。我觉得自己会永远生猛下去，什么也锤不了我。</strong></p>\n<p>我还年轻，我还可以到处走走，我还有很多想要去憧憬的、盼望的……</p>\n<p>–于2019.06.04 7:24 即将下班回家</p>\n","categories":[{"name":"生活感想","slug":"life","api":"api/categories/life.json"}],"tags":[{"name":"旅行","slug":"travel","api":"api/tags/travel.json"}],"api":"api/posts/2019/06/04/写在毕业之际旅行前.json"}],"info":{"type":"index"}},"api":"api/posts/page.6.json"}