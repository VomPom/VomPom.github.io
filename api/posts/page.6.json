{"data":{"index":6,"total":8,"posts":[{"title":"从奶酪夹心饼干生产中来学习Android 中的gradle构建","slug":"从奶酪夹心饼干生产中来学习Android-中的gradle","date":"2019-12-18T11:48:00.000Z","updated":"2025-05-20T11:46:57.000Z","comments":true,"url":"2019/12/18/从奶酪夹心饼干生产中来学习Android-中的gradle/","excerpt":"<p>最近终于有机会做一些关于Android plugin相关的东西，之前虽然有学习过<code>《Android 权威指南》</code>一书，但是并没有进行一个实战操作，都是一些理论相关的学习。最近做了一个plugin主要是为了提取class文件里面的注解信息然后讲起搜集并上传。在实践中回过头发现很多知识都已经遗忘，所以本文对相关一些比较核心的知识进行一个回顾与梳理。</p>\n<h2 id=\"一、Gradle概述\"><a href=\"#一、Gradle概述\" class=\"headerlink\" title=\"一、Gradle概述\"></a>一、Gradle概述</h2><img src=\"https://cdn.julis.wang/blog/img/20191218190829347.png\">\n<p>在Android开发中，Gradle是每个开发者都会接触的，Gradle 是一个非常优秀的项目构建工具。这是大家都知道的，但是又有啥用呢？</p>\n<p>最开始的时候很难理解gradle到底是干什么的，相关知识都比较离散，所以很多东西没有串起来，从而导致理解起来比较困难。</p>\n<p>我自己总结就是：<strong>Gradle是一个构建工具，它存在的目的是产生一套“流水线”，对于安卓开发而言这个流水线就是从本地的编写代码以及资源整合到最终生成的产品过程。</strong></p>\n<p>用一个很形象的例子举例，我们现在要生产一包奶酪夹心饼干，于是我们得定义一个生产顺序：先让有的地方去生成饼干，有的地方生成出来奶酪，之后再让两块饼干夹着一块奶酪，最后再将它们装进一个小包装袋里面。</p>\n<p>另一种情况：如果我想在奶酪中加一点果酱，那么我们不需要重新建立一套生产线，只需要在两块饼干与奶酪结合的过程中修改一下加入果酱的流程。</p>\n<p>再另一种情况：如果我生产出来的奶酪夹心饼干不需要包装，那只需要在最后一个步骤让它另外走一条线路，毕竟没有包装的又不是不能吃，对吧？<br><img src=\"https://cdn.julis.wang/blog/img/20191218143302953.png\"><br>如上图所示，我们定义了三种流程，每种流程最后的产出物是不一样的，因为流程的“<strong>初始化</strong>”的东西是不一样的以及过程中的“<strong>配置</strong>”，所以“<strong>执行</strong>”的时候就不一样。</p>\n<p>对比我们安卓开发：本地的Java文件以及资源文件就是对应的饼干以及奶酪，最终生成的面向用户的apk文件就是包装好的奶酪夹心饼干。</p>\n<p>如果我们想打Debug包，那么就像是一个散装的饼干，我们能自己用用，但是还不能面向用户，如果想打Release包那么就是最终的产品形态能直接面向用户。</p>\n<p>上面的例子讲得比较长，其实主要想让更多人能够更好地去理解gradle的用处。</p>\n<p>当我们每次点击Android Studio的 run运行按钮之后，会看到控制台输出一大堆相关日志，例如下图所示：</p>\n<img width=\"60%\" src=\"https://cdn.julis.wang/blog/img/20191218110343253.png\">\n<p>其实这些都是系统为我们封装好的一些task<br>点击 run 按钮，就相当于执行了一次 Gradle Task，一般来说，是Task <code>assembleDebug</code>或者Task <code>assembleRelease</code></p>\n<p>Gradle是目前Android主流的构建工具，无论通过命令行还是通过AndroidStudio来build，最终都是通过Gradle来实现的。以及Android领域的探索已经越来越深，不少技术领域如插件化、热修复、构建系统等都对Gradle有相关的需要。</p>\n<h2 id=\"二、Groovy\"><a href=\"#二、Groovy\" class=\"headerlink\" title=\"二、Groovy\"></a>二、Groovy</h2><p>知道了Gradle的用处之后，我们很形象的知道Gradle是为了去产生一个流水线。那这个流水线是利用什么做到的呢？对于奶酪饼干生产的工厂他们是不同的车间机械工具直接的逻辑组装。而对于Gradle则是利用<code>groovy</code>语言编写出来的相关脚本从而来进行一个编译相关的配置。这里不再具体描述groovy语言的具体用法，这里我列举出来几个自己认为比较重要的几个技术点。</p>\n<p><strong>1、Closure（闭包）</strong><br><code>闭包</code>是的groovy语言具有，而Java语言不具有的特性，有人说Lambda表达式就是闭包，但是两则还是有一定的差异的，有兴趣的同学可以去看看这篇<a href=\"https://editor.csdn.net/md/?articleId=102466814\">Java中Lambda表达式解析</a></p>\n<p>定义闭的语意 ：</p>\n<blockquote>\n<p><strong>{ [closureParameters -&gt; ] statements }</strong></p>\n</blockquote>\n<p>其中<code>[closureParameters-&gt;]</code>代表参数，多参数用逗号分割，用<code>-&gt;</code>隔开参数与内容，没有参数可以不写<code>-&gt;</code>例如我们精彩在.gradle文件里面看到这样的内容：</p>\n<img src=\"https://cdn.julis.wang/blog/img/20191218150133412.png\">\n<p>其中<code>projcet</code>就是<code>[closureParameters-&gt;]</code>，<code>-&gt;</code>之后的<code>respositories</code>就是statements，对于这段代码而言，statements里面又是一个闭包，如果改写成Java的样子就更形象了：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> <span class=\"title function_\">subprojercts</span><span class=\"params\">(Project projct)</span> &#123;</span><br><span class=\"line\">\tdoSomething....</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>2、方法的输入参数优化</strong><br>groovy中定义的函数，如果至少有一个参数，在调用的时候可以省略括号。比如这样</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">def <span class=\"title function_\">func</span><span class=\"params\">(String a)</span>&#123;</span><br><span class=\"line\">  println(a)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">func &#x27;hello&#x27;</span><br></pre></td></tr></table></figure>\n<p>在gradle有大量省略括号调用函数的例子，比如</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">defaultConfig &#123;</span><br><span class=\"line\">        minSdkVersion rootProject.ext.minSdkVersion</span><br><span class=\"line\">        targetSdkVersion rootProject.targetSdkVersion</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>比如这里minSdkVersion 和 targetSdkVersion 其实就是调用了两个函数,传入了不同的参数，在AndroidStudio里面可以点进去查看函数实现</p>\n<p>当然如果某个函数没有参数，那就不能省略括号，否则会当成一个变量使用</p>\n<p><strong>3、类的Property</strong></p>\n<p>如果类的成员变量没有加任何权限访问，则称为<code>Property</code>, 否则是<code>Field</code>，filed和Java中的成员变量相同，但是<code>Property</code>的话，它是一个private field和getter setter的集合，也就是说groovy会自动生成getter setter方法，因此在类外面的代码，都是会透明的调用getter和setter方法。</p>\n<p><strong>4、Trait</strong></p>\n<p>特性使用关键字 trait 声明，可以拥有普通成员和抽象成员。例如：<br><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">trait MessageHandler &#123;</span><br><span class=\"line\">    <span class=\"comment\">//  属性</span></span><br><span class=\"line\">    <span class=\"type\">int</span> minLenght</span><br><span class=\"line\">    <span class=\"comment\">//  方法</span></span><br><span class=\"line\">    <span class=\"comment\">//  普通方法</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span> <span class=\"title function_\">echo</span><span class=\"params\">(String msg)</span> &#123;</span><br><span class=\"line\">        println(msg)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//  抽象方法</span></span><br><span class=\"line\">    <span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title function_\">show</span><span class=\"params\">(String msg)</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">trait AnotherMessageHandler &#123;</span><br><span class=\"line\">    <span class=\"comment\">//  抽象方法</span></span><br><span class=\"line\">    <span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title function_\">show</span><span class=\"params\">(String msg)</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Message</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">AnotherMessageHandler</span>, MessageHandler &#123;</span><br><span class=\"line\">.......</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>Groovy 中特质本质上是运行时对接口的实现，所以其方法的访问控制符只支持 public 和 private。从代码的书写可以看出来<code>trait</code>又像java中的<code>abstract</code>类又像<code>interface</code>。<br>说他像<code>interface</code>是因为从编写上看就是使用了<code>implements</code>关键字，但是接口又不能使用普通方法。说他像抽象类，因为其内部使用了<code>abstract</code>定义抽象方法。但是它又能<code>implements</code>多个，而达到“多继承”的特性。因此它不是接口，也不是抽象类，它是 <code>trait</code>。</p>\n<h2 id=\"三、Gradle的依赖\"><a href=\"#三、Gradle的依赖\" class=\"headerlink\" title=\"三、Gradle的依赖\"></a>三、Gradle的依赖</h2><p>我们继续回到上面奶酪夹心饼干的生产上面，在产出奶酪夹心饼干之前，我们需要分别生产好单独的饼干与奶酪。假如我们的饼干原料有很多种，姑且我们叫他饼干v1，饼干v2……饼干vn ，奶酪也有很多种，我们叫它奶酪v1，奶酪v2……奶酪vn。那这么多种具体生产起来就应该有相关的选择，在Android开发中各种库都被单独抽了出来，只需要单独声明出来需要用哪个库即可。</p>\n<p>我们平时看的的<code>dependencies</code>如下所示</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">dependencies &#123;</span><br><span class=\"line\">    implementation <span class=\"title function_\">fileTree</span><span class=\"params\">(dir: <span class=\"string\">&#x27;libs&#x27;</span>, include: [<span class=\"string\">&#x27;*.jar&#x27;</span>])</span></span><br><span class=\"line\">    implementation <span class=\"string\">&#x27;com.android.support:appcompat-v7:28.0.0&#x27;</span></span><br><span class=\"line\">    implementation <span class=\"string\">&#x27;com.victor:lib:1.0.4&#x27;</span></span><br><span class=\"line\">    api <span class=\"string\">&#x27;com.android.support:recyclerview-v7:28.0.0&#x27;</span></span><br><span class=\"line\">    implementation <span class=\"string\">&#x27;com.google.code.gson:gson:2.8.6&#x27;</span></span><br><span class=\"line\">    implementation(<span class=\"string\">&#x27;com.wanjian:sak:0.1.0&#x27;</span>) &#123;</span><br><span class=\"line\">        exclude group: <span class=\"string\">&#x27;com.android.support&#x27;</span>, <span class=\"keyword\">module</span>: <span class=\"string\">&#x27;appcompat-v7&#x27;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>1、依赖配置</strong><br>Gradle依赖的配置中主要使用以下关键字，摘自<a href=\"https://developer.android.com/studio/build/dependencies?hl=zh-cn\">谷歌官方Gradle文档-&gt;添加编译依赖项</a></p>\n<p><strong>implementation</strong><br>Gradle 会将依赖项添加到编译类路径，并将依赖项打包到编译输出。不过，当您的模块配置 implementation 依赖项时，会让 Gradle 了解您不希望该模块在编译时将该依赖项泄露给其他模块。也就是说，其他模块只有在运行时才能使用该依赖项。</p>\n<p><strong>api</strong><br>Gradle 会将依赖项添加到编译类路径和编译输出。当一个模块包含 api 依赖项时，会让 Gradle 了解该模块要以传递方式将该依赖项导出到其他模块，以便这些模块在运行时和编译时都可以使用该依赖项</p>\n<p><strong>annotationProcessor</strong><br>要添加对作为注解处理器的库的依赖关系，您必须使用 annotationProcessor 配置将其添加到注解处理器类路径。这是因为，使用此配置可以将编译类路径与注解处理器类路径分开，从而提高编译性能。如果 Gradle 在编译类路径上找到注解处理器，则会禁用避免编译功能，这样会对编译时间产生负面影响（Gradle 5.0 及更高版本会忽略在编译类路径上找到的注解处理器）。</p>\n<p><strong>2、依赖的传递与冲突</strong><br>    在Maven仓库中，构件通过POM（一种XML文件）来描述相关信息以及传递性依赖。Gradle 可以通过分析该文件获取获取所以依赖以及依赖的依赖和依赖的依赖的依赖，为了更加直观的表述，可以通过下面的输出结果了解。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">+--- com.github.hotchemi:permissionsdispatcher:<span class=\"number\">2.2</span><span class=\"number\">.0</span></span><br><span class=\"line\">|    \\--- com.android.support:support-v4:<span class=\"number\">23.1</span><span class=\"number\">.1</span> -&gt; <span class=\"number\">28.0</span><span class=\"number\">.0</span></span><br><span class=\"line\">|         +--- com.android.support:support-compat:<span class=\"number\">28.0</span><span class=\"number\">.0</span></span><br><span class=\"line\">|         |    +--- com.android.support:support-annotations:<span class=\"number\">28.0</span><span class=\"number\">.0</span></span><br><span class=\"line\">|         |    +--- com.android.support:collections:<span class=\"number\">28.0</span><span class=\"number\">.0</span></span><br><span class=\"line\">|         |    |    \\--- com.android.support:support-annotations:<span class=\"number\">28.0</span><span class=\"number\">.0</span></span><br><span class=\"line\">|         |    +--- android.arch.lifecycle:runtime:<span class=\"number\">1.1</span><span class=\"number\">.1</span></span><br><span class=\"line\">|         |    |    +--- android.arch.lifecycle:common:<span class=\"number\">1.1</span><span class=\"number\">.1</span></span><br><span class=\"line\">|         |    |    |    \\--- com.android.support:support-annotations:<span class=\"number\">26.1</span><span class=\"number\">.0</span> -&gt; <span class=\"number\">28.0</span><span class=\"number\">.0</span></span><br><span class=\"line\">|         |    |    +--- android.arch.core:common:<span class=\"number\">1.1</span><span class=\"number\">.1</span></span><br><span class=\"line\">|         |    |    |    \\--- com.android.support:support-annotations:<span class=\"number\">26.1</span><span class=\"number\">.0</span> -&gt; <span class=\"number\">28.0</span><span class=\"number\">.0</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>我依赖hotchemi:permissionsdispatcher这个库，而它内部又陆陆续续地依赖了后面的一大堆。借助Gradle的传递性依赖特性，你无需再你的脚本中把这些依赖都声明一遍，你只需要简单的一行，Gradle便会帮你将传递性依赖一起下载下来。</p>\n<p>然而问题来了这里面依赖了：<code>android.arch.core:common:1.1.1</code>  而我本地其他地方又使用了<code>android.arch.core:common:1.0.0</code>老版本。那我该如何去做这件事呢？</p>\n<p>于是便有了如下关键词：<br><strong>exclude<br>force<br>transitive</strong></p>\n<p>具体作用如下代码所示</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">implementation (<span class=\"string\">&#x27;com.google.code.gson:gson:2.8.6&#x27;</span>) &#123;</span><br><span class=\"line\">    force = <span class=\"literal\">true</span> <span class=\"comment\">//强制使用这个版本的库</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">implementation (<span class=\"string\">&#x27;de.hdodenhof:circleimageview:3.0.1&#x27;</span>) &#123;</span><br><span class=\"line\">    transitive = <span class=\"literal\">true</span> <span class=\"comment\">//防止向外暴露</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">implementation(<span class=\"string\">&#x27;com.wanjian:sak:0.1.0&#x27;</span>) &#123;</span><br><span class=\"line\">    exclude group: <span class=\"string\">&#x27;com.android.support&#x27;</span>, <span class=\"keyword\">module</span>: <span class=\"string\">&#x27;appcompat-v7&#x27;</span> <span class=\"comment\">//排除里面不需要的库</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"四、Gradle的Task构建与执行\"><a href=\"#四、Gradle的Task构建与执行\" class=\"headerlink\" title=\"四、Gradle的Task构建与执行\"></a>四、Gradle的Task构建与执行</h2><p>再回到生产饼干的例子上面来，最开始我们定义了一些流程，然后再让机器以该流程去执行。</p>\n<p>比如先准备两块饼干再与奶酪进行加工生成夹心饼干，最后再加入包装。这是一条正确的流水，我们不可能让加入包装在加工生成夹心饼干之前。于是我们得定义一些约束，让其有正确的执行顺序。或者我们像加入果酱，那么就应该对原始的流程进行一些添加。</p>\n<p>对于Gradle中，我们以Task为单位，类比生产奶酪饼干，生成饼干是一个专门的Task，生成奶酪也是一个专门的Task，加工成夹心也是一个Task……对于Android开发，将java文件编译为class，再到最后的dex生成都是Task</p>\n<p>在Task的构建与执行中主要分为三个流程：</p>\n<p><strong>初始化（Initialization）</strong><br>settings.gradle确定参与构建的module<br>为每个module创建Project对象实例</p>\n<p><strong>配置（Configuration ）</strong><br>build.gradle脚本执行，配置对应project实例<br>创建有向无环图<br>通过finalizedBy指定后续<br>通过must/shouldRunAfter约束执行顺序</p>\n<p><strong>执行（Execution ）</strong><br>根据关系图执行task<br>监听器</p>\n<p>主要流程如图所示（图片摘自<a href=\"https://www.jianshu.com/p/0acdb31eef2d\">https://www.jianshu.com/p/0acdb31eef2d</a>）：</p>\n<img src=\"https://cdn.julis.wang/blog/img/20191218190105218.png\">\n<h2 id=\"五、Gradle插件\"><a href=\"#五、Gradle插件\" class=\"headerlink\" title=\"五、Gradle插件\"></a>五、Gradle插件</h2><p>继续奶酪夹心饼干的故事，如果夹心饼干模样规规矩矩没有花纹，岂不是很low？于是工厂专门研发了一款能让饼干产生纹路的机器，并在加工成夹心饼干之前将纹路印到饼干上面去，假如这台机器我们把它叫做“印花纹机”，是一个能从整个生产流程中独立的出来的机器，这台“印花纹机”也能用在生产其他的饼干上。</p>\n<p>对应在我们的Android开发中，在构建流程中我们抽离出来一些功能，将其独立开来，这就是plugin，这里不再讲解plugin的编写相关操作，可以参考<a href=\"https://juejin.im/post/5cc5929bf265da036706b350\">Gradle 自定义 plugin</a></p>\n<p><strong>1、插件分类</strong></p>\n<p><strong>脚本插件</strong><br>顾名思义，如下图所示我们将对应的插件脚本中加入相关插件的逻辑，如下图所示，“other.gradle”便是一个插件</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">apply from: <span class=\"string\">&#x27;other.gradle&#x27;</span></span><br></pre></td></tr></table></figure>\n<p><strong>二进制插件</strong><br>二进制插件就是实现了 org.gradle.api.Plugin 接口的插件，每个 Java Gradle 插件都有一个 plugin id，可以通过如下方式使用一个 Java 插件：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">apply plugin : <span class=\"string\">&#x27;maven&#x27;</span></span><br></pre></td></tr></table></figure>\n<p>通过上述代码就将 Java 插件应用到我们的项目中了，其中 <code>maven</code> 是 Java 插件的 plugin id，对于 Gradle 自带的核心插件都有唯一的 plugin id</p>\n<p><strong>2、打包方式</strong></p>\n<p><strong>build script</strong><br>在插件分类中我们提到有<code>apply from: &#39;other.gradle&#39;</code> 其中<code>other.gradle</code>就是一个打包好的build script</p>\n<p><strong>buildSrc</strong><br>将插件写在工程根目录下的buildSrc目录下，这样可以在多个模块之间复用该插件。<br>buildSrc是Gradle在项目中配置自定义插件的默认目录，但它并不是标准的Android工程目录，所以使用这种方式需要我们事先手动创建一个buildSrc目录</p>\n<img width=\"60%\" src=\"https://cdn.julis.wang/blog/img/20191218194223783.png\">\n<p><strong>独立项目</strong><br>创建独立的插件项目具有更强的灵活性，能让更多的工程使用这个插件，但流程也会相对复杂一点.这里不再具体讲解，可以参考<a href=\"https://juejin.im/post/5cc5929bf265da036706b350\">Gradle 自定义 plugin</a></p>\n<p>参考资料：</p>\n<p><a href=\"https://www.jianshu.com/p/6dc2074480b8\">https://www.jianshu.com/p/6dc2074480b8</a><br><a href=\"https://www.jianshu.com/p/bcaf9a269d96\">https://www.jianshu.com/p/bcaf9a269d96</a><br><a href=\"https://juejin.im/entry/59918304518825489151732d\">https://juejin.im/entry/59918304518825489151732d</a><br><a href=\"https://www.jianshu.com/p/0acdb31eef2d\">https://www.jianshu.com/p/0acdb31eef2d</a><br><a href=\"https://juejin.im/post/5cc5929bf265da036706b350\">https://juejin.im/post/5cc5929bf265da036706b350</a><br><a href=\"https://doc.yonyoucloud.com/doc/wiki/project/GradleUserGuide-Wiki/gradle_plugins/binary_plugins.html\">https://doc.yonyoucloud.com/doc/wiki/project/GradleUserGuide-Wiki/gradle_plugins/binary_plugins.html</a></p>\n","cover":null,"images":["https://cdn.julis.wang/blog/img/20191218190829347.png","https://cdn.julis.wang/blog/img/20191218143302953.png","https://cdn.julis.wang/blog/img/20191218110343253.png","https://cdn.julis.wang/blog/img/20191218150133412.png","https://cdn.julis.wang/blog/img/20191218190105218.png","https://cdn.julis.wang/blog/img/20191218194223783.png"],"content":"<p>最近终于有机会做一些关于Android plugin相关的东西，之前虽然有学习过<code>《Android 权威指南》</code>一书，但是并没有进行一个实战操作，都是一些理论相关的学习。最近做了一个plugin主要是为了提取class文件里面的注解信息然后讲起搜集并上传。在实践中回过头发现很多知识都已经遗忘，所以本文对相关一些比较核心的知识进行一个回顾与梳理。</p>\n<h2 id=\"一、Gradle概述\"><a href=\"#一、Gradle概述\" class=\"headerlink\" title=\"一、Gradle概述\"></a>一、Gradle概述</h2><img src=\"https://cdn.julis.wang/blog/img/20191218190829347.png\">\n<p>在Android开发中，Gradle是每个开发者都会接触的，Gradle 是一个非常优秀的项目构建工具。这是大家都知道的，但是又有啥用呢？</p>\n<p>最开始的时候很难理解gradle到底是干什么的，相关知识都比较离散，所以很多东西没有串起来，从而导致理解起来比较困难。</p>\n<p>我自己总结就是：<strong>Gradle是一个构建工具，它存在的目的是产生一套“流水线”，对于安卓开发而言这个流水线就是从本地的编写代码以及资源整合到最终生成的产品过程。</strong></p>\n<p>用一个很形象的例子举例，我们现在要生产一包奶酪夹心饼干，于是我们得定义一个生产顺序：先让有的地方去生成饼干，有的地方生成出来奶酪，之后再让两块饼干夹着一块奶酪，最后再将它们装进一个小包装袋里面。</p>\n<p>另一种情况：如果我想在奶酪中加一点果酱，那么我们不需要重新建立一套生产线，只需要在两块饼干与奶酪结合的过程中修改一下加入果酱的流程。</p>\n<p>再另一种情况：如果我生产出来的奶酪夹心饼干不需要包装，那只需要在最后一个步骤让它另外走一条线路，毕竟没有包装的又不是不能吃，对吧？<br><img src=\"https://cdn.julis.wang/blog/img/20191218143302953.png\"><br>如上图所示，我们定义了三种流程，每种流程最后的产出物是不一样的，因为流程的“<strong>初始化</strong>”的东西是不一样的以及过程中的“<strong>配置</strong>”，所以“<strong>执行</strong>”的时候就不一样。</p>\n<p>对比我们安卓开发：本地的Java文件以及资源文件就是对应的饼干以及奶酪，最终生成的面向用户的apk文件就是包装好的奶酪夹心饼干。</p>\n<p>如果我们想打Debug包，那么就像是一个散装的饼干，我们能自己用用，但是还不能面向用户，如果想打Release包那么就是最终的产品形态能直接面向用户。</p>\n<p>上面的例子讲得比较长，其实主要想让更多人能够更好地去理解gradle的用处。</p>\n<p>当我们每次点击Android Studio的 run运行按钮之后，会看到控制台输出一大堆相关日志，例如下图所示：</p>\n<img width=\"60%\" src=\"https://cdn.julis.wang/blog/img/20191218110343253.png\">\n<p>其实这些都是系统为我们封装好的一些task<br>点击 run 按钮，就相当于执行了一次 Gradle Task，一般来说，是Task <code>assembleDebug</code>或者Task <code>assembleRelease</code></p>\n<p>Gradle是目前Android主流的构建工具，无论通过命令行还是通过AndroidStudio来build，最终都是通过Gradle来实现的。以及Android领域的探索已经越来越深，不少技术领域如插件化、热修复、构建系统等都对Gradle有相关的需要。</p>\n<h2 id=\"二、Groovy\"><a href=\"#二、Groovy\" class=\"headerlink\" title=\"二、Groovy\"></a>二、Groovy</h2><p>知道了Gradle的用处之后，我们很形象的知道Gradle是为了去产生一个流水线。那这个流水线是利用什么做到的呢？对于奶酪饼干生产的工厂他们是不同的车间机械工具直接的逻辑组装。而对于Gradle则是利用<code>groovy</code>语言编写出来的相关脚本从而来进行一个编译相关的配置。这里不再具体描述groovy语言的具体用法，这里我列举出来几个自己认为比较重要的几个技术点。</p>\n<p><strong>1、Closure（闭包）</strong><br><code>闭包</code>是的groovy语言具有，而Java语言不具有的特性，有人说Lambda表达式就是闭包，但是两则还是有一定的差异的，有兴趣的同学可以去看看这篇<a href=\"https://editor.csdn.net/md/?articleId=102466814\">Java中Lambda表达式解析</a></p>\n<p>定义闭的语意 ：</p>\n<blockquote>\n<p><strong>{ [closureParameters -&gt; ] statements }</strong></p>\n</blockquote>\n<p>其中<code>[closureParameters-&gt;]</code>代表参数，多参数用逗号分割，用<code>-&gt;</code>隔开参数与内容，没有参数可以不写<code>-&gt;</code>例如我们精彩在.gradle文件里面看到这样的内容：</p>\n<img src=\"https://cdn.julis.wang/blog/img/20191218150133412.png\">\n<p>其中<code>projcet</code>就是<code>[closureParameters-&gt;]</code>，<code>-&gt;</code>之后的<code>respositories</code>就是statements，对于这段代码而言，statements里面又是一个闭包，如果改写成Java的样子就更形象了：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> <span class=\"title function_\">subprojercts</span><span class=\"params\">(Project projct)</span> &#123;</span><br><span class=\"line\">\tdoSomething....</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>2、方法的输入参数优化</strong><br>groovy中定义的函数，如果至少有一个参数，在调用的时候可以省略括号。比如这样</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">def <span class=\"title function_\">func</span><span class=\"params\">(String a)</span>&#123;</span><br><span class=\"line\">  println(a)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">func &#x27;hello&#x27;</span><br></pre></td></tr></table></figure>\n<p>在gradle有大量省略括号调用函数的例子，比如</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">defaultConfig &#123;</span><br><span class=\"line\">        minSdkVersion rootProject.ext.minSdkVersion</span><br><span class=\"line\">        targetSdkVersion rootProject.targetSdkVersion</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>比如这里minSdkVersion 和 targetSdkVersion 其实就是调用了两个函数,传入了不同的参数，在AndroidStudio里面可以点进去查看函数实现</p>\n<p>当然如果某个函数没有参数，那就不能省略括号，否则会当成一个变量使用</p>\n<p><strong>3、类的Property</strong></p>\n<p>如果类的成员变量没有加任何权限访问，则称为<code>Property</code>, 否则是<code>Field</code>，filed和Java中的成员变量相同，但是<code>Property</code>的话，它是一个private field和getter setter的集合，也就是说groovy会自动生成getter setter方法，因此在类外面的代码，都是会透明的调用getter和setter方法。</p>\n<p><strong>4、Trait</strong></p>\n<p>特性使用关键字 trait 声明，可以拥有普通成员和抽象成员。例如：<br><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">trait MessageHandler &#123;</span><br><span class=\"line\">    <span class=\"comment\">//  属性</span></span><br><span class=\"line\">    <span class=\"type\">int</span> minLenght</span><br><span class=\"line\">    <span class=\"comment\">//  方法</span></span><br><span class=\"line\">    <span class=\"comment\">//  普通方法</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span> <span class=\"title function_\">echo</span><span class=\"params\">(String msg)</span> &#123;</span><br><span class=\"line\">        println(msg)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//  抽象方法</span></span><br><span class=\"line\">    <span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title function_\">show</span><span class=\"params\">(String msg)</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">trait AnotherMessageHandler &#123;</span><br><span class=\"line\">    <span class=\"comment\">//  抽象方法</span></span><br><span class=\"line\">    <span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title function_\">show</span><span class=\"params\">(String msg)</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Message</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">AnotherMessageHandler</span>, MessageHandler &#123;</span><br><span class=\"line\">.......</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>Groovy 中特质本质上是运行时对接口的实现，所以其方法的访问控制符只支持 public 和 private。从代码的书写可以看出来<code>trait</code>又像java中的<code>abstract</code>类又像<code>interface</code>。<br>说他像<code>interface</code>是因为从编写上看就是使用了<code>implements</code>关键字，但是接口又不能使用普通方法。说他像抽象类，因为其内部使用了<code>abstract</code>定义抽象方法。但是它又能<code>implements</code>多个，而达到“多继承”的特性。因此它不是接口，也不是抽象类，它是 <code>trait</code>。</p>\n<h2 id=\"三、Gradle的依赖\"><a href=\"#三、Gradle的依赖\" class=\"headerlink\" title=\"三、Gradle的依赖\"></a>三、Gradle的依赖</h2><p>我们继续回到上面奶酪夹心饼干的生产上面，在产出奶酪夹心饼干之前，我们需要分别生产好单独的饼干与奶酪。假如我们的饼干原料有很多种，姑且我们叫他饼干v1，饼干v2……饼干vn ，奶酪也有很多种，我们叫它奶酪v1，奶酪v2……奶酪vn。那这么多种具体生产起来就应该有相关的选择，在Android开发中各种库都被单独抽了出来，只需要单独声明出来需要用哪个库即可。</p>\n<p>我们平时看的的<code>dependencies</code>如下所示</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">dependencies &#123;</span><br><span class=\"line\">    implementation <span class=\"title function_\">fileTree</span><span class=\"params\">(dir: <span class=\"string\">&#x27;libs&#x27;</span>, include: [<span class=\"string\">&#x27;*.jar&#x27;</span>])</span></span><br><span class=\"line\">    implementation <span class=\"string\">&#x27;com.android.support:appcompat-v7:28.0.0&#x27;</span></span><br><span class=\"line\">    implementation <span class=\"string\">&#x27;com.victor:lib:1.0.4&#x27;</span></span><br><span class=\"line\">    api <span class=\"string\">&#x27;com.android.support:recyclerview-v7:28.0.0&#x27;</span></span><br><span class=\"line\">    implementation <span class=\"string\">&#x27;com.google.code.gson:gson:2.8.6&#x27;</span></span><br><span class=\"line\">    implementation(<span class=\"string\">&#x27;com.wanjian:sak:0.1.0&#x27;</span>) &#123;</span><br><span class=\"line\">        exclude group: <span class=\"string\">&#x27;com.android.support&#x27;</span>, <span class=\"keyword\">module</span>: <span class=\"string\">&#x27;appcompat-v7&#x27;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>1、依赖配置</strong><br>Gradle依赖的配置中主要使用以下关键字，摘自<a href=\"https://developer.android.com/studio/build/dependencies?hl=zh-cn\">谷歌官方Gradle文档-&gt;添加编译依赖项</a></p>\n<p><strong>implementation</strong><br>Gradle 会将依赖项添加到编译类路径，并将依赖项打包到编译输出。不过，当您的模块配置 implementation 依赖项时，会让 Gradle 了解您不希望该模块在编译时将该依赖项泄露给其他模块。也就是说，其他模块只有在运行时才能使用该依赖项。</p>\n<p><strong>api</strong><br>Gradle 会将依赖项添加到编译类路径和编译输出。当一个模块包含 api 依赖项时，会让 Gradle 了解该模块要以传递方式将该依赖项导出到其他模块，以便这些模块在运行时和编译时都可以使用该依赖项</p>\n<p><strong>annotationProcessor</strong><br>要添加对作为注解处理器的库的依赖关系，您必须使用 annotationProcessor 配置将其添加到注解处理器类路径。这是因为，使用此配置可以将编译类路径与注解处理器类路径分开，从而提高编译性能。如果 Gradle 在编译类路径上找到注解处理器，则会禁用避免编译功能，这样会对编译时间产生负面影响（Gradle 5.0 及更高版本会忽略在编译类路径上找到的注解处理器）。</p>\n<p><strong>2、依赖的传递与冲突</strong><br>    在Maven仓库中，构件通过POM（一种XML文件）来描述相关信息以及传递性依赖。Gradle 可以通过分析该文件获取获取所以依赖以及依赖的依赖和依赖的依赖的依赖，为了更加直观的表述，可以通过下面的输出结果了解。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">+--- com.github.hotchemi:permissionsdispatcher:<span class=\"number\">2.2</span><span class=\"number\">.0</span></span><br><span class=\"line\">|    \\--- com.android.support:support-v4:<span class=\"number\">23.1</span><span class=\"number\">.1</span> -&gt; <span class=\"number\">28.0</span><span class=\"number\">.0</span></span><br><span class=\"line\">|         +--- com.android.support:support-compat:<span class=\"number\">28.0</span><span class=\"number\">.0</span></span><br><span class=\"line\">|         |    +--- com.android.support:support-annotations:<span class=\"number\">28.0</span><span class=\"number\">.0</span></span><br><span class=\"line\">|         |    +--- com.android.support:collections:<span class=\"number\">28.0</span><span class=\"number\">.0</span></span><br><span class=\"line\">|         |    |    \\--- com.android.support:support-annotations:<span class=\"number\">28.0</span><span class=\"number\">.0</span></span><br><span class=\"line\">|         |    +--- android.arch.lifecycle:runtime:<span class=\"number\">1.1</span><span class=\"number\">.1</span></span><br><span class=\"line\">|         |    |    +--- android.arch.lifecycle:common:<span class=\"number\">1.1</span><span class=\"number\">.1</span></span><br><span class=\"line\">|         |    |    |    \\--- com.android.support:support-annotations:<span class=\"number\">26.1</span><span class=\"number\">.0</span> -&gt; <span class=\"number\">28.0</span><span class=\"number\">.0</span></span><br><span class=\"line\">|         |    |    +--- android.arch.core:common:<span class=\"number\">1.1</span><span class=\"number\">.1</span></span><br><span class=\"line\">|         |    |    |    \\--- com.android.support:support-annotations:<span class=\"number\">26.1</span><span class=\"number\">.0</span> -&gt; <span class=\"number\">28.0</span><span class=\"number\">.0</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>我依赖hotchemi:permissionsdispatcher这个库，而它内部又陆陆续续地依赖了后面的一大堆。借助Gradle的传递性依赖特性，你无需再你的脚本中把这些依赖都声明一遍，你只需要简单的一行，Gradle便会帮你将传递性依赖一起下载下来。</p>\n<p>然而问题来了这里面依赖了：<code>android.arch.core:common:1.1.1</code>  而我本地其他地方又使用了<code>android.arch.core:common:1.0.0</code>老版本。那我该如何去做这件事呢？</p>\n<p>于是便有了如下关键词：<br><strong>exclude<br>force<br>transitive</strong></p>\n<p>具体作用如下代码所示</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">implementation (<span class=\"string\">&#x27;com.google.code.gson:gson:2.8.6&#x27;</span>) &#123;</span><br><span class=\"line\">    force = <span class=\"literal\">true</span> <span class=\"comment\">//强制使用这个版本的库</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">implementation (<span class=\"string\">&#x27;de.hdodenhof:circleimageview:3.0.1&#x27;</span>) &#123;</span><br><span class=\"line\">    transitive = <span class=\"literal\">true</span> <span class=\"comment\">//防止向外暴露</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">implementation(<span class=\"string\">&#x27;com.wanjian:sak:0.1.0&#x27;</span>) &#123;</span><br><span class=\"line\">    exclude group: <span class=\"string\">&#x27;com.android.support&#x27;</span>, <span class=\"keyword\">module</span>: <span class=\"string\">&#x27;appcompat-v7&#x27;</span> <span class=\"comment\">//排除里面不需要的库</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"四、Gradle的Task构建与执行\"><a href=\"#四、Gradle的Task构建与执行\" class=\"headerlink\" title=\"四、Gradle的Task构建与执行\"></a>四、Gradle的Task构建与执行</h2><p>再回到生产饼干的例子上面来，最开始我们定义了一些流程，然后再让机器以该流程去执行。</p>\n<p>比如先准备两块饼干再与奶酪进行加工生成夹心饼干，最后再加入包装。这是一条正确的流水，我们不可能让加入包装在加工生成夹心饼干之前。于是我们得定义一些约束，让其有正确的执行顺序。或者我们像加入果酱，那么就应该对原始的流程进行一些添加。</p>\n<p>对于Gradle中，我们以Task为单位，类比生产奶酪饼干，生成饼干是一个专门的Task，生成奶酪也是一个专门的Task，加工成夹心也是一个Task……对于Android开发，将java文件编译为class，再到最后的dex生成都是Task</p>\n<p>在Task的构建与执行中主要分为三个流程：</p>\n<p><strong>初始化（Initialization）</strong><br>settings.gradle确定参与构建的module<br>为每个module创建Project对象实例</p>\n<p><strong>配置（Configuration ）</strong><br>build.gradle脚本执行，配置对应project实例<br>创建有向无环图<br>通过finalizedBy指定后续<br>通过must/shouldRunAfter约束执行顺序</p>\n<p><strong>执行（Execution ）</strong><br>根据关系图执行task<br>监听器</p>\n<p>主要流程如图所示（图片摘自<a href=\"https://www.jianshu.com/p/0acdb31eef2d\">https://www.jianshu.com/p/0acdb31eef2d</a>）：</p>\n<img src=\"https://cdn.julis.wang/blog/img/20191218190105218.png\">\n<h2 id=\"五、Gradle插件\"><a href=\"#五、Gradle插件\" class=\"headerlink\" title=\"五、Gradle插件\"></a>五、Gradle插件</h2><p>继续奶酪夹心饼干的故事，如果夹心饼干模样规规矩矩没有花纹，岂不是很low？于是工厂专门研发了一款能让饼干产生纹路的机器，并在加工成夹心饼干之前将纹路印到饼干上面去，假如这台机器我们把它叫做“印花纹机”，是一个能从整个生产流程中独立的出来的机器，这台“印花纹机”也能用在生产其他的饼干上。</p>\n<p>对应在我们的Android开发中，在构建流程中我们抽离出来一些功能，将其独立开来，这就是plugin，这里不再讲解plugin的编写相关操作，可以参考<a href=\"https://juejin.im/post/5cc5929bf265da036706b350\">Gradle 自定义 plugin</a></p>\n<p><strong>1、插件分类</strong></p>\n<p><strong>脚本插件</strong><br>顾名思义，如下图所示我们将对应的插件脚本中加入相关插件的逻辑，如下图所示，“other.gradle”便是一个插件</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">apply from: <span class=\"string\">&#x27;other.gradle&#x27;</span></span><br></pre></td></tr></table></figure>\n<p><strong>二进制插件</strong><br>二进制插件就是实现了 org.gradle.api.Plugin 接口的插件，每个 Java Gradle 插件都有一个 plugin id，可以通过如下方式使用一个 Java 插件：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">apply plugin : <span class=\"string\">&#x27;maven&#x27;</span></span><br></pre></td></tr></table></figure>\n<p>通过上述代码就将 Java 插件应用到我们的项目中了，其中 <code>maven</code> 是 Java 插件的 plugin id，对于 Gradle 自带的核心插件都有唯一的 plugin id</p>\n<p><strong>2、打包方式</strong></p>\n<p><strong>build script</strong><br>在插件分类中我们提到有<code>apply from: &#39;other.gradle&#39;</code> 其中<code>other.gradle</code>就是一个打包好的build script</p>\n<p><strong>buildSrc</strong><br>将插件写在工程根目录下的buildSrc目录下，这样可以在多个模块之间复用该插件。<br>buildSrc是Gradle在项目中配置自定义插件的默认目录，但它并不是标准的Android工程目录，所以使用这种方式需要我们事先手动创建一个buildSrc目录</p>\n<img width=\"60%\" src=\"https://cdn.julis.wang/blog/img/20191218194223783.png\">\n<p><strong>独立项目</strong><br>创建独立的插件项目具有更强的灵活性，能让更多的工程使用这个插件，但流程也会相对复杂一点.这里不再具体讲解，可以参考<a href=\"https://juejin.im/post/5cc5929bf265da036706b350\">Gradle 自定义 plugin</a></p>\n<p>参考资料：</p>\n<p><a href=\"https://www.jianshu.com/p/6dc2074480b8\">https://www.jianshu.com/p/6dc2074480b8</a><br><a href=\"https://www.jianshu.com/p/bcaf9a269d96\">https://www.jianshu.com/p/bcaf9a269d96</a><br><a href=\"https://juejin.im/entry/59918304518825489151732d\">https://juejin.im/entry/59918304518825489151732d</a><br><a href=\"https://www.jianshu.com/p/0acdb31eef2d\">https://www.jianshu.com/p/0acdb31eef2d</a><br><a href=\"https://juejin.im/post/5cc5929bf265da036706b350\">https://juejin.im/post/5cc5929bf265da036706b350</a><br><a href=\"https://doc.yonyoucloud.com/doc/wiki/project/GradleUserGuide-Wiki/gradle_plugins/binary_plugins.html\">https://doc.yonyoucloud.com/doc/wiki/project/GradleUserGuide-Wiki/gradle_plugins/binary_plugins.html</a></p>\n","categories":[{"name":"技术文章","slug":"technology","api":"api/categories/technology.json"}],"tags":[{"name":"Android","slug":"Android","api":"api/tags/Android.json"}],"api":"api/posts/2019/12/18/从奶酪夹心饼干生产中来学习Android-中的gradle.json"},{"title":"一款快速生成安卓shape的插件--NoCodeShape","slug":"一款快速生成Android-shape的插件-NoCodeShape","date":"2019-11-27T08:06:00.000Z","updated":"2025-05-20T11:46:57.000Z","comments":true,"url":"2019/11/27/一款快速生成Android-shape的插件-NoCodeShape/","excerpt":"<p>NoCodeShape 是一个能可视化界面操作生成Android中Shape.xml的Android Studio插件。对于新手能更好的去接受Android中相对应的属性，对于资深程序员则能简化操作，快速生成shape.xml。项目已经开源 <a href=\"https://github.com/VomPom/NoCodeShape\">NoCodeShape</a></p>\n<h1 id=\"二、NoCodeShape使用方法\"><a href=\"#二、NoCodeShape使用方法\" class=\"headerlink\" title=\"二、NoCodeShape使用方法\"></a>二、NoCodeShape使用方法</h1><h2 id=\"1-下载和安装\"><a href=\"#1-下载和安装\" class=\"headerlink\" title=\"1. 下载和安装\"></a>1. 下载和安装</h2><p>同一般的Android Studio插件下载一样，可以直接<code>Preferences-&gt;Plugins</code> 搜索 <code>NoCodeShape</code>搜索出来结果直接安装再重启即可。<br><img width=\"60%\" src=\"https://cdn.julis.wang/blog/img/20191126190001658.png\"><br>也可以去jetbrains插件管理的官网下载各个版本的插件<br><a href=\"https://plugins.jetbrains.com/plugin/13325-nocodeshape/versions\">https://plugins.jetbrains.com/plugin/13325-nocodeshape/versions</a><br>然后<code>Preferences-&gt;Plugins</code> 再Install plugins from disk从本地安装</p>\n<h2 id=\"2-如何使用\"><a href=\"#2-如何使用\" class=\"headerlink\" title=\"2. 如何使用\"></a>2. 如何使用</h2><p>在新建一个shape.xml文件后，右键选择NoCodeShape或者直接按快捷键Common+U</p>\n<img src=\"https://cdn.julis.wang/blog/img/20191126192542676.png\">\n<p>然后选择自己想要的属性，随着点击事件的进行会生成相关xml代码，并在Android Studio右边有对应的shape形状的展示。如果对应shape.xml有相关属性，NoCodeShape也会生成对应shape.xml属性的操作界面，非常方便。<br>示例：</p>\n<img src=\"https://cdn.julis.wang/blog/img/20191126192336117.gif\">\n<h1 id=\"三、实现原理\"><a href=\"#三、实现原理\" class=\"headerlink\" title=\"三、实现原理\"></a>三、实现原理</h1><p>实现原理总体来说并不复杂，主要是界面相关操作逻辑比较繁琐。</p>\n<p>对于新生成的一个shape.xml来说只需要弹出一个新的操作界面，用户只需要点击对应模块的属性即可。项目使用了<code>单例模式+Bulider建造者模式</code>去管理各个Shape属性，分别生成 <code>Shape、Solid、Corners、Stroke、Gradient</code>的单例，其内部拥有一个Builder用来去承各类型的具体属性。</p>\n<p>  通过界面的操作，对其内部的<code>Builder</code>进行数据的填充，最后在完成各类操作后，将各类型中的Builder中的所有属性提取出并生成一份完整的xml字符串并将其粘贴到Android Studio的操作界面上。</p>\n<p>实现主要分为两大类：</p>\n<h2 id=\"1-拼接生成xml字符串\"><a href=\"#1-拼接生成xml字符串\" class=\"headerlink\" title=\"1. 拼接生成xml字符串\"></a>1. 拼接生成xml字符串</h2><p>字符串拼接算是其中最复杂的部分，一是各shape的类型拥有较多数据，其中一些属性有逻辑存在性，二是生成最终Android Studio的xml字符串的时候格式存在比较多的处理。对于各类属性都继承于<code>BaseXml</code>，其内部拥有一个静态内部<code>Builder</code>类，以相对简单的Solid类来举例，如下所示：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Solid</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">BaseXml</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Builder builder;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"type\">Solid</span> <span class=\"variable\">instance</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Solid <span class=\"title function_\">getInstance</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (instance == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            builder = <span class=\"keyword\">new</span> <span class=\"title class_\">Builder</span>();</span><br><span class=\"line\">            instance = <span class=\"keyword\">new</span> <span class=\"title class_\">Solid</span>();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\"> <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Builder</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">BaseBuilder</span> &#123;</span><br><span class=\"line\">        String color;</span><br><span class=\"line\">        String colorValue;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">setColor</span><span class=\"params\">(String color)</span> &#123;</span><br><span class=\"line\">            <span class=\"built_in\">this</span>.colorValue = color;</span><br><span class=\"line\">            <span class=\"built_in\">this</span>.color = getAttrWithOutUnitStr(<span class=\"string\">&quot;color&quot;</span>, color);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"keyword\">public</span> String <span class=\"title function_\">getBuilderString</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> StringUtils.getString(color);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">clearData</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">            StringUtils.clearObjectData(<span class=\"built_in\">this</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">analysisAttribute</span><span class=\"params\">(Attributes attributes)</span> &#123;</span><br><span class=\"line\">            Solid.getInstance().setChecked(<span class=\"literal\">true</span>);</span><br><span class=\"line\">            setColor(attributes.getValue(<span class=\"string\">&quot;android:color&quot;</span>));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>其类继承于抽象类BaseXml，代码如下所示：<br><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">class</span> <span class=\"title class_\">BaseXml</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">boolean</span> <span class=\"variable\">isChecked</span> <span class=\"operator\">=</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">getCloser</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot; /&gt;&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">getStartTag</span><span class=\"params\">()</span> &#123; </span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">generateXmlString</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">protected</span> String <span class=\"title function_\">getLineFeedString</span><span class=\"params\">()</span> &#123; </span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;\\n&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">isChecked</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> isChecked;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> BaseXml <span class=\"title function_\">setChecked</span><span class=\"params\">(<span class=\"type\">boolean</span> checked)</span> &#123;</span><br><span class=\"line\">        isChecked = checked;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>抽象类提取出来在字符串拼接阶段，各类型常用的基本操作，例如：返回“&lt;solid”这类的开始标签，” /&gt;”结束标签等</p>\n<p>其内部<code>BaseXml</code>拥有对应类拥有的所有属性的常用操作，其继承与抽象类<code>BaseBuilder</code>，代码如下所示</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">class</span> <span class=\"title class_\">BaseBuilder</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> String <span class=\"title function_\">getBuilderString</span><span class=\"params\">()</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title function_\">clearData</span><span class=\"params\">()</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title function_\">analysisAttribute</span><span class=\"params\">(Attributes attributes)</span>;</span><br><span class=\"line\">    <span class=\"keyword\">protected</span> <span class=\"keyword\">final</span> String <span class=\"title function_\">getAttrWithUnitStr</span><span class=\"params\">(String attributeType, String value)</span> &#123;</span><br><span class=\"line\">        String unit;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (TextUtils.isEmpty(value)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"string\">&quot;&quot;</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (value.contains(<span class=\"string\">&quot;px&quot;</span>) || value.contains(<span class=\"string\">&quot;dp&quot;</span>)) &#123;</span><br><span class=\"line\">            unit = <span class=\"string\">&quot;&quot;</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            unit = DefaultData.UNIT;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;android:&quot;</span> + attributeType + <span class=\"string\">&quot;=\\&quot;&quot;</span> + value + unit + <span class=\"string\">&quot;\\&quot;&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">protected</span> <span class=\"keyword\">final</span> String <span class=\"title function_\">getAttrWithOutUnitStr</span><span class=\"params\">(String attributeType, String value)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (TextUtils.isEmpty(value)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"string\">&quot;&quot;</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;android:&quot;</span> + attributeType + <span class=\"string\">&quot;=\\&quot;&quot;</span> + value + <span class=\"string\">&quot;\\&quot;&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">protected</span> <span class=\"keyword\">final</span> String <span class=\"title function_\">getValueOutUnit</span><span class=\"params\">(String value)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (TextUtils.isEmpty(value)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> value;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> value.replace(<span class=\"string\">&quot;dp&quot;</span>, <span class=\"string\">&quot;&quot;</span>).replace(<span class=\"string\">&quot;px&quot;</span>, <span class=\"string\">&quot;&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>BaseBuilder内部封装了一些属性的常用操作，例如生成：<code>android:color=&quot;#FFFFFF&quot;</code>这样的字符串，获取是否带有单位的字串等。<br>并提供三个抽象方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> String <span class=\"title function_\">getBuilderString</span><span class=\"params\">()</span>; <span class=\"comment\">//获取Builder中所有属性拼接好的字符串</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title function_\">clearData</span><span class=\"params\">()</span>; <span class=\"comment\">//清空Builder内部属性值</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title function_\">analysisAttribute</span><span class=\"params\">(Attributes attributes)</span>; <span class=\"comment\">//分析xml数据中的值，这个在第二大点“将原有shape.xml字符串转化为对应操作界面”中将会讲到</span></span><br></pre></td></tr></table></figure>\n<p>以上是基本数据的构造，在最后在控件交互的地方会调用<code>CommonAction</code>类的<code>refreshAndWriteData</code>：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">abstract</span> <span class=\"keyword\">class</span> <span class=\"title class_\">CommonAction</span> &#123;</span><br><span class=\"line\">    JComponent component;</span><br><span class=\"line\">    NoShapeDialog noShapeDialog;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">void</span> <span class=\"title function_\">refreshAndWriteData</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        NoCodeShapeAction.callWriteData();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>最后会调用基本的Action中的<code>writeData()</code>方法，其具体逻辑为<br><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">    * 数据写入xml文件</span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">   <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">writeData</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">       <span class=\"keyword\">final</span> <span class=\"type\">Document</span> <span class=\"variable\">document</span> <span class=\"operator\">=</span> FileDocumentManager.getInstance().getDocument(file);</span><br><span class=\"line\">       <span class=\"keyword\">if</span> (document == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">           <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">               <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Exception</span>(<span class=\"string\">&quot;Document对象为空&quot;</span>);</span><br><span class=\"line\">           &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">               e.printStackTrace();</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">           <span class=\"keyword\">return</span>;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       <span class=\"keyword\">new</span> <span class=\"title class_\">WriteCommandAction</span>.Simple(project) &#123;</span><br><span class=\"line\">           <span class=\"meta\">@Override</span></span><br><span class=\"line\">           <span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">               document.setText(XMLString.getInstance().generateXmlString());</span><br><span class=\"line\">               <span class=\"comment\">//formatCode();</span></span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">       &#125;.execute();</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure><br>利用<code>XMLString.getInstance().generateXmlString()</code>获取各操作类型的所有属性将其拼接为一份完整的shape.xml文件的字段，最后调用插件系统的相关命令将字符串粘贴在系统对应的输入框中。</p>\n<h2 id=\"2-将原有shape-xml字符串转化为对应操作界面\"><a href=\"#2-将原有shape-xml字符串转化为对应操作界面\" class=\"headerlink\" title=\"2. 将原有shape.xml字符串转化为对应操作界面\"></a>2. 将原有shape.xml字符串转化为对应操作界面</h2><p>上面已经讲述类如何拼接生成xml字符串并将其粘贴到Android Studio界面上，此外NoCodeShape不仅支持新生成的shape.xml，同样也支持对旧shape.xml进行修改的能力。与第一步相比较主要多了一步读取Android Studio xml文档并将其转化为对应操作界面的过程。其主要是在操作界面初始化之前执行了如下方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">initSax</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">       <span class=\"type\">String</span> <span class=\"variable\">text</span> <span class=\"operator\">=</span> FileDocumentManager.getInstance().getDocument(file).getText();</span><br><span class=\"line\">       <span class=\"type\">ShapeSaxHandler</span> <span class=\"variable\">handler</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ShapeSaxHandler</span>();</span><br><span class=\"line\">       <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">           handler.createViewList(text);</span><br><span class=\"line\">       &#125; <span class=\"keyword\">catch</span> (ParserConfigurationException e) &#123;</span><br><span class=\"line\">           e.printStackTrace();</span><br><span class=\"line\">       &#125; <span class=\"keyword\">catch</span> (SAXException e) &#123;</span><br><span class=\"line\">           e.printStackTrace();</span><br><span class=\"line\">       &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">           e.printStackTrace();</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n<p>利用ShapeSaxHandler去解析xml里面的元素，参考了<a href=\"https://github.com/laobie/FindViewByMe\">FindViewByMe</a>的解析原理。</p>\n<p>具体操作逻辑如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">createViewList</span><span class=\"params\">(String string)</span> <span class=\"keyword\">throws</span> ParserConfigurationException, SAXException, IOException &#123;</span><br><span class=\"line\">      <span class=\"type\">InputStream</span> <span class=\"variable\">xmlStream</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ByteArrayInputStream</span>(string.getBytes(<span class=\"string\">&quot;UTF-8&quot;</span>));</span><br><span class=\"line\">      <span class=\"type\">SAXParserFactory</span> <span class=\"variable\">factory</span> <span class=\"operator\">=</span> SAXParserFactory.newInstance();</span><br><span class=\"line\">      <span class=\"type\">SAXParser</span> <span class=\"variable\">parser</span> <span class=\"operator\">=</span> factory.newSAXParser();</span><br><span class=\"line\">      parser.parse(xmlStream, <span class=\"built_in\">this</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">startDocument</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> SAXException &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (shapePartList == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">          shapePartList = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;ShapePart&gt;();</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">startElement</span><span class=\"params\">(String uri, String localName, String qName, Attributes attributes)</span> <span class=\"keyword\">throws</span> SAXException &#123;</span><br><span class=\"line\">      <span class=\"keyword\">switch</span> (qName) &#123;</span><br><span class=\"line\">          <span class=\"keyword\">case</span> <span class=\"string\">&quot;shape&quot;</span>:</span><br><span class=\"line\">              Shape.getInstance().getBuilder().analysisAttribute(attributes);</span><br><span class=\"line\">              <span class=\"keyword\">break</span>;</span><br><span class=\"line\">          <span class=\"keyword\">case</span> <span class=\"string\">&quot;stroke&quot;</span>:</span><br><span class=\"line\">              Stroke.getInstance().getBuilder().analysisAttribute(attributes);</span><br><span class=\"line\">              <span class=\"keyword\">break</span>;</span><br><span class=\"line\">          <span class=\"keyword\">case</span> <span class=\"string\">&quot;solid&quot;</span>:</span><br><span class=\"line\">             Solid.getInstance().getBuilder().analysisAttribute(attributes);</span><br><span class=\"line\">              <span class=\"keyword\">break</span>;</span><br><span class=\"line\">          <span class=\"keyword\">case</span> <span class=\"string\">&quot;gradient&quot;</span>:</span><br><span class=\"line\">              Gradient.getInstance().getBuilder().analysisAttribute(attributes);</span><br><span class=\"line\">              <span class=\"keyword\">break</span>;</span><br><span class=\"line\">          <span class=\"keyword\">case</span> <span class=\"string\">&quot;corners&quot;</span>:</span><br><span class=\"line\">              Corners.getInstance().getBuilder().analysisAttribute(attributes);</span><br><span class=\"line\">              <span class=\"keyword\">break</span>;</span><br><span class=\"line\">          <span class=\"keyword\">default</span>:</span><br><span class=\"line\">              <span class=\"keyword\">break</span>;</span><br><span class=\"line\">      &#125;</span><br></pre></td></tr></table></figure>\n<p>逻辑其实很清楚，主要对startTag的判断，然后通过调用 <code>public abstract void analysisAttribute(Attributes attributes);</code>的方法对相应的 类型的Buidler进行一个赋值操作。</p>\n<p>以Stroke为例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">analysisAttribute</span><span class=\"params\">(Attributes attributes)</span> &#123;</span><br><span class=\"line\">            Stroke.getInstance().setChecked(<span class=\"literal\">true</span>);</span><br><span class=\"line\">            setColor(attributes.getValue(<span class=\"string\">&quot;android:color&quot;</span>));</span><br><span class=\"line\">            setDashGap(attributes.getValue(<span class=\"string\">&quot;android:dashGap&quot;</span>));</span><br><span class=\"line\">            setWidth(attributes.getValue(<span class=\"string\">&quot;android:width&quot;</span>));</span><br><span class=\"line\">            setDashWidth(attributes.getValue(<span class=\"string\">&quot;android:dashWidth&quot;</span>));</span><br><span class=\"line\">        &#125;</span><br></pre></td></tr></table></figure>\n<p>主要是获取到其中的属性，并对初始化的界面进行一些操作(例如选中或者赋值相关操作)。</p>\n<h1 id=\"四、总结\"><a href=\"#四、总结\" class=\"headerlink\" title=\"四、总结\"></a>四、总结</h1><p>这个插件算是自己第一次做一个相对较实用的插件，都是利用工作的空闲事件进行编写，前前后后进行了将近一个月，其中收获颇多，但也踩过了各种各样的坑。在开发过程中由于相关文档较少，通过阅读官方文档还是有点小吃力，不过一步步还是走了下来，自己也得到了成长。其中坑也都添平了，但由于一些基础技术的欠缺，比如对Java GUI界面编程不太熟悉，导致开发过程中有很大一段时间都在跟界面作对，因此后面有机会将去深入了解Java的界面编程，争取能够将页面交互能够做到更好。</p>\n<p>另外由于自身开发精力的原因，不能将插件做到完美，目前插件中还有如下几个问题：</p>\n<p>1、Gradient中对应相关逻辑还需要再优化<br>2、还未支持Size跟Pading（从自身所处环境考虑用得较少，所以暂未支持）<br>3、对于颜色选择器默认打开后不支持对本地颜色字符串处理<br>4、存在大量的界面操作逻辑代码，需要优化</p>\n<p>最后，希望大家能在使用过程中提出相关的意见或建议，也欢迎能一起加入到开发中，从而能将该插件做得更加完美。</p>\n<p>项目地址：</p>\n<p><a href=\"https://github.com/VomPom/NoCodeShape\">https://github.com/VomPom/NoCodeShape</a></p>\n","cover":null,"images":["https://cdn.julis.wang/blog/img/20191126190001658.png","https://cdn.julis.wang/blog/img/20191126192542676.png","https://cdn.julis.wang/blog/img/20191126192336117.gif"],"content":"<p>NoCodeShape 是一个能可视化界面操作生成Android中Shape.xml的Android Studio插件。对于新手能更好的去接受Android中相对应的属性，对于资深程序员则能简化操作，快速生成shape.xml。项目已经开源 <a href=\"https://github.com/VomPom/NoCodeShape\">NoCodeShape</a></p>\n<h1 id=\"二、NoCodeShape使用方法\"><a href=\"#二、NoCodeShape使用方法\" class=\"headerlink\" title=\"二、NoCodeShape使用方法\"></a>二、NoCodeShape使用方法</h1><h2 id=\"1-下载和安装\"><a href=\"#1-下载和安装\" class=\"headerlink\" title=\"1. 下载和安装\"></a>1. 下载和安装</h2><p>同一般的Android Studio插件下载一样，可以直接<code>Preferences-&gt;Plugins</code> 搜索 <code>NoCodeShape</code>搜索出来结果直接安装再重启即可。<br><img width=\"60%\" src=\"https://cdn.julis.wang/blog/img/20191126190001658.png\"><br>也可以去jetbrains插件管理的官网下载各个版本的插件<br><a href=\"https://plugins.jetbrains.com/plugin/13325-nocodeshape/versions\">https://plugins.jetbrains.com/plugin/13325-nocodeshape/versions</a><br>然后<code>Preferences-&gt;Plugins</code> 再Install plugins from disk从本地安装</p>\n<h2 id=\"2-如何使用\"><a href=\"#2-如何使用\" class=\"headerlink\" title=\"2. 如何使用\"></a>2. 如何使用</h2><p>在新建一个shape.xml文件后，右键选择NoCodeShape或者直接按快捷键Common+U</p>\n<img src=\"https://cdn.julis.wang/blog/img/20191126192542676.png\">\n<p>然后选择自己想要的属性，随着点击事件的进行会生成相关xml代码，并在Android Studio右边有对应的shape形状的展示。如果对应shape.xml有相关属性，NoCodeShape也会生成对应shape.xml属性的操作界面，非常方便。<br>示例：</p>\n<img src=\"https://cdn.julis.wang/blog/img/20191126192336117.gif\">\n<h1 id=\"三、实现原理\"><a href=\"#三、实现原理\" class=\"headerlink\" title=\"三、实现原理\"></a>三、实现原理</h1><p>实现原理总体来说并不复杂，主要是界面相关操作逻辑比较繁琐。</p>\n<p>对于新生成的一个shape.xml来说只需要弹出一个新的操作界面，用户只需要点击对应模块的属性即可。项目使用了<code>单例模式+Bulider建造者模式</code>去管理各个Shape属性，分别生成 <code>Shape、Solid、Corners、Stroke、Gradient</code>的单例，其内部拥有一个Builder用来去承各类型的具体属性。</p>\n<p>  通过界面的操作，对其内部的<code>Builder</code>进行数据的填充，最后在完成各类操作后，将各类型中的Builder中的所有属性提取出并生成一份完整的xml字符串并将其粘贴到Android Studio的操作界面上。</p>\n<p>实现主要分为两大类：</p>\n<h2 id=\"1-拼接生成xml字符串\"><a href=\"#1-拼接生成xml字符串\" class=\"headerlink\" title=\"1. 拼接生成xml字符串\"></a>1. 拼接生成xml字符串</h2><p>字符串拼接算是其中最复杂的部分，一是各shape的类型拥有较多数据，其中一些属性有逻辑存在性，二是生成最终Android Studio的xml字符串的时候格式存在比较多的处理。对于各类属性都继承于<code>BaseXml</code>，其内部拥有一个静态内部<code>Builder</code>类，以相对简单的Solid类来举例，如下所示：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Solid</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">BaseXml</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Builder builder;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"type\">Solid</span> <span class=\"variable\">instance</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Solid <span class=\"title function_\">getInstance</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (instance == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            builder = <span class=\"keyword\">new</span> <span class=\"title class_\">Builder</span>();</span><br><span class=\"line\">            instance = <span class=\"keyword\">new</span> <span class=\"title class_\">Solid</span>();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\"> <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Builder</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">BaseBuilder</span> &#123;</span><br><span class=\"line\">        String color;</span><br><span class=\"line\">        String colorValue;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">setColor</span><span class=\"params\">(String color)</span> &#123;</span><br><span class=\"line\">            <span class=\"built_in\">this</span>.colorValue = color;</span><br><span class=\"line\">            <span class=\"built_in\">this</span>.color = getAttrWithOutUnitStr(<span class=\"string\">&quot;color&quot;</span>, color);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"keyword\">public</span> String <span class=\"title function_\">getBuilderString</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> StringUtils.getString(color);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">clearData</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">            StringUtils.clearObjectData(<span class=\"built_in\">this</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">analysisAttribute</span><span class=\"params\">(Attributes attributes)</span> &#123;</span><br><span class=\"line\">            Solid.getInstance().setChecked(<span class=\"literal\">true</span>);</span><br><span class=\"line\">            setColor(attributes.getValue(<span class=\"string\">&quot;android:color&quot;</span>));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>其类继承于抽象类BaseXml，代码如下所示：<br><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">class</span> <span class=\"title class_\">BaseXml</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">boolean</span> <span class=\"variable\">isChecked</span> <span class=\"operator\">=</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">getCloser</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot; /&gt;&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">getStartTag</span><span class=\"params\">()</span> &#123; </span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">generateXmlString</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">protected</span> String <span class=\"title function_\">getLineFeedString</span><span class=\"params\">()</span> &#123; </span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;\\n&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">isChecked</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> isChecked;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> BaseXml <span class=\"title function_\">setChecked</span><span class=\"params\">(<span class=\"type\">boolean</span> checked)</span> &#123;</span><br><span class=\"line\">        isChecked = checked;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>抽象类提取出来在字符串拼接阶段，各类型常用的基本操作，例如：返回“&lt;solid”这类的开始标签，” /&gt;”结束标签等</p>\n<p>其内部<code>BaseXml</code>拥有对应类拥有的所有属性的常用操作，其继承与抽象类<code>BaseBuilder</code>，代码如下所示</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">class</span> <span class=\"title class_\">BaseBuilder</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> String <span class=\"title function_\">getBuilderString</span><span class=\"params\">()</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title function_\">clearData</span><span class=\"params\">()</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title function_\">analysisAttribute</span><span class=\"params\">(Attributes attributes)</span>;</span><br><span class=\"line\">    <span class=\"keyword\">protected</span> <span class=\"keyword\">final</span> String <span class=\"title function_\">getAttrWithUnitStr</span><span class=\"params\">(String attributeType, String value)</span> &#123;</span><br><span class=\"line\">        String unit;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (TextUtils.isEmpty(value)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"string\">&quot;&quot;</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (value.contains(<span class=\"string\">&quot;px&quot;</span>) || value.contains(<span class=\"string\">&quot;dp&quot;</span>)) &#123;</span><br><span class=\"line\">            unit = <span class=\"string\">&quot;&quot;</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            unit = DefaultData.UNIT;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;android:&quot;</span> + attributeType + <span class=\"string\">&quot;=\\&quot;&quot;</span> + value + unit + <span class=\"string\">&quot;\\&quot;&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">protected</span> <span class=\"keyword\">final</span> String <span class=\"title function_\">getAttrWithOutUnitStr</span><span class=\"params\">(String attributeType, String value)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (TextUtils.isEmpty(value)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"string\">&quot;&quot;</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;android:&quot;</span> + attributeType + <span class=\"string\">&quot;=\\&quot;&quot;</span> + value + <span class=\"string\">&quot;\\&quot;&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">protected</span> <span class=\"keyword\">final</span> String <span class=\"title function_\">getValueOutUnit</span><span class=\"params\">(String value)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (TextUtils.isEmpty(value)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> value;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> value.replace(<span class=\"string\">&quot;dp&quot;</span>, <span class=\"string\">&quot;&quot;</span>).replace(<span class=\"string\">&quot;px&quot;</span>, <span class=\"string\">&quot;&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>BaseBuilder内部封装了一些属性的常用操作，例如生成：<code>android:color=&quot;#FFFFFF&quot;</code>这样的字符串，获取是否带有单位的字串等。<br>并提供三个抽象方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> String <span class=\"title function_\">getBuilderString</span><span class=\"params\">()</span>; <span class=\"comment\">//获取Builder中所有属性拼接好的字符串</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title function_\">clearData</span><span class=\"params\">()</span>; <span class=\"comment\">//清空Builder内部属性值</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title function_\">analysisAttribute</span><span class=\"params\">(Attributes attributes)</span>; <span class=\"comment\">//分析xml数据中的值，这个在第二大点“将原有shape.xml字符串转化为对应操作界面”中将会讲到</span></span><br></pre></td></tr></table></figure>\n<p>以上是基本数据的构造，在最后在控件交互的地方会调用<code>CommonAction</code>类的<code>refreshAndWriteData</code>：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">abstract</span> <span class=\"keyword\">class</span> <span class=\"title class_\">CommonAction</span> &#123;</span><br><span class=\"line\">    JComponent component;</span><br><span class=\"line\">    NoShapeDialog noShapeDialog;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">void</span> <span class=\"title function_\">refreshAndWriteData</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        NoCodeShapeAction.callWriteData();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>最后会调用基本的Action中的<code>writeData()</code>方法，其具体逻辑为<br><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">    * 数据写入xml文件</span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">   <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">writeData</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">       <span class=\"keyword\">final</span> <span class=\"type\">Document</span> <span class=\"variable\">document</span> <span class=\"operator\">=</span> FileDocumentManager.getInstance().getDocument(file);</span><br><span class=\"line\">       <span class=\"keyword\">if</span> (document == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">           <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">               <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Exception</span>(<span class=\"string\">&quot;Document对象为空&quot;</span>);</span><br><span class=\"line\">           &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">               e.printStackTrace();</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">           <span class=\"keyword\">return</span>;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       <span class=\"keyword\">new</span> <span class=\"title class_\">WriteCommandAction</span>.Simple(project) &#123;</span><br><span class=\"line\">           <span class=\"meta\">@Override</span></span><br><span class=\"line\">           <span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">               document.setText(XMLString.getInstance().generateXmlString());</span><br><span class=\"line\">               <span class=\"comment\">//formatCode();</span></span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">       &#125;.execute();</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure><br>利用<code>XMLString.getInstance().generateXmlString()</code>获取各操作类型的所有属性将其拼接为一份完整的shape.xml文件的字段，最后调用插件系统的相关命令将字符串粘贴在系统对应的输入框中。</p>\n<h2 id=\"2-将原有shape-xml字符串转化为对应操作界面\"><a href=\"#2-将原有shape-xml字符串转化为对应操作界面\" class=\"headerlink\" title=\"2. 将原有shape.xml字符串转化为对应操作界面\"></a>2. 将原有shape.xml字符串转化为对应操作界面</h2><p>上面已经讲述类如何拼接生成xml字符串并将其粘贴到Android Studio界面上，此外NoCodeShape不仅支持新生成的shape.xml，同样也支持对旧shape.xml进行修改的能力。与第一步相比较主要多了一步读取Android Studio xml文档并将其转化为对应操作界面的过程。其主要是在操作界面初始化之前执行了如下方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">initSax</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">       <span class=\"type\">String</span> <span class=\"variable\">text</span> <span class=\"operator\">=</span> FileDocumentManager.getInstance().getDocument(file).getText();</span><br><span class=\"line\">       <span class=\"type\">ShapeSaxHandler</span> <span class=\"variable\">handler</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ShapeSaxHandler</span>();</span><br><span class=\"line\">       <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">           handler.createViewList(text);</span><br><span class=\"line\">       &#125; <span class=\"keyword\">catch</span> (ParserConfigurationException e) &#123;</span><br><span class=\"line\">           e.printStackTrace();</span><br><span class=\"line\">       &#125; <span class=\"keyword\">catch</span> (SAXException e) &#123;</span><br><span class=\"line\">           e.printStackTrace();</span><br><span class=\"line\">       &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">           e.printStackTrace();</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n<p>利用ShapeSaxHandler去解析xml里面的元素，参考了<a href=\"https://github.com/laobie/FindViewByMe\">FindViewByMe</a>的解析原理。</p>\n<p>具体操作逻辑如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">createViewList</span><span class=\"params\">(String string)</span> <span class=\"keyword\">throws</span> ParserConfigurationException, SAXException, IOException &#123;</span><br><span class=\"line\">      <span class=\"type\">InputStream</span> <span class=\"variable\">xmlStream</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ByteArrayInputStream</span>(string.getBytes(<span class=\"string\">&quot;UTF-8&quot;</span>));</span><br><span class=\"line\">      <span class=\"type\">SAXParserFactory</span> <span class=\"variable\">factory</span> <span class=\"operator\">=</span> SAXParserFactory.newInstance();</span><br><span class=\"line\">      <span class=\"type\">SAXParser</span> <span class=\"variable\">parser</span> <span class=\"operator\">=</span> factory.newSAXParser();</span><br><span class=\"line\">      parser.parse(xmlStream, <span class=\"built_in\">this</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">startDocument</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> SAXException &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (shapePartList == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">          shapePartList = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;ShapePart&gt;();</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">startElement</span><span class=\"params\">(String uri, String localName, String qName, Attributes attributes)</span> <span class=\"keyword\">throws</span> SAXException &#123;</span><br><span class=\"line\">      <span class=\"keyword\">switch</span> (qName) &#123;</span><br><span class=\"line\">          <span class=\"keyword\">case</span> <span class=\"string\">&quot;shape&quot;</span>:</span><br><span class=\"line\">              Shape.getInstance().getBuilder().analysisAttribute(attributes);</span><br><span class=\"line\">              <span class=\"keyword\">break</span>;</span><br><span class=\"line\">          <span class=\"keyword\">case</span> <span class=\"string\">&quot;stroke&quot;</span>:</span><br><span class=\"line\">              Stroke.getInstance().getBuilder().analysisAttribute(attributes);</span><br><span class=\"line\">              <span class=\"keyword\">break</span>;</span><br><span class=\"line\">          <span class=\"keyword\">case</span> <span class=\"string\">&quot;solid&quot;</span>:</span><br><span class=\"line\">             Solid.getInstance().getBuilder().analysisAttribute(attributes);</span><br><span class=\"line\">              <span class=\"keyword\">break</span>;</span><br><span class=\"line\">          <span class=\"keyword\">case</span> <span class=\"string\">&quot;gradient&quot;</span>:</span><br><span class=\"line\">              Gradient.getInstance().getBuilder().analysisAttribute(attributes);</span><br><span class=\"line\">              <span class=\"keyword\">break</span>;</span><br><span class=\"line\">          <span class=\"keyword\">case</span> <span class=\"string\">&quot;corners&quot;</span>:</span><br><span class=\"line\">              Corners.getInstance().getBuilder().analysisAttribute(attributes);</span><br><span class=\"line\">              <span class=\"keyword\">break</span>;</span><br><span class=\"line\">          <span class=\"keyword\">default</span>:</span><br><span class=\"line\">              <span class=\"keyword\">break</span>;</span><br><span class=\"line\">      &#125;</span><br></pre></td></tr></table></figure>\n<p>逻辑其实很清楚，主要对startTag的判断，然后通过调用 <code>public abstract void analysisAttribute(Attributes attributes);</code>的方法对相应的 类型的Buidler进行一个赋值操作。</p>\n<p>以Stroke为例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">analysisAttribute</span><span class=\"params\">(Attributes attributes)</span> &#123;</span><br><span class=\"line\">            Stroke.getInstance().setChecked(<span class=\"literal\">true</span>);</span><br><span class=\"line\">            setColor(attributes.getValue(<span class=\"string\">&quot;android:color&quot;</span>));</span><br><span class=\"line\">            setDashGap(attributes.getValue(<span class=\"string\">&quot;android:dashGap&quot;</span>));</span><br><span class=\"line\">            setWidth(attributes.getValue(<span class=\"string\">&quot;android:width&quot;</span>));</span><br><span class=\"line\">            setDashWidth(attributes.getValue(<span class=\"string\">&quot;android:dashWidth&quot;</span>));</span><br><span class=\"line\">        &#125;</span><br></pre></td></tr></table></figure>\n<p>主要是获取到其中的属性，并对初始化的界面进行一些操作(例如选中或者赋值相关操作)。</p>\n<h1 id=\"四、总结\"><a href=\"#四、总结\" class=\"headerlink\" title=\"四、总结\"></a>四、总结</h1><p>这个插件算是自己第一次做一个相对较实用的插件，都是利用工作的空闲事件进行编写，前前后后进行了将近一个月，其中收获颇多，但也踩过了各种各样的坑。在开发过程中由于相关文档较少，通过阅读官方文档还是有点小吃力，不过一步步还是走了下来，自己也得到了成长。其中坑也都添平了，但由于一些基础技术的欠缺，比如对Java GUI界面编程不太熟悉，导致开发过程中有很大一段时间都在跟界面作对，因此后面有机会将去深入了解Java的界面编程，争取能够将页面交互能够做到更好。</p>\n<p>另外由于自身开发精力的原因，不能将插件做到完美，目前插件中还有如下几个问题：</p>\n<p>1、Gradient中对应相关逻辑还需要再优化<br>2、还未支持Size跟Pading（从自身所处环境考虑用得较少，所以暂未支持）<br>3、对于颜色选择器默认打开后不支持对本地颜色字符串处理<br>4、存在大量的界面操作逻辑代码，需要优化</p>\n<p>最后，希望大家能在使用过程中提出相关的意见或建议，也欢迎能一起加入到开发中，从而能将该插件做得更加完美。</p>\n<p>项目地址：</p>\n<p><a href=\"https://github.com/VomPom/NoCodeShape\">https://github.com/VomPom/NoCodeShape</a></p>\n","categories":[{"name":"技术文章","slug":"technology","api":"api/categories/technology.json"}],"tags":[{"name":"插件","slug":"插件","api":"api/tags/插件.json"}],"api":"api/posts/2019/11/27/一款快速生成Android-shape的插件-NoCodeShape.json"},{"title":"Java中的Reference解析","slug":"Java四种引用","date":"2019-10-30T11:45:00.000Z","updated":"2025-05-20T11:46:57.000Z","comments":true,"url":"2019/10/30/Java四种引用/","excerpt":"<p>Java执行GC判断对象是否存活有两种方式其中一种是<strong>引用计数</strong>。</p>\n<p><strong>引用计数</strong>：Java堆中每一个对象都有一个引用计数属性，引用每新增1次计数加1，引用每释放1次计数减1。</p>\n<p>在JDK 1.2以前的版本中，若一个对象不被任何变量引用，那么程序就无法再使用这个对象。也就是说，只有对象处于(reachable)可达状态，程序才能使用它。</p>\n<p>从JDK 1.2版本开始，对象的引用被划分为4种级别，从而使程序能更加灵活地控制对象的生命周期。这4种级别由高到低依次为：<code>强引用、软引用、弱引用和虚引用</code>，本文主要讲解各个引用的用途以及引用队列的作用。</p>\n<h2 id=\"1、强引用（StrongReference）\"><a href=\"#1、强引用（StrongReference）\" class=\"headerlink\" title=\"1、强引用（StrongReference）\"></a>1、强引用（StrongReference）</h2><p>强引用指的是程序代码中普遍存在的，类似如下代码<br><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">Object</span> <span class=\"variable\">object</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Object</span>();</span><br></pre></td></tr></table></figure><br><strong><em>当内存空间不足时，只要强引用还在，Java虚拟机会抛出OutOfMemoryError错误，使程序异常终止，也不会靠回收强引用的对象来解决内存不足的问题。</em></strong></p>\n<p>如果强引用对象不使用时，需要弱化从而使GC能够回收，如下所示：<br><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">object = <span class=\"literal\">null</span>;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"2、软引用（SoftReference）\"><a href=\"#2、软引用（SoftReference）\" class=\"headerlink\" title=\"2、软引用（SoftReference）\"></a>2、软引用（SoftReference）</h2><p><strong><em>软引用是用来描述一些有用但并不是必需的对象。对于软引用关联着的对象，在系统将要发生内存溢出异常之前，将会把这些对象列进回首范围之中进行第二次回收。如果这次回收还没有足够的内存，才会抛出内存溢出异常。</em></strong></p>\n<p>这一点可以很好地用来解决OOM的问题，并且这个特性很适合用来实现缓存：比如网页缓存、图片缓存等，软引用可用来实现内存敏感的高速缓存。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 强引用</span></span><br><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">strongReference</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">String</span>(<span class=\"string\">&quot;abc&quot;</span>);</span><br><span class=\"line\"><span class=\"comment\">// 软引用</span></span><br><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">str</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">String</span>(<span class=\"string\">&quot;abc&quot;</span>);</span><br><span class=\"line\">SoftReference&lt;String&gt; softReference = <span class=\"keyword\">new</span> <span class=\"title class_\">SoftReference</span>&lt;String&gt;(str);</span><br></pre></td></tr></table></figure>\n<p>软引用可以和一个引用队列(ReferenceQueue)联合使用。如果软引用所引用对象被垃圾回收，JAVA虚拟机就会把这个软引用加入到与之关联的引用队列中。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">ReferenceQueue&lt;String&gt; referenceQueue = <span class=\"keyword\">new</span> <span class=\"title class_\">ReferenceQueue</span>&lt;&gt;();</span><br><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">str</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">String</span>(<span class=\"string\">&quot;abc&quot;</span>);</span><br><span class=\"line\">SoftReference&lt;String&gt; softReference = <span class=\"keyword\">new</span> <span class=\"title class_\">SoftReference</span>&lt;&gt;(str, referenceQueue);</span><br><span class=\"line\">str = <span class=\"literal\">null</span>;</span><br><span class=\"line\"><span class=\"comment\">// Notify GC</span></span><br><span class=\"line\">System.gc();</span><br><span class=\"line\">System.out.println(softReference.get()); <span class=\"comment\">// abc</span></span><br><span class=\"line\">Reference&lt;? <span class=\"keyword\">extends</span> <span class=\"title class_\">String</span>&gt; reference = referenceQueue.poll();</span><br><span class=\"line\">System.out.println(reference); <span class=\"comment\">//null</span></span><br></pre></td></tr></table></figure>\n<p>注意：软引用对象是在jvm内存不够的时候才会被回收，我们调用System.gc()方法只是起通知作用，JVM什么时候扫描回收对象是JVM自己的状态决定的。就算扫描到软引用对象也不一定会回收它，只有内存不够的时候才会回收。</p>\n<p>当内存不足时，JVM首先将软引用中的对象引用置为<code>null</code>，然后通知垃圾回收器进行回收：<br><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span>(JVM内存不足) &#123;</span><br><span class=\"line\">     <span class=\"comment\">// 将软引用中的对象引用置为null</span></span><br><span class=\"line\">     str = <span class=\"literal\">null</span>;</span><br><span class=\"line\">     <span class=\"comment\">// 通知垃圾回收器进行回收</span></span><br><span class=\"line\">     System.gc();</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure><br>也就是说，垃圾收集线程会在虚拟机抛出<code>OutOfMemoryError</code>之前回收软引用对象，而且虚拟机会尽可能优先回收长时间闲置不用的软引用对象。对那些刚构建的或刚使用过的较新的软对象会被虚拟机尽可能保留，这就是引入引用队列ReferenceQueue的原因，后面会具体讲解。</p>\n<h2 id=\"3、弱引用（WeakReference）\"><a href=\"#3、弱引用（WeakReference）\" class=\"headerlink\" title=\"3、弱引用（WeakReference）\"></a>3、弱引用（WeakReference）</h2><p><strong><em>弱引用也是用来描述非必需对象的，但是它的强度比软引用更弱一些，被弱引用关联的<br>对象只能生存到下一次垃圾收集发生之前。当垃圾收集器工作时，无论当前内存是否足够，<br>都会回收掉只被弱引用关联的对象。</em></strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">str</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">String</span>(<span class=\"string\">&quot;abc&quot;</span>);</span><br><span class=\"line\">WeakReference&lt;String&gt; weakReference = <span class=\"keyword\">new</span> <span class=\"title class_\">WeakReference</span>&lt;&gt;(str);</span><br><span class=\"line\">str = <span class=\"literal\">null</span>;</span><br></pre></td></tr></table></figure>\n<p>复制代码JVM首先将软引用中的对象引用置为null，然后通知垃圾回收器进行回收：<br><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">str = <span class=\"literal\">null</span>;</span><br><span class=\"line\">System.gc();</span><br></pre></td></tr></table></figure></p>\n<p>注意：如果一个对象是偶尔(很少)的使用，并且希望在使用时随时就能获取到，但又不想影响此对象的垃圾收集，那么你应该用Weak Reference来记住此对象。</p>\n<p>下面的代码会让一个弱引用再次变为一个强引用：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">str</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">String</span>(<span class=\"string\">&quot;abc&quot;</span>);</span><br><span class=\"line\">WeakReference&lt;String&gt; weakReference = <span class=\"keyword\">new</span> <span class=\"title class_\">WeakReference</span>&lt;&gt;(str);</span><br><span class=\"line\"><span class=\"comment\">// 弱引用转强引用</span></span><br><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">strongReference</span> <span class=\"operator\">=</span> weakReference.get();</span><br></pre></td></tr></table></figure>\n<p>同样，弱引用可以和一个引用队列(ReferenceQueue)联合使用，如果弱引用所引用的对象被垃圾回收，Java虚拟机就会把这个弱引用加入到与之关联的引用队列中。</p>\n<h2 id=\"4、虚引用（PhantomReference）\"><a href=\"#4、虚引用（PhantomReference）\" class=\"headerlink\" title=\"4、虚引用（PhantomReference）\"></a>4、虚引用（PhantomReference）</h2><p><strong><em>虚引用也称为幽灵引用或者幻影引用，它是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生命周期构成影响，也无法通过虚引用获得一个对象实例。</em></strong></p>\n<p>虚引用主要用来<strong>跟踪对象被垃圾回收器回收的活动</strong>，虚引用与软引用和弱引用的一个区别在于：</p>\n<blockquote>\n<p>虚引用必须和引用队列(ReferenceQueue)联合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">str</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">String</span>(<span class=\"string\">&quot;abc&quot;</span>);</span><br><span class=\"line\"><span class=\"type\">ReferenceQueue</span> <span class=\"variable\">queue</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ReferenceQueue</span>();</span><br><span class=\"line\"><span class=\"comment\">// 创建虚引用，要求必须与一个引用队列关联</span></span><br><span class=\"line\"><span class=\"type\">PhantomReference</span> <span class=\"variable\">pr</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">PhantomReference</span>(str, queue);</span><br></pre></td></tr></table></figure>\n<p>程序可以通过判断引用队列中是否已经加入了虚引用，来了解被引用的对象是否将要进行垃圾回收。如果程序发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动。</p>\n<h2 id=\"5、引用队列（ReferenceQueue）\"><a href=\"#5、引用队列（ReferenceQueue）\" class=\"headerlink\" title=\"5、引用队列（ReferenceQueue）\"></a>5、引用队列（ReferenceQueue）</h2><p>在前面软引用、弱引用和虚引用都有讲到引用队列，那引用队列具体是做什么的呢？<br>官方对于引用队列类的注释是：</p>\n<blockquote>\n<p> Reference queues, to which registered reference objects are appended by the garbage collector after the appropriate reachability changes are detected.<br> 译为：引用队列是将垃圾收集器在监测到适当的可达性更改后将已注册的引用对象添加到该队列。</p>\n<p>对于软引用和弱引用和虚引用，我们希望当一个对象被gc掉的时候通知用户线程，进行额外的处理时，就需要使用引用队列了。<code>ReferenceQueue</code>即这样的一个对象，当一个obj被gc掉之后，其相应的包装类，即ref对象会被放入queue中。我们可以从queue中获取到相应的对象信息，同时进行额外的处理。比如反向操作，数据清理等。</p>\n</blockquote>\n<p>查看源码发现ReferenceQueue的代码结构并不复杂，从源码上看，实际上ReferenceQueue只是名义上的引用队列，它只保存了Reference链表的头(head)节点，并且提供了队列出队入队删除操作，而Reference实际上本身提供单向链表的功能，也就是说Reference通过成员属性next构建单向链表，而链表的操作是委托给ReferenceQueue完成。详细参考：<a href=\"https://www.throwable.club/2019/02/16/java-reference/#ReferenceQueue\">深入理解JDK中的Reference原理和源码实现</a></p>\n<img src=\"https://cdn.julis.wang/blog/img/20191030191550407.png\">\n<h2 id=\"6、总结\"><a href=\"#6、总结\" class=\"headerlink\" title=\"6、总结\"></a>6、总结</h2><p>1、Java中四种引用的级别和强度由高到低依次为：<code>强引用 -&gt; 软引用 -&gt; 弱引用 -&gt; 虚引用</code></p>\n<p>2、ReferenceQueue引用队列用来记录被回收的引用为用户线程做额外操作作铺垫</p>\n<p>3、对各种引用回收时间、用途、生成时间作总结：<br><img src=\"https://cdn.julis.wang/blog/img/78afb9b4d86f5feef01ac947f96baee331c.jpg\"><br>参考：</p>\n<p>1、《深入理解Java虚拟机》</p>\n<p>2、<a href=\"https://www.throwable.club/2019/02/16/java-reference/#ReferenceQueue\">深入理解JDK中的Reference原理和源码实现</a></p>\n<p>3、<a href=\"https://juejin.im/post/5b82c02df265da436152f5ad\">理解Java的强引用、软引用、弱引用和虚引用</a></p>\n","cover":null,"images":["https://cdn.julis.wang/blog/img/20191030191550407.png","https://cdn.julis.wang/blog/img/78afb9b4d86f5feef01ac947f96baee331c.jpg"],"content":"<p>Java执行GC判断对象是否存活有两种方式其中一种是<strong>引用计数</strong>。</p>\n<p><strong>引用计数</strong>：Java堆中每一个对象都有一个引用计数属性，引用每新增1次计数加1，引用每释放1次计数减1。</p>\n<p>在JDK 1.2以前的版本中，若一个对象不被任何变量引用，那么程序就无法再使用这个对象。也就是说，只有对象处于(reachable)可达状态，程序才能使用它。</p>\n<p>从JDK 1.2版本开始，对象的引用被划分为4种级别，从而使程序能更加灵活地控制对象的生命周期。这4种级别由高到低依次为：<code>强引用、软引用、弱引用和虚引用</code>，本文主要讲解各个引用的用途以及引用队列的作用。</p>\n<h2 id=\"1、强引用（StrongReference）\"><a href=\"#1、强引用（StrongReference）\" class=\"headerlink\" title=\"1、强引用（StrongReference）\"></a>1、强引用（StrongReference）</h2><p>强引用指的是程序代码中普遍存在的，类似如下代码<br><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">Object</span> <span class=\"variable\">object</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Object</span>();</span><br></pre></td></tr></table></figure><br><strong><em>当内存空间不足时，只要强引用还在，Java虚拟机会抛出OutOfMemoryError错误，使程序异常终止，也不会靠回收强引用的对象来解决内存不足的问题。</em></strong></p>\n<p>如果强引用对象不使用时，需要弱化从而使GC能够回收，如下所示：<br><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">object = <span class=\"literal\">null</span>;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"2、软引用（SoftReference）\"><a href=\"#2、软引用（SoftReference）\" class=\"headerlink\" title=\"2、软引用（SoftReference）\"></a>2、软引用（SoftReference）</h2><p><strong><em>软引用是用来描述一些有用但并不是必需的对象。对于软引用关联着的对象，在系统将要发生内存溢出异常之前，将会把这些对象列进回首范围之中进行第二次回收。如果这次回收还没有足够的内存，才会抛出内存溢出异常。</em></strong></p>\n<p>这一点可以很好地用来解决OOM的问题，并且这个特性很适合用来实现缓存：比如网页缓存、图片缓存等，软引用可用来实现内存敏感的高速缓存。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 强引用</span></span><br><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">strongReference</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">String</span>(<span class=\"string\">&quot;abc&quot;</span>);</span><br><span class=\"line\"><span class=\"comment\">// 软引用</span></span><br><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">str</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">String</span>(<span class=\"string\">&quot;abc&quot;</span>);</span><br><span class=\"line\">SoftReference&lt;String&gt; softReference = <span class=\"keyword\">new</span> <span class=\"title class_\">SoftReference</span>&lt;String&gt;(str);</span><br></pre></td></tr></table></figure>\n<p>软引用可以和一个引用队列(ReferenceQueue)联合使用。如果软引用所引用对象被垃圾回收，JAVA虚拟机就会把这个软引用加入到与之关联的引用队列中。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">ReferenceQueue&lt;String&gt; referenceQueue = <span class=\"keyword\">new</span> <span class=\"title class_\">ReferenceQueue</span>&lt;&gt;();</span><br><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">str</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">String</span>(<span class=\"string\">&quot;abc&quot;</span>);</span><br><span class=\"line\">SoftReference&lt;String&gt; softReference = <span class=\"keyword\">new</span> <span class=\"title class_\">SoftReference</span>&lt;&gt;(str, referenceQueue);</span><br><span class=\"line\">str = <span class=\"literal\">null</span>;</span><br><span class=\"line\"><span class=\"comment\">// Notify GC</span></span><br><span class=\"line\">System.gc();</span><br><span class=\"line\">System.out.println(softReference.get()); <span class=\"comment\">// abc</span></span><br><span class=\"line\">Reference&lt;? <span class=\"keyword\">extends</span> <span class=\"title class_\">String</span>&gt; reference = referenceQueue.poll();</span><br><span class=\"line\">System.out.println(reference); <span class=\"comment\">//null</span></span><br></pre></td></tr></table></figure>\n<p>注意：软引用对象是在jvm内存不够的时候才会被回收，我们调用System.gc()方法只是起通知作用，JVM什么时候扫描回收对象是JVM自己的状态决定的。就算扫描到软引用对象也不一定会回收它，只有内存不够的时候才会回收。</p>\n<p>当内存不足时，JVM首先将软引用中的对象引用置为<code>null</code>，然后通知垃圾回收器进行回收：<br><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span>(JVM内存不足) &#123;</span><br><span class=\"line\">     <span class=\"comment\">// 将软引用中的对象引用置为null</span></span><br><span class=\"line\">     str = <span class=\"literal\">null</span>;</span><br><span class=\"line\">     <span class=\"comment\">// 通知垃圾回收器进行回收</span></span><br><span class=\"line\">     System.gc();</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure><br>也就是说，垃圾收集线程会在虚拟机抛出<code>OutOfMemoryError</code>之前回收软引用对象，而且虚拟机会尽可能优先回收长时间闲置不用的软引用对象。对那些刚构建的或刚使用过的较新的软对象会被虚拟机尽可能保留，这就是引入引用队列ReferenceQueue的原因，后面会具体讲解。</p>\n<h2 id=\"3、弱引用（WeakReference）\"><a href=\"#3、弱引用（WeakReference）\" class=\"headerlink\" title=\"3、弱引用（WeakReference）\"></a>3、弱引用（WeakReference）</h2><p><strong><em>弱引用也是用来描述非必需对象的，但是它的强度比软引用更弱一些，被弱引用关联的<br>对象只能生存到下一次垃圾收集发生之前。当垃圾收集器工作时，无论当前内存是否足够，<br>都会回收掉只被弱引用关联的对象。</em></strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">str</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">String</span>(<span class=\"string\">&quot;abc&quot;</span>);</span><br><span class=\"line\">WeakReference&lt;String&gt; weakReference = <span class=\"keyword\">new</span> <span class=\"title class_\">WeakReference</span>&lt;&gt;(str);</span><br><span class=\"line\">str = <span class=\"literal\">null</span>;</span><br></pre></td></tr></table></figure>\n<p>复制代码JVM首先将软引用中的对象引用置为null，然后通知垃圾回收器进行回收：<br><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">str = <span class=\"literal\">null</span>;</span><br><span class=\"line\">System.gc();</span><br></pre></td></tr></table></figure></p>\n<p>注意：如果一个对象是偶尔(很少)的使用，并且希望在使用时随时就能获取到，但又不想影响此对象的垃圾收集，那么你应该用Weak Reference来记住此对象。</p>\n<p>下面的代码会让一个弱引用再次变为一个强引用：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">str</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">String</span>(<span class=\"string\">&quot;abc&quot;</span>);</span><br><span class=\"line\">WeakReference&lt;String&gt; weakReference = <span class=\"keyword\">new</span> <span class=\"title class_\">WeakReference</span>&lt;&gt;(str);</span><br><span class=\"line\"><span class=\"comment\">// 弱引用转强引用</span></span><br><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">strongReference</span> <span class=\"operator\">=</span> weakReference.get();</span><br></pre></td></tr></table></figure>\n<p>同样，弱引用可以和一个引用队列(ReferenceQueue)联合使用，如果弱引用所引用的对象被垃圾回收，Java虚拟机就会把这个弱引用加入到与之关联的引用队列中。</p>\n<h2 id=\"4、虚引用（PhantomReference）\"><a href=\"#4、虚引用（PhantomReference）\" class=\"headerlink\" title=\"4、虚引用（PhantomReference）\"></a>4、虚引用（PhantomReference）</h2><p><strong><em>虚引用也称为幽灵引用或者幻影引用，它是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生命周期构成影响，也无法通过虚引用获得一个对象实例。</em></strong></p>\n<p>虚引用主要用来<strong>跟踪对象被垃圾回收器回收的活动</strong>，虚引用与软引用和弱引用的一个区别在于：</p>\n<blockquote>\n<p>虚引用必须和引用队列(ReferenceQueue)联合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">str</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">String</span>(<span class=\"string\">&quot;abc&quot;</span>);</span><br><span class=\"line\"><span class=\"type\">ReferenceQueue</span> <span class=\"variable\">queue</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ReferenceQueue</span>();</span><br><span class=\"line\"><span class=\"comment\">// 创建虚引用，要求必须与一个引用队列关联</span></span><br><span class=\"line\"><span class=\"type\">PhantomReference</span> <span class=\"variable\">pr</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">PhantomReference</span>(str, queue);</span><br></pre></td></tr></table></figure>\n<p>程序可以通过判断引用队列中是否已经加入了虚引用，来了解被引用的对象是否将要进行垃圾回收。如果程序发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动。</p>\n<h2 id=\"5、引用队列（ReferenceQueue）\"><a href=\"#5、引用队列（ReferenceQueue）\" class=\"headerlink\" title=\"5、引用队列（ReferenceQueue）\"></a>5、引用队列（ReferenceQueue）</h2><p>在前面软引用、弱引用和虚引用都有讲到引用队列，那引用队列具体是做什么的呢？<br>官方对于引用队列类的注释是：</p>\n<blockquote>\n<p> Reference queues, to which registered reference objects are appended by the garbage collector after the appropriate reachability changes are detected.<br> 译为：引用队列是将垃圾收集器在监测到适当的可达性更改后将已注册的引用对象添加到该队列。</p>\n<p>对于软引用和弱引用和虚引用，我们希望当一个对象被gc掉的时候通知用户线程，进行额外的处理时，就需要使用引用队列了。<code>ReferenceQueue</code>即这样的一个对象，当一个obj被gc掉之后，其相应的包装类，即ref对象会被放入queue中。我们可以从queue中获取到相应的对象信息，同时进行额外的处理。比如反向操作，数据清理等。</p>\n</blockquote>\n<p>查看源码发现ReferenceQueue的代码结构并不复杂，从源码上看，实际上ReferenceQueue只是名义上的引用队列，它只保存了Reference链表的头(head)节点，并且提供了队列出队入队删除操作，而Reference实际上本身提供单向链表的功能，也就是说Reference通过成员属性next构建单向链表，而链表的操作是委托给ReferenceQueue完成。详细参考：<a href=\"https://www.throwable.club/2019/02/16/java-reference/#ReferenceQueue\">深入理解JDK中的Reference原理和源码实现</a></p>\n<img src=\"https://cdn.julis.wang/blog/img/20191030191550407.png\">\n<h2 id=\"6、总结\"><a href=\"#6、总结\" class=\"headerlink\" title=\"6、总结\"></a>6、总结</h2><p>1、Java中四种引用的级别和强度由高到低依次为：<code>强引用 -&gt; 软引用 -&gt; 弱引用 -&gt; 虚引用</code></p>\n<p>2、ReferenceQueue引用队列用来记录被回收的引用为用户线程做额外操作作铺垫</p>\n<p>3、对各种引用回收时间、用途、生成时间作总结：<br><img src=\"https://cdn.julis.wang/blog/img/78afb9b4d86f5feef01ac947f96baee331c.jpg\"><br>参考：</p>\n<p>1、《深入理解Java虚拟机》</p>\n<p>2、<a href=\"https://www.throwable.club/2019/02/16/java-reference/#ReferenceQueue\">深入理解JDK中的Reference原理和源码实现</a></p>\n<p>3、<a href=\"https://juejin.im/post/5b82c02df265da436152f5ad\">理解Java的强引用、软引用、弱引用和虚引用</a></p>\n","categories":[{"name":"技术文章","slug":"technology","api":"api/categories/technology.json"}],"tags":[{"name":"Java","slug":"java","api":"api/tags/java.json"}],"api":"api/posts/2019/10/30/Java四种引用.json"},{"title":"(转)算法之优先队列 PriorityQueue解决Top K 问题","slug":"算法之优先队列-PriorityQueue解决Top-K-问题","date":"2019-10-10T01:51:00.000Z","updated":"2025-05-20T11:46:57.000Z","comments":true,"url":"2019/10/10/算法之优先队列-PriorityQueue解决Top-K-问题/","excerpt":"<p>转自：<a href=\"https://www.jianshu.com/p/a4a1984fc4ff\">https://www.jianshu.com/p/a4a1984fc4ff</a></p>\n<p>解决方法：<br>维护一个大小为 K 的小顶堆，依次将数据放入堆中，当堆的大小满了的时候，只需要将堆顶元素与下一个数比较：如果大于堆顶元素，则将当前的堆顶元素抛弃，并将该元素插入堆中。遍历完全部数据，Top K 的元素也自然都在堆里面了。</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/8807674-d32bc53ef9cadc8d.png?imageMogr2/auto-orient/strip|imageView2/2/w/770/format/webp\" alt=\"\"></p>\n<p>当然，如果是求前 K 个最小的数，只需要改为大顶堆即可</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/8807674-e67fb606d0f5766a.png?imageMogr2/auto-orient/strip|imageView2/2/w/776/format/webp\" alt=\"\"></p>\n<p> 将数据插入堆  95 大于 20，进行替换 95 下沉，维持小顶堆<br>对于海量数据，我们不需要一次性将全部数据取出来，可以一次只取一部分，因为我们只需要将数据一个个拿来与堆顶比较。</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/8807674-15eac9a1c7fb75e2.png?imageMogr2/auto-orient/strip|imageView2/2/w/788/format/webp\" alt=\"\"></p>\n<p>另外还有一个优势就是对于动态数组，我们可以一直都维护一个 K 大小的小顶堆，当有数据被添加到集合中时，我们就直接拿它与堆顶的元素对比。这样，无论任何时候需要查询当前的前 K 大数据，我们都可以里立刻返回给他。</p>\n<p>整个操作中，遍历数组需要 O(n) 的时间复杂度，一次堆化操作需要 O(logK)，加起来就是 O(nlogK) 的复杂度，换个角度来看，如果 K 远小于 n 的话， O(nlogK) 其实就接近于 O(n) 了，甚至会更快，因此也是十分高效的。</p>\n<p>最后，对于 Java，我们可以直接使用优先队列 PriorityQueue 来实现一个小顶堆，这里给个代码：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">public static List&lt;Integer&gt; solutionByHeap(int[] input, int k) &#123;</span><br><span class=\"line\">        List&lt;Integer&gt; list = new ArrayList&lt;&gt;();</span><br><span class=\"line\">        if (k &gt; input.length || k == 0) &#123;</span><br><span class=\"line\">            return list;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        Queue&lt;Integer&gt; queue = new PriorityQueue&lt;&gt;();</span><br><span class=\"line\">        for (int num : input) &#123;</span><br><span class=\"line\">            if (queue.size() &lt; k) &#123;</span><br><span class=\"line\">                queue.add(num);</span><br><span class=\"line\">            &#125; else if (queue.peek() &lt; num) &#123;</span><br><span class=\"line\">                queue.poll();</span><br><span class=\"line\">                queue.add(num);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        while (k-- &gt; 0) &#123;</span><br><span class=\"line\">            list.add(queue.poll());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return list;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>","cover":null,"images":["https://upload-images.jianshu.io/upload_images/8807674-d32bc53ef9cadc8d.png?imageMogr2/auto-orient/strip|imageView2/2/w/770/format/webp","https://upload-images.jianshu.io/upload_images/8807674-e67fb606d0f5766a.png?imageMogr2/auto-orient/strip|imageView2/2/w/776/format/webp","https://upload-images.jianshu.io/upload_images/8807674-15eac9a1c7fb75e2.png?imageMogr2/auto-orient/strip|imageView2/2/w/788/format/webp"],"content":"<p>转自：<a href=\"https://www.jianshu.com/p/a4a1984fc4ff\">https://www.jianshu.com/p/a4a1984fc4ff</a></p>\n<p>解决方法：<br>维护一个大小为 K 的小顶堆，依次将数据放入堆中，当堆的大小满了的时候，只需要将堆顶元素与下一个数比较：如果大于堆顶元素，则将当前的堆顶元素抛弃，并将该元素插入堆中。遍历完全部数据，Top K 的元素也自然都在堆里面了。</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/8807674-d32bc53ef9cadc8d.png?imageMogr2/auto-orient/strip|imageView2/2/w/770/format/webp\" alt=\"\"></p>\n<p>当然，如果是求前 K 个最小的数，只需要改为大顶堆即可</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/8807674-e67fb606d0f5766a.png?imageMogr2/auto-orient/strip|imageView2/2/w/776/format/webp\" alt=\"\"></p>\n<p> 将数据插入堆  95 大于 20，进行替换 95 下沉，维持小顶堆<br>对于海量数据，我们不需要一次性将全部数据取出来，可以一次只取一部分，因为我们只需要将数据一个个拿来与堆顶比较。</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/8807674-15eac9a1c7fb75e2.png?imageMogr2/auto-orient/strip|imageView2/2/w/788/format/webp\" alt=\"\"></p>\n<p>另外还有一个优势就是对于动态数组，我们可以一直都维护一个 K 大小的小顶堆，当有数据被添加到集合中时，我们就直接拿它与堆顶的元素对比。这样，无论任何时候需要查询当前的前 K 大数据，我们都可以里立刻返回给他。</p>\n<p>整个操作中，遍历数组需要 O(n) 的时间复杂度，一次堆化操作需要 O(logK)，加起来就是 O(nlogK) 的复杂度，换个角度来看，如果 K 远小于 n 的话， O(nlogK) 其实就接近于 O(n) 了，甚至会更快，因此也是十分高效的。</p>\n<p>最后，对于 Java，我们可以直接使用优先队列 PriorityQueue 来实现一个小顶堆，这里给个代码：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">public static List&lt;Integer&gt; solutionByHeap(int[] input, int k) &#123;</span><br><span class=\"line\">        List&lt;Integer&gt; list = new ArrayList&lt;&gt;();</span><br><span class=\"line\">        if (k &gt; input.length || k == 0) &#123;</span><br><span class=\"line\">            return list;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        Queue&lt;Integer&gt; queue = new PriorityQueue&lt;&gt;();</span><br><span class=\"line\">        for (int num : input) &#123;</span><br><span class=\"line\">            if (queue.size() &lt; k) &#123;</span><br><span class=\"line\">                queue.add(num);</span><br><span class=\"line\">            &#125; else if (queue.peek() &lt; num) &#123;</span><br><span class=\"line\">                queue.poll();</span><br><span class=\"line\">                queue.add(num);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        while (k-- &gt; 0) &#123;</span><br><span class=\"line\">            list.add(queue.poll());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return list;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>","categories":[{"name":"算法研究","slug":"算法研究","api":"api/categories/算法研究.json"}],"tags":[{"name":"算法","slug":"algorithm","api":"api/tags/algorithm.json"}],"api":"api/posts/2019/10/10/算法之优先队列-PriorityQueue解决Top-K-问题.json"},{"title":"Java中Lambda表达式解析","slug":"Java中Lambda表达式解析","date":"2019-10-09T10:55:00.000Z","updated":"2025-05-20T11:46:57.000Z","comments":true,"url":"2019/10/09/Java中Lambda表达式解析/","excerpt":"<p>在大部分开发者看来，Lambda 表达式只是一种语法糖，简化了书写匿名内部类的写法。实际上Lambda表达式并不仅仅是匿名内部类的语法糖，JVM内部是通过invokedynamic指令来实现Lambda表达式的，与内部类的实现有很大的差异。本文主要记录lambda的实现原理。</p>\n<h2 id=\"一、函数式接口\"><a href=\"#一、函数式接口\" class=\"headerlink\" title=\"一、函数式接口\"></a><strong>一、函数式接口</strong></h2><p>众所周知Javascript具有一个强大的特性：<strong>闭包</strong>。Java中最接近闭包概念的东西就是lambda表达式了，而Lambda为Java添加了缺失函数式编程的特点。所以什么是函数是接口呢？</p>\n<p>函数式接口需满足以下两个条件：</p>\n<ol>\n<li>它是接口</li>\n<li>这个接口<strong>有且仅有一个抽象方法</strong></li>\n</ol>\n<p>例如我们常用的：Runnable、View.OnClickListener、Comparable等都是函数式接口，因为它们都只有一个方法，而且都是抽象的。虽然只有一个抽象方法，是不是就意味着只能有一个方法呢？实际并不是，虽然有且仅有一个抽象方法，但是可以有多个非抽象方法的接口。</p>\n<p>嗯？！Java接口中难道还可以定义非抽象方法么？平时我们的接口大概长这样：<br><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">IdiomSubmitListener</span> &#123;</span><br><span class=\"line\">   \t<span class=\"keyword\">void</span> <span class=\"title function_\">verifyResult</span><span class=\"params\">(String result)</span>;</span><br><span class=\"line\">   \t<span class=\"keyword\">void</span> <span class=\"title function_\">onSuceess</span><span class=\"params\">()</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>那接口的非抽象方法是啥？原来在JDK 1.8 对于接口而言具有以下新特性：<br><strong>接口可以定义非抽象方法，但必须使用default或者staic关键字来修饰</strong><br>具体细节点可以参考 <a href=\"https://blog.csdn.net/austral/article/details/53402476\">JAVA 8新特性 允许接口定义非抽象方法 快速入门案例</a></p>\n<p>如果一个接口符合函数式接口的定义，那么我们就可以在该接口上面声明FunctionalInterface注解，用来表示该接口是一个函数式接口，并按照函数式接口的规范在编译的时候对该接口进行检查。</p>\n<p>当然如果某个接口只有一个抽象方法，但我们并没有给该接口声明FunctionalInterface注解，那么编译器依旧会将该接口看做是函数式接口。</p>\n<p>那Lambda表达式跟函数式接口又有什么关联呢？<br>在JDK 1.8中，Lambda表达式是对象，而不是函数，它们必须依附于一类特别的对象类型—函数式接口。</p>\n<p>因此可以说 在JDK 1.8中，Lambda表达式就是一个函数式接口的实例。<br><strong>所以如果一个实例是函数式接口的实例，那么该对象就可以用Lambda表达式来表示</strong></p>\n<h2 id=\"二、Lambda表达式与匿名内部类\"><a href=\"#二、Lambda表达式与匿名内部类\" class=\"headerlink\" title=\"二、Lambda表达式与匿名内部类\"></a><strong>二、Lambda表达式与匿名内部类</strong></h2><p>我们知道代码IDE如果是在JDK1.8的环境下，使用匿名内部类作为一个参数传入到方法中，编译器会提示我们：<code>Anonymous new Runnable() can be replaced with lambda</code>，匿名内部类XXX可以替换为lambda表达式。</p>\n<p>如下所示，匿名内部类 Runnable是一个函数式接口的实例，所以我们可以用lambda表达式来将之替换，从而将代码变得更加简洁。<br><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly9vc2NpbWcub3NjaGluYS5uZXQvb3NjbmV0Lzc4YzgxZWMyZjkzMmE5MDhmOTcxM2NiZGM5ODRkOGFhMWI2LmpwZw?x-oss-process=image/format,png\" alt=\"\"></p>\n<img src=\"https://cdn.julis.wang/blog/img/20191009170329915.png\">\n<p>那么我们是否就认为：Lambda表达式只是为匿名内部类中提供的一种语法糖，他们有什么区别呢？底层原理是完全一样的呢？</p>\n<p>他们主要区别如下：</p>\n<p>1、关键字this。匿名内部类的this指向匿名类，而Lambda表达式的this指向被Lambda包围的外部类</p>\n<p>2、编译方式。Java编译器将Lambda表达式编译成类的私有方法，使用Java7的invokedynamic字节码动态绑定这个方法。而匿名内部类将编译成<strong>外部类$数字编号</strong>的新类。这也造成第1点关键字this指向不同地方的原因。</p>\n<h2 id=\"三、Lambda实现原理\"><a href=\"#三、Lambda实现原理\" class=\"headerlink\" title=\"三、Lambda实现原理\"></a><strong>三、Lambda实现原理</strong></h2><p>我们知道如果使用匿名内部类，编译期间会生成一个外部类$数字编号的类，如图所示：</p>\n<img src=\"https://cdn.julis.wang/blog/img/20191009172403269.png\">\n<p>而如果使用Lambda表达式进行编译后并没有生成新类。</p>\n<img src=\"https://cdn.julis.wang/blog/img/20191009172455212.png\">\n<p>我们对Lambda表达式生成的class文件使用：javap -p -v Test.class 进行反编译生成如下内容，为便于观察，删除了一些无用内容<br><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">wang</span>.julis.jwbase.basecompact.Test</span><br><span class=\"line\"></span><br><span class=\"line\">Constant pool:</span><br><span class=\"line\">   #<span class=\"number\">1</span> = Methodref          #<span class=\"number\">9.</span>#<span class=\"number\">18</span>         <span class=\"comment\">// java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> wang.julis.jwbase.basecompact.Test();</span><br><span class=\"line\">    descriptor: ()V</span><br><span class=\"line\">    flags: (<span class=\"number\">0x0001</span>) ACC_PUBLIC</span><br><span class=\"line\">    Code:</span><br><span class=\"line\">      stack=<span class=\"number\">1</span>, locals=<span class=\"number\">1</span>, args_size=<span class=\"number\">1</span></span><br><span class=\"line\">         <span class=\"number\">0</span>: aload_0</span><br><span class=\"line\">         <span class=\"number\">1</span>: invokespecial #<span class=\"number\">1</span>                  <span class=\"comment\">// Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class=\"line\">         <span class=\"number\">4</span>: <span class=\"keyword\">return</span></span><br><span class=\"line\">      LineNumberTable:</span><br><span class=\"line\">        line <span class=\"number\">12</span>: <span class=\"number\">0</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">testLambda</span><span class=\"params\">()</span>;</span><br><span class=\"line\">    descriptor: ()V</span><br><span class=\"line\">    flags: (<span class=\"number\">0x0002</span>) ACC_PRIVATE</span><br><span class=\"line\">    Code:</span><br><span class=\"line\">      stack=<span class=\"number\">3</span>, locals=<span class=\"number\">1</span>, args_size=<span class=\"number\">1</span></span><br><span class=\"line\">         <span class=\"number\">0</span>: <span class=\"keyword\">new</span>           #<span class=\"number\">2</span>                  <span class=\"comment\">// class java/lang/Thread</span></span><br><span class=\"line\">         <span class=\"number\">3</span>: dup</span><br><span class=\"line\">         <span class=\"number\">4</span>: invokedynamic #<span class=\"number\">3</span>,  <span class=\"number\">0</span>              <span class=\"comment\">// InvokeDynamic #0:run:()Ljava/lang/Runnable;</span></span><br><span class=\"line\">         <span class=\"number\">9</span>: invokespecial #<span class=\"number\">4</span>                  <span class=\"comment\">// Method java/lang/Thread.&quot;&lt;init&gt;&quot;:(Ljava/lang/Runnable;)V</span></span><br><span class=\"line\">        <span class=\"number\">12</span>: pop</span><br><span class=\"line\">        <span class=\"number\">13</span>: <span class=\"keyword\">return</span></span><br><span class=\"line\">      LineNumberTable:</span><br><span class=\"line\">        line <span class=\"number\">14</span>: <span class=\"number\">0</span></span><br><span class=\"line\">        line <span class=\"number\">18</span>: <span class=\"number\">13</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> lambda$testLambda$<span class=\"number\">0</span>();</span><br><span class=\"line\">    descriptor: ()V</span><br><span class=\"line\">    flags: (<span class=\"number\">0x100a</span>) ACC_PRIVATE, ACC_STATIC, ACC_SYNTHETIC</span><br><span class=\"line\">    Code:</span><br><span class=\"line\">      stack=<span class=\"number\">2</span>, locals=<span class=\"number\">0</span>, args_size=<span class=\"number\">0</span></span><br><span class=\"line\">         <span class=\"number\">0</span>: getstatic     #<span class=\"number\">5</span>                  <span class=\"comment\">// Field java/lang/System.out:Ljava/io/PrintStream;</span></span><br><span class=\"line\">         <span class=\"number\">3</span>: ldc           #<span class=\"number\">6</span>                  <span class=\"comment\">// String lambda</span></span><br><span class=\"line\">         <span class=\"number\">5</span>: invokevirtual #<span class=\"number\">7</span>                  <span class=\"comment\">// Method java/io/PrintStream.println:(Ljava/lang/String;)V</span></span><br><span class=\"line\">         <span class=\"number\">8</span>: <span class=\"keyword\">return</span></span><br><span class=\"line\">      LineNumberTable:</span><br><span class=\"line\">        line <span class=\"number\">15</span>: <span class=\"number\">0</span></span><br><span class=\"line\">        line <span class=\"number\">16</span>: <span class=\"number\">8</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">SourceFile: <span class=\"string\">&quot;Test.java&quot;</span></span><br><span class=\"line\">InnerClasses:</span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> #<span class=\"number\">50</span>= #<span class=\"number\">49</span> of #<span class=\"number\">53</span>;    <span class=\"comment\">// Lookup=class java/lang/invoke/MethodHandles$Lookup of class java/lang/invoke/MethodHandles</span></span><br><span class=\"line\">BootstrapMethods:</span><br><span class=\"line\">  <span class=\"number\">0</span>: #<span class=\"number\">21</span> REF_invokeStatic java/lang/invoke/LambdaMetafactory.metafactory:(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite;</span><br><span class=\"line\">    Method arguments:</span><br><span class=\"line\">      #<span class=\"number\">22</span> ()V</span><br><span class=\"line\">      #<span class=\"number\">23</span> REF_invokeStatic wang/julis/jwbase/basecompact/Test.lambda$testLambda$<span class=\"number\">0</span>:()V</span><br><span class=\"line\">      #<span class=\"number\">22</span> ()V</span><br></pre></td></tr></table></figure><br>从反编译的结果我们可以看到：</p>\n<p>1、编译期间自动生成私有静态类<code>lambda$testLambda$0</code>而这里面就就是lambda的具体实现逻辑</p>\n<p>2、使用invokedynamic去执行lambda表达式 关于invokedynamic命令具体细节可以参考： <a href=\"https://time.geekbang.org/column/article/12564\">08 | JVM是怎么实现invokedynamic的？（上）</a></p>\n<p>3、lambda表达式编译后并没有生成外部类$数字编号的类</p>\n<h2 id=\"总结：\"><a href=\"#总结：\" class=\"headerlink\" title=\"总结：\"></a>总结：</h2><p>1、函数式接口：有且仅有一个抽象方法，可以用非抽象方法1.8后支持</p>\n<p>2、匿名内部类的this指向匿名类，而Lambda表达式的this指向被Lambda包围的外部类</p>\n<p>3、lambda表达式编译后不会生成外部类$数字编号的类</p>\n<p>4、Java编译器将Lambda表达式编译成类的私有方法，使用Java7的invokedynamic字节码动态绑定这个方法。</p>\n<p>参考：<br>1、《深入探索Android热修复技术原理》2.3.8章节<br>2、<a href=\"https://blog.csdn.net/zw19910924/article/details/75907348\">Java8 lambda表达式、函数式接口、方法引用</a></p>\n","cover":null,"images":["https://imgconvert.csdnimg.cn/aHR0cHM6Ly9vc2NpbWcub3NjaGluYS5uZXQvb3NjbmV0Lzc4YzgxZWMyZjkzMmE5MDhmOTcxM2NiZGM5ODRkOGFhMWI2LmpwZw?x-oss-process=image/format,png","https://cdn.julis.wang/blog/img/20191009170329915.png","https://cdn.julis.wang/blog/img/20191009172403269.png","https://cdn.julis.wang/blog/img/20191009172455212.png"],"content":"<p>在大部分开发者看来，Lambda 表达式只是一种语法糖，简化了书写匿名内部类的写法。实际上Lambda表达式并不仅仅是匿名内部类的语法糖，JVM内部是通过invokedynamic指令来实现Lambda表达式的，与内部类的实现有很大的差异。本文主要记录lambda的实现原理。</p>\n<h2 id=\"一、函数式接口\"><a href=\"#一、函数式接口\" class=\"headerlink\" title=\"一、函数式接口\"></a><strong>一、函数式接口</strong></h2><p>众所周知Javascript具有一个强大的特性：<strong>闭包</strong>。Java中最接近闭包概念的东西就是lambda表达式了，而Lambda为Java添加了缺失函数式编程的特点。所以什么是函数是接口呢？</p>\n<p>函数式接口需满足以下两个条件：</p>\n<ol>\n<li>它是接口</li>\n<li>这个接口<strong>有且仅有一个抽象方法</strong></li>\n</ol>\n<p>例如我们常用的：Runnable、View.OnClickListener、Comparable等都是函数式接口，因为它们都只有一个方法，而且都是抽象的。虽然只有一个抽象方法，是不是就意味着只能有一个方法呢？实际并不是，虽然有且仅有一个抽象方法，但是可以有多个非抽象方法的接口。</p>\n<p>嗯？！Java接口中难道还可以定义非抽象方法么？平时我们的接口大概长这样：<br><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">IdiomSubmitListener</span> &#123;</span><br><span class=\"line\">   \t<span class=\"keyword\">void</span> <span class=\"title function_\">verifyResult</span><span class=\"params\">(String result)</span>;</span><br><span class=\"line\">   \t<span class=\"keyword\">void</span> <span class=\"title function_\">onSuceess</span><span class=\"params\">()</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>那接口的非抽象方法是啥？原来在JDK 1.8 对于接口而言具有以下新特性：<br><strong>接口可以定义非抽象方法，但必须使用default或者staic关键字来修饰</strong><br>具体细节点可以参考 <a href=\"https://blog.csdn.net/austral/article/details/53402476\">JAVA 8新特性 允许接口定义非抽象方法 快速入门案例</a></p>\n<p>如果一个接口符合函数式接口的定义，那么我们就可以在该接口上面声明FunctionalInterface注解，用来表示该接口是一个函数式接口，并按照函数式接口的规范在编译的时候对该接口进行检查。</p>\n<p>当然如果某个接口只有一个抽象方法，但我们并没有给该接口声明FunctionalInterface注解，那么编译器依旧会将该接口看做是函数式接口。</p>\n<p>那Lambda表达式跟函数式接口又有什么关联呢？<br>在JDK 1.8中，Lambda表达式是对象，而不是函数，它们必须依附于一类特别的对象类型—函数式接口。</p>\n<p>因此可以说 在JDK 1.8中，Lambda表达式就是一个函数式接口的实例。<br><strong>所以如果一个实例是函数式接口的实例，那么该对象就可以用Lambda表达式来表示</strong></p>\n<h2 id=\"二、Lambda表达式与匿名内部类\"><a href=\"#二、Lambda表达式与匿名内部类\" class=\"headerlink\" title=\"二、Lambda表达式与匿名内部类\"></a><strong>二、Lambda表达式与匿名内部类</strong></h2><p>我们知道代码IDE如果是在JDK1.8的环境下，使用匿名内部类作为一个参数传入到方法中，编译器会提示我们：<code>Anonymous new Runnable() can be replaced with lambda</code>，匿名内部类XXX可以替换为lambda表达式。</p>\n<p>如下所示，匿名内部类 Runnable是一个函数式接口的实例，所以我们可以用lambda表达式来将之替换，从而将代码变得更加简洁。<br><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly9vc2NpbWcub3NjaGluYS5uZXQvb3NjbmV0Lzc4YzgxZWMyZjkzMmE5MDhmOTcxM2NiZGM5ODRkOGFhMWI2LmpwZw?x-oss-process=image/format,png\" alt=\"\"></p>\n<img src=\"https://cdn.julis.wang/blog/img/20191009170329915.png\">\n<p>那么我们是否就认为：Lambda表达式只是为匿名内部类中提供的一种语法糖，他们有什么区别呢？底层原理是完全一样的呢？</p>\n<p>他们主要区别如下：</p>\n<p>1、关键字this。匿名内部类的this指向匿名类，而Lambda表达式的this指向被Lambda包围的外部类</p>\n<p>2、编译方式。Java编译器将Lambda表达式编译成类的私有方法，使用Java7的invokedynamic字节码动态绑定这个方法。而匿名内部类将编译成<strong>外部类$数字编号</strong>的新类。这也造成第1点关键字this指向不同地方的原因。</p>\n<h2 id=\"三、Lambda实现原理\"><a href=\"#三、Lambda实现原理\" class=\"headerlink\" title=\"三、Lambda实现原理\"></a><strong>三、Lambda实现原理</strong></h2><p>我们知道如果使用匿名内部类，编译期间会生成一个外部类$数字编号的类，如图所示：</p>\n<img src=\"https://cdn.julis.wang/blog/img/20191009172403269.png\">\n<p>而如果使用Lambda表达式进行编译后并没有生成新类。</p>\n<img src=\"https://cdn.julis.wang/blog/img/20191009172455212.png\">\n<p>我们对Lambda表达式生成的class文件使用：javap -p -v Test.class 进行反编译生成如下内容，为便于观察，删除了一些无用内容<br><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">wang</span>.julis.jwbase.basecompact.Test</span><br><span class=\"line\"></span><br><span class=\"line\">Constant pool:</span><br><span class=\"line\">   #<span class=\"number\">1</span> = Methodref          #<span class=\"number\">9.</span>#<span class=\"number\">18</span>         <span class=\"comment\">// java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> wang.julis.jwbase.basecompact.Test();</span><br><span class=\"line\">    descriptor: ()V</span><br><span class=\"line\">    flags: (<span class=\"number\">0x0001</span>) ACC_PUBLIC</span><br><span class=\"line\">    Code:</span><br><span class=\"line\">      stack=<span class=\"number\">1</span>, locals=<span class=\"number\">1</span>, args_size=<span class=\"number\">1</span></span><br><span class=\"line\">         <span class=\"number\">0</span>: aload_0</span><br><span class=\"line\">         <span class=\"number\">1</span>: invokespecial #<span class=\"number\">1</span>                  <span class=\"comment\">// Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class=\"line\">         <span class=\"number\">4</span>: <span class=\"keyword\">return</span></span><br><span class=\"line\">      LineNumberTable:</span><br><span class=\"line\">        line <span class=\"number\">12</span>: <span class=\"number\">0</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">testLambda</span><span class=\"params\">()</span>;</span><br><span class=\"line\">    descriptor: ()V</span><br><span class=\"line\">    flags: (<span class=\"number\">0x0002</span>) ACC_PRIVATE</span><br><span class=\"line\">    Code:</span><br><span class=\"line\">      stack=<span class=\"number\">3</span>, locals=<span class=\"number\">1</span>, args_size=<span class=\"number\">1</span></span><br><span class=\"line\">         <span class=\"number\">0</span>: <span class=\"keyword\">new</span>           #<span class=\"number\">2</span>                  <span class=\"comment\">// class java/lang/Thread</span></span><br><span class=\"line\">         <span class=\"number\">3</span>: dup</span><br><span class=\"line\">         <span class=\"number\">4</span>: invokedynamic #<span class=\"number\">3</span>,  <span class=\"number\">0</span>              <span class=\"comment\">// InvokeDynamic #0:run:()Ljava/lang/Runnable;</span></span><br><span class=\"line\">         <span class=\"number\">9</span>: invokespecial #<span class=\"number\">4</span>                  <span class=\"comment\">// Method java/lang/Thread.&quot;&lt;init&gt;&quot;:(Ljava/lang/Runnable;)V</span></span><br><span class=\"line\">        <span class=\"number\">12</span>: pop</span><br><span class=\"line\">        <span class=\"number\">13</span>: <span class=\"keyword\">return</span></span><br><span class=\"line\">      LineNumberTable:</span><br><span class=\"line\">        line <span class=\"number\">14</span>: <span class=\"number\">0</span></span><br><span class=\"line\">        line <span class=\"number\">18</span>: <span class=\"number\">13</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> lambda$testLambda$<span class=\"number\">0</span>();</span><br><span class=\"line\">    descriptor: ()V</span><br><span class=\"line\">    flags: (<span class=\"number\">0x100a</span>) ACC_PRIVATE, ACC_STATIC, ACC_SYNTHETIC</span><br><span class=\"line\">    Code:</span><br><span class=\"line\">      stack=<span class=\"number\">2</span>, locals=<span class=\"number\">0</span>, args_size=<span class=\"number\">0</span></span><br><span class=\"line\">         <span class=\"number\">0</span>: getstatic     #<span class=\"number\">5</span>                  <span class=\"comment\">// Field java/lang/System.out:Ljava/io/PrintStream;</span></span><br><span class=\"line\">         <span class=\"number\">3</span>: ldc           #<span class=\"number\">6</span>                  <span class=\"comment\">// String lambda</span></span><br><span class=\"line\">         <span class=\"number\">5</span>: invokevirtual #<span class=\"number\">7</span>                  <span class=\"comment\">// Method java/io/PrintStream.println:(Ljava/lang/String;)V</span></span><br><span class=\"line\">         <span class=\"number\">8</span>: <span class=\"keyword\">return</span></span><br><span class=\"line\">      LineNumberTable:</span><br><span class=\"line\">        line <span class=\"number\">15</span>: <span class=\"number\">0</span></span><br><span class=\"line\">        line <span class=\"number\">16</span>: <span class=\"number\">8</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">SourceFile: <span class=\"string\">&quot;Test.java&quot;</span></span><br><span class=\"line\">InnerClasses:</span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> #<span class=\"number\">50</span>= #<span class=\"number\">49</span> of #<span class=\"number\">53</span>;    <span class=\"comment\">// Lookup=class java/lang/invoke/MethodHandles$Lookup of class java/lang/invoke/MethodHandles</span></span><br><span class=\"line\">BootstrapMethods:</span><br><span class=\"line\">  <span class=\"number\">0</span>: #<span class=\"number\">21</span> REF_invokeStatic java/lang/invoke/LambdaMetafactory.metafactory:(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite;</span><br><span class=\"line\">    Method arguments:</span><br><span class=\"line\">      #<span class=\"number\">22</span> ()V</span><br><span class=\"line\">      #<span class=\"number\">23</span> REF_invokeStatic wang/julis/jwbase/basecompact/Test.lambda$testLambda$<span class=\"number\">0</span>:()V</span><br><span class=\"line\">      #<span class=\"number\">22</span> ()V</span><br></pre></td></tr></table></figure><br>从反编译的结果我们可以看到：</p>\n<p>1、编译期间自动生成私有静态类<code>lambda$testLambda$0</code>而这里面就就是lambda的具体实现逻辑</p>\n<p>2、使用invokedynamic去执行lambda表达式 关于invokedynamic命令具体细节可以参考： <a href=\"https://time.geekbang.org/column/article/12564\">08 | JVM是怎么实现invokedynamic的？（上）</a></p>\n<p>3、lambda表达式编译后并没有生成外部类$数字编号的类</p>\n<h2 id=\"总结：\"><a href=\"#总结：\" class=\"headerlink\" title=\"总结：\"></a>总结：</h2><p>1、函数式接口：有且仅有一个抽象方法，可以用非抽象方法1.8后支持</p>\n<p>2、匿名内部类的this指向匿名类，而Lambda表达式的this指向被Lambda包围的外部类</p>\n<p>3、lambda表达式编译后不会生成外部类$数字编号的类</p>\n<p>4、Java编译器将Lambda表达式编译成类的私有方法，使用Java7的invokedynamic字节码动态绑定这个方法。</p>\n<p>参考：<br>1、《深入探索Android热修复技术原理》2.3.8章节<br>2、<a href=\"https://blog.csdn.net/zw19910924/article/details/75907348\">Java8 lambda表达式、函数式接口、方法引用</a></p>\n","categories":[{"name":"技术文章","slug":"technology","api":"api/categories/technology.json"}],"tags":[{"name":"Java","slug":"java","api":"api/tags/java.json"}],"api":"api/posts/2019/10/09/Java中Lambda表达式解析.json"},{"title":"观《百鸟朝凤》有感","slug":"观《百鸟朝凤》有感","date":"2019-09-07T18:16:00.000Z","updated":"2025-05-20T11:46:57.000Z","comments":true,"url":"2019/09/08/观《百鸟朝凤》有感/","excerpt":"<p>此刻子时，在朋友的推荐下看完了整部《百鸟朝凤》，看完之后我立马起身来打开电脑，心中思绪万千，准备写下来记录下来。自我观看了这么多电影以来，头一次是如此的触动，头一次留下来这样的眼泪，记得上一次很有感触还是因为《忠犬八公的故事》，那次泪水到了眼角，我忍住了，没有掉下来。这部电影实在是让我太感动了，我的泪水憋不下去了，源源不断地从眼眶里面流出来。我捂着自己的嘴巴，我怕自己嚎啕大哭起来，不停地抽泣。对一代匠人的崇敬之情，当然也让我想起来那个人……</p>\n<p>   他已经离我六年之余，从离开他之后，我的梦大部分都是关于他，梦中的情节很多都是让我感觉他躲起来了，然后又出现再了我的面前。每次梦醒，思前想后，万端交集，竟不能复寐，他便是我的爷爷-兴武老大人。</p>\n<p>   关于他的记忆开始慢慢变得模糊，有很多事情都已经忘记，但又有很多我根本不能忘记。影片中的焦师傅，爷爷的形象简直和他一模一样，都一样抽着大烟，瘦弱的身躯，头顶的中间光秃秃的，走路总是半佝偻着腰，但是眼神又是那么的坚毅。他们都对传统文化有着独特的情感，我的爷爷也算是一个匠人，他是一名竹匠（“四川话叫 mie匠”），他只告诉过我，那个年代他们靠卖竹制的东西（大抵是一些席子、竹帘、晒席之类的东西）过日子，每天都帮着各种编织，才养活了包括我爸在内的五个子女。家中很多东西，也都是竹子做的。在我小的时候，我记得基本上我们整个村，每家每户都有一片属于自家的竹林，它不仅能提供我们编制各种东西的原材料，也能提供做饭生火的材料。在我现在看来，它更能提供那种接近大自然的方式。每当夜里，如果有阵阵微风，竹林中便会的竹叶洒洒作响的声音，我也很久没有听到这种声音了。</p>\n<p>   如果我看到我的爷爷拿着一把弯刀去后院，那我一定知道他应该是要去砍竹子，只听哐哐哐一阵声，竹子便倒了下来，他会剔除掉竹子的枝丫，以及顶部较为脆弱细小的部分。然后用取当中的一节，再用刀将其剖开，根据所做的东西的不同，会将竹子的圆分成不同的等分。然后会做一个比较难得的操作，具体用文字表达我也不知道该用什么术语去说，就是将竹子外层坚韧的部分与内部相分离，分离后的竹条厚度均匀。这便是编制前的准备阶段，对于编制一些特殊的物品，竹条可能还会经过一些其他一些操作才能继续编制。</p>\n<p>   为了编一个撮箕或者簸箕，爷爷可能会花上一整天的时间，弯腰在地一点一点的编织着。我经常在旁边看着，我可能也想去尝试，但一不下心手就会因为竹子的锋利而流血。而爷爷的手并不一样，我记得他的手上有很多老茧，手指头也特别的硬，我感觉他的手就像带了一个硬皮手套一样，这都是岁月留下来的痕迹吧。他总是给我讲他们过去的故事，也会给我讲解人生大道理。他给我讲梁山伯与祝英台的故事，他也给我讲毛泽东，他也讲以前文化大革命的故事……讲以前生活是多么的不容易，他们遭受了多少苦，我都还记得。爷爷编织好的竹制品真的很精致耐用，家里现在也还留着一些当时他编好的东西。我觉得那都是艺术品，都是源于一个人对生活的热爱以及对匠人的诠释吧。</p>\n<p>   后来搬家了，原先家里的那片竹林离我们有一些距离，我爸想把它们都挖了卖掉，因为现在我们不需要那么多竹子了。我爷爷当然不允许啊！卖掉？直接就跟我爸翻脸。在我看来，那片竹林可能承载了太多爷爷的记忆吧，太多的舍不得。但爷爷去世之后，那片竹林还是被移除掉了，实在痛惜。我后悔没有跟我的爷爷学这些编制技术，我爸会一些，但是我认为他只是一个半吊子，和爷爷做的东西比起来实在是差太多了。我爸曾说：“现在谁还做那些啊？有钱我们可以买。”，对于他的话我有反驳过。买来的那些都是些没有被注入感情的废铜烂铁吧，与爷爷的东西差太远了。或许真的因为时代的发展吧，这些东西渐渐地都被淘汰掉了，但我认为这些都是才是真正应该被传承下来的，不仅仅是因为这一门技术，更多的那一份精神吧。是用钱买不来的，机器造不来的。</p>\n<p>   《百鸟朝凤》这部电影令人肃然起敬，质朴的人物形象，体现出来了当代中国传统文化的潦倒与窘境，传承不是说说而已，是每一个中国人应该有的责任。在现代多元文化的冲击下，更多人的失去了对精神的追求和向往，取而代之的是短暂的愉悦刺激以及碎片化的东西。<br>我们的生活其实可以更有内涵……</p>\n<p>困了，就写这么多吧，讲了一些乱七八糟的东西，懂得人自然懂吧。</p>\n<p>晚安~</p>\n<p><img src=\"https://pica.zhimg.com/70/fca270cbac1c48fb0f343fa336c23b3a_1440w.avis?source=172ae18b&amp;biz_tag=Post\" alt=\"\"></p>\n","cover":null,"images":["https://pica.zhimg.com/70/fca270cbac1c48fb0f343fa336c23b3a_1440w.avis?source=172ae18b&amp;biz_tag=Post"],"content":"<p>此刻子时，在朋友的推荐下看完了整部《百鸟朝凤》，看完之后我立马起身来打开电脑，心中思绪万千，准备写下来记录下来。自我观看了这么多电影以来，头一次是如此的触动，头一次留下来这样的眼泪，记得上一次很有感触还是因为《忠犬八公的故事》，那次泪水到了眼角，我忍住了，没有掉下来。这部电影实在是让我太感动了，我的泪水憋不下去了，源源不断地从眼眶里面流出来。我捂着自己的嘴巴，我怕自己嚎啕大哭起来，不停地抽泣。对一代匠人的崇敬之情，当然也让我想起来那个人……</p>\n<p>   他已经离我六年之余，从离开他之后，我的梦大部分都是关于他，梦中的情节很多都是让我感觉他躲起来了，然后又出现再了我的面前。每次梦醒，思前想后，万端交集，竟不能复寐，他便是我的爷爷-兴武老大人。</p>\n<p>   关于他的记忆开始慢慢变得模糊，有很多事情都已经忘记，但又有很多我根本不能忘记。影片中的焦师傅，爷爷的形象简直和他一模一样，都一样抽着大烟，瘦弱的身躯，头顶的中间光秃秃的，走路总是半佝偻着腰，但是眼神又是那么的坚毅。他们都对传统文化有着独特的情感，我的爷爷也算是一个匠人，他是一名竹匠（“四川话叫 mie匠”），他只告诉过我，那个年代他们靠卖竹制的东西（大抵是一些席子、竹帘、晒席之类的东西）过日子，每天都帮着各种编织，才养活了包括我爸在内的五个子女。家中很多东西，也都是竹子做的。在我小的时候，我记得基本上我们整个村，每家每户都有一片属于自家的竹林，它不仅能提供我们编制各种东西的原材料，也能提供做饭生火的材料。在我现在看来，它更能提供那种接近大自然的方式。每当夜里，如果有阵阵微风，竹林中便会的竹叶洒洒作响的声音，我也很久没有听到这种声音了。</p>\n<p>   如果我看到我的爷爷拿着一把弯刀去后院，那我一定知道他应该是要去砍竹子，只听哐哐哐一阵声，竹子便倒了下来，他会剔除掉竹子的枝丫，以及顶部较为脆弱细小的部分。然后用取当中的一节，再用刀将其剖开，根据所做的东西的不同，会将竹子的圆分成不同的等分。然后会做一个比较难得的操作，具体用文字表达我也不知道该用什么术语去说，就是将竹子外层坚韧的部分与内部相分离，分离后的竹条厚度均匀。这便是编制前的准备阶段，对于编制一些特殊的物品，竹条可能还会经过一些其他一些操作才能继续编制。</p>\n<p>   为了编一个撮箕或者簸箕，爷爷可能会花上一整天的时间，弯腰在地一点一点的编织着。我经常在旁边看着，我可能也想去尝试，但一不下心手就会因为竹子的锋利而流血。而爷爷的手并不一样，我记得他的手上有很多老茧，手指头也特别的硬，我感觉他的手就像带了一个硬皮手套一样，这都是岁月留下来的痕迹吧。他总是给我讲他们过去的故事，也会给我讲解人生大道理。他给我讲梁山伯与祝英台的故事，他也给我讲毛泽东，他也讲以前文化大革命的故事……讲以前生活是多么的不容易，他们遭受了多少苦，我都还记得。爷爷编织好的竹制品真的很精致耐用，家里现在也还留着一些当时他编好的东西。我觉得那都是艺术品，都是源于一个人对生活的热爱以及对匠人的诠释吧。</p>\n<p>   后来搬家了，原先家里的那片竹林离我们有一些距离，我爸想把它们都挖了卖掉，因为现在我们不需要那么多竹子了。我爷爷当然不允许啊！卖掉？直接就跟我爸翻脸。在我看来，那片竹林可能承载了太多爷爷的记忆吧，太多的舍不得。但爷爷去世之后，那片竹林还是被移除掉了，实在痛惜。我后悔没有跟我的爷爷学这些编制技术，我爸会一些，但是我认为他只是一个半吊子，和爷爷做的东西比起来实在是差太多了。我爸曾说：“现在谁还做那些啊？有钱我们可以买。”，对于他的话我有反驳过。买来的那些都是些没有被注入感情的废铜烂铁吧，与爷爷的东西差太远了。或许真的因为时代的发展吧，这些东西渐渐地都被淘汰掉了，但我认为这些都是才是真正应该被传承下来的，不仅仅是因为这一门技术，更多的那一份精神吧。是用钱买不来的，机器造不来的。</p>\n<p>   《百鸟朝凤》这部电影令人肃然起敬，质朴的人物形象，体现出来了当代中国传统文化的潦倒与窘境，传承不是说说而已，是每一个中国人应该有的责任。在现代多元文化的冲击下，更多人的失去了对精神的追求和向往，取而代之的是短暂的愉悦刺激以及碎片化的东西。<br>我们的生活其实可以更有内涵……</p>\n<p>困了，就写这么多吧，讲了一些乱七八糟的东西，懂得人自然懂吧。</p>\n<p>晚安~</p>\n<p><img src=\"https://pica.zhimg.com/70/fca270cbac1c48fb0f343fa336c23b3a_1440w.avis?source=172ae18b&amp;biz_tag=Post\" alt=\"\"></p>\n","categories":[{"name":"读书电影","slug":"movie","api":"api/categories/movie.json"}],"tags":[{"name":"省","slug":"thinking","api":"api/tags/thinking.json"}],"api":"api/posts/2019/09/08/观《百鸟朝凤》有感.json"},{"title":"Android骨架屏效果的实现与原理解析","slug":"Android骨架屏效果的实现与原理解析","date":"2019-09-04T09:50:00.000Z","updated":"2025-05-20T11:46:57.000Z","comments":true,"url":"2019/09/04/Android骨架屏效果的实现与原理解析/","excerpt":"<p>大家在使用淘宝的时候，如下图所示有遇到这样的效果，其会只展示一部分骨架大致图，等数据加载完毕之后再展示真正的页面数据。与菊花图相比起来，这样的实现能更好的提升用户的体验，这种效果称做：Skeleton Screen Loading，中文叫做<strong>骨架屏</strong>，本文主要记录其实现过程。</p>\n<h2 id=\"1、骨架屏的实现方式\"><a href=\"#1、骨架屏的实现方式\" class=\"headerlink\" title=\"1、骨架屏的实现方式\"></a>1、骨架屏的实现方式</h2><img src=\"https://cdn.julis.wang/blog/img/b911cd8e3eba7fdc4bea89ad6cb07bf4a7d.png\">\n<p>在现在主流的骨架屏实现效果中有两种方式：</p>\n<ul>\n<li><p>通过View或者Adapter的替换来实现骨架屏效果。可以参考<a href=\"https://github.com/sharish/ShimmerRecyclerView\">ShimmerRecyclerView</a>、<a href=\"https://github.com/ethanhua/Skeleton\">Skeleton</a>及<a href=\"https://github.com/willowtreeapps/spruce-android\">spruce-android</a>。</p>\n</li>\n<li><p>自定义一个View来对布局中的View进行一层包裹，当加载数据时则根据View来绘制骨架，否则显示正常UI，参考<a href=\"https://github.com/rasoulmiri/Skeleton\">Skeleton Android</a>。</p>\n</li>\n</ul>\n<p>这些开源库中，自己比较喜欢今天<strong>Skeleton</strong>这个开源库，总结了有如下一些优缺点：</p>\n<p><strong>优点：</strong></p>\n<ol>\n<li>代码方案实现及使用方式简单，通过替换View和Adapter实现效果，使用Builder设计模式来构造。</li>\n<li>代码耦合程度不高。没有复杂的设计模式，使得代码结构清晰明了。</li>\n<li>骨架屏的效果使用相对于较灵活，可以对整个布局实现骨架屏效果，也可以对单一View实现骨架屏效果。</li>\n</ol>\n<p><strong>缺点：</strong></p>\n<ol>\n<li>需要对每个骨架屏效果单独写一套xml布局。</li>\n<li>使用的removeView和addView对 原有布局的view进行替换，存在一定的风险性</li>\n<li>必须清晰的知道所bind的View类型，存在一定的类型转化问题。</li>\n<li>依赖了shimmerlayout第三方库</li>\n</ol>\n<h2 id=\"2、Skeleton解读\"><a href=\"#2、Skeleton解读\" class=\"headerlink\" title=\"2、Skeleton解读\"></a>2、Skeleton解读</h2><p><strong>一、Skeleton的使用方式</strong></p>\n<p>展示骨架屏效果：<br><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">View</span> <span class=\"variable\">rootView</span> <span class=\"operator\">=</span> findViewById(R.id.rootView);</span><br><span class=\"line\">skeletonScreen = Skeleton.bind(rootView)</span><br><span class=\"line\">           .load(R.layout.activity_view_skeleton)<span class=\"comment\">//骨架屏UI</span></span><br><span class=\"line\">           .duration(<span class=\"number\">1000</span>)<span class=\"comment\">//动画时间，以毫秒为单位</span></span><br><span class=\"line\">           .shimmer(<span class=\"literal\">true</span>)<span class=\"comment\">//是否开启动画</span></span><br><span class=\"line\">           .color(R.color.shimmer_color)<span class=\"comment\">//shimmer的颜色</span></span><br><span class=\"line\">           .angle(<span class=\"number\">30</span>)<span class=\"comment\">//shimmer的倾斜角度</span></span><br><span class=\"line\">           .show();</span><br></pre></td></tr></table></figure><br>关闭骨架屏效果并展示原有View：<br><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">skeletonScreen.hide()</span><br></pre></td></tr></table></figure></p>\n<p><strong>流程：</strong></p>\n<p> **1. 选择需要替换的目标view</p>\n<ol>\n<li>将骨架效果xml与目标view进行绑定</li>\n<li>添加一些效果属性，比如：动画时间、是否开启展示动画、动画颜色等</li>\n<li>在合适的实际关闭骨架屏效果**</li>\n</ol>\n<p><strong>二、Skeleton源码实现</strong></p>\n<p>Skeleton提供两个绑定方法，分别绑定普通View与RecyclerView，分别返回对应的Builder<br><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Skeleton</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> RecyclerViewSkeletonScreen.Builder <span class=\"title function_\">bind</span><span class=\"params\">(RecyclerView recyclerView)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">RecyclerViewSkeletonScreen</span>.Builder(recyclerView);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> ViewSkeletonScreen.Builder <span class=\"title function_\">bind</span><span class=\"params\">(View view)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ViewSkeletonScreen</span>.Builder(view);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>我们首先来看看如何实现与普通View绑定，构造方法中传入目标View，并对shimmer动画效果设置默认的颜色，在Builder里面我们可以看到各种相关参数的设定。<br><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"title function_\">Builder</span><span class=\"params\">(View view)</span> &#123;</span><br><span class=\"line\">\t<span class=\"built_in\">this</span>.mView = view;</span><br><span class=\"line\">\t<span class=\"built_in\">this</span>.mShimmerColor = ContextCompat.getColor(mView.getContext(), R.color.shimmer_color);</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure><br>接下来再到show的步骤，主要实现还是由ViewSkeletonScreen来实现<br><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> ViewSkeletonScreen <span class=\"title function_\">show</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">ViewSkeletonScreen</span> <span class=\"variable\">skeletonScreen</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ViewSkeletonScreen</span>(<span class=\"built_in\">this</span>);</span><br><span class=\"line\">    skeletonScreen.show();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> skeletonScreen;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>其中ViewSkeletonScreen与绑定的RecyclerViewSkeletonScreen都实现了SkeletonScreen接口，SkeletonScreen有两个接口方法分别是   </p>\n<pre><code>void show();\nvoid hide();\n</code></pre><p>对于ViewSkeletonScreen.show()进入源码，这里出现一个比较重要的类<code>ViewReplacer</code>，等下再进行解析，通过show的源码清楚的知道逻辑：<br><strong>1、生成骨架效果View<br>2、利用生成的View替换目标View。</strong><br>其中生成骨架效果View阶段主要还是通过LayoutInflater去加载传入mSkeletonResID</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">show</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">       <span class=\"type\">View</span> <span class=\"variable\">skeletonLoadingView</span> <span class=\"operator\">=</span> generateSkeletonLoadingView();</span><br><span class=\"line\">       <span class=\"keyword\">if</span> (skeletonLoadingView != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">           mViewReplacer.replace(skeletonLoadingView);</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n<p>接下来主要讲解ViewReplacer类，其构造方法传入目标View</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"title function_\">ViewReplacer</span><span class=\"params\">(View sourceView)</span> &#123;</span><br><span class=\"line\">     mSourceView = sourceView;</span><br><span class=\"line\">     mSourceViewLayoutParams = mSourceView.getLayoutParams();</span><br><span class=\"line\">     mCurrentView = mSourceView;</span><br><span class=\"line\">     mSourceViewId = mSourceView.getId();</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n<p>其比较重要的方法有两个：<code>replace()</code> 和 <code>restore()</code> 这两个方法分别为SkeletonScreen 的show()和hide()的最终实现，首先看<code>replace()</code>方法，有两个方法重载，分别传入<code>targetViewResID</code>或者<code>targetView</code>，最终还是会走到<code>replace(View targetView)</code>中。<br>其主要逻辑为：</p>\n<p> **1. 判断所替换的View和骨架屏效果View是否为同一个View</p>\n<ol>\n<li>remove掉在父布局中的目标View</li>\n<li>将骨架屏效果View添加到目标View的父布局中**</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">replace</span><span class=\"params\">(<span class=\"type\">int</span> targetViewResID)</span> &#123;</span><br><span class=\"line\">       <span class=\"keyword\">if</span> (mTargetViewResID == targetViewResID) &#123;</span><br><span class=\"line\">           <span class=\"keyword\">return</span>;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       <span class=\"keyword\">if</span> (init()) &#123;</span><br><span class=\"line\">           mTargetViewResID = targetViewResID;</span><br><span class=\"line\">           replace(LayoutInflater.from(mSourceView.getContext()).inflate(mTargetViewResID, mSourceParentView, <span class=\"literal\">false</span>));</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">replace</span><span class=\"params\">(View targetView)</span> &#123;</span><br><span class=\"line\">       <span class=\"keyword\">if</span> (mCurrentView == targetView) &#123;</span><br><span class=\"line\">           <span class=\"keyword\">return</span>;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       <span class=\"keyword\">if</span> (targetView.getParent() != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">           ((ViewGroup) targetView.getParent()).removeView(targetView);</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       <span class=\"keyword\">if</span> (init()) &#123;</span><br><span class=\"line\">           mTargetView = targetView;</span><br><span class=\"line\">           mSourceParentView.removeView(mCurrentView);</span><br><span class=\"line\">           mTargetView.setId(mSourceViewId);</span><br><span class=\"line\">           mSourceParentView.addView(mTargetView, mSourceViewIndexInParent, mSourceViewLayoutParams);</span><br><span class=\"line\">           mCurrentView = mTargetView;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n<p>在执行添加到目标View的父布局中，有执行一个init方法，主要做两件事：</p>\n<p> **1. 获取目标View的父View</p>\n<ol>\n<li>找到目标View在父View 中的位置索引，为之后添加骨架屏View到父View中做铺垫**</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"type\">boolean</span> <span class=\"title function_\">init</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">     <span class=\"keyword\">if</span> (mSourceParentView == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">         mSourceParentView = (ViewGroup) mSourceView.getParent();</span><br><span class=\"line\">         <span class=\"keyword\">if</span> (mSourceParentView == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">             Log.e(TAG, <span class=\"string\">&quot;the source view have not attach to any view&quot;</span>);</span><br><span class=\"line\">             <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">         <span class=\"type\">int</span> <span class=\"variable\">count</span> <span class=\"operator\">=</span> mSourceParentView.getChildCount();</span><br><span class=\"line\">         <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">index</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; index &lt; count; index++) &#123;</span><br><span class=\"line\">             <span class=\"keyword\">if</span> (mSourceView == mSourceParentView.getChildAt(index)) &#123;</span><br><span class=\"line\">                 mSourceViewIndexInParent = index;</span><br><span class=\"line\">                 <span class=\"keyword\">break</span>;</span><br><span class=\"line\">             &#125;</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">     <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n<p>至此对普通View的骨架屏效果实现流程已经完全梳理完成，那对于<code>RecyclerView</code>呢？其实两者实现逻辑差不多，主要有两个差异：</p>\n<ol>\n<li>在<code>RecyclerViewSkeletonScreen</code>的Builder中，相比ViewSkeletonScreen多了一个adapter()方法，传入目标<code>RecyclerView</code>的<code>Adapter</code></li>\n<li>在show的时候对目标<code>RecyclerView</code>的adapter进行替换，使用骨架屏效果的adapter。hide的时候恢复为原先的Adapter</li>\n</ol>\n<h2 id=\"3、总结\"><a href=\"#3、总结\" class=\"headerlink\" title=\"3、总结\"></a>3、总结</h2><ol>\n<li>Skeleton的原理主要是通过替换目标View和RecyclerView的Adapter</li>\n<li>在Skeleton的使用过程中最需要关心的两个问题是：show()和hide()的时机</li>\n<li>对于整个页面的骨架屏效果实现，个人推荐在布局中添加一个全屏的空View盖在原先内容上</li>\n<li>注意一些异常情况下的hide()，要不然整个页面就“假死”状态了。</li>\n</ol>\n<p>参考：<br><a href=\"https://juejin.im/post/5c789a4ce51d457c042d3b31\">https://juejin.im/post/5c789a4ce51d457c042d3b31</a></p>\n","cover":null,"images":["https://cdn.julis.wang/blog/img/b911cd8e3eba7fdc4bea89ad6cb07bf4a7d.png"],"content":"<p>大家在使用淘宝的时候，如下图所示有遇到这样的效果，其会只展示一部分骨架大致图，等数据加载完毕之后再展示真正的页面数据。与菊花图相比起来，这样的实现能更好的提升用户的体验，这种效果称做：Skeleton Screen Loading，中文叫做<strong>骨架屏</strong>，本文主要记录其实现过程。</p>\n<h2 id=\"1、骨架屏的实现方式\"><a href=\"#1、骨架屏的实现方式\" class=\"headerlink\" title=\"1、骨架屏的实现方式\"></a>1、骨架屏的实现方式</h2><img src=\"https://cdn.julis.wang/blog/img/b911cd8e3eba7fdc4bea89ad6cb07bf4a7d.png\">\n<p>在现在主流的骨架屏实现效果中有两种方式：</p>\n<ul>\n<li><p>通过View或者Adapter的替换来实现骨架屏效果。可以参考<a href=\"https://github.com/sharish/ShimmerRecyclerView\">ShimmerRecyclerView</a>、<a href=\"https://github.com/ethanhua/Skeleton\">Skeleton</a>及<a href=\"https://github.com/willowtreeapps/spruce-android\">spruce-android</a>。</p>\n</li>\n<li><p>自定义一个View来对布局中的View进行一层包裹，当加载数据时则根据View来绘制骨架，否则显示正常UI，参考<a href=\"https://github.com/rasoulmiri/Skeleton\">Skeleton Android</a>。</p>\n</li>\n</ul>\n<p>这些开源库中，自己比较喜欢今天<strong>Skeleton</strong>这个开源库，总结了有如下一些优缺点：</p>\n<p><strong>优点：</strong></p>\n<ol>\n<li>代码方案实现及使用方式简单，通过替换View和Adapter实现效果，使用Builder设计模式来构造。</li>\n<li>代码耦合程度不高。没有复杂的设计模式，使得代码结构清晰明了。</li>\n<li>骨架屏的效果使用相对于较灵活，可以对整个布局实现骨架屏效果，也可以对单一View实现骨架屏效果。</li>\n</ol>\n<p><strong>缺点：</strong></p>\n<ol>\n<li>需要对每个骨架屏效果单独写一套xml布局。</li>\n<li>使用的removeView和addView对 原有布局的view进行替换，存在一定的风险性</li>\n<li>必须清晰的知道所bind的View类型，存在一定的类型转化问题。</li>\n<li>依赖了shimmerlayout第三方库</li>\n</ol>\n<h2 id=\"2、Skeleton解读\"><a href=\"#2、Skeleton解读\" class=\"headerlink\" title=\"2、Skeleton解读\"></a>2、Skeleton解读</h2><p><strong>一、Skeleton的使用方式</strong></p>\n<p>展示骨架屏效果：<br><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">View</span> <span class=\"variable\">rootView</span> <span class=\"operator\">=</span> findViewById(R.id.rootView);</span><br><span class=\"line\">skeletonScreen = Skeleton.bind(rootView)</span><br><span class=\"line\">           .load(R.layout.activity_view_skeleton)<span class=\"comment\">//骨架屏UI</span></span><br><span class=\"line\">           .duration(<span class=\"number\">1000</span>)<span class=\"comment\">//动画时间，以毫秒为单位</span></span><br><span class=\"line\">           .shimmer(<span class=\"literal\">true</span>)<span class=\"comment\">//是否开启动画</span></span><br><span class=\"line\">           .color(R.color.shimmer_color)<span class=\"comment\">//shimmer的颜色</span></span><br><span class=\"line\">           .angle(<span class=\"number\">30</span>)<span class=\"comment\">//shimmer的倾斜角度</span></span><br><span class=\"line\">           .show();</span><br></pre></td></tr></table></figure><br>关闭骨架屏效果并展示原有View：<br><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">skeletonScreen.hide()</span><br></pre></td></tr></table></figure></p>\n<p><strong>流程：</strong></p>\n<p> **1. 选择需要替换的目标view</p>\n<ol>\n<li>将骨架效果xml与目标view进行绑定</li>\n<li>添加一些效果属性，比如：动画时间、是否开启展示动画、动画颜色等</li>\n<li>在合适的实际关闭骨架屏效果**</li>\n</ol>\n<p><strong>二、Skeleton源码实现</strong></p>\n<p>Skeleton提供两个绑定方法，分别绑定普通View与RecyclerView，分别返回对应的Builder<br><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Skeleton</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> RecyclerViewSkeletonScreen.Builder <span class=\"title function_\">bind</span><span class=\"params\">(RecyclerView recyclerView)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">RecyclerViewSkeletonScreen</span>.Builder(recyclerView);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> ViewSkeletonScreen.Builder <span class=\"title function_\">bind</span><span class=\"params\">(View view)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ViewSkeletonScreen</span>.Builder(view);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>我们首先来看看如何实现与普通View绑定，构造方法中传入目标View，并对shimmer动画效果设置默认的颜色，在Builder里面我们可以看到各种相关参数的设定。<br><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"title function_\">Builder</span><span class=\"params\">(View view)</span> &#123;</span><br><span class=\"line\">\t<span class=\"built_in\">this</span>.mView = view;</span><br><span class=\"line\">\t<span class=\"built_in\">this</span>.mShimmerColor = ContextCompat.getColor(mView.getContext(), R.color.shimmer_color);</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure><br>接下来再到show的步骤，主要实现还是由ViewSkeletonScreen来实现<br><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> ViewSkeletonScreen <span class=\"title function_\">show</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">ViewSkeletonScreen</span> <span class=\"variable\">skeletonScreen</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ViewSkeletonScreen</span>(<span class=\"built_in\">this</span>);</span><br><span class=\"line\">    skeletonScreen.show();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> skeletonScreen;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>其中ViewSkeletonScreen与绑定的RecyclerViewSkeletonScreen都实现了SkeletonScreen接口，SkeletonScreen有两个接口方法分别是   </p>\n<pre><code>void show();\nvoid hide();\n</code></pre><p>对于ViewSkeletonScreen.show()进入源码，这里出现一个比较重要的类<code>ViewReplacer</code>，等下再进行解析，通过show的源码清楚的知道逻辑：<br><strong>1、生成骨架效果View<br>2、利用生成的View替换目标View。</strong><br>其中生成骨架效果View阶段主要还是通过LayoutInflater去加载传入mSkeletonResID</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">show</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">       <span class=\"type\">View</span> <span class=\"variable\">skeletonLoadingView</span> <span class=\"operator\">=</span> generateSkeletonLoadingView();</span><br><span class=\"line\">       <span class=\"keyword\">if</span> (skeletonLoadingView != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">           mViewReplacer.replace(skeletonLoadingView);</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n<p>接下来主要讲解ViewReplacer类，其构造方法传入目标View</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"title function_\">ViewReplacer</span><span class=\"params\">(View sourceView)</span> &#123;</span><br><span class=\"line\">     mSourceView = sourceView;</span><br><span class=\"line\">     mSourceViewLayoutParams = mSourceView.getLayoutParams();</span><br><span class=\"line\">     mCurrentView = mSourceView;</span><br><span class=\"line\">     mSourceViewId = mSourceView.getId();</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n<p>其比较重要的方法有两个：<code>replace()</code> 和 <code>restore()</code> 这两个方法分别为SkeletonScreen 的show()和hide()的最终实现，首先看<code>replace()</code>方法，有两个方法重载，分别传入<code>targetViewResID</code>或者<code>targetView</code>，最终还是会走到<code>replace(View targetView)</code>中。<br>其主要逻辑为：</p>\n<p> **1. 判断所替换的View和骨架屏效果View是否为同一个View</p>\n<ol>\n<li>remove掉在父布局中的目标View</li>\n<li>将骨架屏效果View添加到目标View的父布局中**</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">replace</span><span class=\"params\">(<span class=\"type\">int</span> targetViewResID)</span> &#123;</span><br><span class=\"line\">       <span class=\"keyword\">if</span> (mTargetViewResID == targetViewResID) &#123;</span><br><span class=\"line\">           <span class=\"keyword\">return</span>;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       <span class=\"keyword\">if</span> (init()) &#123;</span><br><span class=\"line\">           mTargetViewResID = targetViewResID;</span><br><span class=\"line\">           replace(LayoutInflater.from(mSourceView.getContext()).inflate(mTargetViewResID, mSourceParentView, <span class=\"literal\">false</span>));</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">replace</span><span class=\"params\">(View targetView)</span> &#123;</span><br><span class=\"line\">       <span class=\"keyword\">if</span> (mCurrentView == targetView) &#123;</span><br><span class=\"line\">           <span class=\"keyword\">return</span>;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       <span class=\"keyword\">if</span> (targetView.getParent() != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">           ((ViewGroup) targetView.getParent()).removeView(targetView);</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       <span class=\"keyword\">if</span> (init()) &#123;</span><br><span class=\"line\">           mTargetView = targetView;</span><br><span class=\"line\">           mSourceParentView.removeView(mCurrentView);</span><br><span class=\"line\">           mTargetView.setId(mSourceViewId);</span><br><span class=\"line\">           mSourceParentView.addView(mTargetView, mSourceViewIndexInParent, mSourceViewLayoutParams);</span><br><span class=\"line\">           mCurrentView = mTargetView;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n<p>在执行添加到目标View的父布局中，有执行一个init方法，主要做两件事：</p>\n<p> **1. 获取目标View的父View</p>\n<ol>\n<li>找到目标View在父View 中的位置索引，为之后添加骨架屏View到父View中做铺垫**</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"type\">boolean</span> <span class=\"title function_\">init</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">     <span class=\"keyword\">if</span> (mSourceParentView == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">         mSourceParentView = (ViewGroup) mSourceView.getParent();</span><br><span class=\"line\">         <span class=\"keyword\">if</span> (mSourceParentView == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">             Log.e(TAG, <span class=\"string\">&quot;the source view have not attach to any view&quot;</span>);</span><br><span class=\"line\">             <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">         <span class=\"type\">int</span> <span class=\"variable\">count</span> <span class=\"operator\">=</span> mSourceParentView.getChildCount();</span><br><span class=\"line\">         <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">index</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; index &lt; count; index++) &#123;</span><br><span class=\"line\">             <span class=\"keyword\">if</span> (mSourceView == mSourceParentView.getChildAt(index)) &#123;</span><br><span class=\"line\">                 mSourceViewIndexInParent = index;</span><br><span class=\"line\">                 <span class=\"keyword\">break</span>;</span><br><span class=\"line\">             &#125;</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">     <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n<p>至此对普通View的骨架屏效果实现流程已经完全梳理完成，那对于<code>RecyclerView</code>呢？其实两者实现逻辑差不多，主要有两个差异：</p>\n<ol>\n<li>在<code>RecyclerViewSkeletonScreen</code>的Builder中，相比ViewSkeletonScreen多了一个adapter()方法，传入目标<code>RecyclerView</code>的<code>Adapter</code></li>\n<li>在show的时候对目标<code>RecyclerView</code>的adapter进行替换，使用骨架屏效果的adapter。hide的时候恢复为原先的Adapter</li>\n</ol>\n<h2 id=\"3、总结\"><a href=\"#3、总结\" class=\"headerlink\" title=\"3、总结\"></a>3、总结</h2><ol>\n<li>Skeleton的原理主要是通过替换目标View和RecyclerView的Adapter</li>\n<li>在Skeleton的使用过程中最需要关心的两个问题是：show()和hide()的时机</li>\n<li>对于整个页面的骨架屏效果实现，个人推荐在布局中添加一个全屏的空View盖在原先内容上</li>\n<li>注意一些异常情况下的hide()，要不然整个页面就“假死”状态了。</li>\n</ol>\n<p>参考：<br><a href=\"https://juejin.im/post/5c789a4ce51d457c042d3b31\">https://juejin.im/post/5c789a4ce51d457c042d3b31</a></p>\n","categories":[{"name":"技术文章","slug":"technology","api":"api/categories/technology.json"}],"tags":[{"name":"Android","slug":"Android","api":"api/tags/Android.json"}],"api":"api/posts/2019/09/04/Android骨架屏效果的实现与原理解析.json"},{"title":"Android 插件化之ClassLoader","slug":"Android-插件化之ClassLoader","date":"2019-08-26T08:47:00.000Z","updated":"2025-05-20T11:46:57.000Z","comments":true,"url":"2019/08/26/Android-插件化之ClassLoader/","excerpt":"<p><strong>插件化要解决的三个核心问题：类加载、资源加载、组件生命周期管理。</strong></p>\n<p>在Android插件化中其原理实际是 Java ClassLoader的原理，此博文主要对Android插件化中类加载中的DexClassLoader做总结，便于之后对Android插件化的理解学习。</p>\n<p>Android的Dalvik虚拟机和Java虚拟机的运行原理相同都是将对应的java类加载在内存中运行。而Java虚拟机是加载class文件，也可以将一段二进制流通过defineClass方法生产Class进行加载。Dalvik虚拟机加载的dex文件。dex文件是Android对与Class文件做的优化，以便于提高手机的性能。可以想象dex为class文件的一个压缩文件。dex在Android中的加载和class在jvm中的相同都是基于双亲委派模型，都是调用ClassLoader的loadClass方法加载类。</p>\n<h2 id=\"1、DexClassLoader和PathClassLoader区别\"><a href=\"#1、DexClassLoader和PathClassLoader区别\" class=\"headerlink\" title=\"1、DexClassLoader和PathClassLoader区别\"></a><strong>1、DexClassLoader和PathClassLoader区别</strong></h2><p>Android 也有自己的 ClassLoader，分为 <code>DexClassLoader</code>和<code>PathClassLoader</code>，这两者有什么区别和关联呢？</p>\n<p>阅读源码可以看到两者的构造方法分别为：</p>\n<pre><code>public class PathClassLoader extends BaseDexClassLoader &#123;\n    public PathClassLoader(String dexPath, ClassLoader parent) &#123;\n        super(dexPath, null, null, parent);\n    &#125;\n    public PathClassLoader(String dexPath, String libraryPath,\n            ClassLoader parent) &#123;\n        super(dexPath, null, libraryPath, parent);\n    &#125;\n&#125;\n\npublic class DexClassLoader extends BaseDexClassLoader &#123;\n    public DexClassLoader(String dexPath, String optimizedDirectory,\n            String libraryPath, ClassLoader parent) &#123;\n        super(dexPath, new File(optimizedDirectory), libraryPath, parent);\n    &#125;\n&#125;\n</code></pre><p>可以发现<code>DexClassLoader</code> 比 <code>PathClassLoader</code> 多一个参数<code>String optimizedDirectory</code>，那这个参数具体做什么的呢？继续查看源码我们可以知道<code>optimizedDirectory</code>是用来缓存我们需要加载的dex文件的，并创建一个<code>DexFile</code>对象，如果它为null，那么会直接使用dex文件原有的路径来创建DexFile 对象，其具体体现在如下代码区域：</p>\n<pre><code>private static DexFile loadDexFile(File file, File optimizedDirectory)\n        throws IOException &#123;\n    if (optimizedDirectory == null) &#123;\n        return new DexFile(file);\n    &#125; else &#123;\n        String optimizedPath = optimizedPathFor(file, optimizedDirectory);\n        return DexFile.loadDex(file.getPath(), optimizedPath, 0);\n    &#125;\n&#125;\n</code></pre><p>因此两者区别在于 <code>PathClassLoader</code> 不能直接从 zip 包中得到 dex，因此只支持直接操作 dex 文件或者已经安装过的 apk。而 <code>DexClassLoader</code> 可以加载外部的 apk、jar 或 dex文件，并且会在指定的 outpath 路径存放其 dex 文件。所以在插件化中我们使用<code>DexClassLoader</code>来加载class的，接下来讲解<code>DexClassLoader</code>的用法。</p>\n<h2 id=\"2、DexClassLoader用法\"><a href=\"#2、DexClassLoader用法\" class=\"headerlink\" title=\"2、DexClassLoader用法\"></a><strong>2、DexClassLoader用法</strong></h2><p>其构造方法为：</p>\n<pre><code>DexClassLoader(\n    String dexPath, \n       String optimizedDirectory, \n    String librarySearchPath,\n     ClassLoader parent)\n</code></pre><p><code>dexPath</code>:被解压的apk路径，不能为空。<br><code>optimizedDirectory</code>：解压后的.dex文件的存储路径，不能为空。这个路径强烈建议使用应用程序的私有路径，不要放到sdcard上，否则代码容易被注入攻击。<br><code>libraryPath</code>：os库的存放路径，可以为空，若有os库，必须填写。<br><code>parent</code>：父亲加载器，一般为context.getClassLoader(),使用当前上下文的类加载器。</p>\n<p>接下来讲解具体使用流程：</p>\n<p>1、新建一个名为plugin的project，其中新建一个<code>Bean</code>类，只有一个方法<code>getName()</code>返回一个字符串“My App”，然后对plugin这个工程打包为apk，将apk放在主工程的asser目录中。</p>\n<img src=\"https://cdn.julis.wang/blog/img/20190827104738557.png\">\n<p>2、构造Classloader</p>\n<pre><code>  File extractFile = getFileStreamPath(&quot;app-debug.apk&quot;);\n  String dexPath = extractFile.getPath();\n  File fileRelease = getDir(&quot;dex&quot;, 0);\n  ClassLoader classLoader = new DexClassLoader(dexPath, fileRelease.getAbsolutePath(), null, getClassLoader());\n</code></pre><p>3、利用构造好的Classloader反射调用插件类中的方法</p>\n<pre><code>  Class mLoadClassBean;\n  try &#123;\n        mLoadClassBean = classLoader.loadClass(&quot;com.example.plugin.Bean&quot;);\n        Object beanObject = mLoadClassBean.newInstance();\n        Method getNameMethod = mLoadClassBean.getMethod(&quot;getName&quot;);\n        getNameMethod.setAccessible(true);\n        String name = (String) getNameMethod.invoke(beanObject);\n        Log.e(&quot;julis&quot;, name);\n    &#125; catch(Exception e) &#123;\n        e.printStackTrace();\n    &#125;\n</code></pre><p>成功打印出结果：</p>\n<img src=\"https://cdn.julis.wang/blog/img/20190827143354781.png\">\n<p>参考：</p>\n<p><a href=\"https://www.jianshu.com/p/4b4f1fa6633c\">https://www.jianshu.com/p/4b4f1fa6633c</a></p>\n<p><a href=\"https://www.jianshu.com/p/53aa2de20cf8\">https://www.jianshu.com/p/53aa2de20cf8</a></p>\n<p><a href=\"https://cloud.tencent.com/developer/article/1071815\">https://cloud.tencent.com/developer/article/1071815</a></p>\n","cover":null,"images":["https://cdn.julis.wang/blog/img/20190827104738557.png","https://cdn.julis.wang/blog/img/20190827143354781.png"],"content":"<p><strong>插件化要解决的三个核心问题：类加载、资源加载、组件生命周期管理。</strong></p>\n<p>在Android插件化中其原理实际是 Java ClassLoader的原理，此博文主要对Android插件化中类加载中的DexClassLoader做总结，便于之后对Android插件化的理解学习。</p>\n<p>Android的Dalvik虚拟机和Java虚拟机的运行原理相同都是将对应的java类加载在内存中运行。而Java虚拟机是加载class文件，也可以将一段二进制流通过defineClass方法生产Class进行加载。Dalvik虚拟机加载的dex文件。dex文件是Android对与Class文件做的优化，以便于提高手机的性能。可以想象dex为class文件的一个压缩文件。dex在Android中的加载和class在jvm中的相同都是基于双亲委派模型，都是调用ClassLoader的loadClass方法加载类。</p>\n<h2 id=\"1、DexClassLoader和PathClassLoader区别\"><a href=\"#1、DexClassLoader和PathClassLoader区别\" class=\"headerlink\" title=\"1、DexClassLoader和PathClassLoader区别\"></a><strong>1、DexClassLoader和PathClassLoader区别</strong></h2><p>Android 也有自己的 ClassLoader，分为 <code>DexClassLoader</code>和<code>PathClassLoader</code>，这两者有什么区别和关联呢？</p>\n<p>阅读源码可以看到两者的构造方法分别为：</p>\n<pre><code>public class PathClassLoader extends BaseDexClassLoader &#123;\n    public PathClassLoader(String dexPath, ClassLoader parent) &#123;\n        super(dexPath, null, null, parent);\n    &#125;\n    public PathClassLoader(String dexPath, String libraryPath,\n            ClassLoader parent) &#123;\n        super(dexPath, null, libraryPath, parent);\n    &#125;\n&#125;\n\npublic class DexClassLoader extends BaseDexClassLoader &#123;\n    public DexClassLoader(String dexPath, String optimizedDirectory,\n            String libraryPath, ClassLoader parent) &#123;\n        super(dexPath, new File(optimizedDirectory), libraryPath, parent);\n    &#125;\n&#125;\n</code></pre><p>可以发现<code>DexClassLoader</code> 比 <code>PathClassLoader</code> 多一个参数<code>String optimizedDirectory</code>，那这个参数具体做什么的呢？继续查看源码我们可以知道<code>optimizedDirectory</code>是用来缓存我们需要加载的dex文件的，并创建一个<code>DexFile</code>对象，如果它为null，那么会直接使用dex文件原有的路径来创建DexFile 对象，其具体体现在如下代码区域：</p>\n<pre><code>private static DexFile loadDexFile(File file, File optimizedDirectory)\n        throws IOException &#123;\n    if (optimizedDirectory == null) &#123;\n        return new DexFile(file);\n    &#125; else &#123;\n        String optimizedPath = optimizedPathFor(file, optimizedDirectory);\n        return DexFile.loadDex(file.getPath(), optimizedPath, 0);\n    &#125;\n&#125;\n</code></pre><p>因此两者区别在于 <code>PathClassLoader</code> 不能直接从 zip 包中得到 dex，因此只支持直接操作 dex 文件或者已经安装过的 apk。而 <code>DexClassLoader</code> 可以加载外部的 apk、jar 或 dex文件，并且会在指定的 outpath 路径存放其 dex 文件。所以在插件化中我们使用<code>DexClassLoader</code>来加载class的，接下来讲解<code>DexClassLoader</code>的用法。</p>\n<h2 id=\"2、DexClassLoader用法\"><a href=\"#2、DexClassLoader用法\" class=\"headerlink\" title=\"2、DexClassLoader用法\"></a><strong>2、DexClassLoader用法</strong></h2><p>其构造方法为：</p>\n<pre><code>DexClassLoader(\n    String dexPath, \n       String optimizedDirectory, \n    String librarySearchPath,\n     ClassLoader parent)\n</code></pre><p><code>dexPath</code>:被解压的apk路径，不能为空。<br><code>optimizedDirectory</code>：解压后的.dex文件的存储路径，不能为空。这个路径强烈建议使用应用程序的私有路径，不要放到sdcard上，否则代码容易被注入攻击。<br><code>libraryPath</code>：os库的存放路径，可以为空，若有os库，必须填写。<br><code>parent</code>：父亲加载器，一般为context.getClassLoader(),使用当前上下文的类加载器。</p>\n<p>接下来讲解具体使用流程：</p>\n<p>1、新建一个名为plugin的project，其中新建一个<code>Bean</code>类，只有一个方法<code>getName()</code>返回一个字符串“My App”，然后对plugin这个工程打包为apk，将apk放在主工程的asser目录中。</p>\n<img src=\"https://cdn.julis.wang/blog/img/20190827104738557.png\">\n<p>2、构造Classloader</p>\n<pre><code>  File extractFile = getFileStreamPath(&quot;app-debug.apk&quot;);\n  String dexPath = extractFile.getPath();\n  File fileRelease = getDir(&quot;dex&quot;, 0);\n  ClassLoader classLoader = new DexClassLoader(dexPath, fileRelease.getAbsolutePath(), null, getClassLoader());\n</code></pre><p>3、利用构造好的Classloader反射调用插件类中的方法</p>\n<pre><code>  Class mLoadClassBean;\n  try &#123;\n        mLoadClassBean = classLoader.loadClass(&quot;com.example.plugin.Bean&quot;);\n        Object beanObject = mLoadClassBean.newInstance();\n        Method getNameMethod = mLoadClassBean.getMethod(&quot;getName&quot;);\n        getNameMethod.setAccessible(true);\n        String name = (String) getNameMethod.invoke(beanObject);\n        Log.e(&quot;julis&quot;, name);\n    &#125; catch(Exception e) &#123;\n        e.printStackTrace();\n    &#125;\n</code></pre><p>成功打印出结果：</p>\n<img src=\"https://cdn.julis.wang/blog/img/20190827143354781.png\">\n<p>参考：</p>\n<p><a href=\"https://www.jianshu.com/p/4b4f1fa6633c\">https://www.jianshu.com/p/4b4f1fa6633c</a></p>\n<p><a href=\"https://www.jianshu.com/p/53aa2de20cf8\">https://www.jianshu.com/p/53aa2de20cf8</a></p>\n<p><a href=\"https://cloud.tencent.com/developer/article/1071815\">https://cloud.tencent.com/developer/article/1071815</a></p>\n","categories":[{"name":"技术文章","slug":"technology","api":"api/categories/technology.json"}],"tags":[{"name":"插件化","slug":"plugins","api":"api/tags/plugins.json"}],"api":"api/posts/2019/08/26/Android-插件化之ClassLoader.json"},{"title":"忙碌中求生活-记录23岁生日","slug":"★省★忙碌中求生活","date":"2019-07-13T11:36:00.000Z","updated":"2025-05-20T11:46:57.000Z","comments":true,"url":"2019/07/13/★省★忙碌中求生活/","excerpt":"<p>此时周六晚七点半，刚吃了一碗自己做的番茄鸡蛋面，将浸泡了很久的银耳原料装入了电饭煲内，静待熟时。回到自己的房间，窗外不断传来来往的车轱辘声，好像在告诉我他们很忙吧。看到书桌上的日历，还沉浸在六月份，我可能也很忙吧，都忘记将它带入七月份。</p>\n<p>来杭州一年有余，从一名大三学生暑假实习，到大四学生实习，再到应届毕业生签订转正合同，从而成为一名正式的“社会人儿”。时间过得真的很快吧，一周周一下子就没有了。进入了七月份，明显感觉比之前更忙了，或者说是因为自己身份的转变，导致肩上的责任变得不太一样了吧。因为工作节奏的改变，有时候也变得有些麻木吧，日记有时候总会忘记写，写字这件事感觉也变得有些奢侈起来，日语学习的节奏好像变得慢了起来。但是时间的脚步并不因为你的忙碌而停下来。</p>\n<p>我最近在读《时间简史》，讲述了从认知革命到农业革命再到人类文化的融合统一再到科学革命，作者用通俗的话语讲完了整个人类历史，真的很值得阅读。其中有一章节引发了我的思考，作者认为：农业革命是史上最大的骗局。因为在长达250万里里人类都靠狩猎或者采集果实为生，而到大约一万年前全然改变，从日升到日落，人类忙着对植物的培育，一心认为这样就能得到更多的水果、谷物和肉类，使得人类生活能够变得更加容易。然而事实上是人变得越来越辛苦。人类每次决定多做一点事情（比如用锄头来耕地，而不是直接将种子撒在地里面），我们认为这样没错，这样会使我们的收成更好一点，有了更好的收成，就不用更多地去担心荒年的问题了，不用挨饿了。工作努力一点，生活也能过得好一点。不过这都是理想的状态。</p>\n<p>人们确实工作得更努力也更辛苦，但没想到大家的孩子也更多了，人口慢慢地增加了，所得到的食物也就变得少了，生存压力也就更大了，资源也开始变得稀缺，而引发各种低问题。可是为什么他们不赶快放弃农耕回到原始的采集社会？原因在于，所有的改变都是必须点滴积累，经过许多代，才能改变社会，等到那个时候，已经没有人记得过去的生活方式和现在有什么不一样了，也没得选了。采用了农耕生活，村落的人口从100人到了110人，难道会有10个人自愿挨饿，好让其他人回到过去的美好时光？但这已经无法回头。于是人类付出了更多，但得到的却变得没有以前那样多。</p>\n<p>我们都各自为生活变得轻松而努力，但是事实上我们过得并不轻松。人的欲望永远也满足不了，今天拥有了这个，明天还想拥有更好的。现在，我们随手可以发送一条信息，传到地球另一方，而他立马能够回你。我们确实省下了很多时间和麻烦，但生活真的更轻松了么？我们以为省了时间，然而我们其实是把生活的步调调成了过去的10倍，于是我们整天忙忙碌碌、焦躁不安。</p>\n<p>这是原书作者对农业革命是史上最大的骗局的论证吧，我再赞同不过了。每每与我的爸妈打电话，我都会有很大的感触，他们总是在忙碌，他们每天都在拼命的挣钱，可是日子真的好起来了么？生活真的轻松了么？不久前，在家族微信群里面，我妈拍了一张我爸的照片放在群里，我爸双手背后，露出一脸笑意，背景好像是他们住那里的一个普通的建筑吧。想表现出: 你看我和你妈在玩，我们多开心啊。 当我看到这张照片的时候，我心里五谷杂粮。</p>\n<p>一方面是 我看到我爸的头发，愈发的白了，白了大多半了。记得上一次有这感触的时候，还是我大二的时候，那次我从学校回家，他到车站来接我，我坐他后面，我发现他的白头已经有很多很多了，那时我差点哭了出来。爸妈真的老了，可我还没有给他们带来好的生活，我曾告诉他们说：等我实习你们就回家吧，不要工作了，我能养活我自己，以后也能养活你们。可是他们并不，他们还是在工作，烈日下，每每打电话跟我说太阳是有多么多大温度是有多么高，我心里都很难受。可是他们总会说一句话：“这都是为了你以后更轻松一点”。此时我却不知道该说些什么。</p>\n<p>另一方面是 我看着我妈拍的那张照片，真的很糊，不是我妈不会拍照，也不是她眼神不好，真的是她的手机像素不好。我的爸妈，辛苦了大半辈子，其实也有很多积蓄了，虽然没有大城市里的那样多，但在老家里也算是稍微有一些钱的，可是他们却舍不得给自己多花一分钱，能将就用则用。每次电话，我都给他们讲让他们对自己好一点，我说 你们到底挣钱是为了做什么？给他们讲了很多道理，可是他们也总是会一句：“这都是为了你以后更轻松一点”。而我也只能强忍着，因为我现在还没有足够的能力，心里暗暗发誓：我会让他们过上轻松地日子。</p>\n<p>我其实一直都在思考一个问题：人到底活在这个世界上是为了什么？科学家无法解释，这是一个哲学问题，没有人知道正确的答案。我们只是沧海中的一粟，如果掀不起波浪，那么就好好感受海的浩瀚吧。忙忙碌碌，短视频以及直播的崛起，可能真的是因为都市生活节奏变得太快，于是都在夹缝中去寻找那一丝丝快感，其实可以做的很多吧，摘自网上“试着每天自己为自己做美味的饭菜，试着经常联络一下家人好友，试着拾起丢下很久的小说，试着用心养一颗植物，试着在空气清新的清晨去跑步，试着约一下自己暗恋已久的女孩…”。看看足球比赛，看看电影，多出去走走，再忙也不要忘记生活吧。</p>\n<p>快九点了，删删写写，也不道该放一些什么在日志上，那就这样吧。<br>祝自己二十三岁生日快乐 </p>\n<p>记录两张此时自己二十三岁的照片，没出门没刮胡子没收拾，一张沧桑一张微笑，生活亦如此吧。</p>\n<p>xxx.jpg</p>\n<p>——二零一九年六月十一</p>\n","cover":null,"images":[],"content":"<p>此时周六晚七点半，刚吃了一碗自己做的番茄鸡蛋面，将浸泡了很久的银耳原料装入了电饭煲内，静待熟时。回到自己的房间，窗外不断传来来往的车轱辘声，好像在告诉我他们很忙吧。看到书桌上的日历，还沉浸在六月份，我可能也很忙吧，都忘记将它带入七月份。</p>\n<p>来杭州一年有余，从一名大三学生暑假实习，到大四学生实习，再到应届毕业生签订转正合同，从而成为一名正式的“社会人儿”。时间过得真的很快吧，一周周一下子就没有了。进入了七月份，明显感觉比之前更忙了，或者说是因为自己身份的转变，导致肩上的责任变得不太一样了吧。因为工作节奏的改变，有时候也变得有些麻木吧，日记有时候总会忘记写，写字这件事感觉也变得有些奢侈起来，日语学习的节奏好像变得慢了起来。但是时间的脚步并不因为你的忙碌而停下来。</p>\n<p>我最近在读《时间简史》，讲述了从认知革命到农业革命再到人类文化的融合统一再到科学革命，作者用通俗的话语讲完了整个人类历史，真的很值得阅读。其中有一章节引发了我的思考，作者认为：农业革命是史上最大的骗局。因为在长达250万里里人类都靠狩猎或者采集果实为生，而到大约一万年前全然改变，从日升到日落，人类忙着对植物的培育，一心认为这样就能得到更多的水果、谷物和肉类，使得人类生活能够变得更加容易。然而事实上是人变得越来越辛苦。人类每次决定多做一点事情（比如用锄头来耕地，而不是直接将种子撒在地里面），我们认为这样没错，这样会使我们的收成更好一点，有了更好的收成，就不用更多地去担心荒年的问题了，不用挨饿了。工作努力一点，生活也能过得好一点。不过这都是理想的状态。</p>\n<p>人们确实工作得更努力也更辛苦，但没想到大家的孩子也更多了，人口慢慢地增加了，所得到的食物也就变得少了，生存压力也就更大了，资源也开始变得稀缺，而引发各种低问题。可是为什么他们不赶快放弃农耕回到原始的采集社会？原因在于，所有的改变都是必须点滴积累，经过许多代，才能改变社会，等到那个时候，已经没有人记得过去的生活方式和现在有什么不一样了，也没得选了。采用了农耕生活，村落的人口从100人到了110人，难道会有10个人自愿挨饿，好让其他人回到过去的美好时光？但这已经无法回头。于是人类付出了更多，但得到的却变得没有以前那样多。</p>\n<p>我们都各自为生活变得轻松而努力，但是事实上我们过得并不轻松。人的欲望永远也满足不了，今天拥有了这个，明天还想拥有更好的。现在，我们随手可以发送一条信息，传到地球另一方，而他立马能够回你。我们确实省下了很多时间和麻烦，但生活真的更轻松了么？我们以为省了时间，然而我们其实是把生活的步调调成了过去的10倍，于是我们整天忙忙碌碌、焦躁不安。</p>\n<p>这是原书作者对农业革命是史上最大的骗局的论证吧，我再赞同不过了。每每与我的爸妈打电话，我都会有很大的感触，他们总是在忙碌，他们每天都在拼命的挣钱，可是日子真的好起来了么？生活真的轻松了么？不久前，在家族微信群里面，我妈拍了一张我爸的照片放在群里，我爸双手背后，露出一脸笑意，背景好像是他们住那里的一个普通的建筑吧。想表现出: 你看我和你妈在玩，我们多开心啊。 当我看到这张照片的时候，我心里五谷杂粮。</p>\n<p>一方面是 我看到我爸的头发，愈发的白了，白了大多半了。记得上一次有这感触的时候，还是我大二的时候，那次我从学校回家，他到车站来接我，我坐他后面，我发现他的白头已经有很多很多了，那时我差点哭了出来。爸妈真的老了，可我还没有给他们带来好的生活，我曾告诉他们说：等我实习你们就回家吧，不要工作了，我能养活我自己，以后也能养活你们。可是他们并不，他们还是在工作，烈日下，每每打电话跟我说太阳是有多么多大温度是有多么高，我心里都很难受。可是他们总会说一句话：“这都是为了你以后更轻松一点”。此时我却不知道该说些什么。</p>\n<p>另一方面是 我看着我妈拍的那张照片，真的很糊，不是我妈不会拍照，也不是她眼神不好，真的是她的手机像素不好。我的爸妈，辛苦了大半辈子，其实也有很多积蓄了，虽然没有大城市里的那样多，但在老家里也算是稍微有一些钱的，可是他们却舍不得给自己多花一分钱，能将就用则用。每次电话，我都给他们讲让他们对自己好一点，我说 你们到底挣钱是为了做什么？给他们讲了很多道理，可是他们也总是会一句：“这都是为了你以后更轻松一点”。而我也只能强忍着，因为我现在还没有足够的能力，心里暗暗发誓：我会让他们过上轻松地日子。</p>\n<p>我其实一直都在思考一个问题：人到底活在这个世界上是为了什么？科学家无法解释，这是一个哲学问题，没有人知道正确的答案。我们只是沧海中的一粟，如果掀不起波浪，那么就好好感受海的浩瀚吧。忙忙碌碌，短视频以及直播的崛起，可能真的是因为都市生活节奏变得太快，于是都在夹缝中去寻找那一丝丝快感，其实可以做的很多吧，摘自网上“试着每天自己为自己做美味的饭菜，试着经常联络一下家人好友，试着拾起丢下很久的小说，试着用心养一颗植物，试着在空气清新的清晨去跑步，试着约一下自己暗恋已久的女孩…”。看看足球比赛，看看电影，多出去走走，再忙也不要忘记生活吧。</p>\n<p>快九点了，删删写写，也不道该放一些什么在日志上，那就这样吧。<br>祝自己二十三岁生日快乐 </p>\n<p>记录两张此时自己二十三岁的照片，没出门没刮胡子没收拾，一张沧桑一张微笑，生活亦如此吧。</p>\n<p>xxx.jpg</p>\n<p>——二零一九年六月十一</p>\n","categories":[{"name":"生活感想","slug":"life","api":"api/categories/life.json"}],"tags":[{"name":"生活","slug":"life","api":"api/tags/life.json"}],"api":"api/posts/2019/07/13/★省★忙碌中求生活.json"},{"title":"单例模式的设计","slug":"单例模式的设计","date":"2019-07-09T01:56:00.000Z","updated":"2025-05-20T11:46:57.000Z","comments":true,"url":"2019/07/09/单例模式的设计/","excerpt":"<p>原文回答于知乎(<a href=\"https://www.zhihu.com/question/277243683/answer/392772061\">如何把一段简单的代码变复杂？ - 落叶挽歌的回答</a>)</p>\n<p>我们都知道单例模式很简单，大概是这样：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//单线程单例模式实现</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Singleton</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Singleton instance=<span class=\"literal\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Singleton <span class=\"title function_\">getInstance</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(<span class=\"literal\">null</span>==instance)&#123;</span><br><span class=\"line\">            instance = <span class=\"keyword\">new</span> <span class=\"title class_\">Singleton</span>();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>但是呢，在多线程条件下getInstance()并不是一个原子操作。由于代码没有使用任何同步机制，因此该线程可能会出现线程交错的情形：在instance还是null的时候，如果两个线程同时执行到 if(null==instance)那么会创建两个实例，从而违背了初衷。于是通过简单加锁来解决这种问题：<br><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//简单加锁实现单例模式</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Singleton</span>  &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Singleton instance=<span class=\"literal\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Singleton <span class=\"title function_\">getInstance</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span> (Singleton.class)&#123;<span class=\"comment\">//加入synchronized同步</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(<span class=\"literal\">null</span>==instance)&#123;</span><br><span class=\"line\">                instance = <span class=\"keyword\">new</span> <span class=\"title class_\">Singleton</span>();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>这种方式实现单例模式固然安全，但意味着每次调用 getInstance()都会申请锁，为了避免开销，我们想到了另一种办法：<br><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//基于双重检查锁定的错误单例模式实现</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Singleton</span>  &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Singleton instance=<span class=\"literal\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Singleton <span class=\"title function_\">getInstance</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(<span class=\"literal\">null</span>==instance)&#123;<span class=\"comment\">//先检查是否为null，再执行之上的代码</span></span><br><span class=\"line\">            <span class=\"keyword\">synchronized</span> (Singleton.class)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(<span class=\"literal\">null</span>==instance)&#123;</span><br><span class=\"line\">                    instance = <span class=\"keyword\">new</span> <span class=\"title class_\">Singleton</span>();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>通过这种方法，虽然第一次检查对变量instance的访问没有加锁从而使竞态仍然可能存在，它似乎避免了锁的开销又保障了线程的安全。然后对 instance = new Singleton();进行伪代码独立子操作：<br><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">obj=allocate(Singleton.class);<span class=\"comment\">//1、分配对象所需的存储空间</span></span><br><span class=\"line\">invokeConstructor(obj);<span class=\"comment\">//2、初始化obj的引用对象</span></span><br><span class=\"line\">instance=obj;<span class=\"comment\">//3、将对象引用写入共享变量</span></span><br></pre></td></tr></table></figure><br>由于重排序的规则，临界区内的操作可以再临界区内重排序，因此JIT编译器可能将上述子操作重排序为：1-&gt;3-&gt;2，即在初始化对象之前将对象引用写入实例变量instace。由于锁对有序性的保障是有条件的，而操作1读取intance变量的时候并没有加锁，因此重排序是对1操作是有影响的：该线程可能看到一个未初始化（或者为初始化完毕）的实例，即intance不为null。于是该线程直接就直接返回这个instance变量所引用的实例，而实例可能是未初始化完毕的，这就是可能导致程序出错。明白问题的原因之后，解决方法也不难想到了：<strong>只需将instance变量加入volatile修饰则可</strong>。于是代码变成：<br><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//基于双重检查锁定的正确单例模式实现</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Singleton</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">volatile</span> Singleton instance=<span class=\"literal\">null</span>;<span class=\"comment\">//加入volatile修饰</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Singleton <span class=\"title function_\">getInstance</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(<span class=\"literal\">null</span>==instance)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">synchronized</span> (Singleton.class)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(<span class=\"literal\">null</span>==instance)&#123;</span><br><span class=\"line\">                    instance = <span class=\"keyword\">new</span> <span class=\"title class_\">Singleton</span>();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>到此为止，才正确实现安全的“单例模式”。</p>\n<p>参考：《黄文海-Java多线程编程实战指南（核心篇）》</p>\n","cover":null,"images":[],"content":"<p>原文回答于知乎(<a href=\"https://www.zhihu.com/question/277243683/answer/392772061\">如何把一段简单的代码变复杂？ - 落叶挽歌的回答</a>)</p>\n<p>我们都知道单例模式很简单，大概是这样：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//单线程单例模式实现</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Singleton</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Singleton instance=<span class=\"literal\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Singleton <span class=\"title function_\">getInstance</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(<span class=\"literal\">null</span>==instance)&#123;</span><br><span class=\"line\">            instance = <span class=\"keyword\">new</span> <span class=\"title class_\">Singleton</span>();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>但是呢，在多线程条件下getInstance()并不是一个原子操作。由于代码没有使用任何同步机制，因此该线程可能会出现线程交错的情形：在instance还是null的时候，如果两个线程同时执行到 if(null==instance)那么会创建两个实例，从而违背了初衷。于是通过简单加锁来解决这种问题：<br><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//简单加锁实现单例模式</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Singleton</span>  &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Singleton instance=<span class=\"literal\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Singleton <span class=\"title function_\">getInstance</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span> (Singleton.class)&#123;<span class=\"comment\">//加入synchronized同步</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(<span class=\"literal\">null</span>==instance)&#123;</span><br><span class=\"line\">                instance = <span class=\"keyword\">new</span> <span class=\"title class_\">Singleton</span>();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>这种方式实现单例模式固然安全，但意味着每次调用 getInstance()都会申请锁，为了避免开销，我们想到了另一种办法：<br><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//基于双重检查锁定的错误单例模式实现</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Singleton</span>  &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Singleton instance=<span class=\"literal\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Singleton <span class=\"title function_\">getInstance</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(<span class=\"literal\">null</span>==instance)&#123;<span class=\"comment\">//先检查是否为null，再执行之上的代码</span></span><br><span class=\"line\">            <span class=\"keyword\">synchronized</span> (Singleton.class)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(<span class=\"literal\">null</span>==instance)&#123;</span><br><span class=\"line\">                    instance = <span class=\"keyword\">new</span> <span class=\"title class_\">Singleton</span>();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>通过这种方法，虽然第一次检查对变量instance的访问没有加锁从而使竞态仍然可能存在，它似乎避免了锁的开销又保障了线程的安全。然后对 instance = new Singleton();进行伪代码独立子操作：<br><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">obj=allocate(Singleton.class);<span class=\"comment\">//1、分配对象所需的存储空间</span></span><br><span class=\"line\">invokeConstructor(obj);<span class=\"comment\">//2、初始化obj的引用对象</span></span><br><span class=\"line\">instance=obj;<span class=\"comment\">//3、将对象引用写入共享变量</span></span><br></pre></td></tr></table></figure><br>由于重排序的规则，临界区内的操作可以再临界区内重排序，因此JIT编译器可能将上述子操作重排序为：1-&gt;3-&gt;2，即在初始化对象之前将对象引用写入实例变量instace。由于锁对有序性的保障是有条件的，而操作1读取intance变量的时候并没有加锁，因此重排序是对1操作是有影响的：该线程可能看到一个未初始化（或者为初始化完毕）的实例，即intance不为null。于是该线程直接就直接返回这个instance变量所引用的实例，而实例可能是未初始化完毕的，这就是可能导致程序出错。明白问题的原因之后，解决方法也不难想到了：<strong>只需将instance变量加入volatile修饰则可</strong>。于是代码变成：<br><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//基于双重检查锁定的正确单例模式实现</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Singleton</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">volatile</span> Singleton instance=<span class=\"literal\">null</span>;<span class=\"comment\">//加入volatile修饰</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Singleton <span class=\"title function_\">getInstance</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(<span class=\"literal\">null</span>==instance)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">synchronized</span> (Singleton.class)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(<span class=\"literal\">null</span>==instance)&#123;</span><br><span class=\"line\">                    instance = <span class=\"keyword\">new</span> <span class=\"title class_\">Singleton</span>();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>到此为止，才正确实现安全的“单例模式”。</p>\n<p>参考：《黄文海-Java多线程编程实战指南（核心篇）》</p>\n","categories":[{"name":"技术文章","slug":"technology","api":"api/categories/technology.json"}],"tags":[{"name":"设计模式","slug":"design","api":"api/tags/design.json"}],"api":"api/posts/2019/07/09/单例模式的设计.json"}],"info":{"type":"index"}},"api":"api/posts/page.6.json"}