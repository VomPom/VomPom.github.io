{"data":{"index":1,"total":8,"posts":[{"title":"手写一个精简版Koin：深入理解依赖注入核心原理","slug":"Koin-源码理解相关","date":"2025-08-25T13:08:00.000Z","updated":"2025-08-25T13:44:34.603Z","comments":true,"url":"2025/08/25/Koin-源码理解相关/","excerpt":"<p>在现代 Android 应用开发中，依赖注入（Dependency Injection, DI）已成为构建松耦合、可测试代码的重要技术。Koin 作为一个轻量级的Kotlin依赖注入框架，因其简洁的DSL和易用性深受开发者喜爱。最近对其源码进行学习了解，通过手写一个极度精简的 Koin 核心代码，来透彻理解Koin的注册、解析和参数传递机制。</p>\n<blockquote>\n<p><strong>本文代码基于 Koin 源码思想实现，仅用于学习核心原理，并非 Koin官 方代码。</strong></p>\n</blockquote>\n<h2 id=\"核心概念与项目结构\"><a href=\"#核心概念与项目结构\" class=\"headerlink\" title=\"核心概念与项目结构\"></a>核心概念与项目结构</h2><p>下图是基于 koin 4.1 解析的 主要类UML图，可以比较清晰地看看各个类之间的关系</p>\n<img src=\"https://cdn.julis.wang/blog/img/koin_uml.png\"> \n<p>power by <a href=\"https://www.mermaidchart.com/\">mermaidchart</a></p>\n<p>主要类：</p>\n<ul>\n<li><strong><code>KoinApplication</code></strong>: Koin启动的入口，负责初始化容器和加载模块。</li>\n<li><strong><code>Koin</code></strong>: 核心容器，持有实例注册表 InstanceRegistry 和作用域注册表 ScopeRegistry。</li>\n<li><strong><code>Module</code></strong>: 定义依赖的地方，存放了所有的 bean 定义 BeanDefinition 与 InstanceFactory。</li>\n<li><strong><code>BeanDefinition</code></strong>: 对一个依赖项的定义，包括其类型、限定符、所属作用域以及创建它的 lambda 表达式。</li>\n<li><strong><code>InstanceFactory</code></strong>: 负责根据 <code>BeanDefinition</code> 创建实例的核心工厂，分为 <code>SingleFactory</code> (单例)、<code>FactoryFactory</code> (工厂模式) 和 <code>ScopeFactory</code> (作用域内单例)。</li>\n<li><strong><code>Scope</code></strong>: 作用域，用于管理特定生命周期内的实例。</li>\n<li><strong><code>ParametersHolder</code></strong>: 参数容器，用于在获取实例时动态传递参数。</li>\n</ul>\n<h2 id=\"手写-koin-代码介绍\"><a href=\"#手写-koin-代码介绍\" class=\"headerlink\" title=\"手写 koin 代码介绍\"></a>手写 koin 代码介绍</h2><p>基于对源码的理解和参考，实现了 koin 的基本功能，整体分成三部分：简单 single 数据存取、包含 scope 能力、动态参数能力，分成三个文件夹，顺序123是基于前面带代码累加的。</p>\n<p><strong>简单 single 数据存取</strong><br>代码实现在：<a href=\"https://github.com/VomPom/JProject/blob/master/app/src/main/java/wang/julis/jproject/example/source/koin/noScope1/KoinWithoutScope.kt\">KoinWithoutScope.kt</a></p>\n<p>这是一份最简单的代码，大概200行不到，基本上包含了 koin 的核心思想：启动时注册组件定义。解析时，先查作用域缓存，命中则直接返回。未命中则递归解析其依赖项，调用工厂函数创建实例，最后返回实例。</p>\n<p>从这也能看出来 koin 的缺点：Koin 启动时 (startKoin) 需要将所有模块的定义 (BeanDefinition) 注册到容器中。实例数量过多会显著增加启动注册过程的耗时，影响应用启动速度。由于每个实例都会对应一个 BeanDefinition 以及 Factory ，内存占用会相应地上升。</p>\n<p>整个流程简单来讲就是生成一个 map，通过 key 获取对于的数据。</p>\n<p><strong>Scope 能力</strong><br>代码实现在：<a href=\"https://github.com/VomPom/JProject/blob/master/app/src/main/java/wang/julis/jproject/example/source/koin/scope2/KoinWithScope.kt\">KoinWithScope.kt</a></p>\n<p>这一份是在之前的能力上进行添加，此前将所有的数据都注册到 “root” 这个容器内，全局通用，但为了将不同作用域分开，需要引入 scope 的概念。</p>\n<p>简单理解就是在通过 key 获取的 map 里面的数据的时候，这个 key 是有一定的规则的，核心逻辑在这里：<br> <figure class=\"highlight kotlin\"><table><tr><td class=\"code\"><pre><span class=\"line\"> <span class=\"keyword\">inline</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">indexKey</span><span class=\"params\">(clazz: <span class=\"type\">KClass</span>&lt;*&gt;, typeQualifier: <span class=\"type\">String</span>?, scopeQualifier: <span class=\"type\">String</span>)</span></span>: String &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> buildString &#123;</span><br><span class=\"line\">        append(clazz.java.name)</span><br><span class=\"line\">        append(<span class=\"string\">&#x27;:&#x27;</span>)</span><br><span class=\"line\">        append(typeQualifier ?: <span class=\"string\">&quot;&quot;</span>)</span><br><span class=\"line\">        append(<span class=\"string\">&#x27;:&#x27;</span>)</span><br><span class=\"line\">        append(scopeQualifier)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br> 不同的 scope 实际上也就是获取的 key 值的不同。</p>\n<p><strong>动态参数能力</strong><br>代码实现在：<a href=\"https://github.com/VomPom/JProject/blob/master/app/src/main/java/wang/julis/jproject/example/source/koin/parameter3/KoinWithParameter.kt\">KoinWithParameter.kt</a></p>\n<p>最后在 scope 的基础上实现了一个比较重要的能力-动态参数能力，通过这个能力可以让有实例能够在运行的时候根据参数动态创建。这个能力也是像在安卓 Activity&#x2F;Fragment 里面 viewmodel() 实现依赖注入的必要实现。 </p>\n<p>简单理解就是在 get() 的时候将参数传入到获取实例的调用链中，在运行时执行注册的 Lambda 函数invoke时候将作为参数传递到构造方法中去。这里单独拎出来实现是因为这个参数传递影响到整个流程的逻辑，为了上上面的两个能力逻辑更简单清晰，单独在这一部分实现。</p>\n<h2 id=\"Koin-的注册流程（Declaration）\"><a href=\"#Koin-的注册流程（Declaration）\" class=\"headerlink\" title=\"Koin 的注册流程（Declaration）\"></a>Koin 的注册流程（Declaration）</h2><p>注册是DI容器工作的第一步。通过 <code>startKoin</code> 和 <code>module</code> DSL来声明依赖。</p>\n<h3 id=\"启动-Koin-与模块加载\"><a href=\"#启动-Koin-与模块加载\" class=\"headerlink\" title=\"启动 Koin 与模块加载\"></a>启动 Koin 与模块加载</h3><p>整个启动加载流程将 kotlin 的语法糖用到了极致，也就使得整个代码看起来是如此的简洁。</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> myApp = startKoin &#123;</span><br><span class=\"line\">    modules(appModule)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 定义一个模块</span></span><br><span class=\"line\"><span class=\"keyword\">val</span> appModule = module &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 注册一个单例，其构造需要一個 Int 参数</span></span><br><span class=\"line\">    single &#123; (<span class=\"keyword\">data</span>: <span class=\"built_in\">Int</span>) -&gt; ComponentInt(<span class=\"keyword\">data</span>) &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 注册一个工厂（每次获取都是新实例），其构造需要 Int 和 Float 参数</span></span><br><span class=\"line\">    factory &#123; (data1: <span class=\"built_in\">Int</span>, data2: <span class=\"built_in\">Float</span>) -&gt; ComponentIntFloat(data1, data2) &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>流程剖析：</strong></p>\n<p><strong><code>startKoin</code></strong><br>这是一个顶级函数，它调用 <code>GlobalContext.startKoin</code>，创建并初始化一个 <code>KoinApplication</code> 对象。</p>\n<p><strong><code>modules(...)</code></strong><br><code>KoinApplication</code> 的方法，它将传入的 <code>Module</code> 列表交给 <code>Koin</code> 实例的 <code>loadModels</code> 方法处理。</p>\n<p><strong><code>module &#123; ... &#125;</code></strong><br>DSL函数，它创建一个 <code>Module</code> 对象，并执行其中的配置lambda。</p>\n<p><strong><code>single/factory/scope</code></strong><br><code>Module</code> 的扩展函数。它们的作用是：</p>\n<ul>\n<li>使用 <code>_createDefinition</code> 将 lambda 表达式包装成一个 <code>BeanDefinition</code>对象。</li>\n<li>使用 <code>_InstanceFactory</code> 将 <code>BeanDefinition</code> 包装成对应的 <code>InstanceFactory</code>。</li>\n<li>调用 <code>indexPrimaryType</code>，生成一个<strong>唯一的Key</strong>（格式：<code>类名:限定符:作用域</code>），并将 <code>Factory</code> 存入 <code>Module.mappings</code> 这个 <code>HashMap</code> 中。</li>\n</ul>\n<p><strong>最终存储</strong><br><code>Koin</code> 的 <code>InstanceRegistry</code> 会遍历所有 <code>Module</code>，将它们 <code>mappings</code> 中的全部 <code>Factory</code> 都合并到自己的 <code>_instances</code>（一个 <code>ConcurrentHashMap</code>）中。</p>\n<p>至此，所有依赖的定义都已注册到容器中，静待获取。</p>\n<h2 id=\"Koin的实例获取流程（Retrieval）\"><a href=\"#Koin的实例获取流程（Retrieval）\" class=\"headerlink\" title=\"Koin的实例获取流程（Retrieval）\"></a>Koin的实例获取流程（Retrieval）</h2><figure class=\"highlight kotlin\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 获取无参依赖（普通方式）</span></span><br><span class=\"line\"><span class=\"keyword\">val</span> component = <span class=\"keyword\">get</span>&lt;Component&gt;()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 通过 scope 作用域限定进行获取</span></span><br><span class=\"line\"><span class=\"keyword\">val</span> scope = koin.createScope(<span class=\"string\">&quot;scope&quot;</span>, scopeQualifier)</span><br><span class=\"line\"><span class=\"keyword\">val</span> component = scope.<span class=\"keyword\">get</span>&lt;Component&gt;()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 通过需要动态参数的获取</span></span><br><span class=\"line\"><span class=\"keyword\">val</span> componentWithArgs = <span class=\"keyword\">get</span>&lt;ComponentInt&gt; &#123; parametersOf(<span class=\"number\">42</span>) &#125;</span><br><span class=\"line\"><span class=\"keyword\">val</span> componentWithMultiArgs = <span class=\"keyword\">get</span>&lt;ComponentIntFloat&gt; &#123; parametersOf(<span class=\"number\">101</span>, <span class=\"number\">3.14f</span>) &#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"流程剖析\"><a href=\"#流程剖析\" class=\"headerlink\" title=\"流程剖析\"></a>流程剖析</h3><p><strong><code>Scope.get&lt;T&gt;</code></strong></p>\n<p>这是 <code>Scope</code> 的一个扩展函数。它首先创建一个 <code>ResolutionContext</code>，封装了当前作用域、要解析的类型、限定符以及最重要的——<strong>参数持有器 <code>ParametersHolder</code></strong>（由 <code>parametersOf</code> 函数创建）。</p>\n<p> <strong>解析上下文（ResolutionContext）</strong></p>\n<p> 这个上下文对象包含了解析一个实例所需的所有信息。</p>\n<p><strong>核心解析器（CoreResolver）</strong><br><code>get</code> 操作会委托给 <code>Koin</code> 的 <code>CoreResolver</code>进行处理。源码里面对于查找顺序有非常清晰的层次体现：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"type\">&lt;T&gt;</span> <span class=\"title\">resolveFromContext</span><span class=\"params\">(scope : <span class=\"type\">Scope</span>, instanceContext: <span class=\"type\">ResolutionContext</span>)</span></span>: T &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> resolveFromContextOrNull(scope,instanceContext) ?: throwNoDefinitionFound(instanceContext)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"type\">&lt;T&gt;</span> <span class=\"title\">resolveFromContextOrNull</span><span class=\"params\">(scope : <span class=\"type\">Scope</span>, instanceContext: <span class=\"type\">ResolutionContext</span>, lookupParent : <span class=\"type\">Boolean</span> = <span class=\"literal\">true</span>)</span></span>: T? &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> resolveFromInjectedParameters(instanceContext)</span><br><span class=\"line\">          ?: resolveFromRegistry(scope,instanceContext)</span><br><span class=\"line\">          ?: resolveFromStackedParameters(scope,instanceContext)</span><br><span class=\"line\">          ?: resolveFromScopeSource(scope,instanceContext)</span><br><span class=\"line\">          ?: resolveFromScopeArchetype(scope,instanceContext)</span><br><span class=\"line\">          ?: <span class=\"keyword\">if</span> (lookupParent) resolveFromParentScopes(scope,instanceContext) <span class=\"keyword\">else</span> <span class=\"literal\">null</span></span><br><span class=\"line\">          ?: resolveInExtensions(scope,instanceContext)</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n\n<p> <strong>查找工厂</strong></p>\n<ul>\n<li><code>Resolver</code> 会调用 <code>InstanceRegistry.resolveDefinition</code>。</li>\n<li>该方法使用和注册时<strong>相同的算法</strong>生成Key（类名:限定符:作用域），然后从 <code>_instances</code> 中查找对应的 <code>InstanceFactory</code>。</li>\n</ul>\n<p> <strong>创建实例</strong></p>\n<ul>\n<li><p>找到 <code>Factory</code> 后，调用其 <code>get(context: ResolutionContext)</code> 方法。</p>\n</li>\n<li><p><code>Factory</code> 会调用自己的 <code>create</code> 方法。<strong>关键一步来了</strong>：在 <code>create</code> 方法中，会执行 <code>BeanDefinition.definition.invoke(context.scope, parameters)</code>。这其实就是执行了之前注册的 lambda：<code>&#123; (data: Int) -&gt; ComponentInt(data) &#125;</code>。</p>\n</li>\n<li><p><strong>参数传递</strong>：这里的 <code>parameters</code> 就是在 <code>get</code> 时传入的 <code>ParametersHolder</code>。Lambda 的参数 <code>(data: Int)</code> 会从 <code>ParametersHolder</code> 中按顺序（或使用解构）取出值</p>\n</li>\n</ul>\n<p><strong>返回实例</strong></p>\n<p>工厂将创建好的实例返回给调用者。</p>\n<p>对于 <code>SingleFactory</code>，它会将第一次创建出来的实例缓存起来，后续调用直接返回缓存实例。<code>FactoryFactory</code> 则每次都会执行 <code>create</code> 方法。</p>\n<h2 id=\"其他技术\"><a href=\"#其他技术\" class=\"headerlink\" title=\"其他技术\"></a>其他技术</h2><h3 id=\"DslMarker-的作用\"><a href=\"#DslMarker-的作用\" class=\"headerlink\" title=\"@DslMarker 的作用\"></a>@DslMarker 的作用</h3><p>在实现的过程中发现如下图所示：koin 的代码有颜色分层，能比较清晰地看到各个 block 之间的差异，自己写的代码全部是白色。</p>\n<img src=\"https://cdn.julis.wang/blog/img/koin_color_contrast.png\"> \n\n\n<p>代码开头定义了三个注解：<code>@KoinApplicationDslMarker</code>, <code>@KoinDslMarker</code>, <code>@OptionDslMarker</code>。这是Kotlin DSL的<strong>安全卫士</strong>。</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@DslMarker</span></span><br><span class=\"line\"><span class=\"keyword\">annotation</span> <span class=\"keyword\">class</span> <span class=\"title class_\">KoinDslMarker</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@KoinDslMarker</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Module</span> &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">single</span><span class=\"params\">(...)</span></span> &#123; ... &#125; <span class=\"comment\">// 这个single在DSL里</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@KoinDslMarker</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">KoinApplication</span> &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">modules</span><span class=\"params\">(...)</span></span> &#123; ... &#125; <span class=\"comment\">// 这个modules在DSL里</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">test</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    startKoin &#123;</span><br><span class=\"line\">        modules(...) <span class=\"comment\">// 正确：在 KoinApplication 的 lambda 里</span></span><br><span class=\"line\">        single &#123; ... &#125; <span class=\"comment\">// 编译错误！@DslMarker 阻止了隐式地使用外部 Receiver (Module)</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>@DslMarker</code> 实际的作用是防止在嵌套的DSL Lambda中，意外地调用到外层 Receiver 的方法，从而让DSL书写更加清晰和安全。代码颜色是由 IDE 提供的效果。在代码中加上几个注解之后，效果如图所示：</p>\n<img src=\"https://cdn.julis.wang/blog/img/koin_color_annotation.png\"> \n<p>跟 koin 的颜色不太一致，不过能明显看到代码有分层，应该是由于 koin 对 annotation 也有处理，这里没有再深入研究。</p>\n<h3 id=\"2-优雅的参数传递与解构\"><a href=\"#2-优雅的参数传递与解构\" class=\"headerlink\" title=\"2. 优雅的参数传递与解构\"></a>2. 优雅的参数传递与解构</h3><p>这个逻辑复刻了Koin的动态参数特性。</p>\n<ul>\n<li><strong><code>ParametersHolder</code></strong>：一个轻量的参数容器，内部用一个 <code>List&lt;Any?&gt;</code> 存储参数。</li>\n<li><strong><code>parametersOf</code></strong>：辅助函数，优雅地创建 <code>ParametersHolder</code>。</li>\n<li><strong>解构声明（Destructuring Declaration）</strong>：<code>ParametersHolder</code> 重写了 <code>component1()</code> 到 <code>component5()</code> 操作符。这使得在定义lambda时，可以直接用 <code>(a: A, b: B)</code> 的形式来接收参数，而不是手动调用 <code>parameters.get&lt;X&gt;(0)</code>。</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 注册端：看起来就像普通函数</span></span><br><span class=\"line\">single &#123; (id: <span class=\"built_in\">Int</span>, name: String) -&gt; User(id, name) &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 获取端：传递参数非常直观</span></span><br><span class=\"line\"><span class=\"keyword\">val</span> user = <span class=\"keyword\">get</span>&lt;User&gt; &#123; parametersOf(<span class=\"number\">123</span>, <span class=\"string\">&quot;Julius&quot;</span>) &#125;</span><br></pre></td></tr></table></figure>\n<p>这种设计极大地提升了API的简洁性和可读性。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>通过这个手写的迷你Koin，可以深刻地理解到，一个现代DI容器的核心无非是解决两个问题：</p>\n<ol>\n<li><strong>如何注册（Declaration）</strong>：通过DSL将依赖的创建方式（Lambda）以键值对的形式保存到一个全局的注册表中。</li>\n<li><strong>如何获取（Retrieval）</strong>：根据请求的类型、限定符和作用域生成Key，从注册表中找到对应的创建工厂，并调用它来生成实例。支持通过参数容器实现动态传参。</li>\n</ol>\n<p>除此之外，诸如 <code>@DslMarker</code> 保证DSL安全、<strong>解构</strong>实现参数优雅传递，都是构建一个健壮、易用框架的关键技术。</p>\n<p>虽然这个实现省略了Koin的许多高级功能（如完整的Scope生命周期管理、属性注入、Android特定支持等），但它已经囊括了最核心、最精妙的设计思想，再理解其他的模块也会简单很多。</p>\n<p>实现的所有源码位于：<a href=\"https://github.com/VomPom/JProject/tree/master/app/src/main/java/wang/julis/jproject/example/source/koin\">JProject&#x2F;source&#x2F;koin</a></p>\n","cover":null,"images":["https://cdn.julis.wang/blog/img/koin_uml.png","https://cdn.julis.wang/blog/img/koin_color_contrast.png","https://cdn.julis.wang/blog/img/koin_color_annotation.png"],"content":"<p>在现代 Android 应用开发中，依赖注入（Dependency Injection, DI）已成为构建松耦合、可测试代码的重要技术。Koin 作为一个轻量级的Kotlin依赖注入框架，因其简洁的DSL和易用性深受开发者喜爱。最近对其源码进行学习了解，通过手写一个极度精简的 Koin 核心代码，来透彻理解Koin的注册、解析和参数传递机制。</p>\n<blockquote>\n<p><strong>本文代码基于 Koin 源码思想实现，仅用于学习核心原理，并非 Koin官 方代码。</strong></p>\n</blockquote>\n<h2 id=\"核心概念与项目结构\"><a href=\"#核心概念与项目结构\" class=\"headerlink\" title=\"核心概念与项目结构\"></a>核心概念与项目结构</h2><p>下图是基于 koin 4.1 解析的 主要类UML图，可以比较清晰地看看各个类之间的关系</p>\n<img src=\"https://cdn.julis.wang/blog/img/koin_uml.png\"> \n<p>power by <a href=\"https://www.mermaidchart.com/\">mermaidchart</a></p>\n<p>主要类：</p>\n<ul>\n<li><strong><code>KoinApplication</code></strong>: Koin启动的入口，负责初始化容器和加载模块。</li>\n<li><strong><code>Koin</code></strong>: 核心容器，持有实例注册表 InstanceRegistry 和作用域注册表 ScopeRegistry。</li>\n<li><strong><code>Module</code></strong>: 定义依赖的地方，存放了所有的 bean 定义 BeanDefinition 与 InstanceFactory。</li>\n<li><strong><code>BeanDefinition</code></strong>: 对一个依赖项的定义，包括其类型、限定符、所属作用域以及创建它的 lambda 表达式。</li>\n<li><strong><code>InstanceFactory</code></strong>: 负责根据 <code>BeanDefinition</code> 创建实例的核心工厂，分为 <code>SingleFactory</code> (单例)、<code>FactoryFactory</code> (工厂模式) 和 <code>ScopeFactory</code> (作用域内单例)。</li>\n<li><strong><code>Scope</code></strong>: 作用域，用于管理特定生命周期内的实例。</li>\n<li><strong><code>ParametersHolder</code></strong>: 参数容器，用于在获取实例时动态传递参数。</li>\n</ul>\n<h2 id=\"手写-koin-代码介绍\"><a href=\"#手写-koin-代码介绍\" class=\"headerlink\" title=\"手写 koin 代码介绍\"></a>手写 koin 代码介绍</h2><p>基于对源码的理解和参考，实现了 koin 的基本功能，整体分成三部分：简单 single 数据存取、包含 scope 能力、动态参数能力，分成三个文件夹，顺序123是基于前面带代码累加的。</p>\n<p><strong>简单 single 数据存取</strong><br>代码实现在：<a href=\"https://github.com/VomPom/JProject/blob/master/app/src/main/java/wang/julis/jproject/example/source/koin/noScope1/KoinWithoutScope.kt\">KoinWithoutScope.kt</a></p>\n<p>这是一份最简单的代码，大概200行不到，基本上包含了 koin 的核心思想：启动时注册组件定义。解析时，先查作用域缓存，命中则直接返回。未命中则递归解析其依赖项，调用工厂函数创建实例，最后返回实例。</p>\n<p>从这也能看出来 koin 的缺点：Koin 启动时 (startKoin) 需要将所有模块的定义 (BeanDefinition) 注册到容器中。实例数量过多会显著增加启动注册过程的耗时，影响应用启动速度。由于每个实例都会对应一个 BeanDefinition 以及 Factory ，内存占用会相应地上升。</p>\n<p>整个流程简单来讲就是生成一个 map，通过 key 获取对于的数据。</p>\n<p><strong>Scope 能力</strong><br>代码实现在：<a href=\"https://github.com/VomPom/JProject/blob/master/app/src/main/java/wang/julis/jproject/example/source/koin/scope2/KoinWithScope.kt\">KoinWithScope.kt</a></p>\n<p>这一份是在之前的能力上进行添加，此前将所有的数据都注册到 “root” 这个容器内，全局通用，但为了将不同作用域分开，需要引入 scope 的概念。</p>\n<p>简单理解就是在通过 key 获取的 map 里面的数据的时候，这个 key 是有一定的规则的，核心逻辑在这里：<br> <figure class=\"highlight kotlin\"><table><tr><td class=\"code\"><pre><span class=\"line\"> <span class=\"keyword\">inline</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">indexKey</span><span class=\"params\">(clazz: <span class=\"type\">KClass</span>&lt;*&gt;, typeQualifier: <span class=\"type\">String</span>?, scopeQualifier: <span class=\"type\">String</span>)</span></span>: String &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> buildString &#123;</span><br><span class=\"line\">        append(clazz.java.name)</span><br><span class=\"line\">        append(<span class=\"string\">&#x27;:&#x27;</span>)</span><br><span class=\"line\">        append(typeQualifier ?: <span class=\"string\">&quot;&quot;</span>)</span><br><span class=\"line\">        append(<span class=\"string\">&#x27;:&#x27;</span>)</span><br><span class=\"line\">        append(scopeQualifier)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br> 不同的 scope 实际上也就是获取的 key 值的不同。</p>\n<p><strong>动态参数能力</strong><br>代码实现在：<a href=\"https://github.com/VomPom/JProject/blob/master/app/src/main/java/wang/julis/jproject/example/source/koin/parameter3/KoinWithParameter.kt\">KoinWithParameter.kt</a></p>\n<p>最后在 scope 的基础上实现了一个比较重要的能力-动态参数能力，通过这个能力可以让有实例能够在运行的时候根据参数动态创建。这个能力也是像在安卓 Activity&#x2F;Fragment 里面 viewmodel() 实现依赖注入的必要实现。 </p>\n<p>简单理解就是在 get() 的时候将参数传入到获取实例的调用链中，在运行时执行注册的 Lambda 函数invoke时候将作为参数传递到构造方法中去。这里单独拎出来实现是因为这个参数传递影响到整个流程的逻辑，为了上上面的两个能力逻辑更简单清晰，单独在这一部分实现。</p>\n<h2 id=\"Koin-的注册流程（Declaration）\"><a href=\"#Koin-的注册流程（Declaration）\" class=\"headerlink\" title=\"Koin 的注册流程（Declaration）\"></a>Koin 的注册流程（Declaration）</h2><p>注册是DI容器工作的第一步。通过 <code>startKoin</code> 和 <code>module</code> DSL来声明依赖。</p>\n<h3 id=\"启动-Koin-与模块加载\"><a href=\"#启动-Koin-与模块加载\" class=\"headerlink\" title=\"启动 Koin 与模块加载\"></a>启动 Koin 与模块加载</h3><p>整个启动加载流程将 kotlin 的语法糖用到了极致，也就使得整个代码看起来是如此的简洁。</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> myApp = startKoin &#123;</span><br><span class=\"line\">    modules(appModule)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 定义一个模块</span></span><br><span class=\"line\"><span class=\"keyword\">val</span> appModule = module &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 注册一个单例，其构造需要一個 Int 参数</span></span><br><span class=\"line\">    single &#123; (<span class=\"keyword\">data</span>: <span class=\"built_in\">Int</span>) -&gt; ComponentInt(<span class=\"keyword\">data</span>) &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 注册一个工厂（每次获取都是新实例），其构造需要 Int 和 Float 参数</span></span><br><span class=\"line\">    factory &#123; (data1: <span class=\"built_in\">Int</span>, data2: <span class=\"built_in\">Float</span>) -&gt; ComponentIntFloat(data1, data2) &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>流程剖析：</strong></p>\n<p><strong><code>startKoin</code></strong><br>这是一个顶级函数，它调用 <code>GlobalContext.startKoin</code>，创建并初始化一个 <code>KoinApplication</code> 对象。</p>\n<p><strong><code>modules(...)</code></strong><br><code>KoinApplication</code> 的方法，它将传入的 <code>Module</code> 列表交给 <code>Koin</code> 实例的 <code>loadModels</code> 方法处理。</p>\n<p><strong><code>module &#123; ... &#125;</code></strong><br>DSL函数，它创建一个 <code>Module</code> 对象，并执行其中的配置lambda。</p>\n<p><strong><code>single/factory/scope</code></strong><br><code>Module</code> 的扩展函数。它们的作用是：</p>\n<ul>\n<li>使用 <code>_createDefinition</code> 将 lambda 表达式包装成一个 <code>BeanDefinition</code>对象。</li>\n<li>使用 <code>_InstanceFactory</code> 将 <code>BeanDefinition</code> 包装成对应的 <code>InstanceFactory</code>。</li>\n<li>调用 <code>indexPrimaryType</code>，生成一个<strong>唯一的Key</strong>（格式：<code>类名:限定符:作用域</code>），并将 <code>Factory</code> 存入 <code>Module.mappings</code> 这个 <code>HashMap</code> 中。</li>\n</ul>\n<p><strong>最终存储</strong><br><code>Koin</code> 的 <code>InstanceRegistry</code> 会遍历所有 <code>Module</code>，将它们 <code>mappings</code> 中的全部 <code>Factory</code> 都合并到自己的 <code>_instances</code>（一个 <code>ConcurrentHashMap</code>）中。</p>\n<p>至此，所有依赖的定义都已注册到容器中，静待获取。</p>\n<h2 id=\"Koin的实例获取流程（Retrieval）\"><a href=\"#Koin的实例获取流程（Retrieval）\" class=\"headerlink\" title=\"Koin的实例获取流程（Retrieval）\"></a>Koin的实例获取流程（Retrieval）</h2><figure class=\"highlight kotlin\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 获取无参依赖（普通方式）</span></span><br><span class=\"line\"><span class=\"keyword\">val</span> component = <span class=\"keyword\">get</span>&lt;Component&gt;()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 通过 scope 作用域限定进行获取</span></span><br><span class=\"line\"><span class=\"keyword\">val</span> scope = koin.createScope(<span class=\"string\">&quot;scope&quot;</span>, scopeQualifier)</span><br><span class=\"line\"><span class=\"keyword\">val</span> component = scope.<span class=\"keyword\">get</span>&lt;Component&gt;()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 通过需要动态参数的获取</span></span><br><span class=\"line\"><span class=\"keyword\">val</span> componentWithArgs = <span class=\"keyword\">get</span>&lt;ComponentInt&gt; &#123; parametersOf(<span class=\"number\">42</span>) &#125;</span><br><span class=\"line\"><span class=\"keyword\">val</span> componentWithMultiArgs = <span class=\"keyword\">get</span>&lt;ComponentIntFloat&gt; &#123; parametersOf(<span class=\"number\">101</span>, <span class=\"number\">3.14f</span>) &#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"流程剖析\"><a href=\"#流程剖析\" class=\"headerlink\" title=\"流程剖析\"></a>流程剖析</h3><p><strong><code>Scope.get&lt;T&gt;</code></strong></p>\n<p>这是 <code>Scope</code> 的一个扩展函数。它首先创建一个 <code>ResolutionContext</code>，封装了当前作用域、要解析的类型、限定符以及最重要的——<strong>参数持有器 <code>ParametersHolder</code></strong>（由 <code>parametersOf</code> 函数创建）。</p>\n<p> <strong>解析上下文（ResolutionContext）</strong></p>\n<p> 这个上下文对象包含了解析一个实例所需的所有信息。</p>\n<p><strong>核心解析器（CoreResolver）</strong><br><code>get</code> 操作会委托给 <code>Koin</code> 的 <code>CoreResolver</code>进行处理。源码里面对于查找顺序有非常清晰的层次体现：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"type\">&lt;T&gt;</span> <span class=\"title\">resolveFromContext</span><span class=\"params\">(scope : <span class=\"type\">Scope</span>, instanceContext: <span class=\"type\">ResolutionContext</span>)</span></span>: T &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> resolveFromContextOrNull(scope,instanceContext) ?: throwNoDefinitionFound(instanceContext)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"type\">&lt;T&gt;</span> <span class=\"title\">resolveFromContextOrNull</span><span class=\"params\">(scope : <span class=\"type\">Scope</span>, instanceContext: <span class=\"type\">ResolutionContext</span>, lookupParent : <span class=\"type\">Boolean</span> = <span class=\"literal\">true</span>)</span></span>: T? &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> resolveFromInjectedParameters(instanceContext)</span><br><span class=\"line\">          ?: resolveFromRegistry(scope,instanceContext)</span><br><span class=\"line\">          ?: resolveFromStackedParameters(scope,instanceContext)</span><br><span class=\"line\">          ?: resolveFromScopeSource(scope,instanceContext)</span><br><span class=\"line\">          ?: resolveFromScopeArchetype(scope,instanceContext)</span><br><span class=\"line\">          ?: <span class=\"keyword\">if</span> (lookupParent) resolveFromParentScopes(scope,instanceContext) <span class=\"keyword\">else</span> <span class=\"literal\">null</span></span><br><span class=\"line\">          ?: resolveInExtensions(scope,instanceContext)</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n\n<p> <strong>查找工厂</strong></p>\n<ul>\n<li><code>Resolver</code> 会调用 <code>InstanceRegistry.resolveDefinition</code>。</li>\n<li>该方法使用和注册时<strong>相同的算法</strong>生成Key（类名:限定符:作用域），然后从 <code>_instances</code> 中查找对应的 <code>InstanceFactory</code>。</li>\n</ul>\n<p> <strong>创建实例</strong></p>\n<ul>\n<li><p>找到 <code>Factory</code> 后，调用其 <code>get(context: ResolutionContext)</code> 方法。</p>\n</li>\n<li><p><code>Factory</code> 会调用自己的 <code>create</code> 方法。<strong>关键一步来了</strong>：在 <code>create</code> 方法中，会执行 <code>BeanDefinition.definition.invoke(context.scope, parameters)</code>。这其实就是执行了之前注册的 lambda：<code>&#123; (data: Int) -&gt; ComponentInt(data) &#125;</code>。</p>\n</li>\n<li><p><strong>参数传递</strong>：这里的 <code>parameters</code> 就是在 <code>get</code> 时传入的 <code>ParametersHolder</code>。Lambda 的参数 <code>(data: Int)</code> 会从 <code>ParametersHolder</code> 中按顺序（或使用解构）取出值</p>\n</li>\n</ul>\n<p><strong>返回实例</strong></p>\n<p>工厂将创建好的实例返回给调用者。</p>\n<p>对于 <code>SingleFactory</code>，它会将第一次创建出来的实例缓存起来，后续调用直接返回缓存实例。<code>FactoryFactory</code> 则每次都会执行 <code>create</code> 方法。</p>\n<h2 id=\"其他技术\"><a href=\"#其他技术\" class=\"headerlink\" title=\"其他技术\"></a>其他技术</h2><h3 id=\"DslMarker-的作用\"><a href=\"#DslMarker-的作用\" class=\"headerlink\" title=\"@DslMarker 的作用\"></a>@DslMarker 的作用</h3><p>在实现的过程中发现如下图所示：koin 的代码有颜色分层，能比较清晰地看到各个 block 之间的差异，自己写的代码全部是白色。</p>\n<img src=\"https://cdn.julis.wang/blog/img/koin_color_contrast.png\"> \n\n\n<p>代码开头定义了三个注解：<code>@KoinApplicationDslMarker</code>, <code>@KoinDslMarker</code>, <code>@OptionDslMarker</code>。这是Kotlin DSL的<strong>安全卫士</strong>。</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@DslMarker</span></span><br><span class=\"line\"><span class=\"keyword\">annotation</span> <span class=\"keyword\">class</span> <span class=\"title class_\">KoinDslMarker</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@KoinDslMarker</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Module</span> &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">single</span><span class=\"params\">(...)</span></span> &#123; ... &#125; <span class=\"comment\">// 这个single在DSL里</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@KoinDslMarker</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">KoinApplication</span> &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">modules</span><span class=\"params\">(...)</span></span> &#123; ... &#125; <span class=\"comment\">// 这个modules在DSL里</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">test</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    startKoin &#123;</span><br><span class=\"line\">        modules(...) <span class=\"comment\">// 正确：在 KoinApplication 的 lambda 里</span></span><br><span class=\"line\">        single &#123; ... &#125; <span class=\"comment\">// 编译错误！@DslMarker 阻止了隐式地使用外部 Receiver (Module)</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>@DslMarker</code> 实际的作用是防止在嵌套的DSL Lambda中，意外地调用到外层 Receiver 的方法，从而让DSL书写更加清晰和安全。代码颜色是由 IDE 提供的效果。在代码中加上几个注解之后，效果如图所示：</p>\n<img src=\"https://cdn.julis.wang/blog/img/koin_color_annotation.png\"> \n<p>跟 koin 的颜色不太一致，不过能明显看到代码有分层，应该是由于 koin 对 annotation 也有处理，这里没有再深入研究。</p>\n<h3 id=\"2-优雅的参数传递与解构\"><a href=\"#2-优雅的参数传递与解构\" class=\"headerlink\" title=\"2. 优雅的参数传递与解构\"></a>2. 优雅的参数传递与解构</h3><p>这个逻辑复刻了Koin的动态参数特性。</p>\n<ul>\n<li><strong><code>ParametersHolder</code></strong>：一个轻量的参数容器，内部用一个 <code>List&lt;Any?&gt;</code> 存储参数。</li>\n<li><strong><code>parametersOf</code></strong>：辅助函数，优雅地创建 <code>ParametersHolder</code>。</li>\n<li><strong>解构声明（Destructuring Declaration）</strong>：<code>ParametersHolder</code> 重写了 <code>component1()</code> 到 <code>component5()</code> 操作符。这使得在定义lambda时，可以直接用 <code>(a: A, b: B)</code> 的形式来接收参数，而不是手动调用 <code>parameters.get&lt;X&gt;(0)</code>。</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 注册端：看起来就像普通函数</span></span><br><span class=\"line\">single &#123; (id: <span class=\"built_in\">Int</span>, name: String) -&gt; User(id, name) &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 获取端：传递参数非常直观</span></span><br><span class=\"line\"><span class=\"keyword\">val</span> user = <span class=\"keyword\">get</span>&lt;User&gt; &#123; parametersOf(<span class=\"number\">123</span>, <span class=\"string\">&quot;Julius&quot;</span>) &#125;</span><br></pre></td></tr></table></figure>\n<p>这种设计极大地提升了API的简洁性和可读性。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>通过这个手写的迷你Koin，可以深刻地理解到，一个现代DI容器的核心无非是解决两个问题：</p>\n<ol>\n<li><strong>如何注册（Declaration）</strong>：通过DSL将依赖的创建方式（Lambda）以键值对的形式保存到一个全局的注册表中。</li>\n<li><strong>如何获取（Retrieval）</strong>：根据请求的类型、限定符和作用域生成Key，从注册表中找到对应的创建工厂，并调用它来生成实例。支持通过参数容器实现动态传参。</li>\n</ol>\n<p>除此之外，诸如 <code>@DslMarker</code> 保证DSL安全、<strong>解构</strong>实现参数优雅传递，都是构建一个健壮、易用框架的关键技术。</p>\n<p>虽然这个实现省略了Koin的许多高级功能（如完整的Scope生命周期管理、属性注入、Android特定支持等），但它已经囊括了最核心、最精妙的设计思想，再理解其他的模块也会简单很多。</p>\n<p>实现的所有源码位于：<a href=\"https://github.com/VomPom/JProject/tree/master/app/src/main/java/wang/julis/jproject/example/source/koin\">JProject&#x2F;source&#x2F;koin</a></p>\n","categories":[{"name":"技术文章","slug":"technology","api":"api/categories/technology.json"}],"tags":[{"name":"koin","slug":"koin","api":"api/tags/koin.json"}],"api":"api/posts/2025/08/25/Koin-源码理解相关.json"},{"title":"[Compose Multiplatform]跨平台博客应用实践","slug":"Compose-Multiplatform-跨平台博客应用实践","date":"2025-07-28T12:28:00.000Z","updated":"2025-07-28T14:51:23.535Z","comments":true,"url":"2025/07/28/Compose-Multiplatform-跨平台博客应用实践/","excerpt":"<h2 id=\"用-CMP-构建跨平台博客应用：一次-Kotlin-的全栈实践\"><a href=\"#用-CMP-构建跨平台博客应用：一次-Kotlin-的全栈实践\" class=\"headerlink\" title=\"用 CMP 构建跨平台博客应用：一次 Kotlin 的全栈实践\"></a>用 CMP 构建跨平台博客应用：一次 Kotlin 的全栈实践</h2><p>在追求高效开发的时代，跨平台技术已成为移动应用开发的主流选择，此前基于鸿蒙的开发平台开发 <a href=\"https://julis.wang/2025/05/16/%E9%B8%BF%E8%92%99-%E5%86%99%E4%BA%86%E4%B8%AA%E5%9F%BA%E4%BA%8EHexo%E5%8D%9A%E5%AE%A2%E7%9A%84%E9%B8%BF%E8%92%99App/\">blog_harmony</a>，将自己博客文章进行展示。本文将介绍基于 <strong>CMP(Compose Multiplatform)</strong> 构建的开源博客应用 <a href=\"https://github.com/VomPom/blog_kmp\">blog_kmp</a>，展示如何用 Kotlin 实现跨平台的应用开发。</p>\n<h3 id=\"Compose-Multiplatform\"><a href=\"#Compose-Multiplatform\" class=\"headerlink\" title=\"Compose Multiplatform\"></a>Compose Multiplatform</h3><p>Compose Multiplatform 是 JetBrains 推出的声明式 UI 框架，基于 Jetpack Compose 扩展而来：</p>\n<ul>\n<li><strong>核心优势</strong>：用同一套 Kotlin 代码构建 Android、iOS、Desktop 和 Web 应用</li>\n<li><strong>开发效率</strong>：实时预览、热重载加速开发迭代</li>\n<li><strong>原生性能</strong>：通过 Skia 渲染引擎实现接近原生体验</li>\n<li><strong>共享逻辑</strong>：业务逻辑、网络请求、状态管理可 100% 复用</li>\n</ul>\n<h3 id=\"项目架构与技术栈\"><a href=\"#项目架构与技术栈\" class=\"headerlink\" title=\"项目架构与技术栈\"></a>项目架构与技术栈</h3><p>blog_kmp 采用分层架构设计，核心模块包括：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"code\"><pre><span class=\"line\">shared/</span><br><span class=\"line\">├── src/commonMain/kotlin/  # 共享业务逻辑</span><br><span class=\"line\">│   ├── <span class=\"keyword\">data</span>/               # 数据层</span><br><span class=\"line\">│   ├── domain/             # 领域模型</span><br><span class=\"line\">│   └── presentation/       # UI状态管理</span><br><span class=\"line\">├── src/androidMain/        # Android 平台代码</span><br><span class=\"line\">└── src/iosMain/            # iOS 平台适配</span><br><span class=\"line\">├── composeApp</span><br><span class=\"line\">│   ├── build.gradle.kts</span><br><span class=\"line\">│   └── src</span><br><span class=\"line\">│       ├── androidMain     # Android 平台代码</span><br><span class=\"line\">│       ├── commonMain      # 共享业务逻辑</span><br><span class=\"line\">│            ├── App.kt     # 界面展示入口</span><br><span class=\"line\">│            ├── <span class=\"keyword\">data</span>       # 数据层</span><br><span class=\"line\">│            │   ├── api        # 网络请求</span><br><span class=\"line\">│            │   ├── di         # koin 依赖注入</span><br><span class=\"line\">│            │   ├── model      # model 数据</span><br><span class=\"line\">│            │   └── repository # 数据缓存管理</span><br><span class=\"line\">│            │</span><br><span class=\"line\">│            ├── navigation  # 页面间导航管理</span><br><span class=\"line\">│            ├── platform    # 通过对各个平台抽象的接口 </span><br><span class=\"line\">│            └── ui          # 通用 UI 逻辑</span><br><span class=\"line\">│</span><br><span class=\"line\">│       ├── desktopMain     # Desktop 平台适配</span><br><span class=\"line\">│       └── iosMain         # iOS 平台适配</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"功能预览\"><a href=\"#功能预览\" class=\"headerlink\" title=\"功能预览\"></a>功能预览</h2><h3 id=\"Android\"><a href=\"#Android\" class=\"headerlink\" title=\"Android\"></a>Android</h3><p><img src=\"https://cdn.julis.wang/github/blog_cmp/android.png\"></p>\n<h4 id=\"深色模式\"><a href=\"#深色模式\" class=\"headerlink\" title=\"深色模式\"></a>深色模式</h4><p><img src=\"https://cdn.julis.wang/github/blog_cmp/dark.png\"></p>\n<h3 id=\"iOS\"><a href=\"#iOS\" class=\"headerlink\" title=\"iOS\"></a>iOS</h3><p><img src=\"https://cdn.julis.wang/github/blog_cmp/ios.png\"></p>\n<h3 id=\"Desktop\"><a href=\"#Desktop\" class=\"headerlink\" title=\"Desktop\"></a>Desktop</h3><p><img src=\"https://cdn.julis.wang/github/blog_cmp/desktop.png\"></p>\n<h4 id=\"主要技术栈\"><a href=\"#主要技术栈\" class=\"headerlink\" title=\"主要技术栈\"></a>主要技术栈</h4><ol>\n<li><strong>Ktor 客户端</strong> - 网络请求</li>\n</ol>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> httpClient = HttpClient &#123;</span><br><span class=\"line\">    install(ContentNegotiation) &#123;</span><br><span class=\"line\">        json(Json &#123; ignoreUnknownKeys = <span class=\"literal\">true</span> &#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">suspend</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">loadPosts</span><span class=\"params\">()</span></span>: List&lt;Post&gt; = </span><br><span class=\"line\">    httpClient.<span class=\"keyword\">get</span>(<span class=\"string\">&quot;https://cdn.julis/api/posts&quot;</span>).body()</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li><strong>DataStore</strong> - 跨平台数据库</li>\n</ol>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> dataKey = stringPreferencesKey(key)</span><br><span class=\"line\"><span class=\"keyword\">val</span> result = dataStore.<span class=\"keyword\">data</span></span><br><span class=\"line\">    .<span class=\"keyword\">catch</span> &#123; exception -&gt;</span><br><span class=\"line\">        <span class=\"comment\">// dataStore.data throws an IOException when an error is encountered when reading data</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (exception <span class=\"keyword\">is</span> IOException) &#123;</span><br><span class=\"line\">            emit(emptyPreferences())</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> exception</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    .map &#123; preferences -&gt;</span><br><span class=\"line\">        <span class=\"keyword\">val</span> <span class=\"keyword\">data</span>: String? = preferences[dataKey]</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">data</span> == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"literal\">null</span></span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (isJson) Json.decodeFromString&lt;T&gt;(<span class=\"keyword\">data</span>) <span class=\"keyword\">else</span> (<span class=\"keyword\">data</span> <span class=\"keyword\">as</span> T)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li><strong>Koin</strong> - 依赖注入</li>\n</ol>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> sharedModule = module &#123;</span><br><span class=\"line\">    single&lt;PostRepository&gt; &#123; PostRepositoryImpl(<span class=\"keyword\">get</span>()) &#125;</span><br><span class=\"line\">    viewModel &#123; PostViewModel(<span class=\"keyword\">get</span>()) &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"4\">\n<li><strong>Kotlinx.Serialization</strong> - JSON 解析</li>\n</ol>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Serializable</span></span><br><span class=\"line\"><span class=\"keyword\">data</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Post</span>(</span><br><span class=\"line\">    <span class=\"keyword\">val</span> id: String,</span><br><span class=\"line\">    <span class=\"keyword\">val</span> title: String,</span><br><span class=\"line\">    <span class=\"keyword\">val</span> content: String</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n\n<ol start=\"5\">\n<li><strong>compose-webview-multiplatform</strong> - WebView 浏览器<br>使用的第三方开发<a href=\"https://github.com/KevinnZou/compose-webview-multiplatform\">compose-webview-multiplatform</a>基于 <a href=\"https://github.com/chromiumembedded/java-cef\">java-cef</a>开发，不过这个library 在 desktop 平台表现不是太好，待完善。</li>\n</ol>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> state = rememberWebViewState(postUrl)</span><br><span class=\"line\"> WebView(state = state,modifier = Modifier.fillMaxSize())            </span><br></pre></td></tr></table></figure>\n\n\n<h3 id=\"平台特定实现\"><a href=\"#平台特定实现\" class=\"headerlink\" title=\"平台特定实现\"></a>平台特定实现</h3><p>UI 层面三端能够使用同一份代码，但为了体验，可能需要针对不同的设计，在桌面端可以设计更好地体验UI。这里避免不了 if-else 的UI逻辑，以及一些依赖各种系统的 api 需要单独实现，比如：深色模式监听、资源存储路径、系统信息、状态栏颜色等。</p>\n<p><strong>Android 端</strong><br>Android 特定的功能结合使用起来非常的简单，毕竟都是有血缘关系的。可以使用 AndroidView 直接渲染原生的 UI 页面。</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"code\"><pre><span class=\"line\">AndroidView(</span><br><span class=\"line\">      modifier = Modifier.fillMaxSize(),</span><br><span class=\"line\">      factory = &#123; context -&gt;</span><br><span class=\"line\">          MyView(context) &#125;</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      update = &#123; view -&gt;&#125;</span><br><span class=\"line\">  )</span><br></pre></td></tr></table></figure>\n\n<p><strong>iOS 端</strong><br>iOS端主要需要 XCode 进行配合，还需要关注开发者账号相关的信息等，其他与 Android 端实现没有太大的差异。</p>\n<p><strong>桌面端</strong><br>利用 Compose Desktop 的窗口管理，可以实现窗口多开。</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> = application &#123;</span><br><span class=\"line\">    Window(onCloseRequest = ::exitApplication) &#123;</span><br><span class=\"line\">        DesktopAppTheme &#123; AppContent() &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<h3 id=\"🚀-性能优化实践\"><a href=\"#🚀-性能优化实践\" class=\"headerlink\" title=\"🚀 性能优化实践\"></a>🚀 性能优化实践</h3><ol>\n<li><strong>分页加载</strong>：实现懒加载防止长列表卡顿</li>\n</ol>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"code\"><pre><span class=\"line\">LazyColumn &#123;</span><br><span class=\"line\">    itemsIndexed(posts) &#123; _, post -&gt;</span><br><span class=\"line\">        PostItem(post)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    item &#123; <span class=\"keyword\">if</span> (loading) LoadingIndicator() &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li><strong>本地缓存</strong>：DataStore 离线存储 + Ktor 缓存策略</li>\n</ol>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"code\"><pre><span class=\"line\">HttpClient &#123;</span><br><span class=\"line\">    install(HttpCache) <span class=\"comment\">// 启用 HTTP 缓存</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li><strong>图像处理</strong>：搭配 Coil 实现高效图片加载</li>\n</ol>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"code\"><pre><span class=\"line\">AsyncImage(</span><br><span class=\"line\">    modifier = Modifier.size(<span class=\"number\">80.</span>dp)</span><br><span class=\"line\">        .shadow(</span><br><span class=\"line\">            elevation = <span class=\"number\">5.</span>dp,</span><br><span class=\"line\">            shape = CircleShape,</span><br><span class=\"line\">            spotColor = Color.Black</span><br><span class=\"line\">        )</span><br><span class=\"line\">        .clip(CircleShape)</span><br><span class=\"line\">        .clickable &#123; &#125;,</span><br><span class=\"line\">    model = AppConfig.AVATAR,</span><br><span class=\"line\">    contentDescription = AppConfig.AVATAR,</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n<h3 id=\"开发经验总结\"><a href=\"#开发经验总结\" class=\"headerlink\" title=\"开发经验总结\"></a>开发经验总结</h3><ol>\n<li><p><strong>UI界面</strong><br>  使用 <a href=\"https://developer.android.com/compose\">Compose</a> 进行界面布局开发，声明性编程范式相比于传统的 xml 布局开发，高效很多，使用也很方便。使用了这种方式，传统的 UI 开发方式再也回不去了。</p>\n</li>\n<li><p><strong>状态管理</strong><br>使用 <code>mutableStateOf</code> 实现响应式更新，或者使用 <code>derivedStateOf</code> 实现派生状态的处理。</p>\n</li>\n</ol>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> pagIndex <span class=\"keyword\">by</span> remember &#123; mutableStateOf(<span class=\"number\">0</span>) &#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> errorState <span class=\"keyword\">by</span> remember &#123; mutableStateOf&lt;String?&gt;(<span class=\"literal\">null</span>) &#125;   </span><br><span class=\"line\"><span class=\"keyword\">val</span> themeState <span class=\"keyword\">by</span> mineViewModel.appTheme.collectAsState()</span><br><span class=\"line\"><span class=\"keyword\">val</span> uiChecked <span class=\"keyword\">by</span> remember(themeState) &#123; derivedStateOf &#123; themeState == ThemeConstants.DARK &#125; &#125;</span><br></pre></td></tr></table></figure>\n\n\n<ol start=\"3\">\n<li><strong>导航</strong></li>\n</ol>\n<p>实现 <code>Compose Navigator</code> 统一路由管理</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> gotoDebug: () -&gt; <span class=\"built_in\">Unit</span> = &#123;</span><br><span class=\"line\">    navController.navigate(Routes.Debug())</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">val</span> goToPostDetail: (Post) -&gt; <span class=\"built_in\">Unit</span> = &#123; it -&gt;</span><br><span class=\"line\">    navController.navigate(Routes.PostDetail(title = it.title, it.url))</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ol start=\"4\">\n<li><strong>Kotlin Flow</strong><br>简化异步编程，让网络请求的代码看起来更直观</li>\n</ol>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">loadAllPost</span><span class=\"params\">()</span></span>: Flow&lt;List&lt;PostV2&gt;&gt; = load(<span class=\"string\">&quot;allPosts&quot;</span>) &#123;</span><br><span class=\"line\">    postApi.getAllPost()?.<span class=\"keyword\">data</span> ?: emptyList()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">suspend</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">getAllPost</span><span class=\"params\">()</span></span>: SearchResponse? = request&lt;SearchResponse&gt;(getUrl(<span class=\"string\">&quot;api/search.json&quot;</span>))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">suspend</span> <span class=\"keyword\">inline</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"type\">&lt;<span class=\"keyword\">reified</span> T&gt;</span> <span class=\"title\">request</span><span class=\"params\">(url: <span class=\"type\">String</span>)</span></span>: T? &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        client.<span class=\"keyword\">get</span>(url).body()</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (e: Exception) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (e <span class=\"keyword\">is</span> CancellationException) <span class=\"keyword\">throw</span> e</span><br><span class=\"line\">        e.printStackTrace()</span><br><span class=\"line\">        <span class=\"literal\">null</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>经过一番各种折腾，将很多在工作上无法使用的能力（Koin、Flow、DataStore……）都体验使用了一下，在业余的时间完成了基于博客文章构建的 App 在三个平台上的开发，实际上最初我也想搭建 WebJs 的平台的，后面删除掉了，因为涉及到 web 平台开发的各种库相比客户端少很多，兼容起来也比较费劲。KMP&#x2F;CMP 这块技术确实是能很大地节省开发人力，多端使用同一份UI逻辑代码，部分逻辑也可以用 kotlin 统一进行封装，后续维护也会方便很多。但这里有个缺点就是涉及到的库所需要的 kotlin&#x2F;Java 版本要求比较高，除非开发一些独立的 App，否则公司里的项目想基于这些技术去实现不太大可能。以及如果所需要的能力比较依赖与原生，比如音视频领域就有一定的局限性，总体来讲更适合偏交互业务的开发。</p>\n<p><strong>项目源码</strong>: <a href=\"https://github.com/VomPom/blog_kmp\">https://github.com/VomPom/blog_kmp</a>  </p>\n","cover":null,"images":["https://cdn.julis.wang/github/blog_cmp/android.png","https://cdn.julis.wang/github/blog_cmp/dark.png","https://cdn.julis.wang/github/blog_cmp/ios.png","https://cdn.julis.wang/github/blog_cmp/desktop.png"],"content":"<h2 id=\"用-CMP-构建跨平台博客应用：一次-Kotlin-的全栈实践\"><a href=\"#用-CMP-构建跨平台博客应用：一次-Kotlin-的全栈实践\" class=\"headerlink\" title=\"用 CMP 构建跨平台博客应用：一次 Kotlin 的全栈实践\"></a>用 CMP 构建跨平台博客应用：一次 Kotlin 的全栈实践</h2><p>在追求高效开发的时代，跨平台技术已成为移动应用开发的主流选择，此前基于鸿蒙的开发平台开发 <a href=\"https://julis.wang/2025/05/16/%E9%B8%BF%E8%92%99-%E5%86%99%E4%BA%86%E4%B8%AA%E5%9F%BA%E4%BA%8EHexo%E5%8D%9A%E5%AE%A2%E7%9A%84%E9%B8%BF%E8%92%99App/\">blog_harmony</a>，将自己博客文章进行展示。本文将介绍基于 <strong>CMP(Compose Multiplatform)</strong> 构建的开源博客应用 <a href=\"https://github.com/VomPom/blog_kmp\">blog_kmp</a>，展示如何用 Kotlin 实现跨平台的应用开发。</p>\n<h3 id=\"Compose-Multiplatform\"><a href=\"#Compose-Multiplatform\" class=\"headerlink\" title=\"Compose Multiplatform\"></a>Compose Multiplatform</h3><p>Compose Multiplatform 是 JetBrains 推出的声明式 UI 框架，基于 Jetpack Compose 扩展而来：</p>\n<ul>\n<li><strong>核心优势</strong>：用同一套 Kotlin 代码构建 Android、iOS、Desktop 和 Web 应用</li>\n<li><strong>开发效率</strong>：实时预览、热重载加速开发迭代</li>\n<li><strong>原生性能</strong>：通过 Skia 渲染引擎实现接近原生体验</li>\n<li><strong>共享逻辑</strong>：业务逻辑、网络请求、状态管理可 100% 复用</li>\n</ul>\n<h3 id=\"项目架构与技术栈\"><a href=\"#项目架构与技术栈\" class=\"headerlink\" title=\"项目架构与技术栈\"></a>项目架构与技术栈</h3><p>blog_kmp 采用分层架构设计，核心模块包括：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"code\"><pre><span class=\"line\">shared/</span><br><span class=\"line\">├── src/commonMain/kotlin/  # 共享业务逻辑</span><br><span class=\"line\">│   ├── <span class=\"keyword\">data</span>/               # 数据层</span><br><span class=\"line\">│   ├── domain/             # 领域模型</span><br><span class=\"line\">│   └── presentation/       # UI状态管理</span><br><span class=\"line\">├── src/androidMain/        # Android 平台代码</span><br><span class=\"line\">└── src/iosMain/            # iOS 平台适配</span><br><span class=\"line\">├── composeApp</span><br><span class=\"line\">│   ├── build.gradle.kts</span><br><span class=\"line\">│   └── src</span><br><span class=\"line\">│       ├── androidMain     # Android 平台代码</span><br><span class=\"line\">│       ├── commonMain      # 共享业务逻辑</span><br><span class=\"line\">│            ├── App.kt     # 界面展示入口</span><br><span class=\"line\">│            ├── <span class=\"keyword\">data</span>       # 数据层</span><br><span class=\"line\">│            │   ├── api        # 网络请求</span><br><span class=\"line\">│            │   ├── di         # koin 依赖注入</span><br><span class=\"line\">│            │   ├── model      # model 数据</span><br><span class=\"line\">│            │   └── repository # 数据缓存管理</span><br><span class=\"line\">│            │</span><br><span class=\"line\">│            ├── navigation  # 页面间导航管理</span><br><span class=\"line\">│            ├── platform    # 通过对各个平台抽象的接口 </span><br><span class=\"line\">│            └── ui          # 通用 UI 逻辑</span><br><span class=\"line\">│</span><br><span class=\"line\">│       ├── desktopMain     # Desktop 平台适配</span><br><span class=\"line\">│       └── iosMain         # iOS 平台适配</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"功能预览\"><a href=\"#功能预览\" class=\"headerlink\" title=\"功能预览\"></a>功能预览</h2><h3 id=\"Android\"><a href=\"#Android\" class=\"headerlink\" title=\"Android\"></a>Android</h3><p><img src=\"https://cdn.julis.wang/github/blog_cmp/android.png\"></p>\n<h4 id=\"深色模式\"><a href=\"#深色模式\" class=\"headerlink\" title=\"深色模式\"></a>深色模式</h4><p><img src=\"https://cdn.julis.wang/github/blog_cmp/dark.png\"></p>\n<h3 id=\"iOS\"><a href=\"#iOS\" class=\"headerlink\" title=\"iOS\"></a>iOS</h3><p><img src=\"https://cdn.julis.wang/github/blog_cmp/ios.png\"></p>\n<h3 id=\"Desktop\"><a href=\"#Desktop\" class=\"headerlink\" title=\"Desktop\"></a>Desktop</h3><p><img src=\"https://cdn.julis.wang/github/blog_cmp/desktop.png\"></p>\n<h4 id=\"主要技术栈\"><a href=\"#主要技术栈\" class=\"headerlink\" title=\"主要技术栈\"></a>主要技术栈</h4><ol>\n<li><strong>Ktor 客户端</strong> - 网络请求</li>\n</ol>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> httpClient = HttpClient &#123;</span><br><span class=\"line\">    install(ContentNegotiation) &#123;</span><br><span class=\"line\">        json(Json &#123; ignoreUnknownKeys = <span class=\"literal\">true</span> &#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">suspend</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">loadPosts</span><span class=\"params\">()</span></span>: List&lt;Post&gt; = </span><br><span class=\"line\">    httpClient.<span class=\"keyword\">get</span>(<span class=\"string\">&quot;https://cdn.julis/api/posts&quot;</span>).body()</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li><strong>DataStore</strong> - 跨平台数据库</li>\n</ol>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> dataKey = stringPreferencesKey(key)</span><br><span class=\"line\"><span class=\"keyword\">val</span> result = dataStore.<span class=\"keyword\">data</span></span><br><span class=\"line\">    .<span class=\"keyword\">catch</span> &#123; exception -&gt;</span><br><span class=\"line\">        <span class=\"comment\">// dataStore.data throws an IOException when an error is encountered when reading data</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (exception <span class=\"keyword\">is</span> IOException) &#123;</span><br><span class=\"line\">            emit(emptyPreferences())</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> exception</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    .map &#123; preferences -&gt;</span><br><span class=\"line\">        <span class=\"keyword\">val</span> <span class=\"keyword\">data</span>: String? = preferences[dataKey]</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">data</span> == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"literal\">null</span></span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (isJson) Json.decodeFromString&lt;T&gt;(<span class=\"keyword\">data</span>) <span class=\"keyword\">else</span> (<span class=\"keyword\">data</span> <span class=\"keyword\">as</span> T)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li><strong>Koin</strong> - 依赖注入</li>\n</ol>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> sharedModule = module &#123;</span><br><span class=\"line\">    single&lt;PostRepository&gt; &#123; PostRepositoryImpl(<span class=\"keyword\">get</span>()) &#125;</span><br><span class=\"line\">    viewModel &#123; PostViewModel(<span class=\"keyword\">get</span>()) &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"4\">\n<li><strong>Kotlinx.Serialization</strong> - JSON 解析</li>\n</ol>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Serializable</span></span><br><span class=\"line\"><span class=\"keyword\">data</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Post</span>(</span><br><span class=\"line\">    <span class=\"keyword\">val</span> id: String,</span><br><span class=\"line\">    <span class=\"keyword\">val</span> title: String,</span><br><span class=\"line\">    <span class=\"keyword\">val</span> content: String</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n\n<ol start=\"5\">\n<li><strong>compose-webview-multiplatform</strong> - WebView 浏览器<br>使用的第三方开发<a href=\"https://github.com/KevinnZou/compose-webview-multiplatform\">compose-webview-multiplatform</a>基于 <a href=\"https://github.com/chromiumembedded/java-cef\">java-cef</a>开发，不过这个library 在 desktop 平台表现不是太好，待完善。</li>\n</ol>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> state = rememberWebViewState(postUrl)</span><br><span class=\"line\"> WebView(state = state,modifier = Modifier.fillMaxSize())            </span><br></pre></td></tr></table></figure>\n\n\n<h3 id=\"平台特定实现\"><a href=\"#平台特定实现\" class=\"headerlink\" title=\"平台特定实现\"></a>平台特定实现</h3><p>UI 层面三端能够使用同一份代码，但为了体验，可能需要针对不同的设计，在桌面端可以设计更好地体验UI。这里避免不了 if-else 的UI逻辑，以及一些依赖各种系统的 api 需要单独实现，比如：深色模式监听、资源存储路径、系统信息、状态栏颜色等。</p>\n<p><strong>Android 端</strong><br>Android 特定的功能结合使用起来非常的简单，毕竟都是有血缘关系的。可以使用 AndroidView 直接渲染原生的 UI 页面。</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"code\"><pre><span class=\"line\">AndroidView(</span><br><span class=\"line\">      modifier = Modifier.fillMaxSize(),</span><br><span class=\"line\">      factory = &#123; context -&gt;</span><br><span class=\"line\">          MyView(context) &#125;</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      update = &#123; view -&gt;&#125;</span><br><span class=\"line\">  )</span><br></pre></td></tr></table></figure>\n\n<p><strong>iOS 端</strong><br>iOS端主要需要 XCode 进行配合，还需要关注开发者账号相关的信息等，其他与 Android 端实现没有太大的差异。</p>\n<p><strong>桌面端</strong><br>利用 Compose Desktop 的窗口管理，可以实现窗口多开。</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> = application &#123;</span><br><span class=\"line\">    Window(onCloseRequest = ::exitApplication) &#123;</span><br><span class=\"line\">        DesktopAppTheme &#123; AppContent() &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<h3 id=\"🚀-性能优化实践\"><a href=\"#🚀-性能优化实践\" class=\"headerlink\" title=\"🚀 性能优化实践\"></a>🚀 性能优化实践</h3><ol>\n<li><strong>分页加载</strong>：实现懒加载防止长列表卡顿</li>\n</ol>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"code\"><pre><span class=\"line\">LazyColumn &#123;</span><br><span class=\"line\">    itemsIndexed(posts) &#123; _, post -&gt;</span><br><span class=\"line\">        PostItem(post)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    item &#123; <span class=\"keyword\">if</span> (loading) LoadingIndicator() &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li><strong>本地缓存</strong>：DataStore 离线存储 + Ktor 缓存策略</li>\n</ol>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"code\"><pre><span class=\"line\">HttpClient &#123;</span><br><span class=\"line\">    install(HttpCache) <span class=\"comment\">// 启用 HTTP 缓存</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li><strong>图像处理</strong>：搭配 Coil 实现高效图片加载</li>\n</ol>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"code\"><pre><span class=\"line\">AsyncImage(</span><br><span class=\"line\">    modifier = Modifier.size(<span class=\"number\">80.</span>dp)</span><br><span class=\"line\">        .shadow(</span><br><span class=\"line\">            elevation = <span class=\"number\">5.</span>dp,</span><br><span class=\"line\">            shape = CircleShape,</span><br><span class=\"line\">            spotColor = Color.Black</span><br><span class=\"line\">        )</span><br><span class=\"line\">        .clip(CircleShape)</span><br><span class=\"line\">        .clickable &#123; &#125;,</span><br><span class=\"line\">    model = AppConfig.AVATAR,</span><br><span class=\"line\">    contentDescription = AppConfig.AVATAR,</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n<h3 id=\"开发经验总结\"><a href=\"#开发经验总结\" class=\"headerlink\" title=\"开发经验总结\"></a>开发经验总结</h3><ol>\n<li><p><strong>UI界面</strong><br>  使用 <a href=\"https://developer.android.com/compose\">Compose</a> 进行界面布局开发，声明性编程范式相比于传统的 xml 布局开发，高效很多，使用也很方便。使用了这种方式，传统的 UI 开发方式再也回不去了。</p>\n</li>\n<li><p><strong>状态管理</strong><br>使用 <code>mutableStateOf</code> 实现响应式更新，或者使用 <code>derivedStateOf</code> 实现派生状态的处理。</p>\n</li>\n</ol>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> pagIndex <span class=\"keyword\">by</span> remember &#123; mutableStateOf(<span class=\"number\">0</span>) &#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> errorState <span class=\"keyword\">by</span> remember &#123; mutableStateOf&lt;String?&gt;(<span class=\"literal\">null</span>) &#125;   </span><br><span class=\"line\"><span class=\"keyword\">val</span> themeState <span class=\"keyword\">by</span> mineViewModel.appTheme.collectAsState()</span><br><span class=\"line\"><span class=\"keyword\">val</span> uiChecked <span class=\"keyword\">by</span> remember(themeState) &#123; derivedStateOf &#123; themeState == ThemeConstants.DARK &#125; &#125;</span><br></pre></td></tr></table></figure>\n\n\n<ol start=\"3\">\n<li><strong>导航</strong></li>\n</ol>\n<p>实现 <code>Compose Navigator</code> 统一路由管理</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> gotoDebug: () -&gt; <span class=\"built_in\">Unit</span> = &#123;</span><br><span class=\"line\">    navController.navigate(Routes.Debug())</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">val</span> goToPostDetail: (Post) -&gt; <span class=\"built_in\">Unit</span> = &#123; it -&gt;</span><br><span class=\"line\">    navController.navigate(Routes.PostDetail(title = it.title, it.url))</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ol start=\"4\">\n<li><strong>Kotlin Flow</strong><br>简化异步编程，让网络请求的代码看起来更直观</li>\n</ol>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">loadAllPost</span><span class=\"params\">()</span></span>: Flow&lt;List&lt;PostV2&gt;&gt; = load(<span class=\"string\">&quot;allPosts&quot;</span>) &#123;</span><br><span class=\"line\">    postApi.getAllPost()?.<span class=\"keyword\">data</span> ?: emptyList()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">suspend</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">getAllPost</span><span class=\"params\">()</span></span>: SearchResponse? = request&lt;SearchResponse&gt;(getUrl(<span class=\"string\">&quot;api/search.json&quot;</span>))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">suspend</span> <span class=\"keyword\">inline</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"type\">&lt;<span class=\"keyword\">reified</span> T&gt;</span> <span class=\"title\">request</span><span class=\"params\">(url: <span class=\"type\">String</span>)</span></span>: T? &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        client.<span class=\"keyword\">get</span>(url).body()</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (e: Exception) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (e <span class=\"keyword\">is</span> CancellationException) <span class=\"keyword\">throw</span> e</span><br><span class=\"line\">        e.printStackTrace()</span><br><span class=\"line\">        <span class=\"literal\">null</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>经过一番各种折腾，将很多在工作上无法使用的能力（Koin、Flow、DataStore……）都体验使用了一下，在业余的时间完成了基于博客文章构建的 App 在三个平台上的开发，实际上最初我也想搭建 WebJs 的平台的，后面删除掉了，因为涉及到 web 平台开发的各种库相比客户端少很多，兼容起来也比较费劲。KMP&#x2F;CMP 这块技术确实是能很大地节省开发人力，多端使用同一份UI逻辑代码，部分逻辑也可以用 kotlin 统一进行封装，后续维护也会方便很多。但这里有个缺点就是涉及到的库所需要的 kotlin&#x2F;Java 版本要求比较高，除非开发一些独立的 App，否则公司里的项目想基于这些技术去实现不太大可能。以及如果所需要的能力比较依赖与原生，比如音视频领域就有一定的局限性，总体来讲更适合偏交互业务的开发。</p>\n<p><strong>项目源码</strong>: <a href=\"https://github.com/VomPom/blog_kmp\">https://github.com/VomPom/blog_kmp</a>  </p>\n","categories":[{"name":"思考总结","slug":"thinking","api":"api/categories/thinking.json"}],"tags":[{"name":"KMP","slug":"KMP","api":"api/tags/KMP.json"}],"api":"api/posts/2025/07/28/Compose-Multiplatform-跨平台博客应用实践.json"},{"title":"[鸿蒙]写了个基于Hexo博客的鸿蒙App","slug":"鸿蒙-写了个基于Hexo博客的鸿蒙App","date":"2025-05-16T12:10:00.000Z","updated":"2025-07-28T14:52:28.959Z","comments":true,"url":"2025/05/16/鸿蒙-写了个基于Hexo博客的鸿蒙App/","excerpt":"<p>最近部门也在跟进<a href=\"https://www.harmonyos.com/\">鸿蒙</a>平台的业务开发，自己主要是做 Android 开发，主要使用 Kotlin&#x2F;Java 语言。，需要对新的开发平台和开发模式进行学习，在业余时间开了个项目练手，做了个基于 Hexo 博客内容开发的App。鸿蒙主要使用<a href=\"https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts\">ArkTS语言</a>和<a href=\"https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkui\">ArkUI框架</a>进行开发，有使用 <a href=\"https://developer.android.com/compose\">Jetpack Compose</a> 和 JavaScript&#x2F;TypeScript 的开发经验的话，上手会比较的轻松。本文主要介绍做的App功能以及对鸿蒙开发的一个总结。</p>\n<h2 id=\"App-简介\"><a href=\"#App-简介\" class=\"headerlink\" title=\"App 简介\"></a>App 简介</h2><p>后台数据来自 <a href=\"https://hexo.io/\">Hexo</a> 生成的博客文章，利用 <a href=\"https://github.com/ryanuo/hexo-generator-wxapi\">hexo-generator-wxapi</a> 生成 api .json 文件，再利用 <a href=\"https://www.qiniu.com/\">七牛云</a> 提供对图片和 .json 文件 CDN。</p>\n<p>实现的功能</p>\n<ul>\n<li>博客列表分页加载</li>\n<li>文章详情加载</li>\n<li>文章按分类&#x2F;标签展示</li>\n<li>文章内容统计</li>\n<li>深色&#x2F;浅色模式切换</li>\n<li>数据本地缓存</li>\n</ul>\n<h3 id=\"功能预览\"><a href=\"#功能预览\" class=\"headerlink\" title=\"功能预览\"></a>功能预览</h3><table>\n<thead>\n<tr>\n<th></th>\n<th></th>\n<th></th>\n<th></th>\n<th></th>\n<th></th>\n</tr>\n</thead>\n<tbody><tr>\n<td><img src=\"https://cdn.julis.wang/github/blog_harmony/light_blog_list.jpeg\"  alt=\"博客列表\" /></td>\n<td><img src=\"https://cdn.julis.wang/github/blog_harmony/light_stats.jpeg\"  alt=\"统计\" /></td>\n<td><img src=\"https://cdn.julis.wang/github/blog_harmony/light_mine.jpeg\" alt=\"个人\" /></td>\n<td><img src=\"https://cdn.julis.wang/github/blog_harmony/light_detail.jpeg\"  alt=\"文章详情\" /></td>\n<td><img src=\"https://cdn.julis.wang/github/blog_harmony/light_category.jpeg\"  alt=\"分类\" /></td>\n<td><img src=\"https://cdn.julis.wang/github/blog_harmony/light_tag.jpeg\"  alt=\"标签\" /></td>\n</tr>\n</tbody></table>\n<h3 id=\"依赖项\"><a href=\"#依赖项\" class=\"headerlink\" title=\"依赖项\"></a>依赖项</h3><h4 id=\"Hexo\"><a href=\"#Hexo\" class=\"headerlink\" title=\"Hexo\"></a>Hexo</h4><ul>\n<li><a href=\"https://hexo.io/\">Hexo</a> 快速、简洁且高效的博客框架</li>\n<li><a href=\"https://github.com/ryanuo/hexo-generator-wxapi\">hexo-generator-wxapi</a> 用于将 Hexo 博客内容生成 api 风格的.json文件</li>\n<li><a href=\"https://www.qiniu.com/\">七牛云</a> 提供对图片和.json文件 CDN加速</li>\n</ul>\n<h4 id=\"HarmonyOS\"><a href=\"#HarmonyOS\" class=\"headerlink\" title=\"HarmonyOS\"></a>HarmonyOS</h4><ul>\n<li><a href=\"https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts\">ArkTS</a> ArkTS在TypeScript（简称TS）生态基础上做了进一步扩展，保持了TS的基本风格，同时通过规范定义强化开发期静态检查和分析，提升代码健壮性，并实现更好的程序执行稳定性和性能。</li>\n<li><a href=\"https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkui\">ArkUI</a>  ArkUI（方舟UI框架）为应用的UI开发提供了完整的基础设施，包括简洁的UI语法、丰富的UI功能（组件、布局、动画以及交互事件），以及实时界面预览工具等，可以支持开发者进行可视化界面开发。</li>\n<li><a href=\"https://gitee.com/openharmony-sig/ohos_pull_to_refresh\">ohos_pull_to_refresh</a> 列表加载&#x2F;刷新控件(没有’No more’的状态)</li>\n<li><a href=\"https://github.com/Tencent/MMKV\">MMKV</a> 是基于 mmap 内存映射的 key-value 组件</li>\n</ul>\n<h2 id=\"鸿蒙开发总结\"><a href=\"#鸿蒙开发总结\" class=\"headerlink\" title=\"鸿蒙开发总结\"></a>鸿蒙开发总结</h2><h3 id=\"ArkTs-语言\"><a href=\"#ArkTs-语言\" class=\"headerlink\" title=\"ArkTs 语言\"></a>ArkTs 语言</h3><p>ArkTS 是 TypeScript 的超集，TypeScript 又是 JavaScript 的超集，所以对于基本数据类型使用的是 TypeScript 语法。他们三者的关系如下图所示：</p>\n  <img src=\"https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtybbs/713/408/959/0030086000713408959.20241009110308.85777546121432927171131630988896:50001231000000:2800:D599CEDEC4315A859E47A08CEC5D4D3E334431F82ABC9FD0E9B6AD0F91CD2FF5.png\" width=\"80%\" alt=\"ArkTS与TypeScript的关系\" />\n\n<p>相关的差异可以参考社区话题讨论 <a href=\"https://developer.huawei.com/consumer/cn/forum/topic/0203163854317501934\">ArkTS与Typescript的区别？\n</a></p>\n<p>这里主要记录一下自己使用过程中踩过的坑：</p>\n<h4 id=\"基本语言类型\"><a href=\"#基本语言类型\" class=\"headerlink\" title=\"基本语言类型\"></a>基本语言类型</h4><p>Number 和 number 是两个不同的类型，Number 是 JavaScript 中的一个全局对象，可以使用 new Number() 来创建一个 Number 对象。同理对于 String 和 string，Boolean 和 boolean 也是一样的，大写开头的是<strong>包装对象类型</strong>，小写的是<strong>原始类型</strong>，这点Java&#x2F;kotlin也有类似的包装对象比较好理解，但 Object 居然也有大小写之区分相比难理解点，写代码的时候好几次忽略了这个事，<strong>Object</strong> 是所有对象的基类，object 表示非原始类型（即不是 number、string、boolean、symbol、null 或 undefined 的所有类型）。可以是任何对象、数组、函数、类实例等。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">let obj: object;</span><br><span class=\"line\">obj = &#123; a: 1 &#125;;         // ✅ 正确：普通对象</span><br><span class=\"line\">obj = [1, 2, 3];        // ✅ 正确：数组</span><br><span class=\"line\">obj = () =&gt; &#123;&#125;;         // ✅ 正确：函数</span><br><span class=\"line\">obj = new Date();       // ✅ 正确：类实例</span><br><span class=\"line\"></span><br><span class=\"line\">obj = 42;               // ❌ 错误：原始类型 number</span><br><span class=\"line\">obj = &quot;hello&quot;;          // ❌ 错误：原始类型 string</span><br></pre></td></tr></table></figure>\n<p>两则的区别</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">特性</th>\n<th align=\"left\">object</th>\n<th align=\"left\">Object</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><strong>允许的值</strong></td>\n<td align=\"left\">仅非原始类型（对象、数组等）</td>\n<td align=\"left\">任意类型（包括原始值）</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>原始值处理</strong></td>\n<td align=\"left\">禁止</td>\n<td align=\"left\">自动装箱（如 42 → Number）</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>使用场景</strong></td>\n<td align=\"left\">明确限制为非原始类型时</td>\n<td align=\"left\">极少使用（通常用 unknown 或具体类型替代）</td>\n</tr>\n</tbody></table>\n<h4 id=\"Map-等集合类当作普通-JavaScript-对象来操作\"><a href=\"#Map-等集合类当作普通-JavaScript-对象来操作\" class=\"headerlink\" title=\"Map 等集合类当作普通 JavaScript 对象来操作\"></a>Map 等集合类当作普通 JavaScript 对象来操作</h4><figure class=\"highlight ts\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> map = <span class=\"keyword\">new</span> <span class=\"title class_\">Map</span>&lt;<span class=\"built_in\">string</span>, <span class=\"built_in\">object</span>&gt;();</span><br><span class=\"line\">map[<span class=\"string\">&quot;key&quot;</span>] = value;            <span class=\"comment\">// ❌ 错误用法！</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(map.<span class=\"title function_\">get</span>(<span class=\"string\">&quot;biz&quot;</span>));   <span class=\"comment\">// ❌ 输出 undefined</span></span><br></pre></td></tr></table></figure>\n<p>最开始挺奇怪的 map 明明设置了值，但是对应的 map size 为0，遍历 map 也没有数据。后来才发现是这种方式 不会 触发 Map 的内部机制，而是绕过了 Map 的方法，直接操作对象的属性，赋值后，键值对 不会 被存入 Map 的真实存储中，而是作为对象的普通属性存在。正确的用法是：</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> map = <span class=\"keyword\">new</span> <span class=\"title class_\">Map</span>&lt;<span class=\"built_in\">string</span>, <span class=\"built_in\">object</span>&gt;();</span><br><span class=\"line\">map.<span class=\"property\">set</span>[<span class=\"string\">&quot;key&quot;</span>] = value;        <span class=\"comment\">//  ✅ 正确用法！</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(map.<span class=\"title function_\">get</span>(<span class=\"string\">&quot;biz&quot;</span>));   <span class=\"comment\">//  ✅ 输出 value</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"struct-的困扰\"><a href=\"#struct-的困扰\" class=\"headerlink\" title=\"struct 的困扰\"></a>struct 的困扰</h4><p>在 js 里面是没有 <code>struct</code> 这个关键词的，从刚接触到现在它唯一的作用就是：和 <code>@Component</code>绑定声明一个UI控件。例如：</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> struct <span class=\"title class_\">ToolBar</span>&#123;&#125;</span><br></pre></td></tr></table></figure>\n<p><code>@Component</code> 和 <code>struct</code> 两则缺一不可，既然必须有 <code>@Component</code>来标注这是一个UI控件，为什么不能下面这样呢？能省掉一个关键字。</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ToolBar</span> &#123;&#125;</span><br></pre></td></tr></table></figure>\n<p>同样困扰的人还有很多，这里有一份讨论<a href=\"https://developer.huawei.com/consumer/cn/forum/topic/0204135301248599134\">定义组件时的stuct关键字是什么？</a><br>官方也有一份聊胜于无的介绍</p>\n<blockquote>\n<p>struct和class的区别是什么? </p>\n<p>struct只在自定义组件中使用，@Component装饰的struct就是自定义组件，自定义组件和class是两个概念，自定义组件没有类型，也不能等同于class。如果开发者需要使用组件作为参数在组件之间传递，可以使用自定义占位节点。</p>\n</blockquote>\n<p>我猜测这样是为了省掉对<code>@Component</code>装饰器编译的工作量，如果使用 class 声明，那么声明的UI控件就有“面向对象”的能力，实际上只希望它是一个UI控件声明，不需要它有其他的能力。难道不能对 <code>@Component</code> 装饰过的对象收回“面向对象”的能力么？当然能啊，估计要做很多编译检查的事儿。另外，从开发理解的层面上来讲，它确实也已经不是”对象”了，它只是一个干巴巴的一个UI结构，所以干脆就搞了一个新的关键词 struct。</p>\n<h3 id=\"ArkUI-框架\"><a href=\"#ArkUI-框架\" class=\"headerlink\" title=\"ArkUI 框架\"></a>ArkUI 框架</h3><p>整体框架使用的方式和 <a href=\"https://developer.android.com/compose\">Jetpack Compose</a> 类似，都是声明式UI框架。compose 里面使用  <code>@Composable</code>来标记某个方法这个方法便成了<code>UI控件</code>，控件里面的状态管理使用 <code>remember</code>+ <code>mutableState</code>来控制。而 ArkUI 通过 @State、@Link、@Prop 等装饰器来控制。了解了这些个装饰器的用法，基本上就能理解 ArkUI 的开发流程了。</p>\n<h4 id=\"构建-UI-的-Component-Builder\"><a href=\"#构建-UI-的-Component-Builder\" class=\"headerlink\" title=\"构建 UI 的 @Component @Builder\"></a>构建 UI 的 @Component @Builder</h4><p>@Component 和 @Builder 组合起来实现的差不多就是 Compose 里面使用  <code>@Composable</code> 装饰某个方法的作用，用于构建 UI 或可复用的逻辑单元。<br><strong>@Component</strong><br>用于创建一个自定义组件，组件可以包含独立的 UI 结构、状态管理和生命周期。</p>\n<p><strong>@Builder</strong><br>定义可复用的 UI 片段，用于创建一个UI 构建函数，封装一段可复用的 UI 代码块。不是独立组件，而是嵌入到其他组件或布局中执行，主要作用是复用和逻辑隔离，例如：关于页面，里面的文本是差不多的样式，只是内容不一样，那么只需要保留一个 text 属性出来接收参数。或者某块UI比较复杂，可以抽离一部分UI成为一个独立的UI逻辑模块。</p>\n<h3 id=\"构建-UI-的状态控制装饰器\"><a href=\"#构建-UI-的状态控制装饰器\" class=\"headerlink\" title=\"构建 UI 的状态控制装饰器\"></a>构建 UI 的状态控制装饰器</h3><p><strong>@State</strong><br>比较常用的装饰器，和 Compose 里面 remember+mutableStateOf 的作用差不多，对应的值改变之后，对相关的使用到该属性UI的地方进行刷新。</p>\n<p><strong>@Prop</strong><br>@Prop 装饰的变量和父组件建立单向的同步关系，@Prop变量允许在本地修改，但修改后的变化不会同步回父组件。</p>\n<p>也就是在某个 @Component 的组件内有一个 @State 装饰的属性，传递到子 @Component 组件 @Prop 修饰的属性。子控件对这个属性修改之后，父控件不会对这个改变感知，父控件UI不会改变。</p>\n<p><strong>@Link</strong><br>子组件中被@Link装饰的变量与其父组件中对应的数据源建立双向数据绑定。<br>跟 @Prop 的作用类似，不过是双向的，子控件对这个属性修改之后，父控件会感知这个变化，父控件UI会随着这个属性改变而改变。</p>\n<p><strong>@BuilderParam</strong><br>主要用于动态注入 UI 构建逻辑（即 @Builder 函数），实现父组件向子组件传递可定制的 UI 片段，也就是向子控件传递 UI 参数。</p>\n<p>基本上比较常用到的就这些，还有很多例如：@LocalBuilder @StorageLink @Styles等，都是为了解决开发过过程中遇到的问题，但是只要掌握了 ArkUI UI组件的声明周期和状态管理的基本原理理解其他装饰器还是比较简单的。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>总体开发体验下来，鸿蒙开发学习成本并不是特别高，比较快能上手，但设计的 api 更像一个缝合怪，且使用上不太收敛。很多库还需要再建设，例如音视频开发对应的支持库还不是特别成熟。不过，作为一个从头搞的生态来说能实现成这样已经很不错了，就像此前武磊登陆西甲，以及目前被看好的青年新星王钰栋，都是”自己的孩子”，需要迈出第一步。现在，很多公司也在适配鸿蒙了，期待未来能从 Android 跟 iOS 的生态中争夺出一片大市场。</p>\n<p>项目源码：<a href=\"https://github.com/VomPom/blog_harmony\">https://github.com/VomPom/blog_harmony</a></p>\n","cover":null,"images":["https://cdn.julis.wang/github/blog_harmony/light_blog_list.jpeg","https://cdn.julis.wang/github/blog_harmony/light_stats.jpeg","https://cdn.julis.wang/github/blog_harmony/light_mine.jpeg","https://cdn.julis.wang/github/blog_harmony/light_detail.jpeg","https://cdn.julis.wang/github/blog_harmony/light_category.jpeg","https://cdn.julis.wang/github/blog_harmony/light_tag.jpeg","https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtybbs/713/408/959/0030086000713408959.20241009110308.85777546121432927171131630988896:50001231000000:2800:D599CEDEC4315A859E47A08CEC5D4D3E334431F82ABC9FD0E9B6AD0F91CD2FF5.png"],"content":"<p>最近部门也在跟进<a href=\"https://www.harmonyos.com/\">鸿蒙</a>平台的业务开发，自己主要是做 Android 开发，主要使用 Kotlin&#x2F;Java 语言。，需要对新的开发平台和开发模式进行学习，在业余时间开了个项目练手，做了个基于 Hexo 博客内容开发的App。鸿蒙主要使用<a href=\"https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts\">ArkTS语言</a>和<a href=\"https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkui\">ArkUI框架</a>进行开发，有使用 <a href=\"https://developer.android.com/compose\">Jetpack Compose</a> 和 JavaScript&#x2F;TypeScript 的开发经验的话，上手会比较的轻松。本文主要介绍做的App功能以及对鸿蒙开发的一个总结。</p>\n<h2 id=\"App-简介\"><a href=\"#App-简介\" class=\"headerlink\" title=\"App 简介\"></a>App 简介</h2><p>后台数据来自 <a href=\"https://hexo.io/\">Hexo</a> 生成的博客文章，利用 <a href=\"https://github.com/ryanuo/hexo-generator-wxapi\">hexo-generator-wxapi</a> 生成 api .json 文件，再利用 <a href=\"https://www.qiniu.com/\">七牛云</a> 提供对图片和 .json 文件 CDN。</p>\n<p>实现的功能</p>\n<ul>\n<li>博客列表分页加载</li>\n<li>文章详情加载</li>\n<li>文章按分类&#x2F;标签展示</li>\n<li>文章内容统计</li>\n<li>深色&#x2F;浅色模式切换</li>\n<li>数据本地缓存</li>\n</ul>\n<h3 id=\"功能预览\"><a href=\"#功能预览\" class=\"headerlink\" title=\"功能预览\"></a>功能预览</h3><table>\n<thead>\n<tr>\n<th></th>\n<th></th>\n<th></th>\n<th></th>\n<th></th>\n<th></th>\n</tr>\n</thead>\n<tbody><tr>\n<td><img src=\"https://cdn.julis.wang/github/blog_harmony/light_blog_list.jpeg\"  alt=\"博客列表\" /></td>\n<td><img src=\"https://cdn.julis.wang/github/blog_harmony/light_stats.jpeg\"  alt=\"统计\" /></td>\n<td><img src=\"https://cdn.julis.wang/github/blog_harmony/light_mine.jpeg\" alt=\"个人\" /></td>\n<td><img src=\"https://cdn.julis.wang/github/blog_harmony/light_detail.jpeg\"  alt=\"文章详情\" /></td>\n<td><img src=\"https://cdn.julis.wang/github/blog_harmony/light_category.jpeg\"  alt=\"分类\" /></td>\n<td><img src=\"https://cdn.julis.wang/github/blog_harmony/light_tag.jpeg\"  alt=\"标签\" /></td>\n</tr>\n</tbody></table>\n<h3 id=\"依赖项\"><a href=\"#依赖项\" class=\"headerlink\" title=\"依赖项\"></a>依赖项</h3><h4 id=\"Hexo\"><a href=\"#Hexo\" class=\"headerlink\" title=\"Hexo\"></a>Hexo</h4><ul>\n<li><a href=\"https://hexo.io/\">Hexo</a> 快速、简洁且高效的博客框架</li>\n<li><a href=\"https://github.com/ryanuo/hexo-generator-wxapi\">hexo-generator-wxapi</a> 用于将 Hexo 博客内容生成 api 风格的.json文件</li>\n<li><a href=\"https://www.qiniu.com/\">七牛云</a> 提供对图片和.json文件 CDN加速</li>\n</ul>\n<h4 id=\"HarmonyOS\"><a href=\"#HarmonyOS\" class=\"headerlink\" title=\"HarmonyOS\"></a>HarmonyOS</h4><ul>\n<li><a href=\"https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts\">ArkTS</a> ArkTS在TypeScript（简称TS）生态基础上做了进一步扩展，保持了TS的基本风格，同时通过规范定义强化开发期静态检查和分析，提升代码健壮性，并实现更好的程序执行稳定性和性能。</li>\n<li><a href=\"https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkui\">ArkUI</a>  ArkUI（方舟UI框架）为应用的UI开发提供了完整的基础设施，包括简洁的UI语法、丰富的UI功能（组件、布局、动画以及交互事件），以及实时界面预览工具等，可以支持开发者进行可视化界面开发。</li>\n<li><a href=\"https://gitee.com/openharmony-sig/ohos_pull_to_refresh\">ohos_pull_to_refresh</a> 列表加载&#x2F;刷新控件(没有’No more’的状态)</li>\n<li><a href=\"https://github.com/Tencent/MMKV\">MMKV</a> 是基于 mmap 内存映射的 key-value 组件</li>\n</ul>\n<h2 id=\"鸿蒙开发总结\"><a href=\"#鸿蒙开发总结\" class=\"headerlink\" title=\"鸿蒙开发总结\"></a>鸿蒙开发总结</h2><h3 id=\"ArkTs-语言\"><a href=\"#ArkTs-语言\" class=\"headerlink\" title=\"ArkTs 语言\"></a>ArkTs 语言</h3><p>ArkTS 是 TypeScript 的超集，TypeScript 又是 JavaScript 的超集，所以对于基本数据类型使用的是 TypeScript 语法。他们三者的关系如下图所示：</p>\n  <img src=\"https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtybbs/713/408/959/0030086000713408959.20241009110308.85777546121432927171131630988896:50001231000000:2800:D599CEDEC4315A859E47A08CEC5D4D3E334431F82ABC9FD0E9B6AD0F91CD2FF5.png\" width=\"80%\" alt=\"ArkTS与TypeScript的关系\" />\n\n<p>相关的差异可以参考社区话题讨论 <a href=\"https://developer.huawei.com/consumer/cn/forum/topic/0203163854317501934\">ArkTS与Typescript的区别？\n</a></p>\n<p>这里主要记录一下自己使用过程中踩过的坑：</p>\n<h4 id=\"基本语言类型\"><a href=\"#基本语言类型\" class=\"headerlink\" title=\"基本语言类型\"></a>基本语言类型</h4><p>Number 和 number 是两个不同的类型，Number 是 JavaScript 中的一个全局对象，可以使用 new Number() 来创建一个 Number 对象。同理对于 String 和 string，Boolean 和 boolean 也是一样的，大写开头的是<strong>包装对象类型</strong>，小写的是<strong>原始类型</strong>，这点Java&#x2F;kotlin也有类似的包装对象比较好理解，但 Object 居然也有大小写之区分相比难理解点，写代码的时候好几次忽略了这个事，<strong>Object</strong> 是所有对象的基类，object 表示非原始类型（即不是 number、string、boolean、symbol、null 或 undefined 的所有类型）。可以是任何对象、数组、函数、类实例等。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">let obj: object;</span><br><span class=\"line\">obj = &#123; a: 1 &#125;;         // ✅ 正确：普通对象</span><br><span class=\"line\">obj = [1, 2, 3];        // ✅ 正确：数组</span><br><span class=\"line\">obj = () =&gt; &#123;&#125;;         // ✅ 正确：函数</span><br><span class=\"line\">obj = new Date();       // ✅ 正确：类实例</span><br><span class=\"line\"></span><br><span class=\"line\">obj = 42;               // ❌ 错误：原始类型 number</span><br><span class=\"line\">obj = &quot;hello&quot;;          // ❌ 错误：原始类型 string</span><br></pre></td></tr></table></figure>\n<p>两则的区别</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">特性</th>\n<th align=\"left\">object</th>\n<th align=\"left\">Object</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><strong>允许的值</strong></td>\n<td align=\"left\">仅非原始类型（对象、数组等）</td>\n<td align=\"left\">任意类型（包括原始值）</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>原始值处理</strong></td>\n<td align=\"left\">禁止</td>\n<td align=\"left\">自动装箱（如 42 → Number）</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>使用场景</strong></td>\n<td align=\"left\">明确限制为非原始类型时</td>\n<td align=\"left\">极少使用（通常用 unknown 或具体类型替代）</td>\n</tr>\n</tbody></table>\n<h4 id=\"Map-等集合类当作普通-JavaScript-对象来操作\"><a href=\"#Map-等集合类当作普通-JavaScript-对象来操作\" class=\"headerlink\" title=\"Map 等集合类当作普通 JavaScript 对象来操作\"></a>Map 等集合类当作普通 JavaScript 对象来操作</h4><figure class=\"highlight ts\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> map = <span class=\"keyword\">new</span> <span class=\"title class_\">Map</span>&lt;<span class=\"built_in\">string</span>, <span class=\"built_in\">object</span>&gt;();</span><br><span class=\"line\">map[<span class=\"string\">&quot;key&quot;</span>] = value;            <span class=\"comment\">// ❌ 错误用法！</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(map.<span class=\"title function_\">get</span>(<span class=\"string\">&quot;biz&quot;</span>));   <span class=\"comment\">// ❌ 输出 undefined</span></span><br></pre></td></tr></table></figure>\n<p>最开始挺奇怪的 map 明明设置了值，但是对应的 map size 为0，遍历 map 也没有数据。后来才发现是这种方式 不会 触发 Map 的内部机制，而是绕过了 Map 的方法，直接操作对象的属性，赋值后，键值对 不会 被存入 Map 的真实存储中，而是作为对象的普通属性存在。正确的用法是：</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> map = <span class=\"keyword\">new</span> <span class=\"title class_\">Map</span>&lt;<span class=\"built_in\">string</span>, <span class=\"built_in\">object</span>&gt;();</span><br><span class=\"line\">map.<span class=\"property\">set</span>[<span class=\"string\">&quot;key&quot;</span>] = value;        <span class=\"comment\">//  ✅ 正确用法！</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(map.<span class=\"title function_\">get</span>(<span class=\"string\">&quot;biz&quot;</span>));   <span class=\"comment\">//  ✅ 输出 value</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"struct-的困扰\"><a href=\"#struct-的困扰\" class=\"headerlink\" title=\"struct 的困扰\"></a>struct 的困扰</h4><p>在 js 里面是没有 <code>struct</code> 这个关键词的，从刚接触到现在它唯一的作用就是：和 <code>@Component</code>绑定声明一个UI控件。例如：</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> struct <span class=\"title class_\">ToolBar</span>&#123;&#125;</span><br></pre></td></tr></table></figure>\n<p><code>@Component</code> 和 <code>struct</code> 两则缺一不可，既然必须有 <code>@Component</code>来标注这是一个UI控件，为什么不能下面这样呢？能省掉一个关键字。</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ToolBar</span> &#123;&#125;</span><br></pre></td></tr></table></figure>\n<p>同样困扰的人还有很多，这里有一份讨论<a href=\"https://developer.huawei.com/consumer/cn/forum/topic/0204135301248599134\">定义组件时的stuct关键字是什么？</a><br>官方也有一份聊胜于无的介绍</p>\n<blockquote>\n<p>struct和class的区别是什么? </p>\n<p>struct只在自定义组件中使用，@Component装饰的struct就是自定义组件，自定义组件和class是两个概念，自定义组件没有类型，也不能等同于class。如果开发者需要使用组件作为参数在组件之间传递，可以使用自定义占位节点。</p>\n</blockquote>\n<p>我猜测这样是为了省掉对<code>@Component</code>装饰器编译的工作量，如果使用 class 声明，那么声明的UI控件就有“面向对象”的能力，实际上只希望它是一个UI控件声明，不需要它有其他的能力。难道不能对 <code>@Component</code> 装饰过的对象收回“面向对象”的能力么？当然能啊，估计要做很多编译检查的事儿。另外，从开发理解的层面上来讲，它确实也已经不是”对象”了，它只是一个干巴巴的一个UI结构，所以干脆就搞了一个新的关键词 struct。</p>\n<h3 id=\"ArkUI-框架\"><a href=\"#ArkUI-框架\" class=\"headerlink\" title=\"ArkUI 框架\"></a>ArkUI 框架</h3><p>整体框架使用的方式和 <a href=\"https://developer.android.com/compose\">Jetpack Compose</a> 类似，都是声明式UI框架。compose 里面使用  <code>@Composable</code>来标记某个方法这个方法便成了<code>UI控件</code>，控件里面的状态管理使用 <code>remember</code>+ <code>mutableState</code>来控制。而 ArkUI 通过 @State、@Link、@Prop 等装饰器来控制。了解了这些个装饰器的用法，基本上就能理解 ArkUI 的开发流程了。</p>\n<h4 id=\"构建-UI-的-Component-Builder\"><a href=\"#构建-UI-的-Component-Builder\" class=\"headerlink\" title=\"构建 UI 的 @Component @Builder\"></a>构建 UI 的 @Component @Builder</h4><p>@Component 和 @Builder 组合起来实现的差不多就是 Compose 里面使用  <code>@Composable</code> 装饰某个方法的作用，用于构建 UI 或可复用的逻辑单元。<br><strong>@Component</strong><br>用于创建一个自定义组件，组件可以包含独立的 UI 结构、状态管理和生命周期。</p>\n<p><strong>@Builder</strong><br>定义可复用的 UI 片段，用于创建一个UI 构建函数，封装一段可复用的 UI 代码块。不是独立组件，而是嵌入到其他组件或布局中执行，主要作用是复用和逻辑隔离，例如：关于页面，里面的文本是差不多的样式，只是内容不一样，那么只需要保留一个 text 属性出来接收参数。或者某块UI比较复杂，可以抽离一部分UI成为一个独立的UI逻辑模块。</p>\n<h3 id=\"构建-UI-的状态控制装饰器\"><a href=\"#构建-UI-的状态控制装饰器\" class=\"headerlink\" title=\"构建 UI 的状态控制装饰器\"></a>构建 UI 的状态控制装饰器</h3><p><strong>@State</strong><br>比较常用的装饰器，和 Compose 里面 remember+mutableStateOf 的作用差不多，对应的值改变之后，对相关的使用到该属性UI的地方进行刷新。</p>\n<p><strong>@Prop</strong><br>@Prop 装饰的变量和父组件建立单向的同步关系，@Prop变量允许在本地修改，但修改后的变化不会同步回父组件。</p>\n<p>也就是在某个 @Component 的组件内有一个 @State 装饰的属性，传递到子 @Component 组件 @Prop 修饰的属性。子控件对这个属性修改之后，父控件不会对这个改变感知，父控件UI不会改变。</p>\n<p><strong>@Link</strong><br>子组件中被@Link装饰的变量与其父组件中对应的数据源建立双向数据绑定。<br>跟 @Prop 的作用类似，不过是双向的，子控件对这个属性修改之后，父控件会感知这个变化，父控件UI会随着这个属性改变而改变。</p>\n<p><strong>@BuilderParam</strong><br>主要用于动态注入 UI 构建逻辑（即 @Builder 函数），实现父组件向子组件传递可定制的 UI 片段，也就是向子控件传递 UI 参数。</p>\n<p>基本上比较常用到的就这些，还有很多例如：@LocalBuilder @StorageLink @Styles等，都是为了解决开发过过程中遇到的问题，但是只要掌握了 ArkUI UI组件的声明周期和状态管理的基本原理理解其他装饰器还是比较简单的。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>总体开发体验下来，鸿蒙开发学习成本并不是特别高，比较快能上手，但设计的 api 更像一个缝合怪，且使用上不太收敛。很多库还需要再建设，例如音视频开发对应的支持库还不是特别成熟。不过，作为一个从头搞的生态来说能实现成这样已经很不错了，就像此前武磊登陆西甲，以及目前被看好的青年新星王钰栋，都是”自己的孩子”，需要迈出第一步。现在，很多公司也在适配鸿蒙了，期待未来能从 Android 跟 iOS 的生态中争夺出一片大市场。</p>\n<p>项目源码：<a href=\"https://github.com/VomPom/blog_harmony\">https://github.com/VomPom/blog_harmony</a></p>\n","categories":[{"name":"思考总结","slug":"thinking","api":"api/categories/thinking.json"}],"tags":[{"name":"鸿蒙","slug":"鸿蒙","api":"api/tags/鸿蒙.json"}],"api":"api/posts/2025/05/16/鸿蒙-写了个基于Hexo博客的鸿蒙App.json"},{"title":"KV-存储之mmkv","slug":"KV-存储之mmkv","date":"2025-03-30T03:38:00.000Z","updated":"2025-05-20T11:46:57.000Z","comments":true,"url":"2025/03/30/KV-存储之mmkv/","excerpt":"<p>在平时的业务中，需要用到轻量级存储业务中的数据（例如设置数据存储），绝大多数时候 Anroid 管法提供的 <a href=\"https://developer.android.com/reference/android/content/SharedPreferences\">SharedPreferences</a>  组件就能实现，但针对一些需要高效的场景它就不那么使用了，不适合存储大量数据、多线程操作的不安全性、数据明文不安全性，以及不支持多进程之间的调用等各种问题。<br><a href=\"https://github.com/Tencent/MMKV\">MMKV</a>的诞生就是为了解决以上的问题，本文主要对 MMKV 源码的学习知识点进行一些总结。</p>\n<h2 id=\"核心设计与原理\"><a href=\"#核心设计与原理\" class=\"headerlink\" title=\"核心设计与原理\"></a>核心设计与原理</h2><p>在官方的开源工程中可以看到如下的一些介绍</p>\n<blockquote>\n<p>MMKV 是基于 mmap 内存映射的 key-value 组件，底层序列化&#x2F;反序列化使用 protobuf 实现，性能高，稳定性强。从 2015 年中至今在微信上使用，其性能和稳定性经过了时间的验证。</p>\n</blockquote>\n<h3 id=\"传统I-O与-mmap\"><a href=\"#传统I-O与-mmap\" class=\"headerlink\" title=\"传统I&#x2F;O与 mmap\"></a>传统I&#x2F;O与 mmap</h3><p>mmap 这个是 mmkv 实现的核心，没有 mmap 那么就没有 mmkv。对于 <code>SharedPreferences</code>的实现来说，每次的数据更新都将操作本地文件，而本地文件的写入是通过传统的I&#x2F;O实现。要理解两者的实现差异，需要先理解 Linux <strong>用户空间与内核空间</strong>设计。</p>\n<h4 id=\"用户空间与内核空间\"><a href=\"#用户空间与内核空间\" class=\"headerlink\" title=\"用户空间与内核空间\"></a><strong>用户空间与内核空间</strong></h4><p>Linux的进程是相互独立的，一个进程是不能直接操作或者访问别一个进程空间的。每个进程空间还分为用户空间和内核（Kernel）空间，相当于把Kernel和上层的应用程序抽像的隔离开。</p>\n<p><strong>用户空间</strong>和<strong>内核空间</strong>，用户空间是用户程序代码运行的地方，内核空间是内核代码运行的地方。为了安全，它们是隔离的，即使用户的程序崩溃了，内核也不受影响。</p>\n<p>这里有两个隔离，一个进程间是相互隔离的，二是进程内有用户空间和内核空间的隔离。</p>\n<p>进程间，用户空间的数据不可共享，所以用户空间 &#x3D; 不可共享空间<br>进程间，内核空间的数据可共享，所以内核空间 &#x3D; 可共享空间，所以Linux系统的内存通常是MemFree+Cache<br>所有进程共用1个内核空间。</p>\n<h4 id=\"传统I-O读写流程\"><a href=\"#传统I-O读写流程\" class=\"headerlink\" title=\"传统I&#x2F;O读写流程\"></a><strong>传统I&#x2F;O读写流程</strong></h4><p>常规文件读写操作（调用read&#x2F;fread等函数）过程如下：</p>\n<ul>\n<li><p>进程发起读写文件请求。</p>\n</li>\n<li><p>内核通过查找进程文件符表，定位到内核已打开文件集上的文件信息，从而找到此文件的<code>inode</code>。</p>\n</li>\n<li><p><code>inode</code> 在 <code>address_space</code> 上查找要请求的文件页是否已经缓存在页缓存中。如果存在，则直接返回这片文件页的内容。</p>\n</li>\n<li><p>如果不存在，则通过 <code>inode</code> 定位到文件磁盘地址，将数据从磁盘复制到页缓存。之后再次发起读页面过程，进而将页缓存中的数据发给用户进程。</p>\n<blockquote>\n<p><strong>什么是 inode</strong> ?</p>\n<p>全称为 index node，既<strong>存储文件元信息的区域</strong>，中文译名“索引节点”。<br>包含：文件权限、文件拥有者的UID、文件的大小等等。</p>\n</blockquote>\n</li>\n</ul>\n<img src=\"https://cdn.julis.wang/blog/img/ee519ba873acf3f80fd4ccec86ed72e7.png\">\n\n\n<p>总结来说，常规文件操作为了提高读写效率和保护磁盘，使用了页缓存机制。这样造成读文件时需要先将文件页从磁盘拷贝到页缓存中，由于页缓存处在内核空间，不能被用户进程直接寻址访问，所以还需要将页缓存中的数据页再次拷贝到用户空间中。这样，通过了两次数据拷贝过程，才能完成<strong>进程</strong>对<strong>文件</strong>内容的访问。</p>\n<h4 id=\"mmap基本概念和原理\"><a href=\"#mmap基本概念和原理\" class=\"headerlink\" title=\"mmap基本概念和原理\"></a><strong>mmap基本概念和原理</strong></h4><p>内存映射（mmap），就是<strong>将文件的磁盘扇区映射到进程的虚拟内存空间</strong>的过程，即将一个文件映射到进程的虚拟空间，实现文件磁盘地址和进程虚拟空间中一段虚拟地址的一一对应关系。实现这样的映射关系后，进程就可以采用指针的方式读写操作这一段内存，而系统会自动回写脏页面到对应的文件磁盘上，即完成了对文件的操作而不必再调用read,write等系统调用函数。</p>\n<img src=\"https://cdn.julis.wang/blog/img/mmap_1.png\">\n\n<p>由上图可知，进程的虚拟地址空间，由多个虚拟内存区域构成。每个虚拟内存区域都是进程在虚拟地址空间中的一个同质区间，即具有同样特性的连续地址范围。上图中所示的text数据段（代码段）、初始数据段、BSS数据段、堆、栈和内存映射，都是一个独立的虚拟内存区域。内存映射的地址空间处在堆栈之间的空余部分。</p>\n<p>linux内核使用 <code>vm_area_struc</code>t 结构来表示一个独立的虚拟内存区域，由于每个不同质的虚拟内存区域功能和内部机制都不同，因此一个进程使用多个 <code>vm_area_struct</code> 结构来分别表示不同类型的虚拟内存区域。各个 <code>vm_area_struct</code> 结构使用链表或者树形结构链接，方便进程快速访问，如下图所示：</p>\n<img src=\"https://cdn.julis.wang/blog/img/mmap_2_1.png\">\n\n<p><code>vm_area_struct</code> 结构中包含区域起始和终止地址以及其他相关信息。这样，进程对某一虚拟内存区域的任何操作需要用要的信息，都可以从 <code>vm_area_struct</code> 中获得。mmap函数就是要创建一个新的 <code>vm_area_struct</code> 结构，并将其与文件的物理磁盘地址相连。</p>\n<p>mmap内存映射的实现过程，总的来说可以分为三个阶段：</p>\n<p><strong>阶段一：进程启动映射过程，并在虚拟地址空间中为映射创建虚拟映射区域</strong></p>\n<ul>\n<li>进程在用户空间调用mmap库函数</li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> *<span class=\"title\">mmap</span><span class=\"params\">(<span class=\"type\">void</span> *addr, <span class=\"type\">size_t</span> length, <span class=\"type\">int</span> prot, <span class=\"type\">int</span> flags, <span class=\"type\">int</span> fd, <span class=\"type\">off_t</span> offset)</span></span>;</span><br></pre></td></tr></table></figure>\n\n<p><code>addr</code>：指定映射的虚拟内存地址，可以设置为 NULL，让内核自动选择合适的虚拟内存地址</p>\n<p><code>length</code>：映射的长度。</p>\n<p><code>prot</code>：映射内存的保护模式，可选值如下：  </p>\n<p><code>flags</code>：指定映射的类型</p>\n<p><code>fd</code>：进行映射的文件句柄。</p>\n<p><code>offset</code>：文件偏移量（从文件的何处开始映射）</p>\n<ul>\n<li><p>在当前进程的虚拟地址空间中，寻找一段空闲的满足要求的连续的虚拟地址</p>\n</li>\n<li><p>为此虚拟区分配一个 <code>vm_area_struct</code> 结构，接着对这个结构的各个域进行了初始化</p>\n</li>\n<li><p>将新创建的虚拟区结构 <code>vm_area_struct</code> 对象插入到进程的虚拟地址区域链表&#x2F;树中</p>\n</li>\n</ul>\n<p><strong>阶段二：调用内核空间的mmap函数（不同于用户空间函数），实现文件物理地址和进程虚拟地址的一一映射关系</strong></p>\n<ul>\n<li><p>为映射分配了新的虚拟地址区域后，通过待映射的文件指针，在文件描述符表中找到对应的文件描述符，通过文件描述符，链接到内核“已打开文件集”中该文件的文件结构体（struct file），每个文件结构体维护着和这个已打开文件相关各项信息。</p>\n</li>\n<li><p>为映射分配了新的虚拟地址区域后，通过待映射的文件指针，在文件描述符表中找到对应的文件描述符，通过文件描述符，链接到内核“已打开文件集”中该文件的文件结构体（struct file），每个文件结构体维护着和这个已打开文件相关各项信息。</p>\n</li>\n<li><p>通过该文件的文件结构体，链接到 <code>file_operations</code> 模块，调用内核mmap函数，其原型为：</p>\n</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">int mmap(struct file *filp, struct vm_area_struct *vma) //不同于用户空间mmap库函数</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>内核mmap函数通过虚拟文件系统inode模块定位到文件磁盘物理地址。</p>\n</li>\n<li><p>通过 <code>remap_pfn_range</code> 函数建立页表，即实现了文件地址和虚拟地址区域的映射关系。此时，这片虚拟地址并没有任何数据关联到物理内存(主存)中。</p>\n</li>\n</ul>\n<blockquote>\n<p>主存</p>\n<p>主存储器（Main memory），简称主存。是计算机硬件的一个重要部件，其作用是存放指令和数据，并能由中央处理器（CPU）直接随机存取</p>\n</blockquote>\n<p><strong>阶段三：进程发起对这片映射地址空间的访问，引发缺页异常，实现文件内容到主存（物理内存）的拷贝</strong></p>\n<blockquote>\n<p>前两个阶段仅在于创建虚拟区间并完成地址映射，但是并没有将任何文件数据的拷贝至主存。真正的文件读取是当进程发起读或写操作时</p>\n</blockquote>\n<ul>\n<li><p>进程的读或写操作访问虚拟地址空间这一段映射地址，通过查询页表，发现这一段地址并不在物理页上。因为目前只建立了地址映射，真正的硬盘数据还没有拷贝到内存中，因此引发缺页异常。</p>\n</li>\n<li><p>缺页异常进行一系列判断，确定无非法操作后，内核发起请求调页过程。</p>\n</li>\n<li><p>调页过程先在交换缓存空间（swap cache）中寻找需要访问的内存页，如果没有则调用nopage函数把所缺的页从磁盘装入到主存中。</p>\n</li>\n<li><p>之后进程即可对这片主存进行读或者写的操作，如果写操作改变了其内容，一定时间后系统会自动回写脏页面到对应磁盘地址，也即完成了写入到文件的过程。</p>\n</li>\n</ul>\n<blockquote>\n<p>修改过的脏页面并不会立即更新回文件中，而是有一段时间的延迟，可以调用<code>msync()</code>来强制同步, 这样所写的内容就能立即保存到文件里了</p>\n</blockquote>\n<p>常规文件操作需要从磁盘到内核空间页缓存再到用户空间主存的两次数据拷贝。而mmap文件映射，只需要从磁盘到用户空间主存的一次数据拷贝过程。mmap的关键点是实现了用户空间和内核空间的数据直接交互而省去了空间不同数据不通的繁琐过程，因此 mmap 效率更高。</p>\n<p>以上是 mmap 的基本概念和原理，搞明白了这些才能看明白整个 mmkv 里面的逻辑处理</p>\n<h3 id=\"mmkv-一次-put-的流程\"><a href=\"#mmkv-一次-put-的流程\" class=\"headerlink\" title=\"mmkv 一次 put 的流程\"></a>mmkv 一次 put 的流程</h3><p>mmkv初始化比较简单，主要涉及到一些配置的初始化，文件夹创建等，其中最重要的逻辑 mmap 调用被封装到一个 <code>MemoryFile</code>到对象里面 </p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">MemoryFile::mmap</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">auto</span> oldPtr = m_ptr;</span><br><span class=\"line\">    <span class=\"keyword\">auto</span> mode = m_readOnly ? PROT_READ : (PROT_READ | PROT_WRITE);</span><br><span class=\"line\">    m_ptr = (<span class=\"type\">char</span> *) ::<span class=\"built_in\">mmap</span>(m_ptr, m_size, mode, MAP_SHARED, m_diskFile.m_fd, <span class=\"number\">0</span>);</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>主要记录一下一次 put 任务的流程，以 <code>mmkv.putInt(&quot;int&quot;, 1)</code>为例，进过 JNI 的调用到了</p>\n<p><strong>native-birdge.cpp</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">MMKV_JNI jboolean <span class=\"title\">encodeInt</span><span class=\"params\">(JNIEnv *env, jobject obj, jlong handle, jstring oKey, jint value)</span> </span>&#123;</span><br><span class=\"line\">    MMKV *kv = <span class=\"built_in\">reinterpret_cast</span>&lt;MMKV *&gt;(handle);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (kv &amp;&amp; oKey) &#123;</span><br><span class=\"line\">        string key = <span class=\"built_in\">jstring2string</span>(env, oKey);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (jboolean) kv-&gt;<span class=\"built_in\">set</span>((<span class=\"type\">int32_t</span>) value, key);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (jboolean) <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>进入了<strong>MMVK.cpp</strong>的 </p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">MMKV::set</span><span class=\"params\">(<span class=\"type\">int32_t</span> value, MMKVKey_t key, <span class=\"type\">uint32_t</span> expireDuration)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">isKeyEmpty</span>(key)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"type\">size_t</span> size = <span class=\"built_in\">mmkv_unlikely</span>(m_enableKeyExpire) ? Fixed32Size + <span class=\"built_in\">pbInt32Size</span>(value) : <span class=\"built_in\">pbInt32Size</span>(value);</span><br><span class=\"line\">    <span class=\"function\">MMBuffer <span class=\"title\">data</span><span class=\"params\">(size)</span></span>;</span><br><span class=\"line\">    <span class=\"function\">CodedOutputData <span class=\"title\">output</span><span class=\"params\">(data.getPtr(), size)</span></span>;</span><br><span class=\"line\">    output.<span class=\"built_in\">writeInt32</span>(value);</span><br><span class=\"line\">    <span class=\"comment\">// ... 省略一些校验逻辑</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">setDataForKey</span>(std::<span class=\"built_in\">move</span>(data), key);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这一步主要是准备一下数据，并使用 <code>MMBuffer</code> <code>CodedOutputData</code>将写入的数据进行一次包装（不仅仅是 key-value，还有数据size等等），实际调用在<code>setDataForKey</code></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">MMKV::setDataForKey</span><span class=\"params\">(MMBuffer &amp;&amp;data, MMKVKey_t key, <span class=\"type\">bool</span> isDataHolder)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">checkLoadData</span>(); <span class=\"comment\">// 状态同步相关的逻辑</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (m_crypter) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// ... 省略加密的处理逻辑</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">auto</span> itr = m_dic-&gt;<span class=\"built_in\">find</span>(key);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (itr != m_dic-&gt;<span class=\"built_in\">end</span>()) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// compare data before appending to file</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (<span class=\"built_in\">isCompareBeforeSetEnabled</span>()) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">auto</span> basePtr = (<span class=\"type\">uint8_t</span> *) (m_file-&gt;<span class=\"built_in\">getMemory</span>()) + Fixed32Size;</span><br><span class=\"line\">                MMBuffer oldValueData = itr-&gt;second.<span class=\"built_in\">toMMBuffer</span>(basePtr);</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (isDataHolder) &#123;</span><br><span class=\"line\">                    <span class=\"function\">CodedInputData <span class=\"title\">inputData</span><span class=\"params\">(oldValueData.getPtr(), oldValueData.length())</span></span>;</span><br><span class=\"line\">                    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                        <span class=\"comment\">// read extra holder header bytes and to real MMBuffer</span></span><br><span class=\"line\">                        oldValueData = CodedInputData::<span class=\"built_in\">readRealData</span>(oldValueData);</span><br><span class=\"line\">                        <span class=\"keyword\">if</span> (oldValueData == data) &#123;</span><br><span class=\"line\">                            <span class=\"comment\">// MMKVInfo(&quot;[key] %s, set the same data&quot;, key.c_str());</span></span><br><span class=\"line\">                            <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125; <span class=\"built_in\">catch</span> (std::exception &amp;exception) &#123;</span><br><span class=\"line\">                        <span class=\"built_in\">MMKVWarning</span>(<span class=\"string\">&quot;compareBeforeSet exception: %s&quot;</span>, exception.<span class=\"built_in\">what</span>());</span><br><span class=\"line\">                    &#125; <span class=\"built_in\">catch</span> (...) &#123;</span><br><span class=\"line\">                        <span class=\"built_in\">MMKVWarning</span>(<span class=\"string\">&quot;compareBeforeSet fail&quot;</span>);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                     ...</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"type\">bool</span> onlyOneKey = !<span class=\"built_in\">isMultiProcess</span>() &amp;&amp; m_dic-&gt;<span class=\"built_in\">size</span>() == <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (<span class=\"built_in\">mmkv_likely</span>(!m_enableKeyExpire)) &#123;</span><br><span class=\"line\">                ...</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                KVHolderRet_t ret;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (onlyOneKey) &#123;</span><br><span class=\"line\">                    ret = <span class=\"built_in\">overrideDataWithKey</span>(data, key, isDataHolder);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    ret = <span class=\"built_in\">appendDataWithKey</span>(data, key, isDataHolder);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (!ret.first) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                itr = m_dic-&gt;<span class=\"built_in\">find</span>(key);</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (itr != m_dic-&gt;<span class=\"built_in\">end</span>()) &#123;</span><br><span class=\"line\">                    itr-&gt;second = std::<span class=\"built_in\">move</span>(ret.second);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// in case filterExpiredKeys() is triggered</span></span><br><span class=\"line\">                    m_dic-&gt;<span class=\"built_in\">emplace</span>(key, std::<span class=\"built_in\">move</span>(ret.second));</span><br><span class=\"line\">                    <span class=\"built_in\">mmkv_retain_key</span>(key);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">           ...</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    m_hasFullWriteback = <span class=\"literal\">false</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里面的代码逻辑很长，做了很多 if-else 的逻辑，最终走向两个大分支：</p>\n<p>key 是新增的走 <code>appendDataWithKey</code></p>\n<p>key 将会覆盖原来的将会走 <code>overrideDataWithKey</code></p>\n<p>有这两个分支，主要是因为 mmkv 存储采用的  <a href=\"https://protobuf.com.cn/\">protobuf 协议</a>，另外有一个很重要的方法也在这里执行了：<code>checkLoadData();</code>  安卓里面的多进程实现，将需要这里的一些逻辑，在 mmkv多进程原理篇进行讲解。</p>\n<p><code>appendDataWithKey</code> 转换为 <code>MMBuffer</code>并继续向下执行</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">KVHolderRet_t <span class=\"title\">MMKV::appendDataWithKey</span><span class=\"params\">(<span class=\"type\">const</span> MMBuffer &amp;data, MMKVKey_t key, <span class=\"type\">bool</span> isDataHolder)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">auto</span> keyData = <span class=\"built_in\">MMBuffer</span>((<span class=\"type\">void</span> *) key.<span class=\"built_in\">data</span>(), key.<span class=\"built_in\">size</span>(), MMBufferNoCopy);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">doAppendDataWithKey</span>(data, keyData, isDataHolder, <span class=\"built_in\">static_cast</span>&lt;<span class=\"type\">uint32_t</span>&gt;(keyData.<span class=\"built_in\">length</span>()));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>doAppendDataWithKey</code> 里面的代码也很长，不过也就只做一件事：将k-v值写入到文件里面做准备，真正的写入逻辑在 <code>m_output-&gt;writeData(keyData);</code>，这里先后调用了两次 <code>writeData</code>,是先写入key再写入了 value。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">KVHolderRet_t</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">MMKV::doAppendDataWithKey</span><span class=\"params\">(<span class=\"type\">const</span> MMBuffer &amp;data, <span class=\"type\">const</span> MMBuffer &amp;keyData, <span class=\"type\">bool</span> isDataHolder, <span class=\"type\">uint32_t</span> originKeyLength)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">auto</span> isKeyEncoded = (originKeyLength &lt; keyData.<span class=\"built_in\">length</span>());</span><br><span class=\"line\">    <span class=\"keyword\">auto</span> keyLength = <span class=\"built_in\">static_cast</span>&lt;<span class=\"type\">uint32_t</span>&gt;(keyData.<span class=\"built_in\">length</span>());</span><br><span class=\"line\">    <span class=\"keyword\">auto</span> valueLength = <span class=\"built_in\">static_cast</span>&lt;<span class=\"type\">uint32_t</span>&gt;(data.<span class=\"built_in\">length</span>());</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (isDataHolder) &#123;</span><br><span class=\"line\">        valueLength += <span class=\"built_in\">pbRawVarint32Size</span>(valueLength);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// size needed to encode the key</span></span><br><span class=\"line\">    <span class=\"type\">size_t</span> size = isKeyEncoded ? keyLength : (keyLength + <span class=\"built_in\">pbRawVarint32Size</span>(keyLength));</span><br><span class=\"line\">    <span class=\"comment\">// size needed to encode the value</span></span><br><span class=\"line\">    size += valueLength + <span class=\"built_in\">pbRawVarint32Size</span>(valueLength);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">SCOPED_LOCK</span>(m_exclusiveProcessLock);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">bool</span> hasEnoughSize = <span class=\"built_in\">ensureMemorySize</span>(size);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!hasEnoughSize || !<span class=\"built_in\">isFileValid</span>()) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">make_pair</span>(<span class=\"literal\">false</span>, <span class=\"built_in\">KeyValueHolder</span>());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">\t\t...</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (isKeyEncoded) &#123;</span><br><span class=\"line\">            m_output-&gt;<span class=\"built_in\">writeRawData</span>(keyData);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            m_output-&gt;<span class=\"built_in\">writeData</span>(keyData);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (isDataHolder) &#123;</span><br><span class=\"line\">            m_output-&gt;<span class=\"built_in\">writeRawVarint32</span>((<span class=\"type\">int32_t</span>) valueLength);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        m_output-&gt;<span class=\"built_in\">writeData</span>(data); <span class=\"comment\">// note: write size of data</span></span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">    ...</span><br><span class=\"line\">    m_actualSize += size;</span><br><span class=\"line\">    <span class=\"built_in\">updateCRCDigest</span>(ptr, size);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">make_pair</span>(<span class=\"literal\">true</span>, <span class=\"built_in\">KeyValueHolder</span>(originKeyLength, valueLength, offset));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>writeData</code> 进行了两步先写入数据的 <strong>长度信息</strong>，再写入真实的数据，这里还是因为  <a href=\"https://protobuf.com.cn/\">protobuf 协议</a>设计相关</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">CodedOutputData::writeData</span><span class=\"params\">(<span class=\"type\">const</span> MMBuffer &amp;value)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>-&gt;<span class=\"built_in\">writeRawVarint32</span>((<span class=\"type\">int32_t</span>) value.<span class=\"built_in\">length</span>());</span><br><span class=\"line\">    <span class=\"keyword\">this</span>-&gt;<span class=\"built_in\">writeRawData</span>(value);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>最终走到了<code>writeRawData</code> 关键代码</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">CodedOutputData::writeRawData</span><span class=\"params\">(<span class=\"type\">const</span> MMBuffer &amp;data)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"type\">size_t</span> numberOfBytes = data.<span class=\"built_in\">length</span>();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (m_position + numberOfBytes &gt; m_size) &#123;</span><br><span class=\"line\">       ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">memcpy</span>(m_ptr + m_position, data.<span class=\"built_in\">getPtr</span>(), numberOfBytes);</span><br><span class=\"line\">    m_position += numberOfBytes;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>核心逻辑使用 <code>memcpy</code> 将数据直接通过 memcpy 直接在内存层面进行拷贝，而这里的 <code>m_ptr</code>就是最开始通过<code>mmap</code>创建出来的指针！！到这里一次写入基本上就结束了。</p>\n<h3 id=\"mmkv-一次-get-的流程\"><a href=\"#mmkv-一次-get-的流程\" class=\"headerlink\" title=\"mmkv 一次 get 的流程\"></a>mmkv 一次 get 的流程</h3><p>依然先通过 JNI走到</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">MMKV_JNI jint <span class=\"title\">decodeInt</span><span class=\"params\">(JNIEnv *env, jobject obj, jlong handle, jstring oKey, jint defaultValue)</span> </span>&#123;</span><br><span class=\"line\">    MMKV *kv = <span class=\"built_in\">reinterpret_cast</span>&lt;MMKV *&gt;(handle);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (kv &amp;&amp; oKey) &#123;</span><br><span class=\"line\">        string key = <span class=\"built_in\">jstring2string</span>(env, oKey);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (jint) kv-&gt;<span class=\"built_in\">getInt32</span>(key, defaultValue);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> defaultValue;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>再到 mmkv getInt32</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int32_t</span> <span class=\"title\">MMKV::getInt32</span><span class=\"params\">(MMKVKey_t key, <span class=\"type\">int32_t</span> defaultValue, <span class=\"type\">bool</span> *hasValue)</span> </span>&#123;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">    <span class=\"built_in\">SCOPED_LOCK</span>(m_lock);</span><br><span class=\"line\">    <span class=\"built_in\">SCOPED_LOCK</span>(m_sharedProcessLock);</span><br><span class=\"line\">    <span class=\"keyword\">auto</span> data = <span class=\"built_in\">getDataForKey</span>(key);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (data.<span class=\"built_in\">length</span>() &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"function\">CodedInputData <span class=\"title\">input</span><span class=\"params\">(data.getPtr(), data.length())</span></span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (hasValue != <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">                *hasValue = <span class=\"literal\">true</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> input.<span class=\"built_in\">readInt32</span>();</span><br><span class=\"line\">        &#125; </span><br><span class=\"line\">        ...</span><br><span class=\"line\">    <span class=\"keyword\">return</span> defaultValue;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>getRawDataForKey</code>方法，主要有两个分支，一种是加密逻辑，另一种是非加密逻辑，但他们流程都差不多从一个  map 里面根据 key 获取一个对象（这个对象暂时并不是 get 最终的返回值），那这个 map 是从哪里来的呢？</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">MMBuffer <span class=\"title\">MMKV::getRawDataForKey</span><span class=\"params\">(MMKVKey_t key)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">checkLoadData</span>();</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">ifndef</span> MMKV_DISABLE_CRYPT</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (m_crypter) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">auto</span> itr = m_dicCrypt-&gt;<span class=\"built_in\">find</span>(key);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (itr != m_dicCrypt-&gt;<span class=\"built_in\">end</span>()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">auto</span> basePtr = (<span class=\"type\">uint8_t</span> *) (m_file-&gt;<span class=\"built_in\">getMemory</span>()) + Fixed32Size;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> itr-&gt;second.<span class=\"built_in\">toMMBuffer</span>(basePtr, m_crypter);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span></span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">auto</span> itr = m_dic-&gt;<span class=\"built_in\">find</span>(key);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (itr != m_dic-&gt;<span class=\"built_in\">end</span>()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">auto</span> basePtr = (<span class=\"type\">uint8_t</span> *) (m_file-&gt;<span class=\"built_in\">getMemory</span>()) + Fixed32Size;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> itr-&gt;second.<span class=\"built_in\">toMMBuffer</span>(basePtr);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    MMBuffer nan;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> nan;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>从源码里面溯源<code>m_dicCrypt</code>和 <code>m_dic</code> 是在 MMKV 初始化的时候生成的，主要逻辑在 <code>MMKV_IO .cpp</code>里面的 <code>loadFromFile</code>方法内：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">MMKV::loadFromFile</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">loadMetaInfoAndCheck</span>();</span><br><span class=\"line\">\t\t...</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!m_file-&gt;<span class=\"built_in\">isFileValid</span>()) &#123;</span><br><span class=\"line\">        m_file-&gt;<span class=\"built_in\">reloadFromFile</span>(m_expectedCapacity);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!m_file-&gt;<span class=\"built_in\">isFileValid</span>()) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">MMKVError</span>(<span class=\"string\">&quot;file [%s] not valid&quot;</span>, m_path.<span class=\"built_in\">c_str</span>());</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">bool</span> loadFromFile = <span class=\"literal\">false</span>, needFullWriteback = <span class=\"literal\">false</span>;</span><br><span class=\"line\">        <span class=\"built_in\">checkDataValid</span>(loadFromFile, needFullWriteback);</span><br><span class=\"line\">        ...</span><br><span class=\"line\">        <span class=\"keyword\">auto</span> ptr = (<span class=\"type\">uint8_t</span> *) m_file-&gt;<span class=\"built_in\">getMemory</span>();</span><br><span class=\"line\">        <span class=\"comment\">// loading</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (loadFromFile &amp;&amp; m_actualSize &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\t\t\t...</span><br><span class=\"line\">            <span class=\"function\">MMBuffer <span class=\"title\">inputBuffer</span><span class=\"params\">(ptr + Fixed32Size, m_actualSize, MMBufferNoCopy)</span></span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (m_crypter) &#123;</span><br><span class=\"line\">                <span class=\"built_in\">clearDictionary</span>(m_dicCrypt);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"built_in\">clearDictionary</span>(m_dic);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (needFullWriteback) &#123;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">ifndef</span> MMKV_DISABLE_CRYPT</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (m_crypter) &#123;</span><br><span class=\"line\">                    MiniPBCoder::<span class=\"built_in\">greedyDecodeMap</span>(*m_dicCrypt, inputBuffer, m_crypter);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span></span></span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    MiniPBCoder::<span class=\"built_in\">greedyDecodeMap</span>(*m_dic, inputBuffer);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">ifndef</span> MMKV_DISABLE_CRYPT</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (m_crypter) &#123;</span><br><span class=\"line\">                    MiniPBCoder::<span class=\"built_in\">decodeMap</span>(*m_dicCrypt, inputBuffer, m_crypter);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span></span></span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    MiniPBCoder::<span class=\"built_in\">decodeMap</span>(*m_dic, inputBuffer);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            m_output = <span class=\"keyword\">new</span> <span class=\"built_in\">CodedOutputData</span>(ptr + Fixed32Size, m_file-&gt;<span class=\"built_in\">getFileSize</span>() - Fixed32Size);</span><br><span class=\"line\">            m_output-&gt;<span class=\"built_in\">seek</span>(m_actualSize);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (needFullWriteback) &#123;</span><br><span class=\"line\">                <span class=\"built_in\">fullWriteback</span>();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// file not valid or empty, discard everything</span></span><br><span class=\"line\">            <span class=\"built_in\">SCOPED_LOCK</span>(m_exclusiveProcessLock);</span><br><span class=\"line\"></span><br><span class=\"line\">            m_output = <span class=\"keyword\">new</span> <span class=\"built_in\">CodedOutputData</span>(ptr + Fixed32Size, m_file-&gt;<span class=\"built_in\">getFileSize</span>() - Fixed32Size);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (m_actualSize &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                <span class=\"built_in\">writeActualSize</span>(<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"literal\">nullptr</span>, IncreaseSequence);</span><br><span class=\"line\">                <span class=\"built_in\">sync</span>(MMKV_SYNC);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"built_in\">writeActualSize</span>(<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"literal\">nullptr</span>, KeepSequence);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">\t\t\t\t...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    m_needLoadFromFile = <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>总统来说就是在初始化的时候就会将基于<code>protobuf</code>协议的本地文件里面的数据加载到内存，并将其放在一个 map 内，方便后续使用。</p>\n<p>回到 <code>int32_t MMKV::getInt32()</code>通过 <code>getDataForKey(key)</code>获取到一个<code>MMBuffer</code>对象，并通过 <strong>CodedInputData</strong>进行反序列化操作，读取 <strong>Varint32</strong> 的 <strong>valueSize</strong> 值，随后不断循环通过 <strong>CodedInputData</strong>  读取到<strong>value</strong> 值。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int32_t</span> <span class=\"title\">MMKV::getInt32</span><span class=\"params\">(MMKVKey_t key, <span class=\"type\">int32_t</span> defaultValue, <span class=\"type\">bool</span> *hasValue)</span> </span>&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"keyword\">auto</span> data = <span class=\"built_in\">getDataForKey</span>(key);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (data.<span class=\"built_in\">length</span>() &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"function\">CodedInputData <span class=\"title\">input</span><span class=\"params\">(data.getPtr(), data.length())</span></span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (hasValue != <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">                *hasValue = <span class=\"literal\">true</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> input.<span class=\"built_in\">readInt32</span>();</span><br><span class=\"line\">        &#125; </span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  \t...</span><br><span class=\"line\">    <span class=\"keyword\">return</span> defaultValue;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"mmkv-与-SharedPreferences\"><a href=\"#mmkv-与-SharedPreferences\" class=\"headerlink\" title=\"mmkv 与 SharedPreferences\"></a>mmkv 与 SharedPreferences</h2><p>以下是 <strong>MMKV</strong> 与 <strong>SharedPreferences</strong> 的优劣势对比总结，结合性能、安全性、功能支持等核心维度进行分析：</p>\n<h3 id=\"性能对比\"><a href=\"#性能对比\" class=\"headerlink\" title=\"性能对比\"></a><strong>性能对比</strong></h3><table>\n<thead>\n<tr>\n<th align=\"left\"><strong>维度</strong></th>\n<th align=\"left\"><strong>SharedPreferences</strong></th>\n<th align=\"left\"><strong>MMKV</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><strong>读写速度</strong></td>\n<td align=\"left\">慢（同步 I&#x2F;O，多次数据拷贝）</td>\n<td align=\"left\">快（<code>mmap</code> 零拷贝，内存直接操作）</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>线程安全</strong></td>\n<td align=\"left\">需自行加锁（<code>apply()</code> 异步写入仍有风险）</td>\n<td align=\"left\">内置多线程锁（文件锁 + 内存锁）</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>大数据量支持</strong></td>\n<td align=\"left\">性能急剧下降（全量 XML 解析&#x2F;序列化）</td>\n<td align=\"left\">高效（增量更新，Protobuf 编码）</td>\n</tr>\n</tbody></table>\n<h3 id=\"安全性与稳定性\"><a href=\"#安全性与稳定性\" class=\"headerlink\" title=\"安全性与稳定性\"></a><strong>安全性与稳定性</strong></h3><table>\n<thead>\n<tr>\n<th align=\"left\"><strong>维度</strong></th>\n<th align=\"left\"><strong>SharedPreferences</strong></th>\n<th align=\"left\"><strong>MMKV</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><strong>数据加密</strong></td>\n<td align=\"left\">无（明文存储）</td>\n<td align=\"left\">支持 AES-128&#x2F;AES-256 加密</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>崩溃恢复</strong></td>\n<td align=\"left\">可能因异常导致 XML 损坏</td>\n<td align=\"left\">通过 CRC 校验 + 备份文件保障完整性</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>系统版本适配</strong></td>\n<td align=\"left\">部分版本有 ANR 问题（如 <code>apply()</code>）</td>\n<td align=\"left\">无系统级兼容性问题</td>\n</tr>\n</tbody></table>\n<h3 id=\"功能支持\"><a href=\"#功能支持\" class=\"headerlink\" title=\"功能支持\"></a><strong>功能支持</strong></h3><table>\n<thead>\n<tr>\n<th align=\"left\"><strong>维度</strong></th>\n<th align=\"left\"><strong>SharedPreferences</strong></th>\n<th align=\"left\"><strong>MMKV</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><strong>多进程</strong></td>\n<td align=\"left\">不支持（跨进程数据不同步）</td>\n<td align=\"left\">支持（通过文件锁 + <code>mmap</code> 共享内存）</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>数据类型</strong></td>\n<td align=\"left\">仅支持基本类型（int&#x2F;String 等）</td>\n<td align=\"left\">支持基本类型、二进制数据（MMBuffer）</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>加密存储</strong></td>\n<td align=\"left\">明文存储（XML）</td>\n<td align=\"left\">支持 AES 加密（可选）</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>增量更新</strong></td>\n<td align=\"left\">全量写入（即使只改一个键值）</td>\n<td align=\"left\">仅追加新数据，定期整理</td>\n</tr>\n</tbody></table>\n<p>从上面的对比看看，mmkv 在很多层面都是领先 SharedPreferences 的，那么 mmkv 是否有缺陷呢？答案是有的。</p>\n<blockquote>\n<p>任何的操作系统、任何的软件，在往磁盘写数据的过程中如果发生了意外——例如程序崩溃，或者断电关机——磁盘里的文件就会以这种写了一半的、不完整的形式被保留。写了一半的数据怎么用啊？没法用，这就是文件的损坏。这种问题是不可能避免的，MMKV 虽然由于底层机制的原因，在程序崩溃的时候不会影响数据往磁盘的写入，但断电关机之类的操作系统级别的崩溃，MMKV 就没办法了，文件照样会损坏。对于这种文件损坏，SharedPreferences 和 DataStore 的应对方式是在每次写入新数据之前都对现有文件做一次自动备份，这样在发生了意外出现了文件损坏之后，它们就会把备份的数据恢复过来；而 MMKV，没有这种自动的备份和恢复，那么当文件发生了损坏，数据就丢了，之前保存的各种信息只能被重置。也就是说，MMKV 是唯一会丢数据的方案。</p>\n</blockquote>\n<p>在 mmkv 里面有 <a href=\"https://info.support.huawei.com/info-finder/encyclopedia/zh/CRC.html\">CRC</a> 校验，如果不通过的话，将会废弃掉之前所有的数据。在 mmkv 里面也有人反馈：<a href=\"https://github.com/Tencent/MMKV/issues/729\">https://github.com/Tencent/MMKV/issues/729</a> 在写入的过程中因为一些特殊情况写入失败，会导致本地的文件损坏且不可recovery。</p>\n<p>那有什么办法避免这个问题呢？有大佬开源另一个 KV 框架 <a href=\"https://github.com/BillyWei01/FastKV\">FastKV</a>对这个问题进行了处理，采用通过double-write等方法确保数据的完整性，原理是数据依次写入A&#x2F;B两个文件，如果写入A过程中崩溃，B仍是完整的，如果A完整写入了，则B写入时崩溃也不要紧。这种实现方式理论上是不错的，不太清楚 mmkv 为什么没有采取这样的逻辑。不过这个库并没有经过大量业务进行验证，只能作为一个学习的方案先看看。</p>\n<p>另外谷歌已经开发了新的KV存储框架<a href=\"https://cloud.google.com/datastore/docs/concepts/overview?hl=zh-cn\">DataStore</a>，<code>SharedPreferences</code>也将渐渐地退出历史的舞台了。不过 DataStore 的性能目前仍然没有 mmkv 的好。关于这三者的比较可以查看： <a href=\"https://juejin.cn/post/7112268981163016229\">《Android 的键值对存储有没有最优解？》</a></p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>这篇文章深入剖析了 <strong>MMKV</strong>（腾讯开源的高性能键值存储组件）的核心设计与实现原理，重点对比了传统 I&#x2F;O 与 <code>mmap</code> 内存映射的差异，并详细分析了 MMKV 的读写流程以及和 SharedPreferences 的各方面对比。</p>\n<p><strong>参考</strong></p>\n<p><a href=\"https://juejin.cn/post/7112268981163016229\">《Android 的键值对存储有没有最优解？》</a></p>\n<p><a href=\"https://yangjie2.github.io/2021/11/14/mmap%E5%8E%9F%E7%90%86%E4%B8%8E%E5%BA%94%E7%94%A8/\">《mmap原理与应用》</a></p>\n<p><a href=\"https://blog.csdn.net/zhanglh046/article/details/115603788\">《文件内存映射和传统I&#x2F;O机制》</a></p>\n<p><a href=\"https://blog.csdn.net/luo_boke/article/details/109311432\">Android 内存映射mmap浅谈</a></p>\n","cover":null,"images":["https://cdn.julis.wang/blog/img/ee519ba873acf3f80fd4ccec86ed72e7.png","https://cdn.julis.wang/blog/img/mmap_1.png","https://cdn.julis.wang/blog/img/mmap_2_1.png"],"content":"<p>在平时的业务中，需要用到轻量级存储业务中的数据（例如设置数据存储），绝大多数时候 Anroid 管法提供的 <a href=\"https://developer.android.com/reference/android/content/SharedPreferences\">SharedPreferences</a>  组件就能实现，但针对一些需要高效的场景它就不那么使用了，不适合存储大量数据、多线程操作的不安全性、数据明文不安全性，以及不支持多进程之间的调用等各种问题。<br><a href=\"https://github.com/Tencent/MMKV\">MMKV</a>的诞生就是为了解决以上的问题，本文主要对 MMKV 源码的学习知识点进行一些总结。</p>\n<h2 id=\"核心设计与原理\"><a href=\"#核心设计与原理\" class=\"headerlink\" title=\"核心设计与原理\"></a>核心设计与原理</h2><p>在官方的开源工程中可以看到如下的一些介绍</p>\n<blockquote>\n<p>MMKV 是基于 mmap 内存映射的 key-value 组件，底层序列化&#x2F;反序列化使用 protobuf 实现，性能高，稳定性强。从 2015 年中至今在微信上使用，其性能和稳定性经过了时间的验证。</p>\n</blockquote>\n<h3 id=\"传统I-O与-mmap\"><a href=\"#传统I-O与-mmap\" class=\"headerlink\" title=\"传统I&#x2F;O与 mmap\"></a>传统I&#x2F;O与 mmap</h3><p>mmap 这个是 mmkv 实现的核心，没有 mmap 那么就没有 mmkv。对于 <code>SharedPreferences</code>的实现来说，每次的数据更新都将操作本地文件，而本地文件的写入是通过传统的I&#x2F;O实现。要理解两者的实现差异，需要先理解 Linux <strong>用户空间与内核空间</strong>设计。</p>\n<h4 id=\"用户空间与内核空间\"><a href=\"#用户空间与内核空间\" class=\"headerlink\" title=\"用户空间与内核空间\"></a><strong>用户空间与内核空间</strong></h4><p>Linux的进程是相互独立的，一个进程是不能直接操作或者访问别一个进程空间的。每个进程空间还分为用户空间和内核（Kernel）空间，相当于把Kernel和上层的应用程序抽像的隔离开。</p>\n<p><strong>用户空间</strong>和<strong>内核空间</strong>，用户空间是用户程序代码运行的地方，内核空间是内核代码运行的地方。为了安全，它们是隔离的，即使用户的程序崩溃了，内核也不受影响。</p>\n<p>这里有两个隔离，一个进程间是相互隔离的，二是进程内有用户空间和内核空间的隔离。</p>\n<p>进程间，用户空间的数据不可共享，所以用户空间 &#x3D; 不可共享空间<br>进程间，内核空间的数据可共享，所以内核空间 &#x3D; 可共享空间，所以Linux系统的内存通常是MemFree+Cache<br>所有进程共用1个内核空间。</p>\n<h4 id=\"传统I-O读写流程\"><a href=\"#传统I-O读写流程\" class=\"headerlink\" title=\"传统I&#x2F;O读写流程\"></a><strong>传统I&#x2F;O读写流程</strong></h4><p>常规文件读写操作（调用read&#x2F;fread等函数）过程如下：</p>\n<ul>\n<li><p>进程发起读写文件请求。</p>\n</li>\n<li><p>内核通过查找进程文件符表，定位到内核已打开文件集上的文件信息，从而找到此文件的<code>inode</code>。</p>\n</li>\n<li><p><code>inode</code> 在 <code>address_space</code> 上查找要请求的文件页是否已经缓存在页缓存中。如果存在，则直接返回这片文件页的内容。</p>\n</li>\n<li><p>如果不存在，则通过 <code>inode</code> 定位到文件磁盘地址，将数据从磁盘复制到页缓存。之后再次发起读页面过程，进而将页缓存中的数据发给用户进程。</p>\n<blockquote>\n<p><strong>什么是 inode</strong> ?</p>\n<p>全称为 index node，既<strong>存储文件元信息的区域</strong>，中文译名“索引节点”。<br>包含：文件权限、文件拥有者的UID、文件的大小等等。</p>\n</blockquote>\n</li>\n</ul>\n<img src=\"https://cdn.julis.wang/blog/img/ee519ba873acf3f80fd4ccec86ed72e7.png\">\n\n\n<p>总结来说，常规文件操作为了提高读写效率和保护磁盘，使用了页缓存机制。这样造成读文件时需要先将文件页从磁盘拷贝到页缓存中，由于页缓存处在内核空间，不能被用户进程直接寻址访问，所以还需要将页缓存中的数据页再次拷贝到用户空间中。这样，通过了两次数据拷贝过程，才能完成<strong>进程</strong>对<strong>文件</strong>内容的访问。</p>\n<h4 id=\"mmap基本概念和原理\"><a href=\"#mmap基本概念和原理\" class=\"headerlink\" title=\"mmap基本概念和原理\"></a><strong>mmap基本概念和原理</strong></h4><p>内存映射（mmap），就是<strong>将文件的磁盘扇区映射到进程的虚拟内存空间</strong>的过程，即将一个文件映射到进程的虚拟空间，实现文件磁盘地址和进程虚拟空间中一段虚拟地址的一一对应关系。实现这样的映射关系后，进程就可以采用指针的方式读写操作这一段内存，而系统会自动回写脏页面到对应的文件磁盘上，即完成了对文件的操作而不必再调用read,write等系统调用函数。</p>\n<img src=\"https://cdn.julis.wang/blog/img/mmap_1.png\">\n\n<p>由上图可知，进程的虚拟地址空间，由多个虚拟内存区域构成。每个虚拟内存区域都是进程在虚拟地址空间中的一个同质区间，即具有同样特性的连续地址范围。上图中所示的text数据段（代码段）、初始数据段、BSS数据段、堆、栈和内存映射，都是一个独立的虚拟内存区域。内存映射的地址空间处在堆栈之间的空余部分。</p>\n<p>linux内核使用 <code>vm_area_struc</code>t 结构来表示一个独立的虚拟内存区域，由于每个不同质的虚拟内存区域功能和内部机制都不同，因此一个进程使用多个 <code>vm_area_struct</code> 结构来分别表示不同类型的虚拟内存区域。各个 <code>vm_area_struct</code> 结构使用链表或者树形结构链接，方便进程快速访问，如下图所示：</p>\n<img src=\"https://cdn.julis.wang/blog/img/mmap_2_1.png\">\n\n<p><code>vm_area_struct</code> 结构中包含区域起始和终止地址以及其他相关信息。这样，进程对某一虚拟内存区域的任何操作需要用要的信息，都可以从 <code>vm_area_struct</code> 中获得。mmap函数就是要创建一个新的 <code>vm_area_struct</code> 结构，并将其与文件的物理磁盘地址相连。</p>\n<p>mmap内存映射的实现过程，总的来说可以分为三个阶段：</p>\n<p><strong>阶段一：进程启动映射过程，并在虚拟地址空间中为映射创建虚拟映射区域</strong></p>\n<ul>\n<li>进程在用户空间调用mmap库函数</li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> *<span class=\"title\">mmap</span><span class=\"params\">(<span class=\"type\">void</span> *addr, <span class=\"type\">size_t</span> length, <span class=\"type\">int</span> prot, <span class=\"type\">int</span> flags, <span class=\"type\">int</span> fd, <span class=\"type\">off_t</span> offset)</span></span>;</span><br></pre></td></tr></table></figure>\n\n<p><code>addr</code>：指定映射的虚拟内存地址，可以设置为 NULL，让内核自动选择合适的虚拟内存地址</p>\n<p><code>length</code>：映射的长度。</p>\n<p><code>prot</code>：映射内存的保护模式，可选值如下：  </p>\n<p><code>flags</code>：指定映射的类型</p>\n<p><code>fd</code>：进行映射的文件句柄。</p>\n<p><code>offset</code>：文件偏移量（从文件的何处开始映射）</p>\n<ul>\n<li><p>在当前进程的虚拟地址空间中，寻找一段空闲的满足要求的连续的虚拟地址</p>\n</li>\n<li><p>为此虚拟区分配一个 <code>vm_area_struct</code> 结构，接着对这个结构的各个域进行了初始化</p>\n</li>\n<li><p>将新创建的虚拟区结构 <code>vm_area_struct</code> 对象插入到进程的虚拟地址区域链表&#x2F;树中</p>\n</li>\n</ul>\n<p><strong>阶段二：调用内核空间的mmap函数（不同于用户空间函数），实现文件物理地址和进程虚拟地址的一一映射关系</strong></p>\n<ul>\n<li><p>为映射分配了新的虚拟地址区域后，通过待映射的文件指针，在文件描述符表中找到对应的文件描述符，通过文件描述符，链接到内核“已打开文件集”中该文件的文件结构体（struct file），每个文件结构体维护着和这个已打开文件相关各项信息。</p>\n</li>\n<li><p>为映射分配了新的虚拟地址区域后，通过待映射的文件指针，在文件描述符表中找到对应的文件描述符，通过文件描述符，链接到内核“已打开文件集”中该文件的文件结构体（struct file），每个文件结构体维护着和这个已打开文件相关各项信息。</p>\n</li>\n<li><p>通过该文件的文件结构体，链接到 <code>file_operations</code> 模块，调用内核mmap函数，其原型为：</p>\n</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">int mmap(struct file *filp, struct vm_area_struct *vma) //不同于用户空间mmap库函数</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>内核mmap函数通过虚拟文件系统inode模块定位到文件磁盘物理地址。</p>\n</li>\n<li><p>通过 <code>remap_pfn_range</code> 函数建立页表，即实现了文件地址和虚拟地址区域的映射关系。此时，这片虚拟地址并没有任何数据关联到物理内存(主存)中。</p>\n</li>\n</ul>\n<blockquote>\n<p>主存</p>\n<p>主存储器（Main memory），简称主存。是计算机硬件的一个重要部件，其作用是存放指令和数据，并能由中央处理器（CPU）直接随机存取</p>\n</blockquote>\n<p><strong>阶段三：进程发起对这片映射地址空间的访问，引发缺页异常，实现文件内容到主存（物理内存）的拷贝</strong></p>\n<blockquote>\n<p>前两个阶段仅在于创建虚拟区间并完成地址映射，但是并没有将任何文件数据的拷贝至主存。真正的文件读取是当进程发起读或写操作时</p>\n</blockquote>\n<ul>\n<li><p>进程的读或写操作访问虚拟地址空间这一段映射地址，通过查询页表，发现这一段地址并不在物理页上。因为目前只建立了地址映射，真正的硬盘数据还没有拷贝到内存中，因此引发缺页异常。</p>\n</li>\n<li><p>缺页异常进行一系列判断，确定无非法操作后，内核发起请求调页过程。</p>\n</li>\n<li><p>调页过程先在交换缓存空间（swap cache）中寻找需要访问的内存页，如果没有则调用nopage函数把所缺的页从磁盘装入到主存中。</p>\n</li>\n<li><p>之后进程即可对这片主存进行读或者写的操作，如果写操作改变了其内容，一定时间后系统会自动回写脏页面到对应磁盘地址，也即完成了写入到文件的过程。</p>\n</li>\n</ul>\n<blockquote>\n<p>修改过的脏页面并不会立即更新回文件中，而是有一段时间的延迟，可以调用<code>msync()</code>来强制同步, 这样所写的内容就能立即保存到文件里了</p>\n</blockquote>\n<p>常规文件操作需要从磁盘到内核空间页缓存再到用户空间主存的两次数据拷贝。而mmap文件映射，只需要从磁盘到用户空间主存的一次数据拷贝过程。mmap的关键点是实现了用户空间和内核空间的数据直接交互而省去了空间不同数据不通的繁琐过程，因此 mmap 效率更高。</p>\n<p>以上是 mmap 的基本概念和原理，搞明白了这些才能看明白整个 mmkv 里面的逻辑处理</p>\n<h3 id=\"mmkv-一次-put-的流程\"><a href=\"#mmkv-一次-put-的流程\" class=\"headerlink\" title=\"mmkv 一次 put 的流程\"></a>mmkv 一次 put 的流程</h3><p>mmkv初始化比较简单，主要涉及到一些配置的初始化，文件夹创建等，其中最重要的逻辑 mmap 调用被封装到一个 <code>MemoryFile</code>到对象里面 </p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">MemoryFile::mmap</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">auto</span> oldPtr = m_ptr;</span><br><span class=\"line\">    <span class=\"keyword\">auto</span> mode = m_readOnly ? PROT_READ : (PROT_READ | PROT_WRITE);</span><br><span class=\"line\">    m_ptr = (<span class=\"type\">char</span> *) ::<span class=\"built_in\">mmap</span>(m_ptr, m_size, mode, MAP_SHARED, m_diskFile.m_fd, <span class=\"number\">0</span>);</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>主要记录一下一次 put 任务的流程，以 <code>mmkv.putInt(&quot;int&quot;, 1)</code>为例，进过 JNI 的调用到了</p>\n<p><strong>native-birdge.cpp</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">MMKV_JNI jboolean <span class=\"title\">encodeInt</span><span class=\"params\">(JNIEnv *env, jobject obj, jlong handle, jstring oKey, jint value)</span> </span>&#123;</span><br><span class=\"line\">    MMKV *kv = <span class=\"built_in\">reinterpret_cast</span>&lt;MMKV *&gt;(handle);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (kv &amp;&amp; oKey) &#123;</span><br><span class=\"line\">        string key = <span class=\"built_in\">jstring2string</span>(env, oKey);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (jboolean) kv-&gt;<span class=\"built_in\">set</span>((<span class=\"type\">int32_t</span>) value, key);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (jboolean) <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>进入了<strong>MMVK.cpp</strong>的 </p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">MMKV::set</span><span class=\"params\">(<span class=\"type\">int32_t</span> value, MMKVKey_t key, <span class=\"type\">uint32_t</span> expireDuration)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">isKeyEmpty</span>(key)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"type\">size_t</span> size = <span class=\"built_in\">mmkv_unlikely</span>(m_enableKeyExpire) ? Fixed32Size + <span class=\"built_in\">pbInt32Size</span>(value) : <span class=\"built_in\">pbInt32Size</span>(value);</span><br><span class=\"line\">    <span class=\"function\">MMBuffer <span class=\"title\">data</span><span class=\"params\">(size)</span></span>;</span><br><span class=\"line\">    <span class=\"function\">CodedOutputData <span class=\"title\">output</span><span class=\"params\">(data.getPtr(), size)</span></span>;</span><br><span class=\"line\">    output.<span class=\"built_in\">writeInt32</span>(value);</span><br><span class=\"line\">    <span class=\"comment\">// ... 省略一些校验逻辑</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">setDataForKey</span>(std::<span class=\"built_in\">move</span>(data), key);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这一步主要是准备一下数据，并使用 <code>MMBuffer</code> <code>CodedOutputData</code>将写入的数据进行一次包装（不仅仅是 key-value，还有数据size等等），实际调用在<code>setDataForKey</code></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">MMKV::setDataForKey</span><span class=\"params\">(MMBuffer &amp;&amp;data, MMKVKey_t key, <span class=\"type\">bool</span> isDataHolder)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">checkLoadData</span>(); <span class=\"comment\">// 状态同步相关的逻辑</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (m_crypter) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// ... 省略加密的处理逻辑</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">auto</span> itr = m_dic-&gt;<span class=\"built_in\">find</span>(key);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (itr != m_dic-&gt;<span class=\"built_in\">end</span>()) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// compare data before appending to file</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (<span class=\"built_in\">isCompareBeforeSetEnabled</span>()) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">auto</span> basePtr = (<span class=\"type\">uint8_t</span> *) (m_file-&gt;<span class=\"built_in\">getMemory</span>()) + Fixed32Size;</span><br><span class=\"line\">                MMBuffer oldValueData = itr-&gt;second.<span class=\"built_in\">toMMBuffer</span>(basePtr);</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (isDataHolder) &#123;</span><br><span class=\"line\">                    <span class=\"function\">CodedInputData <span class=\"title\">inputData</span><span class=\"params\">(oldValueData.getPtr(), oldValueData.length())</span></span>;</span><br><span class=\"line\">                    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                        <span class=\"comment\">// read extra holder header bytes and to real MMBuffer</span></span><br><span class=\"line\">                        oldValueData = CodedInputData::<span class=\"built_in\">readRealData</span>(oldValueData);</span><br><span class=\"line\">                        <span class=\"keyword\">if</span> (oldValueData == data) &#123;</span><br><span class=\"line\">                            <span class=\"comment\">// MMKVInfo(&quot;[key] %s, set the same data&quot;, key.c_str());</span></span><br><span class=\"line\">                            <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125; <span class=\"built_in\">catch</span> (std::exception &amp;exception) &#123;</span><br><span class=\"line\">                        <span class=\"built_in\">MMKVWarning</span>(<span class=\"string\">&quot;compareBeforeSet exception: %s&quot;</span>, exception.<span class=\"built_in\">what</span>());</span><br><span class=\"line\">                    &#125; <span class=\"built_in\">catch</span> (...) &#123;</span><br><span class=\"line\">                        <span class=\"built_in\">MMKVWarning</span>(<span class=\"string\">&quot;compareBeforeSet fail&quot;</span>);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                     ...</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"type\">bool</span> onlyOneKey = !<span class=\"built_in\">isMultiProcess</span>() &amp;&amp; m_dic-&gt;<span class=\"built_in\">size</span>() == <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (<span class=\"built_in\">mmkv_likely</span>(!m_enableKeyExpire)) &#123;</span><br><span class=\"line\">                ...</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                KVHolderRet_t ret;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (onlyOneKey) &#123;</span><br><span class=\"line\">                    ret = <span class=\"built_in\">overrideDataWithKey</span>(data, key, isDataHolder);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    ret = <span class=\"built_in\">appendDataWithKey</span>(data, key, isDataHolder);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (!ret.first) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                itr = m_dic-&gt;<span class=\"built_in\">find</span>(key);</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (itr != m_dic-&gt;<span class=\"built_in\">end</span>()) &#123;</span><br><span class=\"line\">                    itr-&gt;second = std::<span class=\"built_in\">move</span>(ret.second);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// in case filterExpiredKeys() is triggered</span></span><br><span class=\"line\">                    m_dic-&gt;<span class=\"built_in\">emplace</span>(key, std::<span class=\"built_in\">move</span>(ret.second));</span><br><span class=\"line\">                    <span class=\"built_in\">mmkv_retain_key</span>(key);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">           ...</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    m_hasFullWriteback = <span class=\"literal\">false</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里面的代码逻辑很长，做了很多 if-else 的逻辑，最终走向两个大分支：</p>\n<p>key 是新增的走 <code>appendDataWithKey</code></p>\n<p>key 将会覆盖原来的将会走 <code>overrideDataWithKey</code></p>\n<p>有这两个分支，主要是因为 mmkv 存储采用的  <a href=\"https://protobuf.com.cn/\">protobuf 协议</a>，另外有一个很重要的方法也在这里执行了：<code>checkLoadData();</code>  安卓里面的多进程实现，将需要这里的一些逻辑，在 mmkv多进程原理篇进行讲解。</p>\n<p><code>appendDataWithKey</code> 转换为 <code>MMBuffer</code>并继续向下执行</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">KVHolderRet_t <span class=\"title\">MMKV::appendDataWithKey</span><span class=\"params\">(<span class=\"type\">const</span> MMBuffer &amp;data, MMKVKey_t key, <span class=\"type\">bool</span> isDataHolder)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">auto</span> keyData = <span class=\"built_in\">MMBuffer</span>((<span class=\"type\">void</span> *) key.<span class=\"built_in\">data</span>(), key.<span class=\"built_in\">size</span>(), MMBufferNoCopy);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">doAppendDataWithKey</span>(data, keyData, isDataHolder, <span class=\"built_in\">static_cast</span>&lt;<span class=\"type\">uint32_t</span>&gt;(keyData.<span class=\"built_in\">length</span>()));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>doAppendDataWithKey</code> 里面的代码也很长，不过也就只做一件事：将k-v值写入到文件里面做准备，真正的写入逻辑在 <code>m_output-&gt;writeData(keyData);</code>，这里先后调用了两次 <code>writeData</code>,是先写入key再写入了 value。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">KVHolderRet_t</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">MMKV::doAppendDataWithKey</span><span class=\"params\">(<span class=\"type\">const</span> MMBuffer &amp;data, <span class=\"type\">const</span> MMBuffer &amp;keyData, <span class=\"type\">bool</span> isDataHolder, <span class=\"type\">uint32_t</span> originKeyLength)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">auto</span> isKeyEncoded = (originKeyLength &lt; keyData.<span class=\"built_in\">length</span>());</span><br><span class=\"line\">    <span class=\"keyword\">auto</span> keyLength = <span class=\"built_in\">static_cast</span>&lt;<span class=\"type\">uint32_t</span>&gt;(keyData.<span class=\"built_in\">length</span>());</span><br><span class=\"line\">    <span class=\"keyword\">auto</span> valueLength = <span class=\"built_in\">static_cast</span>&lt;<span class=\"type\">uint32_t</span>&gt;(data.<span class=\"built_in\">length</span>());</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (isDataHolder) &#123;</span><br><span class=\"line\">        valueLength += <span class=\"built_in\">pbRawVarint32Size</span>(valueLength);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// size needed to encode the key</span></span><br><span class=\"line\">    <span class=\"type\">size_t</span> size = isKeyEncoded ? keyLength : (keyLength + <span class=\"built_in\">pbRawVarint32Size</span>(keyLength));</span><br><span class=\"line\">    <span class=\"comment\">// size needed to encode the value</span></span><br><span class=\"line\">    size += valueLength + <span class=\"built_in\">pbRawVarint32Size</span>(valueLength);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">SCOPED_LOCK</span>(m_exclusiveProcessLock);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">bool</span> hasEnoughSize = <span class=\"built_in\">ensureMemorySize</span>(size);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!hasEnoughSize || !<span class=\"built_in\">isFileValid</span>()) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">make_pair</span>(<span class=\"literal\">false</span>, <span class=\"built_in\">KeyValueHolder</span>());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">\t\t...</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (isKeyEncoded) &#123;</span><br><span class=\"line\">            m_output-&gt;<span class=\"built_in\">writeRawData</span>(keyData);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            m_output-&gt;<span class=\"built_in\">writeData</span>(keyData);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (isDataHolder) &#123;</span><br><span class=\"line\">            m_output-&gt;<span class=\"built_in\">writeRawVarint32</span>((<span class=\"type\">int32_t</span>) valueLength);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        m_output-&gt;<span class=\"built_in\">writeData</span>(data); <span class=\"comment\">// note: write size of data</span></span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">    ...</span><br><span class=\"line\">    m_actualSize += size;</span><br><span class=\"line\">    <span class=\"built_in\">updateCRCDigest</span>(ptr, size);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">make_pair</span>(<span class=\"literal\">true</span>, <span class=\"built_in\">KeyValueHolder</span>(originKeyLength, valueLength, offset));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>writeData</code> 进行了两步先写入数据的 <strong>长度信息</strong>，再写入真实的数据，这里还是因为  <a href=\"https://protobuf.com.cn/\">protobuf 协议</a>设计相关</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">CodedOutputData::writeData</span><span class=\"params\">(<span class=\"type\">const</span> MMBuffer &amp;value)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>-&gt;<span class=\"built_in\">writeRawVarint32</span>((<span class=\"type\">int32_t</span>) value.<span class=\"built_in\">length</span>());</span><br><span class=\"line\">    <span class=\"keyword\">this</span>-&gt;<span class=\"built_in\">writeRawData</span>(value);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>最终走到了<code>writeRawData</code> 关键代码</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">CodedOutputData::writeRawData</span><span class=\"params\">(<span class=\"type\">const</span> MMBuffer &amp;data)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"type\">size_t</span> numberOfBytes = data.<span class=\"built_in\">length</span>();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (m_position + numberOfBytes &gt; m_size) &#123;</span><br><span class=\"line\">       ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">memcpy</span>(m_ptr + m_position, data.<span class=\"built_in\">getPtr</span>(), numberOfBytes);</span><br><span class=\"line\">    m_position += numberOfBytes;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>核心逻辑使用 <code>memcpy</code> 将数据直接通过 memcpy 直接在内存层面进行拷贝，而这里的 <code>m_ptr</code>就是最开始通过<code>mmap</code>创建出来的指针！！到这里一次写入基本上就结束了。</p>\n<h3 id=\"mmkv-一次-get-的流程\"><a href=\"#mmkv-一次-get-的流程\" class=\"headerlink\" title=\"mmkv 一次 get 的流程\"></a>mmkv 一次 get 的流程</h3><p>依然先通过 JNI走到</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">MMKV_JNI jint <span class=\"title\">decodeInt</span><span class=\"params\">(JNIEnv *env, jobject obj, jlong handle, jstring oKey, jint defaultValue)</span> </span>&#123;</span><br><span class=\"line\">    MMKV *kv = <span class=\"built_in\">reinterpret_cast</span>&lt;MMKV *&gt;(handle);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (kv &amp;&amp; oKey) &#123;</span><br><span class=\"line\">        string key = <span class=\"built_in\">jstring2string</span>(env, oKey);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (jint) kv-&gt;<span class=\"built_in\">getInt32</span>(key, defaultValue);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> defaultValue;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>再到 mmkv getInt32</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int32_t</span> <span class=\"title\">MMKV::getInt32</span><span class=\"params\">(MMKVKey_t key, <span class=\"type\">int32_t</span> defaultValue, <span class=\"type\">bool</span> *hasValue)</span> </span>&#123;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">    <span class=\"built_in\">SCOPED_LOCK</span>(m_lock);</span><br><span class=\"line\">    <span class=\"built_in\">SCOPED_LOCK</span>(m_sharedProcessLock);</span><br><span class=\"line\">    <span class=\"keyword\">auto</span> data = <span class=\"built_in\">getDataForKey</span>(key);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (data.<span class=\"built_in\">length</span>() &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"function\">CodedInputData <span class=\"title\">input</span><span class=\"params\">(data.getPtr(), data.length())</span></span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (hasValue != <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">                *hasValue = <span class=\"literal\">true</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> input.<span class=\"built_in\">readInt32</span>();</span><br><span class=\"line\">        &#125; </span><br><span class=\"line\">        ...</span><br><span class=\"line\">    <span class=\"keyword\">return</span> defaultValue;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>getRawDataForKey</code>方法，主要有两个分支，一种是加密逻辑，另一种是非加密逻辑，但他们流程都差不多从一个  map 里面根据 key 获取一个对象（这个对象暂时并不是 get 最终的返回值），那这个 map 是从哪里来的呢？</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">MMBuffer <span class=\"title\">MMKV::getRawDataForKey</span><span class=\"params\">(MMKVKey_t key)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">checkLoadData</span>();</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">ifndef</span> MMKV_DISABLE_CRYPT</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (m_crypter) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">auto</span> itr = m_dicCrypt-&gt;<span class=\"built_in\">find</span>(key);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (itr != m_dicCrypt-&gt;<span class=\"built_in\">end</span>()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">auto</span> basePtr = (<span class=\"type\">uint8_t</span> *) (m_file-&gt;<span class=\"built_in\">getMemory</span>()) + Fixed32Size;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> itr-&gt;second.<span class=\"built_in\">toMMBuffer</span>(basePtr, m_crypter);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span></span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">auto</span> itr = m_dic-&gt;<span class=\"built_in\">find</span>(key);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (itr != m_dic-&gt;<span class=\"built_in\">end</span>()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">auto</span> basePtr = (<span class=\"type\">uint8_t</span> *) (m_file-&gt;<span class=\"built_in\">getMemory</span>()) + Fixed32Size;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> itr-&gt;second.<span class=\"built_in\">toMMBuffer</span>(basePtr);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    MMBuffer nan;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> nan;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>从源码里面溯源<code>m_dicCrypt</code>和 <code>m_dic</code> 是在 MMKV 初始化的时候生成的，主要逻辑在 <code>MMKV_IO .cpp</code>里面的 <code>loadFromFile</code>方法内：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">MMKV::loadFromFile</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">loadMetaInfoAndCheck</span>();</span><br><span class=\"line\">\t\t...</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!m_file-&gt;<span class=\"built_in\">isFileValid</span>()) &#123;</span><br><span class=\"line\">        m_file-&gt;<span class=\"built_in\">reloadFromFile</span>(m_expectedCapacity);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!m_file-&gt;<span class=\"built_in\">isFileValid</span>()) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">MMKVError</span>(<span class=\"string\">&quot;file [%s] not valid&quot;</span>, m_path.<span class=\"built_in\">c_str</span>());</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">bool</span> loadFromFile = <span class=\"literal\">false</span>, needFullWriteback = <span class=\"literal\">false</span>;</span><br><span class=\"line\">        <span class=\"built_in\">checkDataValid</span>(loadFromFile, needFullWriteback);</span><br><span class=\"line\">        ...</span><br><span class=\"line\">        <span class=\"keyword\">auto</span> ptr = (<span class=\"type\">uint8_t</span> *) m_file-&gt;<span class=\"built_in\">getMemory</span>();</span><br><span class=\"line\">        <span class=\"comment\">// loading</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (loadFromFile &amp;&amp; m_actualSize &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\t\t\t...</span><br><span class=\"line\">            <span class=\"function\">MMBuffer <span class=\"title\">inputBuffer</span><span class=\"params\">(ptr + Fixed32Size, m_actualSize, MMBufferNoCopy)</span></span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (m_crypter) &#123;</span><br><span class=\"line\">                <span class=\"built_in\">clearDictionary</span>(m_dicCrypt);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"built_in\">clearDictionary</span>(m_dic);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (needFullWriteback) &#123;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">ifndef</span> MMKV_DISABLE_CRYPT</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (m_crypter) &#123;</span><br><span class=\"line\">                    MiniPBCoder::<span class=\"built_in\">greedyDecodeMap</span>(*m_dicCrypt, inputBuffer, m_crypter);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span></span></span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    MiniPBCoder::<span class=\"built_in\">greedyDecodeMap</span>(*m_dic, inputBuffer);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">ifndef</span> MMKV_DISABLE_CRYPT</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (m_crypter) &#123;</span><br><span class=\"line\">                    MiniPBCoder::<span class=\"built_in\">decodeMap</span>(*m_dicCrypt, inputBuffer, m_crypter);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span></span></span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    MiniPBCoder::<span class=\"built_in\">decodeMap</span>(*m_dic, inputBuffer);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            m_output = <span class=\"keyword\">new</span> <span class=\"built_in\">CodedOutputData</span>(ptr + Fixed32Size, m_file-&gt;<span class=\"built_in\">getFileSize</span>() - Fixed32Size);</span><br><span class=\"line\">            m_output-&gt;<span class=\"built_in\">seek</span>(m_actualSize);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (needFullWriteback) &#123;</span><br><span class=\"line\">                <span class=\"built_in\">fullWriteback</span>();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// file not valid or empty, discard everything</span></span><br><span class=\"line\">            <span class=\"built_in\">SCOPED_LOCK</span>(m_exclusiveProcessLock);</span><br><span class=\"line\"></span><br><span class=\"line\">            m_output = <span class=\"keyword\">new</span> <span class=\"built_in\">CodedOutputData</span>(ptr + Fixed32Size, m_file-&gt;<span class=\"built_in\">getFileSize</span>() - Fixed32Size);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (m_actualSize &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                <span class=\"built_in\">writeActualSize</span>(<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"literal\">nullptr</span>, IncreaseSequence);</span><br><span class=\"line\">                <span class=\"built_in\">sync</span>(MMKV_SYNC);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"built_in\">writeActualSize</span>(<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"literal\">nullptr</span>, KeepSequence);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">\t\t\t\t...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    m_needLoadFromFile = <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>总统来说就是在初始化的时候就会将基于<code>protobuf</code>协议的本地文件里面的数据加载到内存，并将其放在一个 map 内，方便后续使用。</p>\n<p>回到 <code>int32_t MMKV::getInt32()</code>通过 <code>getDataForKey(key)</code>获取到一个<code>MMBuffer</code>对象，并通过 <strong>CodedInputData</strong>进行反序列化操作，读取 <strong>Varint32</strong> 的 <strong>valueSize</strong> 值，随后不断循环通过 <strong>CodedInputData</strong>  读取到<strong>value</strong> 值。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int32_t</span> <span class=\"title\">MMKV::getInt32</span><span class=\"params\">(MMKVKey_t key, <span class=\"type\">int32_t</span> defaultValue, <span class=\"type\">bool</span> *hasValue)</span> </span>&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"keyword\">auto</span> data = <span class=\"built_in\">getDataForKey</span>(key);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (data.<span class=\"built_in\">length</span>() &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"function\">CodedInputData <span class=\"title\">input</span><span class=\"params\">(data.getPtr(), data.length())</span></span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (hasValue != <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">                *hasValue = <span class=\"literal\">true</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> input.<span class=\"built_in\">readInt32</span>();</span><br><span class=\"line\">        &#125; </span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  \t...</span><br><span class=\"line\">    <span class=\"keyword\">return</span> defaultValue;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"mmkv-与-SharedPreferences\"><a href=\"#mmkv-与-SharedPreferences\" class=\"headerlink\" title=\"mmkv 与 SharedPreferences\"></a>mmkv 与 SharedPreferences</h2><p>以下是 <strong>MMKV</strong> 与 <strong>SharedPreferences</strong> 的优劣势对比总结，结合性能、安全性、功能支持等核心维度进行分析：</p>\n<h3 id=\"性能对比\"><a href=\"#性能对比\" class=\"headerlink\" title=\"性能对比\"></a><strong>性能对比</strong></h3><table>\n<thead>\n<tr>\n<th align=\"left\"><strong>维度</strong></th>\n<th align=\"left\"><strong>SharedPreferences</strong></th>\n<th align=\"left\"><strong>MMKV</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><strong>读写速度</strong></td>\n<td align=\"left\">慢（同步 I&#x2F;O，多次数据拷贝）</td>\n<td align=\"left\">快（<code>mmap</code> 零拷贝，内存直接操作）</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>线程安全</strong></td>\n<td align=\"left\">需自行加锁（<code>apply()</code> 异步写入仍有风险）</td>\n<td align=\"left\">内置多线程锁（文件锁 + 内存锁）</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>大数据量支持</strong></td>\n<td align=\"left\">性能急剧下降（全量 XML 解析&#x2F;序列化）</td>\n<td align=\"left\">高效（增量更新，Protobuf 编码）</td>\n</tr>\n</tbody></table>\n<h3 id=\"安全性与稳定性\"><a href=\"#安全性与稳定性\" class=\"headerlink\" title=\"安全性与稳定性\"></a><strong>安全性与稳定性</strong></h3><table>\n<thead>\n<tr>\n<th align=\"left\"><strong>维度</strong></th>\n<th align=\"left\"><strong>SharedPreferences</strong></th>\n<th align=\"left\"><strong>MMKV</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><strong>数据加密</strong></td>\n<td align=\"left\">无（明文存储）</td>\n<td align=\"left\">支持 AES-128&#x2F;AES-256 加密</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>崩溃恢复</strong></td>\n<td align=\"left\">可能因异常导致 XML 损坏</td>\n<td align=\"left\">通过 CRC 校验 + 备份文件保障完整性</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>系统版本适配</strong></td>\n<td align=\"left\">部分版本有 ANR 问题（如 <code>apply()</code>）</td>\n<td align=\"left\">无系统级兼容性问题</td>\n</tr>\n</tbody></table>\n<h3 id=\"功能支持\"><a href=\"#功能支持\" class=\"headerlink\" title=\"功能支持\"></a><strong>功能支持</strong></h3><table>\n<thead>\n<tr>\n<th align=\"left\"><strong>维度</strong></th>\n<th align=\"left\"><strong>SharedPreferences</strong></th>\n<th align=\"left\"><strong>MMKV</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><strong>多进程</strong></td>\n<td align=\"left\">不支持（跨进程数据不同步）</td>\n<td align=\"left\">支持（通过文件锁 + <code>mmap</code> 共享内存）</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>数据类型</strong></td>\n<td align=\"left\">仅支持基本类型（int&#x2F;String 等）</td>\n<td align=\"left\">支持基本类型、二进制数据（MMBuffer）</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>加密存储</strong></td>\n<td align=\"left\">明文存储（XML）</td>\n<td align=\"left\">支持 AES 加密（可选）</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>增量更新</strong></td>\n<td align=\"left\">全量写入（即使只改一个键值）</td>\n<td align=\"left\">仅追加新数据，定期整理</td>\n</tr>\n</tbody></table>\n<p>从上面的对比看看，mmkv 在很多层面都是领先 SharedPreferences 的，那么 mmkv 是否有缺陷呢？答案是有的。</p>\n<blockquote>\n<p>任何的操作系统、任何的软件，在往磁盘写数据的过程中如果发生了意外——例如程序崩溃，或者断电关机——磁盘里的文件就会以这种写了一半的、不完整的形式被保留。写了一半的数据怎么用啊？没法用，这就是文件的损坏。这种问题是不可能避免的，MMKV 虽然由于底层机制的原因，在程序崩溃的时候不会影响数据往磁盘的写入，但断电关机之类的操作系统级别的崩溃，MMKV 就没办法了，文件照样会损坏。对于这种文件损坏，SharedPreferences 和 DataStore 的应对方式是在每次写入新数据之前都对现有文件做一次自动备份，这样在发生了意外出现了文件损坏之后，它们就会把备份的数据恢复过来；而 MMKV，没有这种自动的备份和恢复，那么当文件发生了损坏，数据就丢了，之前保存的各种信息只能被重置。也就是说，MMKV 是唯一会丢数据的方案。</p>\n</blockquote>\n<p>在 mmkv 里面有 <a href=\"https://info.support.huawei.com/info-finder/encyclopedia/zh/CRC.html\">CRC</a> 校验，如果不通过的话，将会废弃掉之前所有的数据。在 mmkv 里面也有人反馈：<a href=\"https://github.com/Tencent/MMKV/issues/729\">https://github.com/Tencent/MMKV/issues/729</a> 在写入的过程中因为一些特殊情况写入失败，会导致本地的文件损坏且不可recovery。</p>\n<p>那有什么办法避免这个问题呢？有大佬开源另一个 KV 框架 <a href=\"https://github.com/BillyWei01/FastKV\">FastKV</a>对这个问题进行了处理，采用通过double-write等方法确保数据的完整性，原理是数据依次写入A&#x2F;B两个文件，如果写入A过程中崩溃，B仍是完整的，如果A完整写入了，则B写入时崩溃也不要紧。这种实现方式理论上是不错的，不太清楚 mmkv 为什么没有采取这样的逻辑。不过这个库并没有经过大量业务进行验证，只能作为一个学习的方案先看看。</p>\n<p>另外谷歌已经开发了新的KV存储框架<a href=\"https://cloud.google.com/datastore/docs/concepts/overview?hl=zh-cn\">DataStore</a>，<code>SharedPreferences</code>也将渐渐地退出历史的舞台了。不过 DataStore 的性能目前仍然没有 mmkv 的好。关于这三者的比较可以查看： <a href=\"https://juejin.cn/post/7112268981163016229\">《Android 的键值对存储有没有最优解？》</a></p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>这篇文章深入剖析了 <strong>MMKV</strong>（腾讯开源的高性能键值存储组件）的核心设计与实现原理，重点对比了传统 I&#x2F;O 与 <code>mmap</code> 内存映射的差异，并详细分析了 MMKV 的读写流程以及和 SharedPreferences 的各方面对比。</p>\n<p><strong>参考</strong></p>\n<p><a href=\"https://juejin.cn/post/7112268981163016229\">《Android 的键值对存储有没有最优解？》</a></p>\n<p><a href=\"https://yangjie2.github.io/2021/11/14/mmap%E5%8E%9F%E7%90%86%E4%B8%8E%E5%BA%94%E7%94%A8/\">《mmap原理与应用》</a></p>\n<p><a href=\"https://blog.csdn.net/zhanglh046/article/details/115603788\">《文件内存映射和传统I&#x2F;O机制》</a></p>\n<p><a href=\"https://blog.csdn.net/luo_boke/article/details/109311432\">Android 内存映射mmap浅谈</a></p>\n","categories":[],"tags":[{"name":"mmap","slug":"mmap","api":"api/tags/mmap.json"}],"api":"api/posts/2025/03/30/KV-存储之mmkv.json"},{"title":"RetroFit2 源码学习相关","slug":"Learn-from-RetroFit","date":"2025-03-17T12:28:00.000Z","updated":"2025-05-20T11:46:57.000Z","comments":true,"url":"2025/03/17/Learn-from-RetroFit/","excerpt":"<p>研究 <a href=\"https://github.com/square/retrofit\">retrofit</a> 目标：理解动态代理、注解、反射、学习它所用到的设计模式，达到自己能手写它的核心实现。</p>\n<p>最近终于有点精力能够去研究研究源码了， 真的是写的一个非常好的的开源库，以前刚接触安卓的时候扒拉过相关的源码，但是随着工作了几年之后，经验的积累，让我对源码里面的东西能够体会更深刻，自己也尝试去手写里面的核心实现，看完源码对整体的架构理解了之后，以为自己能很顺利的写下来，实则不然。<br>知识还是需要知行合一，这篇文章主要记录 <a href=\"https://github.com/square/retrofit\">retrofit</a>  的一些知识点。</p>\n<h3 id=\"retrofit-的设计模式\"><a href=\"#retrofit-的设计模式\" class=\"headerlink\" title=\"retrofit 的设计模式\"></a>retrofit 的设计模式</h3><p>retrofit 里面中使用了多种设计模式，以实现其灵活、可扩展和高性能的特性：</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">设计模式</th>\n<th align=\"left\">应用场景</th>\n<th align=\"left\">作用</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><strong>建造者模式</strong></td>\n<td align=\"left\"><code>Retrofit.Builder</code></td>\n<td align=\"left\">灵活配置 Retrofit 实例</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>工厂模式</strong></td>\n<td align=\"left\"><code>Converter.Factory</code>、<code>CallAdapter.Factory</code></td>\n<td align=\"left\">创建 Converter 和 CallAdapter 实例</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>动态代理模式</strong></td>\n<td align=\"left\">接口方法转换为 HTTP 请求</td>\n<td align=\"left\">运行时生成接口代理对象</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>适配器模式</strong></td>\n<td align=\"left\"><code>CallAdapter</code></td>\n<td align=\"left\">将 <code>Call</code> 适配为其他类型</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>装饰器模式</strong></td>\n<td align=\"left\"><code>OkHttp</code> 拦截器</td>\n<td align=\"left\">增强 HTTP 请求和响应的功能</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>观察者模式</strong></td>\n<td align=\"left\">与 <code>RxJava</code> 或 <code>LiveData</code> 结合</td>\n<td align=\"left\">实现异步数据流的订阅和通知</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>策略模式</strong></td>\n<td align=\"left\"><code>Converter</code> 和 <code>CallAdapter</code> 选择</td>\n<td align=\"left\">动态选择数据转换或调用适配策略</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>单例模式</strong></td>\n<td align=\"left\"><code>Retrofit</code> 实例共享</td>\n<td align=\"left\">确保全局只有一个 Retrofit 实例</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>模板方法模式</strong></td>\n<td align=\"left\"><code>Call</code> 的实现</td>\n<td align=\"left\">定义 HTTP 请求的执行流程</td>\n</tr>\n</tbody></table>\n<p><strong>retrofit 的动态代理模式</strong></p>\n<p>retrofit 用了诸多的设计模式，其中最经典的莫过于动态代理模式了，在了解 retrofit 之前，我一直以为这样的网络请求形式是最直观的，参考以前写的<a href=\"https://julis.wang/2019/05/13/%E5%9F%BA%E4%BA%8EVolley%E6%A1%86%E6%9E%B6%E7%9A%84%E8%BF%94%E5%9B%9E%E6%95%B0%E6%8D%AE%E7%9A%84%E8%8C%83%E5%9E%8B%E5%A4%84%E7%90%86/\">基于Volley框架的返回数据的范型处理</a></p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"code\"><pre><span class=\"line\">Request.<span class=\"keyword\">get</span>(</span><br><span class=\"line\">    url = url,</span><br><span class=\"line\">    params = param,</span><br><span class=\"line\">    listener = <span class=\"keyword\">object</span> : OnRequestListener&lt;Data&gt; &#123;</span><br><span class=\"line\">        <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onSuccess</span><span class=\"params\">(commonData: <span class=\"type\">CommonData</span>?, <span class=\"keyword\">data</span>: <span class=\"type\">Data</span>?)</span></span> &#123;&#125;</span><br><span class=\"line\">        <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onFailure</span><span class=\"params\">(errorCode: <span class=\"type\">Int</span>, errorMessage: <span class=\"type\">String</span>?)</span></span> &#123;&#125;</span><br><span class=\"line\">    &#125;)</span><br></pre></td></tr></table></figure>\n\n<p>以为这样很直观，逻辑也很清晰，实则 代码冗余，回调嵌套，如果有多个连续的请求，代码会变得难以维护，而 retrofit 搭配上协程能这样实现：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> <span class=\"keyword\">data</span> = apiService.getXXX(params)</span><br></pre></td></tr></table></figure>\n\n<p>简单到不能再简单，<code>动态代理</code>功不可没，上面的 apiService 是一个接口，由：<code> retrofit.create(ApiInterface::class.java)</code> 生成其实例，动态代理其核心实现：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> &lt;T&gt; T <span class=\"title function_\">create</span><span class=\"params\">(<span class=\"keyword\">final</span> Class&lt;T&gt; service)</span> &#123;</span><br><span class=\"line\">    validateServiceInterface(service);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (T)</span><br><span class=\"line\">        Proxy.newProxyInstance(</span><br><span class=\"line\">            service.getClassLoader(),</span><br><span class=\"line\">            <span class=\"keyword\">new</span> <span class=\"title class_\">Class</span>&lt;?&gt;[] &#123;service&#125;,</span><br><span class=\"line\">            <span class=\"keyword\">new</span> <span class=\"title class_\">InvocationHandler</span>() &#123;</span><br><span class=\"line\">              <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"type\">Platform</span> <span class=\"variable\">platform</span> <span class=\"operator\">=</span> Platform.get();</span><br><span class=\"line\">              <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Object[] emptyArgs = <span class=\"keyword\">new</span> <span class=\"title class_\">Object</span>[<span class=\"number\">0</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">              <span class=\"meta\">@Override</span></span><br><span class=\"line\">              <span class=\"keyword\">public</span> <span class=\"meta\">@Nullable</span> Object <span class=\"title function_\">invoke</span><span class=\"params\">(Object proxy, Method method, <span class=\"meta\">@Nullable</span> Object[] args)</span> <span class=\"keyword\">throws</span> Throwable &#123;</span><br><span class=\"line\">                <span class=\"comment\">// ....</span></span><br><span class=\"line\">                <span class=\"keyword\">return</span> platform.isDefaultMethod(method)</span><br><span class=\"line\">                    ? platform.invokeDefaultMethod(method, service, proxy, args)</span><br><span class=\"line\">                    : loadServiceMethod(method).invoke(args);</span><br><span class=\"line\">              &#125;</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n\n<p>由<code>loadServiceMethod(method).invoke(args)</code> 负责将接口方法（通过 Java 反射获取的 <code>Method</code> 对象）解析并转换为一个可执行的 HTTP 请求。</p>\n<p><code>Proxy.newProxyInstance</code> 方法，参数：</p>\n<ul>\n<li><p>ClassLoader loader 用于加载代理类的类加载器。</p>\n</li>\n<li><p>Class&lt;?&gt;[] interfaces 代理类需要实现的接口数组，代理对象将实现这些接口，并拦截对这些接口方法的调用。只能代理实现了接口的类，不能代理没有接口的类。</p>\n</li>\n<li><p>InvocationHandler h<br>调用处理器，负责处理代理对象上的方法调用。每次调用代理对象的方法时，都会调用 <code>InvocationHandler</code> 的 <code>invoke</code> 方法。对于 Retrofit 的接口我们并没有去“实现”它的方法，所有的逻辑都由&#96;&#96; retrofit.create()<code>方法里面返回的 </code>InvocationHandler<code>实现的 </code>invoke&#96;方法实现的。</p>\n</li>\n</ul>\n<h3 id=\"核心实现逻辑\"><a href=\"#核心实现逻辑\" class=\"headerlink\" title=\"核心实现逻辑\"></a>核心实现逻辑</h3><h4 id=\"协程的支持\"><a href=\"#协程的支持\" class=\"headerlink\" title=\"协程的支持\"></a><strong>协程的支持</strong></h4><p>Retrofit 支持多种异步编程模型，包括回调、RxJava 和协程等，这里主要记录一下对协程的支持。普通方法和异步逻辑的分叉在：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (!isKotlinSuspendFunction) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> new CallAdapted&lt;&gt;(requestFactory, callFactory, responseConverter, callAdapter);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (continuationWantsResponse) &#123;</span><br><span class=\"line\">      <span class=\"comment\">//noinspection unchecked Kotlin compiler guarantees ReturnT to be Object.</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> (HttpServiceMethod&lt;ResponseT, ReturnT&gt;)</span><br><span class=\"line\">          new SuspendForResponse&lt;&gt;(</span><br><span class=\"line\">              requestFactory,</span><br><span class=\"line\">              callFactory,</span><br><span class=\"line\">              responseConverter,</span><br><span class=\"line\">              (CallAdapter&lt;ResponseT, Call&lt;ResponseT&gt;&gt;) callAdapter);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">//noinspection unchecked Kotlin compiler guarantees ReturnT to be Object.</span></span><br><span class=\"line\">\t\t\t<span class=\"comment\">//...</span></span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面代码关键变量<code>isKotlinSuspendFunction</code> ，用于判断是否为协程方法（suspend修饰），判断逻辑很简单，只需要判定方法最后一个参数是否为<code> Continuation.class</code> 即可。这里的分叉逻辑都继承自<code>HttpServiceMethod&lt;T&gt;</code>实现 <code>ReturnT adapt(Call&lt;ResponseT&gt; call, Object[] args)</code>这个抽象方法，这也是 retrofit 使用 <strong>适配器模式</strong>的地方，把不同的调用方式进行统一。对于协程方式的调用有实现：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">protected</span> Object adapt(Call&lt;ResponseT&gt; call, Object[] args) &#123;</span><br><span class=\"line\">      call = callAdapter.adapt(call);</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">//noinspection unchecked Checked by reflection inside RequestFactory.</span></span><br><span class=\"line\">      Continuation&lt;Response&lt;ResponseT&gt;&gt; continuation =</span><br><span class=\"line\">          (Continuation&lt;Response&lt;ResponseT&gt;&gt;) args[args.length - <span class=\"number\">1</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">// See SuspendForBody for explanation about this try/catch.</span></span><br><span class=\"line\">      <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> KotlinExtensions.awaitResponse(call, continuation);</span><br><span class=\"line\">      &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>.suspendAndThrow(e, continuation);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight kotlin\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">suspend</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"type\">&lt;T&gt;</span> Call<span class=\"type\">&lt;T&gt;</span>.<span class=\"title\">awaitResponse</span><span class=\"params\">()</span></span>: Response&lt;T&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> suspendCancellableCoroutine &#123; continuation -&gt;</span><br><span class=\"line\">    continuation.invokeOnCancellation &#123;</span><br><span class=\"line\">      cancel()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    enqueue(<span class=\"keyword\">object</span> : Callback&lt;T&gt; &#123;</span><br><span class=\"line\">      <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onResponse</span><span class=\"params\">(call: <span class=\"type\">Call</span>&lt;<span class=\"type\">T</span>&gt;, response: <span class=\"type\">Response</span>&lt;<span class=\"type\">T</span>&gt;)</span></span> &#123;</span><br><span class=\"line\">        continuation.resume(response)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onFailure</span><span class=\"params\">(call: <span class=\"type\">Call</span>&lt;<span class=\"type\">T</span>&gt;, t: <span class=\"type\">Throwable</span>)</span></span> &#123;</span><br><span class=\"line\">        continuation.resumeWithException(t)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里就一切都明朗了，实现了 <code>Call</code>的扩展方法，这里的 <code>Call</code>并不是 <code>okhttp3.Call</code>，它只是 retrofit  <code>okhttp3.Call</code>为方便框架整体逻辑的处理而定义的，比如 retrofit 的 <code>Call</code> 是泛型化的，可以直接返回解析后的对象，<code>enqueue</code>同理。</p>\n<p><code>suspendCancellableCoroutine</code>方法是实现协程方法的关键，它可以将基于回调的异步操作封装成一个挂起函数，怎么理解呢？对 扩展方法<code>awaitResponse</code>反编译可以看到方法定义是这样的：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Object <span class=\"title function_\">await</span><span class=\"params\">(<span class=\"meta\">@NotNull</span> Call $<span class=\"built_in\">this</span>$await, <span class=\"meta\">@NotNull</span> Continuation $completion)</span> </span><br></pre></td></tr></table></figure>\n\n<p>其实这里跟定义一个 <code>listener</code>去监听方法的回调有点像，这个方法改写成 <code>listener</code>的实现话大概就是这样：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"type\">&lt;T&gt;</span> Call<span class=\"type\">&lt;T&gt;</span>.<span class=\"title\">awaitResponse</span><span class=\"params\">(listener:<span class=\"type\">Listener</span>&lt;<span class=\"type\">T</span>&gt;)</span></span>: Response&lt;T&gt; &#123;</span><br><span class=\"line\">        enqueue(<span class=\"keyword\">object</span> : Callback&lt;T&gt; &#123;</span><br><span class=\"line\">            <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onResponse</span><span class=\"params\">(call: <span class=\"type\">Call</span>&lt;<span class=\"type\">T</span>&gt;, response: <span class=\"type\">Response</span>&lt;<span class=\"type\">T</span>&gt;)</span></span> &#123;</span><br><span class=\"line\">                Listener.resume(response)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onFailure</span><span class=\"params\">(call: <span class=\"type\">Call</span>&lt;<span class=\"type\">T</span>&gt;, t: <span class=\"type\">Throwable</span>)</span></span> &#123;</span><br><span class=\"line\">                Listener.resumeWithException(t)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可看到改造实现需要传递一个 <code>listener</code>，哪这个 <code>listener</code>是什么？前面其有如何判断一个方法是否为协程的方法的逻辑：判定方法最后一个参数是否为<code> Continuation.class</code> 即可。这里的  <code>listener</code> 其实可以等价于 一个 <code>Continuation</code>实例，kotlin 的协程库帮我们实现了对应的封装，对于使用我们不会直观地感受<code>Continuation</code>的存在，实际它贯穿整个协程。关于协程这里不再赘述，可以查看 <a href=\"https://juejin.cn/post/7142743424670629895?searchId=202503230943390124BC33C1668EC4B62B\">《带着问题分析Kotlin协程原理》</a>了解。</p>\n<h3 id=\"返回数据格式的解析\"><a href=\"#返回数据格式的解析\" class=\"headerlink\" title=\"返回数据格式的解析\"></a><strong>返回数据格式的解析</strong></h3><p>对于<strong>Converter</strong>,在协程和普通方法调用分叉逻辑的前面点：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"code\"><pre><span class=\"line\">Converter&lt;ResponseBody, ResponseT&gt; responseConverter = createResponseConverter(retrofit, method, responseType);</span><br></pre></td></tr></table></figure>\n\n<p><code>createResponseConverter</code>之后一路走到</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> &lt;T&gt; Converter&lt;ResponseBody, T&gt; nextResponseBodyConverter(</span><br><span class=\"line\">    <span class=\"meta\">@Nullable</span> Converter.Factory skipPast, Type type, Annotation[] annotations) &#123;</span><br><span class=\"line\">  Objects.requireNonNull(type, <span class=\"string\">&quot;type == null&quot;</span>);</span><br><span class=\"line\">  Objects.requireNonNull(annotations, <span class=\"string\">&quot;annotations == null&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  int start = converterFactories.indexOf(skipPast) + <span class=\"number\">1</span>;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (int i = start, count = converterFactories.size(); i &lt; count; i++) &#123;</span><br><span class=\"line\">    Converter&lt;ResponseBody, ?&gt; converter =</span><br><span class=\"line\">        converterFactories.<span class=\"keyword\">get</span>(i).responseBodyConverter(type, annotations, <span class=\"keyword\">this</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (converter != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">      <span class=\"comment\">//noinspection unchecked</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> (Converter&lt;ResponseBody, T&gt;) converter;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>converterFactories</code> 的值就是在 retrofit 初始化的时候进行使用  <code>public Builder addConverterFactory(Converter.Factory factory)</code>添加的值。可以看到是按添加到<code>List&lt;Converter.Factory&gt; converterFactories</code>里面的顺序进行选择的，默认<code>GsonConverterFactory</code>实现了利用 <code>Gson</code>进行数据转化 ，如果我们自己实现<code>Converter.Factory</code>的接口的话，那么可以根据一定的规则判断是否要返回我们自定义的 <code>Converter</code>，如果不需要使用就返回 null，会自动匹配下一个能使用的 <code>Converter</code>。注意这里并不会因为前一个  <code>Converter</code> 解析失败而自动尝试使用下一个<code>Converter</code>（当然，你可以在自定义的<code>Converter</code>里面做类似这样的尝试策略）。</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><ul>\n<li><p>这篇文章深入剖析了 <strong>Retrofit</strong> 框架的核心设计模式、动态代理机制、协程支持以及数据解析逻辑，通过源码分析和手写实现，帮助读者更好地理解 Retrofit 的工作原理，并强调了理论与实践结合的重要性。</p>\n</li>\n<li><p>为加深对 retrofit 的理解，可以尝试手写核心实现，自己尝试的的代码在 <a href=\"https://github.com/VomPom/JProject/tree/master/app/src/main/java/wang/julis/jproject/example/source/retrofit2/learn/vmfit\">vmfit</a> </p>\n</li>\n<li><p>附一张 retrofit 的全流程图，来源：<a href=\"https://cloud.tencent.com/developer/article/1683334\">https://cloud.tencent.com/developer/article/1683334</a></p>\n</li>\n</ul>\n<img src=\"https://cdn.julis.wang/blog/img/ru5ssbhumq.jpeg\">","cover":null,"images":["https://cdn.julis.wang/blog/img/ru5ssbhumq.jpeg"],"content":"<p>研究 <a href=\"https://github.com/square/retrofit\">retrofit</a> 目标：理解动态代理、注解、反射、学习它所用到的设计模式，达到自己能手写它的核心实现。</p>\n<p>最近终于有点精力能够去研究研究源码了， 真的是写的一个非常好的的开源库，以前刚接触安卓的时候扒拉过相关的源码，但是随着工作了几年之后，经验的积累，让我对源码里面的东西能够体会更深刻，自己也尝试去手写里面的核心实现，看完源码对整体的架构理解了之后，以为自己能很顺利的写下来，实则不然。<br>知识还是需要知行合一，这篇文章主要记录 <a href=\"https://github.com/square/retrofit\">retrofit</a>  的一些知识点。</p>\n<h3 id=\"retrofit-的设计模式\"><a href=\"#retrofit-的设计模式\" class=\"headerlink\" title=\"retrofit 的设计模式\"></a>retrofit 的设计模式</h3><p>retrofit 里面中使用了多种设计模式，以实现其灵活、可扩展和高性能的特性：</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">设计模式</th>\n<th align=\"left\">应用场景</th>\n<th align=\"left\">作用</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><strong>建造者模式</strong></td>\n<td align=\"left\"><code>Retrofit.Builder</code></td>\n<td align=\"left\">灵活配置 Retrofit 实例</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>工厂模式</strong></td>\n<td align=\"left\"><code>Converter.Factory</code>、<code>CallAdapter.Factory</code></td>\n<td align=\"left\">创建 Converter 和 CallAdapter 实例</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>动态代理模式</strong></td>\n<td align=\"left\">接口方法转换为 HTTP 请求</td>\n<td align=\"left\">运行时生成接口代理对象</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>适配器模式</strong></td>\n<td align=\"left\"><code>CallAdapter</code></td>\n<td align=\"left\">将 <code>Call</code> 适配为其他类型</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>装饰器模式</strong></td>\n<td align=\"left\"><code>OkHttp</code> 拦截器</td>\n<td align=\"left\">增强 HTTP 请求和响应的功能</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>观察者模式</strong></td>\n<td align=\"left\">与 <code>RxJava</code> 或 <code>LiveData</code> 结合</td>\n<td align=\"left\">实现异步数据流的订阅和通知</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>策略模式</strong></td>\n<td align=\"left\"><code>Converter</code> 和 <code>CallAdapter</code> 选择</td>\n<td align=\"left\">动态选择数据转换或调用适配策略</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>单例模式</strong></td>\n<td align=\"left\"><code>Retrofit</code> 实例共享</td>\n<td align=\"left\">确保全局只有一个 Retrofit 实例</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>模板方法模式</strong></td>\n<td align=\"left\"><code>Call</code> 的实现</td>\n<td align=\"left\">定义 HTTP 请求的执行流程</td>\n</tr>\n</tbody></table>\n<p><strong>retrofit 的动态代理模式</strong></p>\n<p>retrofit 用了诸多的设计模式，其中最经典的莫过于动态代理模式了，在了解 retrofit 之前，我一直以为这样的网络请求形式是最直观的，参考以前写的<a href=\"https://julis.wang/2019/05/13/%E5%9F%BA%E4%BA%8EVolley%E6%A1%86%E6%9E%B6%E7%9A%84%E8%BF%94%E5%9B%9E%E6%95%B0%E6%8D%AE%E7%9A%84%E8%8C%83%E5%9E%8B%E5%A4%84%E7%90%86/\">基于Volley框架的返回数据的范型处理</a></p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"code\"><pre><span class=\"line\">Request.<span class=\"keyword\">get</span>(</span><br><span class=\"line\">    url = url,</span><br><span class=\"line\">    params = param,</span><br><span class=\"line\">    listener = <span class=\"keyword\">object</span> : OnRequestListener&lt;Data&gt; &#123;</span><br><span class=\"line\">        <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onSuccess</span><span class=\"params\">(commonData: <span class=\"type\">CommonData</span>?, <span class=\"keyword\">data</span>: <span class=\"type\">Data</span>?)</span></span> &#123;&#125;</span><br><span class=\"line\">        <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onFailure</span><span class=\"params\">(errorCode: <span class=\"type\">Int</span>, errorMessage: <span class=\"type\">String</span>?)</span></span> &#123;&#125;</span><br><span class=\"line\">    &#125;)</span><br></pre></td></tr></table></figure>\n\n<p>以为这样很直观，逻辑也很清晰，实则 代码冗余，回调嵌套，如果有多个连续的请求，代码会变得难以维护，而 retrofit 搭配上协程能这样实现：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> <span class=\"keyword\">data</span> = apiService.getXXX(params)</span><br></pre></td></tr></table></figure>\n\n<p>简单到不能再简单，<code>动态代理</code>功不可没，上面的 apiService 是一个接口，由：<code> retrofit.create(ApiInterface::class.java)</code> 生成其实例，动态代理其核心实现：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> &lt;T&gt; T <span class=\"title function_\">create</span><span class=\"params\">(<span class=\"keyword\">final</span> Class&lt;T&gt; service)</span> &#123;</span><br><span class=\"line\">    validateServiceInterface(service);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (T)</span><br><span class=\"line\">        Proxy.newProxyInstance(</span><br><span class=\"line\">            service.getClassLoader(),</span><br><span class=\"line\">            <span class=\"keyword\">new</span> <span class=\"title class_\">Class</span>&lt;?&gt;[] &#123;service&#125;,</span><br><span class=\"line\">            <span class=\"keyword\">new</span> <span class=\"title class_\">InvocationHandler</span>() &#123;</span><br><span class=\"line\">              <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"type\">Platform</span> <span class=\"variable\">platform</span> <span class=\"operator\">=</span> Platform.get();</span><br><span class=\"line\">              <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Object[] emptyArgs = <span class=\"keyword\">new</span> <span class=\"title class_\">Object</span>[<span class=\"number\">0</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">              <span class=\"meta\">@Override</span></span><br><span class=\"line\">              <span class=\"keyword\">public</span> <span class=\"meta\">@Nullable</span> Object <span class=\"title function_\">invoke</span><span class=\"params\">(Object proxy, Method method, <span class=\"meta\">@Nullable</span> Object[] args)</span> <span class=\"keyword\">throws</span> Throwable &#123;</span><br><span class=\"line\">                <span class=\"comment\">// ....</span></span><br><span class=\"line\">                <span class=\"keyword\">return</span> platform.isDefaultMethod(method)</span><br><span class=\"line\">                    ? platform.invokeDefaultMethod(method, service, proxy, args)</span><br><span class=\"line\">                    : loadServiceMethod(method).invoke(args);</span><br><span class=\"line\">              &#125;</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n\n<p>由<code>loadServiceMethod(method).invoke(args)</code> 负责将接口方法（通过 Java 反射获取的 <code>Method</code> 对象）解析并转换为一个可执行的 HTTP 请求。</p>\n<p><code>Proxy.newProxyInstance</code> 方法，参数：</p>\n<ul>\n<li><p>ClassLoader loader 用于加载代理类的类加载器。</p>\n</li>\n<li><p>Class&lt;?&gt;[] interfaces 代理类需要实现的接口数组，代理对象将实现这些接口，并拦截对这些接口方法的调用。只能代理实现了接口的类，不能代理没有接口的类。</p>\n</li>\n<li><p>InvocationHandler h<br>调用处理器，负责处理代理对象上的方法调用。每次调用代理对象的方法时，都会调用 <code>InvocationHandler</code> 的 <code>invoke</code> 方法。对于 Retrofit 的接口我们并没有去“实现”它的方法，所有的逻辑都由&#96;&#96; retrofit.create()<code>方法里面返回的 </code>InvocationHandler<code>实现的 </code>invoke&#96;方法实现的。</p>\n</li>\n</ul>\n<h3 id=\"核心实现逻辑\"><a href=\"#核心实现逻辑\" class=\"headerlink\" title=\"核心实现逻辑\"></a>核心实现逻辑</h3><h4 id=\"协程的支持\"><a href=\"#协程的支持\" class=\"headerlink\" title=\"协程的支持\"></a><strong>协程的支持</strong></h4><p>Retrofit 支持多种异步编程模型，包括回调、RxJava 和协程等，这里主要记录一下对协程的支持。普通方法和异步逻辑的分叉在：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (!isKotlinSuspendFunction) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> new CallAdapted&lt;&gt;(requestFactory, callFactory, responseConverter, callAdapter);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (continuationWantsResponse) &#123;</span><br><span class=\"line\">      <span class=\"comment\">//noinspection unchecked Kotlin compiler guarantees ReturnT to be Object.</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> (HttpServiceMethod&lt;ResponseT, ReturnT&gt;)</span><br><span class=\"line\">          new SuspendForResponse&lt;&gt;(</span><br><span class=\"line\">              requestFactory,</span><br><span class=\"line\">              callFactory,</span><br><span class=\"line\">              responseConverter,</span><br><span class=\"line\">              (CallAdapter&lt;ResponseT, Call&lt;ResponseT&gt;&gt;) callAdapter);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">//noinspection unchecked Kotlin compiler guarantees ReturnT to be Object.</span></span><br><span class=\"line\">\t\t\t<span class=\"comment\">//...</span></span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面代码关键变量<code>isKotlinSuspendFunction</code> ，用于判断是否为协程方法（suspend修饰），判断逻辑很简单，只需要判定方法最后一个参数是否为<code> Continuation.class</code> 即可。这里的分叉逻辑都继承自<code>HttpServiceMethod&lt;T&gt;</code>实现 <code>ReturnT adapt(Call&lt;ResponseT&gt; call, Object[] args)</code>这个抽象方法，这也是 retrofit 使用 <strong>适配器模式</strong>的地方，把不同的调用方式进行统一。对于协程方式的调用有实现：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">protected</span> Object adapt(Call&lt;ResponseT&gt; call, Object[] args) &#123;</span><br><span class=\"line\">      call = callAdapter.adapt(call);</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">//noinspection unchecked Checked by reflection inside RequestFactory.</span></span><br><span class=\"line\">      Continuation&lt;Response&lt;ResponseT&gt;&gt; continuation =</span><br><span class=\"line\">          (Continuation&lt;Response&lt;ResponseT&gt;&gt;) args[args.length - <span class=\"number\">1</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">// See SuspendForBody for explanation about this try/catch.</span></span><br><span class=\"line\">      <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> KotlinExtensions.awaitResponse(call, continuation);</span><br><span class=\"line\">      &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>.suspendAndThrow(e, continuation);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight kotlin\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">suspend</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"type\">&lt;T&gt;</span> Call<span class=\"type\">&lt;T&gt;</span>.<span class=\"title\">awaitResponse</span><span class=\"params\">()</span></span>: Response&lt;T&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> suspendCancellableCoroutine &#123; continuation -&gt;</span><br><span class=\"line\">    continuation.invokeOnCancellation &#123;</span><br><span class=\"line\">      cancel()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    enqueue(<span class=\"keyword\">object</span> : Callback&lt;T&gt; &#123;</span><br><span class=\"line\">      <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onResponse</span><span class=\"params\">(call: <span class=\"type\">Call</span>&lt;<span class=\"type\">T</span>&gt;, response: <span class=\"type\">Response</span>&lt;<span class=\"type\">T</span>&gt;)</span></span> &#123;</span><br><span class=\"line\">        continuation.resume(response)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onFailure</span><span class=\"params\">(call: <span class=\"type\">Call</span>&lt;<span class=\"type\">T</span>&gt;, t: <span class=\"type\">Throwable</span>)</span></span> &#123;</span><br><span class=\"line\">        continuation.resumeWithException(t)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里就一切都明朗了，实现了 <code>Call</code>的扩展方法，这里的 <code>Call</code>并不是 <code>okhttp3.Call</code>，它只是 retrofit  <code>okhttp3.Call</code>为方便框架整体逻辑的处理而定义的，比如 retrofit 的 <code>Call</code> 是泛型化的，可以直接返回解析后的对象，<code>enqueue</code>同理。</p>\n<p><code>suspendCancellableCoroutine</code>方法是实现协程方法的关键，它可以将基于回调的异步操作封装成一个挂起函数，怎么理解呢？对 扩展方法<code>awaitResponse</code>反编译可以看到方法定义是这样的：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Object <span class=\"title function_\">await</span><span class=\"params\">(<span class=\"meta\">@NotNull</span> Call $<span class=\"built_in\">this</span>$await, <span class=\"meta\">@NotNull</span> Continuation $completion)</span> </span><br></pre></td></tr></table></figure>\n\n<p>其实这里跟定义一个 <code>listener</code>去监听方法的回调有点像，这个方法改写成 <code>listener</code>的实现话大概就是这样：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"type\">&lt;T&gt;</span> Call<span class=\"type\">&lt;T&gt;</span>.<span class=\"title\">awaitResponse</span><span class=\"params\">(listener:<span class=\"type\">Listener</span>&lt;<span class=\"type\">T</span>&gt;)</span></span>: Response&lt;T&gt; &#123;</span><br><span class=\"line\">        enqueue(<span class=\"keyword\">object</span> : Callback&lt;T&gt; &#123;</span><br><span class=\"line\">            <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onResponse</span><span class=\"params\">(call: <span class=\"type\">Call</span>&lt;<span class=\"type\">T</span>&gt;, response: <span class=\"type\">Response</span>&lt;<span class=\"type\">T</span>&gt;)</span></span> &#123;</span><br><span class=\"line\">                Listener.resume(response)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onFailure</span><span class=\"params\">(call: <span class=\"type\">Call</span>&lt;<span class=\"type\">T</span>&gt;, t: <span class=\"type\">Throwable</span>)</span></span> &#123;</span><br><span class=\"line\">                Listener.resumeWithException(t)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可看到改造实现需要传递一个 <code>listener</code>，哪这个 <code>listener</code>是什么？前面其有如何判断一个方法是否为协程的方法的逻辑：判定方法最后一个参数是否为<code> Continuation.class</code> 即可。这里的  <code>listener</code> 其实可以等价于 一个 <code>Continuation</code>实例，kotlin 的协程库帮我们实现了对应的封装，对于使用我们不会直观地感受<code>Continuation</code>的存在，实际它贯穿整个协程。关于协程这里不再赘述，可以查看 <a href=\"https://juejin.cn/post/7142743424670629895?searchId=202503230943390124BC33C1668EC4B62B\">《带着问题分析Kotlin协程原理》</a>了解。</p>\n<h3 id=\"返回数据格式的解析\"><a href=\"#返回数据格式的解析\" class=\"headerlink\" title=\"返回数据格式的解析\"></a><strong>返回数据格式的解析</strong></h3><p>对于<strong>Converter</strong>,在协程和普通方法调用分叉逻辑的前面点：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"code\"><pre><span class=\"line\">Converter&lt;ResponseBody, ResponseT&gt; responseConverter = createResponseConverter(retrofit, method, responseType);</span><br></pre></td></tr></table></figure>\n\n<p><code>createResponseConverter</code>之后一路走到</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> &lt;T&gt; Converter&lt;ResponseBody, T&gt; nextResponseBodyConverter(</span><br><span class=\"line\">    <span class=\"meta\">@Nullable</span> Converter.Factory skipPast, Type type, Annotation[] annotations) &#123;</span><br><span class=\"line\">  Objects.requireNonNull(type, <span class=\"string\">&quot;type == null&quot;</span>);</span><br><span class=\"line\">  Objects.requireNonNull(annotations, <span class=\"string\">&quot;annotations == null&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  int start = converterFactories.indexOf(skipPast) + <span class=\"number\">1</span>;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (int i = start, count = converterFactories.size(); i &lt; count; i++) &#123;</span><br><span class=\"line\">    Converter&lt;ResponseBody, ?&gt; converter =</span><br><span class=\"line\">        converterFactories.<span class=\"keyword\">get</span>(i).responseBodyConverter(type, annotations, <span class=\"keyword\">this</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (converter != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">      <span class=\"comment\">//noinspection unchecked</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> (Converter&lt;ResponseBody, T&gt;) converter;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>converterFactories</code> 的值就是在 retrofit 初始化的时候进行使用  <code>public Builder addConverterFactory(Converter.Factory factory)</code>添加的值。可以看到是按添加到<code>List&lt;Converter.Factory&gt; converterFactories</code>里面的顺序进行选择的，默认<code>GsonConverterFactory</code>实现了利用 <code>Gson</code>进行数据转化 ，如果我们自己实现<code>Converter.Factory</code>的接口的话，那么可以根据一定的规则判断是否要返回我们自定义的 <code>Converter</code>，如果不需要使用就返回 null，会自动匹配下一个能使用的 <code>Converter</code>。注意这里并不会因为前一个  <code>Converter</code> 解析失败而自动尝试使用下一个<code>Converter</code>（当然，你可以在自定义的<code>Converter</code>里面做类似这样的尝试策略）。</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><ul>\n<li><p>这篇文章深入剖析了 <strong>Retrofit</strong> 框架的核心设计模式、动态代理机制、协程支持以及数据解析逻辑，通过源码分析和手写实现，帮助读者更好地理解 Retrofit 的工作原理，并强调了理论与实践结合的重要性。</p>\n</li>\n<li><p>为加深对 retrofit 的理解，可以尝试手写核心实现，自己尝试的的代码在 <a href=\"https://github.com/VomPom/JProject/tree/master/app/src/main/java/wang/julis/jproject/example/source/retrofit2/learn/vmfit\">vmfit</a> </p>\n</li>\n<li><p>附一张 retrofit 的全流程图，来源：<a href=\"https://cloud.tencent.com/developer/article/1683334\">https://cloud.tencent.com/developer/article/1683334</a></p>\n</li>\n</ul>\n<img src=\"https://cdn.julis.wang/blog/img/ru5ssbhumq.jpeg\">","categories":[{"name":"技术文章","slug":"technology","api":"api/categories/technology.json"}],"tags":[{"name":"Android","slug":"Android","api":"api/tags/Android.json"}],"api":"api/posts/2025/03/17/Learn-from-RetroFit.json"},{"title":"Android屏幕刷新机制","slug":"Android屏幕刷新机制","date":"2025-02-24T02:49:00.000Z","updated":"2025-05-20T11:46:57.000Z","comments":true,"url":"2025/02/24/Android屏幕刷新机制/","excerpt":"<p>最近在研究 Android 屏幕显示与渲染相关的内容，平时经常看到这些类 <code>ViewRootImpl</code>、<code>Choreographer</code>、<code>Surface</code> 、 <code>SurfaceFlinger</code>等，知道它们都用于屏幕渲染相关，但对它们细节了解较少，相关的文章也比较多，不需要自己完全重新再编写一份，于是对相关内容进行一个总结,<br>主要来源：<a href=\"https://juejin.cn/post/6863756420380196877\">《Android屏幕刷新机制—VSyncChoreographer 全面理解》</a>，这篇博客是我认为是目前看到过最好的一篇，文章由浅入深比较好理解。不过文章里面图片链接资源已经失效，为以后复习相关知识点，在此将其整理删除冗余内容，并对图片资源进行更新。</p>\n<h2 id=\"一、背景和疑问\"><a href=\"#一、背景和疑问\" class=\"headerlink\" title=\"一、背景和疑问\"></a><strong>一、背景和疑问</strong></h2><p>在Android中，当我们谈到 <strong>布局优化</strong>、<strong>卡顿优化</strong> 时，通常都知道 需要减少布局层级、减少主线程耗时操作，这样可以减少<strong>丢帧</strong>。如果丢帧比较严重，那么界面可能会有明显的卡顿感。我们知道 通常手机刷新是每秒60次，即每隔16.6ms刷新一次。 问题来了：</p>\n<ol>\n<li><strong>丢帧</strong>(掉帧) ，是说 这一帧延迟显示 还是丢弃不再显示 ？</li>\n<li>布局层级较多&#x2F;主线程耗时 是如何造成 丢帧的呢？</li>\n<li>16.6ms刷新一次 是啥意思？是每16.6ms都走一次 measure&#x2F;layout&#x2F;draw ？</li>\n<li>measure&#x2F;layout&#x2F;draw 走完，界面就立刻刷新了吗?</li>\n<li>如果界面没动静止了，还会刷新吗？</li>\n<li>可能你知道<strong>VSYNC</strong>，这个具体指啥？在屏幕刷新中如何工作的？</li>\n<li>可能你还听过屏幕刷新使用 <strong>双缓存</strong>、<strong>三缓存</strong>，这又是啥意思呢？</li>\n<li>可能你还听过神秘的<strong>Choreographer</strong>，这又是干啥的？</li>\n</ol>\n<h2 id=\"二、显示系统基础知识\"><a href=\"#二、显示系统基础知识\" class=\"headerlink\" title=\"二、显示系统基础知识\"></a><strong>二、显示系统基础知识</strong></h2><p>在一个典型的显示系统中，一般包括CPU、GPU、Display三个部分， CPU负责计算帧数据，把计算好的数据交给GPU，GPU会对图形数据进行渲染，渲染好后放到buffer(图像缓冲区)里存起来，然后Display（屏幕或显示器）负责把buffer里的数据呈现到屏幕上。如下图：</p>\n<img src=\"https://cdn.julis.wang/blog/img/0nq54q5jtq.jpeg\">\n\n<p>单缓存，从缓存映射到屏幕。</p>\n<h3 id=\"2-1-基础概念\"><a href=\"#2-1-基础概念\" class=\"headerlink\" title=\"2.1 基础概念\"></a><strong>2.1 基础概念</strong></h3><ul>\n<li><strong>屏幕刷新频率</strong> 一秒内屏幕刷新的次数（一秒内显示了多少帧的图像），单位 Hz（赫兹），如常见的 60 Hz。<strong>刷新频率取决于硬件的固定参数</strong>（不会变的）。</li>\n<li><strong>逐行扫描</strong> 显示器并不是一次性将画面显示到屏幕上，而是从左到右边，从上到下逐行扫描，顺序显示整屏的一个个像素点，不过这一过程快到人眼无法察觉到变化。以 60 Hz 刷新率的屏幕为例，这一过程即 1000 &#x2F; 60 ≈ 16ms。</li>\n<li><strong>帧率</strong> （Frame Rate） 表示 <strong>GPU 在一秒内绘制操作的帧数</strong>，单位 fps。例如在电影界采用 24 帧的速度足够使画面运行的非常流畅。而 Android 系统则采用更加流程的 60 fps，即每秒钟GPU最多绘制 60 帧画面。帧率是动态变化的，例如当画面静止时，GPU 是没有绘制操作的，屏幕刷新的还是buffer中的数据，即GPU最后操作的帧数据。</li>\n<li><strong>画面撕裂</strong>（tearing） 一个屏幕内的数据来自2个不同的帧，画面会出现撕裂感，如下图</li>\n</ul>\n<img src=\"https://cdn.julis.wang/blog/img/xxm0lvzypa.jpeg\">\n\n<p>明显看出画面错位的位置，这就是画面撕裂。</p>\n<h3 id=\"2-2-双缓存\"><a href=\"#2-2-双缓存\" class=\"headerlink\" title=\"2.2 双缓存\"></a><strong>2.2 双缓存</strong></h3><h5 id=\"2-2-1-画面撕裂-原因\"><a href=\"#2-2-1-画面撕裂-原因\" class=\"headerlink\" title=\"2.2.1  画面撕裂 原因\"></a><strong>2.2.1  画面撕裂 原因</strong></h5><p>屏幕刷新频是固定的，比如每16.6ms从buffer取数据显示完一帧，理想情况下帧率和刷新频率保持一致，即每绘制完成一帧，显示器显示一帧。但是CPU&#x2F;GPU写数据是不可控的，所以会出现buffer里有些数据根本没显示出来就被重写了，即buffer里的数据可能是来自不同的帧的， 当屏幕刷新时，此时它并不知道buffer的状态，因此从buffer抓取的帧并不是完整的一帧画面，即出现画面撕裂。</p>\n<p>简单说就是Display在显示的过程中，buffer内数据被CPU&#x2F;GPU修改，导致画面撕裂。</p>\n<h5 id=\"2-2-2-双缓存\"><a href=\"#2-2-2-双缓存\" class=\"headerlink\" title=\"2.2.2  双缓存\"></a><strong>2.2.2  双缓存</strong></h5><p>那咋解决画面撕裂呢？答案是使用 双缓存。</p>\n<p>由于图像绘制和屏幕读取 使用的是同个buffer，所以屏幕刷新时可能读取到的是不完整的一帧画面。</p>\n<p><strong>双缓存</strong>，让绘制和显示器拥有各自的buffer：GPU 始终将完成的一帧图像数据写入到 <strong>Back Buffer</strong>，而显示器使用 <strong>Frame Buffer</strong>，当屏幕刷新时，Frame Buffer 并不会发生变化，当Back buffer准备就绪后，它们才进行交换。如下图：</p>\n<img src=\"https://cdn.julis.wang/blog/img/q2vukxpyvq.jpeg\">\n\n<p>双缓存，CPU&#x2F;GPU写数据到Back Buffer，显示器从Frame Buffer取数据</p>\n<h5 id=\"2-2-3-VSync\"><a href=\"#2-2-3-VSync\" class=\"headerlink\" title=\"2.2.3  VSync\"></a><strong>2.2.3  VSync</strong></h5><p>问题又来了：什么时候进行两个buffer的交换呢？</p>\n<p>假如是 Back buffer准备完成一帧数据以后就进行，那么如果此时屏幕还没有完整显示上一帧内容的话，肯定是会出问题的。看来只能是等到屏幕处理完一帧数据后，才可以执行这一操作了。</p>\n<p>当扫描完一个屏幕后，设备需要重新回到第一行以进入下一次的循环，此时有一段时间空隙，称为VerticalBlanking Interval(VBI)。那，这个时间点就是我们进行缓冲区交换的最佳时间。因为此时屏幕没有在刷新，也就避免了交换过程中出现 screen tearing的状况。</p>\n<p><strong>VSync</strong>(垂直同步)是VerticalSynchronization的简写，它利用VBI时期出现的vertical sync pulse（垂直同步脉冲）来保证双缓冲在最佳时间点才进行交换。另外，交换是指各自的内存地址，可以认为该操作是瞬间完成。</p>\n<p>所以说V-sync这个概念并不是Google首创的，它在早年的PC机领域就已经出现了。</p>\n<h2 id=\"三、Android屏幕刷新机制\"><a href=\"#三、Android屏幕刷新机制\" class=\"headerlink\" title=\"三、Android屏幕刷新机制\"></a><strong>三、Android屏幕刷新机制</strong></h2><h3 id=\"3-1-Android4-1之前的问题\"><a href=\"#3-1-Android4-1之前的问题\" class=\"headerlink\" title=\"3.1 Android4.1之前的问题\"></a><strong>3.1 Android4.1之前的问题</strong></h3><p>具体到Android中，在Android4.1之前，屏幕刷新也遵循 上面介绍的 双缓存+VSync 机制。如下图：</p>\n<img src=\"https://cdn.julis.wang/blog/img/1ax0mz0nu1.jpeg\">\n\n<p>双缓存会在VSync脉冲时交换，但CPU&#x2F;GPU绘制是随机的</p>\n<p>以时间的顺序来看下将会发生的过程：</p>\n<ol>\n<li>Display显示第0帧数据，此时CPU和<a href=\"https://cloud.tencent.com/solution/render?from_column=20065&from=20065\">GPU渲染</a>第1帧画面，且在Display显示下一帧前完成</li>\n<li>因为渲染及时，Display在第0帧显示完成后，也就是第1个VSync后，缓存进行交换，然后正常显示第1帧</li>\n<li>接着第2帧开始处理，是直到第2个VSync快来前才开始处理的。</li>\n<li>第2个VSync来时，由于第2帧数据还没有准备就绪，缓存没有交换，显示的还是第1帧。这种情况被Android开发组命名为“Jank”，即发生了<strong>丢帧</strong>。</li>\n<li>当第2帧数据准备完成后，它并不会马上被显示，而是要等待下一个VSync 进行缓存交换再显示。</li>\n</ol>\n<p>所以总的来说，就是屏幕平白无故地多显示了一次第1帧。</p>\n<p>原因是 第2帧的CPU&#x2F;GPU计算 没能在VSync信号到来前完成 。</p>\n<p>我们知道，<strong>双缓存的交换 是在Vsyn到来时进行，交换后屏幕会取Frame buffer内的新数据，而实际 此时的Back buffer 就可以供GPU准备下一帧数据了。如果 Vsyn到来时  CPU&#x2F;GPU就开始操作的话，是有完整的16.6ms的，这样应该会基本避免jank的出现了</strong>（除非CPU&#x2F;GPU计算超过了16.6ms）。  那如何让 CPU&#x2F;GPU计算在 Vsyn到来时进行呢？</p>\n<h3 id=\"3-2-drawing-with-VSync\"><a href=\"#3-2-drawing-with-VSync\" class=\"headerlink\" title=\"3.2 drawing with VSync\"></a><strong>3.2 drawing with VSync</strong></h3><p>为了优化显示性能，Google在Android 4.1系统中对Android Display系统进行了重构，实现了Project Butter（黄油工程）：系统在收到VSync pulse后，将马上开始下一帧的渲染。即<strong>一旦收到VSync通知（16ms触发一次），CPU和GPU 才立刻开始计算然后把数据写入buffer</strong>。如下图：</p>\n<img src=\"https://cdn.julis.wang/blog/img/uuqflxwo53.jpeg\">\n\n<p>VSync脉冲到来：双缓存交换，且开始CPU&#x2F;GPU绘制 CPU&#x2F;GPU根据VSYNC信号同步处理数据，可以让CPU&#x2F;GPU有完整的16ms时间来处理数据，减少了jank。</p>\n<p>一句话总结，<strong>VSync同步使得CPU&#x2F;GPU充分利用了16.6ms时间，减少jank。</strong></p>\n<p>问题又来了，如果界面比较复杂，CPU&#x2F;GPU的处理时间较长 超过了16.6ms呢？如下图：</p>\n<img src=\"https://cdn.julis.wang/blog/img/po2jd1h7u8.jpeg\">\n\n<p>虽然CPU&#x2F;GPU开始在VSync，但超过16.6ms</p>\n<ol>\n<li>在第二个时间段内，但却因 GPU 还在处理 B 帧，缓存没能交换，导致 A 帧被重复显示。</li>\n<li>而B完成后，又因为缺乏VSync pulse信号，它只能等待下一个signal的来临。于是在这一过程中，有一大段时间是被浪费的。</li>\n<li>当下一个VSync出现时，CPU&#x2F;GPU马上执行操作（A帧），且缓存交换，相应的显示屏对应的就是B。这时看起来就是正常的。只不过由于执行时间仍然超过16ms，导致下一次应该执行的缓冲区交换又被推迟了——如此循环反复，便出现了越来越多的“Jank”。</li>\n</ol>\n<p><strong>为什么 CPU 不能在第二个 16ms 处理绘制工作呢？</strong></p>\n<p>原因是只有两个 buffer，Back buffer正在被GPU用来处理B帧的数据， Frame buffer的内容用于Display的显示，这样两个buffer都被占用，CPU 则无法准备下一帧的数据。那么，如果再提供一个buffer，CPU、GPU 和显示设备都能使用各自的buffer工作，互不影响。</p>\n<h3 id=\"3-3-三缓存\"><a href=\"#3-3-三缓存\" class=\"headerlink\" title=\"3.3 三缓存\"></a><strong>3.3 三缓存</strong></h3><p><strong>三缓存</strong>就是在双缓冲机制基础上增加了一个 Graphic Buffer 缓冲区，这样可以最大限度的利用空闲时间，带来的坏处是多使用的一个 Graphic Buffer 所占用的内存。</p>\n<img src=\"https://cdn.julis.wang/blog/img/ldq7oda57p.jpeg\">\n\n<p>三缓存</p>\n<ol>\n<li>第一个Jank，是不可避免的。但是在第二个 16ms 时间段，CPU&#x2F;GPU 使用 <strong>第三个 Buffer</strong> 完成C帧的计算，虽然还是会多显示一次 A 帧，但后续显示就比较顺畅了，有效避免 Jank 的进一步加剧。</li>\n<li>注意在第3段中，A帧的计算已完成，但是在第4个vsync来的时候才显示，如果是双缓冲，那在第三个vynsc就可以显示了。</li>\n</ol>\n<p><strong>三缓冲有效利用了等待vysnc的时间，减少了jank，但是带来了延迟。</strong> 所以，是不是 Buffer 越多越好呢？这个是否定的，Buffer 正常还是两个，当出现 Jank 后三个足以。</p>\n<p>以上就是Android屏幕刷新的原理了。</p>\n<h2 id=\"四、Choreographer\"><a href=\"#四、Choreographer\" class=\"headerlink\" title=\"四、Choreographer\"></a><strong>四、Choreographer</strong></h2><h3 id=\"4-1-概述\"><a href=\"#4-1-概述\" class=\"headerlink\" title=\"4.1 概述\"></a><strong>4.1 概述</strong></h3><p>上面讲到，Google在Android 4.1系统中对Android Display系统进行了优化：在收到VSync pulse后，将马上开始下一帧的渲染。即<strong>一旦收到VSync通知，CPU和GPU就立刻开始计算然后把数据写入buffer</strong>。本节就来讲 “drawing with VSync” 的实现——<strong>Choreographer</strong>。</p>\n<ul>\n<li>Choreographer，意为 舞蹈编导、编舞者。在这里就是指 对CPU&#x2F;GPU绘制的指导—— 收到VSync信号 才开始绘制，保证绘制拥有完整的16.6ms，避免绘制的随机性。</li>\n<li>Choreographer，是一个Java类，包路径android.view.Choreographer。类注释是“协调动画、输入和绘图的计时”。</li>\n<li>通常 应用层不会直接使用Choreographer，而是使用更高级的API，例如动画和View绘制相关的ValueAnimator.start()、View.invalidate()等。</li>\n<li>业界一般通过Choreographer来监控应用的帧率。</li>\n</ul>\n<h3 id=\"4-2-源码分析\"><a href=\"#4-2-源码分析\" class=\"headerlink\" title=\"4.2 源码分析\"></a><strong>4.2 源码分析</strong></h3><p>学习 Choreographer 可以帮助理解 每帧运行的原理，也可加深对 Handler机制、View绘制流程的理解，这样再去做UI优化、卡顿优化，思路会更清晰。</p>\n<p>好了，下面开始源码分析了~</p>\n<h5 id=\"4-2-1-入口-和-实例创建\"><a href=\"#4-2-1-入口-和-实例创建\" class=\"headerlink\" title=\"4.2.1 入口 和 实例创建\"></a><strong>4.2.1 入口 和 实例创建</strong></h5><p>在<a href=\"https://juejin.cn/post/7076274407416528909\">《Window和WindowManager》</a>、<a href=\"https://blog.csdn.net/allen_xu_2012_new/article/details/131167564\">《Activity的启动过程详解》</a>中介绍过，Activity启动 走完onResume方法后，会进行<strong>window的添加</strong>。window添加过程会 调用ViewRootImpl的setView()方法，setView()方法会调用requestLayout()方法来请求绘制布局，requestLayout()方法内部又会走到scheduleTraversals()方法，最后会走到performTraversals()方法，接着到了我们熟知的测量、布局、绘制三大流程了。</p>\n<p>另外，查看源码发现，当我们使用 ValueAnimator.start()、View.invalidate()时，最后也是走到ViewRootImpl的scheduleTraversals()方法。（View.invalidate()内部会循环获取ViewParent直到ViewRootImpl的invalidateChildInParent()方法，然后走到scheduleTraversals()，可自行查看源码 ）</p>\n<p>即 <strong>所有UI的变化都是走到ViewRootImpl的scheduleTraversals()方法。</strong></p>\n<p>那么问题又来了，scheduleTraversals() 到 performTraversals() 中间 经历了什么呢？是立刻执行吗？答案很显然是否定的，根据我们上面的介绍，在VSync信号到来时才会执行绘制，即performTraversals()方法。下面来瞅瞅这是如何实现的：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//ViewRootImpl.java</span></span><br><span class=\"line\"><span class=\"keyword\">void</span> <span class=\"title function_\">scheduleTraversals</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!mTraversalScheduled) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//此字段保证同时间多次更改只会刷新一次，例如TextView连续两次setText(),也只会走一次绘制流程</span></span><br><span class=\"line\">        mTraversalScheduled = <span class=\"literal\">true</span>;</span><br><span class=\"line\">        <span class=\"comment\">//添加同步屏障，屏蔽同步消息，保证VSync到来立即执行绘制</span></span><br><span class=\"line\">        mTraversalBarrier = mHandler.getLooper().getQueue().postSyncBarrier();</span><br><span class=\"line\">        <span class=\"comment\">//mTraversalRunnable是TraversalRunnable实例，最终走到run()，也即doTraversal();</span></span><br><span class=\"line\">        mChoreographer.postCallback(</span><br><span class=\"line\">                Choreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, <span class=\"literal\">null</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!mUnbufferedInputDispatch) &#123;</span><br><span class=\"line\">            scheduleConsumeBatchedInput();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        notifyRendererOfFramePending();</span><br><span class=\"line\">        pokeDrawLockIfNeeded();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">final</span> <span class=\"keyword\">class</span> <span class=\"title class_\">TraversalRunnable</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Runnable</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        doTraversal();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">final</span> <span class=\"type\">TraversalRunnable</span> <span class=\"variable\">mTraversalRunnable</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">TraversalRunnable</span>();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">void</span> <span class=\"title function_\">doTraversal</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mTraversalScheduled) &#123;</span><br><span class=\"line\">        mTraversalScheduled = <span class=\"literal\">false</span>;</span><br><span class=\"line\">        <span class=\"comment\">//移除同步屏障</span></span><br><span class=\"line\">        mHandler.getLooper().getQueue().removeSyncBarrier(mTraversalBarrier);</span><br><span class=\"line\">        ...</span><br><span class=\"line\">        <span class=\"comment\">//开始三大绘制流程</span></span><br><span class=\"line\">        performTraversals();</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>主要有以下逻辑：</p>\n<ol>\n<li>首先使用mTraversalScheduled字段保证同时间多次更改只会刷新一次，例如TextView连续两次setText()，也只会走一次绘制流程。</li>\n<li>然后把当前线程的<a href=\"https://cloud.tencent.com/product/message-queue-catalog?from_column=20065&from=20065\">消息队列</a>Queue添加了<strong>同步屏障</strong>，这样就屏蔽了正常的同步消息，保证VSync到来后立即执行绘制，而不是要等前面的同步消息。后面会具体分析同步屏障和异步消息的代码逻辑。</li>\n<li>调用了mChoreographer.postCallback()方法，发送一个会在下一帧执行的回调，即<strong>在下一个VSync到来时会执行TraversalRunnable–&gt;doTraversal()—&gt;performTraversals()–&gt;绘制流程</strong>。</li>\n</ol>\n<p>接下来，就是分析的重点——Choreographer。我们先看它的实例mChoreographer，是在ViewRootImpl的构造方法内使用Choreographer.getInstance()创建：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">Choreographer mChoreographer;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//ViewRootImpl实例是在添加window时创建</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"title function_\">ViewRootImpl</span><span class=\"params\">(Context context, Display display)</span> &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    mChoreographer = Choreographer.getInstance();</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们先来看看Choreographer.getInstance()：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Choreographer <span class=\"title function_\">getInstance</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> sThreadInstance.get();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> ThreadLocal&lt;Choreographer&gt; sThreadInstance =</span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">ThreadLocal</span>&lt;Choreographer&gt;() &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">protected</span> Choreographer <span class=\"title function_\">initialValue</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">Looper</span> <span class=\"variable\">looper</span> <span class=\"operator\">=</span> Looper.myLooper();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (looper == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//当前线程要有looper，Choreographer实例需要传入</span></span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">IllegalStateException</span>(<span class=\"string\">&quot;The current thread must have a looper!&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"type\">Choreographer</span> <span class=\"variable\">choreographer</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Choreographer</span>(looper, VSYNC_SOURCE_APP);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (looper == Looper.getMainLooper()) &#123;</span><br><span class=\"line\">            mMainInstance = choreographer;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> choreographer;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>看到这里 如你对Handler机制中looper比较熟悉的话，应该知道 Choreographer和Looper一样 是线程单例的。且当前线程要有looper，Choreographer实例需要传入。接着看看Choreographer构造方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"title function_\">Choreographer</span><span class=\"params\">(Looper looper, <span class=\"type\">int</span> vsyncSource)</span> &#123;</span><br><span class=\"line\">    mLooper = looper;</span><br><span class=\"line\">    <span class=\"comment\">//使用当前线程looper创建 mHandler</span></span><br><span class=\"line\">    mHandler = <span class=\"keyword\">new</span> <span class=\"title class_\">FrameHandler</span>(looper);</span><br><span class=\"line\">    <span class=\"comment\">//USE_VSYNC 4.1以上默认是true，表示 具备接受VSync的能力，这个接受能力就是FrameDisplayEventReceiver</span></span><br><span class=\"line\">    mDisplayEventReceiver = USE_VSYNC</span><br><span class=\"line\">            ? <span class=\"keyword\">new</span> <span class=\"title class_\">FrameDisplayEventReceiver</span>(looper, vsyncSource)</span><br><span class=\"line\">            : <span class=\"literal\">null</span>;</span><br><span class=\"line\">    mLastFrameTimeNanos = Long.MIN_VALUE;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 计算一帧的时间，Android手机屏幕是60Hz的刷新频率，就是16ms</span></span><br><span class=\"line\">    mFrameIntervalNanos = (<span class=\"type\">long</span>)(<span class=\"number\">1000000000</span> / getRefreshRate());</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 创建一个链表类型CallbackQueue的数组，大小为5，</span></span><br><span class=\"line\">    <span class=\"comment\">//也就是数组中有五个链表，每个链表存相同类型的任务：输入、动画、遍历绘制等任务（CALLBACK_INPUT、CALLBACK_ANIMATION、CALLBACK_TRAVERSAL）</span></span><br><span class=\"line\">    mCallbackQueues = <span class=\"keyword\">new</span> <span class=\"title class_\">CallbackQueue</span>[CALLBACK_LAST + <span class=\"number\">1</span>];</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt;= CALLBACK_LAST; i++) &#123;</span><br><span class=\"line\">        mCallbackQueues[i] = <span class=\"keyword\">new</span> <span class=\"title class_\">CallbackQueue</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// b/68769804: For low FPS experiments.</span></span><br><span class=\"line\">    setFPSDivisor(SystemProperties.getInt(ThreadedRenderer.DEBUG_FPS_DIVISOR, <span class=\"number\">1</span>));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>代码中都有注释，创建了一个mHandler、VSync事件接收器mDisplayEventReceiver、任务链表数组mCallbackQueues。FrameHandler、FrameDisplayEventReceiver、CallbackQueue后面会一一说明。</p>\n<h5 id=\"4-2-2-安排任务—postCallback\"><a href=\"#4-2-2-安排任务—postCallback\" class=\"headerlink\" title=\"4.2.2 安排任务—postCallback\"></a><strong>4.2.2 安排任务—postCallback</strong></h5><p>回头看mChoreographer.postCallback(Choreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, null)方法，注意到第一个参数是CALLBACK_TRAVERSAL，表示回调任务的类型，共有以下5种类型：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//输入事件，首先执行</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">CALLBACK_INPUT</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"comment\">//动画，第二执行</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">CALLBACK_ANIMATION</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"comment\">//插入更新的动画，第三执行</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">CALLBACK_INSETS_ANIMATION</span> <span class=\"operator\">=</span> <span class=\"number\">2</span>;</span><br><span class=\"line\"><span class=\"comment\">//绘制，第四执行</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">CALLBACK_TRAVERSAL</span> <span class=\"operator\">=</span> <span class=\"number\">3</span>;</span><br><span class=\"line\"><span class=\"comment\">//提交，最后执行，</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">CALLBACK_COMMIT</span> <span class=\"operator\">=</span> <span class=\"number\">4</span>;</span><br></pre></td></tr></table></figure>\n\n<p>五种类型任务对应存入对应的CallbackQueue中，每当收到 VSYNC 信号时，Choreographer 将首先处理 INPUT 类型的任务，然后是 ANIMATION 类型，最后才是 TRAVERSAL 类型。</p>\n<p>postCallback()内部调用postCallbackDelayed()，接着又调用postCallbackDelayedInternal()，来瞅瞅：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">postCallbackDelayedInternal</span><span class=\"params\">(<span class=\"type\">int</span> callbackType,</span></span><br><span class=\"line\"><span class=\"params\">        Object action, Object token, <span class=\"type\">long</span> delayMillis)</span> &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (mLock) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 当前时间</span></span><br><span class=\"line\">        <span class=\"keyword\">final</span> <span class=\"type\">long</span> <span class=\"variable\">now</span> <span class=\"operator\">=</span> SystemClock.uptimeMillis();</span><br><span class=\"line\">        <span class=\"comment\">// 加上延迟时间</span></span><br><span class=\"line\">        <span class=\"keyword\">final</span> <span class=\"type\">long</span> <span class=\"variable\">dueTime</span> <span class=\"operator\">=</span> now + delayMillis;</span><br><span class=\"line\">        <span class=\"comment\">//取对应类型的CallbackQueue添加任务</span></span><br><span class=\"line\">        mCallbackQueues[callbackType].addCallbackLocked(dueTime, action, token);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (dueTime &lt;= now) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//立即执行</span></span><br><span class=\"line\">            scheduleFrameLocked(now);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">//延迟运行，最终也会走到scheduleFrameLocked()</span></span><br><span class=\"line\">            <span class=\"type\">Message</span> <span class=\"variable\">msg</span> <span class=\"operator\">=</span> mHandler.obtainMessage(MSG_DO_SCHEDULE_CALLBACK, action);</span><br><span class=\"line\">            msg.arg1 = callbackType;</span><br><span class=\"line\">            msg.setAsynchronous(<span class=\"literal\">true</span>);</span><br><span class=\"line\">            mHandler.sendMessageAtTime(msg, dueTime);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>首先取对应类型的CallbackQueue添加任务，action就是mTraversalRunnable，token是null。<strong>CallbackQueue的addCallbackLocked()就是把 dueTime、action、token组装成CallbackRecord后 存入CallbackQueue的下一个节点</strong>，具体代码比较简单，不再跟进。</p>\n<p>然后注意到如果没有延迟会执行scheduleFrameLocked()方法，有延迟就会使用 mHandler发送MSG_DO_SCHEDULE_CALLBACK消息，并且注意到 <strong>使用msg.setAsynchronous(true)把消息设置成异步</strong>，这是因为前面设置了同步屏障，只有异步消息才会执行。我们看下mHandler的对这个消息的处理：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">class</span> <span class=\"title class_\">FrameHandler</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">Handler</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">FrameHandler</span><span class=\"params\">(Looper looper)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">super</span>(looper);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">handleMessage</span><span class=\"params\">(Message msg)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">switch</span> (msg.what) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> MSG_DO_FRAME:</span><br><span class=\"line\">                <span class=\"comment\">// 执行doFrame,即绘制过程</span></span><br><span class=\"line\">                doFrame(System.nanoTime(), <span class=\"number\">0</span>);</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> MSG_DO_SCHEDULE_VSYNC:</span><br><span class=\"line\">                <span class=\"comment\">//申请VSYNC信号，例如当前需要绘制任务时</span></span><br><span class=\"line\">                doScheduleVsync();</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> MSG_DO_SCHEDULE_CALLBACK:</span><br><span class=\"line\">                <span class=\"comment\">//需要延迟的任务，最终还是执行上述两个事件</span></span><br><span class=\"line\">                doScheduleCallback(msg.arg1);</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>直接使用doScheduleCallback方法，看看：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> <span class=\"title function_\">doScheduleCallback</span><span class=\"params\">(<span class=\"type\">int</span> callbackType)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (mLock) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!mFrameScheduled) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">final</span> <span class=\"type\">long</span> <span class=\"variable\">now</span> <span class=\"operator\">=</span> SystemClock.uptimeMillis();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (mCallbackQueues[callbackType].hasDueCallbacksLocked(now)) &#123;</span><br><span class=\"line\">                scheduleFrameLocked(now);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>发现也是走到这里，即延迟运行最终也会走到scheduleFrameLocked()，跟进看看：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">scheduleFrameLocked</span><span class=\"params\">(<span class=\"type\">long</span> now)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!mFrameScheduled) &#123;</span><br><span class=\"line\">        mFrameScheduled = <span class=\"literal\">true</span>;</span><br><span class=\"line\">        <span class=\"comment\">//开启了VSYNC</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (USE_VSYNC) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (DEBUG_FRAMES) &#123;</span><br><span class=\"line\">                Log.d(TAG, <span class=\"string\">&quot;Scheduling next frame on vsync.&quot;</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">//当前执行的线程，是否是mLooper所在线程</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (isRunningOnLooperThreadLocked()) &#123;</span><br><span class=\"line\">                <span class=\"comment\">//申请 VSYNC 信号</span></span><br><span class=\"line\">                scheduleVsyncLocked();</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 若不在，就用mHandler发送消息到原线程，最后还是调用scheduleVsyncLocked方法</span></span><br><span class=\"line\">                <span class=\"type\">Message</span> <span class=\"variable\">msg</span> <span class=\"operator\">=</span> mHandler.obtainMessage(MSG_DO_SCHEDULE_VSYNC);</span><br><span class=\"line\">                msg.setAsynchronous(<span class=\"literal\">true</span>);<span class=\"comment\">//异步</span></span><br><span class=\"line\">                mHandler.sendMessageAtFrontOfQueue(msg);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 如果未开启VSYNC则直接doFrame方法（4.1后默认开启）</span></span><br><span class=\"line\">            <span class=\"keyword\">final</span> <span class=\"type\">long</span> <span class=\"variable\">nextFrameTime</span> <span class=\"operator\">=</span> Math.max(</span><br><span class=\"line\">                    mLastFrameTimeNanos / TimeUtils.NANOS_PER_MS + sFrameDelay, now);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (DEBUG_FRAMES) &#123;</span><br><span class=\"line\">                Log.d(TAG, <span class=\"string\">&quot;Scheduling next frame in &quot;</span> + (nextFrameTime - now) + <span class=\"string\">&quot; ms.&quot;</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"type\">Message</span> <span class=\"variable\">msg</span> <span class=\"operator\">=</span> mHandler.obtainMessage(MSG_DO_FRAME);</span><br><span class=\"line\">            msg.setAsynchronous(<span class=\"literal\">true</span>);<span class=\"comment\">//异步</span></span><br><span class=\"line\">            mHandler.sendMessageAtTime(msg, nextFrameTime);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>如果系统未开启 VSYNC 机制，此时直接发送 MSG_DO_FRAME 消息到 FrameHandler。注意查看上面贴出的 FrameHandler 代码，此时直接执行 doFrame 方法。</li>\n<li>Android 4.1 之后系统默认开启 VSYNC，在 Choreographer 的构造方法会创建一个 FrameDisplayEventReceiver，scheduleVsyncLocked 方法将会通过它申请 VSYNC 信号。</li>\n<li>isRunningOnLooperThreadLocked 方法，其内部根据 Looper 判断是否在原线程，否则发送消息到 FrameHandler。最终还是会调用 scheduleVsyncLocked 方法申请 VSYNC 信号。</li>\n</ol>\n<p>到这里，<strong>FrameHandler的作用很明显里了：发送异步消息（因为前面设置了同步屏障）。有延迟的任务发延迟消息、不在原线程的发到原线程、没开启VSYNC的直接走 doFrame 方法取执行绘制。</strong></p>\n<h5 id=\"4-2-3-申请和接受VSync\"><a href=\"#4-2-3-申请和接受VSync\" class=\"headerlink\" title=\"4.2.3 申请和接受VSync\"></a><strong>4.2.3 申请和接受VSync</strong></h5><p>好了， 接着就看 scheduleVsyncLocked 方法是如何申请 VSYNC 信号的。猜测肯定申请 VSYNC 信号后，信号到来时也是走doFrame() 方法，doFrame()后面再看。先跟进scheduleVsyncLocked():</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">scheduleVsyncLocked</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    mDisplayEventReceiver.scheduleVsync();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>很简单，调用mDisplayEventReceiver的scheduleVsync()方法，mDisplayEventReceiver是Choreographer构造方法中创建，是FrameDisplayEventReceiver 的实例。FrameDisplayEventReceiver是 DisplayEventReceiver 的子类，DisplayEventReceiver 是一个 abstract class：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"title function_\">DisplayEventReceiver</span><span class=\"params\">(Looper looper, <span class=\"type\">int</span> vsyncSource)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (looper == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">IllegalArgumentException</span>(<span class=\"string\">&quot;looper must not be null&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    mMessageQueue = looper.getQueue();</span><br><span class=\"line\">    <span class=\"comment\">// 注册VSYNC信号监听者</span></span><br><span class=\"line\">    mReceiverPtr = nativeInit(<span class=\"keyword\">new</span> <span class=\"title class_\">WeakReference</span>&lt;DisplayEventReceiver&gt;(<span class=\"built_in\">this</span>), mMessageQueue,</span><br><span class=\"line\">            vsyncSource);</span><br><span class=\"line\"></span><br><span class=\"line\">    mCloseGuard.open(<span class=\"string\">&quot;dispose&quot;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在 DisplayEventReceiver 的构造方法会通过 JNI 创建一个 IDisplayEventConnection 的 VSYNC 的监听者。</p>\n<p>FrameDisplayEventReceiver的scheduleVsync()就是在 DisplayEventReceiver中：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">scheduleVsync</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mReceiverPtr == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        Log.w(TAG, <span class=\"string\">&quot;Attempted to schedule a vertical sync pulse but the display event &quot;</span></span><br><span class=\"line\">                + <span class=\"string\">&quot;receiver has already been disposed.&quot;</span>);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 申请VSYNC中断信号，会回调onVsync方法</span></span><br><span class=\"line\">        nativeScheduleVsync(mReceiverPtr);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>那么scheduleVsync()就是使用native方法nativeScheduleVsync()去申请VSYNC信号。这个native方法就看不了了，只需要知道<strong>VSYNC信号的接受回调是onVsync()</strong>，我们直接看onVsync()：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 接收到VSync脉冲时 回调</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> timestampNanos VSync脉冲的时间戳</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> physicalDisplayId Stable display ID that uniquely describes a (display, port) pair.</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> frame 帧号码，自增</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"meta\">@UnsupportedAppUsage</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">onVsync</span><span class=\"params\">(<span class=\"type\">long</span> timestampNanos, <span class=\"type\">long</span> physicalDisplayId, <span class=\"type\">int</span> frame)</span> &#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>具体实现是在FrameDisplayEventReceiver中：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">class</span> <span class=\"title class_\">FrameDisplayEventReceiver</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">DisplayEventReceiver</span></span><br><span class=\"line\">        <span class=\"keyword\">implements</span> <span class=\"title class_\">Runnable</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">boolean</span> mHavePendingVsync;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">long</span> mTimestampNanos;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">int</span> mFrame;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">FrameDisplayEventReceiver</span><span class=\"params\">(Looper looper, <span class=\"type\">int</span> vsyncSource)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">super</span>(looper, vsyncSource);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">onVsync</span><span class=\"params\">(<span class=\"type\">long</span> timestampNanos, <span class=\"type\">long</span> physicalDisplayId, <span class=\"type\">int</span> frame)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// Post the vsync event to the Handler.</span></span><br><span class=\"line\">        <span class=\"comment\">// The idea is to prevent incoming vsync events from completely starving</span></span><br><span class=\"line\">        <span class=\"comment\">// the message queue.  If there are no messages in the queue with timestamps</span></span><br><span class=\"line\">        <span class=\"comment\">// earlier than the frame time, then the vsync event will be processed immediately.</span></span><br><span class=\"line\">        <span class=\"comment\">// Otherwise, messages that predate the vsync event will be handled first.</span></span><br><span class=\"line\">        <span class=\"type\">long</span> <span class=\"variable\">now</span> <span class=\"operator\">=</span> System.nanoTime();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (timestampNanos &gt; now) &#123;</span><br><span class=\"line\">            Log.w(TAG, <span class=\"string\">&quot;Frame time is &quot;</span> + ((timestampNanos - now) * <span class=\"number\">0.000001f</span>)</span><br><span class=\"line\">                    + <span class=\"string\">&quot; ms in the future!  Check that graphics HAL is generating vsync &quot;</span></span><br><span class=\"line\">                    + <span class=\"string\">&quot;timestamps using the correct timebase.&quot;</span>);</span><br><span class=\"line\">            timestampNanos = now;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mHavePendingVsync) &#123;</span><br><span class=\"line\">            Log.w(TAG, <span class=\"string\">&quot;Already have a pending vsync event.  There should only be &quot;</span></span><br><span class=\"line\">                    + <span class=\"string\">&quot;one at a time.&quot;</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            mHavePendingVsync = <span class=\"literal\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        mTimestampNanos = timestampNanos;</span><br><span class=\"line\">        mFrame = frame;</span><br><span class=\"line\">        <span class=\"comment\">//将本身作为runnable传入msg， 发消息后 会走run()，即doFrame()，也是异步消息</span></span><br><span class=\"line\">        <span class=\"type\">Message</span> <span class=\"variable\">msg</span> <span class=\"operator\">=</span> Message.obtain(mHandler, <span class=\"built_in\">this</span>);</span><br><span class=\"line\">        msg.setAsynchronous(<span class=\"literal\">true</span>);</span><br><span class=\"line\">        mHandler.sendMessageAtTime(msg, timestampNanos / TimeUtils.NANOS_PER_MS);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        mHavePendingVsync = <span class=\"literal\">false</span>;</span><br><span class=\"line\">        doFrame(mTimestampNanos, mFrame);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>onVsync()中，将接收器本身作为runnable传入异步消息msg，并使用mHandler发送msg，最终执行的就是doFrame()方法了。</p>\n<p>注意一点是，<strong>onVsync()方法中只是使用mHandler发送消息到MessageQueue中，不一定是立刻执行，如何MessageQueue中前面有较为耗时的操作，那么就要等完成，才会执行本次的doFrame()</strong>。</p>\n<h5 id=\"4-2-4-doFrame\"><a href=\"#4-2-4-doFrame\" class=\"headerlink\" title=\"4.2.4 doFrame\"></a><strong>4.2.4 doFrame</strong></h5><p>和上面猜测一样，申请VSync信号接收到后确实是走 doFrame()方法，那么就来看看Choreographer的doFrame()：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> <span class=\"title function_\">doFrame</span><span class=\"params\">(<span class=\"type\">long</span> frameTimeNanos, <span class=\"type\">int</span> frame)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"type\">long</span> startNanos;</span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (mLock) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!mFrameScheduled) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span>; <span class=\"comment\">// no work to do</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        ...</span><br><span class=\"line\">        <span class=\"comment\">// 预期执行时间</span></span><br><span class=\"line\">        <span class=\"type\">long</span> <span class=\"variable\">intendedFrameTimeNanos</span> <span class=\"operator\">=</span> frameTimeNanos;</span><br><span class=\"line\">        startNanos = System.nanoTime();</span><br><span class=\"line\">        <span class=\"comment\">// 超时时间是否超过一帧的时间（这是因为MessageQueue虽然添加了同步屏障，但是还是有正在执行的同步任务，导致doFrame延迟执行了）</span></span><br><span class=\"line\">        <span class=\"keyword\">final</span> <span class=\"type\">long</span> <span class=\"variable\">jitterNanos</span> <span class=\"operator\">=</span> startNanos - frameTimeNanos;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (jitterNanos &gt;= mFrameIntervalNanos) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 计算掉帧数</span></span><br><span class=\"line\">            <span class=\"keyword\">final</span> <span class=\"type\">long</span> <span class=\"variable\">skippedFrames</span> <span class=\"operator\">=</span> jitterNanos / mFrameIntervalNanos;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (skippedFrames &gt;= SKIPPED_FRAME_WARNING_LIMIT) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 掉帧超过30帧打印Log提示</span></span><br><span class=\"line\">                Log.i(TAG, <span class=\"string\">&quot;Skipped &quot;</span> + skippedFrames + <span class=\"string\">&quot; frames!  &quot;</span></span><br><span class=\"line\">                        + <span class=\"string\">&quot;The application may be doing too much work on its main thread.&quot;</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">final</span> <span class=\"type\">long</span> <span class=\"variable\">lastFrameOffset</span> <span class=\"operator\">=</span> jitterNanos % mFrameIntervalNanos;</span><br><span class=\"line\">            ...</span><br><span class=\"line\">            frameTimeNanos = startNanos - lastFrameOffset;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        ...</span><br><span class=\"line\"></span><br><span class=\"line\">        mFrameInfo.setVsync(intendedFrameTimeNanos, frameTimeNanos);</span><br><span class=\"line\">        <span class=\"comment\">// Frame标志位恢复</span></span><br><span class=\"line\">        mFrameScheduled = <span class=\"literal\">false</span>;</span><br><span class=\"line\">        <span class=\"comment\">// 记录最后一帧时间</span></span><br><span class=\"line\">        mLastFrameTimeNanos = frameTimeNanos;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 按类型顺序 执行任务</span></span><br><span class=\"line\">        Trace.traceBegin(Trace.TRACE_TAG_VIEW, <span class=\"string\">&quot;Choreographer#doFrame&quot;</span>);</span><br><span class=\"line\">        AnimationUtils.lockAnimationClock(frameTimeNanos / TimeUtils.NANOS_PER_MS);</span><br><span class=\"line\"></span><br><span class=\"line\">        mFrameInfo.markInputHandlingStart();</span><br><span class=\"line\">        doCallbacks(Choreographer.CALLBACK_INPUT, frameTimeNanos);</span><br><span class=\"line\"></span><br><span class=\"line\">        mFrameInfo.markAnimationsStart();</span><br><span class=\"line\">        doCallbacks(Choreographer.CALLBACK_ANIMATION, frameTimeNanos);</span><br><span class=\"line\">        doCallbacks(Choreographer.CALLBACK_INSETS_ANIMATION, frameTimeNanos);</span><br><span class=\"line\"></span><br><span class=\"line\">        mFrameInfo.markPerformTraversalsStart();</span><br><span class=\"line\">        doCallbacks(Choreographer.CALLBACK_TRAVERSAL, frameTimeNanos);</span><br><span class=\"line\"></span><br><span class=\"line\">        doCallbacks(Choreographer.CALLBACK_COMMIT, frameTimeNanos);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        AnimationUtils.unlockAnimationClock();</span><br><span class=\"line\">        Trace.traceEnd(Trace.TRACE_TAG_VIEW);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面都有注释了很好理解，接着看任务的具体执行doCallbacks 方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> <span class=\"title function_\">doCallbacks</span><span class=\"params\">(<span class=\"type\">int</span> callbackType, <span class=\"type\">long</span> frameTimeNanos)</span> &#123;</span><br><span class=\"line\">    CallbackRecord callbacks;</span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (mLock) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">final</span> <span class=\"type\">long</span> <span class=\"variable\">now</span> <span class=\"operator\">=</span> System.nanoTime();</span><br><span class=\"line\">        <span class=\"comment\">// 根据指定的类型CallbackkQueue中查找到达执行时间的CallbackRecord</span></span><br><span class=\"line\">        callbacks = mCallbackQueues[callbackType].extractDueCallbacksLocked(now / TimeUtils.NANOS_PER_MS);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (callbacks == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        mCallbacksRunning = <span class=\"literal\">true</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//提交任务类型</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (callbackType == Choreographer.CALLBACK_COMMIT) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">final</span> <span class=\"type\">long</span> <span class=\"variable\">jitterNanos</span> <span class=\"operator\">=</span> now - frameTimeNanos;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (jitterNanos &gt;= <span class=\"number\">2</span> * mFrameIntervalNanos) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">final</span> <span class=\"type\">long</span> <span class=\"variable\">lastFrameOffset</span> <span class=\"operator\">=</span> jitterNanos % mFrameIntervalNanos</span><br><span class=\"line\">                        + mFrameIntervalNanos;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (DEBUG_JANK) &#123;</span><br><span class=\"line\">                    Log.d(TAG, <span class=\"string\">&quot;Commit callback delayed by &quot;</span> + (jitterNanos * <span class=\"number\">0.000001f</span>)</span><br><span class=\"line\">                            + <span class=\"string\">&quot; ms which is more than twice the frame interval of &quot;</span></span><br><span class=\"line\">                            + (mFrameIntervalNanos * <span class=\"number\">0.000001f</span>) + <span class=\"string\">&quot; ms!  &quot;</span></span><br><span class=\"line\">                            + <span class=\"string\">&quot;Setting frame time to &quot;</span> + (lastFrameOffset * <span class=\"number\">0.000001f</span>)</span><br><span class=\"line\">                            + <span class=\"string\">&quot; ms in the past.&quot;</span>);</span><br><span class=\"line\">                    mDebugPrintNextFrameTimeDelta = <span class=\"literal\">true</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                frameTimeNanos = now - lastFrameOffset;</span><br><span class=\"line\">                mLastFrameTimeNanos = frameTimeNanos;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 迭代执行队列所有任务</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">CallbackRecord</span> <span class=\"variable\">c</span> <span class=\"operator\">=</span> callbacks; c != <span class=\"literal\">null</span>; c = c.next) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 回调CallbackRecord的run，其内部回调Callback的run</span></span><br><span class=\"line\">            c.run(frameTimeNanos);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span> (mLock) &#123;</span><br><span class=\"line\">            mCallbacksRunning = <span class=\"literal\">false</span>;</span><br><span class=\"line\">            <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">final</span> <span class=\"type\">CallbackRecord</span> <span class=\"variable\">next</span> <span class=\"operator\">=</span> callbacks.next;</span><br><span class=\"line\">                <span class=\"comment\">//回收CallbackRecord</span></span><br><span class=\"line\">                recycleCallbackLocked(callbacks);</span><br><span class=\"line\">                callbacks = next;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">while</span> (callbacks != <span class=\"literal\">null</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>主要内容就是取对应任务类型的队列，遍历队列执行所有任务，执行任务是 CallbackRecord的 run 方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">class</span> <span class=\"title class_\">CallbackRecord</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> CallbackRecord next;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">long</span> dueTime;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> Object action; <span class=\"comment\">// Runnable or FrameCallback</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Object token;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@UnsupportedAppUsage</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">(<span class=\"type\">long</span> frameTimeNanos)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (token == FRAME_CALLBACK_TOKEN) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 通过postFrameCallback 或 postFrameCallbackDelayed，会执行这里</span></span><br><span class=\"line\">            ((FrameCallback)action).doFrame(frameTimeNanos);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">//取出Runnable执行run()</span></span><br><span class=\"line\">            ((Runnable)action).run();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>前面看到mChoreographer.postCallback传的token是null，所以取出action，就是Runnable，执行run()，这里的action就是 ViewRootImpl 发起的绘制任务mTraversalRunnable了，那么<strong>这样整个逻辑就闭环了</strong>。</p>\n<p>那么 啥时候 token &#x3D;&#x3D; FRAME_CALLBACK_TOKEN 呢？答案是Choreographer的postFrameCallback()方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">postFrameCallback</span><span class=\"params\">(FrameCallback callback)</span> &#123;</span><br><span class=\"line\">    postFrameCallbackDelayed(callback, <span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">postFrameCallbackDelayed</span><span class=\"params\">(FrameCallback callback, <span class=\"type\">long</span> delayMillis)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (callback == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">IllegalArgumentException</span>(<span class=\"string\">&quot;callback must not be null&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//也是走到是postCallbackDelayedInternal，并且注意是CALLBACK_ANIMATION类型，</span></span><br><span class=\"line\">    <span class=\"comment\">//token是FRAME_CALLBACK_TOKEN，action就是FrameCallback</span></span><br><span class=\"line\">    postCallbackDelayedInternal(CALLBACK_ANIMATION,</span><br><span class=\"line\">            callback, FRAME_CALLBACK_TOKEN, delayMillis);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">FrameCallback</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">doFrame</span><span class=\"params\">(<span class=\"type\">long</span> frameTimeNanos)</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可以看到postFrameCallback()传入的是FrameCallback实例，接口FrameCallback只有一个doFrame()方法。并且也是走到postCallbackDelayedInternal，FrameCallback实例作为action传入，token则是FRAME_CALLBACK_TOKEN，并且任务是CALLBACK_ANIMATION类型。</p>\n<p><strong>Choreographer的postFrameCallback()通常用来计算丢帧情况</strong>，使用方式如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">      <span class=\"comment\">//Application.java</span></span><br><span class=\"line\">       <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">onCreate</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">           <span class=\"built_in\">super</span>.onCreate();</span><br><span class=\"line\">           <span class=\"comment\">//在Application中使用postFrameCallback</span></span><br><span class=\"line\">           Choreographer.getInstance().postFrameCallback(<span class=\"keyword\">new</span> <span class=\"title class_\">FPSFrameCallback</span>(System.nanoTime()));</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">FPSFrameCallback</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Choreographer</span>.FrameCallback &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">String</span> <span class=\"variable\">TAG</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;FPS_TEST&quot;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">long</span> <span class=\"variable\">mLastFrameTimeNanos</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">long</span> mFrameIntervalNanos;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">FPSFrameCallback</span><span class=\"params\">(<span class=\"type\">long</span> lastFrameTimeNanos)</span> &#123;</span><br><span class=\"line\">        mLastFrameTimeNanos = lastFrameTimeNanos;</span><br><span class=\"line\">        mFrameIntervalNanos = (<span class=\"type\">long</span>)(<span class=\"number\">1000000000</span> / <span class=\"number\">60.0</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">doFrame</span><span class=\"params\">(<span class=\"type\">long</span> frameTimeNanos)</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//初始化时间</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mLastFrameTimeNanos == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            mLastFrameTimeNanos = frameTimeNanos;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> <span class=\"type\">long</span> <span class=\"variable\">jitterNanos</span> <span class=\"operator\">=</span> frameTimeNanos - mLastFrameTimeNanos;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (jitterNanos &gt;= mFrameIntervalNanos) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">final</span> <span class=\"type\">long</span> <span class=\"variable\">skippedFrames</span> <span class=\"operator\">=</span> jitterNanos / mFrameIntervalNanos;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(skippedFrames&gt;<span class=\"number\">30</span>)&#123;</span><br><span class=\"line\">                <span class=\"comment\">//丢帧30以上打印日志</span></span><br><span class=\"line\">                Log.i(TAG, <span class=\"string\">&quot;Skipped &quot;</span> + skippedFrames + <span class=\"string\">&quot; frames!  &quot;</span></span><br><span class=\"line\">                        + <span class=\"string\">&quot;The application may be doing too much work on its main thread.&quot;</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        mLastFrameTimeNanos=frameTimeNanos;</span><br><span class=\"line\">        <span class=\"comment\">//注册下一帧回调</span></span><br><span class=\"line\">        Choreographer.getInstance().postFrameCallback(<span class=\"built_in\">this</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"4-2-5-小结\"><a href=\"#4-2-5-小结\" class=\"headerlink\" title=\"4.2.5 小结\"></a><strong>4.2.5 小结</strong></h5><p>使用Choreographer的postCallback()、postFrameCallback() 作用理解：发送任务 存队列中，监听VSync信号，当前VSync到来时 会使用mHandler发送异步message，这个message的Runnable就是队列中的所有任务。</p>\n<p>好了，Choreographer整个代码逻辑都讲完了，引用《Android 之 Choreographer 详细分析》的流程图：</p>\n<p>原文流程图为：<a href=\"https://i-blog.csdnimg.cn/blog_migrate/5ff22e98afde4ff780f8a291d1081619.png\">Android 之 Choreographer</a>，但并不是很形象，引用另一张流程图：</p>\n<img src=\"https://cdn.julis.wang/blog/img/aab4273a0af898dcc9bb0fdcc0447b5a.png\">\n<h2 id=\"六、疑问解答\"><a href=\"#六、疑问解答\" class=\"headerlink\" title=\"六、疑问解答\"></a><strong>六、疑问解答</strong></h2><ol>\n<li><strong>丢帧</strong>(掉帧) ，是说 这一帧延迟显示 还是丢弃不再显示 ？ 答：延迟显示，因为缓存交换的时机只能等下一个VSync了。</li>\n<li>布局层级较多&#x2F;主线程耗时 是如何造成 丢帧的呢？ 答：布局层级较多&#x2F;主线程耗时 会影响CPU&#x2F;GPU的执行时间，大于16.6ms时只能等下一个VSync了。</li>\n<li>16.6ms刷新一次 是啥意思？是每16.6ms都走一次 measure&#x2F;layout&#x2F;draw ？ 答：屏幕的固定刷新频率是60Hz，即16.6ms。不是每16.6ms都走一次 measure&#x2F;layout&#x2F;draw，而是有绘制任务才会走，并且绘制时间间隔是取决于布局复杂度及主线程耗时。</li>\n<li>measure&#x2F;layout&#x2F;draw 走完，界面就立刻刷新了吗? 答：不是。measure&#x2F;layout&#x2F;draw 走完后 会在VSync到来时进行缓存交换和刷新。</li>\n<li>如果界面没动静止了，还会刷新吗？ 答：屏幕会固定没16.6ms刷新，但CPU&#x2F;GPU不走绘制流程。见下面的SysTrace图。</li>\n<li>可能你知道<strong>VSYNC</strong>，这个具体指啥？在屏幕刷新中如何工作的？ 答：当扫描完一个屏幕后，设备需要重新回到第一行以进入下一次的循环，此时会出现的vertical sync pulse（垂直同步脉冲）来保证双缓冲在最佳时间点才进行交换。并且Android4.1后 CPU&#x2F;GPU的绘制是在VSYNC到来时开始。</li>\n<li>可能你还听过屏幕刷新使用 <strong>双缓存</strong>、<strong>三缓存</strong>，这又是啥意思呢？ 答：双缓存是Back buffer、Frame buffer，用于解决画面撕裂。三缓存增加一个Back buffer，用于减少Jank。</li>\n<li>可能你还听过神秘的<strong>Choreographer</strong>，这又是干啥的？ 答：用于实现——“CPU&#x2F;GPU的绘制是在VSYNC到来时开始”。</li>\n</ol>\n","cover":null,"images":["https://cdn.julis.wang/blog/img/0nq54q5jtq.jpeg","https://cdn.julis.wang/blog/img/xxm0lvzypa.jpeg","https://cdn.julis.wang/blog/img/q2vukxpyvq.jpeg","https://cdn.julis.wang/blog/img/1ax0mz0nu1.jpeg","https://cdn.julis.wang/blog/img/uuqflxwo53.jpeg","https://cdn.julis.wang/blog/img/po2jd1h7u8.jpeg","https://cdn.julis.wang/blog/img/ldq7oda57p.jpeg","https://cdn.julis.wang/blog/img/aab4273a0af898dcc9bb0fdcc0447b5a.png"],"content":"<p>最近在研究 Android 屏幕显示与渲染相关的内容，平时经常看到这些类 <code>ViewRootImpl</code>、<code>Choreographer</code>、<code>Surface</code> 、 <code>SurfaceFlinger</code>等，知道它们都用于屏幕渲染相关，但对它们细节了解较少，相关的文章也比较多，不需要自己完全重新再编写一份，于是对相关内容进行一个总结,<br>主要来源：<a href=\"https://juejin.cn/post/6863756420380196877\">《Android屏幕刷新机制—VSyncChoreographer 全面理解》</a>，这篇博客是我认为是目前看到过最好的一篇，文章由浅入深比较好理解。不过文章里面图片链接资源已经失效，为以后复习相关知识点，在此将其整理删除冗余内容，并对图片资源进行更新。</p>\n<h2 id=\"一、背景和疑问\"><a href=\"#一、背景和疑问\" class=\"headerlink\" title=\"一、背景和疑问\"></a><strong>一、背景和疑问</strong></h2><p>在Android中，当我们谈到 <strong>布局优化</strong>、<strong>卡顿优化</strong> 时，通常都知道 需要减少布局层级、减少主线程耗时操作，这样可以减少<strong>丢帧</strong>。如果丢帧比较严重，那么界面可能会有明显的卡顿感。我们知道 通常手机刷新是每秒60次，即每隔16.6ms刷新一次。 问题来了：</p>\n<ol>\n<li><strong>丢帧</strong>(掉帧) ，是说 这一帧延迟显示 还是丢弃不再显示 ？</li>\n<li>布局层级较多&#x2F;主线程耗时 是如何造成 丢帧的呢？</li>\n<li>16.6ms刷新一次 是啥意思？是每16.6ms都走一次 measure&#x2F;layout&#x2F;draw ？</li>\n<li>measure&#x2F;layout&#x2F;draw 走完，界面就立刻刷新了吗?</li>\n<li>如果界面没动静止了，还会刷新吗？</li>\n<li>可能你知道<strong>VSYNC</strong>，这个具体指啥？在屏幕刷新中如何工作的？</li>\n<li>可能你还听过屏幕刷新使用 <strong>双缓存</strong>、<strong>三缓存</strong>，这又是啥意思呢？</li>\n<li>可能你还听过神秘的<strong>Choreographer</strong>，这又是干啥的？</li>\n</ol>\n<h2 id=\"二、显示系统基础知识\"><a href=\"#二、显示系统基础知识\" class=\"headerlink\" title=\"二、显示系统基础知识\"></a><strong>二、显示系统基础知识</strong></h2><p>在一个典型的显示系统中，一般包括CPU、GPU、Display三个部分， CPU负责计算帧数据，把计算好的数据交给GPU，GPU会对图形数据进行渲染，渲染好后放到buffer(图像缓冲区)里存起来，然后Display（屏幕或显示器）负责把buffer里的数据呈现到屏幕上。如下图：</p>\n<img src=\"https://cdn.julis.wang/blog/img/0nq54q5jtq.jpeg\">\n\n<p>单缓存，从缓存映射到屏幕。</p>\n<h3 id=\"2-1-基础概念\"><a href=\"#2-1-基础概念\" class=\"headerlink\" title=\"2.1 基础概念\"></a><strong>2.1 基础概念</strong></h3><ul>\n<li><strong>屏幕刷新频率</strong> 一秒内屏幕刷新的次数（一秒内显示了多少帧的图像），单位 Hz（赫兹），如常见的 60 Hz。<strong>刷新频率取决于硬件的固定参数</strong>（不会变的）。</li>\n<li><strong>逐行扫描</strong> 显示器并不是一次性将画面显示到屏幕上，而是从左到右边，从上到下逐行扫描，顺序显示整屏的一个个像素点，不过这一过程快到人眼无法察觉到变化。以 60 Hz 刷新率的屏幕为例，这一过程即 1000 &#x2F; 60 ≈ 16ms。</li>\n<li><strong>帧率</strong> （Frame Rate） 表示 <strong>GPU 在一秒内绘制操作的帧数</strong>，单位 fps。例如在电影界采用 24 帧的速度足够使画面运行的非常流畅。而 Android 系统则采用更加流程的 60 fps，即每秒钟GPU最多绘制 60 帧画面。帧率是动态变化的，例如当画面静止时，GPU 是没有绘制操作的，屏幕刷新的还是buffer中的数据，即GPU最后操作的帧数据。</li>\n<li><strong>画面撕裂</strong>（tearing） 一个屏幕内的数据来自2个不同的帧，画面会出现撕裂感，如下图</li>\n</ul>\n<img src=\"https://cdn.julis.wang/blog/img/xxm0lvzypa.jpeg\">\n\n<p>明显看出画面错位的位置，这就是画面撕裂。</p>\n<h3 id=\"2-2-双缓存\"><a href=\"#2-2-双缓存\" class=\"headerlink\" title=\"2.2 双缓存\"></a><strong>2.2 双缓存</strong></h3><h5 id=\"2-2-1-画面撕裂-原因\"><a href=\"#2-2-1-画面撕裂-原因\" class=\"headerlink\" title=\"2.2.1  画面撕裂 原因\"></a><strong>2.2.1  画面撕裂 原因</strong></h5><p>屏幕刷新频是固定的，比如每16.6ms从buffer取数据显示完一帧，理想情况下帧率和刷新频率保持一致，即每绘制完成一帧，显示器显示一帧。但是CPU&#x2F;GPU写数据是不可控的，所以会出现buffer里有些数据根本没显示出来就被重写了，即buffer里的数据可能是来自不同的帧的， 当屏幕刷新时，此时它并不知道buffer的状态，因此从buffer抓取的帧并不是完整的一帧画面，即出现画面撕裂。</p>\n<p>简单说就是Display在显示的过程中，buffer内数据被CPU&#x2F;GPU修改，导致画面撕裂。</p>\n<h5 id=\"2-2-2-双缓存\"><a href=\"#2-2-2-双缓存\" class=\"headerlink\" title=\"2.2.2  双缓存\"></a><strong>2.2.2  双缓存</strong></h5><p>那咋解决画面撕裂呢？答案是使用 双缓存。</p>\n<p>由于图像绘制和屏幕读取 使用的是同个buffer，所以屏幕刷新时可能读取到的是不完整的一帧画面。</p>\n<p><strong>双缓存</strong>，让绘制和显示器拥有各自的buffer：GPU 始终将完成的一帧图像数据写入到 <strong>Back Buffer</strong>，而显示器使用 <strong>Frame Buffer</strong>，当屏幕刷新时，Frame Buffer 并不会发生变化，当Back buffer准备就绪后，它们才进行交换。如下图：</p>\n<img src=\"https://cdn.julis.wang/blog/img/q2vukxpyvq.jpeg\">\n\n<p>双缓存，CPU&#x2F;GPU写数据到Back Buffer，显示器从Frame Buffer取数据</p>\n<h5 id=\"2-2-3-VSync\"><a href=\"#2-2-3-VSync\" class=\"headerlink\" title=\"2.2.3  VSync\"></a><strong>2.2.3  VSync</strong></h5><p>问题又来了：什么时候进行两个buffer的交换呢？</p>\n<p>假如是 Back buffer准备完成一帧数据以后就进行，那么如果此时屏幕还没有完整显示上一帧内容的话，肯定是会出问题的。看来只能是等到屏幕处理完一帧数据后，才可以执行这一操作了。</p>\n<p>当扫描完一个屏幕后，设备需要重新回到第一行以进入下一次的循环，此时有一段时间空隙，称为VerticalBlanking Interval(VBI)。那，这个时间点就是我们进行缓冲区交换的最佳时间。因为此时屏幕没有在刷新，也就避免了交换过程中出现 screen tearing的状况。</p>\n<p><strong>VSync</strong>(垂直同步)是VerticalSynchronization的简写，它利用VBI时期出现的vertical sync pulse（垂直同步脉冲）来保证双缓冲在最佳时间点才进行交换。另外，交换是指各自的内存地址，可以认为该操作是瞬间完成。</p>\n<p>所以说V-sync这个概念并不是Google首创的，它在早年的PC机领域就已经出现了。</p>\n<h2 id=\"三、Android屏幕刷新机制\"><a href=\"#三、Android屏幕刷新机制\" class=\"headerlink\" title=\"三、Android屏幕刷新机制\"></a><strong>三、Android屏幕刷新机制</strong></h2><h3 id=\"3-1-Android4-1之前的问题\"><a href=\"#3-1-Android4-1之前的问题\" class=\"headerlink\" title=\"3.1 Android4.1之前的问题\"></a><strong>3.1 Android4.1之前的问题</strong></h3><p>具体到Android中，在Android4.1之前，屏幕刷新也遵循 上面介绍的 双缓存+VSync 机制。如下图：</p>\n<img src=\"https://cdn.julis.wang/blog/img/1ax0mz0nu1.jpeg\">\n\n<p>双缓存会在VSync脉冲时交换，但CPU&#x2F;GPU绘制是随机的</p>\n<p>以时间的顺序来看下将会发生的过程：</p>\n<ol>\n<li>Display显示第0帧数据，此时CPU和<a href=\"https://cloud.tencent.com/solution/render?from_column=20065&from=20065\">GPU渲染</a>第1帧画面，且在Display显示下一帧前完成</li>\n<li>因为渲染及时，Display在第0帧显示完成后，也就是第1个VSync后，缓存进行交换，然后正常显示第1帧</li>\n<li>接着第2帧开始处理，是直到第2个VSync快来前才开始处理的。</li>\n<li>第2个VSync来时，由于第2帧数据还没有准备就绪，缓存没有交换，显示的还是第1帧。这种情况被Android开发组命名为“Jank”，即发生了<strong>丢帧</strong>。</li>\n<li>当第2帧数据准备完成后，它并不会马上被显示，而是要等待下一个VSync 进行缓存交换再显示。</li>\n</ol>\n<p>所以总的来说，就是屏幕平白无故地多显示了一次第1帧。</p>\n<p>原因是 第2帧的CPU&#x2F;GPU计算 没能在VSync信号到来前完成 。</p>\n<p>我们知道，<strong>双缓存的交换 是在Vsyn到来时进行，交换后屏幕会取Frame buffer内的新数据，而实际 此时的Back buffer 就可以供GPU准备下一帧数据了。如果 Vsyn到来时  CPU&#x2F;GPU就开始操作的话，是有完整的16.6ms的，这样应该会基本避免jank的出现了</strong>（除非CPU&#x2F;GPU计算超过了16.6ms）。  那如何让 CPU&#x2F;GPU计算在 Vsyn到来时进行呢？</p>\n<h3 id=\"3-2-drawing-with-VSync\"><a href=\"#3-2-drawing-with-VSync\" class=\"headerlink\" title=\"3.2 drawing with VSync\"></a><strong>3.2 drawing with VSync</strong></h3><p>为了优化显示性能，Google在Android 4.1系统中对Android Display系统进行了重构，实现了Project Butter（黄油工程）：系统在收到VSync pulse后，将马上开始下一帧的渲染。即<strong>一旦收到VSync通知（16ms触发一次），CPU和GPU 才立刻开始计算然后把数据写入buffer</strong>。如下图：</p>\n<img src=\"https://cdn.julis.wang/blog/img/uuqflxwo53.jpeg\">\n\n<p>VSync脉冲到来：双缓存交换，且开始CPU&#x2F;GPU绘制 CPU&#x2F;GPU根据VSYNC信号同步处理数据，可以让CPU&#x2F;GPU有完整的16ms时间来处理数据，减少了jank。</p>\n<p>一句话总结，<strong>VSync同步使得CPU&#x2F;GPU充分利用了16.6ms时间，减少jank。</strong></p>\n<p>问题又来了，如果界面比较复杂，CPU&#x2F;GPU的处理时间较长 超过了16.6ms呢？如下图：</p>\n<img src=\"https://cdn.julis.wang/blog/img/po2jd1h7u8.jpeg\">\n\n<p>虽然CPU&#x2F;GPU开始在VSync，但超过16.6ms</p>\n<ol>\n<li>在第二个时间段内，但却因 GPU 还在处理 B 帧，缓存没能交换，导致 A 帧被重复显示。</li>\n<li>而B完成后，又因为缺乏VSync pulse信号，它只能等待下一个signal的来临。于是在这一过程中，有一大段时间是被浪费的。</li>\n<li>当下一个VSync出现时，CPU&#x2F;GPU马上执行操作（A帧），且缓存交换，相应的显示屏对应的就是B。这时看起来就是正常的。只不过由于执行时间仍然超过16ms，导致下一次应该执行的缓冲区交换又被推迟了——如此循环反复，便出现了越来越多的“Jank”。</li>\n</ol>\n<p><strong>为什么 CPU 不能在第二个 16ms 处理绘制工作呢？</strong></p>\n<p>原因是只有两个 buffer，Back buffer正在被GPU用来处理B帧的数据， Frame buffer的内容用于Display的显示，这样两个buffer都被占用，CPU 则无法准备下一帧的数据。那么，如果再提供一个buffer，CPU、GPU 和显示设备都能使用各自的buffer工作，互不影响。</p>\n<h3 id=\"3-3-三缓存\"><a href=\"#3-3-三缓存\" class=\"headerlink\" title=\"3.3 三缓存\"></a><strong>3.3 三缓存</strong></h3><p><strong>三缓存</strong>就是在双缓冲机制基础上增加了一个 Graphic Buffer 缓冲区，这样可以最大限度的利用空闲时间，带来的坏处是多使用的一个 Graphic Buffer 所占用的内存。</p>\n<img src=\"https://cdn.julis.wang/blog/img/ldq7oda57p.jpeg\">\n\n<p>三缓存</p>\n<ol>\n<li>第一个Jank，是不可避免的。但是在第二个 16ms 时间段，CPU&#x2F;GPU 使用 <strong>第三个 Buffer</strong> 完成C帧的计算，虽然还是会多显示一次 A 帧，但后续显示就比较顺畅了，有效避免 Jank 的进一步加剧。</li>\n<li>注意在第3段中，A帧的计算已完成，但是在第4个vsync来的时候才显示，如果是双缓冲，那在第三个vynsc就可以显示了。</li>\n</ol>\n<p><strong>三缓冲有效利用了等待vysnc的时间，减少了jank，但是带来了延迟。</strong> 所以，是不是 Buffer 越多越好呢？这个是否定的，Buffer 正常还是两个，当出现 Jank 后三个足以。</p>\n<p>以上就是Android屏幕刷新的原理了。</p>\n<h2 id=\"四、Choreographer\"><a href=\"#四、Choreographer\" class=\"headerlink\" title=\"四、Choreographer\"></a><strong>四、Choreographer</strong></h2><h3 id=\"4-1-概述\"><a href=\"#4-1-概述\" class=\"headerlink\" title=\"4.1 概述\"></a><strong>4.1 概述</strong></h3><p>上面讲到，Google在Android 4.1系统中对Android Display系统进行了优化：在收到VSync pulse后，将马上开始下一帧的渲染。即<strong>一旦收到VSync通知，CPU和GPU就立刻开始计算然后把数据写入buffer</strong>。本节就来讲 “drawing with VSync” 的实现——<strong>Choreographer</strong>。</p>\n<ul>\n<li>Choreographer，意为 舞蹈编导、编舞者。在这里就是指 对CPU&#x2F;GPU绘制的指导—— 收到VSync信号 才开始绘制，保证绘制拥有完整的16.6ms，避免绘制的随机性。</li>\n<li>Choreographer，是一个Java类，包路径android.view.Choreographer。类注释是“协调动画、输入和绘图的计时”。</li>\n<li>通常 应用层不会直接使用Choreographer，而是使用更高级的API，例如动画和View绘制相关的ValueAnimator.start()、View.invalidate()等。</li>\n<li>业界一般通过Choreographer来监控应用的帧率。</li>\n</ul>\n<h3 id=\"4-2-源码分析\"><a href=\"#4-2-源码分析\" class=\"headerlink\" title=\"4.2 源码分析\"></a><strong>4.2 源码分析</strong></h3><p>学习 Choreographer 可以帮助理解 每帧运行的原理，也可加深对 Handler机制、View绘制流程的理解，这样再去做UI优化、卡顿优化，思路会更清晰。</p>\n<p>好了，下面开始源码分析了~</p>\n<h5 id=\"4-2-1-入口-和-实例创建\"><a href=\"#4-2-1-入口-和-实例创建\" class=\"headerlink\" title=\"4.2.1 入口 和 实例创建\"></a><strong>4.2.1 入口 和 实例创建</strong></h5><p>在<a href=\"https://juejin.cn/post/7076274407416528909\">《Window和WindowManager》</a>、<a href=\"https://blog.csdn.net/allen_xu_2012_new/article/details/131167564\">《Activity的启动过程详解》</a>中介绍过，Activity启动 走完onResume方法后，会进行<strong>window的添加</strong>。window添加过程会 调用ViewRootImpl的setView()方法，setView()方法会调用requestLayout()方法来请求绘制布局，requestLayout()方法内部又会走到scheduleTraversals()方法，最后会走到performTraversals()方法，接着到了我们熟知的测量、布局、绘制三大流程了。</p>\n<p>另外，查看源码发现，当我们使用 ValueAnimator.start()、View.invalidate()时，最后也是走到ViewRootImpl的scheduleTraversals()方法。（View.invalidate()内部会循环获取ViewParent直到ViewRootImpl的invalidateChildInParent()方法，然后走到scheduleTraversals()，可自行查看源码 ）</p>\n<p>即 <strong>所有UI的变化都是走到ViewRootImpl的scheduleTraversals()方法。</strong></p>\n<p>那么问题又来了，scheduleTraversals() 到 performTraversals() 中间 经历了什么呢？是立刻执行吗？答案很显然是否定的，根据我们上面的介绍，在VSync信号到来时才会执行绘制，即performTraversals()方法。下面来瞅瞅这是如何实现的：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//ViewRootImpl.java</span></span><br><span class=\"line\"><span class=\"keyword\">void</span> <span class=\"title function_\">scheduleTraversals</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!mTraversalScheduled) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//此字段保证同时间多次更改只会刷新一次，例如TextView连续两次setText(),也只会走一次绘制流程</span></span><br><span class=\"line\">        mTraversalScheduled = <span class=\"literal\">true</span>;</span><br><span class=\"line\">        <span class=\"comment\">//添加同步屏障，屏蔽同步消息，保证VSync到来立即执行绘制</span></span><br><span class=\"line\">        mTraversalBarrier = mHandler.getLooper().getQueue().postSyncBarrier();</span><br><span class=\"line\">        <span class=\"comment\">//mTraversalRunnable是TraversalRunnable实例，最终走到run()，也即doTraversal();</span></span><br><span class=\"line\">        mChoreographer.postCallback(</span><br><span class=\"line\">                Choreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, <span class=\"literal\">null</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!mUnbufferedInputDispatch) &#123;</span><br><span class=\"line\">            scheduleConsumeBatchedInput();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        notifyRendererOfFramePending();</span><br><span class=\"line\">        pokeDrawLockIfNeeded();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">final</span> <span class=\"keyword\">class</span> <span class=\"title class_\">TraversalRunnable</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Runnable</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        doTraversal();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">final</span> <span class=\"type\">TraversalRunnable</span> <span class=\"variable\">mTraversalRunnable</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">TraversalRunnable</span>();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">void</span> <span class=\"title function_\">doTraversal</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mTraversalScheduled) &#123;</span><br><span class=\"line\">        mTraversalScheduled = <span class=\"literal\">false</span>;</span><br><span class=\"line\">        <span class=\"comment\">//移除同步屏障</span></span><br><span class=\"line\">        mHandler.getLooper().getQueue().removeSyncBarrier(mTraversalBarrier);</span><br><span class=\"line\">        ...</span><br><span class=\"line\">        <span class=\"comment\">//开始三大绘制流程</span></span><br><span class=\"line\">        performTraversals();</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>主要有以下逻辑：</p>\n<ol>\n<li>首先使用mTraversalScheduled字段保证同时间多次更改只会刷新一次，例如TextView连续两次setText()，也只会走一次绘制流程。</li>\n<li>然后把当前线程的<a href=\"https://cloud.tencent.com/product/message-queue-catalog?from_column=20065&from=20065\">消息队列</a>Queue添加了<strong>同步屏障</strong>，这样就屏蔽了正常的同步消息，保证VSync到来后立即执行绘制，而不是要等前面的同步消息。后面会具体分析同步屏障和异步消息的代码逻辑。</li>\n<li>调用了mChoreographer.postCallback()方法，发送一个会在下一帧执行的回调，即<strong>在下一个VSync到来时会执行TraversalRunnable–&gt;doTraversal()—&gt;performTraversals()–&gt;绘制流程</strong>。</li>\n</ol>\n<p>接下来，就是分析的重点——Choreographer。我们先看它的实例mChoreographer，是在ViewRootImpl的构造方法内使用Choreographer.getInstance()创建：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">Choreographer mChoreographer;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//ViewRootImpl实例是在添加window时创建</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"title function_\">ViewRootImpl</span><span class=\"params\">(Context context, Display display)</span> &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    mChoreographer = Choreographer.getInstance();</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们先来看看Choreographer.getInstance()：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Choreographer <span class=\"title function_\">getInstance</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> sThreadInstance.get();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> ThreadLocal&lt;Choreographer&gt; sThreadInstance =</span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">ThreadLocal</span>&lt;Choreographer&gt;() &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">protected</span> Choreographer <span class=\"title function_\">initialValue</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">Looper</span> <span class=\"variable\">looper</span> <span class=\"operator\">=</span> Looper.myLooper();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (looper == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//当前线程要有looper，Choreographer实例需要传入</span></span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">IllegalStateException</span>(<span class=\"string\">&quot;The current thread must have a looper!&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"type\">Choreographer</span> <span class=\"variable\">choreographer</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Choreographer</span>(looper, VSYNC_SOURCE_APP);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (looper == Looper.getMainLooper()) &#123;</span><br><span class=\"line\">            mMainInstance = choreographer;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> choreographer;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>看到这里 如你对Handler机制中looper比较熟悉的话，应该知道 Choreographer和Looper一样 是线程单例的。且当前线程要有looper，Choreographer实例需要传入。接着看看Choreographer构造方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"title function_\">Choreographer</span><span class=\"params\">(Looper looper, <span class=\"type\">int</span> vsyncSource)</span> &#123;</span><br><span class=\"line\">    mLooper = looper;</span><br><span class=\"line\">    <span class=\"comment\">//使用当前线程looper创建 mHandler</span></span><br><span class=\"line\">    mHandler = <span class=\"keyword\">new</span> <span class=\"title class_\">FrameHandler</span>(looper);</span><br><span class=\"line\">    <span class=\"comment\">//USE_VSYNC 4.1以上默认是true，表示 具备接受VSync的能力，这个接受能力就是FrameDisplayEventReceiver</span></span><br><span class=\"line\">    mDisplayEventReceiver = USE_VSYNC</span><br><span class=\"line\">            ? <span class=\"keyword\">new</span> <span class=\"title class_\">FrameDisplayEventReceiver</span>(looper, vsyncSource)</span><br><span class=\"line\">            : <span class=\"literal\">null</span>;</span><br><span class=\"line\">    mLastFrameTimeNanos = Long.MIN_VALUE;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 计算一帧的时间，Android手机屏幕是60Hz的刷新频率，就是16ms</span></span><br><span class=\"line\">    mFrameIntervalNanos = (<span class=\"type\">long</span>)(<span class=\"number\">1000000000</span> / getRefreshRate());</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 创建一个链表类型CallbackQueue的数组，大小为5，</span></span><br><span class=\"line\">    <span class=\"comment\">//也就是数组中有五个链表，每个链表存相同类型的任务：输入、动画、遍历绘制等任务（CALLBACK_INPUT、CALLBACK_ANIMATION、CALLBACK_TRAVERSAL）</span></span><br><span class=\"line\">    mCallbackQueues = <span class=\"keyword\">new</span> <span class=\"title class_\">CallbackQueue</span>[CALLBACK_LAST + <span class=\"number\">1</span>];</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt;= CALLBACK_LAST; i++) &#123;</span><br><span class=\"line\">        mCallbackQueues[i] = <span class=\"keyword\">new</span> <span class=\"title class_\">CallbackQueue</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// b/68769804: For low FPS experiments.</span></span><br><span class=\"line\">    setFPSDivisor(SystemProperties.getInt(ThreadedRenderer.DEBUG_FPS_DIVISOR, <span class=\"number\">1</span>));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>代码中都有注释，创建了一个mHandler、VSync事件接收器mDisplayEventReceiver、任务链表数组mCallbackQueues。FrameHandler、FrameDisplayEventReceiver、CallbackQueue后面会一一说明。</p>\n<h5 id=\"4-2-2-安排任务—postCallback\"><a href=\"#4-2-2-安排任务—postCallback\" class=\"headerlink\" title=\"4.2.2 安排任务—postCallback\"></a><strong>4.2.2 安排任务—postCallback</strong></h5><p>回头看mChoreographer.postCallback(Choreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, null)方法，注意到第一个参数是CALLBACK_TRAVERSAL，表示回调任务的类型，共有以下5种类型：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//输入事件，首先执行</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">CALLBACK_INPUT</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"comment\">//动画，第二执行</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">CALLBACK_ANIMATION</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"comment\">//插入更新的动画，第三执行</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">CALLBACK_INSETS_ANIMATION</span> <span class=\"operator\">=</span> <span class=\"number\">2</span>;</span><br><span class=\"line\"><span class=\"comment\">//绘制，第四执行</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">CALLBACK_TRAVERSAL</span> <span class=\"operator\">=</span> <span class=\"number\">3</span>;</span><br><span class=\"line\"><span class=\"comment\">//提交，最后执行，</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">CALLBACK_COMMIT</span> <span class=\"operator\">=</span> <span class=\"number\">4</span>;</span><br></pre></td></tr></table></figure>\n\n<p>五种类型任务对应存入对应的CallbackQueue中，每当收到 VSYNC 信号时，Choreographer 将首先处理 INPUT 类型的任务，然后是 ANIMATION 类型，最后才是 TRAVERSAL 类型。</p>\n<p>postCallback()内部调用postCallbackDelayed()，接着又调用postCallbackDelayedInternal()，来瞅瞅：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">postCallbackDelayedInternal</span><span class=\"params\">(<span class=\"type\">int</span> callbackType,</span></span><br><span class=\"line\"><span class=\"params\">        Object action, Object token, <span class=\"type\">long</span> delayMillis)</span> &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (mLock) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 当前时间</span></span><br><span class=\"line\">        <span class=\"keyword\">final</span> <span class=\"type\">long</span> <span class=\"variable\">now</span> <span class=\"operator\">=</span> SystemClock.uptimeMillis();</span><br><span class=\"line\">        <span class=\"comment\">// 加上延迟时间</span></span><br><span class=\"line\">        <span class=\"keyword\">final</span> <span class=\"type\">long</span> <span class=\"variable\">dueTime</span> <span class=\"operator\">=</span> now + delayMillis;</span><br><span class=\"line\">        <span class=\"comment\">//取对应类型的CallbackQueue添加任务</span></span><br><span class=\"line\">        mCallbackQueues[callbackType].addCallbackLocked(dueTime, action, token);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (dueTime &lt;= now) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//立即执行</span></span><br><span class=\"line\">            scheduleFrameLocked(now);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">//延迟运行，最终也会走到scheduleFrameLocked()</span></span><br><span class=\"line\">            <span class=\"type\">Message</span> <span class=\"variable\">msg</span> <span class=\"operator\">=</span> mHandler.obtainMessage(MSG_DO_SCHEDULE_CALLBACK, action);</span><br><span class=\"line\">            msg.arg1 = callbackType;</span><br><span class=\"line\">            msg.setAsynchronous(<span class=\"literal\">true</span>);</span><br><span class=\"line\">            mHandler.sendMessageAtTime(msg, dueTime);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>首先取对应类型的CallbackQueue添加任务，action就是mTraversalRunnable，token是null。<strong>CallbackQueue的addCallbackLocked()就是把 dueTime、action、token组装成CallbackRecord后 存入CallbackQueue的下一个节点</strong>，具体代码比较简单，不再跟进。</p>\n<p>然后注意到如果没有延迟会执行scheduleFrameLocked()方法，有延迟就会使用 mHandler发送MSG_DO_SCHEDULE_CALLBACK消息，并且注意到 <strong>使用msg.setAsynchronous(true)把消息设置成异步</strong>，这是因为前面设置了同步屏障，只有异步消息才会执行。我们看下mHandler的对这个消息的处理：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">class</span> <span class=\"title class_\">FrameHandler</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">Handler</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">FrameHandler</span><span class=\"params\">(Looper looper)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">super</span>(looper);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">handleMessage</span><span class=\"params\">(Message msg)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">switch</span> (msg.what) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> MSG_DO_FRAME:</span><br><span class=\"line\">                <span class=\"comment\">// 执行doFrame,即绘制过程</span></span><br><span class=\"line\">                doFrame(System.nanoTime(), <span class=\"number\">0</span>);</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> MSG_DO_SCHEDULE_VSYNC:</span><br><span class=\"line\">                <span class=\"comment\">//申请VSYNC信号，例如当前需要绘制任务时</span></span><br><span class=\"line\">                doScheduleVsync();</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> MSG_DO_SCHEDULE_CALLBACK:</span><br><span class=\"line\">                <span class=\"comment\">//需要延迟的任务，最终还是执行上述两个事件</span></span><br><span class=\"line\">                doScheduleCallback(msg.arg1);</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>直接使用doScheduleCallback方法，看看：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> <span class=\"title function_\">doScheduleCallback</span><span class=\"params\">(<span class=\"type\">int</span> callbackType)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (mLock) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!mFrameScheduled) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">final</span> <span class=\"type\">long</span> <span class=\"variable\">now</span> <span class=\"operator\">=</span> SystemClock.uptimeMillis();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (mCallbackQueues[callbackType].hasDueCallbacksLocked(now)) &#123;</span><br><span class=\"line\">                scheduleFrameLocked(now);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>发现也是走到这里，即延迟运行最终也会走到scheduleFrameLocked()，跟进看看：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">scheduleFrameLocked</span><span class=\"params\">(<span class=\"type\">long</span> now)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!mFrameScheduled) &#123;</span><br><span class=\"line\">        mFrameScheduled = <span class=\"literal\">true</span>;</span><br><span class=\"line\">        <span class=\"comment\">//开启了VSYNC</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (USE_VSYNC) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (DEBUG_FRAMES) &#123;</span><br><span class=\"line\">                Log.d(TAG, <span class=\"string\">&quot;Scheduling next frame on vsync.&quot;</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">//当前执行的线程，是否是mLooper所在线程</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (isRunningOnLooperThreadLocked()) &#123;</span><br><span class=\"line\">                <span class=\"comment\">//申请 VSYNC 信号</span></span><br><span class=\"line\">                scheduleVsyncLocked();</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 若不在，就用mHandler发送消息到原线程，最后还是调用scheduleVsyncLocked方法</span></span><br><span class=\"line\">                <span class=\"type\">Message</span> <span class=\"variable\">msg</span> <span class=\"operator\">=</span> mHandler.obtainMessage(MSG_DO_SCHEDULE_VSYNC);</span><br><span class=\"line\">                msg.setAsynchronous(<span class=\"literal\">true</span>);<span class=\"comment\">//异步</span></span><br><span class=\"line\">                mHandler.sendMessageAtFrontOfQueue(msg);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 如果未开启VSYNC则直接doFrame方法（4.1后默认开启）</span></span><br><span class=\"line\">            <span class=\"keyword\">final</span> <span class=\"type\">long</span> <span class=\"variable\">nextFrameTime</span> <span class=\"operator\">=</span> Math.max(</span><br><span class=\"line\">                    mLastFrameTimeNanos / TimeUtils.NANOS_PER_MS + sFrameDelay, now);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (DEBUG_FRAMES) &#123;</span><br><span class=\"line\">                Log.d(TAG, <span class=\"string\">&quot;Scheduling next frame in &quot;</span> + (nextFrameTime - now) + <span class=\"string\">&quot; ms.&quot;</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"type\">Message</span> <span class=\"variable\">msg</span> <span class=\"operator\">=</span> mHandler.obtainMessage(MSG_DO_FRAME);</span><br><span class=\"line\">            msg.setAsynchronous(<span class=\"literal\">true</span>);<span class=\"comment\">//异步</span></span><br><span class=\"line\">            mHandler.sendMessageAtTime(msg, nextFrameTime);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>如果系统未开启 VSYNC 机制，此时直接发送 MSG_DO_FRAME 消息到 FrameHandler。注意查看上面贴出的 FrameHandler 代码，此时直接执行 doFrame 方法。</li>\n<li>Android 4.1 之后系统默认开启 VSYNC，在 Choreographer 的构造方法会创建一个 FrameDisplayEventReceiver，scheduleVsyncLocked 方法将会通过它申请 VSYNC 信号。</li>\n<li>isRunningOnLooperThreadLocked 方法，其内部根据 Looper 判断是否在原线程，否则发送消息到 FrameHandler。最终还是会调用 scheduleVsyncLocked 方法申请 VSYNC 信号。</li>\n</ol>\n<p>到这里，<strong>FrameHandler的作用很明显里了：发送异步消息（因为前面设置了同步屏障）。有延迟的任务发延迟消息、不在原线程的发到原线程、没开启VSYNC的直接走 doFrame 方法取执行绘制。</strong></p>\n<h5 id=\"4-2-3-申请和接受VSync\"><a href=\"#4-2-3-申请和接受VSync\" class=\"headerlink\" title=\"4.2.3 申请和接受VSync\"></a><strong>4.2.3 申请和接受VSync</strong></h5><p>好了， 接着就看 scheduleVsyncLocked 方法是如何申请 VSYNC 信号的。猜测肯定申请 VSYNC 信号后，信号到来时也是走doFrame() 方法，doFrame()后面再看。先跟进scheduleVsyncLocked():</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">scheduleVsyncLocked</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    mDisplayEventReceiver.scheduleVsync();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>很简单，调用mDisplayEventReceiver的scheduleVsync()方法，mDisplayEventReceiver是Choreographer构造方法中创建，是FrameDisplayEventReceiver 的实例。FrameDisplayEventReceiver是 DisplayEventReceiver 的子类，DisplayEventReceiver 是一个 abstract class：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"title function_\">DisplayEventReceiver</span><span class=\"params\">(Looper looper, <span class=\"type\">int</span> vsyncSource)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (looper == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">IllegalArgumentException</span>(<span class=\"string\">&quot;looper must not be null&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    mMessageQueue = looper.getQueue();</span><br><span class=\"line\">    <span class=\"comment\">// 注册VSYNC信号监听者</span></span><br><span class=\"line\">    mReceiverPtr = nativeInit(<span class=\"keyword\">new</span> <span class=\"title class_\">WeakReference</span>&lt;DisplayEventReceiver&gt;(<span class=\"built_in\">this</span>), mMessageQueue,</span><br><span class=\"line\">            vsyncSource);</span><br><span class=\"line\"></span><br><span class=\"line\">    mCloseGuard.open(<span class=\"string\">&quot;dispose&quot;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在 DisplayEventReceiver 的构造方法会通过 JNI 创建一个 IDisplayEventConnection 的 VSYNC 的监听者。</p>\n<p>FrameDisplayEventReceiver的scheduleVsync()就是在 DisplayEventReceiver中：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">scheduleVsync</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mReceiverPtr == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        Log.w(TAG, <span class=\"string\">&quot;Attempted to schedule a vertical sync pulse but the display event &quot;</span></span><br><span class=\"line\">                + <span class=\"string\">&quot;receiver has already been disposed.&quot;</span>);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 申请VSYNC中断信号，会回调onVsync方法</span></span><br><span class=\"line\">        nativeScheduleVsync(mReceiverPtr);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>那么scheduleVsync()就是使用native方法nativeScheduleVsync()去申请VSYNC信号。这个native方法就看不了了，只需要知道<strong>VSYNC信号的接受回调是onVsync()</strong>，我们直接看onVsync()：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 接收到VSync脉冲时 回调</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> timestampNanos VSync脉冲的时间戳</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> physicalDisplayId Stable display ID that uniquely describes a (display, port) pair.</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> frame 帧号码，自增</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"meta\">@UnsupportedAppUsage</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">onVsync</span><span class=\"params\">(<span class=\"type\">long</span> timestampNanos, <span class=\"type\">long</span> physicalDisplayId, <span class=\"type\">int</span> frame)</span> &#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>具体实现是在FrameDisplayEventReceiver中：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">class</span> <span class=\"title class_\">FrameDisplayEventReceiver</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">DisplayEventReceiver</span></span><br><span class=\"line\">        <span class=\"keyword\">implements</span> <span class=\"title class_\">Runnable</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">boolean</span> mHavePendingVsync;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">long</span> mTimestampNanos;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">int</span> mFrame;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">FrameDisplayEventReceiver</span><span class=\"params\">(Looper looper, <span class=\"type\">int</span> vsyncSource)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">super</span>(looper, vsyncSource);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">onVsync</span><span class=\"params\">(<span class=\"type\">long</span> timestampNanos, <span class=\"type\">long</span> physicalDisplayId, <span class=\"type\">int</span> frame)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// Post the vsync event to the Handler.</span></span><br><span class=\"line\">        <span class=\"comment\">// The idea is to prevent incoming vsync events from completely starving</span></span><br><span class=\"line\">        <span class=\"comment\">// the message queue.  If there are no messages in the queue with timestamps</span></span><br><span class=\"line\">        <span class=\"comment\">// earlier than the frame time, then the vsync event will be processed immediately.</span></span><br><span class=\"line\">        <span class=\"comment\">// Otherwise, messages that predate the vsync event will be handled first.</span></span><br><span class=\"line\">        <span class=\"type\">long</span> <span class=\"variable\">now</span> <span class=\"operator\">=</span> System.nanoTime();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (timestampNanos &gt; now) &#123;</span><br><span class=\"line\">            Log.w(TAG, <span class=\"string\">&quot;Frame time is &quot;</span> + ((timestampNanos - now) * <span class=\"number\">0.000001f</span>)</span><br><span class=\"line\">                    + <span class=\"string\">&quot; ms in the future!  Check that graphics HAL is generating vsync &quot;</span></span><br><span class=\"line\">                    + <span class=\"string\">&quot;timestamps using the correct timebase.&quot;</span>);</span><br><span class=\"line\">            timestampNanos = now;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mHavePendingVsync) &#123;</span><br><span class=\"line\">            Log.w(TAG, <span class=\"string\">&quot;Already have a pending vsync event.  There should only be &quot;</span></span><br><span class=\"line\">                    + <span class=\"string\">&quot;one at a time.&quot;</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            mHavePendingVsync = <span class=\"literal\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        mTimestampNanos = timestampNanos;</span><br><span class=\"line\">        mFrame = frame;</span><br><span class=\"line\">        <span class=\"comment\">//将本身作为runnable传入msg， 发消息后 会走run()，即doFrame()，也是异步消息</span></span><br><span class=\"line\">        <span class=\"type\">Message</span> <span class=\"variable\">msg</span> <span class=\"operator\">=</span> Message.obtain(mHandler, <span class=\"built_in\">this</span>);</span><br><span class=\"line\">        msg.setAsynchronous(<span class=\"literal\">true</span>);</span><br><span class=\"line\">        mHandler.sendMessageAtTime(msg, timestampNanos / TimeUtils.NANOS_PER_MS);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        mHavePendingVsync = <span class=\"literal\">false</span>;</span><br><span class=\"line\">        doFrame(mTimestampNanos, mFrame);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>onVsync()中，将接收器本身作为runnable传入异步消息msg，并使用mHandler发送msg，最终执行的就是doFrame()方法了。</p>\n<p>注意一点是，<strong>onVsync()方法中只是使用mHandler发送消息到MessageQueue中，不一定是立刻执行，如何MessageQueue中前面有较为耗时的操作，那么就要等完成，才会执行本次的doFrame()</strong>。</p>\n<h5 id=\"4-2-4-doFrame\"><a href=\"#4-2-4-doFrame\" class=\"headerlink\" title=\"4.2.4 doFrame\"></a><strong>4.2.4 doFrame</strong></h5><p>和上面猜测一样，申请VSync信号接收到后确实是走 doFrame()方法，那么就来看看Choreographer的doFrame()：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> <span class=\"title function_\">doFrame</span><span class=\"params\">(<span class=\"type\">long</span> frameTimeNanos, <span class=\"type\">int</span> frame)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"type\">long</span> startNanos;</span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (mLock) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!mFrameScheduled) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span>; <span class=\"comment\">// no work to do</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        ...</span><br><span class=\"line\">        <span class=\"comment\">// 预期执行时间</span></span><br><span class=\"line\">        <span class=\"type\">long</span> <span class=\"variable\">intendedFrameTimeNanos</span> <span class=\"operator\">=</span> frameTimeNanos;</span><br><span class=\"line\">        startNanos = System.nanoTime();</span><br><span class=\"line\">        <span class=\"comment\">// 超时时间是否超过一帧的时间（这是因为MessageQueue虽然添加了同步屏障，但是还是有正在执行的同步任务，导致doFrame延迟执行了）</span></span><br><span class=\"line\">        <span class=\"keyword\">final</span> <span class=\"type\">long</span> <span class=\"variable\">jitterNanos</span> <span class=\"operator\">=</span> startNanos - frameTimeNanos;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (jitterNanos &gt;= mFrameIntervalNanos) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 计算掉帧数</span></span><br><span class=\"line\">            <span class=\"keyword\">final</span> <span class=\"type\">long</span> <span class=\"variable\">skippedFrames</span> <span class=\"operator\">=</span> jitterNanos / mFrameIntervalNanos;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (skippedFrames &gt;= SKIPPED_FRAME_WARNING_LIMIT) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 掉帧超过30帧打印Log提示</span></span><br><span class=\"line\">                Log.i(TAG, <span class=\"string\">&quot;Skipped &quot;</span> + skippedFrames + <span class=\"string\">&quot; frames!  &quot;</span></span><br><span class=\"line\">                        + <span class=\"string\">&quot;The application may be doing too much work on its main thread.&quot;</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">final</span> <span class=\"type\">long</span> <span class=\"variable\">lastFrameOffset</span> <span class=\"operator\">=</span> jitterNanos % mFrameIntervalNanos;</span><br><span class=\"line\">            ...</span><br><span class=\"line\">            frameTimeNanos = startNanos - lastFrameOffset;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        ...</span><br><span class=\"line\"></span><br><span class=\"line\">        mFrameInfo.setVsync(intendedFrameTimeNanos, frameTimeNanos);</span><br><span class=\"line\">        <span class=\"comment\">// Frame标志位恢复</span></span><br><span class=\"line\">        mFrameScheduled = <span class=\"literal\">false</span>;</span><br><span class=\"line\">        <span class=\"comment\">// 记录最后一帧时间</span></span><br><span class=\"line\">        mLastFrameTimeNanos = frameTimeNanos;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 按类型顺序 执行任务</span></span><br><span class=\"line\">        Trace.traceBegin(Trace.TRACE_TAG_VIEW, <span class=\"string\">&quot;Choreographer#doFrame&quot;</span>);</span><br><span class=\"line\">        AnimationUtils.lockAnimationClock(frameTimeNanos / TimeUtils.NANOS_PER_MS);</span><br><span class=\"line\"></span><br><span class=\"line\">        mFrameInfo.markInputHandlingStart();</span><br><span class=\"line\">        doCallbacks(Choreographer.CALLBACK_INPUT, frameTimeNanos);</span><br><span class=\"line\"></span><br><span class=\"line\">        mFrameInfo.markAnimationsStart();</span><br><span class=\"line\">        doCallbacks(Choreographer.CALLBACK_ANIMATION, frameTimeNanos);</span><br><span class=\"line\">        doCallbacks(Choreographer.CALLBACK_INSETS_ANIMATION, frameTimeNanos);</span><br><span class=\"line\"></span><br><span class=\"line\">        mFrameInfo.markPerformTraversalsStart();</span><br><span class=\"line\">        doCallbacks(Choreographer.CALLBACK_TRAVERSAL, frameTimeNanos);</span><br><span class=\"line\"></span><br><span class=\"line\">        doCallbacks(Choreographer.CALLBACK_COMMIT, frameTimeNanos);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        AnimationUtils.unlockAnimationClock();</span><br><span class=\"line\">        Trace.traceEnd(Trace.TRACE_TAG_VIEW);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面都有注释了很好理解，接着看任务的具体执行doCallbacks 方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> <span class=\"title function_\">doCallbacks</span><span class=\"params\">(<span class=\"type\">int</span> callbackType, <span class=\"type\">long</span> frameTimeNanos)</span> &#123;</span><br><span class=\"line\">    CallbackRecord callbacks;</span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (mLock) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">final</span> <span class=\"type\">long</span> <span class=\"variable\">now</span> <span class=\"operator\">=</span> System.nanoTime();</span><br><span class=\"line\">        <span class=\"comment\">// 根据指定的类型CallbackkQueue中查找到达执行时间的CallbackRecord</span></span><br><span class=\"line\">        callbacks = mCallbackQueues[callbackType].extractDueCallbacksLocked(now / TimeUtils.NANOS_PER_MS);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (callbacks == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        mCallbacksRunning = <span class=\"literal\">true</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//提交任务类型</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (callbackType == Choreographer.CALLBACK_COMMIT) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">final</span> <span class=\"type\">long</span> <span class=\"variable\">jitterNanos</span> <span class=\"operator\">=</span> now - frameTimeNanos;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (jitterNanos &gt;= <span class=\"number\">2</span> * mFrameIntervalNanos) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">final</span> <span class=\"type\">long</span> <span class=\"variable\">lastFrameOffset</span> <span class=\"operator\">=</span> jitterNanos % mFrameIntervalNanos</span><br><span class=\"line\">                        + mFrameIntervalNanos;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (DEBUG_JANK) &#123;</span><br><span class=\"line\">                    Log.d(TAG, <span class=\"string\">&quot;Commit callback delayed by &quot;</span> + (jitterNanos * <span class=\"number\">0.000001f</span>)</span><br><span class=\"line\">                            + <span class=\"string\">&quot; ms which is more than twice the frame interval of &quot;</span></span><br><span class=\"line\">                            + (mFrameIntervalNanos * <span class=\"number\">0.000001f</span>) + <span class=\"string\">&quot; ms!  &quot;</span></span><br><span class=\"line\">                            + <span class=\"string\">&quot;Setting frame time to &quot;</span> + (lastFrameOffset * <span class=\"number\">0.000001f</span>)</span><br><span class=\"line\">                            + <span class=\"string\">&quot; ms in the past.&quot;</span>);</span><br><span class=\"line\">                    mDebugPrintNextFrameTimeDelta = <span class=\"literal\">true</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                frameTimeNanos = now - lastFrameOffset;</span><br><span class=\"line\">                mLastFrameTimeNanos = frameTimeNanos;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 迭代执行队列所有任务</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">CallbackRecord</span> <span class=\"variable\">c</span> <span class=\"operator\">=</span> callbacks; c != <span class=\"literal\">null</span>; c = c.next) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 回调CallbackRecord的run，其内部回调Callback的run</span></span><br><span class=\"line\">            c.run(frameTimeNanos);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span> (mLock) &#123;</span><br><span class=\"line\">            mCallbacksRunning = <span class=\"literal\">false</span>;</span><br><span class=\"line\">            <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">final</span> <span class=\"type\">CallbackRecord</span> <span class=\"variable\">next</span> <span class=\"operator\">=</span> callbacks.next;</span><br><span class=\"line\">                <span class=\"comment\">//回收CallbackRecord</span></span><br><span class=\"line\">                recycleCallbackLocked(callbacks);</span><br><span class=\"line\">                callbacks = next;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">while</span> (callbacks != <span class=\"literal\">null</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>主要内容就是取对应任务类型的队列，遍历队列执行所有任务，执行任务是 CallbackRecord的 run 方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">class</span> <span class=\"title class_\">CallbackRecord</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> CallbackRecord next;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">long</span> dueTime;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> Object action; <span class=\"comment\">// Runnable or FrameCallback</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Object token;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@UnsupportedAppUsage</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">(<span class=\"type\">long</span> frameTimeNanos)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (token == FRAME_CALLBACK_TOKEN) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 通过postFrameCallback 或 postFrameCallbackDelayed，会执行这里</span></span><br><span class=\"line\">            ((FrameCallback)action).doFrame(frameTimeNanos);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">//取出Runnable执行run()</span></span><br><span class=\"line\">            ((Runnable)action).run();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>前面看到mChoreographer.postCallback传的token是null，所以取出action，就是Runnable，执行run()，这里的action就是 ViewRootImpl 发起的绘制任务mTraversalRunnable了，那么<strong>这样整个逻辑就闭环了</strong>。</p>\n<p>那么 啥时候 token &#x3D;&#x3D; FRAME_CALLBACK_TOKEN 呢？答案是Choreographer的postFrameCallback()方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">postFrameCallback</span><span class=\"params\">(FrameCallback callback)</span> &#123;</span><br><span class=\"line\">    postFrameCallbackDelayed(callback, <span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">postFrameCallbackDelayed</span><span class=\"params\">(FrameCallback callback, <span class=\"type\">long</span> delayMillis)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (callback == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">IllegalArgumentException</span>(<span class=\"string\">&quot;callback must not be null&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//也是走到是postCallbackDelayedInternal，并且注意是CALLBACK_ANIMATION类型，</span></span><br><span class=\"line\">    <span class=\"comment\">//token是FRAME_CALLBACK_TOKEN，action就是FrameCallback</span></span><br><span class=\"line\">    postCallbackDelayedInternal(CALLBACK_ANIMATION,</span><br><span class=\"line\">            callback, FRAME_CALLBACK_TOKEN, delayMillis);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">FrameCallback</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">doFrame</span><span class=\"params\">(<span class=\"type\">long</span> frameTimeNanos)</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可以看到postFrameCallback()传入的是FrameCallback实例，接口FrameCallback只有一个doFrame()方法。并且也是走到postCallbackDelayedInternal，FrameCallback实例作为action传入，token则是FRAME_CALLBACK_TOKEN，并且任务是CALLBACK_ANIMATION类型。</p>\n<p><strong>Choreographer的postFrameCallback()通常用来计算丢帧情况</strong>，使用方式如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">      <span class=\"comment\">//Application.java</span></span><br><span class=\"line\">       <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">onCreate</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">           <span class=\"built_in\">super</span>.onCreate();</span><br><span class=\"line\">           <span class=\"comment\">//在Application中使用postFrameCallback</span></span><br><span class=\"line\">           Choreographer.getInstance().postFrameCallback(<span class=\"keyword\">new</span> <span class=\"title class_\">FPSFrameCallback</span>(System.nanoTime()));</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">FPSFrameCallback</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Choreographer</span>.FrameCallback &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">String</span> <span class=\"variable\">TAG</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;FPS_TEST&quot;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">long</span> <span class=\"variable\">mLastFrameTimeNanos</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">long</span> mFrameIntervalNanos;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">FPSFrameCallback</span><span class=\"params\">(<span class=\"type\">long</span> lastFrameTimeNanos)</span> &#123;</span><br><span class=\"line\">        mLastFrameTimeNanos = lastFrameTimeNanos;</span><br><span class=\"line\">        mFrameIntervalNanos = (<span class=\"type\">long</span>)(<span class=\"number\">1000000000</span> / <span class=\"number\">60.0</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">doFrame</span><span class=\"params\">(<span class=\"type\">long</span> frameTimeNanos)</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//初始化时间</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mLastFrameTimeNanos == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            mLastFrameTimeNanos = frameTimeNanos;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> <span class=\"type\">long</span> <span class=\"variable\">jitterNanos</span> <span class=\"operator\">=</span> frameTimeNanos - mLastFrameTimeNanos;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (jitterNanos &gt;= mFrameIntervalNanos) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">final</span> <span class=\"type\">long</span> <span class=\"variable\">skippedFrames</span> <span class=\"operator\">=</span> jitterNanos / mFrameIntervalNanos;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(skippedFrames&gt;<span class=\"number\">30</span>)&#123;</span><br><span class=\"line\">                <span class=\"comment\">//丢帧30以上打印日志</span></span><br><span class=\"line\">                Log.i(TAG, <span class=\"string\">&quot;Skipped &quot;</span> + skippedFrames + <span class=\"string\">&quot; frames!  &quot;</span></span><br><span class=\"line\">                        + <span class=\"string\">&quot;The application may be doing too much work on its main thread.&quot;</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        mLastFrameTimeNanos=frameTimeNanos;</span><br><span class=\"line\">        <span class=\"comment\">//注册下一帧回调</span></span><br><span class=\"line\">        Choreographer.getInstance().postFrameCallback(<span class=\"built_in\">this</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"4-2-5-小结\"><a href=\"#4-2-5-小结\" class=\"headerlink\" title=\"4.2.5 小结\"></a><strong>4.2.5 小结</strong></h5><p>使用Choreographer的postCallback()、postFrameCallback() 作用理解：发送任务 存队列中，监听VSync信号，当前VSync到来时 会使用mHandler发送异步message，这个message的Runnable就是队列中的所有任务。</p>\n<p>好了，Choreographer整个代码逻辑都讲完了，引用《Android 之 Choreographer 详细分析》的流程图：</p>\n<p>原文流程图为：<a href=\"https://i-blog.csdnimg.cn/blog_migrate/5ff22e98afde4ff780f8a291d1081619.png\">Android 之 Choreographer</a>，但并不是很形象，引用另一张流程图：</p>\n<img src=\"https://cdn.julis.wang/blog/img/aab4273a0af898dcc9bb0fdcc0447b5a.png\">\n<h2 id=\"六、疑问解答\"><a href=\"#六、疑问解答\" class=\"headerlink\" title=\"六、疑问解答\"></a><strong>六、疑问解答</strong></h2><ol>\n<li><strong>丢帧</strong>(掉帧) ，是说 这一帧延迟显示 还是丢弃不再显示 ？ 答：延迟显示，因为缓存交换的时机只能等下一个VSync了。</li>\n<li>布局层级较多&#x2F;主线程耗时 是如何造成 丢帧的呢？ 答：布局层级较多&#x2F;主线程耗时 会影响CPU&#x2F;GPU的执行时间，大于16.6ms时只能等下一个VSync了。</li>\n<li>16.6ms刷新一次 是啥意思？是每16.6ms都走一次 measure&#x2F;layout&#x2F;draw ？ 答：屏幕的固定刷新频率是60Hz，即16.6ms。不是每16.6ms都走一次 measure&#x2F;layout&#x2F;draw，而是有绘制任务才会走，并且绘制时间间隔是取决于布局复杂度及主线程耗时。</li>\n<li>measure&#x2F;layout&#x2F;draw 走完，界面就立刻刷新了吗? 答：不是。measure&#x2F;layout&#x2F;draw 走完后 会在VSync到来时进行缓存交换和刷新。</li>\n<li>如果界面没动静止了，还会刷新吗？ 答：屏幕会固定没16.6ms刷新，但CPU&#x2F;GPU不走绘制流程。见下面的SysTrace图。</li>\n<li>可能你知道<strong>VSYNC</strong>，这个具体指啥？在屏幕刷新中如何工作的？ 答：当扫描完一个屏幕后，设备需要重新回到第一行以进入下一次的循环，此时会出现的vertical sync pulse（垂直同步脉冲）来保证双缓冲在最佳时间点才进行交换。并且Android4.1后 CPU&#x2F;GPU的绘制是在VSYNC到来时开始。</li>\n<li>可能你还听过屏幕刷新使用 <strong>双缓存</strong>、<strong>三缓存</strong>，这又是啥意思呢？ 答：双缓存是Back buffer、Frame buffer，用于解决画面撕裂。三缓存增加一个Back buffer，用于减少Jank。</li>\n<li>可能你还听过神秘的<strong>Choreographer</strong>，这又是干啥的？ 答：用于实现——“CPU&#x2F;GPU的绘制是在VSYNC到来时开始”。</li>\n</ol>\n","categories":[{"name":"技术文章","slug":"technology","api":"api/categories/technology.json"}],"tags":[{"name":"安卓","slug":"Android","api":"api/tags/Android.json"}],"api":"api/posts/2025/02/24/Android屏幕刷新机制.json"},{"title":"关于 pthread_key_t 导致的 Android Crash 的探索","slug":"关于-pthread-key-t-导致的-Android-Crash-的探索","date":"2024-11-10T08:11:00.000Z","updated":"2025-05-20T11:46:57.000Z","comments":true,"url":"2024/11/10/关于-pthread-key-t-导致的-Android-Crash-的探索/","excerpt":"<p>此前我负责的 SDK 已集成多个司内业务，一切运行正常，最近在接入到一些游戏项目中的时候发现存在比较多关于 <strong>libc.so</strong> 的 crash，在游戏中某个场景会使用SDK 进行逻辑处理，在部分手机会在短时间就直接 Crash，且集中在性能比较好的手机中。经过一番折腾，最后被定位在了一个跟 SDK 没有什么关系的地方：<code>pthread_key_t</code></p>\n<h2 id=\"Crash-表现\"><a href=\"#Crash-表现\" class=\"headerlink\" title=\"Crash 表现\"></a>Crash 表现</h2><p>在 Crash 上报平台中收到诸多的 Crash 上报，调用的形式多种多样，异常名都是<code>signal 6 (SIGABRT)</code></p>\n<p>但崩溃调用栈最终都停留在<br>  <code>/apex/com.android.runtime/lib64/bionic/libc.so pc (abort+168) </code></p>\n<p>以及中间都会经过：<br><code>/apex/com.android.runtime/lib64/bionic/libc.so (pthread_once+136)</code></p>\n<h3 id=\"难以复现的问题\"><a href=\"#难以复现的问题\" class=\"headerlink\" title=\"难以复现的问题\"></a>难以复现的问题</h3><p>由于我们的项目依赖于其他业务的SDK，最终的 SDK 打包合并在 Unity 的游戏中，我们不能直接使用游戏侧代码逻辑进行编译打包进行调试，这为问题的排查增大了一定的难度，只能在 Unity 的 demo 工程具体的表现为：</p>\n<p>1、部分性能好的手机（如小米14 pro）才会出现 Crash，而且在对应的游戏中必现，有些游戏又不会复现</p>\n<p>2、SDK里面同样的代码逻辑在测试 App 工程中完全不会复现</p>\n<p>3、SDK里面同样的代码逻辑在 Unity 测试游戏 demo 中也完全不会复现</p>\n<p>4、使用了业务方（游戏侧）的 Unity 的各种配置，依然没有复现</p>\n<p>5、崩溃栈中有涉及到 <strong>thread</strong> 相关的关键词，怀疑是线程相关问题，但在原生层开辟N个线程也没有复现</p>\n<p>6、其他各种尝试都没有复现：开辟大量内存、Unity 与 Android 调用方式调整……</p>\n<h2 id=\"解决线索与方案\"><a href=\"#解决线索与方案\" class=\"headerlink\" title=\"解决线索与方案\"></a>解决线索与方案</h2><p>一开始是怀疑业务方的环境与 SDK 运行环境有冲突，毕竟 SDK 已经在诸多业务中上线并正常运行了很久，不应该是 SDK 本身代码逻辑不对导致的才对。但没过多久，我们在另一个业务中也发现了这个问题，那说明并不是一个游戏环境导致。</p>\n<p>解决问题直接看对应的崩溃栈，其崩溃栈都是使用相关的组件导致的 Crash，询问了相关的开发大佬之后并没有得到解决办法，原因是我们使用的版本相对较老，经历了比较久的迭代，逻辑改掉了很多。二是有可能这个问题在新版本中已经修复掉了。于是我们进行了一大波改造升级，经过一段时间后，再次集成到业务方，原以为这个问题就此解决了，调用了一下创编 SDK 之后依然 crash，此时心拔凉拔凉……<br>但这时候比较能确定的是，这个 crash 跟依赖的SDK 没有直接关系，可能是由其他的环境问题什么。</p>\n<h3 id=\"问题线索-pthread-key\"><a href=\"#问题线索-pthread-key\" class=\"headerlink\" title=\"问题线索 pthread_key\"></a>问题线索 pthread_key</h3><p>在最开始的排查问题过程中一直在关注在环境的差异上面，经过一番折腾依然没有效果，方向错误了，于是再次回到 Crash 栈中来，在崩溃栈中都含有：<code>pthread_once</code>、<code>emutls_get_address</code>、<code>cxa_get_globals</code>、<code>emutls_init</code>相关的关键词，由于平时完全没有接触过这几个函数，对他们的了解比较少。但经过一番搜索之后，他们都有提到一个关键的术语：<strong>TLS (thread-local storage)</strong></p>\n<p>以及对几个函数调用的源码进行查看，发现这几个函数最终涉及到的都是 <code>pthread</code>  使用或者创建相关的</p>\n<p>其中在 cs.android的 <a href=\"https://cs.android.com/android/platform/superproject/main/+/main:external/compiler-rt/lib/builtins/emutls.c?q=emutls_init&ss=android/platform/superproject/main\">emutls.c</a> 源码里有：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">static</span> <span class=\"type\">void</span> <span class=\"title\">emutls_init</span><span class=\"params\">(<span class=\"type\">void</span>)</span> </span>&#123;</span><br><span class=\"line\"> <span class=\"keyword\">if</span> (<span class=\"built_in\">pthread_key_create</span>(&amp;emutls_pthread_key, emutls_key_destructor) != <span class=\"number\">0</span>)</span><br><span class=\"line\">\t<span class=\"built_in\">abort</span>();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里基本上可以和崩溃栈对应上了，正是这里执行的 <code>abort()</code>，那么原因是否是由 <code>pthread_key_create()</code>引起的呢？继续对 <code>pthread_key_create</code> 研究，原来在 Bionic 中，能够被开发者所使用的 Pthread Key 数量，是 <code>PTHREAD_KEYS_MAX</code> 宏所定义的 128 个。</p>\n<p>那我们遇到的问题是否也是同一个问题呢？得到答案最好的方式是验证，想办法做一个验证，用代码把系统能提供的 pthread_key 耗尽然后再使用我们创编SDK的功能，使用如下代码创建 <code>PTHREAD_KEYS_MAX</code>个 <code>pthread_key_t</code>，再直接使用创编 SDK，果不其然 Crash了，而且 crash 栈与上报的数据比较的一致（没有完全一致，毕竟一些场景还是会有点差异）。</p>\n<p>以下的代码会耗尽目前程序中的 key，只创建 pthread_key，而不释放掉</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">available_key</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; PTHREAD_KEYS_MAX; i++) &#123;</span><br><span class=\"line\">        <span class=\"type\">pthread_key_t</span> key;</span><br><span class=\"line\">        <span class=\"type\">int</span> result = pthread_key_create(&amp;key, detachDestructor);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (result == JNI_OK) &#123;</span><br><span class=\"line\">            __android_log_print(ANDROID_LOG_ERROR, <span class=\"string\">&quot;--julis&quot;</span>, <span class=\"string\">&quot;create thread key Success&quot;</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            __android_log_print(ANDROID_LOG_ERROR, <span class=\"string\">&quot;--julis&quot;</span>, <span class=\"string\">&quot;create thread key failed&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>从打印的日志里面看，在 Unity demo App 里面大概创建到 60 多的时候就创建失败了，也就是说Unity 本身可能就使用了很多 key，留给应用层开发的就只有几十个 key 了。</p>\n<p>虽然尝试是Crash了，但怎么能证明这个就是导致业务方 Crash 就是这个原因呢？以及怎么解释有的手机为什么会Crash，有的手机不会Crash呢？</p>\n<p>我们继续，从目前的推论来看，我们的创编SDK需要使用 <code>pthread_key_t</code>, 可能数量不够了，也就说创编SDK需要使用一定数量的key，那我们将刚才代码里面的<code> i &lt; PTHREAD_KEYS_MAX;</code> 进行调整，我们预留足够的 key 空间给创编SDK，<code>i &lt; target_number;</code> 于是在之前 crash 的手机和未 crash 的手机做了一次对比。</p>\n<p>以下是对部手机的测试结果，记录日志前面的数字就是代码里面的 <code>target_number</code></p>\n<img src=\"https://cdn.julis.wang/blog/img/j51nlsfd.jpg\">\n\n<p>从对比结果看，两部手机他们可以供应用层使用的 key 的数量是不同的，之前会 crash 的手机它可以使用的 key 明显是少于之前未 crash 手机的数量的，这也就能解释为什么有的手机为什么会 crash，有的手机不会 crash 了。以及，可以推测出来创编SDK使用了5个key左右。</p>\n<p>这里提一下在解决问题之初，我们发现 crash 的手机基本上都是市面上比较好的手机，且手机的 GPU 都集中于 Adreno 比较新的型号，一度误以为是相关底层 SDK 未进行兼容性适配导致。为什么性能更好的手机使用的 <code>pthread_key_t</code> 会更多？猜测可能是好的手机 Unity 运行相关的东西或者优化(这里的优化指的是游戏特效或者功能玩法)更多，所以消耗的资源就更多一点，当然这里只是个人猜测，具体原因还需要深入了解。</p>\n<p>还剩下一个问题：业务方的 App 为什么会Crash？于是将上面的 <code>available_key()</code>方法进行一次包装，并将其打包集成进游戏侧测试，从日志里面看到留给我们创编SDK使用的 key 只有3个了！而我们的 SDK 需要5个左右，问题原因基本就是这个了，那如何解决呢？</p>\n<h3 id=\"方案解决\"><a href=\"#方案解决\" class=\"headerlink\" title=\"方案解决\"></a>方案解决</h3><p>究其根本原因是 Android 系统的 <code>pthread_key_t</code> 的使用数量的限制，那么最直接的解决方式那就是降低对 <code>pthread_key_t</code> 的使用，但是由于我们依赖使用其他地方的 SDK，对其项目直接优化更改可能成本相对较高，直接修改源码解决的话一时半会儿无法解决。这里先对 <code>pthread_key_t</code> 数量限制相关的问题进行一些研究总结：</p>\n<p>在 Android 官方源码 <a href=\"https://android.googlesource.com/platform/bionic/+/master/libc/include/pthread.h\">pthread.h#pthread_key_create()</a> 里面有提到：</p>\n<blockquote>\n<p>There is a limit of <code>PTHREAD_KEYS_MAX</code> keys per process, but most callers should just use the C or C++ <code>thread_local</code> storage specifier anyway. When targeting new enough OS versions, the compiler will automatically use ELF TLS; when targeting old OS versions the emutls implementation will multiplex pthread keys behind the scenes, using one per library rather than one per thread-local variable. If you are implementing the runtime for a different language, you should consider similar implementation choices and avoid a direct one-to-one mapping from thread locals to pthread keys.<br>Returns 0 on success and returns an error number on failure.</p>\n</blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">int pthread_key_create(pthread_key_t* _Nonnull **key_ptr, void (* _Nullable **key_destructor)(void* _Nullable));</span><br></pre></td></tr></table></figure>\n\n<p>可以看到官方建议使用 <code>thread_local</code> 去实现 TLS，以及在新的系统版本中会使用 <code>ELF TLS</code> 对 <code>pthread_key_t</code> 将不直接依赖，<br>但条件相对比较高，参考官方更新：需要 miniSDK&gt;29 和NDK r26</p>\n<blockquote>\n<p>ELF TLS (Available for API level &gt;&#x3D; 29)<br>Android supports <a href=\"https://android.googlesource.com/platform/bionic/+/HEAD/docs/elf-tls.md\">ELF TLS</a> starting at API level 29. Since NDK r26, clang will automatically enable ELF TLS for <code>minSdkVersion 29</code> or higher. Otherwise, the existing emutls implementation (which uses <code>pthread_key_create()</code> behind the scenes) will continue to be used. This means that convenient C&#x2F;C++ thread-local syntax is available at any API level; at worst it will perform similarly to “roll your own” thread locals using <code>pthread_key_create()</code> but at best you’ll get the performance benefit of ELF TLS, and the NDK will take care of the details.</p>\n</blockquote>\n<p>最后我们的解决方式是依据上面 <code>pthread_key_create</code> 提到的</p>\n<blockquote>\n<p>There is a limit of <code>PTHREAD_KEYS_MAX</code> keys per process…..</p>\n</blockquote>\n<p>重点是：<strong>per process</strong>，每个进程有 <code>PTHREAD_KEYS_MAX</code>,这个<code>PTHREAD_KEYS_MAX</code>被定义在 <a href=\"https://android.googlesource.com/platform/bionic/+/refs/heads/main/libc/include/limits.h\">limits.h</a>  现在的 Android 基本上都是定义为128。那那我们将我们的SDK 使用的时候放在一个单独的进程不就ok了？事实是的，由于我们的SDK向业务只是提供一个 素材输入&#x3D;&gt;视频输出的功能，中间过程是一个黑盒，那么这个场景使用多进程是完全OK的，使用多进程还有一个好处就是能与游戏进程相独立，尽量减少两者之间的依赖。但多进程也带来了一些门槛，但这相比与改渲染 SDK 底层的源码来说是相对简单很多的，最终经过一番折腾我们将创编SDK得渲染放在了一个单独的进程，后试验运行在之前 Crash 过的游戏业务上一切正常。</p>\n<h3 id=\"pthread-key-检测工具\"><a href=\"#pthread-key-检测工具\" class=\"headerlink\" title=\"pthread_key 检测工具\"></a>pthread_key 检测工具</h3><p>为了以后接入其他游戏前不再发生类似的Crash问题，在接入业务前做一些技术评估，<code>pthread_key_t</code> 可用数量可能也需要成为一个考量指标，可用数的不同，可能需要不同的技术方案，我专门写了一个小工具，可方便查询业务项目目前使用了多少 pthread_key_t，能帮助项目排查当前问题是否是由于 <code>pthread_key_t</code> 占满导致的相关问题。</p>\n<p>不过我更想做一个能够检测项目里面有消耗过 pthread_key_t 的地方，将其 hook 住，打印出来对应的调用栈，这样就能方便业务排查。未来，随着 Android 业务的复杂化，这种问题可能会变成更多大型项目将会遇到。调研发现 Tencent 对外开源项目 <a href=\"https://github.com/Tencent/matrix?tab=readme-ov-file\">Tencent&#x2F;matrix</a> 已经有针对 pthread_key 做了相关的hook，业务侧也可以直接使用 matrix 进行检测，但其项目相对比较庞大，以及使用的方式较复杂。于是将其精简到一个小工具内，整体大小只有1MB 不到。</p>\n<p>源码地址：<a href=\"https://github.com/VomPom/PthreadKeyDetect\">PthreadKeyDetect</a></p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>本文主要记录了i创作SDK出现大佬了关于 <code>libc.so</code> 的 Crash，经过调查，问题被定位在 <code>pthread_key_t</code> 资源耗尽的问题上，并对其进行了相关研究，最后并解决了该问题的过程。</p>\n<h3 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h3><p><a href=\"https://android.googlesource.com/platform/bionic/+/HEAD/android-changes-for-ndk-developers.md#elf-tls-available-for-api-level-29\">Android linker changes for NDK developers</a></p>\n<p><a href=\"https://github.com/android/ndk/issues/789\">thread specific key leakage</a></p>\n<p><a href=\"https://juejin.cn/post/6987921143487283236\">pthread_key_create用法导致的崩溃修复</a></p>\n<p><a href=\"https://github.com/flutter/flutter/issues/127079\">Crash issue caused by pthread_key_create failed: 11 when integrating Flutter into our project #127079</a></p>\n<p><a href=\"https://muc.lists.netbsd.tech.userlevel.narkive.com/gFAi2gse/increase-pthread-keys-max\">Increase PTHREAD_KEYS_MAX</a></p>\n","cover":null,"images":["https://cdn.julis.wang/blog/img/j51nlsfd.jpg"],"content":"<p>此前我负责的 SDK 已集成多个司内业务，一切运行正常，最近在接入到一些游戏项目中的时候发现存在比较多关于 <strong>libc.so</strong> 的 crash，在游戏中某个场景会使用SDK 进行逻辑处理，在部分手机会在短时间就直接 Crash，且集中在性能比较好的手机中。经过一番折腾，最后被定位在了一个跟 SDK 没有什么关系的地方：<code>pthread_key_t</code></p>\n<h2 id=\"Crash-表现\"><a href=\"#Crash-表现\" class=\"headerlink\" title=\"Crash 表现\"></a>Crash 表现</h2><p>在 Crash 上报平台中收到诸多的 Crash 上报，调用的形式多种多样，异常名都是<code>signal 6 (SIGABRT)</code></p>\n<p>但崩溃调用栈最终都停留在<br>  <code>/apex/com.android.runtime/lib64/bionic/libc.so pc (abort+168) </code></p>\n<p>以及中间都会经过：<br><code>/apex/com.android.runtime/lib64/bionic/libc.so (pthread_once+136)</code></p>\n<h3 id=\"难以复现的问题\"><a href=\"#难以复现的问题\" class=\"headerlink\" title=\"难以复现的问题\"></a>难以复现的问题</h3><p>由于我们的项目依赖于其他业务的SDK，最终的 SDK 打包合并在 Unity 的游戏中，我们不能直接使用游戏侧代码逻辑进行编译打包进行调试，这为问题的排查增大了一定的难度，只能在 Unity 的 demo 工程具体的表现为：</p>\n<p>1、部分性能好的手机（如小米14 pro）才会出现 Crash，而且在对应的游戏中必现，有些游戏又不会复现</p>\n<p>2、SDK里面同样的代码逻辑在测试 App 工程中完全不会复现</p>\n<p>3、SDK里面同样的代码逻辑在 Unity 测试游戏 demo 中也完全不会复现</p>\n<p>4、使用了业务方（游戏侧）的 Unity 的各种配置，依然没有复现</p>\n<p>5、崩溃栈中有涉及到 <strong>thread</strong> 相关的关键词，怀疑是线程相关问题，但在原生层开辟N个线程也没有复现</p>\n<p>6、其他各种尝试都没有复现：开辟大量内存、Unity 与 Android 调用方式调整……</p>\n<h2 id=\"解决线索与方案\"><a href=\"#解决线索与方案\" class=\"headerlink\" title=\"解决线索与方案\"></a>解决线索与方案</h2><p>一开始是怀疑业务方的环境与 SDK 运行环境有冲突，毕竟 SDK 已经在诸多业务中上线并正常运行了很久，不应该是 SDK 本身代码逻辑不对导致的才对。但没过多久，我们在另一个业务中也发现了这个问题，那说明并不是一个游戏环境导致。</p>\n<p>解决问题直接看对应的崩溃栈，其崩溃栈都是使用相关的组件导致的 Crash，询问了相关的开发大佬之后并没有得到解决办法，原因是我们使用的版本相对较老，经历了比较久的迭代，逻辑改掉了很多。二是有可能这个问题在新版本中已经修复掉了。于是我们进行了一大波改造升级，经过一段时间后，再次集成到业务方，原以为这个问题就此解决了，调用了一下创编 SDK 之后依然 crash，此时心拔凉拔凉……<br>但这时候比较能确定的是，这个 crash 跟依赖的SDK 没有直接关系，可能是由其他的环境问题什么。</p>\n<h3 id=\"问题线索-pthread-key\"><a href=\"#问题线索-pthread-key\" class=\"headerlink\" title=\"问题线索 pthread_key\"></a>问题线索 pthread_key</h3><p>在最开始的排查问题过程中一直在关注在环境的差异上面，经过一番折腾依然没有效果，方向错误了，于是再次回到 Crash 栈中来，在崩溃栈中都含有：<code>pthread_once</code>、<code>emutls_get_address</code>、<code>cxa_get_globals</code>、<code>emutls_init</code>相关的关键词，由于平时完全没有接触过这几个函数，对他们的了解比较少。但经过一番搜索之后，他们都有提到一个关键的术语：<strong>TLS (thread-local storage)</strong></p>\n<p>以及对几个函数调用的源码进行查看，发现这几个函数最终涉及到的都是 <code>pthread</code>  使用或者创建相关的</p>\n<p>其中在 cs.android的 <a href=\"https://cs.android.com/android/platform/superproject/main/+/main:external/compiler-rt/lib/builtins/emutls.c?q=emutls_init&ss=android/platform/superproject/main\">emutls.c</a> 源码里有：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">static</span> <span class=\"type\">void</span> <span class=\"title\">emutls_init</span><span class=\"params\">(<span class=\"type\">void</span>)</span> </span>&#123;</span><br><span class=\"line\"> <span class=\"keyword\">if</span> (<span class=\"built_in\">pthread_key_create</span>(&amp;emutls_pthread_key, emutls_key_destructor) != <span class=\"number\">0</span>)</span><br><span class=\"line\">\t<span class=\"built_in\">abort</span>();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里基本上可以和崩溃栈对应上了，正是这里执行的 <code>abort()</code>，那么原因是否是由 <code>pthread_key_create()</code>引起的呢？继续对 <code>pthread_key_create</code> 研究，原来在 Bionic 中，能够被开发者所使用的 Pthread Key 数量，是 <code>PTHREAD_KEYS_MAX</code> 宏所定义的 128 个。</p>\n<p>那我们遇到的问题是否也是同一个问题呢？得到答案最好的方式是验证，想办法做一个验证，用代码把系统能提供的 pthread_key 耗尽然后再使用我们创编SDK的功能，使用如下代码创建 <code>PTHREAD_KEYS_MAX</code>个 <code>pthread_key_t</code>，再直接使用创编 SDK，果不其然 Crash了，而且 crash 栈与上报的数据比较的一致（没有完全一致，毕竟一些场景还是会有点差异）。</p>\n<p>以下的代码会耗尽目前程序中的 key，只创建 pthread_key，而不释放掉</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">available_key</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; PTHREAD_KEYS_MAX; i++) &#123;</span><br><span class=\"line\">        <span class=\"type\">pthread_key_t</span> key;</span><br><span class=\"line\">        <span class=\"type\">int</span> result = pthread_key_create(&amp;key, detachDestructor);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (result == JNI_OK) &#123;</span><br><span class=\"line\">            __android_log_print(ANDROID_LOG_ERROR, <span class=\"string\">&quot;--julis&quot;</span>, <span class=\"string\">&quot;create thread key Success&quot;</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            __android_log_print(ANDROID_LOG_ERROR, <span class=\"string\">&quot;--julis&quot;</span>, <span class=\"string\">&quot;create thread key failed&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>从打印的日志里面看，在 Unity demo App 里面大概创建到 60 多的时候就创建失败了，也就是说Unity 本身可能就使用了很多 key，留给应用层开发的就只有几十个 key 了。</p>\n<p>虽然尝试是Crash了，但怎么能证明这个就是导致业务方 Crash 就是这个原因呢？以及怎么解释有的手机为什么会Crash，有的手机不会Crash呢？</p>\n<p>我们继续，从目前的推论来看，我们的创编SDK需要使用 <code>pthread_key_t</code>, 可能数量不够了，也就说创编SDK需要使用一定数量的key，那我们将刚才代码里面的<code> i &lt; PTHREAD_KEYS_MAX;</code> 进行调整，我们预留足够的 key 空间给创编SDK，<code>i &lt; target_number;</code> 于是在之前 crash 的手机和未 crash 的手机做了一次对比。</p>\n<p>以下是对部手机的测试结果，记录日志前面的数字就是代码里面的 <code>target_number</code></p>\n<img src=\"https://cdn.julis.wang/blog/img/j51nlsfd.jpg\">\n\n<p>从对比结果看，两部手机他们可以供应用层使用的 key 的数量是不同的，之前会 crash 的手机它可以使用的 key 明显是少于之前未 crash 手机的数量的，这也就能解释为什么有的手机为什么会 crash，有的手机不会 crash 了。以及，可以推测出来创编SDK使用了5个key左右。</p>\n<p>这里提一下在解决问题之初，我们发现 crash 的手机基本上都是市面上比较好的手机，且手机的 GPU 都集中于 Adreno 比较新的型号，一度误以为是相关底层 SDK 未进行兼容性适配导致。为什么性能更好的手机使用的 <code>pthread_key_t</code> 会更多？猜测可能是好的手机 Unity 运行相关的东西或者优化(这里的优化指的是游戏特效或者功能玩法)更多，所以消耗的资源就更多一点，当然这里只是个人猜测，具体原因还需要深入了解。</p>\n<p>还剩下一个问题：业务方的 App 为什么会Crash？于是将上面的 <code>available_key()</code>方法进行一次包装，并将其打包集成进游戏侧测试，从日志里面看到留给我们创编SDK使用的 key 只有3个了！而我们的 SDK 需要5个左右，问题原因基本就是这个了，那如何解决呢？</p>\n<h3 id=\"方案解决\"><a href=\"#方案解决\" class=\"headerlink\" title=\"方案解决\"></a>方案解决</h3><p>究其根本原因是 Android 系统的 <code>pthread_key_t</code> 的使用数量的限制，那么最直接的解决方式那就是降低对 <code>pthread_key_t</code> 的使用，但是由于我们依赖使用其他地方的 SDK，对其项目直接优化更改可能成本相对较高，直接修改源码解决的话一时半会儿无法解决。这里先对 <code>pthread_key_t</code> 数量限制相关的问题进行一些研究总结：</p>\n<p>在 Android 官方源码 <a href=\"https://android.googlesource.com/platform/bionic/+/master/libc/include/pthread.h\">pthread.h#pthread_key_create()</a> 里面有提到：</p>\n<blockquote>\n<p>There is a limit of <code>PTHREAD_KEYS_MAX</code> keys per process, but most callers should just use the C or C++ <code>thread_local</code> storage specifier anyway. When targeting new enough OS versions, the compiler will automatically use ELF TLS; when targeting old OS versions the emutls implementation will multiplex pthread keys behind the scenes, using one per library rather than one per thread-local variable. If you are implementing the runtime for a different language, you should consider similar implementation choices and avoid a direct one-to-one mapping from thread locals to pthread keys.<br>Returns 0 on success and returns an error number on failure.</p>\n</blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">int pthread_key_create(pthread_key_t* _Nonnull **key_ptr, void (* _Nullable **key_destructor)(void* _Nullable));</span><br></pre></td></tr></table></figure>\n\n<p>可以看到官方建议使用 <code>thread_local</code> 去实现 TLS，以及在新的系统版本中会使用 <code>ELF TLS</code> 对 <code>pthread_key_t</code> 将不直接依赖，<br>但条件相对比较高，参考官方更新：需要 miniSDK&gt;29 和NDK r26</p>\n<blockquote>\n<p>ELF TLS (Available for API level &gt;&#x3D; 29)<br>Android supports <a href=\"https://android.googlesource.com/platform/bionic/+/HEAD/docs/elf-tls.md\">ELF TLS</a> starting at API level 29. Since NDK r26, clang will automatically enable ELF TLS for <code>minSdkVersion 29</code> or higher. Otherwise, the existing emutls implementation (which uses <code>pthread_key_create()</code> behind the scenes) will continue to be used. This means that convenient C&#x2F;C++ thread-local syntax is available at any API level; at worst it will perform similarly to “roll your own” thread locals using <code>pthread_key_create()</code> but at best you’ll get the performance benefit of ELF TLS, and the NDK will take care of the details.</p>\n</blockquote>\n<p>最后我们的解决方式是依据上面 <code>pthread_key_create</code> 提到的</p>\n<blockquote>\n<p>There is a limit of <code>PTHREAD_KEYS_MAX</code> keys per process…..</p>\n</blockquote>\n<p>重点是：<strong>per process</strong>，每个进程有 <code>PTHREAD_KEYS_MAX</code>,这个<code>PTHREAD_KEYS_MAX</code>被定义在 <a href=\"https://android.googlesource.com/platform/bionic/+/refs/heads/main/libc/include/limits.h\">limits.h</a>  现在的 Android 基本上都是定义为128。那那我们将我们的SDK 使用的时候放在一个单独的进程不就ok了？事实是的，由于我们的SDK向业务只是提供一个 素材输入&#x3D;&gt;视频输出的功能，中间过程是一个黑盒，那么这个场景使用多进程是完全OK的，使用多进程还有一个好处就是能与游戏进程相独立，尽量减少两者之间的依赖。但多进程也带来了一些门槛，但这相比与改渲染 SDK 底层的源码来说是相对简单很多的，最终经过一番折腾我们将创编SDK得渲染放在了一个单独的进程，后试验运行在之前 Crash 过的游戏业务上一切正常。</p>\n<h3 id=\"pthread-key-检测工具\"><a href=\"#pthread-key-检测工具\" class=\"headerlink\" title=\"pthread_key 检测工具\"></a>pthread_key 检测工具</h3><p>为了以后接入其他游戏前不再发生类似的Crash问题，在接入业务前做一些技术评估，<code>pthread_key_t</code> 可用数量可能也需要成为一个考量指标，可用数的不同，可能需要不同的技术方案，我专门写了一个小工具，可方便查询业务项目目前使用了多少 pthread_key_t，能帮助项目排查当前问题是否是由于 <code>pthread_key_t</code> 占满导致的相关问题。</p>\n<p>不过我更想做一个能够检测项目里面有消耗过 pthread_key_t 的地方，将其 hook 住，打印出来对应的调用栈，这样就能方便业务排查。未来，随着 Android 业务的复杂化，这种问题可能会变成更多大型项目将会遇到。调研发现 Tencent 对外开源项目 <a href=\"https://github.com/Tencent/matrix?tab=readme-ov-file\">Tencent&#x2F;matrix</a> 已经有针对 pthread_key 做了相关的hook，业务侧也可以直接使用 matrix 进行检测，但其项目相对比较庞大，以及使用的方式较复杂。于是将其精简到一个小工具内，整体大小只有1MB 不到。</p>\n<p>源码地址：<a href=\"https://github.com/VomPom/PthreadKeyDetect\">PthreadKeyDetect</a></p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>本文主要记录了i创作SDK出现大佬了关于 <code>libc.so</code> 的 Crash，经过调查，问题被定位在 <code>pthread_key_t</code> 资源耗尽的问题上，并对其进行了相关研究，最后并解决了该问题的过程。</p>\n<h3 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h3><p><a href=\"https://android.googlesource.com/platform/bionic/+/HEAD/android-changes-for-ndk-developers.md#elf-tls-available-for-api-level-29\">Android linker changes for NDK developers</a></p>\n<p><a href=\"https://github.com/android/ndk/issues/789\">thread specific key leakage</a></p>\n<p><a href=\"https://juejin.cn/post/6987921143487283236\">pthread_key_create用法导致的崩溃修复</a></p>\n<p><a href=\"https://github.com/flutter/flutter/issues/127079\">Crash issue caused by pthread_key_create failed: 11 when integrating Flutter into our project #127079</a></p>\n<p><a href=\"https://muc.lists.netbsd.tech.userlevel.narkive.com/gFAi2gse/increase-pthread-keys-max\">Increase PTHREAD_KEYS_MAX</a></p>\n","categories":[{"name":"技术文章","slug":"technology","api":"api/categories/technology.json"}],"tags":[{"name":"Android","slug":"Android","api":"api/tags/Android.json"}],"api":"api/posts/2024/11/10/关于-pthread-key-t-导致的-Android-Crash-的探索.json"},{"title":"[译]软件开发人员的常青技能","slug":"软件开发人员的常青技能","date":"2024-07-08T23:27:19.000Z","updated":"2025-05-20T11:46:57.000Z","comments":true,"url":"2024/07/09/软件开发人员的常青技能/","excerpt":"<p>最近在 Github 看到这一篇将程序员一直需要使用的非技术核心能力进行了总结，深受里面内容的启发，语言、框架都是会过时的，但有些技能无论是什么语言或者框架都是通用的，如果要在这个行业持续深根，那么这些非技术能力是必备的且实用的。本文在原文上进行翻译，并对文中提到部分专业术语进行了解释，以及对指向外部链接的文档内容作了一些简单的概述，希望能帮助到查看此文档的人。</p>\n<p>原文地址：<a href=\"https://github.com/romenrg/evergreen-skills-developers.git\">evergreen-skills-developers</a></p>\n<p>中英双文地址：<a href=\"https://github.com/VomPom/evergreen-skills-developers/blob/master/README_en_cn.md\">[译]evergreen-skills-developers</a></p>\n<h2 id=\"原文翻译：\"><a href=\"#原文翻译：\" class=\"headerlink\" title=\"原文翻译：\"></a>原文翻译：</h2><p>这个仓库包括了一份“常青技能”清单，这份清单应该可以作为对技术精湛的软件工程师&#x2F;开发者客观评价。</p>\n<p>这份工作的是为了在招聘软件开发者&#x2F;工程师时，提供一个替代的技术面试的方案。文档关注的是软开发最佳实践、跨框架原则和通用的技能；而不是我们在行业中经常看到的语言层面，或者特定技术框架的内容。</p>\n<p>编程语言不断进化，公司也不断改变他们的技术栈，框架很快就会过时，有经验的工程师使用搜索引擎能在几分钟就能解决语法相关的问题。因此，在面试候选人时关注这些方面是否有意义呢？</p>\n<p>另一方面，技术框架以外的原理和非技术的技能是在谷歌上查不到的，这些技能是“常青”的，并且对工程师的表现有巨大的影响。这些更能反映出软件开发者&#x2F;工程师为团队带来的真正价值。</p>\n<p>这个仓库是基于以下文章的一个衍生作品：”<a href=\"https://www.romenrg.com/blog/2018/12/29/what-makes-a-great-software-engineer\">是什么造就了一位伟大的软件工程师</a>“。</p>\n<p>这是一个正在进行中的工作。重要的知识可能缺失，现有的条目可能可以改进，更好的分组策略也可能被发现。因此，任何贡献（即PR或问题）都是受欢迎的。请随时按照<a href=\"https://gptx.woa.com/CONTRIBUTING.md\">贡献指南</a>提出修改建议。</p>\n<h2 id=\"目录\"><a href=\"#目录\" class=\"headerlink\" title=\"目录\"></a>目录</h2><ul>\n<li><p><a href=\"#%E9%9D%9E%E6%8A%80%E6%9C%AF%E6%8A%80%E8%83%BD\">非技术技能</a></p>\n<ul>\n<li><a href=\"#%E6%A0%B8%E5%BF%83%E6%8A%80%E8%83%BD%EF%BC%88%E5%8F%88%E7%A7%B0%E2%80%9C%E8%BD%AF%E6%8A%80%E8%83%BD%E2%80%9D%EF%BC%89\">核心技能</a><ul>\n<li><a href=\"#%E4%BA%A4%E6%B5%81\">交流</a></li>\n<li><a href=\"#%E5%9B%A2%E9%98%9F\">团队</a></li>\n</ul>\n</li>\n<li><a href=\"#%E5%88%9B%E6%96%B0%E5%92%8C%E8%87%AA%E6%88%91%E7%AE%A1%E7%90%86%E6%8A%80%E8%83%BD\">创新和自我管理技能</a><ul>\n<li><a href=\"#%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B\">开发流程</a></li>\n<li><a href=\"#%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E8%83%BD%E5%8A%9B\">问题解决能力</a></li>\n<li><a href=\"#%E5%BF%83%E6%80%81\">心态</a></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p><a href=\"#%E6%8A%80%E8%83%BD%E8%83%BD%E5%8A%9B\">技能能力</a></p>\n<ul>\n<li><a href=\"#%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF%E8%83%BD%E5%8A%9B\">通用技术能力</a></li>\n<li><a href=\"#%E7%BC%96%E7%A8%8B%E5%87%86%E5%88%99\">编程准则</a><ul>\n<li><a href=\"#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84\">数据结构</a> </li>\n<li><a href=\"#%E4%BB%A3%E7%A0%81%E6%95%B4%E6%B4%81\">代码整洁</a></li>\n<li><a href=\"#%E6%BA%90%E7%A0%81%E7%AE%A1%E7%90%86\">源码管理</a></li>\n<li><a href=\"#%E6%8A%80%E6%9C%AF%E5%90%88%E4%BD%9C\">技术合作</a></li>\n<li><a href=\"#DevOps%E5%AE%9E%E8%B7%B5\">DevOps实践</a></li>\n<li><a href=\"%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86\">通用技术知识</a><ul>\n<li><a href=\"#%E8%AF%AD%E8%A8%80%E7%90%86%E8%AE%BA%E7%9F%A5%E8%AF%86\">语言理论知识</a></li>\n<li><a href=\"#%E4%BC%98%E5%8C%96\">优化</a></li>\n<li><a href=\"#%E5%B9%B6%E5%8F%91\">并发</a></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p><a href=\"#%E7%89%B9%E5%AE%9A%E9%A2%86%E5%9F%9F%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86\">特定领域技术知识</a></p>\n<ul>\n<li><p><a href=\"#%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91\">前端开发</a></p>\n</li>\n<li><p><a href=\"#%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91\">后端开发</a></p>\n</li>\n<li><p><a href=\"#%E6%9E%B6%E6%9E%84\">架构</a></p>\n</li>\n<li><p><a href=\"#%E5%9F%BA%E7%A1%80%E5%BB%BA%E8%AE%BE\">基础建设</a></p>\n</li>\n<li><p><a href=\"#%E5%AE%89%E5%85%A8\">安全</a></p>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"非技术技能\"><a href=\"#非技术技能\" class=\"headerlink\" title=\"非技术技能\"></a>非技术技能</h2><p>以下非技术能力可能是开发者最重要的能力。尽管一个人可能具备很强的技术能力，但在公司中没有良好的沟通、团队合作态度、开发流程、解决问题的能力和学习的心态的话，一切会变得非常糟糕。</p>\n<h3 id=\"核心技能（又称“软技能”）\"><a href=\"#核心技能（又称“软技能”）\" class=\"headerlink\" title=\"核心技能（又称“软技能”）\"></a>核心技能（又称“软技能”）</h3><h4 id=\"交流\"><a href=\"#交流\" class=\"headerlink\" title=\"交流\"></a>交流</h4><ul>\n<li>遵循邮件使用的最佳策略(例： <a href=\"https://www.grammarly.com/blog/email-etiquette-rules-to-know/\">some e-mail etiquette rules</a>)</li>\n</ul>\n<ul>\n<li><p>遵循沟通的最佳策略 (e.g. <a href=\"https://slack.com/intl/en-es/help/articles/115000769927-Use-threads-to-organize-discussions-\">use threads to organize discussions</a> and <a href=\"https://blog.rescuetime.com/slack-focus-guide/\">other best-practices from Slack</a>)</p>\n<p>两份链接指向的 slack 的一则使用文档和一份 slack 使用技巧文档</p>\n</li>\n<li><p><a href=\"https://jaxenter.com/aaaand-gone-true-cost-interruptions-128741.html\">最小化干扰</a></p>\n<p>链接指向的文章是一篇关于程序员在工作中，因被其他事项而中断程序开发的影响，一般人，在工作过程中断打扰后大约需要23分钟才能恢复到之前的状态，而程序员需要更久，文中强调了工作中断对程序员工作效率和心情的影响，并讨论了有计划和非计划性中断的不同影响。</p>\n</li>\n<li><p>保持礼貌</p>\n</li>\n</ul>\n<h4 id=\"团队\"><a href=\"#团队\" class=\"headerlink\" title=\"团队\"></a>团队</h4><ul>\n<li><p><a href=\"https://simpleprogrammer.com/empathy-software-developers\">练习同理心</a></p>\n</li>\n<li><p>保持谦逊和低调</p>\n</li>\n<li><p>做一个积极倾听的人</p>\n</li>\n<li><p>做一个好的导师</p>\n</li>\n<li><p>知识分享</p>\n</li>\n<li><p>得有见地</p>\n</li>\n</ul>\n<h3 id=\"创新和自我管理技能\"><a href=\"#创新和自我管理技能\" class=\"headerlink\" title=\"创新和自我管理技能\"></a>创新和自我管理技能</h3><h4 id=\"开发流程\"><a href=\"#开发流程\" class=\"headerlink\" title=\"开发流程\"></a>开发流程</h4><ul>\n<li><p>了解<a href=\"https://agilemanifesto.org/principles.html\">《敏捷开发原则》</a></p>\n</li>\n<li><p>适应迭代和增量开发</p>\n</li>\n<li><p>自组织的能力</p>\n<p>指的是个体或系统能够自发地、无需外部强制指挥，根据内部规则和相互作用来组织自身结构和行为的能力。这种能力在多个层面都有体现，包括个人自我管理、团队协作以及更广泛的社会和生态系统</p>\n</li>\n<li><p>避免产生错误的预估（比如：工时预估）</p>\n</li>\n<li><p>关注优先级和业务价值</p>\n</li>\n</ul>\n<h4 id=\"问题解决能力\"><a href=\"#问题解决能力\" class=\"headerlink\" title=\"问题解决能力\"></a>问题解决能力</h4><ul>\n<li><p>使用科学方法(<a href=\"https://en.wikipedia.org/wiki/Scientific_method\">Scientific Method</a>)</p>\n<blockquote>\n<p>科学方法是一种有系统地寻求知识的程序，涉及了以下三个步骤：问题的认知与表述、实验数据的收集、假说的构成与测试。</p>\n</blockquote>\n</li>\n<li><p>检索能力</p>\n</li>\n<li><p>横向思维</p>\n<blockquote>\n<p>横向思维，指使用间接的、具有创造力的、不是一望而知的推理方式来解决问题</p>\n</blockquote>\n</li>\n<li><p>抽象化能力</p>\n</li>\n<li><p>创造力</p>\n</li>\n<li><p><a href=\"http://en.wikipedia.org/wiki/5_Whys\">五问法</a></p>\n<blockquote>\n<p>五问法关键所在就是，鼓励解决问题的人要努力避开主观或自负的假设和逻辑陷阱，从结果着手，沿着因果关系链条，顺藤摸瓜，穿越不同的抽象层面，直至找出原有问题的根本原因。简而言之，就是鼓励解决问题的人要有“打破砂锅问到底”的精神。</p>\n</blockquote>\n</li>\n<li><p>风险管理</p>\n</li>\n</ul>\n<h4 id=\"心态\"><a href=\"#心态\" class=\"headerlink\" title=\"心态\"></a>心态</h4><ul>\n<li><p>不要害怕变化</p>\n</li>\n<li><p>敢于失败</p>\n</li>\n<li><p>终生学习</p>\n</li>\n<li><p><a href=\"https://en.wikipedia.org/wiki/Critical_thinking\">批判性思维</a> （保持理性，质疑决定，“让事实说话”）</p>\n</li>\n</ul>\n<h2 id=\"技能能力\"><a href=\"#技能能力\" class=\"headerlink\" title=\"技能能力\"></a>技能能力</h2><h3 id=\"通用技术能力\"><a href=\"#通用技术能力\" class=\"headerlink\" title=\"通用技术能力\"></a>通用技术能力</h3><p>有一些技术知识是永恒的，对任何软件工程师都有关，尽管他们将要从事的具体领域各不相同。为了深入了解他们的资历并了解他们的工程实践有多扎实，你可以和他们就编程原理、数据结构、清晰的代码、源代码管理、技术协作或者DevOps实践等主题进行交谈。如果这些基础扎实，他们可能能够毫无问题地学习你们特定领域的东西。</p>\n<h4 id=\"编程准则\"><a href=\"#编程准则\" class=\"headerlink\" title=\"编程准则\"></a>编程准则</h4><ul>\n<li><p>基本流程结构和逻辑代数</p>\n</li>\n<li><p>面向对象编程</p>\n</li>\n<li><p><a href=\"https://en.wikipedia.org/wiki/SOLID\">SOLID</a>, <a href=\"https://en.wikipedia.org/wiki/GRASP_(object-oriented_design)\">GRASP</a>面向对象设计</p>\n<blockquote>\n<p><strong>SOLID</strong>（单一功能、开闭原则、里氏替换、接口隔离以及依赖反转）</p>\n</blockquote>\n</li>\n</ul>\n<blockquote>\n<table>\n<thead>\n<tr>\n<th align=\"center\"></th>\n<th></th>\n<th></th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">S</td>\n<td><a href=\"https://zh.wikipedia.org/wiki/%E5%8D%95%E4%B8%80%E5%8A%9F%E8%83%BD%E5%8E%9F%E5%88%99\">单一功能原则</a></td>\n<td>认为“对象应该仅具有一种单一功能”的概念。</td>\n</tr>\n<tr>\n<td align=\"center\">O</td>\n<td><a href=\"https://zh.wikipedia.org/wiki/%E5%BC%80%E9%97%AD%E5%8E%9F%E5%88%99\">开闭原则</a></td>\n<td>认为“软件应该是对于扩展开放的，但是对于修改封闭的”的概念。</td>\n</tr>\n<tr>\n<td align=\"center\">L</td>\n<td><a href=\"https://zh.wikipedia.org/wiki/%E9%87%8C%E6%B0%8F%E6%9B%BF%E6%8D%A2%E5%8E%9F%E5%88%99\">里氏替换原则</a></td>\n<td>认为“程序中的对象应该是可以在不改变程序正确性的前提下被它的子类所替换的”的概念。参考契约式设计。</td>\n</tr>\n<tr>\n<td align=\"center\">I</td>\n<td><a href=\"https://zh.wikipedia.org/wiki/%E6%8E%A5%E5%8F%A3%E9%9A%94%E7%A6%BB%E5%8E%9F%E5%88%99\">接口隔离原则</a></td>\n<td>认为“多个特定客户端接口要好于一个宽泛用途的接口”的概念。</td>\n</tr>\n<tr>\n<td align=\"center\">D</td>\n<td><a href=\"https://zh.wikipedia.org/wiki/%E4%BE%9D%E8%B5%96%E5%8F%8D%E8%BD%AC%E5%8E%9F%E5%88%99\">依赖反转原则</a></td>\n<td>认为一个方法应该遵从“依赖于抽象而不是一个实例”的概念。 依赖注入是该原则的一种实现方式。</td>\n</tr>\n</tbody></table>\n<p><strong>GRASP</strong>中提到的模式和原则包括有控制器（controller）、创建者（creator）、中介（indirection）、信息专家（information expert）、低耦合性（low coupling）、高内聚性（high cohesion）、多态（polymorphism）、保护变化（protected variations）和纯虚构（pure Fabrication）[2]</p>\n</blockquote>\n<ul>\n<li><p>函数式编程（纯函数、不变性、递归……）</p>\n</li>\n<li><p><a href=\"http://amzotti.github.io/programming%20paradigms/2015/02/13/what-is-the-difference-between-procedural-function-imperative-and-declarative-programming-paradigms/\">声明式与命令式编程</a></p>\n<blockquote>\n<p>声明式和命令式编程范例只不过是描述在不同抽象层次上编码的流行词。声明式编程关注的是“做什么，而不是如何做”，而命令式编程则关注的是“如何做，而不是做什么”。声明式编程是在比命令式编程更高的抽象层次上进行编程。两者都有其适用的地方，例如在网页开发中使用框架时需要声明式编程，而在设计算法和其他底层需求时则需要命令式编程。</p>\n</blockquote>\n</li>\n</ul>\n<h4 id=\"数据结构\"><a href=\"#数据结构\" class=\"headerlink\" title=\"数据结构\"></a>数据结构</h4><ul>\n<li><p>基本数据结构（基本类型、数组、矩阵、对象…）</p>\n</li>\n<li><p>缓存和 memoization</p>\n<p>memoization 没有一个很好的词能翻译，大概意思就是通过存储函数调用的结果，并在再次使用相同输入调用函数时直接返回已存储的结果，从而加速计算逻辑。斐波那契数列就是一个使用 memoization 的例子</p>\n</li>\n<li><p>Hash codes、 tokens、编码（比如 Base64）</p>\n</li>\n<li><p><a href=\"https://stackoverflow.com/a/80113/1213497\">栈与堆内存</a> </p>\n<p>链接指向一则在 <a href=\"https://stackoverflow.com/questions/79923/what-and-where-are-the-stack-and-heap/80113#80113\">stackoverflow</a>  提出堆栈相关的诸多疑问，最高数回答解释了堆栈两种内存分配方式的基本概念、操作方式和性能差异，其中栈内存分配方式由于其后进先出的特性和近距离的存取模式，使得其在内存分配和回收上更加高效；而堆内存分配方式由于其动态和灵活的特性，对内存的管理相对复杂，但能够满足更多的内存需求</p>\n</li>\n</ul>\n<h4 id=\"代码整洁\"><a href=\"#代码整洁\" class=\"headerlink\" title=\"代码整洁\"></a>代码整洁</h4><ul>\n<li><p>懂得命名对代码的可读性的重要性</p>\n</li>\n<li><p>避免过长的方法和类，确保职责被划分到各个方法或者类中</p>\n</li>\n<li><p>遵循约定来管理项目结构</p>\n</li>\n<li><p>将复杂的布尔条件提取到命名良好的函数中</p>\n</li>\n<li><p>尽量编写尽可能自解释的代码（即通过阅读代码就能容易理解代码的功能）</p>\n</li>\n<li><p>良好的命名和轻量的文档而不是行内注释</p>\n<p><a href=\"https://www.codeproject.com/Articles/872073/Code-Comments-are-Lies\">代码注释通常可能会误导人</a>，因为它们经常被用作一种捷径，用来解释一段混乱的代码块的功能，而不是投入时间去重构它以提高其可读性。</p>\n<p>链接的文章主张编写清晰、自解释和可维护的代码，而不是过度依赖注释，同时也承认在某些特殊情况下，注释是有其必要性和价值的。</p>\n</li>\n<li><p>将文档编写为代码，理想情况下与代码一起，以便于维护（例如，在仓库中的“docs”文件夹中的 markdown 文件）</p>\n</li>\n<li><p>使用文档来描述“为什么”和“怎么做”（例如，目标、用例、组件、高级架构概述等）</p>\n</li>\n<li><p>在面向对象编程中，组合优于继承</p>\n</li>\n<li><p><a href=\"https://semver.org/\">Follow 语义化</a></p>\n</li>\n<li><p>了解TDD及其实践（例如，“红色，绿色，重构”）</p>\n<blockquote>\n<p><strong>TDD</strong>(测试驱动开发)是戴两顶帽子思考的开发方式：先戴上实现功能的帽子，在测试的辅助下，快速实现其功能；再戴上测试驱动开发的帽子，在测试的保护下，通过去除冗余的代码，提高代码品质。测试驱动着整个开发过程：首先，驱动代码的设计和功能的实现；其后，驱动代码的再设计和重构。</p>\n<ul>\n<li><p>红色：首先编写一个针对新功能的测试用例，此时由于功能尚未实现，测试用例将无法通过（失败，显示红色）</p>\n</li>\n<li><p>绿色：接下来编写功能代码，使得测试用例能够通过（成功，显示绿色）。在这个阶段，重点是让测试通过，而不是编写完美的代码。</p>\n</li>\n<li><p>重构：在测试用例通过后，对功能代码进行优化和重构，提高代码质量，同时确保测试用例仍然能够通过。</p>\n</li>\n</ul>\n</blockquote>\n</li>\n</ul>\n<h4 id=\"源码管理能力\"><a href=\"#源码管理能力\" class=\"headerlink\" title=\"源码管理能力\"></a>源码管理能力</h4><ul>\n<li><p>CVS（控制版本系统）&#x2F; SCM（源代码管理）基础知识：分支、标签、集中式与分散式等</p>\n</li>\n<li><p>SCM与仓库管理&#x2F;托管的区别（即<a href=\"https://stackoverflow.com/a/13321586\">Git与GitHub之间的区别</a>）</p>\n</li>\n<li><p>理解版本化的重要性</p>\n</li>\n<li><p>Commit 最佳实践</p>\n<ul>\n<li><p><a href=\"https://lucasr.org/2011/01/29/micro-commits/\">微提交</a> &#x2F;原子提交，良好的描述等</p>\n</li>\n<li><p><a href=\"https://www.conventionalcommits.org/en/v1.0.0/\">常规提交</a></p>\n</li>\n</ul>\n</li>\n<li><p>功能分支（短期）</p>\n</li>\n<li><p>基于主干的开发</p>\n</li>\n<li><p>依赖管理（包管理器的重要性，依赖地狱的风险等）</p>\n</li>\n</ul>\n<h4 id=\"技术合作\"><a href=\"#技术合作\" class=\"headerlink\" title=\"技术合作\"></a>技术合作</h4><ul>\n<li><p><a href=\"https://blog.github.com/2015-01-21-how-to-write-the-perfect-pull-request/\">代码 review 最佳实践</a></p>\n<ul>\n<li>一句话来说就是：在执行代码审查时关注相关部分。目的是学习，而不是指责。</li>\n</ul>\n</li>\n<li><p><a href=\"https://martinfowler.com/articles/on-pair-programming.html\">结对编程</a></p>\n<p>这篇文章主要讨论了结对编程（Pair Programming）的相关主题，包括其风格、时间管理、轮换策略、日常规划、物理环境设置、远程配对等方面。还探讨了结对编程的好处和挑战，以及如何说服管理者和同事采用这种方法。此外，文章还涉及了一些与配对编程相关的细节和常见问题</p>\n</li>\n</ul>\n<h4 id=\"DevOps-实践\"><a href=\"#DevOps-实践\" class=\"headerlink\" title=\"DevOps 实践\"></a>DevOps 实践</h4><ul>\n<li><p>自动化构建</p>\n</li>\n<li><p>构件仓库和镜像注册表</p>\n</li>\n<li><p>编写自动化测试</p>\n</li>\n<li><p>单元、集成和端到端（e2e）测试之间的区别</p>\n</li>\n<li><p>测试金字塔</p>\n</li>\n<li><p>持续集成</p>\n</li>\n<li><p>持续交付与持续部署</p>\n</li>\n<li><p>功能 Flag 和功能开关</p>\n</li>\n</ul>\n<h4 id=\"通用技术知识\"><a href=\"#通用技术知识\" class=\"headerlink\" title=\"通用技术知识\"></a>通用技术知识</h4><h5 id=\"语言理论知识\"><a href=\"#语言理论知识\" class=\"headerlink\" title=\"语言理论知识\"></a>语言理论知识</h5><ul>\n<li><p>正则表达式（regex）</p>\n</li>\n<li><p>编译型与解释型语言</p>\n</li>\n<li><p><a href=\"https://medium.com/@cpave3/understanding-types-static-vs-dynamic-strong-vs-weak-88a4e1f0ed5f\">动态与静态 &amp; 弱类型与强类型语言类型</a></p>\n</li>\n</ul>\n<h5 id=\"优化\"><a href=\"#优化\" class=\"headerlink\" title=\"优化\"></a>优化</h5><ul>\n<li><p>懒加载</p>\n</li>\n<li><p><a href=\"https://en.wikipedia.org/wiki/Profiling_(computer_programming)\">性能分析</a></p>\n</li>\n</ul>\n<h5 id=\"并发\"><a href=\"#并发\" class=\"headerlink\" title=\"并发\"></a>并发</h5><ul>\n<li><p>竞态条件</p>\n</li>\n<li><p>死锁</p>\n</li>\n<li><p>互斥</p>\n</li>\n</ul>\n<h3 id=\"特定领域技术知识\"><a href=\"#特定领域技术知识\" class=\"headerlink\" title=\"特定领域技术知识\"></a>特定领域技术知识</h3><p>在某些情况下，您可能希望工程师已经了解某些特定领域，例如前端、后端、架构、基础设施或安全方面。在这些情况下，还有一些跨框架的概念和原则，可用于推动针对每个领域的特定技术知识的内容。</p>\n<h4 id=\"前端开发\"><a href=\"#前端开发\" class=\"headerlink\" title=\"前端开发\"></a>前端开发</h4><ul>\n<li><p>API通信（不同的架构标准，数据如何传输…）</p>\n</li>\n<li><p>DOM（定义，理解，虚拟DOM…）</p>\n</li>\n<li><p>浏览器事件</p>\n</li>\n<li><p>响应式设计（目的，优点，渐进增强…）</p>\n</li>\n<li><p>客户端渲染（CSR）与服务器端渲染（SSR）</p>\n</li>\n<li><p>分页</p>\n</li>\n<li><p>状态管理（相关问题，无状态方法…）</p>\n</li>\n<li><p>MVC 和相关的衍生品</p>\n</li>\n<li><p>WebSockets 网络通信协议</p>\n</li>\n</ul>\n<h4 id=\"后端开发\"><a href=\"#后端开发\" class=\"headerlink\" title=\"后端开发\"></a>后端开发</h4><ul>\n<li><p>API设计（不同的架构标准，数据如何传输…）</p>\n</li>\n<li><p><a href=\"https://en.wikipedia.org/wiki/Message_broker\">消息代理</a></p>\n</li>\n<li><p>关系型数据库（它们是如何工作的，基本概念…）</p>\n</li>\n<li><p>非关系型数据库</p>\n</li>\n<li><p>数据库设计</p>\n</li>\n<li><p>ORM（对象关系映射）</p>\n</li>\n<li><p>批处理进程 &#x2F; 定时任务</p>\n</li>\n<li><p>会话处理</p>\n</li>\n<li><p><a href=\"https://lti.umuc.edu/contentadaptor/topics/byid/db0a8c4f-f738-4674-9f60-b75323cdb07f\">错误处理、审查、日志记录</a></p>\n</li>\n</ul>\n<h4 id=\"架构\"><a href=\"#架构\" class=\"headerlink\" title=\"架构\"></a>架构</h4><ul>\n<li><p>API</p>\n<ul>\n<li><p>标准协议：REST &#x2F; SOAP </p>\n</li>\n<li><p>安全性（例如拦截机器人，控制账户接管攻击等）</p>\n</li>\n<li><p>针对第三方服务故障的弹性橱窗（例如断路器）</p>\n</li>\n</ul>\n</li>\n<li><p>外部可配置化</p>\n</li>\n<li><p><a href=\"https://www.romenrg.com/blog/2019/12/31/everything-as-code/\">万物皆代码（即配置即代码，基础设施即代码，文档即代码…）</a></p>\n</li>\n<li><p>单体应用与微服务</p>\n</li>\n<li><p>领域驱动设计（DDD）</p>\n</li>\n<li><p>六边形架构</p>\n</li>\n<li><p>服务 Mesh</p>\n</li>\n<li><p>相关的互联网协议及其用法（如 HTTP, HTTPS, TCP, UDP, LDAP, SSH, SMTP…）</p>\n</li>\n<li><p><a href=\"https://en.wikipedia.org/wiki/Data_modeling\">数据建模</a></p>\n</li>\n</ul>\n<h4 id=\"基础设施\"><a href=\"#基础设施\" class=\"headerlink\" title=\"基础设施\"></a>基础设施</h4><ul>\n<li><p>虚拟机与容器</p>\n</li>\n<li><p>进程与线程</p>\n</li>\n<li><p>控制器-代理&#x2F;主副本模式</p>\n</li>\n<li><p>C&#x2F;S模式</p>\n</li>\n<li><p>IAAS, PAAS, SASS</p>\n</li>\n<li><p>Web服务器</p>\n</li>\n<li><p>反向代理</p>\n</li>\n<li><p>负载均衡</p>\n</li>\n<li><p>冗余</p>\n</li>\n<li><p>延迟</p>\n</li>\n<li><p>监控</p>\n</li>\n<li><p><a href=\"https://docs.honeycomb.io/learning-about-observability/intro-to-observability/\">可监控性</a></p>\n</li>\n</ul>\n<h4 id=\"安全\"><a href=\"#安全\" class=\"headerlink\" title=\"安全\"></a>安全</h4><ul>\n<li><p>身份和访问管理（IAM）</p>\n<ul>\n<li><p>认证（JWT, SSO）</p>\n</li>\n<li><p>授权（RBAC, ABAC）</p>\n</li>\n</ul>\n</li>\n<li><p>公钥密码系统（例如RSA）</p>\n</li>\n<li><p>加密协议（TLS, SSL）</p>\n</li>\n<li><p>最小权限原则</p>\n</li>\n<li><p>DoS &#x2F; DDoS</p>\n</li>\n<li><p>SQL 注入</p>\n</li>\n<li><p>中间人攻击</p>\n</li>\n<li><p>XSS（跨站脚本攻击） 和 CSRF（跨站请求伪造）</p>\n</li>\n</ul>\n","cover":null,"images":[],"content":"<p>最近在 Github 看到这一篇将程序员一直需要使用的非技术核心能力进行了总结，深受里面内容的启发，语言、框架都是会过时的，但有些技能无论是什么语言或者框架都是通用的，如果要在这个行业持续深根，那么这些非技术能力是必备的且实用的。本文在原文上进行翻译，并对文中提到部分专业术语进行了解释，以及对指向外部链接的文档内容作了一些简单的概述，希望能帮助到查看此文档的人。</p>\n<p>原文地址：<a href=\"https://github.com/romenrg/evergreen-skills-developers.git\">evergreen-skills-developers</a></p>\n<p>中英双文地址：<a href=\"https://github.com/VomPom/evergreen-skills-developers/blob/master/README_en_cn.md\">[译]evergreen-skills-developers</a></p>\n<h2 id=\"原文翻译：\"><a href=\"#原文翻译：\" class=\"headerlink\" title=\"原文翻译：\"></a>原文翻译：</h2><p>这个仓库包括了一份“常青技能”清单，这份清单应该可以作为对技术精湛的软件工程师&#x2F;开发者客观评价。</p>\n<p>这份工作的是为了在招聘软件开发者&#x2F;工程师时，提供一个替代的技术面试的方案。文档关注的是软开发最佳实践、跨框架原则和通用的技能；而不是我们在行业中经常看到的语言层面，或者特定技术框架的内容。</p>\n<p>编程语言不断进化，公司也不断改变他们的技术栈，框架很快就会过时，有经验的工程师使用搜索引擎能在几分钟就能解决语法相关的问题。因此，在面试候选人时关注这些方面是否有意义呢？</p>\n<p>另一方面，技术框架以外的原理和非技术的技能是在谷歌上查不到的，这些技能是“常青”的，并且对工程师的表现有巨大的影响。这些更能反映出软件开发者&#x2F;工程师为团队带来的真正价值。</p>\n<p>这个仓库是基于以下文章的一个衍生作品：”<a href=\"https://www.romenrg.com/blog/2018/12/29/what-makes-a-great-software-engineer\">是什么造就了一位伟大的软件工程师</a>“。</p>\n<p>这是一个正在进行中的工作。重要的知识可能缺失，现有的条目可能可以改进，更好的分组策略也可能被发现。因此，任何贡献（即PR或问题）都是受欢迎的。请随时按照<a href=\"https://gptx.woa.com/CONTRIBUTING.md\">贡献指南</a>提出修改建议。</p>\n<h2 id=\"目录\"><a href=\"#目录\" class=\"headerlink\" title=\"目录\"></a>目录</h2><ul>\n<li><p><a href=\"#%E9%9D%9E%E6%8A%80%E6%9C%AF%E6%8A%80%E8%83%BD\">非技术技能</a></p>\n<ul>\n<li><a href=\"#%E6%A0%B8%E5%BF%83%E6%8A%80%E8%83%BD%EF%BC%88%E5%8F%88%E7%A7%B0%E2%80%9C%E8%BD%AF%E6%8A%80%E8%83%BD%E2%80%9D%EF%BC%89\">核心技能</a><ul>\n<li><a href=\"#%E4%BA%A4%E6%B5%81\">交流</a></li>\n<li><a href=\"#%E5%9B%A2%E9%98%9F\">团队</a></li>\n</ul>\n</li>\n<li><a href=\"#%E5%88%9B%E6%96%B0%E5%92%8C%E8%87%AA%E6%88%91%E7%AE%A1%E7%90%86%E6%8A%80%E8%83%BD\">创新和自我管理技能</a><ul>\n<li><a href=\"#%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B\">开发流程</a></li>\n<li><a href=\"#%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E8%83%BD%E5%8A%9B\">问题解决能力</a></li>\n<li><a href=\"#%E5%BF%83%E6%80%81\">心态</a></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p><a href=\"#%E6%8A%80%E8%83%BD%E8%83%BD%E5%8A%9B\">技能能力</a></p>\n<ul>\n<li><a href=\"#%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF%E8%83%BD%E5%8A%9B\">通用技术能力</a></li>\n<li><a href=\"#%E7%BC%96%E7%A8%8B%E5%87%86%E5%88%99\">编程准则</a><ul>\n<li><a href=\"#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84\">数据结构</a> </li>\n<li><a href=\"#%E4%BB%A3%E7%A0%81%E6%95%B4%E6%B4%81\">代码整洁</a></li>\n<li><a href=\"#%E6%BA%90%E7%A0%81%E7%AE%A1%E7%90%86\">源码管理</a></li>\n<li><a href=\"#%E6%8A%80%E6%9C%AF%E5%90%88%E4%BD%9C\">技术合作</a></li>\n<li><a href=\"#DevOps%E5%AE%9E%E8%B7%B5\">DevOps实践</a></li>\n<li><a href=\"%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86\">通用技术知识</a><ul>\n<li><a href=\"#%E8%AF%AD%E8%A8%80%E7%90%86%E8%AE%BA%E7%9F%A5%E8%AF%86\">语言理论知识</a></li>\n<li><a href=\"#%E4%BC%98%E5%8C%96\">优化</a></li>\n<li><a href=\"#%E5%B9%B6%E5%8F%91\">并发</a></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p><a href=\"#%E7%89%B9%E5%AE%9A%E9%A2%86%E5%9F%9F%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86\">特定领域技术知识</a></p>\n<ul>\n<li><p><a href=\"#%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91\">前端开发</a></p>\n</li>\n<li><p><a href=\"#%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91\">后端开发</a></p>\n</li>\n<li><p><a href=\"#%E6%9E%B6%E6%9E%84\">架构</a></p>\n</li>\n<li><p><a href=\"#%E5%9F%BA%E7%A1%80%E5%BB%BA%E8%AE%BE\">基础建设</a></p>\n</li>\n<li><p><a href=\"#%E5%AE%89%E5%85%A8\">安全</a></p>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"非技术技能\"><a href=\"#非技术技能\" class=\"headerlink\" title=\"非技术技能\"></a>非技术技能</h2><p>以下非技术能力可能是开发者最重要的能力。尽管一个人可能具备很强的技术能力，但在公司中没有良好的沟通、团队合作态度、开发流程、解决问题的能力和学习的心态的话，一切会变得非常糟糕。</p>\n<h3 id=\"核心技能（又称“软技能”）\"><a href=\"#核心技能（又称“软技能”）\" class=\"headerlink\" title=\"核心技能（又称“软技能”）\"></a>核心技能（又称“软技能”）</h3><h4 id=\"交流\"><a href=\"#交流\" class=\"headerlink\" title=\"交流\"></a>交流</h4><ul>\n<li>遵循邮件使用的最佳策略(例： <a href=\"https://www.grammarly.com/blog/email-etiquette-rules-to-know/\">some e-mail etiquette rules</a>)</li>\n</ul>\n<ul>\n<li><p>遵循沟通的最佳策略 (e.g. <a href=\"https://slack.com/intl/en-es/help/articles/115000769927-Use-threads-to-organize-discussions-\">use threads to organize discussions</a> and <a href=\"https://blog.rescuetime.com/slack-focus-guide/\">other best-practices from Slack</a>)</p>\n<p>两份链接指向的 slack 的一则使用文档和一份 slack 使用技巧文档</p>\n</li>\n<li><p><a href=\"https://jaxenter.com/aaaand-gone-true-cost-interruptions-128741.html\">最小化干扰</a></p>\n<p>链接指向的文章是一篇关于程序员在工作中，因被其他事项而中断程序开发的影响，一般人，在工作过程中断打扰后大约需要23分钟才能恢复到之前的状态，而程序员需要更久，文中强调了工作中断对程序员工作效率和心情的影响，并讨论了有计划和非计划性中断的不同影响。</p>\n</li>\n<li><p>保持礼貌</p>\n</li>\n</ul>\n<h4 id=\"团队\"><a href=\"#团队\" class=\"headerlink\" title=\"团队\"></a>团队</h4><ul>\n<li><p><a href=\"https://simpleprogrammer.com/empathy-software-developers\">练习同理心</a></p>\n</li>\n<li><p>保持谦逊和低调</p>\n</li>\n<li><p>做一个积极倾听的人</p>\n</li>\n<li><p>做一个好的导师</p>\n</li>\n<li><p>知识分享</p>\n</li>\n<li><p>得有见地</p>\n</li>\n</ul>\n<h3 id=\"创新和自我管理技能\"><a href=\"#创新和自我管理技能\" class=\"headerlink\" title=\"创新和自我管理技能\"></a>创新和自我管理技能</h3><h4 id=\"开发流程\"><a href=\"#开发流程\" class=\"headerlink\" title=\"开发流程\"></a>开发流程</h4><ul>\n<li><p>了解<a href=\"https://agilemanifesto.org/principles.html\">《敏捷开发原则》</a></p>\n</li>\n<li><p>适应迭代和增量开发</p>\n</li>\n<li><p>自组织的能力</p>\n<p>指的是个体或系统能够自发地、无需外部强制指挥，根据内部规则和相互作用来组织自身结构和行为的能力。这种能力在多个层面都有体现，包括个人自我管理、团队协作以及更广泛的社会和生态系统</p>\n</li>\n<li><p>避免产生错误的预估（比如：工时预估）</p>\n</li>\n<li><p>关注优先级和业务价值</p>\n</li>\n</ul>\n<h4 id=\"问题解决能力\"><a href=\"#问题解决能力\" class=\"headerlink\" title=\"问题解决能力\"></a>问题解决能力</h4><ul>\n<li><p>使用科学方法(<a href=\"https://en.wikipedia.org/wiki/Scientific_method\">Scientific Method</a>)</p>\n<blockquote>\n<p>科学方法是一种有系统地寻求知识的程序，涉及了以下三个步骤：问题的认知与表述、实验数据的收集、假说的构成与测试。</p>\n</blockquote>\n</li>\n<li><p>检索能力</p>\n</li>\n<li><p>横向思维</p>\n<blockquote>\n<p>横向思维，指使用间接的、具有创造力的、不是一望而知的推理方式来解决问题</p>\n</blockquote>\n</li>\n<li><p>抽象化能力</p>\n</li>\n<li><p>创造力</p>\n</li>\n<li><p><a href=\"http://en.wikipedia.org/wiki/5_Whys\">五问法</a></p>\n<blockquote>\n<p>五问法关键所在就是，鼓励解决问题的人要努力避开主观或自负的假设和逻辑陷阱，从结果着手，沿着因果关系链条，顺藤摸瓜，穿越不同的抽象层面，直至找出原有问题的根本原因。简而言之，就是鼓励解决问题的人要有“打破砂锅问到底”的精神。</p>\n</blockquote>\n</li>\n<li><p>风险管理</p>\n</li>\n</ul>\n<h4 id=\"心态\"><a href=\"#心态\" class=\"headerlink\" title=\"心态\"></a>心态</h4><ul>\n<li><p>不要害怕变化</p>\n</li>\n<li><p>敢于失败</p>\n</li>\n<li><p>终生学习</p>\n</li>\n<li><p><a href=\"https://en.wikipedia.org/wiki/Critical_thinking\">批判性思维</a> （保持理性，质疑决定，“让事实说话”）</p>\n</li>\n</ul>\n<h2 id=\"技能能力\"><a href=\"#技能能力\" class=\"headerlink\" title=\"技能能力\"></a>技能能力</h2><h3 id=\"通用技术能力\"><a href=\"#通用技术能力\" class=\"headerlink\" title=\"通用技术能力\"></a>通用技术能力</h3><p>有一些技术知识是永恒的，对任何软件工程师都有关，尽管他们将要从事的具体领域各不相同。为了深入了解他们的资历并了解他们的工程实践有多扎实，你可以和他们就编程原理、数据结构、清晰的代码、源代码管理、技术协作或者DevOps实践等主题进行交谈。如果这些基础扎实，他们可能能够毫无问题地学习你们特定领域的东西。</p>\n<h4 id=\"编程准则\"><a href=\"#编程准则\" class=\"headerlink\" title=\"编程准则\"></a>编程准则</h4><ul>\n<li><p>基本流程结构和逻辑代数</p>\n</li>\n<li><p>面向对象编程</p>\n</li>\n<li><p><a href=\"https://en.wikipedia.org/wiki/SOLID\">SOLID</a>, <a href=\"https://en.wikipedia.org/wiki/GRASP_(object-oriented_design)\">GRASP</a>面向对象设计</p>\n<blockquote>\n<p><strong>SOLID</strong>（单一功能、开闭原则、里氏替换、接口隔离以及依赖反转）</p>\n</blockquote>\n</li>\n</ul>\n<blockquote>\n<table>\n<thead>\n<tr>\n<th align=\"center\"></th>\n<th></th>\n<th></th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">S</td>\n<td><a href=\"https://zh.wikipedia.org/wiki/%E5%8D%95%E4%B8%80%E5%8A%9F%E8%83%BD%E5%8E%9F%E5%88%99\">单一功能原则</a></td>\n<td>认为“对象应该仅具有一种单一功能”的概念。</td>\n</tr>\n<tr>\n<td align=\"center\">O</td>\n<td><a href=\"https://zh.wikipedia.org/wiki/%E5%BC%80%E9%97%AD%E5%8E%9F%E5%88%99\">开闭原则</a></td>\n<td>认为“软件应该是对于扩展开放的，但是对于修改封闭的”的概念。</td>\n</tr>\n<tr>\n<td align=\"center\">L</td>\n<td><a href=\"https://zh.wikipedia.org/wiki/%E9%87%8C%E6%B0%8F%E6%9B%BF%E6%8D%A2%E5%8E%9F%E5%88%99\">里氏替换原则</a></td>\n<td>认为“程序中的对象应该是可以在不改变程序正确性的前提下被它的子类所替换的”的概念。参考契约式设计。</td>\n</tr>\n<tr>\n<td align=\"center\">I</td>\n<td><a href=\"https://zh.wikipedia.org/wiki/%E6%8E%A5%E5%8F%A3%E9%9A%94%E7%A6%BB%E5%8E%9F%E5%88%99\">接口隔离原则</a></td>\n<td>认为“多个特定客户端接口要好于一个宽泛用途的接口”的概念。</td>\n</tr>\n<tr>\n<td align=\"center\">D</td>\n<td><a href=\"https://zh.wikipedia.org/wiki/%E4%BE%9D%E8%B5%96%E5%8F%8D%E8%BD%AC%E5%8E%9F%E5%88%99\">依赖反转原则</a></td>\n<td>认为一个方法应该遵从“依赖于抽象而不是一个实例”的概念。 依赖注入是该原则的一种实现方式。</td>\n</tr>\n</tbody></table>\n<p><strong>GRASP</strong>中提到的模式和原则包括有控制器（controller）、创建者（creator）、中介（indirection）、信息专家（information expert）、低耦合性（low coupling）、高内聚性（high cohesion）、多态（polymorphism）、保护变化（protected variations）和纯虚构（pure Fabrication）[2]</p>\n</blockquote>\n<ul>\n<li><p>函数式编程（纯函数、不变性、递归……）</p>\n</li>\n<li><p><a href=\"http://amzotti.github.io/programming%20paradigms/2015/02/13/what-is-the-difference-between-procedural-function-imperative-and-declarative-programming-paradigms/\">声明式与命令式编程</a></p>\n<blockquote>\n<p>声明式和命令式编程范例只不过是描述在不同抽象层次上编码的流行词。声明式编程关注的是“做什么，而不是如何做”，而命令式编程则关注的是“如何做，而不是做什么”。声明式编程是在比命令式编程更高的抽象层次上进行编程。两者都有其适用的地方，例如在网页开发中使用框架时需要声明式编程，而在设计算法和其他底层需求时则需要命令式编程。</p>\n</blockquote>\n</li>\n</ul>\n<h4 id=\"数据结构\"><a href=\"#数据结构\" class=\"headerlink\" title=\"数据结构\"></a>数据结构</h4><ul>\n<li><p>基本数据结构（基本类型、数组、矩阵、对象…）</p>\n</li>\n<li><p>缓存和 memoization</p>\n<p>memoization 没有一个很好的词能翻译，大概意思就是通过存储函数调用的结果，并在再次使用相同输入调用函数时直接返回已存储的结果，从而加速计算逻辑。斐波那契数列就是一个使用 memoization 的例子</p>\n</li>\n<li><p>Hash codes、 tokens、编码（比如 Base64）</p>\n</li>\n<li><p><a href=\"https://stackoverflow.com/a/80113/1213497\">栈与堆内存</a> </p>\n<p>链接指向一则在 <a href=\"https://stackoverflow.com/questions/79923/what-and-where-are-the-stack-and-heap/80113#80113\">stackoverflow</a>  提出堆栈相关的诸多疑问，最高数回答解释了堆栈两种内存分配方式的基本概念、操作方式和性能差异，其中栈内存分配方式由于其后进先出的特性和近距离的存取模式，使得其在内存分配和回收上更加高效；而堆内存分配方式由于其动态和灵活的特性，对内存的管理相对复杂，但能够满足更多的内存需求</p>\n</li>\n</ul>\n<h4 id=\"代码整洁\"><a href=\"#代码整洁\" class=\"headerlink\" title=\"代码整洁\"></a>代码整洁</h4><ul>\n<li><p>懂得命名对代码的可读性的重要性</p>\n</li>\n<li><p>避免过长的方法和类，确保职责被划分到各个方法或者类中</p>\n</li>\n<li><p>遵循约定来管理项目结构</p>\n</li>\n<li><p>将复杂的布尔条件提取到命名良好的函数中</p>\n</li>\n<li><p>尽量编写尽可能自解释的代码（即通过阅读代码就能容易理解代码的功能）</p>\n</li>\n<li><p>良好的命名和轻量的文档而不是行内注释</p>\n<p><a href=\"https://www.codeproject.com/Articles/872073/Code-Comments-are-Lies\">代码注释通常可能会误导人</a>，因为它们经常被用作一种捷径，用来解释一段混乱的代码块的功能，而不是投入时间去重构它以提高其可读性。</p>\n<p>链接的文章主张编写清晰、自解释和可维护的代码，而不是过度依赖注释，同时也承认在某些特殊情况下，注释是有其必要性和价值的。</p>\n</li>\n<li><p>将文档编写为代码，理想情况下与代码一起，以便于维护（例如，在仓库中的“docs”文件夹中的 markdown 文件）</p>\n</li>\n<li><p>使用文档来描述“为什么”和“怎么做”（例如，目标、用例、组件、高级架构概述等）</p>\n</li>\n<li><p>在面向对象编程中，组合优于继承</p>\n</li>\n<li><p><a href=\"https://semver.org/\">Follow 语义化</a></p>\n</li>\n<li><p>了解TDD及其实践（例如，“红色，绿色，重构”）</p>\n<blockquote>\n<p><strong>TDD</strong>(测试驱动开发)是戴两顶帽子思考的开发方式：先戴上实现功能的帽子，在测试的辅助下，快速实现其功能；再戴上测试驱动开发的帽子，在测试的保护下，通过去除冗余的代码，提高代码品质。测试驱动着整个开发过程：首先，驱动代码的设计和功能的实现；其后，驱动代码的再设计和重构。</p>\n<ul>\n<li><p>红色：首先编写一个针对新功能的测试用例，此时由于功能尚未实现，测试用例将无法通过（失败，显示红色）</p>\n</li>\n<li><p>绿色：接下来编写功能代码，使得测试用例能够通过（成功，显示绿色）。在这个阶段，重点是让测试通过，而不是编写完美的代码。</p>\n</li>\n<li><p>重构：在测试用例通过后，对功能代码进行优化和重构，提高代码质量，同时确保测试用例仍然能够通过。</p>\n</li>\n</ul>\n</blockquote>\n</li>\n</ul>\n<h4 id=\"源码管理能力\"><a href=\"#源码管理能力\" class=\"headerlink\" title=\"源码管理能力\"></a>源码管理能力</h4><ul>\n<li><p>CVS（控制版本系统）&#x2F; SCM（源代码管理）基础知识：分支、标签、集中式与分散式等</p>\n</li>\n<li><p>SCM与仓库管理&#x2F;托管的区别（即<a href=\"https://stackoverflow.com/a/13321586\">Git与GitHub之间的区别</a>）</p>\n</li>\n<li><p>理解版本化的重要性</p>\n</li>\n<li><p>Commit 最佳实践</p>\n<ul>\n<li><p><a href=\"https://lucasr.org/2011/01/29/micro-commits/\">微提交</a> &#x2F;原子提交，良好的描述等</p>\n</li>\n<li><p><a href=\"https://www.conventionalcommits.org/en/v1.0.0/\">常规提交</a></p>\n</li>\n</ul>\n</li>\n<li><p>功能分支（短期）</p>\n</li>\n<li><p>基于主干的开发</p>\n</li>\n<li><p>依赖管理（包管理器的重要性，依赖地狱的风险等）</p>\n</li>\n</ul>\n<h4 id=\"技术合作\"><a href=\"#技术合作\" class=\"headerlink\" title=\"技术合作\"></a>技术合作</h4><ul>\n<li><p><a href=\"https://blog.github.com/2015-01-21-how-to-write-the-perfect-pull-request/\">代码 review 最佳实践</a></p>\n<ul>\n<li>一句话来说就是：在执行代码审查时关注相关部分。目的是学习，而不是指责。</li>\n</ul>\n</li>\n<li><p><a href=\"https://martinfowler.com/articles/on-pair-programming.html\">结对编程</a></p>\n<p>这篇文章主要讨论了结对编程（Pair Programming）的相关主题，包括其风格、时间管理、轮换策略、日常规划、物理环境设置、远程配对等方面。还探讨了结对编程的好处和挑战，以及如何说服管理者和同事采用这种方法。此外，文章还涉及了一些与配对编程相关的细节和常见问题</p>\n</li>\n</ul>\n<h4 id=\"DevOps-实践\"><a href=\"#DevOps-实践\" class=\"headerlink\" title=\"DevOps 实践\"></a>DevOps 实践</h4><ul>\n<li><p>自动化构建</p>\n</li>\n<li><p>构件仓库和镜像注册表</p>\n</li>\n<li><p>编写自动化测试</p>\n</li>\n<li><p>单元、集成和端到端（e2e）测试之间的区别</p>\n</li>\n<li><p>测试金字塔</p>\n</li>\n<li><p>持续集成</p>\n</li>\n<li><p>持续交付与持续部署</p>\n</li>\n<li><p>功能 Flag 和功能开关</p>\n</li>\n</ul>\n<h4 id=\"通用技术知识\"><a href=\"#通用技术知识\" class=\"headerlink\" title=\"通用技术知识\"></a>通用技术知识</h4><h5 id=\"语言理论知识\"><a href=\"#语言理论知识\" class=\"headerlink\" title=\"语言理论知识\"></a>语言理论知识</h5><ul>\n<li><p>正则表达式（regex）</p>\n</li>\n<li><p>编译型与解释型语言</p>\n</li>\n<li><p><a href=\"https://medium.com/@cpave3/understanding-types-static-vs-dynamic-strong-vs-weak-88a4e1f0ed5f\">动态与静态 &amp; 弱类型与强类型语言类型</a></p>\n</li>\n</ul>\n<h5 id=\"优化\"><a href=\"#优化\" class=\"headerlink\" title=\"优化\"></a>优化</h5><ul>\n<li><p>懒加载</p>\n</li>\n<li><p><a href=\"https://en.wikipedia.org/wiki/Profiling_(computer_programming)\">性能分析</a></p>\n</li>\n</ul>\n<h5 id=\"并发\"><a href=\"#并发\" class=\"headerlink\" title=\"并发\"></a>并发</h5><ul>\n<li><p>竞态条件</p>\n</li>\n<li><p>死锁</p>\n</li>\n<li><p>互斥</p>\n</li>\n</ul>\n<h3 id=\"特定领域技术知识\"><a href=\"#特定领域技术知识\" class=\"headerlink\" title=\"特定领域技术知识\"></a>特定领域技术知识</h3><p>在某些情况下，您可能希望工程师已经了解某些特定领域，例如前端、后端、架构、基础设施或安全方面。在这些情况下，还有一些跨框架的概念和原则，可用于推动针对每个领域的特定技术知识的内容。</p>\n<h4 id=\"前端开发\"><a href=\"#前端开发\" class=\"headerlink\" title=\"前端开发\"></a>前端开发</h4><ul>\n<li><p>API通信（不同的架构标准，数据如何传输…）</p>\n</li>\n<li><p>DOM（定义，理解，虚拟DOM…）</p>\n</li>\n<li><p>浏览器事件</p>\n</li>\n<li><p>响应式设计（目的，优点，渐进增强…）</p>\n</li>\n<li><p>客户端渲染（CSR）与服务器端渲染（SSR）</p>\n</li>\n<li><p>分页</p>\n</li>\n<li><p>状态管理（相关问题，无状态方法…）</p>\n</li>\n<li><p>MVC 和相关的衍生品</p>\n</li>\n<li><p>WebSockets 网络通信协议</p>\n</li>\n</ul>\n<h4 id=\"后端开发\"><a href=\"#后端开发\" class=\"headerlink\" title=\"后端开发\"></a>后端开发</h4><ul>\n<li><p>API设计（不同的架构标准，数据如何传输…）</p>\n</li>\n<li><p><a href=\"https://en.wikipedia.org/wiki/Message_broker\">消息代理</a></p>\n</li>\n<li><p>关系型数据库（它们是如何工作的，基本概念…）</p>\n</li>\n<li><p>非关系型数据库</p>\n</li>\n<li><p>数据库设计</p>\n</li>\n<li><p>ORM（对象关系映射）</p>\n</li>\n<li><p>批处理进程 &#x2F; 定时任务</p>\n</li>\n<li><p>会话处理</p>\n</li>\n<li><p><a href=\"https://lti.umuc.edu/contentadaptor/topics/byid/db0a8c4f-f738-4674-9f60-b75323cdb07f\">错误处理、审查、日志记录</a></p>\n</li>\n</ul>\n<h4 id=\"架构\"><a href=\"#架构\" class=\"headerlink\" title=\"架构\"></a>架构</h4><ul>\n<li><p>API</p>\n<ul>\n<li><p>标准协议：REST &#x2F; SOAP </p>\n</li>\n<li><p>安全性（例如拦截机器人，控制账户接管攻击等）</p>\n</li>\n<li><p>针对第三方服务故障的弹性橱窗（例如断路器）</p>\n</li>\n</ul>\n</li>\n<li><p>外部可配置化</p>\n</li>\n<li><p><a href=\"https://www.romenrg.com/blog/2019/12/31/everything-as-code/\">万物皆代码（即配置即代码，基础设施即代码，文档即代码…）</a></p>\n</li>\n<li><p>单体应用与微服务</p>\n</li>\n<li><p>领域驱动设计（DDD）</p>\n</li>\n<li><p>六边形架构</p>\n</li>\n<li><p>服务 Mesh</p>\n</li>\n<li><p>相关的互联网协议及其用法（如 HTTP, HTTPS, TCP, UDP, LDAP, SSH, SMTP…）</p>\n</li>\n<li><p><a href=\"https://en.wikipedia.org/wiki/Data_modeling\">数据建模</a></p>\n</li>\n</ul>\n<h4 id=\"基础设施\"><a href=\"#基础设施\" class=\"headerlink\" title=\"基础设施\"></a>基础设施</h4><ul>\n<li><p>虚拟机与容器</p>\n</li>\n<li><p>进程与线程</p>\n</li>\n<li><p>控制器-代理&#x2F;主副本模式</p>\n</li>\n<li><p>C&#x2F;S模式</p>\n</li>\n<li><p>IAAS, PAAS, SASS</p>\n</li>\n<li><p>Web服务器</p>\n</li>\n<li><p>反向代理</p>\n</li>\n<li><p>负载均衡</p>\n</li>\n<li><p>冗余</p>\n</li>\n<li><p>延迟</p>\n</li>\n<li><p>监控</p>\n</li>\n<li><p><a href=\"https://docs.honeycomb.io/learning-about-observability/intro-to-observability/\">可监控性</a></p>\n</li>\n</ul>\n<h4 id=\"安全\"><a href=\"#安全\" class=\"headerlink\" title=\"安全\"></a>安全</h4><ul>\n<li><p>身份和访问管理（IAM）</p>\n<ul>\n<li><p>认证（JWT, SSO）</p>\n</li>\n<li><p>授权（RBAC, ABAC）</p>\n</li>\n</ul>\n</li>\n<li><p>公钥密码系统（例如RSA）</p>\n</li>\n<li><p>加密协议（TLS, SSL）</p>\n</li>\n<li><p>最小权限原则</p>\n</li>\n<li><p>DoS &#x2F; DDoS</p>\n</li>\n<li><p>SQL 注入</p>\n</li>\n<li><p>中间人攻击</p>\n</li>\n<li><p>XSS（跨站脚本攻击） 和 CSRF（跨站请求伪造）</p>\n</li>\n</ul>\n","categories":[],"tags":[],"api":"api/posts/2024/07/09/软件开发人员的常青技能.json"},{"title":"UTF-8字符编码相关","slug":"关于Windows中文字符乱码","date":"2024-04-11T06:23:00.000Z","updated":"2025-05-20T11:46:57.000Z","comments":true,"url":"2024/04/11/关于Windows中文字符乱码/","excerpt":"<p>最近在 Windows 上开发一些逻辑的时候遇到一些关于中文的坑，中文路径会乱码，是由于 Window 系统默认的编码格式是 <strong>GBK</strong>，而传入的参数编码格式是 <strong>UTF-8</strong>，导致整个程序出错。后续使用了&#96;&#96;MultiByteToWideChar<code> 和</code>WideCharToMultiByte&#96; 方法对编码进行一次改变，从而避免了这个问题的产生。但不了解相关原因，经过一番学习，对相关的概念进行一些简单的总结，并对一些 api  的实现源码进行分析。</p>\n<h3 id=\"ASCII-码\"><a href=\"#ASCII-码\" class=\"headerlink\" title=\"ASCII 码\"></a>ASCII 码</h3><p> ASCII ( American Standard Code for Information Interchange)<br> 256个符号，从 00000000 到 11111111    </p>\n<h3 id=\"ANSI\"><a href=\"#ANSI\" class=\"headerlink\" title=\"ANSI\"></a>ANSI</h3><p>ANSI（American National Standards Institute，美国国家标准协会）编码：ANSI 编码是一种基于 8 位的字符编码。它包含了 128 个美国英语字符和其他 128 个特殊字符，共 256 个字符。ANSI 编码主要用于表示英语字符，但它的局限性在于无法表示其他语言的字符。为了解决这个问题，各国家和地区分别制定了自己的 ANSI 编码标准，但这又引入了新的问题，即不同编码之间的互不兼容。</p>\n<p>​       美国和西欧：Windows-1252<br>​       中文（简体）：GB2312 或 GBK<br>​       中文（繁体）：Big5<br>​       日文：Shift-JIS<br>​       韩文：EUC-KR   </p>\n<h3 id=\"Unicode\"><a href=\"#Unicode\" class=\"headerlink\" title=\"Unicode\"></a>Unicode</h3><p>为了解决字符编码之间的兼容性问题，Unicode 标准应运而生。Unicode 是一种包含世界上大多数字符的编码方案，它为每个字符分配一个唯一的数字（称为码点），无论在任何平台、程序或语言中，都可以表示这些字符。Unicode 有多种实现方式，如 UTF-8、UTF-16 和 UTF-32。UTF-8 是最常用的 Unicode 实现方式，它是一种变长编码，可以使用 1 到 4 个字节来表示一个字符，这使得它在存储和传输方面更加高效</p>\n<p>  “FE FF” 是 Unicode 字符串的字节顺序标记（Byte Order Mark，简称 BOM），用于表示字符串的字节顺序<br>  Unicode Little-Endian，”FF FE”<br>  Unicode Big-Endian，”FE FF”</p>\n<h3 id=\"UTF-8\"><a href=\"#UTF-8\" class=\"headerlink\" title=\"UTF-8\"></a>UTF-8</h3><p>UTF-8 是 Unicode 的实现方式之一  ，是一种变长编码，它使用 1 到 4 个字节（8 位）来表示一个字符</p>\n<p><strong>单字节</strong>   所有的ASCII 字符<br><strong>二字节</strong>  带有附加符号的拉丁文、希腊文、西里尔字母、亚美尼亚语、希伯来文、阿拉伯文、叙利亚文及它拿字母则需要二个字节编码                </p>\n<p><strong>三字节</strong> 基本等同于GBK，含21000多个汉字 </p>\n<p><strong>四字节</strong> 中日韩超大字符集里面的汉字，有5万多个</p>\n<p><strong>UTF-8编码对照表</strong></p>\n<table>\n<thead>\n<tr>\n<th>Unicode 符号范围   (十六进制)</th>\n<th>UTF-8编码方式（二进制）</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>0000 0000 ~ 0000 007F</td>\n<td>0xxxxxxx</td>\n</tr>\n<tr>\n<td>0000 0080 ~ 0000 07FF</td>\n<td>110xxxxx 10xxxxxx</td>\n</tr>\n<tr>\n<td>0000 0800 ~ 0000 FFFF</td>\n<td>1110xxxx 10xxxxxx 10xxxxxx</td>\n</tr>\n<tr>\n<td>0001 0000 ~ 0010 FFFF</td>\n<td>11110xxx 10xxxxxx 10xxxxxx 10xxxxxx</td>\n</tr>\n</tbody></table>\n<h3 id=\"源码阅读：Java-String-toUtf8\"><a href=\"#源码阅读：Java-String-toUtf8\" class=\"headerlink\" title=\"源码阅读：Java String toUtf8\"></a>源码阅读：Java String toUtf8</h3><p> Java 的 String 默认用 UTF-16 存储数据，String 类的方法<code>.getBytes(StandardCharsets.UTF_8)</code> 将指定的字符集将字符串编码为 byte 序列，并将结果存储到一个新的 byte 数组中。</p>\n<p>其主要逻辑在:<a href=\"https://android.googlesource.com/platform/libcore/+/master/luni/src/main/java/libcore/util/CharsetUtils.java#46\">CharsetUtils.java#toUtf8Bytes</a></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">native</span> <span class=\"type\">byte</span>[] toUtf8Bytes(String s, <span class=\"type\">int</span> offset, <span class=\"type\">int</span> length);</span><br></pre></td></tr></table></figure>\n\n<p>对应的最终实现：<a href=\"https://android.googlesource.com/platform/libcore/+/3e8abdd9bdca823a635aac3adacf71ef227b18e1/luni/src/main/native/java_nio_charset_Charsets.cpp#183\">java_nio_charset_Charsets.cpp#Charsets_toUtf8Bytes</a> </p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">static</span> jbyteArray <span class=\"title\">Charsets_toUtf8Bytes</span><span class=\"params\">(JNIEnv* env, jclass, jcharArray javaChars, jint offset, jint length)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// ....此处省略 一些检查逻辑</span></span><br><span class=\"line\">    <span class=\"type\">const</span> <span class=\"type\">int</span> end = offset + length;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = offset; i &lt; end; ++i) &#123;</span><br><span class=\"line\">        jint ch = chars[i];</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (ch &lt; <span class=\"number\">0x80</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 单字节直接放进去</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!out.<span class=\"built_in\">append</span>(ch)) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (ch &lt; <span class=\"number\">0x800</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 双字节</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!out.<span class=\"built_in\">append</span>((ch &gt;&gt; <span class=\"number\">6</span>) | <span class=\"number\">0xc0</span>) || !out.<span class=\"built_in\">append</span>((ch &amp; <span class=\"number\">0x3f</span>) | <span class=\"number\">0x80</span>)) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"built_in\">U16_IS_SURROGATE</span>(ch)) &#123;</span><br><span class=\"line\">          \t<span class=\"comment\">// ....此处省略 UTF-16 代理字符串相关的逻辑</span></span><br><span class=\"line\">            ch = <span class=\"built_in\">U16_GET_SUPPLEMENTARY</span>(high, low);</span><br><span class=\"line\">            <span class=\"comment\">// 四字节 </span></span><br><span class=\"line\">            jbyte b1 = (ch &gt;&gt; <span class=\"number\">18</span>) | <span class=\"number\">0xf0</span>;</span><br><span class=\"line\">            jbyte b2 = ((ch &gt;&gt; <span class=\"number\">12</span>) &amp; <span class=\"number\">0x3f</span>) | <span class=\"number\">0x80</span>;</span><br><span class=\"line\">            jbyte b3 = ((ch &gt;&gt; <span class=\"number\">6</span>) &amp; <span class=\"number\">0x3f</span>) | <span class=\"number\">0x80</span>;</span><br><span class=\"line\">            jbyte b4 = (ch &amp; <span class=\"number\">0x3f</span>) | <span class=\"number\">0x80</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!out.<span class=\"built_in\">append</span>(b1) || !out.<span class=\"built_in\">append</span>(b2) || !out.<span class=\"built_in\">append</span>(b3) || !out.<span class=\"built_in\">append</span>(b4)) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 三字节.</span></span><br><span class=\"line\">            jbyte b1 = (ch &gt;&gt; <span class=\"number\">12</span>) | <span class=\"number\">0xe0</span>;</span><br><span class=\"line\">            jbyte b2 = ((ch &gt;&gt; <span class=\"number\">6</span>) &amp; <span class=\"number\">0x3f</span>) | <span class=\"number\">0x80</span>;</span><br><span class=\"line\">            jbyte b3 = (ch &amp; <span class=\"number\">0x3f</span>) | <span class=\"number\">0x80</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!out.<span class=\"built_in\">append</span>(b1) || !out.<span class=\"built_in\">append</span>(b2) || !out.<span class=\"built_in\">append</span>(b3)) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> out.<span class=\"built_in\">toByteArray</span>();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>整体的逻辑非常的好理解：判断输入值的区间，并分成单双三四字节的处理逻辑，其中有处理 UTF-16 代理字符串相关的逻辑此处忽略，可以了解<a href=\"https://learn.microsoft.com/zh-cn/windows/win32/intl/surrogates-and-supplementary-characters\">代理项和增补字符</a>。对应单字节符号处理，直接将原始值返回即可，其他的字节就一个一个地获取，这里分析一下对于双字节的逻辑处理。获取第一个字节的逻辑为：<code>(ch &gt;&gt; 6) | 0xc0 </code>第二个字节逻辑为 <code>(ch &amp; 0x3f) | 0x80</code> </p>\n<ul>\n<li><p><code>(ch &gt;&gt; 6) | 0xc0</code></p>\n<p>第一个字节的前两位是 <code>11</code>（十六进制中的 <code>0xc0</code>），后面的 5 位是 Unicode 码点的高 5 位</p>\n</li>\n<li><p><code>(ch &amp; 0x3f) | 0x80</code></p>\n<p>第二个字节的前两位是 <code>10</code>（十六进制中的 <code>0x80</code>），后面的 6 位是 Unicode 码点的低 6 位</p>\n</li>\n</ul>\n<p>举例，希腊符号  <code>ε</code>(epsilon) 在 UTF-8 编码里面是用双字节表示， Unicode 为 <code>0x03B5</code>  对应二进制数据：<code>0000001110110101</code>，计算流程如下所示：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"># ε 0x03B5 to UTF-8 </span><br><span class=\"line\"></span><br><span class=\"line\"># 第一个字节 (ch &gt;&gt; 6) | 0xc0</span><br><span class=\"line\">0000001110110101 &gt;&gt; 6</span><br><span class=\"line\">      0000001110 | 0xc0 (11000000)</span><br><span class=\"line\">        11000000</span><br><span class=\"line\">             ||</span><br><span class=\"line\">        11001110</span><br><span class=\"line\">            0xCE</span><br><span class=\"line\"></span><br><span class=\"line\"># 第二个字节 (ch &amp; 0x3f) | 0x80</span><br><span class=\"line\">0000001110110101 &amp; 0x3f (111111)</span><br><span class=\"line\">          111111</span><br><span class=\"line\">          110101 | 0x80 (10000000)</span><br><span class=\"line\">        10000000</span><br><span class=\"line\">              ||</span><br><span class=\"line\">        10110101</span><br><span class=\"line\">            0xB5</span><br></pre></td></tr></table></figure>\n\n<p>从而计算出  <code>ε</code> 对应的 UTF-8 Encoding为<code>0xCE 0xB5</code></p>\n<h3 id=\"“锟斤拷”和“烫”\"><a href=\"#“锟斤拷”和“烫”\" class=\"headerlink\" title=\"“锟斤拷”和“烫”\"></a>“锟斤拷”和“烫”</h3><p><code>“锟斤拷”</code>通常发生在UTF-8 到 GBK 编码的转换中，在 UTF-8 编码中，”0xEF 0xBF 0xBD” 是一个特殊的字符，表示 REPLACEMENT CHARACTER（替换字符），当解码器在解码字节序列时遇到无法识别的字节或无效的编码时，通常会用 REPLACEMENT CHARACTER（U+FFFD）替换这些无效的字节 ，”0xEF 0xBF 0xBD” 在 GBK 里面则编码成 “锟斤拷”。</p>\n<p><code>“烫”</code> 则是由于在 Windows 操作系统中，开发者在使用调试器调试程序时，会发现未初始化的内存通常会被填充为0xCC，而”0xCC” 在 GBK 里面则编码成“烫”。</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>本文主要讨论了字符编码的一些基本概念和原理，包括 ASCII、ANSI、Unicode 和 UTF-8 编码，文章分析了 Java String 类的<code>.getBytes(StandardCharsets.UTF_8)</code>方法的实现源码，解释了将 Unicode 字符串转换为 UTF-8 编码字节序列的过程，最后介绍了一下 “锟斤拷”和”烫”为什么会被展示。</p>\n","cover":null,"images":[],"content":"<p>最近在 Windows 上开发一些逻辑的时候遇到一些关于中文的坑，中文路径会乱码，是由于 Window 系统默认的编码格式是 <strong>GBK</strong>，而传入的参数编码格式是 <strong>UTF-8</strong>，导致整个程序出错。后续使用了&#96;&#96;MultiByteToWideChar<code> 和</code>WideCharToMultiByte&#96; 方法对编码进行一次改变，从而避免了这个问题的产生。但不了解相关原因，经过一番学习，对相关的概念进行一些简单的总结，并对一些 api  的实现源码进行分析。</p>\n<h3 id=\"ASCII-码\"><a href=\"#ASCII-码\" class=\"headerlink\" title=\"ASCII 码\"></a>ASCII 码</h3><p> ASCII ( American Standard Code for Information Interchange)<br> 256个符号，从 00000000 到 11111111    </p>\n<h3 id=\"ANSI\"><a href=\"#ANSI\" class=\"headerlink\" title=\"ANSI\"></a>ANSI</h3><p>ANSI（American National Standards Institute，美国国家标准协会）编码：ANSI 编码是一种基于 8 位的字符编码。它包含了 128 个美国英语字符和其他 128 个特殊字符，共 256 个字符。ANSI 编码主要用于表示英语字符，但它的局限性在于无法表示其他语言的字符。为了解决这个问题，各国家和地区分别制定了自己的 ANSI 编码标准，但这又引入了新的问题，即不同编码之间的互不兼容。</p>\n<p>​       美国和西欧：Windows-1252<br>​       中文（简体）：GB2312 或 GBK<br>​       中文（繁体）：Big5<br>​       日文：Shift-JIS<br>​       韩文：EUC-KR   </p>\n<h3 id=\"Unicode\"><a href=\"#Unicode\" class=\"headerlink\" title=\"Unicode\"></a>Unicode</h3><p>为了解决字符编码之间的兼容性问题，Unicode 标准应运而生。Unicode 是一种包含世界上大多数字符的编码方案，它为每个字符分配一个唯一的数字（称为码点），无论在任何平台、程序或语言中，都可以表示这些字符。Unicode 有多种实现方式，如 UTF-8、UTF-16 和 UTF-32。UTF-8 是最常用的 Unicode 实现方式，它是一种变长编码，可以使用 1 到 4 个字节来表示一个字符，这使得它在存储和传输方面更加高效</p>\n<p>  “FE FF” 是 Unicode 字符串的字节顺序标记（Byte Order Mark，简称 BOM），用于表示字符串的字节顺序<br>  Unicode Little-Endian，”FF FE”<br>  Unicode Big-Endian，”FE FF”</p>\n<h3 id=\"UTF-8\"><a href=\"#UTF-8\" class=\"headerlink\" title=\"UTF-8\"></a>UTF-8</h3><p>UTF-8 是 Unicode 的实现方式之一  ，是一种变长编码，它使用 1 到 4 个字节（8 位）来表示一个字符</p>\n<p><strong>单字节</strong>   所有的ASCII 字符<br><strong>二字节</strong>  带有附加符号的拉丁文、希腊文、西里尔字母、亚美尼亚语、希伯来文、阿拉伯文、叙利亚文及它拿字母则需要二个字节编码                </p>\n<p><strong>三字节</strong> 基本等同于GBK，含21000多个汉字 </p>\n<p><strong>四字节</strong> 中日韩超大字符集里面的汉字，有5万多个</p>\n<p><strong>UTF-8编码对照表</strong></p>\n<table>\n<thead>\n<tr>\n<th>Unicode 符号范围   (十六进制)</th>\n<th>UTF-8编码方式（二进制）</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>0000 0000 ~ 0000 007F</td>\n<td>0xxxxxxx</td>\n</tr>\n<tr>\n<td>0000 0080 ~ 0000 07FF</td>\n<td>110xxxxx 10xxxxxx</td>\n</tr>\n<tr>\n<td>0000 0800 ~ 0000 FFFF</td>\n<td>1110xxxx 10xxxxxx 10xxxxxx</td>\n</tr>\n<tr>\n<td>0001 0000 ~ 0010 FFFF</td>\n<td>11110xxx 10xxxxxx 10xxxxxx 10xxxxxx</td>\n</tr>\n</tbody></table>\n<h3 id=\"源码阅读：Java-String-toUtf8\"><a href=\"#源码阅读：Java-String-toUtf8\" class=\"headerlink\" title=\"源码阅读：Java String toUtf8\"></a>源码阅读：Java String toUtf8</h3><p> Java 的 String 默认用 UTF-16 存储数据，String 类的方法<code>.getBytes(StandardCharsets.UTF_8)</code> 将指定的字符集将字符串编码为 byte 序列，并将结果存储到一个新的 byte 数组中。</p>\n<p>其主要逻辑在:<a href=\"https://android.googlesource.com/platform/libcore/+/master/luni/src/main/java/libcore/util/CharsetUtils.java#46\">CharsetUtils.java#toUtf8Bytes</a></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">native</span> <span class=\"type\">byte</span>[] toUtf8Bytes(String s, <span class=\"type\">int</span> offset, <span class=\"type\">int</span> length);</span><br></pre></td></tr></table></figure>\n\n<p>对应的最终实现：<a href=\"https://android.googlesource.com/platform/libcore/+/3e8abdd9bdca823a635aac3adacf71ef227b18e1/luni/src/main/native/java_nio_charset_Charsets.cpp#183\">java_nio_charset_Charsets.cpp#Charsets_toUtf8Bytes</a> </p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">static</span> jbyteArray <span class=\"title\">Charsets_toUtf8Bytes</span><span class=\"params\">(JNIEnv* env, jclass, jcharArray javaChars, jint offset, jint length)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// ....此处省略 一些检查逻辑</span></span><br><span class=\"line\">    <span class=\"type\">const</span> <span class=\"type\">int</span> end = offset + length;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = offset; i &lt; end; ++i) &#123;</span><br><span class=\"line\">        jint ch = chars[i];</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (ch &lt; <span class=\"number\">0x80</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 单字节直接放进去</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!out.<span class=\"built_in\">append</span>(ch)) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (ch &lt; <span class=\"number\">0x800</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 双字节</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!out.<span class=\"built_in\">append</span>((ch &gt;&gt; <span class=\"number\">6</span>) | <span class=\"number\">0xc0</span>) || !out.<span class=\"built_in\">append</span>((ch &amp; <span class=\"number\">0x3f</span>) | <span class=\"number\">0x80</span>)) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"built_in\">U16_IS_SURROGATE</span>(ch)) &#123;</span><br><span class=\"line\">          \t<span class=\"comment\">// ....此处省略 UTF-16 代理字符串相关的逻辑</span></span><br><span class=\"line\">            ch = <span class=\"built_in\">U16_GET_SUPPLEMENTARY</span>(high, low);</span><br><span class=\"line\">            <span class=\"comment\">// 四字节 </span></span><br><span class=\"line\">            jbyte b1 = (ch &gt;&gt; <span class=\"number\">18</span>) | <span class=\"number\">0xf0</span>;</span><br><span class=\"line\">            jbyte b2 = ((ch &gt;&gt; <span class=\"number\">12</span>) &amp; <span class=\"number\">0x3f</span>) | <span class=\"number\">0x80</span>;</span><br><span class=\"line\">            jbyte b3 = ((ch &gt;&gt; <span class=\"number\">6</span>) &amp; <span class=\"number\">0x3f</span>) | <span class=\"number\">0x80</span>;</span><br><span class=\"line\">            jbyte b4 = (ch &amp; <span class=\"number\">0x3f</span>) | <span class=\"number\">0x80</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!out.<span class=\"built_in\">append</span>(b1) || !out.<span class=\"built_in\">append</span>(b2) || !out.<span class=\"built_in\">append</span>(b3) || !out.<span class=\"built_in\">append</span>(b4)) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 三字节.</span></span><br><span class=\"line\">            jbyte b1 = (ch &gt;&gt; <span class=\"number\">12</span>) | <span class=\"number\">0xe0</span>;</span><br><span class=\"line\">            jbyte b2 = ((ch &gt;&gt; <span class=\"number\">6</span>) &amp; <span class=\"number\">0x3f</span>) | <span class=\"number\">0x80</span>;</span><br><span class=\"line\">            jbyte b3 = (ch &amp; <span class=\"number\">0x3f</span>) | <span class=\"number\">0x80</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!out.<span class=\"built_in\">append</span>(b1) || !out.<span class=\"built_in\">append</span>(b2) || !out.<span class=\"built_in\">append</span>(b3)) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> out.<span class=\"built_in\">toByteArray</span>();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>整体的逻辑非常的好理解：判断输入值的区间，并分成单双三四字节的处理逻辑，其中有处理 UTF-16 代理字符串相关的逻辑此处忽略，可以了解<a href=\"https://learn.microsoft.com/zh-cn/windows/win32/intl/surrogates-and-supplementary-characters\">代理项和增补字符</a>。对应单字节符号处理，直接将原始值返回即可，其他的字节就一个一个地获取，这里分析一下对于双字节的逻辑处理。获取第一个字节的逻辑为：<code>(ch &gt;&gt; 6) | 0xc0 </code>第二个字节逻辑为 <code>(ch &amp; 0x3f) | 0x80</code> </p>\n<ul>\n<li><p><code>(ch &gt;&gt; 6) | 0xc0</code></p>\n<p>第一个字节的前两位是 <code>11</code>（十六进制中的 <code>0xc0</code>），后面的 5 位是 Unicode 码点的高 5 位</p>\n</li>\n<li><p><code>(ch &amp; 0x3f) | 0x80</code></p>\n<p>第二个字节的前两位是 <code>10</code>（十六进制中的 <code>0x80</code>），后面的 6 位是 Unicode 码点的低 6 位</p>\n</li>\n</ul>\n<p>举例，希腊符号  <code>ε</code>(epsilon) 在 UTF-8 编码里面是用双字节表示， Unicode 为 <code>0x03B5</code>  对应二进制数据：<code>0000001110110101</code>，计算流程如下所示：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"># ε 0x03B5 to UTF-8 </span><br><span class=\"line\"></span><br><span class=\"line\"># 第一个字节 (ch &gt;&gt; 6) | 0xc0</span><br><span class=\"line\">0000001110110101 &gt;&gt; 6</span><br><span class=\"line\">      0000001110 | 0xc0 (11000000)</span><br><span class=\"line\">        11000000</span><br><span class=\"line\">             ||</span><br><span class=\"line\">        11001110</span><br><span class=\"line\">            0xCE</span><br><span class=\"line\"></span><br><span class=\"line\"># 第二个字节 (ch &amp; 0x3f) | 0x80</span><br><span class=\"line\">0000001110110101 &amp; 0x3f (111111)</span><br><span class=\"line\">          111111</span><br><span class=\"line\">          110101 | 0x80 (10000000)</span><br><span class=\"line\">        10000000</span><br><span class=\"line\">              ||</span><br><span class=\"line\">        10110101</span><br><span class=\"line\">            0xB5</span><br></pre></td></tr></table></figure>\n\n<p>从而计算出  <code>ε</code> 对应的 UTF-8 Encoding为<code>0xCE 0xB5</code></p>\n<h3 id=\"“锟斤拷”和“烫”\"><a href=\"#“锟斤拷”和“烫”\" class=\"headerlink\" title=\"“锟斤拷”和“烫”\"></a>“锟斤拷”和“烫”</h3><p><code>“锟斤拷”</code>通常发生在UTF-8 到 GBK 编码的转换中，在 UTF-8 编码中，”0xEF 0xBF 0xBD” 是一个特殊的字符，表示 REPLACEMENT CHARACTER（替换字符），当解码器在解码字节序列时遇到无法识别的字节或无效的编码时，通常会用 REPLACEMENT CHARACTER（U+FFFD）替换这些无效的字节 ，”0xEF 0xBF 0xBD” 在 GBK 里面则编码成 “锟斤拷”。</p>\n<p><code>“烫”</code> 则是由于在 Windows 操作系统中，开发者在使用调试器调试程序时，会发现未初始化的内存通常会被填充为0xCC，而”0xCC” 在 GBK 里面则编码成“烫”。</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>本文主要讨论了字符编码的一些基本概念和原理，包括 ASCII、ANSI、Unicode 和 UTF-8 编码，文章分析了 Java String 类的<code>.getBytes(StandardCharsets.UTF_8)</code>方法的实现源码，解释了将 Unicode 字符串转换为 UTF-8 编码字节序列的过程，最后介绍了一下 “锟斤拷”和”烫”为什么会被展示。</p>\n","categories":[],"tags":[{"name":"UTF-8","slug":"UTF-8","api":"api/tags/UTF-8.json"}],"api":"api/posts/2024/04/11/关于Windows中文字符乱码.json"},{"title":"实现一个自定义 FFmpeg Filter","slug":"实现一个自定义FFmpeg-Filter","date":"2024-03-07T02:58:00.000Z","updated":"2025-05-20T11:46:57.000Z","comments":true,"url":"2024/03/07/实现一个自定义FFmpeg-Filter/","excerpt":"<p>此前在做  ffmpeg+某个第三库作为 filter 的集成，第三库是做AE特效相关的，与 ffmpeg 结合能让视频渲染效果大大提升。整体流程将第三方库作为 ffmpeg 的一个filter 形式进行结合，其中就涉及到 ffmpeg 的 filter 开发，本文即 对ffmpeg 的滤镜开发流程作一个总结。本文以实现一个视频垂直翻转的 filter 为例，ffmpeg 源码基于<a href=\"https://github.com/FFmpeg/FFmpeg/tree/release/6.1\">FFmpeg6.1</a> </p>\n<h2 id=\"实现自定义-Filter-流程\"><a href=\"#实现自定义-Filter-流程\" class=\"headerlink\" title=\"实现自定义 Filter 流程\"></a>实现自定义 Filter 流程</h2><ul>\n<li><p>编写 filter.c 文件</p>\n<p>一般视频滤镜以 vf_ 为前缀，视频滤镜以 af_ 为前缀，放在libavfilter目录下，参考其他 filter 代码逻辑，模块化配置相关参数，本文例以 vf_flip.c 实现视频的上下翻转</p>\n</li>\n<li><p>在 <code>libavfilter/allfilters.c</code> 注册</p>\n<p>例如：extern const AVFilter ff_vf_flip;  <code>ff_vf_flip</code>就是在 <code>vf_flip.c</code>的 filter 注册名称</p>\n</li>\n<li><p>修改 <code>libavfilter/Makefile</code> 添加编译配置： </p>\n<p>例如：OBJS-$(CONFIG_FLIP_FILTER)                   +&#x3D; vf_flip.o</p>\n</li>\n<li><p>编译打包</p>\n</li>\n</ul>\n<h2 id=\"编写-filter-c-文件\"><a href=\"#编写-filter-c-文件\" class=\"headerlink\" title=\"编写 filter.c 文件\"></a>编写 filter.c 文件</h2><h3 id=\"AVFilter主体\"><a href=\"#AVFilter主体\" class=\"headerlink\" title=\"AVFilter主体\"></a>AVFilter主体</h3><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">AVFilter</span> &#123;</span></span><br><span class=\"line\">  <span class=\"type\">const</span> <span class=\"type\">char</span> *name;</span><br><span class=\"line\">  <span class=\"type\">const</span> <span class=\"type\">char</span> *description;</span><br><span class=\"line\">  <span class=\"type\">const</span> AVFilterPad *inputs;</span><br><span class=\"line\">  <span class=\"type\">const</span> AVFilterPad *outputs;</span><br><span class=\"line\">  <span class=\"type\">const</span> AVClass *priv_class;</span><br><span class=\"line\">  <span class=\"type\">int</span> flags;</span><br><span class=\"line\">  <span class=\"type\">int</span> (*preinit)(AVFilterContext *ctx);</span><br><span class=\"line\">  <span class=\"type\">int</span> (*init)(AVFilterContext *ctx);</span><br><span class=\"line\">  <span class=\"type\">int</span> (*init_dict)(AVFilterContext *ctx, AVDictionary **options);</span><br><span class=\"line\">  <span class=\"type\">void</span> (*uninit)(AVFilterContext *ctx);</span><br><span class=\"line\">  <span class=\"type\">int</span> (*query_formats)(AVFilterContext *);</span><br><span class=\"line\">  <span class=\"type\">int</span> priv_size;   </span><br><span class=\"line\">  <span class=\"type\">int</span> flags_internal; </span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">AVFilter</span> *<span class=\"title\">next</span>;</span></span><br><span class=\"line\">  <span class=\"type\">int</span> (*process_command)(AVFilterContext *, <span class=\"type\">const</span> <span class=\"type\">char</span> *cmd, <span class=\"type\">const</span> <span class=\"type\">char</span> *arg, <span class=\"type\">char</span> *res, <span class=\"type\">int</span> res_len, <span class=\"type\">int</span> flags);</span><br><span class=\"line\">  <span class=\"type\">int</span> (*init_opaque)(AVFilterContext *ctx, <span class=\"type\">void</span> *opaque);</span><br><span class=\"line\">  <span class=\"type\">int</span> (*activate)(AVFilterContext *ctx);</span><br><span class=\"line\">&#125; AVFilter;</span><br></pre></td></tr></table></figure>\n\n<p>具体里面的属性作用可以参考：<a href=\"https://www.cnblogs.com/TaigaCon/p/10171464.html\">[ffmpeg] 定制滤波器</a>，可以根据需求实现里面的相关函数，接下来以一个最简单的 Filter 和一个较复杂一点的 Filter 举例。</p>\n<h3 id=\"最简单的-AVFilter\"><a href=\"#最简单的-AVFilter\" class=\"headerlink\" title=\"最简单的 AVFilter\"></a>最简单的 AVFilter</h3><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> &#123;</span></span><br><span class=\"line\">    <span class=\"type\">const</span> AVClass *<span class=\"class\"><span class=\"keyword\">class</span>;</span></span><br><span class=\"line\">&#125; NoopContext;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">int</span> <span class=\"title function_\">filter_frame</span><span class=\"params\">(AVFilterLink *link, AVFrame *frame)</span> &#123;</span><br><span class=\"line\">    av_log(<span class=\"literal\">NULL</span>, AV_LOG_INFO, <span class=\"string\">&quot;filter frame pts:%lld\\n&quot;</span>, frame-&gt;pts);</span><br><span class=\"line\">    NoopContext *noopContext = link-&gt;dst-&gt;priv;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ff_filter_frame(link-&gt;dst-&gt;outputs[<span class=\"number\">0</span>], frame);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">const</span> AVFilterPad noop_inputs[] = &#123;</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">                .name         = <span class=\"string\">&quot;default&quot;</span>,</span><br><span class=\"line\">                .type         = AVMEDIA_TYPE_VIDEO,</span><br><span class=\"line\">                .filter_frame = filter_frame,</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">const</span> AVFilterPad noop_outputs[] = &#123;</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">                .name = <span class=\"string\">&quot;default&quot;</span>,</span><br><span class=\"line\">                .type = AVMEDIA_TYPE_VIDEO,</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"type\">const</span> AVFilter ff_vf_noop = &#123;</span><br><span class=\"line\">        .name          = <span class=\"string\">&quot;noop&quot;</span>,</span><br><span class=\"line\">        .description   = NULL_IF_CONFIG_SMALL(<span class=\"string\">&quot;Pass the input video unchanged.&quot;</span>),</span><br><span class=\"line\">        .priv_size     = <span class=\"keyword\">sizeof</span>(NoopContext),</span><br><span class=\"line\">        FILTER_INPUTS(noop_inputs),</span><br><span class=\"line\">        FILTER_OUTPUTS(noop_outputs),</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>命令行运行：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">ffmpeg -i test.mp4 -vf &quot;noop&quot; noop.mp4</span><br></pre></td></tr></table></figure>\n\n<p> 正常输出文件（对原片没有做任何更改）,这个 filter 的作用是将输入的视频帧不做任何处理地传递给下一个过滤器，在处理每帧的时候会打印处理的 PTS，麻雀虽小五脏俱全，它包含了一个 AVFilter 基础的结构：</p>\n<ol>\n<li><p><strong><code>NoopContext</code></strong></p>\n<p>这是一个简单的结构体，包含一个指向 AVClass 的指针。在这个例子中，实际上没有使用到 NoopContext 结构体的任何成员，因为这个过滤器没有需要存储的私有数据。</p>\n</li>\n<li><p><strong><code>filter_frame</code></strong> </p>\n<p>这个函数的作用是处理输入的视频帧。在这个例子中，它只是打印帧的 PTS（Presentation Time Stamp，显示时间戳）并将帧传递给下一个过滤器，不对帧做任何修改。</p>\n</li>\n<li><p><strong><code>noop_inputs</code> 和 <code>noop_outputs</code></strong></p>\n<p>这两个数组定义了过滤器的输入和输出 Pad。在这个例子中，输入 Pad 类型为 AVMEDIA_TYPE_VIDEO，并关联了 <code>filter_frame</code> 函数。输出 Pad 也是 AVMEDIA_TYPE_VIDEO 类型，但没有关联任何函数，因为输出直接由 <code>filter_frame</code> 函数处理。</p>\n</li>\n<li><p><strong><code>ff_vf_noop</code></strong></p>\n<p>这是一个 AVFilter 结构体实例，包含了过滤器的名称、描述、私有数据大小以及输入和输出 Pad。在这个例子中，过滤器的名称为 “noop”，描述为 “Pass the input video unchanged.”，这也就是在执行：<code>ffmpeg -filters</code> 看到的 Filter描述内容。</p>\n</li>\n</ol>\n<p>接下来看一个稍微复杂的一个 AVFilter，实现一个视频的上下翻转</p>\n<h3 id=\"复杂一点的-AVFilter\"><a href=\"#复杂一点的-AVFilter\" class=\"headerlink\" title=\"复杂一点的 AVFilter\"></a>复杂一点的 AVFilter</h3><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">FlipContext</span> &#123;</span></span><br><span class=\"line\">    <span class=\"type\">const</span> AVClass *<span class=\"class\"><span class=\"keyword\">class</span>;</span></span><br><span class=\"line\">    <span class=\"type\">int</span> duration;</span><br><span class=\"line\">&#125; FlipContext;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> OFFSET(x) offsetof(FlipContext, x)</span></span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">const</span> AVOption flip_options[] = &#123;</span><br><span class=\"line\">        &#123;<span class=\"string\">&quot;duration&quot;</span>, <span class=\"string\">&quot;set flip duration&quot;</span>, OFFSET(duration), AV_OPT_TYPE_INT, &#123;.i64 = <span class=\"number\">0</span>&#125;, <span class=\"number\">0</span>, INT_MAX, .flags = AV_OPT_FLAG_FILTERING_PARAM&#125;,</span><br><span class=\"line\">        &#123;<span class=\"literal\">NULL</span>&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">static</span> av_cold <span class=\"type\">int</span> <span class=\"title function_\">flip_init</span><span class=\"params\">(AVFilterContext *ctx)</span> &#123;</span><br><span class=\"line\">    FlipContext *context = ctx-&gt;priv;</span><br><span class=\"line\">    av_log(<span class=\"literal\">NULL</span>, AV_LOG_ERROR, <span class=\"string\">&quot;Input duration: %d.\\n&quot;</span>, context-&gt;duration);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">static</span> av_cold <span class=\"type\">void</span> <span class=\"title function_\">flip_uninit</span><span class=\"params\">(AVFilterContext *ctx)</span> &#123;</span><br><span class=\"line\">    FlipContext *context = ctx-&gt;priv;</span><br><span class=\"line\">    <span class=\"comment\">// no-op 本例无需释放滤镜实例分配的内存、关闭文件、资源等</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 对输入的 AVFrame 进行翻转</span></span><br><span class=\"line\"><span class=\"type\">static</span> AVFrame *<span class=\"title function_\">flip_frame</span><span class=\"params\">(AVFilterContext *ctx, AVFrame *in_frame)</span> &#123;</span><br><span class=\"line\"> \t\tAVFilterLink *inlink = ctx-&gt;inputs[<span class=\"number\">0</span>];</span><br><span class=\"line\">    FlipContext *s = ctx-&gt;priv;</span><br><span class=\"line\">    <span class=\"type\">int64_t</span> pts = in_frame-&gt;pts;</span><br><span class=\"line\">    <span class=\"comment\">// 将时间戳（pts）转化以秒为单位的时间戳</span></span><br><span class=\"line\">    <span class=\"type\">float</span> time_s = TS2T(pts, inlink-&gt;time_base);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (time_s &gt; s-&gt;duration) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 超过对应的时间则直接输出in_frame</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> in_frame;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 创建输出帧并分配内存</span></span><br><span class=\"line\">    AVFrame *out_frame = av_frame_alloc();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!out_frame) &#123;</span><br><span class=\"line\">        av_frame_free(&amp;in_frame);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> out_frame;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 设置输出帧的属性</span></span><br><span class=\"line\">    out_frame-&gt;format = in_frame-&gt;format;</span><br><span class=\"line\">    out_frame-&gt;width = in_frame-&gt;width;</span><br><span class=\"line\">    out_frame-&gt;height = in_frame-&gt;height;</span><br><span class=\"line\">    out_frame-&gt;pts = in_frame-&gt;pts;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 分配输出帧的数据缓冲区</span></span><br><span class=\"line\">    <span class=\"type\">int</span> ret = av_frame_get_buffer(out_frame, <span class=\"number\">32</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ret &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        av_frame_free(&amp;in_frame);</span><br><span class=\"line\">        av_frame_free(&amp;out_frame);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> out_frame;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 这个示例仅适用于 YUV 格式的视频。对于其他格式（如 RGB）</span></span><br><span class=\"line\">    <span class=\"comment\">// 翻转输入帧的数据到输出帧</span></span><br><span class=\"line\">    <span class=\"comment\">// 翻转了 Y 分量，然后翻转了 U 和 V 分量</span></span><br><span class=\"line\">    <span class=\"comment\">//</span></span><br><span class=\"line\">    <span class=\"type\">uint8_t</span> *src_y = in_frame-&gt;data[<span class=\"number\">0</span>];</span><br><span class=\"line\">    <span class=\"type\">uint8_t</span> *src_u = in_frame-&gt;data[<span class=\"number\">1</span>];</span><br><span class=\"line\">    <span class=\"type\">uint8_t</span> *src_v = in_frame-&gt;data[<span class=\"number\">2</span>];</span><br><span class=\"line\">    <span class=\"type\">uint8_t</span> *dst_y = out_frame-&gt;data[<span class=\"number\">0</span>] + (in_frame-&gt;height - <span class=\"number\">1</span>) * out_frame-&gt;linesize[<span class=\"number\">0</span>];</span><br><span class=\"line\">    <span class=\"type\">uint8_t</span> *dst_u = out_frame-&gt;data[<span class=\"number\">1</span>] + (in_frame-&gt;height / <span class=\"number\">2</span> - <span class=\"number\">1</span>) * out_frame-&gt;linesize[<span class=\"number\">1</span>];</span><br><span class=\"line\">    <span class=\"type\">uint8_t</span> *dst_v = out_frame-&gt;data[<span class=\"number\">2</span>] + (in_frame-&gt;height / <span class=\"number\">2</span> - <span class=\"number\">1</span>) * out_frame-&gt;linesize[<span class=\"number\">2</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; in_frame-&gt;height; i++) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">memcpy</span>(dst_y, src_y, in_frame-&gt;width);</span><br><span class=\"line\">        src_y += in_frame-&gt;linesize[<span class=\"number\">0</span>];</span><br><span class=\"line\">        dst_y -= out_frame-&gt;linesize[<span class=\"number\">0</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (i &lt; in_frame-&gt;height / <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">memcpy</span>(dst_u, src_u, in_frame-&gt;width / <span class=\"number\">2</span>);</span><br><span class=\"line\">            <span class=\"built_in\">memcpy</span>(dst_v, src_v, in_frame-&gt;width / <span class=\"number\">2</span>);</span><br><span class=\"line\">            src_u += in_frame-&gt;linesize[<span class=\"number\">1</span>];</span><br><span class=\"line\">            src_v += in_frame-&gt;linesize[<span class=\"number\">2</span>];</span><br><span class=\"line\">            dst_u -= out_frame-&gt;linesize[<span class=\"number\">1</span>];</span><br><span class=\"line\">            dst_v -= out_frame-&gt;linesize[<span class=\"number\">2</span>];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> out_frame;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">int</span> <span class=\"title function_\">activate</span><span class=\"params\">(AVFilterContext *ctx)</span> &#123;</span><br><span class=\"line\">    AVFilterLink *inlink = ctx-&gt;inputs[<span class=\"number\">0</span>];</span><br><span class=\"line\">    AVFilterLink *outlink = ctx-&gt;outputs[<span class=\"number\">0</span>];</span><br><span class=\"line\">    AVFrame *in_frame = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    AVFrame *out_frame = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    <span class=\"type\">int</span> ret = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 获取输入帧</span></span><br><span class=\"line\">    ret = ff_inlink_consume_frame(inlink, &amp;in_frame);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ret &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 如果有输入帧，进行翻转处理</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (in_frame) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 对输出帧进行上下翻转处理</span></span><br><span class=\"line\">        out_frame = flip_frame(ctx, in_frame);</span><br><span class=\"line\">        <span class=\"comment\">// 将处理后的帧放入输出缓冲区</span></span><br><span class=\"line\">        ret = ff_filter_frame(outlink, out_frame);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (ret &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            av_frame_free(&amp;out_frame);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 如果没有输入帧，尝试请求一个新的输入帧</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!in_frame) &#123;</span><br><span class=\"line\">        ff_inlink_request_frame(inlink);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">int</span> status;</span><br><span class=\"line\">    <span class=\"type\">int64_t</span> pts;</span><br><span class=\"line\">    ret = ff_inlink_acknowledge_status(inlink, &amp;status, &amp;pts);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ret &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (status == AVERROR_EOF) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 输入链接已经结束，设置输出链接的状态为 EOF</span></span><br><span class=\"line\">        ff_outlink_set_status(outlink, AVERROR_EOF, pts);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">AVFILTER_DEFINE_CLASS(flip);</span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">const</span> AVFilterPad flip_inputs[] = &#123;</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">                .name = <span class=\"string\">&quot;default&quot;</span>,</span><br><span class=\"line\">                .type = AVMEDIA_TYPE_VIDEO,</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">const</span> AVFilterPad flip_outputs[] = &#123;</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">                .name = <span class=\"string\">&quot;default&quot;</span>,</span><br><span class=\"line\">                .type = AVMEDIA_TYPE_VIDEO,</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"type\">const</span> AVFilter ff_vf_flip = &#123;</span><br><span class=\"line\">        .name = <span class=\"string\">&quot;flip&quot;</span>,</span><br><span class=\"line\">        .description = NULL_IF_CONFIG_SMALL(<span class=\"string\">&quot;Flip the input video.&quot;</span>),</span><br><span class=\"line\">        .priv_size = <span class=\"keyword\">sizeof</span>(FlipContext),</span><br><span class=\"line\">        .priv_class = &amp;flip_class,</span><br><span class=\"line\">        .activate      = activate,</span><br><span class=\"line\">        .init = flip_init,</span><br><span class=\"line\">        .uninit = flip_uninit,</span><br><span class=\"line\">        FILTER_INPUTS(flip_inputs),</span><br><span class=\"line\">        FILTER_OUTPUTS(flip_outputs),</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>命令行运行：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">ffmpeg -i test.mp4 -filter_complex &quot;[0:v]flip=duration=5[out];&quot; -map &quot;[out]&quot; flip.mp4</span><br></pre></td></tr></table></figure>\n\n<p> 得到渲染好的视频，前5s是上下翻转的，后面的内容正常。</p>\n<p>相比于最简单的 AVFilter 多了几个实现：</p>\n<ol>\n<li><p><strong><code>AVOption flip_options</code></strong></p>\n<p>用于设置翻转持续时间的选项，外部命令配置可选输入<code>duration=5</code>，会自动对数据合法性进行校验。参数类型为 <code>AV_OPT_TYPE_INT</code>，默认值为 0，取值范围为 0 到 <code>INT_MAX</code>。<code>.flags</code> 设置为 <code>AV_OPT_FLAG_FILTERING_PARAM</code>，表示这是一个过滤参数。</p>\n</li>\n<li><p><strong><code>.priv_class</code></strong>  </p>\n<p>配置的<code>flip_class</code>实际是通过 <code>AVFILTER_DEFINE_CLASS(flip);</code> 宏实现的一个声明：见：<a href=\"https://github.com/FFmpeg/FFmpeg/blob/release/6.1/libavfilter/internal.h#L311\">internal.h#AVFILTER_DEFINE_CLASS_EXT</a></p>\n</li>\n<li><p><strong><code>**init</code>&amp; <code>uninit</code></strong></p>\n<p>滤镜在初始化或者释放资源的时候将会调用</p>\n</li>\n<li><p><strong><code>activate</code></strong></p>\n<p>这个函数首先获取输入帧，然后调用 <code>flip_frame</code> 函数进行翻转操作，并将处理后的帧放入输出链接。如果没有输入帧，它会请求一个新的输入帧。最后，它会确认输入链接的状态，并根据需要设置输出链接的状态。</p>\n</li>\n</ol>\n<p>这个例子相比最简单的 filter 使用了 <code>activate</code> 函数 用于帧渲染，而不是使用 <code>filter_frame</code>去渲染，这两个方法有什么区别于联系呢？查看：<a href=\"##filter_frame()%E5%92%8Cactivate()%E5%87%BD%E6%95%B0\">filter_frame和activate方法</a></p>\n<p>也能通过 <code>filter_frame</code>实现，对代码部分逻辑更新更改：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">const</span> AVFilterPad flip_inputs[] = &#123;</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">                .name = <span class=\"string\">&quot;default&quot;</span>,</span><br><span class=\"line\">                .type = AVMEDIA_TYPE_VIDEO,</span><br><span class=\"line\">                .filter_frame = filter_frame, <span class=\"comment\">//添加filter_frame 实现</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">const</span> AVFilter ff_vf_flip = &#123;</span><br><span class=\"line\">       ……</span><br><span class=\"line\">        .priv_class = &amp;flip_class,</span><br><span class=\"line\">       <span class=\"comment\">// .activate      = activate,</span></span><br><span class=\"line\">        .init = flip_init,</span><br><span class=\"line\">       ……</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">int</span> <span class=\"title function_\">filter_frame</span><span class=\"params\">(AVFilterLink *inlink, AVFrame *in)</span> &#123;</span><br><span class=\"line\">    AVFilterContext *ctx = inlink-&gt;dst;</span><br><span class=\"line\">    FlipContext *s = ctx-&gt;priv;</span><br><span class=\"line\">    AVFilterLink *outlink = ctx-&gt;outputs[<span class=\"number\">0</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">int64_t</span> pts = in-&gt;pts;</span><br><span class=\"line\">    <span class=\"comment\">// 将时间戳（pts）转化以秒为单位的时间戳</span></span><br><span class=\"line\">    <span class=\"type\">float</span> time_s = TS2T(pts, inlink-&gt;time_base);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (time_s &gt; s-&gt;duration) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 超过对应的时间则直接输出in_frame</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> ff_filter_frame(outlink, in);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        av_log(<span class=\"literal\">NULL</span>, AV_LOG_ERROR, <span class=\"string\">&quot;time_s s: %f.\\n&quot;</span>, time_s);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    AVFrame *out = flip_frame(ctx, in);</span><br><span class=\"line\">    <span class=\"comment\">// 释放输入帧</span></span><br><span class=\"line\">    av_frame_free(&amp;in);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 将输出帧传递给下一个滤镜</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> ff_filter_frame(outlink, out);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>命令行运行，得到的输出结果是一样的。</p>\n<h2 id=\"filter-frame-和activate-函数\"><a href=\"#filter-frame-和activate-函数\" class=\"headerlink\" title=\"filter_frame()和activate()函数\"></a>filter_frame()和activate()函数</h2><p>对于这点查了相关资料，看看源码相关的实现</p>\n<p>参考：<a href=\"https://www.ffmpeg.org/doxygen/5.0/filter__design_8txt.html\">https://www.ffmpeg.org/doxygen/5.0/filter__design_8txt.html</a></p>\n<blockquote>\n<p>The purpose of these rules is to ensure that frames flow in the filter graph without getting stuck and accumulating somewhere. Simple filters that output one frame for each input frame should not have to worry about it. There are two design for filters:one using the  <a href=\"https://www.ffmpeg.org/doxygen/5.0/vsink__nullsink_8c.html#aaa9a0e0f9de1464941d86a984cf77d37\">filter_frame</a>() and <a href=\"https://www.ffmpeg.org/doxygen/5.0/vsrc__mptestsrc_8c.html#a72949c8fcad3f201712a3569fc6888cb\">request_frame</a>() callbacks and the other using the activate() callback. The design using filter_frame() and request_frame() is legacy, but it is suitable for filters that have a single input and process one frame at a time. New filters with several inputs, that treat several frames at a time or that require a special treatment at EOF should probably use the design using activate(). activate ——– This method is called when something must be done in a filter</p>\n</blockquote>\n<p>大意，实现滤镜有两种实现方式：</p>\n<ul>\n<li><p><strong><code>filter_frame()</code></strong></p>\n<p>可以被认为是历史遗留产物。在早期的 AVFilter 设计中，<code>filter_frame()</code> 和 <code>request_frame()</code> 是主要用于处理输入帧和请求输出帧的回调函数。这种设计适用于简单的过滤器，例如单输入且每次处理一个帧的过滤器。</p>\n</li>\n<li><p><strong><code>activate()</code></strong></p>\n<p>随着 ffmpeg 和 AVFilter 的发展，处理需求变得越来越复杂，例如需要处理多个输入、一次处理多个帧或在文件结束（EOF）时进行特殊处理等。为了满足这些需求，引入了 <code>activate()</code> 函数，它提供了更灵活和强大的处理能力。因此，虽然 <code>filter_frame()</code> 在某些简单场景下仍然可以使用，但对于新的或复杂的过滤器，建议使用 <code>activate()</code> 函数。</p>\n</li>\n</ul>\n<p>如果两个方法都实现了，那他们谁会先执行呢？</p>\n<p>对应的源码处理逻辑： <a href=\"https://github.com/FFmpeg/FFmpeg/blob/release/6.1/libavfilter/avfilter.c#L1322\">avfilter.c</a></p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">ff_filter_activate</span><span class=\"params\">(AVFilterContext *filter)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> ret;</span><br><span class=\"line\">\t\t……</span><br><span class=\"line\">    ret = filter-&gt;filter-&gt;activate ? filter-&gt;filter-&gt;activate(filter) :</span><br><span class=\"line\">          ff_filter_activate_default(filter);</span><br><span class=\"line\">  \t……</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如果配置了activate() 函数则执行，否则执行 ff_filter_activate_default()-&gt;ff_filter_frame_to_filter()-&gt;ff_filter_frame_framed() 最终执行到配置的 filter_frame() 方法。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">int</span> <span class=\"title function_\">ff_filter_frame_framed</span><span class=\"params\">(AVFilterLink *link, AVFrame *frame)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> (*filter_frame)(AVFilterLink *, AVFrame *);</span><br><span class=\"line\">    AVFilterContext *dstctx = link-&gt;dst;</span><br><span class=\"line\">    AVFilterPad *dst = link-&gt;dstpad;</span><br><span class=\"line\">    <span class=\"type\">int</span> ret;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!(filter_frame = dst-&gt;filter_frame))</span><br><span class=\"line\">        filter_frame = default_filter_frame;</span><br><span class=\"line\">    ……</span><br><span class=\"line\">    ret = filter_frame(link, frame);  <span class=\"comment\">// 最终调用到的地方</span></span><br><span class=\"line\">    link-&gt;frame_count_out++;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">fail:</span><br><span class=\"line\">    ……</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>本文介绍了 FFmpeg 滤镜开发的整体流程，如何编写 filter.c 文件，并以一个最简单的 AVFilter 和一个较为复杂的 AVFilter 为例，解析了滤镜开发的具体步骤和代码实现，并介绍了 filter_frame() 和 activate() 函数的区别与联系。</p>\n<p>在滤镜开发过程中，需要注意的是，filter_frame() 和 activate() 函数的使用取决于滤镜的复杂性。对于简单的滤镜，可以使用 filter_frame() 函数；而对于需要处理多个输入、一次处理多个帧或在文件结束（EOF）时进行特殊处理的复杂滤镜，建议使用 activate() 函数。</p>\n<p>文中的源码可以查看：<a href=\"https://github.com/VomPom/FFmpeg/commit/9176f58ae60e0b70e5708b25017f374deac9fae7\">add most simplest  AVFilter and a simple video flip filter.</a></p>\n<h3 id=\"参考：\"><a href=\"#参考：\" class=\"headerlink\" title=\"参考：\"></a>参考：</h3><p><a href=\"https://www.cnblogs.com/TaigaCon/p/10171464.html\">https://www.cnblogs.com/TaigaCon/p/10171464.html</a></p>\n<p><a href=\"https://www.cnblogs.com/ranson7zop/p/7728639.html\">https://www.cnblogs.com/ranson7zop/p/7728639.html</a></p>\n<p><a href=\"https://www.ffmpeg.org/doxygen/5.0/filter__design_8txt.html\">https://www.ffmpeg.org/doxygen/5.0/filter__design_8txt.html</a></p>\n","cover":null,"images":[],"content":"<p>此前在做  ffmpeg+某个第三库作为 filter 的集成，第三库是做AE特效相关的，与 ffmpeg 结合能让视频渲染效果大大提升。整体流程将第三方库作为 ffmpeg 的一个filter 形式进行结合，其中就涉及到 ffmpeg 的 filter 开发，本文即 对ffmpeg 的滤镜开发流程作一个总结。本文以实现一个视频垂直翻转的 filter 为例，ffmpeg 源码基于<a href=\"https://github.com/FFmpeg/FFmpeg/tree/release/6.1\">FFmpeg6.1</a> </p>\n<h2 id=\"实现自定义-Filter-流程\"><a href=\"#实现自定义-Filter-流程\" class=\"headerlink\" title=\"实现自定义 Filter 流程\"></a>实现自定义 Filter 流程</h2><ul>\n<li><p>编写 filter.c 文件</p>\n<p>一般视频滤镜以 vf_ 为前缀，视频滤镜以 af_ 为前缀，放在libavfilter目录下，参考其他 filter 代码逻辑，模块化配置相关参数，本文例以 vf_flip.c 实现视频的上下翻转</p>\n</li>\n<li><p>在 <code>libavfilter/allfilters.c</code> 注册</p>\n<p>例如：extern const AVFilter ff_vf_flip;  <code>ff_vf_flip</code>就是在 <code>vf_flip.c</code>的 filter 注册名称</p>\n</li>\n<li><p>修改 <code>libavfilter/Makefile</code> 添加编译配置： </p>\n<p>例如：OBJS-$(CONFIG_FLIP_FILTER)                   +&#x3D; vf_flip.o</p>\n</li>\n<li><p>编译打包</p>\n</li>\n</ul>\n<h2 id=\"编写-filter-c-文件\"><a href=\"#编写-filter-c-文件\" class=\"headerlink\" title=\"编写 filter.c 文件\"></a>编写 filter.c 文件</h2><h3 id=\"AVFilter主体\"><a href=\"#AVFilter主体\" class=\"headerlink\" title=\"AVFilter主体\"></a>AVFilter主体</h3><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">AVFilter</span> &#123;</span></span><br><span class=\"line\">  <span class=\"type\">const</span> <span class=\"type\">char</span> *name;</span><br><span class=\"line\">  <span class=\"type\">const</span> <span class=\"type\">char</span> *description;</span><br><span class=\"line\">  <span class=\"type\">const</span> AVFilterPad *inputs;</span><br><span class=\"line\">  <span class=\"type\">const</span> AVFilterPad *outputs;</span><br><span class=\"line\">  <span class=\"type\">const</span> AVClass *priv_class;</span><br><span class=\"line\">  <span class=\"type\">int</span> flags;</span><br><span class=\"line\">  <span class=\"type\">int</span> (*preinit)(AVFilterContext *ctx);</span><br><span class=\"line\">  <span class=\"type\">int</span> (*init)(AVFilterContext *ctx);</span><br><span class=\"line\">  <span class=\"type\">int</span> (*init_dict)(AVFilterContext *ctx, AVDictionary **options);</span><br><span class=\"line\">  <span class=\"type\">void</span> (*uninit)(AVFilterContext *ctx);</span><br><span class=\"line\">  <span class=\"type\">int</span> (*query_formats)(AVFilterContext *);</span><br><span class=\"line\">  <span class=\"type\">int</span> priv_size;   </span><br><span class=\"line\">  <span class=\"type\">int</span> flags_internal; </span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">AVFilter</span> *<span class=\"title\">next</span>;</span></span><br><span class=\"line\">  <span class=\"type\">int</span> (*process_command)(AVFilterContext *, <span class=\"type\">const</span> <span class=\"type\">char</span> *cmd, <span class=\"type\">const</span> <span class=\"type\">char</span> *arg, <span class=\"type\">char</span> *res, <span class=\"type\">int</span> res_len, <span class=\"type\">int</span> flags);</span><br><span class=\"line\">  <span class=\"type\">int</span> (*init_opaque)(AVFilterContext *ctx, <span class=\"type\">void</span> *opaque);</span><br><span class=\"line\">  <span class=\"type\">int</span> (*activate)(AVFilterContext *ctx);</span><br><span class=\"line\">&#125; AVFilter;</span><br></pre></td></tr></table></figure>\n\n<p>具体里面的属性作用可以参考：<a href=\"https://www.cnblogs.com/TaigaCon/p/10171464.html\">[ffmpeg] 定制滤波器</a>，可以根据需求实现里面的相关函数，接下来以一个最简单的 Filter 和一个较复杂一点的 Filter 举例。</p>\n<h3 id=\"最简单的-AVFilter\"><a href=\"#最简单的-AVFilter\" class=\"headerlink\" title=\"最简单的 AVFilter\"></a>最简单的 AVFilter</h3><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> &#123;</span></span><br><span class=\"line\">    <span class=\"type\">const</span> AVClass *<span class=\"class\"><span class=\"keyword\">class</span>;</span></span><br><span class=\"line\">&#125; NoopContext;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">int</span> <span class=\"title function_\">filter_frame</span><span class=\"params\">(AVFilterLink *link, AVFrame *frame)</span> &#123;</span><br><span class=\"line\">    av_log(<span class=\"literal\">NULL</span>, AV_LOG_INFO, <span class=\"string\">&quot;filter frame pts:%lld\\n&quot;</span>, frame-&gt;pts);</span><br><span class=\"line\">    NoopContext *noopContext = link-&gt;dst-&gt;priv;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ff_filter_frame(link-&gt;dst-&gt;outputs[<span class=\"number\">0</span>], frame);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">const</span> AVFilterPad noop_inputs[] = &#123;</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">                .name         = <span class=\"string\">&quot;default&quot;</span>,</span><br><span class=\"line\">                .type         = AVMEDIA_TYPE_VIDEO,</span><br><span class=\"line\">                .filter_frame = filter_frame,</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">const</span> AVFilterPad noop_outputs[] = &#123;</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">                .name = <span class=\"string\">&quot;default&quot;</span>,</span><br><span class=\"line\">                .type = AVMEDIA_TYPE_VIDEO,</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"type\">const</span> AVFilter ff_vf_noop = &#123;</span><br><span class=\"line\">        .name          = <span class=\"string\">&quot;noop&quot;</span>,</span><br><span class=\"line\">        .description   = NULL_IF_CONFIG_SMALL(<span class=\"string\">&quot;Pass the input video unchanged.&quot;</span>),</span><br><span class=\"line\">        .priv_size     = <span class=\"keyword\">sizeof</span>(NoopContext),</span><br><span class=\"line\">        FILTER_INPUTS(noop_inputs),</span><br><span class=\"line\">        FILTER_OUTPUTS(noop_outputs),</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>命令行运行：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">ffmpeg -i test.mp4 -vf &quot;noop&quot; noop.mp4</span><br></pre></td></tr></table></figure>\n\n<p> 正常输出文件（对原片没有做任何更改）,这个 filter 的作用是将输入的视频帧不做任何处理地传递给下一个过滤器，在处理每帧的时候会打印处理的 PTS，麻雀虽小五脏俱全，它包含了一个 AVFilter 基础的结构：</p>\n<ol>\n<li><p><strong><code>NoopContext</code></strong></p>\n<p>这是一个简单的结构体，包含一个指向 AVClass 的指针。在这个例子中，实际上没有使用到 NoopContext 结构体的任何成员，因为这个过滤器没有需要存储的私有数据。</p>\n</li>\n<li><p><strong><code>filter_frame</code></strong> </p>\n<p>这个函数的作用是处理输入的视频帧。在这个例子中，它只是打印帧的 PTS（Presentation Time Stamp，显示时间戳）并将帧传递给下一个过滤器，不对帧做任何修改。</p>\n</li>\n<li><p><strong><code>noop_inputs</code> 和 <code>noop_outputs</code></strong></p>\n<p>这两个数组定义了过滤器的输入和输出 Pad。在这个例子中，输入 Pad 类型为 AVMEDIA_TYPE_VIDEO，并关联了 <code>filter_frame</code> 函数。输出 Pad 也是 AVMEDIA_TYPE_VIDEO 类型，但没有关联任何函数，因为输出直接由 <code>filter_frame</code> 函数处理。</p>\n</li>\n<li><p><strong><code>ff_vf_noop</code></strong></p>\n<p>这是一个 AVFilter 结构体实例，包含了过滤器的名称、描述、私有数据大小以及输入和输出 Pad。在这个例子中，过滤器的名称为 “noop”，描述为 “Pass the input video unchanged.”，这也就是在执行：<code>ffmpeg -filters</code> 看到的 Filter描述内容。</p>\n</li>\n</ol>\n<p>接下来看一个稍微复杂的一个 AVFilter，实现一个视频的上下翻转</p>\n<h3 id=\"复杂一点的-AVFilter\"><a href=\"#复杂一点的-AVFilter\" class=\"headerlink\" title=\"复杂一点的 AVFilter\"></a>复杂一点的 AVFilter</h3><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">FlipContext</span> &#123;</span></span><br><span class=\"line\">    <span class=\"type\">const</span> AVClass *<span class=\"class\"><span class=\"keyword\">class</span>;</span></span><br><span class=\"line\">    <span class=\"type\">int</span> duration;</span><br><span class=\"line\">&#125; FlipContext;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> OFFSET(x) offsetof(FlipContext, x)</span></span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">const</span> AVOption flip_options[] = &#123;</span><br><span class=\"line\">        &#123;<span class=\"string\">&quot;duration&quot;</span>, <span class=\"string\">&quot;set flip duration&quot;</span>, OFFSET(duration), AV_OPT_TYPE_INT, &#123;.i64 = <span class=\"number\">0</span>&#125;, <span class=\"number\">0</span>, INT_MAX, .flags = AV_OPT_FLAG_FILTERING_PARAM&#125;,</span><br><span class=\"line\">        &#123;<span class=\"literal\">NULL</span>&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">static</span> av_cold <span class=\"type\">int</span> <span class=\"title function_\">flip_init</span><span class=\"params\">(AVFilterContext *ctx)</span> &#123;</span><br><span class=\"line\">    FlipContext *context = ctx-&gt;priv;</span><br><span class=\"line\">    av_log(<span class=\"literal\">NULL</span>, AV_LOG_ERROR, <span class=\"string\">&quot;Input duration: %d.\\n&quot;</span>, context-&gt;duration);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">static</span> av_cold <span class=\"type\">void</span> <span class=\"title function_\">flip_uninit</span><span class=\"params\">(AVFilterContext *ctx)</span> &#123;</span><br><span class=\"line\">    FlipContext *context = ctx-&gt;priv;</span><br><span class=\"line\">    <span class=\"comment\">// no-op 本例无需释放滤镜实例分配的内存、关闭文件、资源等</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 对输入的 AVFrame 进行翻转</span></span><br><span class=\"line\"><span class=\"type\">static</span> AVFrame *<span class=\"title function_\">flip_frame</span><span class=\"params\">(AVFilterContext *ctx, AVFrame *in_frame)</span> &#123;</span><br><span class=\"line\"> \t\tAVFilterLink *inlink = ctx-&gt;inputs[<span class=\"number\">0</span>];</span><br><span class=\"line\">    FlipContext *s = ctx-&gt;priv;</span><br><span class=\"line\">    <span class=\"type\">int64_t</span> pts = in_frame-&gt;pts;</span><br><span class=\"line\">    <span class=\"comment\">// 将时间戳（pts）转化以秒为单位的时间戳</span></span><br><span class=\"line\">    <span class=\"type\">float</span> time_s = TS2T(pts, inlink-&gt;time_base);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (time_s &gt; s-&gt;duration) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 超过对应的时间则直接输出in_frame</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> in_frame;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 创建输出帧并分配内存</span></span><br><span class=\"line\">    AVFrame *out_frame = av_frame_alloc();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!out_frame) &#123;</span><br><span class=\"line\">        av_frame_free(&amp;in_frame);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> out_frame;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 设置输出帧的属性</span></span><br><span class=\"line\">    out_frame-&gt;format = in_frame-&gt;format;</span><br><span class=\"line\">    out_frame-&gt;width = in_frame-&gt;width;</span><br><span class=\"line\">    out_frame-&gt;height = in_frame-&gt;height;</span><br><span class=\"line\">    out_frame-&gt;pts = in_frame-&gt;pts;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 分配输出帧的数据缓冲区</span></span><br><span class=\"line\">    <span class=\"type\">int</span> ret = av_frame_get_buffer(out_frame, <span class=\"number\">32</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ret &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        av_frame_free(&amp;in_frame);</span><br><span class=\"line\">        av_frame_free(&amp;out_frame);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> out_frame;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 这个示例仅适用于 YUV 格式的视频。对于其他格式（如 RGB）</span></span><br><span class=\"line\">    <span class=\"comment\">// 翻转输入帧的数据到输出帧</span></span><br><span class=\"line\">    <span class=\"comment\">// 翻转了 Y 分量，然后翻转了 U 和 V 分量</span></span><br><span class=\"line\">    <span class=\"comment\">//</span></span><br><span class=\"line\">    <span class=\"type\">uint8_t</span> *src_y = in_frame-&gt;data[<span class=\"number\">0</span>];</span><br><span class=\"line\">    <span class=\"type\">uint8_t</span> *src_u = in_frame-&gt;data[<span class=\"number\">1</span>];</span><br><span class=\"line\">    <span class=\"type\">uint8_t</span> *src_v = in_frame-&gt;data[<span class=\"number\">2</span>];</span><br><span class=\"line\">    <span class=\"type\">uint8_t</span> *dst_y = out_frame-&gt;data[<span class=\"number\">0</span>] + (in_frame-&gt;height - <span class=\"number\">1</span>) * out_frame-&gt;linesize[<span class=\"number\">0</span>];</span><br><span class=\"line\">    <span class=\"type\">uint8_t</span> *dst_u = out_frame-&gt;data[<span class=\"number\">1</span>] + (in_frame-&gt;height / <span class=\"number\">2</span> - <span class=\"number\">1</span>) * out_frame-&gt;linesize[<span class=\"number\">1</span>];</span><br><span class=\"line\">    <span class=\"type\">uint8_t</span> *dst_v = out_frame-&gt;data[<span class=\"number\">2</span>] + (in_frame-&gt;height / <span class=\"number\">2</span> - <span class=\"number\">1</span>) * out_frame-&gt;linesize[<span class=\"number\">2</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; in_frame-&gt;height; i++) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">memcpy</span>(dst_y, src_y, in_frame-&gt;width);</span><br><span class=\"line\">        src_y += in_frame-&gt;linesize[<span class=\"number\">0</span>];</span><br><span class=\"line\">        dst_y -= out_frame-&gt;linesize[<span class=\"number\">0</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (i &lt; in_frame-&gt;height / <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">memcpy</span>(dst_u, src_u, in_frame-&gt;width / <span class=\"number\">2</span>);</span><br><span class=\"line\">            <span class=\"built_in\">memcpy</span>(dst_v, src_v, in_frame-&gt;width / <span class=\"number\">2</span>);</span><br><span class=\"line\">            src_u += in_frame-&gt;linesize[<span class=\"number\">1</span>];</span><br><span class=\"line\">            src_v += in_frame-&gt;linesize[<span class=\"number\">2</span>];</span><br><span class=\"line\">            dst_u -= out_frame-&gt;linesize[<span class=\"number\">1</span>];</span><br><span class=\"line\">            dst_v -= out_frame-&gt;linesize[<span class=\"number\">2</span>];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> out_frame;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">int</span> <span class=\"title function_\">activate</span><span class=\"params\">(AVFilterContext *ctx)</span> &#123;</span><br><span class=\"line\">    AVFilterLink *inlink = ctx-&gt;inputs[<span class=\"number\">0</span>];</span><br><span class=\"line\">    AVFilterLink *outlink = ctx-&gt;outputs[<span class=\"number\">0</span>];</span><br><span class=\"line\">    AVFrame *in_frame = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    AVFrame *out_frame = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    <span class=\"type\">int</span> ret = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 获取输入帧</span></span><br><span class=\"line\">    ret = ff_inlink_consume_frame(inlink, &amp;in_frame);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ret &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 如果有输入帧，进行翻转处理</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (in_frame) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 对输出帧进行上下翻转处理</span></span><br><span class=\"line\">        out_frame = flip_frame(ctx, in_frame);</span><br><span class=\"line\">        <span class=\"comment\">// 将处理后的帧放入输出缓冲区</span></span><br><span class=\"line\">        ret = ff_filter_frame(outlink, out_frame);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (ret &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            av_frame_free(&amp;out_frame);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 如果没有输入帧，尝试请求一个新的输入帧</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!in_frame) &#123;</span><br><span class=\"line\">        ff_inlink_request_frame(inlink);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">int</span> status;</span><br><span class=\"line\">    <span class=\"type\">int64_t</span> pts;</span><br><span class=\"line\">    ret = ff_inlink_acknowledge_status(inlink, &amp;status, &amp;pts);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ret &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (status == AVERROR_EOF) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 输入链接已经结束，设置输出链接的状态为 EOF</span></span><br><span class=\"line\">        ff_outlink_set_status(outlink, AVERROR_EOF, pts);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">AVFILTER_DEFINE_CLASS(flip);</span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">const</span> AVFilterPad flip_inputs[] = &#123;</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">                .name = <span class=\"string\">&quot;default&quot;</span>,</span><br><span class=\"line\">                .type = AVMEDIA_TYPE_VIDEO,</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">const</span> AVFilterPad flip_outputs[] = &#123;</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">                .name = <span class=\"string\">&quot;default&quot;</span>,</span><br><span class=\"line\">                .type = AVMEDIA_TYPE_VIDEO,</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"type\">const</span> AVFilter ff_vf_flip = &#123;</span><br><span class=\"line\">        .name = <span class=\"string\">&quot;flip&quot;</span>,</span><br><span class=\"line\">        .description = NULL_IF_CONFIG_SMALL(<span class=\"string\">&quot;Flip the input video.&quot;</span>),</span><br><span class=\"line\">        .priv_size = <span class=\"keyword\">sizeof</span>(FlipContext),</span><br><span class=\"line\">        .priv_class = &amp;flip_class,</span><br><span class=\"line\">        .activate      = activate,</span><br><span class=\"line\">        .init = flip_init,</span><br><span class=\"line\">        .uninit = flip_uninit,</span><br><span class=\"line\">        FILTER_INPUTS(flip_inputs),</span><br><span class=\"line\">        FILTER_OUTPUTS(flip_outputs),</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>命令行运行：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">ffmpeg -i test.mp4 -filter_complex &quot;[0:v]flip=duration=5[out];&quot; -map &quot;[out]&quot; flip.mp4</span><br></pre></td></tr></table></figure>\n\n<p> 得到渲染好的视频，前5s是上下翻转的，后面的内容正常。</p>\n<p>相比于最简单的 AVFilter 多了几个实现：</p>\n<ol>\n<li><p><strong><code>AVOption flip_options</code></strong></p>\n<p>用于设置翻转持续时间的选项，外部命令配置可选输入<code>duration=5</code>，会自动对数据合法性进行校验。参数类型为 <code>AV_OPT_TYPE_INT</code>，默认值为 0，取值范围为 0 到 <code>INT_MAX</code>。<code>.flags</code> 设置为 <code>AV_OPT_FLAG_FILTERING_PARAM</code>，表示这是一个过滤参数。</p>\n</li>\n<li><p><strong><code>.priv_class</code></strong>  </p>\n<p>配置的<code>flip_class</code>实际是通过 <code>AVFILTER_DEFINE_CLASS(flip);</code> 宏实现的一个声明：见：<a href=\"https://github.com/FFmpeg/FFmpeg/blob/release/6.1/libavfilter/internal.h#L311\">internal.h#AVFILTER_DEFINE_CLASS_EXT</a></p>\n</li>\n<li><p><strong><code>**init</code>&amp; <code>uninit</code></strong></p>\n<p>滤镜在初始化或者释放资源的时候将会调用</p>\n</li>\n<li><p><strong><code>activate</code></strong></p>\n<p>这个函数首先获取输入帧，然后调用 <code>flip_frame</code> 函数进行翻转操作，并将处理后的帧放入输出链接。如果没有输入帧，它会请求一个新的输入帧。最后，它会确认输入链接的状态，并根据需要设置输出链接的状态。</p>\n</li>\n</ol>\n<p>这个例子相比最简单的 filter 使用了 <code>activate</code> 函数 用于帧渲染，而不是使用 <code>filter_frame</code>去渲染，这两个方法有什么区别于联系呢？查看：<a href=\"##filter_frame()%E5%92%8Cactivate()%E5%87%BD%E6%95%B0\">filter_frame和activate方法</a></p>\n<p>也能通过 <code>filter_frame</code>实现，对代码部分逻辑更新更改：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">const</span> AVFilterPad flip_inputs[] = &#123;</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">                .name = <span class=\"string\">&quot;default&quot;</span>,</span><br><span class=\"line\">                .type = AVMEDIA_TYPE_VIDEO,</span><br><span class=\"line\">                .filter_frame = filter_frame, <span class=\"comment\">//添加filter_frame 实现</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">const</span> AVFilter ff_vf_flip = &#123;</span><br><span class=\"line\">       ……</span><br><span class=\"line\">        .priv_class = &amp;flip_class,</span><br><span class=\"line\">       <span class=\"comment\">// .activate      = activate,</span></span><br><span class=\"line\">        .init = flip_init,</span><br><span class=\"line\">       ……</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">int</span> <span class=\"title function_\">filter_frame</span><span class=\"params\">(AVFilterLink *inlink, AVFrame *in)</span> &#123;</span><br><span class=\"line\">    AVFilterContext *ctx = inlink-&gt;dst;</span><br><span class=\"line\">    FlipContext *s = ctx-&gt;priv;</span><br><span class=\"line\">    AVFilterLink *outlink = ctx-&gt;outputs[<span class=\"number\">0</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">int64_t</span> pts = in-&gt;pts;</span><br><span class=\"line\">    <span class=\"comment\">// 将时间戳（pts）转化以秒为单位的时间戳</span></span><br><span class=\"line\">    <span class=\"type\">float</span> time_s = TS2T(pts, inlink-&gt;time_base);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (time_s &gt; s-&gt;duration) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 超过对应的时间则直接输出in_frame</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> ff_filter_frame(outlink, in);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        av_log(<span class=\"literal\">NULL</span>, AV_LOG_ERROR, <span class=\"string\">&quot;time_s s: %f.\\n&quot;</span>, time_s);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    AVFrame *out = flip_frame(ctx, in);</span><br><span class=\"line\">    <span class=\"comment\">// 释放输入帧</span></span><br><span class=\"line\">    av_frame_free(&amp;in);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 将输出帧传递给下一个滤镜</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> ff_filter_frame(outlink, out);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>命令行运行，得到的输出结果是一样的。</p>\n<h2 id=\"filter-frame-和activate-函数\"><a href=\"#filter-frame-和activate-函数\" class=\"headerlink\" title=\"filter_frame()和activate()函数\"></a>filter_frame()和activate()函数</h2><p>对于这点查了相关资料，看看源码相关的实现</p>\n<p>参考：<a href=\"https://www.ffmpeg.org/doxygen/5.0/filter__design_8txt.html\">https://www.ffmpeg.org/doxygen/5.0/filter__design_8txt.html</a></p>\n<blockquote>\n<p>The purpose of these rules is to ensure that frames flow in the filter graph without getting stuck and accumulating somewhere. Simple filters that output one frame for each input frame should not have to worry about it. There are two design for filters:one using the  <a href=\"https://www.ffmpeg.org/doxygen/5.0/vsink__nullsink_8c.html#aaa9a0e0f9de1464941d86a984cf77d37\">filter_frame</a>() and <a href=\"https://www.ffmpeg.org/doxygen/5.0/vsrc__mptestsrc_8c.html#a72949c8fcad3f201712a3569fc6888cb\">request_frame</a>() callbacks and the other using the activate() callback. The design using filter_frame() and request_frame() is legacy, but it is suitable for filters that have a single input and process one frame at a time. New filters with several inputs, that treat several frames at a time or that require a special treatment at EOF should probably use the design using activate(). activate ——– This method is called when something must be done in a filter</p>\n</blockquote>\n<p>大意，实现滤镜有两种实现方式：</p>\n<ul>\n<li><p><strong><code>filter_frame()</code></strong></p>\n<p>可以被认为是历史遗留产物。在早期的 AVFilter 设计中，<code>filter_frame()</code> 和 <code>request_frame()</code> 是主要用于处理输入帧和请求输出帧的回调函数。这种设计适用于简单的过滤器，例如单输入且每次处理一个帧的过滤器。</p>\n</li>\n<li><p><strong><code>activate()</code></strong></p>\n<p>随着 ffmpeg 和 AVFilter 的发展，处理需求变得越来越复杂，例如需要处理多个输入、一次处理多个帧或在文件结束（EOF）时进行特殊处理等。为了满足这些需求，引入了 <code>activate()</code> 函数，它提供了更灵活和强大的处理能力。因此，虽然 <code>filter_frame()</code> 在某些简单场景下仍然可以使用，但对于新的或复杂的过滤器，建议使用 <code>activate()</code> 函数。</p>\n</li>\n</ul>\n<p>如果两个方法都实现了，那他们谁会先执行呢？</p>\n<p>对应的源码处理逻辑： <a href=\"https://github.com/FFmpeg/FFmpeg/blob/release/6.1/libavfilter/avfilter.c#L1322\">avfilter.c</a></p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">ff_filter_activate</span><span class=\"params\">(AVFilterContext *filter)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> ret;</span><br><span class=\"line\">\t\t……</span><br><span class=\"line\">    ret = filter-&gt;filter-&gt;activate ? filter-&gt;filter-&gt;activate(filter) :</span><br><span class=\"line\">          ff_filter_activate_default(filter);</span><br><span class=\"line\">  \t……</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如果配置了activate() 函数则执行，否则执行 ff_filter_activate_default()-&gt;ff_filter_frame_to_filter()-&gt;ff_filter_frame_framed() 最终执行到配置的 filter_frame() 方法。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">int</span> <span class=\"title function_\">ff_filter_frame_framed</span><span class=\"params\">(AVFilterLink *link, AVFrame *frame)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> (*filter_frame)(AVFilterLink *, AVFrame *);</span><br><span class=\"line\">    AVFilterContext *dstctx = link-&gt;dst;</span><br><span class=\"line\">    AVFilterPad *dst = link-&gt;dstpad;</span><br><span class=\"line\">    <span class=\"type\">int</span> ret;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!(filter_frame = dst-&gt;filter_frame))</span><br><span class=\"line\">        filter_frame = default_filter_frame;</span><br><span class=\"line\">    ……</span><br><span class=\"line\">    ret = filter_frame(link, frame);  <span class=\"comment\">// 最终调用到的地方</span></span><br><span class=\"line\">    link-&gt;frame_count_out++;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">fail:</span><br><span class=\"line\">    ……</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>本文介绍了 FFmpeg 滤镜开发的整体流程，如何编写 filter.c 文件，并以一个最简单的 AVFilter 和一个较为复杂的 AVFilter 为例，解析了滤镜开发的具体步骤和代码实现，并介绍了 filter_frame() 和 activate() 函数的区别与联系。</p>\n<p>在滤镜开发过程中，需要注意的是，filter_frame() 和 activate() 函数的使用取决于滤镜的复杂性。对于简单的滤镜，可以使用 filter_frame() 函数；而对于需要处理多个输入、一次处理多个帧或在文件结束（EOF）时进行特殊处理的复杂滤镜，建议使用 activate() 函数。</p>\n<p>文中的源码可以查看：<a href=\"https://github.com/VomPom/FFmpeg/commit/9176f58ae60e0b70e5708b25017f374deac9fae7\">add most simplest  AVFilter and a simple video flip filter.</a></p>\n<h3 id=\"参考：\"><a href=\"#参考：\" class=\"headerlink\" title=\"参考：\"></a>参考：</h3><p><a href=\"https://www.cnblogs.com/TaigaCon/p/10171464.html\">https://www.cnblogs.com/TaigaCon/p/10171464.html</a></p>\n<p><a href=\"https://www.cnblogs.com/ranson7zop/p/7728639.html\">https://www.cnblogs.com/ranson7zop/p/7728639.html</a></p>\n<p><a href=\"https://www.ffmpeg.org/doxygen/5.0/filter__design_8txt.html\">https://www.ffmpeg.org/doxygen/5.0/filter__design_8txt.html</a></p>\n","categories":[],"tags":[{"name":"FFmpeg","slug":"FFmpeg","api":"api/tags/FFmpeg.json"}],"api":"api/posts/2024/03/07/实现一个自定义FFmpeg-Filter.json"}],"info":{"type":"index"}},"api":"api/posts/page.1.json"}