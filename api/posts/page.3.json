{"data":{"index":3,"total":8,"posts":[{"title":"我写了一个场所码小工具（上海实用）","slug":"写了一个场所码小工具","date":"2022-07-03T15:14:00.000Z","updated":"2025-05-20T11:46:57.000Z","comments":true,"url":"2022/07/03/写了一个场所码小工具/","excerpt":"<p>随着新冠疫情的常态化，以上海为例，出示健康码、扫码场所码已经成了每天进出地铁、公司必备操作。对于上班工作，每天的场所码都是同一个地点，对应的场所码图片也不会发生变化，每次扫场所码的时候要不就是前面有很多人一起挤着，或者遇到下雨天不方便等情况。对于我自己而言，我会把场所码保存下来，方便下一次“扫场所码”，但由于存在图库，每次依然需要打开支付宝或者微信选择对应的图片进行扫描，所以就做了个工具，实现：<strong>一键打开健康码、自动保存场所码、一键打开存储的场所码。</strong></p>\n<h2 id=\"小工具使用\"><a href=\"#小工具使用\" class=\"headerlink\" title=\"小工具使用\"></a>小工具使用</h2> <img width=\"40%\" src=\"https://cdn.julis.wang/blog/img/af7fdb3bd9884abf9e8bacfa04936511.png\">\n<p>如图所示提供两个按钮：</p>\n<ul>\n<li>扫一扫 </li>\n</ul>\n<p>扫一扫主要是为了扫场所码，它会扫码对应的二维码图片进行扫描（或者从相册进行读取），识别到对应的场所码信息会自动跳转到支付宝（当前只支持打开支付宝的场所码），并将这一次的结果保存到数据库中。如果下次需要同一个场所码，可以从列表中选择对应的场所码数据并点击直接跳转到场所码，不需要再进行手动扫描。</p>\n<ul>\n<li>健康码</li>\n</ul>\n<p>主要是实现一键打开健康码功能</p>\n<p>对于场所码的信息，在第一次添加的过程中会弹出提示框提示修改场所码的信息进行备注，当然也可以在对应的类目左滑进行编辑操作。</p>\n  <img width=\"40%\" src=\"https://cdn.julis.wang/blog/img/94555e91ef1f4a51942f1a80c349e6d6.png\">\n  <img width=\"40%\" src=\"https://cdn.julis.wang/blog/img/0d09051321934a7e8936209a94b6d110.png\">\n<h2 id=\"下载\"><a href=\"#下载\" class=\"headerlink\" title=\"下载\"></a>下载</h2><p>整个实现是使用Flutter写的，能实现跨平台，但由于iOS需要开发者证书相关上架AppStore较为麻烦，暂时没法进行分发。</p>\n<p>Android 同学可以扫描下面的二维码进行体验使用，或者点击 <a href=\"https://www.pgyer.com/W4La\">场所码小助手</a>去该页面下载</p>\n<p><img src=\"https://www.pgyer.com/app/qrcode/W4La\" width = 40% alt=\"图片名称\" align=center /></p>\n","cover":null,"images":["https://cdn.julis.wang/blog/img/af7fdb3bd9884abf9e8bacfa04936511.png","https://cdn.julis.wang/blog/img/94555e91ef1f4a51942f1a80c349e6d6.png","https://cdn.julis.wang/blog/img/0d09051321934a7e8936209a94b6d110.png","https://www.pgyer.com/app/qrcode/W4La"],"content":"<p>随着新冠疫情的常态化，以上海为例，出示健康码、扫码场所码已经成了每天进出地铁、公司必备操作。对于上班工作，每天的场所码都是同一个地点，对应的场所码图片也不会发生变化，每次扫场所码的时候要不就是前面有很多人一起挤着，或者遇到下雨天不方便等情况。对于我自己而言，我会把场所码保存下来，方便下一次“扫场所码”，但由于存在图库，每次依然需要打开支付宝或者微信选择对应的图片进行扫描，所以就做了个工具，实现：<strong>一键打开健康码、自动保存场所码、一键打开存储的场所码。</strong></p>\n<h2 id=\"小工具使用\"><a href=\"#小工具使用\" class=\"headerlink\" title=\"小工具使用\"></a>小工具使用</h2> <img width=\"40%\" src=\"https://cdn.julis.wang/blog/img/af7fdb3bd9884abf9e8bacfa04936511.png\">\n<p>如图所示提供两个按钮：</p>\n<ul>\n<li>扫一扫 </li>\n</ul>\n<p>扫一扫主要是为了扫场所码，它会扫码对应的二维码图片进行扫描（或者从相册进行读取），识别到对应的场所码信息会自动跳转到支付宝（当前只支持打开支付宝的场所码），并将这一次的结果保存到数据库中。如果下次需要同一个场所码，可以从列表中选择对应的场所码数据并点击直接跳转到场所码，不需要再进行手动扫描。</p>\n<ul>\n<li>健康码</li>\n</ul>\n<p>主要是实现一键打开健康码功能</p>\n<p>对于场所码的信息，在第一次添加的过程中会弹出提示框提示修改场所码的信息进行备注，当然也可以在对应的类目左滑进行编辑操作。</p>\n  <img width=\"40%\" src=\"https://cdn.julis.wang/blog/img/94555e91ef1f4a51942f1a80c349e6d6.png\">\n  <img width=\"40%\" src=\"https://cdn.julis.wang/blog/img/0d09051321934a7e8936209a94b6d110.png\">\n<h2 id=\"下载\"><a href=\"#下载\" class=\"headerlink\" title=\"下载\"></a>下载</h2><p>整个实现是使用Flutter写的，能实现跨平台，但由于iOS需要开发者证书相关上架AppStore较为麻烦，暂时没法进行分发。</p>\n<p>Android 同学可以扫描下面的二维码进行体验使用，或者点击 <a href=\"https://www.pgyer.com/W4La\">场所码小助手</a>去该页面下载</p>\n<p><img src=\"https://www.pgyer.com/app/qrcode/W4La\" width = 40% alt=\"图片名称\" align=center /></p>\n","categories":[],"tags":[],"api":"api/posts/2022/07/03/写了一个场所码小工具.json"},{"title":"FFmpeg之AVFrame转Android Bitmap","slug":"FFmpeg之AVFrame转Android-Bitmap","date":"2022-05-22T13:03:00.000Z","updated":"2025-09-15T13:06:47.170Z","comments":true,"url":"2022/05/22/FFmpeg之AVFrame转Android-Bitmap/","excerpt":"<p>此前很多工作都设计到使用 FFmpeg 对视频帧进行获取，在 FFmpeg 解码视频文件获取到帧数据结构是 <code>AVFrame</code>, 对于应用层我们没有办法直接拿到进行数据处理，需要转换为 Android 平台特有的处理结构。而我是需要对应的帧图片数据，那么在 Android 侧需要将其转化为 <code>Bitmap</code> ,之前整理的过程中发现了这篇<a href=\"https://segmentfault.com/a/1190000016674715?utm_source=sf-similar-article\">《Android音视频开发】从AVFrame到MediaFrame数组(二)》</a>博客文章 ，觉得写得很不错，非常精简，适合我的需求，于是对齐进行整理，并标注一下自己在过程中遇到的一些坑点。</p>\n<h2 id=\"Native层创建Bitmap\"><a href=\"#Native层创建Bitmap\" class=\"headerlink\" title=\"Native层创建Bitmap\"></a>Native层创建Bitmap</h2><p><code>Bitmap</code> 是对 <a href=\"https://docs.microsoft.com/en-us/dotnet/api/skiasharp.skbitmap?view=skiasharp-2.80.2\">SkBitmap</a> 的包装。具体说来， Bitmap 的实现包括 Java 层和 JNI 层，JNI 层依赖 Skia，<code>SkBitmap</code> 本质上可简单理解为内存中的一个字节数组</p>\n<p>想要生成 <code>Bitmap</code>,  我们首先需要构造一个 <code>Bitmap</code> 对象，Java层有很多种方式可以生成Bitmap对象，最简单的方式如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">Bitmap.createBitmap(width,height,<span class=\"keyword\">new</span> <span class=\"title class_\">Bitmap</span>.Config.ARGB_8888)</span><br></pre></td></tr></table></figure>\n<p>由于整个 <code>FFmpeg</code>的操作在 JNI 侧进行，对应的操作需要使用 <code>JNIEnv</code>  进行相关的调用，主要逻辑如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">jobject <span class=\"title\">create_bitmap</span><span class=\"params\">(JNIEnv *env, <span class=\"type\">int</span> width, <span class=\"type\">int</span> height)</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 找到 Bitmap.class 和 该类中的 createBitmap 方法</span></span><br><span class=\"line\">    jclass clz_bitmap = env-&gt;<span class=\"built_in\">FindClass</span>(<span class=\"string\">&quot;android/graphics/Bitmap&quot;</span>);</span><br><span class=\"line\">    jmethodID mtd_bitmap = env-&gt;<span class=\"built_in\">GetStaticMethodID</span>(</span><br><span class=\"line\">            clz_bitmap, <span class=\"string\">&quot;createBitmap&quot;</span>,</span><br><span class=\"line\">            <span class=\"string\">&quot;(IILandroid/graphics/Bitmap$Config;)Landroid/graphics/Bitmap;&quot;</span>);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 配置 Bitmap</span></span><br><span class=\"line\">    jstring str_config = env-&gt;<span class=\"built_in\">NewStringUTF</span>(<span class=\"string\">&quot;ARGB_8888&quot;</span>);</span><br><span class=\"line\">    jclass clz_config = env-&gt;<span class=\"built_in\">FindClass</span>(<span class=\"string\">&quot;android/graphics/Bitmap$Config&quot;</span>);</span><br><span class=\"line\">    jmethodID mtd_config = env-&gt;<span class=\"built_in\">GetStaticMethodID</span>(</span><br><span class=\"line\">            clz_config, <span class=\"string\">&quot;valueOf&quot;</span>, <span class=\"string\">&quot;(Ljava/lang/String;)Landroid/graphics/Bitmap$Config;&quot;</span>);</span><br><span class=\"line\">    jobject obj_config = env-&gt;<span class=\"built_in\">CallStaticObjectMethod</span>(clz_config, mtd_config, str_config);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 创建 Bitmap 对象</span></span><br><span class=\"line\">    jobject bitmap = env-&gt;<span class=\"built_in\">CallStaticObjectMethod</span>(</span><br><span class=\"line\">            clz_bitmap, mtd_bitmap, width, height, obj_config);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> bitmap;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"获取Bitmap像素数据地址，并锁定\"><a href=\"#获取Bitmap像素数据地址，并锁定\" class=\"headerlink\" title=\"获取Bitmap像素数据地址，并锁定\"></a>获取Bitmap像素数据地址，并锁定</h2><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> *addr_pixels;</span><br><span class=\"line\"><span class=\"built_in\">AndroidBitmap_lockPixels</span>(env, bitmap, &amp;addr_pixels);</span><br></pre></td></tr></table></figure>\n<p>解释一下这两句话：</p>\n<blockquote>\n<p>第一句的作用声明并定义一个指向任意类型的指针变量，名称是addr_pixels。我们定义它的目的，是让它指向bitmap像素数据(即:<br>addr_pixels的值为bitmap像素数据的地址)。注意哦，这时候，addr_pixels的值是一个随机的值(假定此时为：0x01)，由系统分配，它还不指向bitmap像素数据。<br>第二句话的作用就是将bitmap的像素数据地址赋值给addr_pixels，此时它的值被修改(假定为：0x002)。并且锁定该地址，保证不会被移动。【注：地址不会被移动这里我也不太懂什么意思，有兴趣的可以去查看该方法的API文档】<br>【注：】此时的bitmap由像素数据的地址，但是该地址内还没有任何像素数据哦，或者说它的像素数据为\\0</p>\n</blockquote>\n<p>到这里，我们已经有了源像素数据在AVFrame中，有了目的像素数据地址addr_pixels，那么接下来的任务就是将AVFrame中的像素数据写入到addr_pixels指向的那片内存中去。</p>\n<h2 id=\"向Bitmap中写入像素数据\"><a href=\"#向Bitmap中写入像素数据\" class=\"headerlink\" title=\"向Bitmap中写入像素数据\"></a>向Bitmap中写入像素数据</h2><p>这里要说一下，我们获取到的AVFrame的像素格式通常是YUV格式的，而Bitmap的像素格式通常是RGB格式的。因此我们需要将YUV格式的像素数据转换成RGB格式进行存储。而RGB的存储空间Bitmap不是已经给我门提供好了吗？嘿嘿，直接用就OK了，那现在问题就是YUV如何转换成RGB呢？<br>关于YUV和RGB之间的转换，我知道的有三种方式：</p>\n<ul>\n<li>通过公式换算</li>\n<li>FFmpeg提供的libswscale</li>\n<li>Google提供的libyuv<br>这里我们选择libyuv因为它的性能好、使用简单。</li>\n</ul>\n<p>说它使用简单，到底有多简单，嘿，一个函数就够了！！</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\">libyuv::<span class=\"built_in\">I420ToABGR</span>(frame-&gt;data[<span class=\"number\">0</span>], frame-&gt;linesize[<span class=\"number\">0</span>], <span class=\"comment\">// Y</span></span><br><span class=\"line\">                   frame-&gt;data[<span class=\"number\">1</span>], frame-&gt;linesize[<span class=\"number\">1</span>], <span class=\"comment\">// U</span></span><br><span class=\"line\">                   frame-&gt;data[<span class=\"number\">2</span>], frame-&gt;linesize[<span class=\"number\">2</span>], <span class=\"comment\">// V</span></span><br><span class=\"line\">                   (<span class=\"type\">uint8_t</span> *) addr_pixels, linesize,  <span class=\"comment\">// RGBA</span></span><br><span class=\"line\">                   frame-&gt;width, frame-&gt;height);</span><br></pre></td></tr></table></figure>\n<p>解释一下这个函数：</p>\n<ul>\n<li>I420ToABGR: I420表示的是YUV420P格式，ABGR表示的RGBA格式(execuse me?? 是的，你没看错，Google说RGBA格式的数据在底层的存储方式是ABGR，顺序反过来，看下libyuv源码的函数注释就知道了)</li>\n<li>frame-&gt;data&amp;linesize: 这些个参数表示的是源YUV数据，上面有标注</li>\n<li>(uint8_t *) addr_pixels: 嘿，这个就是说往这块空间里写入像素数据啦</li>\n<li>linesize: 这个表示的是该图片一行数据的字节大小，Bitmap按照RBGA格式存储，也就是说一个像素是4个字节，那么一行共有：frame-&gt;width 个像素，所以：<br>linesize = frame-&gt; width * 4</li>\n</ul>\n<p>【注：】关于这一小块功能的实现，可能其他地方你会看到这样的写法，他们用了如下接口：</p>\n<p>// 思路</p>\n<blockquote>\n<p>是：新建一个AVFrame(RGB格式)，通过av_image_fill_arrays来实现AVFrame(RGB)中像素数据和Bitmap像素数据的关联，也就是让AVFrame(RGB)像素数据指针等于addr_pixels<br>pRGBFrame = av_frame_alloc() av_image_get_buffer_size()<br>av_image_fill_arrays() /<em><br>我也是写到这里的时候，才想到这个问题，为什么要这样用呢，直接使用addr_pixels不是也一样可以么？<br>不过大家都这么用，应该是有它不可替代的使用场景的。因此这里也说一下av_image_fill_arrays这个函数。\n</em>/</p>\n<p>// TODO: 解释下这个函数的作用 av_image_fill_arrays(dst_data, dst_linesize,<br>src_data, pix_fmt, width, height, align); 它的作用就是</p>\n<ol>\n<li>根据src_data，设置dst_data，事实上根据现象或者自己去调试，可以发现dst_data的值就是src_data的值(我印象中好像值是相同的，这会我忘了，后面我再验证下)</li>\n<li>根据pix_fmt, width, height设置linesize的值，其实linesize的计算就和我上面给出的那个公式是一样子的值</li>\n</ol>\n</blockquote>\n<p>OK, 函数执行完毕，我们Bitmap就有了像素数据，下面就是把Bitmap上传给Java层</p>\n<h2 id=\"Native回调Java接口\"><a href=\"#Native回调Java接口\" class=\"headerlink\" title=\"Native回调Java接口\"></a>Native回调Java接口</h2><p>说下Java层</p>\n<p>有一个MainActivity.java用于界面的显示<br>有一个JNIHelper.java用于Java层和Native层的沟通</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">JNIHelper</span> &#123;</span><br><span class=\"line\">   <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">onReceived</span><span class=\"params\">(Bitmap bitmap)</span>&#123;</span><br><span class=\"line\">       <span class=\"comment\">// <span class=\"doctag\">TODO:</span> Java层接收到Bitmap后，可以开始搞事情了</span></span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Native层的回调代码如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\">jclass clz = env-&gt;<span class=\"built_in\">FindClass</span>(<span class=\"string\">&quot;me/oogh/xplayer/JNIHelper&quot;</span>);</span><br><span class=\"line\">jmethodID method = env-&gt;<span class=\"built_in\">GetMethodID</span>(clz, <span class=\"string\">&quot;onReceived&quot;</span>, <span class=\"string\">&quot;(Landroid/graphics/Bitmap;)V&quot;</span>);</span><br><span class=\"line\">env-&gt;<span class=\"built_in\">CallVoidMethod</span>(obj, method, bitmap);</span><br></pre></td></tr></table></figure>\n<h2 id=\"AndroidBitmap-lockPixels-方法\"><a href=\"#AndroidBitmap-lockPixels-方法\" class=\"headerlink\" title=\"AndroidBitmap_lockPixels 方法\"></a>AndroidBitmap_lockPixels 方法</h2><p>以上就是整个文章的内容，使用起来也是 no problem!  但使用过程中遇到的问题就是内存回收的问题，最开始使用的时候并没有过多关注JNI层 <code>AndroidBitmap_lockPixels</code>这个方法，以至于后来我在处理Bitmap内存回收上遇到了一些问题。 <code>AndroidBitmap_lockPixels</code> 与之对应还有一个   <code>AndroidBitmap_unlockPixels</code></p>\n<p><code>AndroidBitmap_lockPixels</code> “函数作用锁定了像素缓存以确保像素的内存不会被移动”，这句话看起来好像挺难理解，但是我们在 Java层面有与之类似的操作，那就是 <code>SurfaceHolder.lockCanvas()</code>，还记得我们在绘制的过程中需要先使用 <code>lockCanvas</code> 锁定画布，返回的画布对象<code>Canvas</code>然后使用 <code>unlockCanvasAndPost(Canvas canvas)</code> 结束锁定画布，并提交改变。<code>AndroidBitmap_lockPixels</code> 与  <code>AndroidBitmap_unlockPixels</code>做的是类似的事情，都是锁住一块内存区域，保证其安全。</p>\n<p>回到上面说的内存回收的问题，由于自己使用失误，流程大概是这样：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">AndroidBitmap_lockPixels</span>(env, bitmap, &amp;addr_pixels);</span><br><span class=\"line\"><span class=\"comment\">//在两者之间，将生成好的 Bitmap Obj 回调到Java层</span></span><br><span class=\"line\"><span class=\"built_in\">AndroidBitmap_unlockPixels</span>(env, bitmap);</span><br></pre></td></tr></table></figure>\n<p>然后在Java层有这样的逻辑：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">onReceived</span><span class=\"params\">(Bitmap bitmap)</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//……一些业务逻辑</span></span><br><span class=\"line\">    <span class=\"comment\">//我们习惯性对bitmap使用recycle对其数据进行回收……</span></span><br><span class=\"line\">    bitmap.recycle()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>但是我发现使用了 <code>bitmap.recycle()</code>与不使用，内存中 Native区域仍然占了一大部分，后来在<code>AndroidBitmap_lockPixels</code>的注释才发现不对的地方：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Given a java bitmap object, attempt to lock the pixel address.</span></span><br><span class=\"line\"><span class=\"comment\"> * Locking will ensure that the memory for the pixels will not move</span></span><br><span class=\"line\"><span class=\"comment\"> * until the unlockPixels call, and ensure that, if the pixels had been</span></span><br><span class=\"line\"><span class=\"comment\"> * previously purged, they will have been restored.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * If this call succeeds, it must be balanced by a call to</span></span><br><span class=\"line\"><span class=\"comment\"> * AndroidBitmap_unlockPixels, after which time the address of the pixels should</span></span><br><span class=\"line\"><span class=\"comment\"> * no longer be used.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * If this succeeds, *addrPtr will be set to the pixel address. If the call</span></span><br><span class=\"line\"><span class=\"comment\"> * fails, addrPtr will be ignored.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">AndroidBitmap_lockPixels</span><span class=\"params\">(JNIEnv* env, jobject jbitmap, <span class=\"type\">void</span>** addrPtr)</span></span>;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>其中：</p>\n<blockquote>\n<p><strong>if the pixels had been previously purged, they will have been restored.</strong></p>\n</blockquote>\n<p>也就是说在<code>AndroidBitmap_unlockPixels</code> 调用之前，如果像素数据被销毁了，他们会被恢复！至于为什么会被恢复，这个就需要之后再进行研究了。</p>\n<p>后来对逻辑进行更改，将 Bitmap.recycle()的逻辑移动到 AndroidBitmap_unlockPixels之后。</p>\n","cover":null,"images":[],"content":"<p>此前很多工作都设计到使用 FFmpeg 对视频帧进行获取，在 FFmpeg 解码视频文件获取到帧数据结构是 <code>AVFrame</code>, 对于应用层我们没有办法直接拿到进行数据处理，需要转换为 Android 平台特有的处理结构。而我是需要对应的帧图片数据，那么在 Android 侧需要将其转化为 <code>Bitmap</code> ,之前整理的过程中发现了这篇<a href=\"https://segmentfault.com/a/1190000016674715?utm_source=sf-similar-article\">《Android音视频开发】从AVFrame到MediaFrame数组(二)》</a>博客文章 ，觉得写得很不错，非常精简，适合我的需求，于是对齐进行整理，并标注一下自己在过程中遇到的一些坑点。</p>\n<h2 id=\"Native层创建Bitmap\"><a href=\"#Native层创建Bitmap\" class=\"headerlink\" title=\"Native层创建Bitmap\"></a>Native层创建Bitmap</h2><p><code>Bitmap</code> 是对 <a href=\"https://docs.microsoft.com/en-us/dotnet/api/skiasharp.skbitmap?view=skiasharp-2.80.2\">SkBitmap</a> 的包装。具体说来， Bitmap 的实现包括 Java 层和 JNI 层，JNI 层依赖 Skia，<code>SkBitmap</code> 本质上可简单理解为内存中的一个字节数组</p>\n<p>想要生成 <code>Bitmap</code>,  我们首先需要构造一个 <code>Bitmap</code> 对象，Java层有很多种方式可以生成Bitmap对象，最简单的方式如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">Bitmap.createBitmap(width,height,<span class=\"keyword\">new</span> <span class=\"title class_\">Bitmap</span>.Config.ARGB_8888)</span><br></pre></td></tr></table></figure>\n<p>由于整个 <code>FFmpeg</code>的操作在 JNI 侧进行，对应的操作需要使用 <code>JNIEnv</code>  进行相关的调用，主要逻辑如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">jobject <span class=\"title\">create_bitmap</span><span class=\"params\">(JNIEnv *env, <span class=\"type\">int</span> width, <span class=\"type\">int</span> height)</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 找到 Bitmap.class 和 该类中的 createBitmap 方法</span></span><br><span class=\"line\">    jclass clz_bitmap = env-&gt;<span class=\"built_in\">FindClass</span>(<span class=\"string\">&quot;android/graphics/Bitmap&quot;</span>);</span><br><span class=\"line\">    jmethodID mtd_bitmap = env-&gt;<span class=\"built_in\">GetStaticMethodID</span>(</span><br><span class=\"line\">            clz_bitmap, <span class=\"string\">&quot;createBitmap&quot;</span>,</span><br><span class=\"line\">            <span class=\"string\">&quot;(IILandroid/graphics/Bitmap$Config;)Landroid/graphics/Bitmap;&quot;</span>);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 配置 Bitmap</span></span><br><span class=\"line\">    jstring str_config = env-&gt;<span class=\"built_in\">NewStringUTF</span>(<span class=\"string\">&quot;ARGB_8888&quot;</span>);</span><br><span class=\"line\">    jclass clz_config = env-&gt;<span class=\"built_in\">FindClass</span>(<span class=\"string\">&quot;android/graphics/Bitmap$Config&quot;</span>);</span><br><span class=\"line\">    jmethodID mtd_config = env-&gt;<span class=\"built_in\">GetStaticMethodID</span>(</span><br><span class=\"line\">            clz_config, <span class=\"string\">&quot;valueOf&quot;</span>, <span class=\"string\">&quot;(Ljava/lang/String;)Landroid/graphics/Bitmap$Config;&quot;</span>);</span><br><span class=\"line\">    jobject obj_config = env-&gt;<span class=\"built_in\">CallStaticObjectMethod</span>(clz_config, mtd_config, str_config);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 创建 Bitmap 对象</span></span><br><span class=\"line\">    jobject bitmap = env-&gt;<span class=\"built_in\">CallStaticObjectMethod</span>(</span><br><span class=\"line\">            clz_bitmap, mtd_bitmap, width, height, obj_config);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> bitmap;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"获取Bitmap像素数据地址，并锁定\"><a href=\"#获取Bitmap像素数据地址，并锁定\" class=\"headerlink\" title=\"获取Bitmap像素数据地址，并锁定\"></a>获取Bitmap像素数据地址，并锁定</h2><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> *addr_pixels;</span><br><span class=\"line\"><span class=\"built_in\">AndroidBitmap_lockPixels</span>(env, bitmap, &amp;addr_pixels);</span><br></pre></td></tr></table></figure>\n<p>解释一下这两句话：</p>\n<blockquote>\n<p>第一句的作用声明并定义一个指向任意类型的指针变量，名称是addr_pixels。我们定义它的目的，是让它指向bitmap像素数据(即:<br>addr_pixels的值为bitmap像素数据的地址)。注意哦，这时候，addr_pixels的值是一个随机的值(假定此时为：0x01)，由系统分配，它还不指向bitmap像素数据。<br>第二句话的作用就是将bitmap的像素数据地址赋值给addr_pixels，此时它的值被修改(假定为：0x002)。并且锁定该地址，保证不会被移动。【注：地址不会被移动这里我也不太懂什么意思，有兴趣的可以去查看该方法的API文档】<br>【注：】此时的bitmap由像素数据的地址，但是该地址内还没有任何像素数据哦，或者说它的像素数据为\\0</p>\n</blockquote>\n<p>到这里，我们已经有了源像素数据在AVFrame中，有了目的像素数据地址addr_pixels，那么接下来的任务就是将AVFrame中的像素数据写入到addr_pixels指向的那片内存中去。</p>\n<h2 id=\"向Bitmap中写入像素数据\"><a href=\"#向Bitmap中写入像素数据\" class=\"headerlink\" title=\"向Bitmap中写入像素数据\"></a>向Bitmap中写入像素数据</h2><p>这里要说一下，我们获取到的AVFrame的像素格式通常是YUV格式的，而Bitmap的像素格式通常是RGB格式的。因此我们需要将YUV格式的像素数据转换成RGB格式进行存储。而RGB的存储空间Bitmap不是已经给我门提供好了吗？嘿嘿，直接用就OK了，那现在问题就是YUV如何转换成RGB呢？<br>关于YUV和RGB之间的转换，我知道的有三种方式：</p>\n<ul>\n<li>通过公式换算</li>\n<li>FFmpeg提供的libswscale</li>\n<li>Google提供的libyuv<br>这里我们选择libyuv因为它的性能好、使用简单。</li>\n</ul>\n<p>说它使用简单，到底有多简单，嘿，一个函数就够了！！</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\">libyuv::<span class=\"built_in\">I420ToABGR</span>(frame-&gt;data[<span class=\"number\">0</span>], frame-&gt;linesize[<span class=\"number\">0</span>], <span class=\"comment\">// Y</span></span><br><span class=\"line\">                   frame-&gt;data[<span class=\"number\">1</span>], frame-&gt;linesize[<span class=\"number\">1</span>], <span class=\"comment\">// U</span></span><br><span class=\"line\">                   frame-&gt;data[<span class=\"number\">2</span>], frame-&gt;linesize[<span class=\"number\">2</span>], <span class=\"comment\">// V</span></span><br><span class=\"line\">                   (<span class=\"type\">uint8_t</span> *) addr_pixels, linesize,  <span class=\"comment\">// RGBA</span></span><br><span class=\"line\">                   frame-&gt;width, frame-&gt;height);</span><br></pre></td></tr></table></figure>\n<p>解释一下这个函数：</p>\n<ul>\n<li>I420ToABGR: I420表示的是YUV420P格式，ABGR表示的RGBA格式(execuse me?? 是的，你没看错，Google说RGBA格式的数据在底层的存储方式是ABGR，顺序反过来，看下libyuv源码的函数注释就知道了)</li>\n<li>frame-&gt;data&amp;linesize: 这些个参数表示的是源YUV数据，上面有标注</li>\n<li>(uint8_t *) addr_pixels: 嘿，这个就是说往这块空间里写入像素数据啦</li>\n<li>linesize: 这个表示的是该图片一行数据的字节大小，Bitmap按照RBGA格式存储，也就是说一个像素是4个字节，那么一行共有：frame-&gt;width 个像素，所以：<br>linesize = frame-&gt; width * 4</li>\n</ul>\n<p>【注：】关于这一小块功能的实现，可能其他地方你会看到这样的写法，他们用了如下接口：</p>\n<p>// 思路</p>\n<blockquote>\n<p>是：新建一个AVFrame(RGB格式)，通过av_image_fill_arrays来实现AVFrame(RGB)中像素数据和Bitmap像素数据的关联，也就是让AVFrame(RGB)像素数据指针等于addr_pixels<br>pRGBFrame = av_frame_alloc() av_image_get_buffer_size()<br>av_image_fill_arrays() /<em><br>我也是写到这里的时候，才想到这个问题，为什么要这样用呢，直接使用addr_pixels不是也一样可以么？<br>不过大家都这么用，应该是有它不可替代的使用场景的。因此这里也说一下av_image_fill_arrays这个函数。\n</em>/</p>\n<p>// TODO: 解释下这个函数的作用 av_image_fill_arrays(dst_data, dst_linesize,<br>src_data, pix_fmt, width, height, align); 它的作用就是</p>\n<ol>\n<li>根据src_data，设置dst_data，事实上根据现象或者自己去调试，可以发现dst_data的值就是src_data的值(我印象中好像值是相同的，这会我忘了，后面我再验证下)</li>\n<li>根据pix_fmt, width, height设置linesize的值，其实linesize的计算就和我上面给出的那个公式是一样子的值</li>\n</ol>\n</blockquote>\n<p>OK, 函数执行完毕，我们Bitmap就有了像素数据，下面就是把Bitmap上传给Java层</p>\n<h2 id=\"Native回调Java接口\"><a href=\"#Native回调Java接口\" class=\"headerlink\" title=\"Native回调Java接口\"></a>Native回调Java接口</h2><p>说下Java层</p>\n<p>有一个MainActivity.java用于界面的显示<br>有一个JNIHelper.java用于Java层和Native层的沟通</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">JNIHelper</span> &#123;</span><br><span class=\"line\">   <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">onReceived</span><span class=\"params\">(Bitmap bitmap)</span>&#123;</span><br><span class=\"line\">       <span class=\"comment\">// <span class=\"doctag\">TODO:</span> Java层接收到Bitmap后，可以开始搞事情了</span></span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Native层的回调代码如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\">jclass clz = env-&gt;<span class=\"built_in\">FindClass</span>(<span class=\"string\">&quot;me/oogh/xplayer/JNIHelper&quot;</span>);</span><br><span class=\"line\">jmethodID method = env-&gt;<span class=\"built_in\">GetMethodID</span>(clz, <span class=\"string\">&quot;onReceived&quot;</span>, <span class=\"string\">&quot;(Landroid/graphics/Bitmap;)V&quot;</span>);</span><br><span class=\"line\">env-&gt;<span class=\"built_in\">CallVoidMethod</span>(obj, method, bitmap);</span><br></pre></td></tr></table></figure>\n<h2 id=\"AndroidBitmap-lockPixels-方法\"><a href=\"#AndroidBitmap-lockPixels-方法\" class=\"headerlink\" title=\"AndroidBitmap_lockPixels 方法\"></a>AndroidBitmap_lockPixels 方法</h2><p>以上就是整个文章的内容，使用起来也是 no problem!  但使用过程中遇到的问题就是内存回收的问题，最开始使用的时候并没有过多关注JNI层 <code>AndroidBitmap_lockPixels</code>这个方法，以至于后来我在处理Bitmap内存回收上遇到了一些问题。 <code>AndroidBitmap_lockPixels</code> 与之对应还有一个   <code>AndroidBitmap_unlockPixels</code></p>\n<p><code>AndroidBitmap_lockPixels</code> “函数作用锁定了像素缓存以确保像素的内存不会被移动”，这句话看起来好像挺难理解，但是我们在 Java层面有与之类似的操作，那就是 <code>SurfaceHolder.lockCanvas()</code>，还记得我们在绘制的过程中需要先使用 <code>lockCanvas</code> 锁定画布，返回的画布对象<code>Canvas</code>然后使用 <code>unlockCanvasAndPost(Canvas canvas)</code> 结束锁定画布，并提交改变。<code>AndroidBitmap_lockPixels</code> 与  <code>AndroidBitmap_unlockPixels</code>做的是类似的事情，都是锁住一块内存区域，保证其安全。</p>\n<p>回到上面说的内存回收的问题，由于自己使用失误，流程大概是这样：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">AndroidBitmap_lockPixels</span>(env, bitmap, &amp;addr_pixels);</span><br><span class=\"line\"><span class=\"comment\">//在两者之间，将生成好的 Bitmap Obj 回调到Java层</span></span><br><span class=\"line\"><span class=\"built_in\">AndroidBitmap_unlockPixels</span>(env, bitmap);</span><br></pre></td></tr></table></figure>\n<p>然后在Java层有这样的逻辑：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">onReceived</span><span class=\"params\">(Bitmap bitmap)</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//……一些业务逻辑</span></span><br><span class=\"line\">    <span class=\"comment\">//我们习惯性对bitmap使用recycle对其数据进行回收……</span></span><br><span class=\"line\">    bitmap.recycle()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>但是我发现使用了 <code>bitmap.recycle()</code>与不使用，内存中 Native区域仍然占了一大部分，后来在<code>AndroidBitmap_lockPixels</code>的注释才发现不对的地方：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Given a java bitmap object, attempt to lock the pixel address.</span></span><br><span class=\"line\"><span class=\"comment\"> * Locking will ensure that the memory for the pixels will not move</span></span><br><span class=\"line\"><span class=\"comment\"> * until the unlockPixels call, and ensure that, if the pixels had been</span></span><br><span class=\"line\"><span class=\"comment\"> * previously purged, they will have been restored.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * If this call succeeds, it must be balanced by a call to</span></span><br><span class=\"line\"><span class=\"comment\"> * AndroidBitmap_unlockPixels, after which time the address of the pixels should</span></span><br><span class=\"line\"><span class=\"comment\"> * no longer be used.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * If this succeeds, *addrPtr will be set to the pixel address. If the call</span></span><br><span class=\"line\"><span class=\"comment\"> * fails, addrPtr will be ignored.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">AndroidBitmap_lockPixels</span><span class=\"params\">(JNIEnv* env, jobject jbitmap, <span class=\"type\">void</span>** addrPtr)</span></span>;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>其中：</p>\n<blockquote>\n<p><strong>if the pixels had been previously purged, they will have been restored.</strong></p>\n</blockquote>\n<p>也就是说在<code>AndroidBitmap_unlockPixels</code> 调用之前，如果像素数据被销毁了，他们会被恢复！至于为什么会被恢复，这个就需要之后再进行研究了。</p>\n<p>后来对逻辑进行更改，将 Bitmap.recycle()的逻辑移动到 AndroidBitmap_unlockPixels之后。</p>\n","categories":[{"name":"技术文章","slug":"technology","api":"api/categories/technology.json"}],"tags":[{"name":"FFmpeg","slug":"FFmpeg","api":"api/tags/FFmpeg.json"},{"name":"音视频","slug":"音视频","api":"api/tags/音视频.json"}],"api":"api/posts/2022/05/22/FFmpeg之AVFrame转Android-Bitmap.json"},{"title":"记一次Android依赖库版本不兼容的问题处理过程","slug":"记一次Android依赖-wire-低版本与高版本不兼容的处理过程","date":"2022-03-31T02:47:00.000Z","updated":"2025-05-20T11:46:57.000Z","comments":true,"url":"2022/03/31/记一次Android依赖-wire-低版本与高版本不兼容的处理过程/","excerpt":"<p>此前我们项目组开发了相关 SDK 并集成到 App 工程中进行测试，发现业务App中的 <a href=\"https://github.com/square/wire\">wire</a> (一个与 protobuf 相关的库)，版本为1.5.1，而 SDK 中所依赖的版本为3.7.0，两者之间相互不兼容。如果要让业务升级到高版本的库的话，初步排查低版本中使用的某个类而高版本中已废除，单纯的就这一个类涉及100多个文件，工程量太大了，SDK中亦然。所以不能通过简单地更改版本号来解决版本冲突问题，最后经过一系列的尝试，终于解决了该问题。</p>\n<h2 id=\"分析和处理\"><a href=\"#分析和处理\" class=\"headerlink\" title=\"分析和处理\"></a>分析和处理</h2><p>最初集成 SDK 到 App 运行时发现报错：<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">java.lang.NoClassDefFoundError: Failed resolution of: Lcom/squareup/wire/ProtoEnum;</span><br></pre></td></tr></table></figure><br>检查代码发现 <code>ProtoEnum</code>位于wire 1.5.1中，打印依赖树发现App中的库被SDK所依赖的库给覆盖掉了，自动升级到新的版本，但新的版本又不存在该类。</p>\n<blockquote>\n<p><code>|    |    |    \\--- com.squareup.wire:wire-runtime:1.5.1 -&gt; 3.7.0</code></p>\n</blockquote>\n<p>以为只是简单的版本冲突的问题，尝试解冲突，我们知道处理Android版本冲突主要使用 <code>exclude``transitive</code> <code>force</code> gralde 处理依赖的关键字解决依赖冲突，但我无论使用什么操作整个项目中所打出来的Apk只存在一个版本：要么1.5.1要么3.7.0，对比两个库：<br><img src=\"https://cdn.julis.wang/blog/img/acb66f45a28a458fb4d00ae03cecafc1.png\"><br>发现高版本相比于低版本多了太多的类，以及一部分类进行了改名，至此我们可以得出一个结论：<strong>wire库高版本(3.7.1)与低版本(1.5.1)完全不兼容。</strong> 现在摆在我面前有两条路可以走：</p>\n<p>一、手动升级App中的低版本</p>\n<p>二、手动降级SDK中的高版本</p>\n<p>对于第一种，发现到App中大量文件使用 Wire 中的 <code>Message</code> 类，虽然两个版本都有<code>Message</code>类，但是两者“今非昔比”，涉及到太多的方法改动，而 <code>Message</code> 类在App有100+文件使用，如果一个个改过去，可能XXXXXXXX了。</p>\n<p>两个库之间有这么大的差异，甚至1.X版本不支持kotlin，而SDK中大量代码都是使用的 Kotlin，那么第二种降低SDK的高版本也自然变得不太现实。</p>\n<p>向大佬们请教，有被指点到：<strong>是否可以通过 ffat-aar+混淆的方式将 wire库跟SDK合并打包到一起？</strong></p>\n<p>！！大佬毕竟大佬，我的脑子瞬间有一种叮咚的感觉，其实这种方式也就是将SDK变向的重命名，将两个不同的版本库进行“共存”，现在要做的就是：<strong>将 SDK 中的高版本的库包名给改掉，以达到两个不同版本库之间的兼容。</strong></p>\n<p>说干就干，打好了库之后运行发现：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">java.lang.RuntimeException: Duplicate class a.a.a.a found in modules</span><br><span class=\"line\">etified-target-SDK-0.0.1.11-SNAPSHOT-runtime.jar</span><br><span class=\"line\">and ctlogin-0.4.23.04_lol_47-runtime.jar</span><br><span class=\"line\">(clogin-sso.clogin:0.4.23.04_lol_47)</span><br></pre></td></tr></table></figure>\n<img src=\"https://cdn.julis.wang/blog/img/41a8f2543baa48c5bf6b5a363cde6a9b.png\">\n<p>我当时内心就是这个表情,心想：难道<code>wtlogin</code> 大佬们也是想采用这种方式来避免一些库的兼容问题？这问题不大，因为混淆默认从a-z进行命名，只要给混淆再配一些参数就能避免掉这个问题，于是加上以下参数<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">-obfuscationdictionary obfucationdictionary.txt</span><br><span class=\"line\">-classobfuscationdictionary obfucationdictionary.txt</span><br><span class=\"line\">-packageobfuscationdictionary obfucationdictionary.txt</span><br></pre></td></tr></table></figure><br>当再次运行的时候，发现又报错了：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">java.lang.NoClassDefFoundError: Failed resolution of: Lcom/squareup/wire/ProtoAdapter;</span><br></pre></td></tr></table></figure>\n<p>？？？<code>ProtoAdapter</code> 是属于3.7.0高版本的类，不是已经被混淆了么？为什么还会报这个错？<br><img src=\"https://cdn.julis.wang/blog/img/32adc8ebefda4dfea050974c533fb4de.png\"><br>难道是使用混淆的方式是不行的？于是继续搜寻解决方案，了解到使用 <a href=\"https://github.com/shevek/jarjar\">jarjar.jar</a>可以对包重新命名打包，尝试了一下运行，依然报错<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">java.lang.NoClassDefFoundError: Failed resolution of: Lcom/squareup/wire/ProtoAdapter;</span><br></pre></td></tr></table></figure></p>\n<p>到底哪里还有 使用 <code>com/squareup/wire/ProtoAdapter</code>呢？使用<code>jd-gui</code>对重新打好的 jar 包的内容进行搜索.<br><img src=\"https://cdn.julis.wang/blog/img/14e36a6fa7da4feda26779f83b4e9b63.png\"><br>果然有搜到相应的内容，这是一个字符串，第一反应就是反射。我瞬间明白了，这是一串字符串并且是写死的，回到App中来，如下图所示：<code>wire</code>库的作用是将 .proto 文件生成咱们通常所说的 Model 类，下图的    <code>AudioEffect</code>就是通过 .proto 文件中定义好的属性生成的。<br><img src=\"https://cdn.julis.wang/blog/img/1512ded69e1248ac9e19ef5a4b995c63.png\"><br>那该怎么办呢？就一个依赖库版本冲突的问题，常规的方法就这些呀，难道真的要肝一波了么？<br><img src=\"https://cdn.julis.wang/blog/img/a5011fe0e772443f8e00fbbdd0b7f09f.png\"><br>到这里我们大概知道是怎么回事了，我们的目标很简单，就是改一个包名，但是包又在  <code>wire-gradle-plugin</code> 插件中，所以改wire的运行库当然是不行的……</p>\n<p>那还有一个终极办法：<strong>改源码</strong>。</p>\n<p>说干就干，直接拉 <a href=\"https://github.com/square/wire\">wire</a> 源码</p>\n<img src=\"https://cdn.julis.wang/blog/img/2dab42479a29453391b68a979008ae31.png\">\n<p>，主要关注以下几个目录：<br><code>wire-gradle-plugin</code>: wire-gradle 插件的主要源码<br><code>wire-compiler</code>: wire编译.proto相关的操作<br><code>wire-runtime</code>: wire运行时所需要的类<br>接下来要做的就是 <strong>右键+rename</strong>,重新编译打包，也……就1000多处改动</p>\n<img src=\"https://cdn.julis.wang/blog/img/daac3e4f19db4e5c9b8d1354ab65b7b7.png\">\n<p>打完包之后发现整个插件生成出来类的包还是包含<code>&quot;com.squareup.wire.ProtoAdapter&quot;</code>，我的目标是生成：<code>&quot;com.squareup.xxxx_.ProtoAdapter&quot;</code>，跟wire-plguin-gradle的源码，发现有这么一处：</p>\n<img src=\"https://cdn.julis.wang/blog/img/fed8bf2812474044b6344ec7d0acf290.png\">\n<p>它回在运行中重新从仓库中拉取<code>com.squareup.wire:wire-runtime:3.7.0</code>，于是需要对整个<code>wire-runtime</code>也重新打包，最终生成了一系列jar包如下所示：然后将其作为 plugin </p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"code\"><pre><span class=\"line\">classpath files(<span class=\"string\">&#x27;wire-profiles-3.7.0.jar&#x27;</span>)</span><br><span class=\"line\">classpath files(<span class=\"string\">&#x27;wire-compiler-3.7.0.jar&#x27;</span>)</span><br><span class=\"line\">classpath files(<span class=\"string\">&#x27;wire-kotlin-generator-3.7.0.jar&#x27;</span>)</span><br><span class=\"line\">classpath files(<span class=\"string\">&#x27;wire-gradle-plugin-3.7.0.jar&#x27;</span>)</span><br><span class=\"line\">classpath files(<span class=\"string\">&#x27;wire-schema-jvm-3.7.0.jar&#x27;</span>)</span><br></pre></td></tr></table></figure>\n<p>然后再将运行时所需要的类跟随SDK一起打包</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"code\"><pre><span class=\"line\">implementation files(<span class=\"string\">&#x27;src/libs/wire-runtime-jvm-3.7.0.jar&#x27;</span>)</span><br></pre></td></tr></table></figure>\n<p>重新编译打包，run、install 成功运行！</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>1、整个一系列操作，让我又学到了很多平时没有接触过的东西，比如：jarjar.jar，这个库对一些比较小的库存，或者说轻量级的库重新命名会比较快速的解决。本文中所述的 wire 库实在是太复杂，只能从源码层面进行操作了。还有就是在看 wire工程源码的时候又发现了一个<strong>shadowJar</strong>(利用gradle shadowjar构建包含依赖的JAR包)，之前一直用 ffat-aar打入的依赖，不知道这个插件怎么样，后面学习学习试试。</p>\n<p>2、在改整个源码之前，其实内心是比较抗拒的，因为一般改源码这种操作都是比较危险，或者更耗时，有可能就算改完了，也不一定能正常运行，一度想放弃，但实在是不想去改业务中那100+的文件，既然一条路走到黑，还是走下去吧，让我明白一定要坚持下去，不要放弃。</p>\n","cover":null,"images":["https://cdn.julis.wang/blog/img/acb66f45a28a458fb4d00ae03cecafc1.png","https://cdn.julis.wang/blog/img/41a8f2543baa48c5bf6b5a363cde6a9b.png","https://cdn.julis.wang/blog/img/32adc8ebefda4dfea050974c533fb4de.png","https://cdn.julis.wang/blog/img/14e36a6fa7da4feda26779f83b4e9b63.png","https://cdn.julis.wang/blog/img/2dab42479a29453391b68a979008ae31.png","https://cdn.julis.wang/blog/img/daac3e4f19db4e5c9b8d1354ab65b7b7.png","https://cdn.julis.wang/blog/img/fed8bf2812474044b6344ec7d0acf290.png"],"content":"<p>此前我们项目组开发了相关 SDK 并集成到 App 工程中进行测试，发现业务App中的 <a href=\"https://github.com/square/wire\">wire</a> (一个与 protobuf 相关的库)，版本为1.5.1，而 SDK 中所依赖的版本为3.7.0，两者之间相互不兼容。如果要让业务升级到高版本的库的话，初步排查低版本中使用的某个类而高版本中已废除，单纯的就这一个类涉及100多个文件，工程量太大了，SDK中亦然。所以不能通过简单地更改版本号来解决版本冲突问题，最后经过一系列的尝试，终于解决了该问题。</p>\n<h2 id=\"分析和处理\"><a href=\"#分析和处理\" class=\"headerlink\" title=\"分析和处理\"></a>分析和处理</h2><p>最初集成 SDK 到 App 运行时发现报错：<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">java.lang.NoClassDefFoundError: Failed resolution of: Lcom/squareup/wire/ProtoEnum;</span><br></pre></td></tr></table></figure><br>检查代码发现 <code>ProtoEnum</code>位于wire 1.5.1中，打印依赖树发现App中的库被SDK所依赖的库给覆盖掉了，自动升级到新的版本，但新的版本又不存在该类。</p>\n<blockquote>\n<p><code>|    |    |    \\--- com.squareup.wire:wire-runtime:1.5.1 -&gt; 3.7.0</code></p>\n</blockquote>\n<p>以为只是简单的版本冲突的问题，尝试解冲突，我们知道处理Android版本冲突主要使用 <code>exclude``transitive</code> <code>force</code> gralde 处理依赖的关键字解决依赖冲突，但我无论使用什么操作整个项目中所打出来的Apk只存在一个版本：要么1.5.1要么3.7.0，对比两个库：<br><img src=\"https://cdn.julis.wang/blog/img/acb66f45a28a458fb4d00ae03cecafc1.png\"><br>发现高版本相比于低版本多了太多的类，以及一部分类进行了改名，至此我们可以得出一个结论：<strong>wire库高版本(3.7.1)与低版本(1.5.1)完全不兼容。</strong> 现在摆在我面前有两条路可以走：</p>\n<p>一、手动升级App中的低版本</p>\n<p>二、手动降级SDK中的高版本</p>\n<p>对于第一种，发现到App中大量文件使用 Wire 中的 <code>Message</code> 类，虽然两个版本都有<code>Message</code>类，但是两者“今非昔比”，涉及到太多的方法改动，而 <code>Message</code> 类在App有100+文件使用，如果一个个改过去，可能XXXXXXXX了。</p>\n<p>两个库之间有这么大的差异，甚至1.X版本不支持kotlin，而SDK中大量代码都是使用的 Kotlin，那么第二种降低SDK的高版本也自然变得不太现实。</p>\n<p>向大佬们请教，有被指点到：<strong>是否可以通过 ffat-aar+混淆的方式将 wire库跟SDK合并打包到一起？</strong></p>\n<p>！！大佬毕竟大佬，我的脑子瞬间有一种叮咚的感觉，其实这种方式也就是将SDK变向的重命名，将两个不同的版本库进行“共存”，现在要做的就是：<strong>将 SDK 中的高版本的库包名给改掉，以达到两个不同版本库之间的兼容。</strong></p>\n<p>说干就干，打好了库之后运行发现：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">java.lang.RuntimeException: Duplicate class a.a.a.a found in modules</span><br><span class=\"line\">etified-target-SDK-0.0.1.11-SNAPSHOT-runtime.jar</span><br><span class=\"line\">and ctlogin-0.4.23.04_lol_47-runtime.jar</span><br><span class=\"line\">(clogin-sso.clogin:0.4.23.04_lol_47)</span><br></pre></td></tr></table></figure>\n<img src=\"https://cdn.julis.wang/blog/img/41a8f2543baa48c5bf6b5a363cde6a9b.png\">\n<p>我当时内心就是这个表情,心想：难道<code>wtlogin</code> 大佬们也是想采用这种方式来避免一些库的兼容问题？这问题不大，因为混淆默认从a-z进行命名，只要给混淆再配一些参数就能避免掉这个问题，于是加上以下参数<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">-obfuscationdictionary obfucationdictionary.txt</span><br><span class=\"line\">-classobfuscationdictionary obfucationdictionary.txt</span><br><span class=\"line\">-packageobfuscationdictionary obfucationdictionary.txt</span><br></pre></td></tr></table></figure><br>当再次运行的时候，发现又报错了：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">java.lang.NoClassDefFoundError: Failed resolution of: Lcom/squareup/wire/ProtoAdapter;</span><br></pre></td></tr></table></figure>\n<p>？？？<code>ProtoAdapter</code> 是属于3.7.0高版本的类，不是已经被混淆了么？为什么还会报这个错？<br><img src=\"https://cdn.julis.wang/blog/img/32adc8ebefda4dfea050974c533fb4de.png\"><br>难道是使用混淆的方式是不行的？于是继续搜寻解决方案，了解到使用 <a href=\"https://github.com/shevek/jarjar\">jarjar.jar</a>可以对包重新命名打包，尝试了一下运行，依然报错<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">java.lang.NoClassDefFoundError: Failed resolution of: Lcom/squareup/wire/ProtoAdapter;</span><br></pre></td></tr></table></figure></p>\n<p>到底哪里还有 使用 <code>com/squareup/wire/ProtoAdapter</code>呢？使用<code>jd-gui</code>对重新打好的 jar 包的内容进行搜索.<br><img src=\"https://cdn.julis.wang/blog/img/14e36a6fa7da4feda26779f83b4e9b63.png\"><br>果然有搜到相应的内容，这是一个字符串，第一反应就是反射。我瞬间明白了，这是一串字符串并且是写死的，回到App中来，如下图所示：<code>wire</code>库的作用是将 .proto 文件生成咱们通常所说的 Model 类，下图的    <code>AudioEffect</code>就是通过 .proto 文件中定义好的属性生成的。<br><img src=\"https://cdn.julis.wang/blog/img/1512ded69e1248ac9e19ef5a4b995c63.png\"><br>那该怎么办呢？就一个依赖库版本冲突的问题，常规的方法就这些呀，难道真的要肝一波了么？<br><img src=\"https://cdn.julis.wang/blog/img/a5011fe0e772443f8e00fbbdd0b7f09f.png\"><br>到这里我们大概知道是怎么回事了，我们的目标很简单，就是改一个包名，但是包又在  <code>wire-gradle-plugin</code> 插件中，所以改wire的运行库当然是不行的……</p>\n<p>那还有一个终极办法：<strong>改源码</strong>。</p>\n<p>说干就干，直接拉 <a href=\"https://github.com/square/wire\">wire</a> 源码</p>\n<img src=\"https://cdn.julis.wang/blog/img/2dab42479a29453391b68a979008ae31.png\">\n<p>，主要关注以下几个目录：<br><code>wire-gradle-plugin</code>: wire-gradle 插件的主要源码<br><code>wire-compiler</code>: wire编译.proto相关的操作<br><code>wire-runtime</code>: wire运行时所需要的类<br>接下来要做的就是 <strong>右键+rename</strong>,重新编译打包，也……就1000多处改动</p>\n<img src=\"https://cdn.julis.wang/blog/img/daac3e4f19db4e5c9b8d1354ab65b7b7.png\">\n<p>打完包之后发现整个插件生成出来类的包还是包含<code>&quot;com.squareup.wire.ProtoAdapter&quot;</code>，我的目标是生成：<code>&quot;com.squareup.xxxx_.ProtoAdapter&quot;</code>，跟wire-plguin-gradle的源码，发现有这么一处：</p>\n<img src=\"https://cdn.julis.wang/blog/img/fed8bf2812474044b6344ec7d0acf290.png\">\n<p>它回在运行中重新从仓库中拉取<code>com.squareup.wire:wire-runtime:3.7.0</code>，于是需要对整个<code>wire-runtime</code>也重新打包，最终生成了一系列jar包如下所示：然后将其作为 plugin </p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"code\"><pre><span class=\"line\">classpath files(<span class=\"string\">&#x27;wire-profiles-3.7.0.jar&#x27;</span>)</span><br><span class=\"line\">classpath files(<span class=\"string\">&#x27;wire-compiler-3.7.0.jar&#x27;</span>)</span><br><span class=\"line\">classpath files(<span class=\"string\">&#x27;wire-kotlin-generator-3.7.0.jar&#x27;</span>)</span><br><span class=\"line\">classpath files(<span class=\"string\">&#x27;wire-gradle-plugin-3.7.0.jar&#x27;</span>)</span><br><span class=\"line\">classpath files(<span class=\"string\">&#x27;wire-schema-jvm-3.7.0.jar&#x27;</span>)</span><br></pre></td></tr></table></figure>\n<p>然后再将运行时所需要的类跟随SDK一起打包</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"code\"><pre><span class=\"line\">implementation files(<span class=\"string\">&#x27;src/libs/wire-runtime-jvm-3.7.0.jar&#x27;</span>)</span><br></pre></td></tr></table></figure>\n<p>重新编译打包，run、install 成功运行！</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>1、整个一系列操作，让我又学到了很多平时没有接触过的东西，比如：jarjar.jar，这个库对一些比较小的库存，或者说轻量级的库重新命名会比较快速的解决。本文中所述的 wire 库实在是太复杂，只能从源码层面进行操作了。还有就是在看 wire工程源码的时候又发现了一个<strong>shadowJar</strong>(利用gradle shadowjar构建包含依赖的JAR包)，之前一直用 ffat-aar打入的依赖，不知道这个插件怎么样，后面学习学习试试。</p>\n<p>2、在改整个源码之前，其实内心是比较抗拒的，因为一般改源码这种操作都是比较危险，或者更耗时，有可能就算改完了，也不一定能正常运行，一度想放弃，但实在是不想去改业务中那100+的文件，既然一条路走到黑，还是走下去吧，让我明白一定要坚持下去，不要放弃。</p>\n","categories":[],"tags":[{"name":"技术文章","slug":"technology","api":"api/tags/technology.json"}],"api":"api/posts/2022/03/31/记一次Android依赖-wire-低版本与高版本不兼容的处理过程.json"},{"title":"Android 视频抽帧","slug":"Android-视频抽帧相关","date":"2022-02-22T08:11:00.000Z","updated":"2025-05-20T11:46:57.000Z","comments":true,"url":"2022/02/22/Android-视频抽帧相关/","excerpt":"<p>要对移动端的抽帧，对于 iOS 来说，有 <a href=\"https://developer.apple.com/documentation/avfoundation\">AVFoundation</a> 这样一个神奇的库，开箱即用，已经支持了抽帧并且效率非常的高。而 Android 就不那么乐观了，Android 自带的 <code>MediaMetadataRetriever</code> 也能实现抽帧并将帧数据转化为 Bitmap，但效率非常低，平均抽取一帧需要 200ms-300ms，这当然满足不了我们的需求。无独有偶，Android 还提供了另一个类 <code>MediaCodec</code>-用于对音视频进行编解码的类，它通过访问底层的 codec 来实现编解码的功能，我们能对解码的数据进行定制化处理，本文也主要讲解利用 MediaCodec 进行抽帧。</p>\n<h2 id=\"一、MediaCodec\"><a href=\"#一、MediaCodec\" class=\"headerlink\" title=\"一、MediaCodec\"></a>一、MediaCodec</h2><p>为什么选择 MediaCodec? 项目的前期做了比较多的调研，在 Android 平台上除了 <code>MediaCodec</code> 还可以实现抽帧的方案有：<code>MediaMetadataRetriever</code>、<code>OpenCV</code>、<code>FFmpeg</code>，对于前两者实现效率非常的低，获取成本也比较大，对于 <code>FFmpeg</code>方案有进行了一定的尝试，ffmpeg是软解码抽帧(当然ffmpeg也可以 ffmpeg+mediaCodec 进行硬解码)，在设置 <code>AVCodecContext-&gt;thread_count=8</code> 速度提升了很多个档次，但对于 CPU 的使用率非常的高，消耗资源比较严重，不利于手机的流畅度，这里不再赘述。</p>\n<img src=\"https://cdn.julis.wang/blog/img/59036b70b7b44ccbad6b0b5c75445820.png\">\n<p>如上图所示 ffmpeg 软解 CPU 的使用率，维持在80%左右。</p>\n<p>MediaCodec 实现抽帧主要是参考 bigflake 网站提供的抽帧 Demo:<br><a href=\"https://bigflake.com/mediacodec/ExtractMpegFramesTest_egl14.java.txt\">ExtractMpegFramesTest</a></p>\n<p>主要方案流程如下图所示：</p>\n<img src=\"https://cdn.julis.wang/blog/img/b256cc7c59104dfa992e7672be571009.png\">\n<p>方案使用 <code>MediaExtractor</code> 获取 Codec-specific Data(对于H.264来说，”csd-0”和”csd-1”分别对应sps和pps；对于AAC来说，”csd-0”对应ADTS)发送给 <code>MediaCodec</code> 进行解码，将解码后的数据存放在 <code>Surface</code>，由于不需要将解码后的帧进行播放展示，我们进行离屏渲染(Pbuffer)，通过 <code>glReadPixels()</code> 将 GPU 渲染完存在显存数据，回传内存。获取到对应帧 Buffer 数据之后，再利用<code>Bitmap.copyPixelsFromBuffer</code> 创建 Android 平台 Bitmap 对象。</p>\n<p>但整个方案尝试下来之后发现：使用 <code>glReadPixels</code> 将显存数据回传，以及保存 Bitmap 是比较耗时以及消耗内存的操作。</p>\n<p>那么我们可以将数据不进行回传也不保存为 Bitmap，而直接使用 GPU 上的数据进行识别么？</p>\n<h2 id=\"二、GPU-Buffer-生成流程\"><a href=\"#二、GPU-Buffer-生成流程\" class=\"headerlink\" title=\"二、GPU Buffer 生成流程\"></a>二、GPU Buffer 生成流程</h2><p>在创建GPU Buffer之前我们需要简单介绍一下 <code>SurfaceTexture</code>，SurfaceTexture 是离屏渲染,内部包含了一个BufferQueue，可以把 Surface 生成的图像流，转换为纹理，供进一步加工使用。那么 <code>SurfaceTexture</code> 与前面的 MediaCodec 结合起来</p>\n<p>我们的目的是为了将 GPU 上的图片 buffer 传递给算法侧进行识别，来自 SurfaceTexture 只支持外部 GLES 纹理<code>GL_TEXTURE_EXTERNAL_OES</code>，而算法一般都是基于 <code>OpenGL</code>使用 <code>GL_TEXTURE_2D</code> , 所以需要客户端这边做一个转换工作。</p>\n<p>外部纹理 <code>GL_TEXTURE_EXTERNAL_OES</code> 的主要优势是它们能够直接从 BufferQueue 数据进行渲染。</p>\n<p>整体流程如下图所示：<br><img src=\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f9b96bb960304a46867fe7d65a27f540~tplv-k3u1fbpfcp-zoom-crop-mark:3024:3024:3024:1702.awebp??height=952&amp;width=1610\" alt=\"\"></p>\n<p>在拿到了 GPU Buffer 之后，就可以与算法愉快的进行相关的识别了，并且使用硬解抽帧之后对于 CPU 的使用率降到了15%左右。</p>\n<img src=\"https://cdn.julis.wang/blog/img/e05acc59ef49439e98293d38695991c2.png\">\n<h2 id=\"三、总结\"><a href=\"#三、总结\" class=\"headerlink\" title=\"三、总结\"></a>三、总结</h2><p>使用 MediaCodec 抽帧最大的优点就是能够使用硬件进行解码，降低 CPU 的使用率，并且整个帧数据可以存在于 GPU 上，算法侧也能直接拿取数据进行进行识别，能比较好的提升 “抽帧-识别” 的效率。但由于硬解码在不同的硬件上表现的性能有一定的差异，以及在不同的视频与FFmpeg上也有存在不同的性能差异，各有优劣，所以在后续的方案上，针对于不同的视频可能会采取不同的方案进行抽帧。</p>\n<p>参考：</p>\n<p>1.<a href=\"https://bigflake.com/mediacodec/ExtractMpegFramesTest_egl14.java.txt\">ExtractMpegFramesTest.java</a></p>\n<p>2.<a href=\"https://source.android.google.cn/devices/graphics/arch-st?hl=zh-c\">SurfaceTexture</a></p>\n<p>3.<a href=\"https://juejin.cn/post/701251727476817923\">Android Opengl OES 纹理渲染到 GL_TEXTURE_2D</a></p>\n","cover":null,"images":["https://cdn.julis.wang/blog/img/59036b70b7b44ccbad6b0b5c75445820.png","https://cdn.julis.wang/blog/img/b256cc7c59104dfa992e7672be571009.png","https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f9b96bb960304a46867fe7d65a27f540~tplv-k3u1fbpfcp-zoom-crop-mark:3024:3024:3024:1702.awebp??height=952&amp;width=1610","https://cdn.julis.wang/blog/img/e05acc59ef49439e98293d38695991c2.png"],"content":"<p>要对移动端的抽帧，对于 iOS 来说，有 <a href=\"https://developer.apple.com/documentation/avfoundation\">AVFoundation</a> 这样一个神奇的库，开箱即用，已经支持了抽帧并且效率非常的高。而 Android 就不那么乐观了，Android 自带的 <code>MediaMetadataRetriever</code> 也能实现抽帧并将帧数据转化为 Bitmap，但效率非常低，平均抽取一帧需要 200ms-300ms，这当然满足不了我们的需求。无独有偶，Android 还提供了另一个类 <code>MediaCodec</code>-用于对音视频进行编解码的类，它通过访问底层的 codec 来实现编解码的功能，我们能对解码的数据进行定制化处理，本文也主要讲解利用 MediaCodec 进行抽帧。</p>\n<h2 id=\"一、MediaCodec\"><a href=\"#一、MediaCodec\" class=\"headerlink\" title=\"一、MediaCodec\"></a>一、MediaCodec</h2><p>为什么选择 MediaCodec? 项目的前期做了比较多的调研，在 Android 平台上除了 <code>MediaCodec</code> 还可以实现抽帧的方案有：<code>MediaMetadataRetriever</code>、<code>OpenCV</code>、<code>FFmpeg</code>，对于前两者实现效率非常的低，获取成本也比较大，对于 <code>FFmpeg</code>方案有进行了一定的尝试，ffmpeg是软解码抽帧(当然ffmpeg也可以 ffmpeg+mediaCodec 进行硬解码)，在设置 <code>AVCodecContext-&gt;thread_count=8</code> 速度提升了很多个档次，但对于 CPU 的使用率非常的高，消耗资源比较严重，不利于手机的流畅度，这里不再赘述。</p>\n<img src=\"https://cdn.julis.wang/blog/img/59036b70b7b44ccbad6b0b5c75445820.png\">\n<p>如上图所示 ffmpeg 软解 CPU 的使用率，维持在80%左右。</p>\n<p>MediaCodec 实现抽帧主要是参考 bigflake 网站提供的抽帧 Demo:<br><a href=\"https://bigflake.com/mediacodec/ExtractMpegFramesTest_egl14.java.txt\">ExtractMpegFramesTest</a></p>\n<p>主要方案流程如下图所示：</p>\n<img src=\"https://cdn.julis.wang/blog/img/b256cc7c59104dfa992e7672be571009.png\">\n<p>方案使用 <code>MediaExtractor</code> 获取 Codec-specific Data(对于H.264来说，”csd-0”和”csd-1”分别对应sps和pps；对于AAC来说，”csd-0”对应ADTS)发送给 <code>MediaCodec</code> 进行解码，将解码后的数据存放在 <code>Surface</code>，由于不需要将解码后的帧进行播放展示，我们进行离屏渲染(Pbuffer)，通过 <code>glReadPixels()</code> 将 GPU 渲染完存在显存数据，回传内存。获取到对应帧 Buffer 数据之后，再利用<code>Bitmap.copyPixelsFromBuffer</code> 创建 Android 平台 Bitmap 对象。</p>\n<p>但整个方案尝试下来之后发现：使用 <code>glReadPixels</code> 将显存数据回传，以及保存 Bitmap 是比较耗时以及消耗内存的操作。</p>\n<p>那么我们可以将数据不进行回传也不保存为 Bitmap，而直接使用 GPU 上的数据进行识别么？</p>\n<h2 id=\"二、GPU-Buffer-生成流程\"><a href=\"#二、GPU-Buffer-生成流程\" class=\"headerlink\" title=\"二、GPU Buffer 生成流程\"></a>二、GPU Buffer 生成流程</h2><p>在创建GPU Buffer之前我们需要简单介绍一下 <code>SurfaceTexture</code>，SurfaceTexture 是离屏渲染,内部包含了一个BufferQueue，可以把 Surface 生成的图像流，转换为纹理，供进一步加工使用。那么 <code>SurfaceTexture</code> 与前面的 MediaCodec 结合起来</p>\n<p>我们的目的是为了将 GPU 上的图片 buffer 传递给算法侧进行识别，来自 SurfaceTexture 只支持外部 GLES 纹理<code>GL_TEXTURE_EXTERNAL_OES</code>，而算法一般都是基于 <code>OpenGL</code>使用 <code>GL_TEXTURE_2D</code> , 所以需要客户端这边做一个转换工作。</p>\n<p>外部纹理 <code>GL_TEXTURE_EXTERNAL_OES</code> 的主要优势是它们能够直接从 BufferQueue 数据进行渲染。</p>\n<p>整体流程如下图所示：<br><img src=\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f9b96bb960304a46867fe7d65a27f540~tplv-k3u1fbpfcp-zoom-crop-mark:3024:3024:3024:1702.awebp??height=952&amp;width=1610\" alt=\"\"></p>\n<p>在拿到了 GPU Buffer 之后，就可以与算法愉快的进行相关的识别了，并且使用硬解抽帧之后对于 CPU 的使用率降到了15%左右。</p>\n<img src=\"https://cdn.julis.wang/blog/img/e05acc59ef49439e98293d38695991c2.png\">\n<h2 id=\"三、总结\"><a href=\"#三、总结\" class=\"headerlink\" title=\"三、总结\"></a>三、总结</h2><p>使用 MediaCodec 抽帧最大的优点就是能够使用硬件进行解码，降低 CPU 的使用率，并且整个帧数据可以存在于 GPU 上，算法侧也能直接拿取数据进行进行识别，能比较好的提升 “抽帧-识别” 的效率。但由于硬解码在不同的硬件上表现的性能有一定的差异，以及在不同的视频与FFmpeg上也有存在不同的性能差异，各有优劣，所以在后续的方案上，针对于不同的视频可能会采取不同的方案进行抽帧。</p>\n<p>参考：</p>\n<p>1.<a href=\"https://bigflake.com/mediacodec/ExtractMpegFramesTest_egl14.java.txt\">ExtractMpegFramesTest.java</a></p>\n<p>2.<a href=\"https://source.android.google.cn/devices/graphics/arch-st?hl=zh-c\">SurfaceTexture</a></p>\n<p>3.<a href=\"https://juejin.cn/post/701251727476817923\">Android Opengl OES 纹理渲染到 GL_TEXTURE_2D</a></p>\n","categories":[{"name":"技术文章","slug":"technology","api":"api/categories/technology.json"}],"tags":[{"name":"FFmpeg","slug":"FFmpeg","api":"api/tags/FFmpeg.json"},{"name":"MediaCodec","slug":"MediaCodec","api":"api/tags/MediaCodec.json"}],"api":"api/posts/2022/02/22/Android-视频抽帧相关.json"},{"title":"快捷-Mac桌面adb push小工具","slug":"快捷-Mac桌面adb-push小工具","date":"2022-01-15T15:43:00.000Z","updated":"2025-09-15T13:12:07.867Z","comments":true,"url":"2022/01/15/快捷-Mac桌面adb-push小工具/","excerpt":"<p>最近在Android开发过程中会遇到很多传文件的操作，市面上也有比较多的“文件管理器”，例如锤子的HandShaker，或者谷歌官方的<a href=\"https://www.android.com/filetransfer/\">filetransfer</a>,但他们都需要打开“传输文件”这个行为，个人感觉比较繁琐。作为Android开发，使用adb命令行去传输文件是不错的，但每次输入<code>adb push xxx</code>还是挺麻烦，而且必须打开 Terminal 才能运行。为了让所有操作更简化，我做了一个简单的桌面工具，只需要连上手机，正常打开adb，拖到文件到对应区域，则可以实现文件传输。</p>\n<h2 id=\"Macos-Adb-Helper\"><a href=\"#Macos-Adb-Helper\" class=\"headerlink\" title=\"Macos Adb Helper\"></a>Macos Adb Helper</h2><p>由于自己主要是从事Android相关的开发，对于Mac桌面端的开发不太熟悉，但是 Flutter 这个神奇的跨平台框架可以让你稍微消除这个平衡。</p>\n<p>实现一键拖拽文件发送到Android手机，主要需要实现的功能有两个：</p>\n<p>1、文件拖动功能</p>\n<p>2、发送功能</p>\n<h3 id=\"文件拖动功能\"><a href=\"#文件拖动功能\" class=\"headerlink\" title=\"文件拖动功能\"></a>文件拖动功能</h3><p>拖动功能也不需要自己去写，已经有现成的库 <a href=\"https://pub.dev/packages/desktop_drop\">desktop_drop</a> 实现好了该功能。看了下源码与大多数 plugin 一样，通过methed channel进行mac os进行通信，对桌面开发相关Api不太熟，实现原理没有太深究。</p>\n<h3 id=\"发送功能\"><a href=\"#发送功能\" class=\"headerlink\" title=\"发送功能\"></a>发送功能</h3><p>发送功能主要使用 adb 功能提供的 push命令实现。不过要在 Flutter 上面实现执行命令的功能还是比较简单，只要使用 <code>Process.start(&#39;adb&#39;, [&#39;push&#39;, ...])</code>即可，但是中间会遇到权限不足的问题，报错：<code>ProcessException (ProcessException: Operation not permitted)</code><br>需要关闭沙盒权限才行，将<code>com.apple.security.app-sandbox</code>之设为<code>false</code>。 那咱们这个程序就不太安全咯?不知道还有没有更好的办法?个人感觉不大行……</p>\n<p>在这里还遇到个比较蛋疼的问题，对于实现大文件的发送，通常时间比较久，使用<code>Process.start</code>没有找到相关的api能够直接拿到进度，不过也就简单实用，问题不大 ^_^#。</p>\n<p>效果展示<br><img src=\"https://cdn.julis.wang/blog/img/mac_adb_helper.gif\"></p>\n<p>项目地址：<a href=\"https://github.com/VomPom/macos_adb_helper\">macos_adb_helper</a></p>\n","cover":null,"images":["https://cdn.julis.wang/blog/img/mac_adb_helper.gif"],"content":"<p>最近在Android开发过程中会遇到很多传文件的操作，市面上也有比较多的“文件管理器”，例如锤子的HandShaker，或者谷歌官方的<a href=\"https://www.android.com/filetransfer/\">filetransfer</a>,但他们都需要打开“传输文件”这个行为，个人感觉比较繁琐。作为Android开发，使用adb命令行去传输文件是不错的，但每次输入<code>adb push xxx</code>还是挺麻烦，而且必须打开 Terminal 才能运行。为了让所有操作更简化，我做了一个简单的桌面工具，只需要连上手机，正常打开adb，拖到文件到对应区域，则可以实现文件传输。</p>\n<h2 id=\"Macos-Adb-Helper\"><a href=\"#Macos-Adb-Helper\" class=\"headerlink\" title=\"Macos Adb Helper\"></a>Macos Adb Helper</h2><p>由于自己主要是从事Android相关的开发，对于Mac桌面端的开发不太熟悉，但是 Flutter 这个神奇的跨平台框架可以让你稍微消除这个平衡。</p>\n<p>实现一键拖拽文件发送到Android手机，主要需要实现的功能有两个：</p>\n<p>1、文件拖动功能</p>\n<p>2、发送功能</p>\n<h3 id=\"文件拖动功能\"><a href=\"#文件拖动功能\" class=\"headerlink\" title=\"文件拖动功能\"></a>文件拖动功能</h3><p>拖动功能也不需要自己去写，已经有现成的库 <a href=\"https://pub.dev/packages/desktop_drop\">desktop_drop</a> 实现好了该功能。看了下源码与大多数 plugin 一样，通过methed channel进行mac os进行通信，对桌面开发相关Api不太熟，实现原理没有太深究。</p>\n<h3 id=\"发送功能\"><a href=\"#发送功能\" class=\"headerlink\" title=\"发送功能\"></a>发送功能</h3><p>发送功能主要使用 adb 功能提供的 push命令实现。不过要在 Flutter 上面实现执行命令的功能还是比较简单，只要使用 <code>Process.start(&#39;adb&#39;, [&#39;push&#39;, ...])</code>即可，但是中间会遇到权限不足的问题，报错：<code>ProcessException (ProcessException: Operation not permitted)</code><br>需要关闭沙盒权限才行，将<code>com.apple.security.app-sandbox</code>之设为<code>false</code>。 那咱们这个程序就不太安全咯?不知道还有没有更好的办法?个人感觉不大行……</p>\n<p>在这里还遇到个比较蛋疼的问题，对于实现大文件的发送，通常时间比较久，使用<code>Process.start</code>没有找到相关的api能够直接拿到进度，不过也就简单实用，问题不大 ^_^#。</p>\n<p>效果展示<br><img src=\"https://cdn.julis.wang/blog/img/mac_adb_helper.gif\"></p>\n<p>项目地址：<a href=\"https://github.com/VomPom/macos_adb_helper\">macos_adb_helper</a></p>\n","categories":[{"name":"思考总结","slug":"thinking","api":"api/categories/thinking.json"}],"tags":[{"name":"Flutter","slug":"Flutter","api":"api/tags/Flutter.json"},{"name":"工具","slug":"工具","api":"api/tags/工具.json"}],"api":"api/posts/2022/01/15/快捷-Mac桌面adb-push小工具.json"},{"title":"Android音视频-初识FFmpeg","slug":"音视频-初识FFmpeg","date":"2021-11-14T01:49:00.000Z","updated":"2025-09-15T13:07:56.100Z","comments":true,"url":"2021/11/14/音视频-初识FFmpeg/","excerpt":"<p>已经很久没有写过技术博客了，这段时间加入了新公司，主要时间花在熟悉新业务的技术上。而新的业务主要跟音视频相关，关于音视频的尝试在加入新公司之前，自己有做相关demo的尝试与学习，可以参看<a href=\"https://github.com/VomPom/JProject/tree/master/app/src/main/java/wang/julis/jproject/example/media\">音视频相关学习demo</a>。当然，那都是自己“想当然”学习的一些东西，虽然实际工作中并没有派上太大的用处，但让我对音视频相关的基础知识有了一定的概念，对后面的技术尝试做了铺垫。第一个技术挑战比较大的就是进行：<strong>视频抽帧</strong>，关于视频抽帧网上有很多很多文章进行讲解，但……我始终没有找到一个效率很高的解决方案。直到我遇见了 ffmpeg，仿佛打开了新世界的大门……</p>\n<h2 id=\"关于FFmpeg\"><a href=\"#关于FFmpeg\" class=\"headerlink\" title=\"关于FFmpeg\"></a>关于FFmpeg</h2><p>刚接触 ffmpeg 时，我一脸懵逼，完全不知道该怎么做，也不知道在哪里开始进行学习，后来在<a href=\"https://blog.csdn.net/leixiaohua1020\">雷霄骅大神的博客</a>中渐渐找到了感觉，膜拜！不过雷神的博客代码是基于老版本的 ffmpeg api，推荐搭配<a href=\"https://github.com/FFmpeg/FFmpeg/tree/master/doc/examples\">官方example</a>，先跑通雷声的博客，再对照官方的例子对进行api相关接口的修改。</p>\n<p>当然，想要使用 ffmpeg编写代码之前，我们首先要做的是对 FFmpeg 进行so库编译，这一步也是难倒了众多的英雄好汉，引用<a href=\"https://juejin.cn/post/6844904039524597773\">FFmpeg so库编译</a>作者的话：</p>\n<blockquote>\n<p>为什么FFmpeg让人觉得很难搞？<br>我想主要是因为迈出第一步就很困难，连so库都编译不出来，后面的都是扯淡了。</p>\n</blockquote>\n<p>参考<a href=\"https://juejin.cn/post/6844904039524597773\">FFmpeg so库编译</a>文章能成功地打包出 ffmpeg.so，接下来就是添加在项目中运行。</p>\n<h2 id=\"踏上-FFmpeg-音视频之路\"><a href=\"#踏上-FFmpeg-音视频之路\" class=\"headerlink\" title=\"踏上 FFmpeg 音视频之路\"></a>踏上 FFmpeg 音视频之路</h2><p>关于音视频等开发，无论是做特效渲染还是做视频播放，那么最重要也是最基本的步骤就是：<strong>音视频解码</strong></p>\n<p>众所周知的是视频是由一帧帧视频帧(图片)/音频帧编码组合而成</p>\n<p>视频解码要做的就是解码出视频文件中的每一帧，我们以:<strong>将视频转化为一帧帧的图片</strong>作为例进行学习。</p>\n<h2 id=\"FFmpeg-提取视频每一帧图像\"><a href=\"#FFmpeg-提取视频每一帧图像\" class=\"headerlink\" title=\"FFmpeg 提取视频每一帧图像\"></a>FFmpeg 提取视频每一帧图像</h2><p>在学习之前，我们思考一个问题：抛开 ffmpeg，如果让你去设计一个提取的代码，n你会怎么设计？</p>\n<p>因为视频是以文件流的形式存在，我相信很多人一上来就能想到这样的结构：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">while</span> (!EOF) &#123; <span class=\"comment\">//当文件流没有结束</span></span><br><span class=\"line\">    <span class=\"type\">Stream</span> <span class=\"variable\">stream</span> <span class=\"operator\">=</span> getStream(); <span class=\"comment\">//获取一定区域的stream</span></span><br><span class=\"line\">    <span class=\"type\">Frame</span> <span class=\"variable\">steam</span> <span class=\"operator\">=</span> getFrame(stream); <span class=\"comment\">//Stream转化为视频帧</span></span><br><span class=\"line\">    <span class=\"type\">Picture</span> <span class=\"variable\">picture</span> <span class=\"operator\">=</span> decodeFrame(steam); <span class=\"comment\">//将视频帧转化为 .jpeg等格式图片</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>的确是这样的，这里是给出一份ffmpeg提取视频帧图片的核心逻辑：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\">AVFrame frame = av_frame_alloc(); </span><br><span class=\"line\"><span class=\"keyword\">while</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (av_read_frame(fmt_ctx, &amp;avpkt) &gt;= <span class=\"number\">0</span>) &#123; <span class=\"comment\">// Return the next frame of a stream.</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (avpkt.stream_index == video_stream_index) &#123; <span class=\"comment\">//标识该AVPacket所属的视频/音频流。</span></span><br><span class=\"line\">            avcodec_send_packet(codeCtx, &amp;avpkt); <span class=\"comment\">//Supply raw packet data as input to a decoder.</span></span><br><span class=\"line\">            <span class=\"keyword\">while</span> (avcodec_receive_frame(codeCtx, frame) == <span class=\"number\">0</span>) &#123; <span class=\"comment\">//Return decoded output data from a decoder.</span></span><br><span class=\"line\">                <span class=\"built_in\">snprintf</span>(buf, <span class=\"keyword\">sizeof</span>(buf), <span class=\"string\">&quot;%s/frame-%d.jpg&quot;</span>, out_filename, frame_count);</span><br><span class=\"line\">                saveJpg(frame, buf);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            frame_count++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        av_packet_unref(&amp;avpkt);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        LOGE(<span class=\"string\">&quot;//Exit&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面的代码块就是 ffmpeg 进行视频解码最核心的逻辑了，主要的注释也贴在了代码上，完整代码请查看<a href=\"https://github.com/VomPom/FFmpegLearn/blob/main/app/src/main/cpp/func/video_to_jpeg.cpp\">video_to_jpeg.cpp</a>，查看完整的代码后，会感觉到很惊讶：为什么这么复杂？特别是前面的初始化操作。放心，ffmpeg就像一套组合拳，有固定不变的套路，写一次就足够了，了解了其中的流程，之后理解起来就会很容易了。</p>\n<p>上面的代码我们还可以做一些其他处理，比如只获取关键帧、查找指定时间戳位置的帧、视频按2s一帧进行抽取、视频不保存为jpeg文件转化为Java的bitmap？</p>\n<p>这些实现需求也都是基于上述核心模块进行修改：</p>\n<p>如果<strong>想只获取关键帧</strong>，可以利用<code>AVFrame</code>对象的属性<code>AVFrame-&gt;key_frame</code>进行判断。</p>\n<p><strong>查找指定时间戳位置的帧</strong>：利用 <code>av_seek_frame</code>查找到指定帧时间最近的关键帧，然后依次进行编码，直到<code>pts</code>与目标时间相近</p>\n<p><strong>视频按2s一帧进行抽取</strong>：简单的操作可以去获取视频fps，比如视频25fps，可以使用一个计数器判断<code>if(frame_count%25==0)</code>,这时候则是刚好1s。当然这样子性能不太好。如果需要追求性能，那么也可以利用<code>av_seek_frame</code>，查找目标时间附近，然后循环进行解码直到目标时间。</p>\n<p><strong>视频不保存为jpeg文件转化为Java的Bitmap</strong>：只需要对最终获取的 <code>AVFrame</code>做不一样的操作进行了，获取到对应的buffer，再利用jni调用构造 Java 的 bitmap 对象。</p>\n<p>可以做的还有很多……</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>提取视频图片这个功能只是 FFmpeg 强大功能的九牛一毛，需要探究的还有很多很多……</p>\n<p>如果能跑起来 FFmpeg 最简单的例子，已经迈出了很大一步了，但如果要理解其中的原理，还需要更多的基础知识，以及像<code>AVPacket</code>、<code>AVFrame</code>、 <code>AVCodec</code> ……每一个类的数据结构，以及实现都需要仔细研究。</p>\n<p>自己在网上找到的 FFmpeg 相关的教程，以及自己想要去实现的功能的资源太少，很多东西都需要自己去摸索。有时候我总在怀疑：<strong>为什么这么基础且很实用的功能没有现成的轮子？</strong> 这可能也是现在音视频相关开发的现状吧，成熟可用的轮子相对而言较少，以及相关技术的分享可能不太好做。既然没有，那就靠自己一点点积累吧。</p>\n<p>学习之路，任重而道远呐。</p>\n","cover":null,"images":[],"content":"<p>已经很久没有写过技术博客了，这段时间加入了新公司，主要时间花在熟悉新业务的技术上。而新的业务主要跟音视频相关，关于音视频的尝试在加入新公司之前，自己有做相关demo的尝试与学习，可以参看<a href=\"https://github.com/VomPom/JProject/tree/master/app/src/main/java/wang/julis/jproject/example/media\">音视频相关学习demo</a>。当然，那都是自己“想当然”学习的一些东西，虽然实际工作中并没有派上太大的用处，但让我对音视频相关的基础知识有了一定的概念，对后面的技术尝试做了铺垫。第一个技术挑战比较大的就是进行：<strong>视频抽帧</strong>，关于视频抽帧网上有很多很多文章进行讲解，但……我始终没有找到一个效率很高的解决方案。直到我遇见了 ffmpeg，仿佛打开了新世界的大门……</p>\n<h2 id=\"关于FFmpeg\"><a href=\"#关于FFmpeg\" class=\"headerlink\" title=\"关于FFmpeg\"></a>关于FFmpeg</h2><p>刚接触 ffmpeg 时，我一脸懵逼，完全不知道该怎么做，也不知道在哪里开始进行学习，后来在<a href=\"https://blog.csdn.net/leixiaohua1020\">雷霄骅大神的博客</a>中渐渐找到了感觉，膜拜！不过雷神的博客代码是基于老版本的 ffmpeg api，推荐搭配<a href=\"https://github.com/FFmpeg/FFmpeg/tree/master/doc/examples\">官方example</a>，先跑通雷声的博客，再对照官方的例子对进行api相关接口的修改。</p>\n<p>当然，想要使用 ffmpeg编写代码之前，我们首先要做的是对 FFmpeg 进行so库编译，这一步也是难倒了众多的英雄好汉，引用<a href=\"https://juejin.cn/post/6844904039524597773\">FFmpeg so库编译</a>作者的话：</p>\n<blockquote>\n<p>为什么FFmpeg让人觉得很难搞？<br>我想主要是因为迈出第一步就很困难，连so库都编译不出来，后面的都是扯淡了。</p>\n</blockquote>\n<p>参考<a href=\"https://juejin.cn/post/6844904039524597773\">FFmpeg so库编译</a>文章能成功地打包出 ffmpeg.so，接下来就是添加在项目中运行。</p>\n<h2 id=\"踏上-FFmpeg-音视频之路\"><a href=\"#踏上-FFmpeg-音视频之路\" class=\"headerlink\" title=\"踏上 FFmpeg 音视频之路\"></a>踏上 FFmpeg 音视频之路</h2><p>关于音视频等开发，无论是做特效渲染还是做视频播放，那么最重要也是最基本的步骤就是：<strong>音视频解码</strong></p>\n<p>众所周知的是视频是由一帧帧视频帧(图片)/音频帧编码组合而成</p>\n<p>视频解码要做的就是解码出视频文件中的每一帧，我们以:<strong>将视频转化为一帧帧的图片</strong>作为例进行学习。</p>\n<h2 id=\"FFmpeg-提取视频每一帧图像\"><a href=\"#FFmpeg-提取视频每一帧图像\" class=\"headerlink\" title=\"FFmpeg 提取视频每一帧图像\"></a>FFmpeg 提取视频每一帧图像</h2><p>在学习之前，我们思考一个问题：抛开 ffmpeg，如果让你去设计一个提取的代码，n你会怎么设计？</p>\n<p>因为视频是以文件流的形式存在，我相信很多人一上来就能想到这样的结构：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">while</span> (!EOF) &#123; <span class=\"comment\">//当文件流没有结束</span></span><br><span class=\"line\">    <span class=\"type\">Stream</span> <span class=\"variable\">stream</span> <span class=\"operator\">=</span> getStream(); <span class=\"comment\">//获取一定区域的stream</span></span><br><span class=\"line\">    <span class=\"type\">Frame</span> <span class=\"variable\">steam</span> <span class=\"operator\">=</span> getFrame(stream); <span class=\"comment\">//Stream转化为视频帧</span></span><br><span class=\"line\">    <span class=\"type\">Picture</span> <span class=\"variable\">picture</span> <span class=\"operator\">=</span> decodeFrame(steam); <span class=\"comment\">//将视频帧转化为 .jpeg等格式图片</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>的确是这样的，这里是给出一份ffmpeg提取视频帧图片的核心逻辑：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\">AVFrame frame = av_frame_alloc(); </span><br><span class=\"line\"><span class=\"keyword\">while</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (av_read_frame(fmt_ctx, &amp;avpkt) &gt;= <span class=\"number\">0</span>) &#123; <span class=\"comment\">// Return the next frame of a stream.</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (avpkt.stream_index == video_stream_index) &#123; <span class=\"comment\">//标识该AVPacket所属的视频/音频流。</span></span><br><span class=\"line\">            avcodec_send_packet(codeCtx, &amp;avpkt); <span class=\"comment\">//Supply raw packet data as input to a decoder.</span></span><br><span class=\"line\">            <span class=\"keyword\">while</span> (avcodec_receive_frame(codeCtx, frame) == <span class=\"number\">0</span>) &#123; <span class=\"comment\">//Return decoded output data from a decoder.</span></span><br><span class=\"line\">                <span class=\"built_in\">snprintf</span>(buf, <span class=\"keyword\">sizeof</span>(buf), <span class=\"string\">&quot;%s/frame-%d.jpg&quot;</span>, out_filename, frame_count);</span><br><span class=\"line\">                saveJpg(frame, buf);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            frame_count++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        av_packet_unref(&amp;avpkt);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        LOGE(<span class=\"string\">&quot;//Exit&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面的代码块就是 ffmpeg 进行视频解码最核心的逻辑了，主要的注释也贴在了代码上，完整代码请查看<a href=\"https://github.com/VomPom/FFmpegLearn/blob/main/app/src/main/cpp/func/video_to_jpeg.cpp\">video_to_jpeg.cpp</a>，查看完整的代码后，会感觉到很惊讶：为什么这么复杂？特别是前面的初始化操作。放心，ffmpeg就像一套组合拳，有固定不变的套路，写一次就足够了，了解了其中的流程，之后理解起来就会很容易了。</p>\n<p>上面的代码我们还可以做一些其他处理，比如只获取关键帧、查找指定时间戳位置的帧、视频按2s一帧进行抽取、视频不保存为jpeg文件转化为Java的bitmap？</p>\n<p>这些实现需求也都是基于上述核心模块进行修改：</p>\n<p>如果<strong>想只获取关键帧</strong>，可以利用<code>AVFrame</code>对象的属性<code>AVFrame-&gt;key_frame</code>进行判断。</p>\n<p><strong>查找指定时间戳位置的帧</strong>：利用 <code>av_seek_frame</code>查找到指定帧时间最近的关键帧，然后依次进行编码，直到<code>pts</code>与目标时间相近</p>\n<p><strong>视频按2s一帧进行抽取</strong>：简单的操作可以去获取视频fps，比如视频25fps，可以使用一个计数器判断<code>if(frame_count%25==0)</code>,这时候则是刚好1s。当然这样子性能不太好。如果需要追求性能，那么也可以利用<code>av_seek_frame</code>，查找目标时间附近，然后循环进行解码直到目标时间。</p>\n<p><strong>视频不保存为jpeg文件转化为Java的Bitmap</strong>：只需要对最终获取的 <code>AVFrame</code>做不一样的操作进行了，获取到对应的buffer，再利用jni调用构造 Java 的 bitmap 对象。</p>\n<p>可以做的还有很多……</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>提取视频图片这个功能只是 FFmpeg 强大功能的九牛一毛，需要探究的还有很多很多……</p>\n<p>如果能跑起来 FFmpeg 最简单的例子，已经迈出了很大一步了，但如果要理解其中的原理，还需要更多的基础知识，以及像<code>AVPacket</code>、<code>AVFrame</code>、 <code>AVCodec</code> ……每一个类的数据结构，以及实现都需要仔细研究。</p>\n<p>自己在网上找到的 FFmpeg 相关的教程，以及自己想要去实现的功能的资源太少，很多东西都需要自己去摸索。有时候我总在怀疑：<strong>为什么这么基础且很实用的功能没有现成的轮子？</strong> 这可能也是现在音视频相关开发的现状吧，成熟可用的轮子相对而言较少，以及相关技术的分享可能不太好做。既然没有，那就靠自己一点点积累吧。</p>\n<p>学习之路，任重而道远呐。</p>\n","categories":[{"name":"技术文章","slug":"technology","api":"api/categories/technology.json"}],"tags":[{"name":"FFmpeg","slug":"FFmpeg","api":"api/tags/FFmpeg.json"},{"name":"音视频","slug":"音视频","api":"api/tags/音视频.json"}],"api":"api/posts/2021/11/14/音视频-初识FFmpeg.json"},{"title":"记一段 Android 面试时光","slug":"记一段-Android-面试时光","date":"2021-07-06T14:56:00.000Z","updated":"2025-05-20T11:46:57.000Z","comments":true,"url":"2021/07/06/记一段-Android-面试时光/","excerpt":"<p>今晚已到下班时间，我又如往常一样，背着自己的包来到了楼下的会议室。不过与前些天的日子不太一样，今天我已经放下了诸多包袱，剩下的是一个轻松的自己，历经一个月的面试时光，终于可以在这会议室惬然地写下一些东西。</p>\n<p>准备面试以及参加面试都是一个高度紧张的过程，为了面试，我放弃了一些时间，也让自己每天变得很疲惫，因而有更少的精力去干一些其他事情。在六月，我还未完成一本书的阅读，时间忙碌所占去，或者那个疲惫的身体没有能静得下心来阅读一本书籍，我好希望能够有一个轻轻松松的时间，能够做自己想做的事\b。但在诸多现实面前，不得不低下头吧，好在现在收获的Offer也能对得起自己的付出，遂想记录一下这一个月来自己的面试经历。</p>\n<p>在五月初便有想跳槽的想法，原因也很简单：现在的日子太舒服，想找到一个更大的平台来提升自己。在五月下旬开始行动了起来，自己当然有想要去的厂，也通过一些相关的流程约到了面试的时间。那么接下来就是准备吧，准备的过程包括：<strong>算法(视公司而定)、基础知识(常见面试问题等)、项目(项目本身以及相关的深度知识)</strong>。当然还包括了面试经验，在面之前需要找一些中型公司来锻炼锻炼自己的表达能力，以及对问到的一些知识盲区进行一些补缺，于是面试之路开始了。</p>\n<p>记得第一家面的某快递公司，很久没有面试过了，发现面试的感觉还是有点差，被问了一些 Android 相关的基础知识，我知道那件事，但是我回忆不起来了，也讲不太出来了。理所应当挂了，不过无所谓吧，问题不大，回去之后把他问了的一些基础点再准备了看看。</p>\n<p>大概也就是第二天吧，是某买菜公司的面试，这次面试让我哭笑不得。我也本着找面经的态度来面试的，我希望他能多问点有深度的知识，然后我能知道我该去准备些什么。结果他一直不停地问我所做的项目，全程没有技术问题。大概问了我20分钟项目经历，他说：我问完了，你有什么要问的么？我一脸懵逼？？？？我（你特么）都不问点技术问题？他：我……感觉你好强啊（还有点支支吾吾的感觉）……不太敢问，怕暴露了……  不过登了很久也没有见他们约二面（难道是怕我太强了？？哈哈哈😂）。</p>\n<p>第三次面试是杭州某中厂，在经过两次面试的时间之后，我觉得我的基础知识准备还行，这一次的面试，全程问得还是比较轻松，技术深度也不是特别大，很轻松的过去了。后面相互交流时间，我问了一些他们在做什么东西，面试官倒是很热情地给我讲了一大堆，但我并不是很感兴趣，出于礼貌，还是耐心地听了下去。他问我现在的工资是怎样，我如实回答后他说：我们可能还要低些。后面又讲了他们的业务(企图用爱来发电)，不过我依然没有表现出多大的兴趣，后面也没有再约面试了吧。</p>\n<p>第四次面试我投了某能便宜买东西电商公司，这个公司算是我拿到的第一个Offer的公司，记得清楚是5.30号，因为当天下午面完，赶去苏州看国足世界杯预选赛的比赛了。一面的小哥还是很nice的，问的问题比较有深度，答得还行吧，在后面跟我讨论了起来 Flutter 的发展，聊得还是比较惬意，最后又是一道算法题（记不太清是什么题了，应该是easy难度），然后约我去现场进行下一面，也就是5.30号。去现场跟HR聊了好一会儿，才来一个看着很资深的大佬，问了我一些也不算事太难的问题，甚至感觉他没有仔细看我简历，一直看我简历，看一会儿问一会儿，最后又是一道算法题：求两个View的最近公共View，叫我直接在纸上写，那桌子太低，弯着个腰，写着太难受了，那字也写得跟个啥一样，不过他还是看懂了，后面也没有问个啥，然后就直接HRBP面了，问我期望工资，我说了一个期望，她当然会砍价，因为这时候没有其他 Offer ，她给我给得很低，然后 pua 我了一下，说什么你前两年浪费了呀，你要来的话，得赶紧过来之类的……然后没过几天就让我提交工资流水了。</p>\n<p>在后面是某手机大厂，这个厂流程也真的是一个之复杂。简历通过后，一上来就有个在线笔试，三道算法题，三个小时，三个题我应该都做出来了，难度中等吧，不过他的测试用例不知道怎么设计的，我的测试用例通过率每道题都没有超过百分之五十，可是我实在是找不到可以再加的逻辑了，忐忑的心情提交了上去。结果第二天跟我说通过了，刚好过。然后又给我发了一份职业问卷测评的链接，好嘛，点开一个看，woc 几百道题……也真的是做着累，问题也就是一些不痛不痒的问题。在做做之前，HR有给我发一份“高分教程”，大概总结一下就是你得选一些符合他们公司价值观的选项，总体的感觉就是：他们喜欢加班的人、能吃苦耐劳不计较报酬、不能有自己的个性……行吧……有的选项真的有点打击我三观，不过我还是坚持地做完了。</p>\n<p>第二天HR跟我说通过了，不过“XX值”有点偏高，到时候可能需要跟leader解释一下，我…… 然后到了第一面技术面，一上来又是一道算法题，还行吧，这道理大概完成了，后面去leetcode上面看了一下，也是个medium。不过面试官是真的很强的感觉，把我问得不要不要的，对于系统底层的问题问了很多，我甚至很佩服该厂的技术人员，怎么可以这么强？中间我有好几个问题没有答上来，但是大佬还是很耐心的给我讲解了一下，这次面试的收获也是蛮大的。</p>\n<p>后来居然先是HR面试，很神奇哟。不过这次HR面试让我很不爽很不爽，体验极差。跟HR聊着，真的是“痛不欲生”，她搁这里戴个有线耳机，只挂了一个在耳朵上（记不太清了，应该是挂的没有话筒的那一边）导致交流起来我能听到她的声音很不清楚，我得很仔细听她讲话。然而反过来呢？我在讲话的时候，她一边玩着自己的手指甲，中间时不时还有几个哈欠出来……后面聊到薪资一块，问了我期望薪资，我说了一个数（在我现在拿到了其他公司的offer之后，再看的话，真的算是一个比较低的数字了），她跟我说：你去看其他厂，除了某厂，其他不可能给你这么多的（现在看就呵呵了），然后还特别的高傲的把我pua了一顿……总之体验不太好。又过了一段时间跟我说要二轮技术面，我拒绝了。</p>\n<p>第二个Offer是曾经的XYZ的X，一面技术面居然是个姐姐，问的问题还算可以，不难，但是有一些个“坑”，我跳进去过几次，给我贴了好几段代码，让我找哪里有问题，不得不说这一波面试让我学到了很多知识点，让我对 Android 的 HandlerThread 有了更多了解。二面去的现场，去现场我还是挺感慨，这么大一块园区都是他们公司的，整个logo放大楼前面，真的是气派！在前台等了一会儿有面试官下来接待，天呐！又是一个姐姐！娘子军大作战？单独找了个会议室，跟这个面试官聊起来，感觉压力还是蛮大的，各种问我“架构设计”方面的事儿，让我画项目架构图在黑板上之类的。以及被诸多的技术灵魂拷问，总体聊了一个半小时，压力还是蛮大。后来是要他们主管过来面，我看这主管样子就是大佬样，应该有四十多岁了，有一种职场气质的技术主管。问我也是一些通用型的问题，架构、思维、方法论等，压力更多来自于他给我一种资历压迫感（我感觉我说的东西都太幼稚在他看来），因为我跟他说了我等会儿要赶飞机，所以跟他只聊了半个小时，后面的HR面也只聊了十几分钟，我就匆匆跑路了，然后第二周叫提交薪资流水。</p>\n<p>前面的面试还算是比较顺利，没有怎么失败过，我以为我能以“全胜出线”，结果现实并不是这样。再后来面了某视频网站和XYZ的Y。这两次失败是连在一起的，Y已经是最后一面的技术面，大佬面，应该问题不大了，可是，意外总是会出现。事情是这样子的，当天晚上七点约了视频网站的二面，八点是Y公司的最后一轮技术面了（只要没有什么幺蛾子事情发生，后续应该就是HR了）。当时前者公司正视频面试着，又是个女面试官，全程问了我一些问题莫名奇妙，我一开始还以为她是HR，问了我好几个非技术问题，以及一些有的得没得问题（比如：我们为什么招你？害～ 你能为我们带来什么？害～），但在七点四十多的时候收到了Y公司的电话，想立马面试，我跟他解释现在有事，并推迟到了八点之后。结果就是因为这一推，给大佬造成了不好的影响……据后来内推的同事说，很大的一部分原因就是这个。然后在面试过程中还接电话，结果两边都没有个好结果，害～ 这事儿整得，让我明白了：<strong>面试时间安排太紧凑比较危险。</strong></p>\n<p>最后拿到的两个offer，也是我最终纠结选择取哪里的offer，两个公司都比较好吧。一个在上海，一个在杭州，原本想拒绝上海这个公司的，因为杭州的公司有我诸多前同事，以及杭州相比上海而言有更好的生活舒适度，所以选择了杭州的公司，但是拒绝真的很难。上海的公司算事行业的佼佼者了，为了能更好的拒绝，我甚至写了一份“千字长文拒绝信”给对应HR，来表达我不能去其公司歉意（那内容我作为旁观者，看着都要给感动哭了），但HR也并没有回我什么（可能是见惯了这种场景），没过多久我收到了其公司的同事的关怀，但我还是对他表示拒绝的想法。又过了不久，我收到电话，貌似是之前去公司面试的时候，“我的直属leader”打过来的，向我阐述了大平台的重要，以及杭州公司的业务发展没有这边好。后来又被拉群，加入到了含有部门总监的群，他加了我微信，表示晚上要跟我谈一谈，并附言几句，大概意思翻译就是：你去杭州的不是一个明智之举，来我们这里才是最正确的选择。一下午就因为这些事“舌战群儒”，不过我很强烈地感受到了他们对人才的追求和肯定，让我感觉到：我何德何能？能让这么多陌生的人来劝我回去，让我很感动， 这或许就是大公司每个人都以人才来看待吧。</p>\n<p>此时我开始陷入了更深的纠结与迷茫：到底该怎么选？对于上海的公司体量是N个杭州公司那么大的，工作室是在做一些比较前沿的东西(视频特效渲染、移动端深度学习、音视频合成等)，很多东西我都没有接触过，要重新开始学习，会比较肝。对于杭州公司，在那里有我诸多的前同事，包括 leader 都是我之前公司的，公司位于滨江河畔，离钱塘江也不远，钱塘夜景让我久久不能忘怀。加之杭州的物价与房价都低于上海，不得不说杭州更适合生活。但做的东西比较与业务相关，需要与产品-测试等相关人员对接，相对而言所接触到的知识点没有上海这边深入。所以，我是否要去选择在上海再拼一拼呢？有那么些纠结，到底要选择相对轻松舒适的杭州，还是更有拼搏感的上海公司？最终吧，还是选择了上海，最近在读<strong>《草莓人生》</strong>，有一句话让我又更坚定了这个选择：<strong>“其实没有一种工作是轻松的，正因为不轻松，所以才叫工作啊”</strong>，学吧，学吧，肝吧肝吧，在上海再干几年，祝我有朝一日成大佬😂<br>昨日，已点击“接受本Offer”<br>至此，结束一段面试时光。</p>\n","cover":null,"images":[],"content":"<p>今晚已到下班时间，我又如往常一样，背着自己的包来到了楼下的会议室。不过与前些天的日子不太一样，今天我已经放下了诸多包袱，剩下的是一个轻松的自己，历经一个月的面试时光，终于可以在这会议室惬然地写下一些东西。</p>\n<p>准备面试以及参加面试都是一个高度紧张的过程，为了面试，我放弃了一些时间，也让自己每天变得很疲惫，因而有更少的精力去干一些其他事情。在六月，我还未完成一本书的阅读，时间忙碌所占去，或者那个疲惫的身体没有能静得下心来阅读一本书籍，我好希望能够有一个轻轻松松的时间，能够做自己想做的事\b。但在诸多现实面前，不得不低下头吧，好在现在收获的Offer也能对得起自己的付出，遂想记录一下这一个月来自己的面试经历。</p>\n<p>在五月初便有想跳槽的想法，原因也很简单：现在的日子太舒服，想找到一个更大的平台来提升自己。在五月下旬开始行动了起来，自己当然有想要去的厂，也通过一些相关的流程约到了面试的时间。那么接下来就是准备吧，准备的过程包括：<strong>算法(视公司而定)、基础知识(常见面试问题等)、项目(项目本身以及相关的深度知识)</strong>。当然还包括了面试经验，在面之前需要找一些中型公司来锻炼锻炼自己的表达能力，以及对问到的一些知识盲区进行一些补缺，于是面试之路开始了。</p>\n<p>记得第一家面的某快递公司，很久没有面试过了，发现面试的感觉还是有点差，被问了一些 Android 相关的基础知识，我知道那件事，但是我回忆不起来了，也讲不太出来了。理所应当挂了，不过无所谓吧，问题不大，回去之后把他问了的一些基础点再准备了看看。</p>\n<p>大概也就是第二天吧，是某买菜公司的面试，这次面试让我哭笑不得。我也本着找面经的态度来面试的，我希望他能多问点有深度的知识，然后我能知道我该去准备些什么。结果他一直不停地问我所做的项目，全程没有技术问题。大概问了我20分钟项目经历，他说：我问完了，你有什么要问的么？我一脸懵逼？？？？我（你特么）都不问点技术问题？他：我……感觉你好强啊（还有点支支吾吾的感觉）……不太敢问，怕暴露了……  不过登了很久也没有见他们约二面（难道是怕我太强了？？哈哈哈😂）。</p>\n<p>第三次面试是杭州某中厂，在经过两次面试的时间之后，我觉得我的基础知识准备还行，这一次的面试，全程问得还是比较轻松，技术深度也不是特别大，很轻松的过去了。后面相互交流时间，我问了一些他们在做什么东西，面试官倒是很热情地给我讲了一大堆，但我并不是很感兴趣，出于礼貌，还是耐心地听了下去。他问我现在的工资是怎样，我如实回答后他说：我们可能还要低些。后面又讲了他们的业务(企图用爱来发电)，不过我依然没有表现出多大的兴趣，后面也没有再约面试了吧。</p>\n<p>第四次面试我投了某能便宜买东西电商公司，这个公司算是我拿到的第一个Offer的公司，记得清楚是5.30号，因为当天下午面完，赶去苏州看国足世界杯预选赛的比赛了。一面的小哥还是很nice的，问的问题比较有深度，答得还行吧，在后面跟我讨论了起来 Flutter 的发展，聊得还是比较惬意，最后又是一道算法题（记不太清是什么题了，应该是easy难度），然后约我去现场进行下一面，也就是5.30号。去现场跟HR聊了好一会儿，才来一个看着很资深的大佬，问了我一些也不算事太难的问题，甚至感觉他没有仔细看我简历，一直看我简历，看一会儿问一会儿，最后又是一道算法题：求两个View的最近公共View，叫我直接在纸上写，那桌子太低，弯着个腰，写着太难受了，那字也写得跟个啥一样，不过他还是看懂了，后面也没有问个啥，然后就直接HRBP面了，问我期望工资，我说了一个期望，她当然会砍价，因为这时候没有其他 Offer ，她给我给得很低，然后 pua 我了一下，说什么你前两年浪费了呀，你要来的话，得赶紧过来之类的……然后没过几天就让我提交工资流水了。</p>\n<p>在后面是某手机大厂，这个厂流程也真的是一个之复杂。简历通过后，一上来就有个在线笔试，三道算法题，三个小时，三个题我应该都做出来了，难度中等吧，不过他的测试用例不知道怎么设计的，我的测试用例通过率每道题都没有超过百分之五十，可是我实在是找不到可以再加的逻辑了，忐忑的心情提交了上去。结果第二天跟我说通过了，刚好过。然后又给我发了一份职业问卷测评的链接，好嘛，点开一个看，woc 几百道题……也真的是做着累，问题也就是一些不痛不痒的问题。在做做之前，HR有给我发一份“高分教程”，大概总结一下就是你得选一些符合他们公司价值观的选项，总体的感觉就是：他们喜欢加班的人、能吃苦耐劳不计较报酬、不能有自己的个性……行吧……有的选项真的有点打击我三观，不过我还是坚持地做完了。</p>\n<p>第二天HR跟我说通过了，不过“XX值”有点偏高，到时候可能需要跟leader解释一下，我…… 然后到了第一面技术面，一上来又是一道算法题，还行吧，这道理大概完成了，后面去leetcode上面看了一下，也是个medium。不过面试官是真的很强的感觉，把我问得不要不要的，对于系统底层的问题问了很多，我甚至很佩服该厂的技术人员，怎么可以这么强？中间我有好几个问题没有答上来，但是大佬还是很耐心的给我讲解了一下，这次面试的收获也是蛮大的。</p>\n<p>后来居然先是HR面试，很神奇哟。不过这次HR面试让我很不爽很不爽，体验极差。跟HR聊着，真的是“痛不欲生”，她搁这里戴个有线耳机，只挂了一个在耳朵上（记不太清了，应该是挂的没有话筒的那一边）导致交流起来我能听到她的声音很不清楚，我得很仔细听她讲话。然而反过来呢？我在讲话的时候，她一边玩着自己的手指甲，中间时不时还有几个哈欠出来……后面聊到薪资一块，问了我期望薪资，我说了一个数（在我现在拿到了其他公司的offer之后，再看的话，真的算是一个比较低的数字了），她跟我说：你去看其他厂，除了某厂，其他不可能给你这么多的（现在看就呵呵了），然后还特别的高傲的把我pua了一顿……总之体验不太好。又过了一段时间跟我说要二轮技术面，我拒绝了。</p>\n<p>第二个Offer是曾经的XYZ的X，一面技术面居然是个姐姐，问的问题还算可以，不难，但是有一些个“坑”，我跳进去过几次，给我贴了好几段代码，让我找哪里有问题，不得不说这一波面试让我学到了很多知识点，让我对 Android 的 HandlerThread 有了更多了解。二面去的现场，去现场我还是挺感慨，这么大一块园区都是他们公司的，整个logo放大楼前面，真的是气派！在前台等了一会儿有面试官下来接待，天呐！又是一个姐姐！娘子军大作战？单独找了个会议室，跟这个面试官聊起来，感觉压力还是蛮大的，各种问我“架构设计”方面的事儿，让我画项目架构图在黑板上之类的。以及被诸多的技术灵魂拷问，总体聊了一个半小时，压力还是蛮大。后来是要他们主管过来面，我看这主管样子就是大佬样，应该有四十多岁了，有一种职场气质的技术主管。问我也是一些通用型的问题，架构、思维、方法论等，压力更多来自于他给我一种资历压迫感（我感觉我说的东西都太幼稚在他看来），因为我跟他说了我等会儿要赶飞机，所以跟他只聊了半个小时，后面的HR面也只聊了十几分钟，我就匆匆跑路了，然后第二周叫提交薪资流水。</p>\n<p>前面的面试还算是比较顺利，没有怎么失败过，我以为我能以“全胜出线”，结果现实并不是这样。再后来面了某视频网站和XYZ的Y。这两次失败是连在一起的，Y已经是最后一面的技术面，大佬面，应该问题不大了，可是，意外总是会出现。事情是这样子的，当天晚上七点约了视频网站的二面，八点是Y公司的最后一轮技术面了（只要没有什么幺蛾子事情发生，后续应该就是HR了）。当时前者公司正视频面试着，又是个女面试官，全程问了我一些问题莫名奇妙，我一开始还以为她是HR，问了我好几个非技术问题，以及一些有的得没得问题（比如：我们为什么招你？害～ 你能为我们带来什么？害～），但在七点四十多的时候收到了Y公司的电话，想立马面试，我跟他解释现在有事，并推迟到了八点之后。结果就是因为这一推，给大佬造成了不好的影响……据后来内推的同事说，很大的一部分原因就是这个。然后在面试过程中还接电话，结果两边都没有个好结果，害～ 这事儿整得，让我明白了：<strong>面试时间安排太紧凑比较危险。</strong></p>\n<p>最后拿到的两个offer，也是我最终纠结选择取哪里的offer，两个公司都比较好吧。一个在上海，一个在杭州，原本想拒绝上海这个公司的，因为杭州的公司有我诸多前同事，以及杭州相比上海而言有更好的生活舒适度，所以选择了杭州的公司，但是拒绝真的很难。上海的公司算事行业的佼佼者了，为了能更好的拒绝，我甚至写了一份“千字长文拒绝信”给对应HR，来表达我不能去其公司歉意（那内容我作为旁观者，看着都要给感动哭了），但HR也并没有回我什么（可能是见惯了这种场景），没过多久我收到了其公司的同事的关怀，但我还是对他表示拒绝的想法。又过了不久，我收到电话，貌似是之前去公司面试的时候，“我的直属leader”打过来的，向我阐述了大平台的重要，以及杭州公司的业务发展没有这边好。后来又被拉群，加入到了含有部门总监的群，他加了我微信，表示晚上要跟我谈一谈，并附言几句，大概意思翻译就是：你去杭州的不是一个明智之举，来我们这里才是最正确的选择。一下午就因为这些事“舌战群儒”，不过我很强烈地感受到了他们对人才的追求和肯定，让我感觉到：我何德何能？能让这么多陌生的人来劝我回去，让我很感动， 这或许就是大公司每个人都以人才来看待吧。</p>\n<p>此时我开始陷入了更深的纠结与迷茫：到底该怎么选？对于上海的公司体量是N个杭州公司那么大的，工作室是在做一些比较前沿的东西(视频特效渲染、移动端深度学习、音视频合成等)，很多东西我都没有接触过，要重新开始学习，会比较肝。对于杭州公司，在那里有我诸多的前同事，包括 leader 都是我之前公司的，公司位于滨江河畔，离钱塘江也不远，钱塘夜景让我久久不能忘怀。加之杭州的物价与房价都低于上海，不得不说杭州更适合生活。但做的东西比较与业务相关，需要与产品-测试等相关人员对接，相对而言所接触到的知识点没有上海这边深入。所以，我是否要去选择在上海再拼一拼呢？有那么些纠结，到底要选择相对轻松舒适的杭州，还是更有拼搏感的上海公司？最终吧，还是选择了上海，最近在读<strong>《草莓人生》</strong>，有一句话让我又更坚定了这个选择：<strong>“其实没有一种工作是轻松的，正因为不轻松，所以才叫工作啊”</strong>，学吧，学吧，肝吧肝吧，在上海再干几年，祝我有朝一日成大佬😂<br>昨日，已点击“接受本Offer”<br>至此，结束一段面试时光。</p>\n","categories":[{"name":"思考总结","slug":"thinking","api":"api/categories/thinking.json"}],"tags":[{"name":"面试","slug":"面试","api":"api/tags/面试.json"}],"api":"api/posts/2021/07/06/记一段-Android-面试时光.json"},{"title":"逆向相关经验总结","slug":"逆向相关经验总结","date":"2021-07-06T06:47:00.000Z","updated":"2025-12-22T03:23:22.456Z","comments":true,"url":"2021/07/06/逆向相关经验总结/","excerpt":"<p>在离开 YW 之前很长的一段时间都在做逆向相关，从最初只需要反编译 .apk 文件就能“摸清”应用内部相关逻辑，到后来需要对App文件进行脱壳，到需要动态调试。花了很大的精力，这中间也走了很多弯路。在换了工作之后，不知还会不会再有接触逆向相关的开发，但过去的探索也是我技术的宝贵经验吧，遂将此前的学习的一些经验进行整理。</p>\n<h2 id=\"逆向相关原理与流程参考资料\"><a href=\"#逆向相关原理与流程参考资料\" class=\"headerlink\" title=\"逆向相关原理与流程参考资料\"></a>逆向相关原理与流程参考资料</h2><p><a href=\"https://www.jianshu.com/p/d22f52a6a6fb\">安卓打包流程</a></p>\n<p><a href=\"https://julis.wang/2021/05/14/Android-%E9%80%86%E5%90%91-%E5%8F%8D%E7%BC%96%E8%AF%91/\">反编译流程</a></p>\n<p><a href=\"https://www.jianshu.com/p/4ff48b761ff6\">加固原理</a></p>\n<p><a href=\"https://zhuanlan.zhihu.com/p/70894166\">脱壳教程</a></p>\n<p><a href=\"https://blog.csdn.net/weixin_36001685/article/details/102997126\">不root怎么将FDex2反编译的dex文件拷出来</a></p>\n<p><a href=\"https://blog.csdn.net/qq_22000459/article/details/90314255\">Xposed之Hook方法</a></p>\n<p><a href=\"https://juejin.cn/post/6844903762771853326\">Xposed Hook混淆且加固后的APP</a></p>\n<p><a href=\"https://github.com/CodingGay/BlackDex\">最方便快捷的脱壳软件（不需要Root、也不需要Xposed</a></p>\n<p>关于脱壳、破解逆向等资源工具最好的网站是—-&gt;  <a href=\"http://www.52pojie.cn\">www.52pojie.cn</a></p>\n<p>整理一份相关破解工具集：<a href=\"https://github.com/VomPom/Hack/tree/master/apk_reverse\">https://github.com/VomPom/Hack/tree/master/apk_reverse</a></p>\n<h2 id=\"个人一些经验总结：\"><a href=\"#个人一些经验总结：\" class=\"headerlink\" title=\"个人一些经验总结：\"></a>个人一些经验总结：</h2><p>1、 App抓包尽量使用Android 低版本（Android 7以下）7之后有些新版本系统的安全限制</p>\n<p>2、 能进行静态代码就直接进行静态代码分析，在万不得已的时候再利用 hook以及动态调试（相关收益率以及成功率比较低）</p>\n<p>3、 利用BlackDex之类的软件脱壳之后，从手机复制过来到一个文件夹，利用apk2dex2jar2class2java.sh 执行 sh apk2dex2jar2class2java.sh /xx/xx (对应的脱壳后的dex文件夹) 得到jar/java文件夹可方便进行静态代码分析</p>\n<p>4、 如何找到请求接口加解密的地方？这个只有靠个人经验，对于很多普通加密利用了标准加密库，可以尝试搜索“Cipher.getInstance”之类的标准代码（注意第三方相关sdk也会使用），或者搜搜“Response”相关的字段，或者 请求过程中相关的具体字段或者域名等，不过这部分代码一般都是被混淆的，需要耐心慢慢摸索。</p>\n<p>5、 有时候代码会有找不到相关的类的情况，这是由于脱壳相关机制导致的，需要对其进行修复，或者尝试使用其他脱壳软件进行脱壳。</p>\n","cover":null,"images":[],"content":"<p>在离开 YW 之前很长的一段时间都在做逆向相关，从最初只需要反编译 .apk 文件就能“摸清”应用内部相关逻辑，到后来需要对App文件进行脱壳，到需要动态调试。花了很大的精力，这中间也走了很多弯路。在换了工作之后，不知还会不会再有接触逆向相关的开发，但过去的探索也是我技术的宝贵经验吧，遂将此前的学习的一些经验进行整理。</p>\n<h2 id=\"逆向相关原理与流程参考资料\"><a href=\"#逆向相关原理与流程参考资料\" class=\"headerlink\" title=\"逆向相关原理与流程参考资料\"></a>逆向相关原理与流程参考资料</h2><p><a href=\"https://www.jianshu.com/p/d22f52a6a6fb\">安卓打包流程</a></p>\n<p><a href=\"https://julis.wang/2021/05/14/Android-%E9%80%86%E5%90%91-%E5%8F%8D%E7%BC%96%E8%AF%91/\">反编译流程</a></p>\n<p><a href=\"https://www.jianshu.com/p/4ff48b761ff6\">加固原理</a></p>\n<p><a href=\"https://zhuanlan.zhihu.com/p/70894166\">脱壳教程</a></p>\n<p><a href=\"https://blog.csdn.net/weixin_36001685/article/details/102997126\">不root怎么将FDex2反编译的dex文件拷出来</a></p>\n<p><a href=\"https://blog.csdn.net/qq_22000459/article/details/90314255\">Xposed之Hook方法</a></p>\n<p><a href=\"https://juejin.cn/post/6844903762771853326\">Xposed Hook混淆且加固后的APP</a></p>\n<p><a href=\"https://github.com/CodingGay/BlackDex\">最方便快捷的脱壳软件（不需要Root、也不需要Xposed</a></p>\n<p>关于脱壳、破解逆向等资源工具最好的网站是—-&gt;  <a href=\"http://www.52pojie.cn\">www.52pojie.cn</a></p>\n<p>整理一份相关破解工具集：<a href=\"https://github.com/VomPom/Hack/tree/master/apk_reverse\">https://github.com/VomPom/Hack/tree/master/apk_reverse</a></p>\n<h2 id=\"个人一些经验总结：\"><a href=\"#个人一些经验总结：\" class=\"headerlink\" title=\"个人一些经验总结：\"></a>个人一些经验总结：</h2><p>1、 App抓包尽量使用Android 低版本（Android 7以下）7之后有些新版本系统的安全限制</p>\n<p>2、 能进行静态代码就直接进行静态代码分析，在万不得已的时候再利用 hook以及动态调试（相关收益率以及成功率比较低）</p>\n<p>3、 利用BlackDex之类的软件脱壳之后，从手机复制过来到一个文件夹，利用apk2dex2jar2class2java.sh 执行 sh apk2dex2jar2class2java.sh /xx/xx (对应的脱壳后的dex文件夹) 得到jar/java文件夹可方便进行静态代码分析</p>\n<p>4、 如何找到请求接口加解密的地方？这个只有靠个人经验，对于很多普通加密利用了标准加密库，可以尝试搜索“Cipher.getInstance”之类的标准代码（注意第三方相关sdk也会使用），或者搜搜“Response”相关的字段，或者 请求过程中相关的具体字段或者域名等，不过这部分代码一般都是被混淆的，需要耐心慢慢摸索。</p>\n<p>5、 有时候代码会有找不到相关的类的情况，这是由于脱壳相关机制导致的，需要对其进行修复，或者尝试使用其他脱壳软件进行脱壳。</p>\n","categories":[],"tags":[],"api":"api/posts/2021/07/06/逆向相关经验总结.json"},{"title":"Android 逆向-反编译","slug":"Android-逆向-反编译","date":"2021-05-14T06:45:00.000Z","updated":"2025-12-22T03:27:00.920Z","comments":true,"url":"2021/05/14/Android-逆向-反编译/","excerpt":"<p>最近由于机缘巧合接触到了 Android 逆向相关的事情，经过一番探索，对其有了更深刻地认识，过程中遇到了了一些坑，或者一些有用的经验，分享并记录分析一下。在整个过程中使用的工具有：</p>\n<p><strong>反编译</strong>：dex2jar、CFR、jd-gui、</p>\n<p><strong>脱壳</strong>：VirtualApp、Xposed installer、FDex2</p>\n<p><strong>其他</strong>：IDA、VSCode、Total commander</p>\n<p>接下来咱们以两个具体情景，讲解整个逆向（静态代码分析）的流程，去分析两个 Apk 中相关页面的加密算法。</p>\n<p>在开发安卓应用的过程中，我们平时写得最多的代码就是 Java(以及Kotlin)，我们的逻辑也都在这一块，如果我们需要对应 apk 中代码逻辑，能直接看到这样的代码当然是最好不过的。要对相关 apk 中的代码逻辑进行分析，那么第一步便是需要对 apk 进行反编译，从而得到可以进行阅读理解的代码。</p>\n<h1 id=\"Apk的打包流程\"><a href=\"#Apk的打包流程\" class=\"headerlink\" title=\"Apk的打包流程\"></a>Apk的打包流程</h1><p>我们先对 安卓的打包流程进行一个简单的了解，从而明白.java文件 是一步步\b成为 apk中的一部分的，在生成 apk 的过程中主要包含以下流程，括号中代表使用的工具：</p>\n<p>1、打包资源文件，生成R.java文件 (aapt)</p>\n<p>2、处理aidl文件，生成相应的.java文件 (aidl)</p>\n<p>3、编译项目源代码，生成class文件 (javac)</p>\n<p>4、转换所有的class文件，生成classes.dex文件 (dx)</p>\n<p>5、编译过的资源和.dex文件都会被apkbuilder工具打包到最终的.apk文件中。 (apkbuilder)</p>\n<p>6、对APK文件进行签名 (jarsigner)</p>\n<p>7、对签名后的APK文件进行对齐处理 (zipalign)</p>\n<p>主要流程参考这张图：<br><img src=\"https://developer.android.com/images/tools/studio/build-process_2x.png\" alt=\"build-process_2x\"></p>\n<h1 id=\"反编译流程\"><a href=\"#反编译流程\" class=\"headerlink\" title=\"反编译流程\"></a>反编译流程</h1><p>在 apk的打包流程的步骤为：*(资源/aidl等)-&gt; .java-&gt;.calss-&gt;.dex-&gt;.apk，反编译只需要对每个步骤反向进行。</p>\n<h2 id=\"apk-gt-dex\"><a href=\"#apk-gt-dex\" class=\"headerlink\" title=\".apk-&gt;.dex\"></a>.apk-&gt;.dex</h2><p>安卓安装包本质上是一个压缩文件，只需要对齐进行解压即可(Mac上直接将后缀apk，改成 zip 再使用自带解压软件即可)<br>解压获得以下文件：</p>\n<figure class=\"highlight text\"><table><tr><td class=\"code\"><pre><span class=\"line\">├── AndroidManifest.xml</span><br><span class=\"line\">├── META-INF</span><br><span class=\"line\">├── assets</span><br><span class=\"line\">├── classes.dex </span><br><span class=\"line\">├── classes2.dex</span><br><span class=\"line\">├── lib</span><br><span class=\"line\">├── okhttp3</span><br><span class=\"line\">├── org</span><br><span class=\"line\">├── r</span><br><span class=\"line\">└── resources.arsc</span><br></pre></td></tr></table></figure>\n<p>从目录结构得到两个.dex文件，这是由于在单个dex文件引用的方法总数不能超过65536（为什么？因为dex文件中的方法个数采用原生类型short来索引，而short是4个字节，4个字节最大数据存储量是65536），多数 app 超过了这一限制。</p>\n<h2 id=\"dex-gt-class\"><a href=\"#dex-gt-class\" class=\"headerlink\" title=\".dex-&gt;.class\"></a>.dex-&gt;.class</h2><p>这里我们需要利用工具 dex2jar</p>\n<blockquote>\n<p>d2j-dex2jar: Convert .dex file to .class files (zipped as jar)</p>\n</blockquote>\n<p>执行：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">sh /XXX/dex2jar-2.0/d2j-dex2jar.sh classes.dex </span><br></pre></td></tr></table></figure>\n<p>生成 classes-dex2jar.jar, 这个 jar 就是从classes.dex反编译出来的 .class集合。得到了这份 .jar我们已经可以开始使用 jd-gui进行查看了，这里吐槽一下jd-gui的搜索功能，搜索功能有限，纯字符串搜索是有问题的（或许是我版本不对），可以在 File/Save all sources 将所有反编译好的文件进行保存，然后利用其他工具（例如VsCode）进行搜索。</p>\n<img src=\"https://cdn.julis.wang/blog/img/up-6ddc9f6e11b1cffd9cc5a2d8a5634d650f9.png\">\n<p>再看上面的代码，有一部分是 字节码，工具未能将它正常反编译，为什么呢？相关解释在<br><a href=\"https://www.zhihu.com/question/50140866\">https://www.zhihu.com/question/50140866</a> </p>\n<p>这里推荐使用 CFR,执行：</p>\n<figure class=\"highlight text\"><table><tr><td class=\"code\"><pre><span class=\"line\">java -jar /xxx/cfr-0.151.jar /xxx/classes-dex2jar.jar --outputdir /xxx/java</span><br></pre></td></tr></table></figure>\n<img src=\"https://cdn.julis.wang/blog/img/up-b876618b177cd018b2125221c34d0e94907.png\">\n<p>CFR对于 jd-gui 有更好的支持，那还要 jd-gui 干什么呢？在我看来 jd-gui 有一个最大的好处就是能像IDE那样可以点进进入方法内部，所以推荐两则结合起来使用。</p>\n<h2 id=\"so-反编译\"><a href=\"#so-反编译\" class=\"headerlink\" title=\".so 反编译\"></a>.so 反编译</h2><p>在追溯逻辑的过程中，可能会遇到有 native 方法，如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">native</span> <span class=\"type\">int</span> <span class=\"title function_\">dataFromNative</span><span class=\"params\">(<span class=\"type\">byte</span>[] param, <span class=\"type\">int</span> paramInt1, <span class=\"type\">int</span> paramInt2)</span>;</span><br></pre></td></tr></table></figure>\n<p>相关逻辑写在 c/c++文件中，最终把打在.so库中，这时候就需要宇宙第一反汇编分析工具 IDA了，我们在 apk 解压后的 lib 中找到对应的 .so 文件（这里可能需要一点耐心，lib中大多是第三方的，可以很好通过 so 文件名找到开发者的 so文件）,利用 IDA F5 插件查看 汇编代码的伪代码。以字节某 SDK中的某段代码为例：</p>\n<img src=\"https://cdn.julis.wang/blog/img/up-a94ff19122e8fd51ac625f6888620e46ece.png\">\n<p>可以看到对应的逻辑，这时候就考验水平的时候了……<br>当然，IDA 是一个强大的工具，关于IDA的使用绝对不是通过查看一两篇博文就能熟练使用的，可以去查看<br><a href=\"https://www.amazon.com/IDA-Pro-Book-Unofficial-Disassembler/dp/1593272898\">《IDA Pro权威指南》</a></p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>1、当然上述流程只针对”正常App”，但在实际的 App 不会这样轻易的被反编译，App 可能还进行了加固，那我需要对其进行脱壳才能实现正确的反编译，这一内容放在另一章节再进行讲解。<br>2、反编译整个流程，如果没有加固，一般操作是：解压-&gt;class2jar 进行转jar-&gt;CFR/jx-gui 反编译class，如果对逆向还有更多的操作还可以使用 apk_tool。相关流程已经在github 有开源的脚本了<a href=\"https://github.com/tp7309/TTDeDroid\">TTDeDroid</a>，有兴趣的同学可以去看看，但是我感觉有些复杂，我自己也写了一个脚本<a href=\"https://github.com/VomPom/Hack/tree/master/apk_reverse\">apk2dex2jar2class2java.sh</a></p>\n","cover":null,"images":["https://developer.android.com/images/tools/studio/build-process_2x.png","https://cdn.julis.wang/blog/img/up-6ddc9f6e11b1cffd9cc5a2d8a5634d650f9.png","https://cdn.julis.wang/blog/img/up-b876618b177cd018b2125221c34d0e94907.png","https://cdn.julis.wang/blog/img/up-a94ff19122e8fd51ac625f6888620e46ece.png"],"content":"<p>最近由于机缘巧合接触到了 Android 逆向相关的事情，经过一番探索，对其有了更深刻地认识，过程中遇到了了一些坑，或者一些有用的经验，分享并记录分析一下。在整个过程中使用的工具有：</p>\n<p><strong>反编译</strong>：dex2jar、CFR、jd-gui、</p>\n<p><strong>脱壳</strong>：VirtualApp、Xposed installer、FDex2</p>\n<p><strong>其他</strong>：IDA、VSCode、Total commander</p>\n<p>接下来咱们以两个具体情景，讲解整个逆向（静态代码分析）的流程，去分析两个 Apk 中相关页面的加密算法。</p>\n<p>在开发安卓应用的过程中，我们平时写得最多的代码就是 Java(以及Kotlin)，我们的逻辑也都在这一块，如果我们需要对应 apk 中代码逻辑，能直接看到这样的代码当然是最好不过的。要对相关 apk 中的代码逻辑进行分析，那么第一步便是需要对 apk 进行反编译，从而得到可以进行阅读理解的代码。</p>\n<h1 id=\"Apk的打包流程\"><a href=\"#Apk的打包流程\" class=\"headerlink\" title=\"Apk的打包流程\"></a>Apk的打包流程</h1><p>我们先对 安卓的打包流程进行一个简单的了解，从而明白.java文件 是一步步\b成为 apk中的一部分的，在生成 apk 的过程中主要包含以下流程，括号中代表使用的工具：</p>\n<p>1、打包资源文件，生成R.java文件 (aapt)</p>\n<p>2、处理aidl文件，生成相应的.java文件 (aidl)</p>\n<p>3、编译项目源代码，生成class文件 (javac)</p>\n<p>4、转换所有的class文件，生成classes.dex文件 (dx)</p>\n<p>5、编译过的资源和.dex文件都会被apkbuilder工具打包到最终的.apk文件中。 (apkbuilder)</p>\n<p>6、对APK文件进行签名 (jarsigner)</p>\n<p>7、对签名后的APK文件进行对齐处理 (zipalign)</p>\n<p>主要流程参考这张图：<br><img src=\"https://developer.android.com/images/tools/studio/build-process_2x.png\" alt=\"build-process_2x\"></p>\n<h1 id=\"反编译流程\"><a href=\"#反编译流程\" class=\"headerlink\" title=\"反编译流程\"></a>反编译流程</h1><p>在 apk的打包流程的步骤为：*(资源/aidl等)-&gt; .java-&gt;.calss-&gt;.dex-&gt;.apk，反编译只需要对每个步骤反向进行。</p>\n<h2 id=\"apk-gt-dex\"><a href=\"#apk-gt-dex\" class=\"headerlink\" title=\".apk-&gt;.dex\"></a>.apk-&gt;.dex</h2><p>安卓安装包本质上是一个压缩文件，只需要对齐进行解压即可(Mac上直接将后缀apk，改成 zip 再使用自带解压软件即可)<br>解压获得以下文件：</p>\n<figure class=\"highlight text\"><table><tr><td class=\"code\"><pre><span class=\"line\">├── AndroidManifest.xml</span><br><span class=\"line\">├── META-INF</span><br><span class=\"line\">├── assets</span><br><span class=\"line\">├── classes.dex </span><br><span class=\"line\">├── classes2.dex</span><br><span class=\"line\">├── lib</span><br><span class=\"line\">├── okhttp3</span><br><span class=\"line\">├── org</span><br><span class=\"line\">├── r</span><br><span class=\"line\">└── resources.arsc</span><br></pre></td></tr></table></figure>\n<p>从目录结构得到两个.dex文件，这是由于在单个dex文件引用的方法总数不能超过65536（为什么？因为dex文件中的方法个数采用原生类型short来索引，而short是4个字节，4个字节最大数据存储量是65536），多数 app 超过了这一限制。</p>\n<h2 id=\"dex-gt-class\"><a href=\"#dex-gt-class\" class=\"headerlink\" title=\".dex-&gt;.class\"></a>.dex-&gt;.class</h2><p>这里我们需要利用工具 dex2jar</p>\n<blockquote>\n<p>d2j-dex2jar: Convert .dex file to .class files (zipped as jar)</p>\n</blockquote>\n<p>执行：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">sh /XXX/dex2jar-2.0/d2j-dex2jar.sh classes.dex </span><br></pre></td></tr></table></figure>\n<p>生成 classes-dex2jar.jar, 这个 jar 就是从classes.dex反编译出来的 .class集合。得到了这份 .jar我们已经可以开始使用 jd-gui进行查看了，这里吐槽一下jd-gui的搜索功能，搜索功能有限，纯字符串搜索是有问题的（或许是我版本不对），可以在 File/Save all sources 将所有反编译好的文件进行保存，然后利用其他工具（例如VsCode）进行搜索。</p>\n<img src=\"https://cdn.julis.wang/blog/img/up-6ddc9f6e11b1cffd9cc5a2d8a5634d650f9.png\">\n<p>再看上面的代码，有一部分是 字节码，工具未能将它正常反编译，为什么呢？相关解释在<br><a href=\"https://www.zhihu.com/question/50140866\">https://www.zhihu.com/question/50140866</a> </p>\n<p>这里推荐使用 CFR,执行：</p>\n<figure class=\"highlight text\"><table><tr><td class=\"code\"><pre><span class=\"line\">java -jar /xxx/cfr-0.151.jar /xxx/classes-dex2jar.jar --outputdir /xxx/java</span><br></pre></td></tr></table></figure>\n<img src=\"https://cdn.julis.wang/blog/img/up-b876618b177cd018b2125221c34d0e94907.png\">\n<p>CFR对于 jd-gui 有更好的支持，那还要 jd-gui 干什么呢？在我看来 jd-gui 有一个最大的好处就是能像IDE那样可以点进进入方法内部，所以推荐两则结合起来使用。</p>\n<h2 id=\"so-反编译\"><a href=\"#so-反编译\" class=\"headerlink\" title=\".so 反编译\"></a>.so 反编译</h2><p>在追溯逻辑的过程中，可能会遇到有 native 方法，如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">native</span> <span class=\"type\">int</span> <span class=\"title function_\">dataFromNative</span><span class=\"params\">(<span class=\"type\">byte</span>[] param, <span class=\"type\">int</span> paramInt1, <span class=\"type\">int</span> paramInt2)</span>;</span><br></pre></td></tr></table></figure>\n<p>相关逻辑写在 c/c++文件中，最终把打在.so库中，这时候就需要宇宙第一反汇编分析工具 IDA了，我们在 apk 解压后的 lib 中找到对应的 .so 文件（这里可能需要一点耐心，lib中大多是第三方的，可以很好通过 so 文件名找到开发者的 so文件）,利用 IDA F5 插件查看 汇编代码的伪代码。以字节某 SDK中的某段代码为例：</p>\n<img src=\"https://cdn.julis.wang/blog/img/up-a94ff19122e8fd51ac625f6888620e46ece.png\">\n<p>可以看到对应的逻辑，这时候就考验水平的时候了……<br>当然，IDA 是一个强大的工具，关于IDA的使用绝对不是通过查看一两篇博文就能熟练使用的，可以去查看<br><a href=\"https://www.amazon.com/IDA-Pro-Book-Unofficial-Disassembler/dp/1593272898\">《IDA Pro权威指南》</a></p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>1、当然上述流程只针对”正常App”，但在实际的 App 不会这样轻易的被反编译，App 可能还进行了加固，那我需要对其进行脱壳才能实现正确的反编译，这一内容放在另一章节再进行讲解。<br>2、反编译整个流程，如果没有加固，一般操作是：解压-&gt;class2jar 进行转jar-&gt;CFR/jx-gui 反编译class，如果对逆向还有更多的操作还可以使用 apk_tool。相关流程已经在github 有开源的脚本了<a href=\"https://github.com/tp7309/TTDeDroid\">TTDeDroid</a>，有兴趣的同学可以去看看，但是我感觉有些复杂，我自己也写了一个脚本<a href=\"https://github.com/VomPom/Hack/tree/master/apk_reverse\">apk2dex2jar2class2java.sh</a></p>\n","categories":[{"name":"技术文章","slug":"technology","api":"api/categories/technology.json"}],"tags":[{"name":"Android","slug":"Android","api":"api/tags/Android.json"},{"name":"逆向","slug":"逆向","api":"api/tags/逆向.json"}],"api":"api/posts/2021/05/14/Android-逆向-反编译.json"},{"title":"Flutter FFI实践","slug":"FlutterFFI实践","date":"2021-04-18T02:34:00.000Z","updated":"2025-05-20T11:46:57.000Z","comments":true,"url":"2021/04/18/FlutterFFI实践/","excerpt":"<p>在 Android的开发中，我们有 <a href=\"https://developer.android.com/training/articles/perf-jni\">JNI</a> 使得 Java可以调用本地应用或库。<br>Flutter 在前不久发布了 <a href=\"https://developers.googleblog.com/2021/03/announcing-flutter-2.html\">Flutter2</a>，更新了 <a href=\"https://dart.dev/guides/libraries/c-interop\">FFI</a> (我们是否可以把它叫做DNI呢？)进入了稳定状态,开发者可以更安心的使用其功能。<br>但是相关的文档依然很欠缺，导致使用起来有诸多的疑问，以及相关原理性的介绍比较少，所以整理记录一下。</p>\n<h2 id=\"一、Dart-同步调用-Native-方法\"><a href=\"#一、Dart-同步调用-Native-方法\" class=\"headerlink\" title=\"一、Dart 同步调用 Native 方法\"></a>一、Dart 同步调用 Native 方法</h2><p>我们以最简单的demo为例,请求一个有参无返回值的C方法<br>在 C/C++中有如下函数：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">extern</span> <span class=\"string\">&quot;C&quot;</span> __attribute__((visibility(<span class=\"string\">&quot;default&quot;</span>))) __attribute__((used))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">c_with_out_return_value</span><span class=\"params\">(<span class=\"type\">int</span> value)</span> &#123;</span><br><span class=\"line\">    LOG_D(<span class=\"string\">&quot;Got invoke value: %d&quot;</span>, value);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Dart:</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">final</span> DynamicLibrary ffiLib = Platform.isAndroid ? DynamicLibrary.open(<span class=\"string\">&#x27;lib_invoke.so&#x27;</span>) : DynamicLibrary.process();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">final</span> cMethod = ffiLib.lookupFunction&lt;Void <span class=\"built_in\">Function</span>(Int32 value), <span class=\"keyword\">void</span> <span class=\"built_in\">Function</span>(<span class=\"built_in\">int</span> value)&gt;(<span class=\"string\">&#x27;c_with_out_return_value&#x27;</span>);</span><br><span class=\"line\">cMethod(<span class=\"number\">123</span>);  </span><br></pre></td></tr></table></figure>\n<p>这样一次调用就完成了一次调用，传递了123到Native并执行了一次打印，同理相关有参有返回值的请求也都是这样做到的，那 Dart 和 Native内部具体怎样实现的呢？</p>\n<p><code>DynamicLibrary.open()</code> 最终执行的逻辑如下, 源码位于<a href=\"https://github.com/dart-lang/sdk/blob/master/runtime/lib/ffi_dynamic_library.cc\">ffi_dynamic_library.cc</a>：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">void</span>* <span class=\"title function_\">LoadExtensionLibrary</span><span class=\"params\">(<span class=\"type\">const</span> <span class=\"type\">char</span>* library_file)</span> &#123;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">if</span> defined(HOST_OS_LINUX) || defined(HOST_OS_MACOS) ||                        \\</span></span><br><span class=\"line\"><span class=\"meta\">    defined(HOST_OS_ANDROID) || defined(HOST_OS_FUCHSIA)</span></span><br><span class=\"line\">  <span class=\"type\">void</span>* handle = dlopen(library_file, RTLD_LAZY);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (handle == nullptr) &#123;</span><br><span class=\"line\">    <span class=\"type\">char</span>* error = dlerror();</span><br><span class=\"line\">    <span class=\"type\">const</span> String&amp; msg = String::Handle(</span><br><span class=\"line\">        String::NewFormatted(<span class=\"string\">&quot;Failed to load dynamic library (%s)&quot;</span>, error));</span><br><span class=\"line\">    Exceptions::ThrowArgumentError(msg);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> handle;</span><br><span class=\"line\">  ……</span><br></pre></td></tr></table></figure>\n<p>可以看到最终使用 <a href=\"https://pubs.opengroup.org/onlinepubs/009696699/functions/dlopen.html\">dlopen</a> 加载动态链接库，并返回句柄。</p>\n<p>拿到对应的动态链接库的句柄之后，就能使用相关方法进行操作了。<br>句柄主要包含以下两个方法：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//在内存中查找对应符号名的地址，与dlsym()功能相同</span></span><br><span class=\"line\"><span class=\"keyword\">external</span> Pointer&lt;T&gt; lookup&lt;T <span class=\"keyword\">extends</span> NativeType&gt;(<span class=\"built_in\">String</span> symbolName);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//1、去动态库中查找对应名称的函数 </span></span><br><span class=\"line\"><span class=\"comment\">//2、将 Native 类型的 C/C++ 函数转化为 Dart 的 Function 类型</span></span><br><span class=\"line\"><span class=\"keyword\">external</span> F lookupFunction&lt;T <span class=\"keyword\">extends</span> <span class=\"built_in\">Function</span>, F <span class=\"keyword\">extends</span> <span class=\"built_in\">Function</span>&gt;(<span class=\"built_in\">String</span> symbolName);</span><br></pre></td></tr></table></figure>\n<p>其中lookup()的最终实现主要使用了 <a href=\"https://pubs.opengroup.org/onlinepubs/009695399/functions/dlsym.html\">dlsym</a></p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">void</span>* <span class=\"title function_\">ResolveSymbol</span><span class=\"params\">(<span class=\"type\">void</span>* handle, <span class=\"type\">const</span> <span class=\"type\">char</span>* symbol)</span> &#123;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">if</span> defined(HOST_OS_LINUX) || defined(HOST_OS_MACOS) ||                       </span></span><br><span class=\"line\">    defined(HOST_OS_ANDROID) || defined(HOST_OS_FUCHSIA)</span><br><span class=\"line\">  dlerror();  <span class=\"comment\">// Clear any errors.</span></span><br><span class=\"line\">  <span class=\"type\">void</span>* pointer = dlsym(handle, symbol);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (pointer == nullptr) &#123;</span><br><span class=\"line\">    <span class=\"type\">char</span>* error = dlerror();</span><br><span class=\"line\">    <span class=\"type\">const</span> String&amp; msg = String::Handle(</span><br><span class=\"line\">        String::NewFormatted(<span class=\"string\">&quot;Failed to lookup symbol (%s)&quot;</span>, error));</span><br><span class=\"line\">    Exceptions::ThrowArgumentError(msg);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> pointer;</span><br></pre></td></tr></table></figure>\n<h2 id=\"二、Dart-异步调用-Native-方法\"><a href=\"#二、Dart-异步调用-Native-方法\" class=\"headerlink\" title=\"二、Dart 异步调用 Native 方法\"></a>二、Dart 异步调用 Native 方法</h2><p>在很多场景我们不能像上述同步方法那样，dart 进行一次请求之后立马得到结果，可能会有一些耗时操作，为了不让 Flutter 的UI线程卡住，我们进行异步请求。那如何实现异步请求呢？<br>对于异步实现，官方并没有很明确的文档，都得靠自己琢磨，在官方的讨论中 <a href=\"https://github.com/dart-lang/sdk/issues/37022\">https://github.com/dart-lang/sdk/issues/37022</a> 以及 <a href=\"https://github.com/flutter/flutter/issues/63255\">https://github.com/flutter/flutter/issues/63255</a> 提到一些解决方案:</p>\n<blockquote>\n<p>1.In your C++ code include include/dart_api_dl.h and include/dart_api_dl.cc from here <a href=\"https://github.com/dart-lang/sdk/blob/master/runtime/include/\">https://github.com/dart-lang/sdk/blob/master/runtime/include/</a> (they also depend on include/internal/*).</p>\n<p>2.From Dart call Dart_InitializeApiDL passing NativeApi.initializeApiDLData as an argument.</p>\n<p>3.On Dart side create a ReceivePort and pass port number of the corresponding SendPort to the native side (port.sendPort.nativePort).</p>\n<p>4.Now on C++ side you can use Dart_PostCObject_DL to send messages back to Dart side from any thread.</p>\n</blockquote>\n<p>按上述的操作进行实现，接下来具体分析一些里面的逻辑原理。<br>1、导入include/dart_api_dl.h include/dart_api_dl.cc 相关的文件并在 CMakeList.txt进行相关配置<br>2、从dart中 调用Native中 Dart_InitializeApiDL</p>\n<p>Dart:</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> main() &#123;</span><br><span class=\"line\">  initializeApi(NativeApi.initializeApiDLData);</span><br><span class=\"line\">  runApp(MyApp());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>C++:</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Initialize `dart_api_dl.h`</span></span><br><span class=\"line\">DART_EXPORT <span class=\"type\">intptr_t</span> <span class=\"title function_\">InitDartApiDL</span><span class=\"params\">(<span class=\"type\">void</span> *data)</span> &#123;</span><br><span class=\"line\">    LOG_D(<span class=\"string\">&quot;InitDartApiDL&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> Dart_InitializeApiDL(data);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>在 initializeApi(NativeApi.initializeApiDLData) 中 initializeApi 向 Native请求 <code>DART_EXPORT intptr_t InitDartApiDL(void *data)</code>方法，传入的参数就是在 <a href=\"https://github.com/dart-lang/sdk/blob/master/runtime/include/dart_api_dl.h\">dart_api_dl.h</a><br> DART_NATIVE_API_DL_SYMBOLS 以及 DART_API_DL_SYMBOLS 中的方法。</p>\n<p>NativeApi.initializeApiDLData 逻辑：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">const</span> DartApiEntry dart_api_entries[] = &#123;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> ENTRY(name, R, A)                                                      \\</span></span><br><span class=\"line\"><span class=\"meta\">  DartApiEntry&#123;#name, reinterpret_cast<span class=\"string\">&lt;void (*)()&gt;</span>(name)&#125;,</span></span><br><span class=\"line\">    DART_API_ALL_DL_SYMBOLS(ENTRY)</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">undef</span> ENTRY</span></span><br><span class=\"line\">        DartApiEntry&#123;nullptr, nullptr&#125;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">const</span> DartApi dart_api_data = &#123;</span><br><span class=\"line\">    DART_API_DL_MAJOR_VERSION, DART_API_DL_MINOR_VERSION, dart_api_entries&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">DEFINE_NATIVE_ENTRY(DartApiDLInitializeData, <span class=\"number\">0</span>, <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> Integer::New(reinterpret_cast&lt;<span class=\"type\">intptr_t</span>&gt;(&amp;dart_api_data));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>dart_api_dl中定义的方法：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> DART_NATIVE_API_DL_SYMBOLS(F)                                          \\</span></span><br><span class=\"line\"><span class=\"meta\">  <span class=\"comment\">/***** dart_native_api.h *****/</span>                                              \\</span></span><br><span class=\"line\"><span class=\"meta\">  <span class=\"comment\">/* Dart_Port */</span>                                                              \\</span></span><br><span class=\"line\"><span class=\"meta\">  F(Dart_PostCObject, bool, (Dart_Port_DL port_id, Dart_CObject * message))    \\</span></span><br><span class=\"line\"><span class=\"meta\">  F(Dart_PostInteger, bool, (Dart_Port_DL port_id, int64_t message))           \\</span></span><br><span class=\"line\"><span class=\"meta\">  .....</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// dart_api.h symbols can only be called on Dart threads.</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> DART_API_DL_SYMBOLS(F)                                                 \\</span></span><br><span class=\"line\"><span class=\"meta\">  <span class=\"comment\">/***** dart_api.h *****/</span>                                                     \\</span></span><br><span class=\"line\"><span class=\"meta\">  <span class=\"comment\">/* Errors */</span>                                                                 \\</span></span><br><span class=\"line\"><span class=\"meta\">  F(Dart_IsError, bool, (Dart_Handle handle))                                  \\</span></span><br><span class=\"line\"><span class=\"meta\">  F(Dart_IsApiError, bool, (Dart_Handle handle))                               \\</span></span><br><span class=\"line\"><span class=\"meta\">  .....</span></span><br></pre></td></tr></table></figure>\n<p>其实这上面的逻辑很简单，主要是为了让业务中的代码能够进行动态链接，从而调用到 Flutter SDK 中相关方法。</p>\n<p>3、第三步添加 ReceivePort 监听</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Work</span> <span class=\"keyword\">extends</span> <span class=\"title\">Opaque</span> </span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">void</span> requestExecuteCallback(<span class=\"built_in\">dynamic</span> message) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">final</span> <span class=\"built_in\">int</span> workAddress = message <span class=\"keyword\">as</span> <span class=\"built_in\">int</span>;</span><br><span class=\"line\">  <span class=\"keyword\">final</span> Pointer&lt;Work&gt; work = Pointer&lt;Work&gt;.fromAddress(workAddress);</span><br><span class=\"line\">  executeCallback(work);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">final</span> ReceivePort interactiveCppRequests = ReceivePort()..listen(requestExecuteCallback);</span><br></pre></td></tr></table></figure>\n<p>向 Native 发送带有 interactiveCppRequests.sendPort.nativePort 的数据，为native异步回调做准备。</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">Future&lt;<span class=\"built_in\">int</span>&gt; platformAsync(<span class=\"built_in\">int</span> value1, <span class=\"built_in\">int</span> value2) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">final</span> Completer&lt;<span class=\"built_in\">int</span>&gt; completer = Completer&lt;<span class=\"built_in\">int</span>&gt;();</span><br><span class=\"line\">  <span class=\"keyword\">final</span> <span class=\"built_in\">String</span> cid = uuid.v1();</span><br><span class=\"line\">  <span class=\"keyword\">final</span> Pointer&lt;Utf8&gt; cidPtr = cid.toNativeUtf8();</span><br><span class=\"line\">  completerMapping[cid] = completer;</span><br><span class=\"line\">  <span class=\"comment\">//生成一个nativePort，为native异步回调做准备</span></span><br><span class=\"line\">  <span class=\"keyword\">final</span> <span class=\"built_in\">int</span> nativePort = interactiveCppRequests.sendPort.nativePort; </span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">final</span> cMethod = ffiLib.lookupFunction&lt;</span><br><span class=\"line\">      Int32 <span class=\"built_in\">Function</span>(Pointer&lt;Utf8&gt; cId, Int64 sendPort, Int32 value1, Int32 value2,</span><br><span class=\"line\">          Pointer&lt;NativeFunction&lt;callback_type&gt;&gt; callbackBlock),</span><br><span class=\"line\">      <span class=\"built_in\">int</span> <span class=\"built_in\">Function</span>(Pointer&lt;Utf8&gt; cId, <span class=\"built_in\">int</span> sendPort, <span class=\"built_in\">int</span> value1, <span class=\"built_in\">int</span> value2,</span><br><span class=\"line\">          Pointer&lt;NativeFunction&lt;callback_type&gt;&gt; callbackBlock)&gt;(<span class=\"string\">&#x27;platform_async&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  cMethod(cidPtr, nativePort, value1, value2, Pointer.fromFunction&lt;callback_type&gt;(_callbackBlocking));</span><br><span class=\"line\">  <span class=\"keyword\">return</span> completer.future;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>4、当异步执行完成之后，在 Native 执行 Dart_PostCObject_DL 通知 Dart 已经得到结果<br>对于代码如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">response</span><span class=\"params\">(jint result)</span> </span>&#123;</span><br><span class=\"line\">    Work work = [_callback,result] &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (_callback != <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">            _callback( result);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"built_in\">LOG_E</span>(<span class=\"string\">&quot;_callback == null&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    <span class=\"comment\">// Copy to heap to make it outlive the function scope.</span></span><br><span class=\"line\">    <span class=\"type\">const</span> Work *work_ptr = <span class=\"keyword\">new</span> <span class=\"built_in\">Work</span>(work);</span><br><span class=\"line\">    <span class=\"built_in\">NotifyDart</span>(send_port, work_ptr);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">NotifyDart</span><span class=\"params\">(Dart_Port send_port, <span class=\"type\">const</span> Work *work)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"type\">const</span> <span class=\"keyword\">auto</span> work_address = <span class=\"built_in\">reinterpret_cast</span>&lt;<span class=\"type\">intptr_t</span>&gt;(work);</span><br><span class=\"line\">    Dart_CObject dart_object;</span><br><span class=\"line\">    dart_object.type = Dart_CObject_kInt64;</span><br><span class=\"line\">    dart_object.value.as_int64 = work_address;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">const</span> <span class=\"type\">bool</span> result = <span class=\"built_in\">Dart_PostCObject_DL</span>(send_port, &amp;dart_object);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!result) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">LOG_D</span>(<span class=\"string\">&quot;FFI C  :  Posting message to port failed.&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面的代码最核心的就是<code>Dart_PostCObject_DL()</code>这里真正调用的还是，<code>Dart_PostCObject()</code>，加_DL()表示动态链接的方法，为了防止与原先符号冲突。</p>\n<blockquote>\n<p>All symbols are postfixed with _DL to indicate that they are dynamically</p>\n<p>linked and to prevent conflicts with the original symbol.</p>\n</blockquote>\n<p>我们继续看看  <code>Dart_PostCObject()</code>真正做了什么，Dart_PostCObject()最终调用的方法如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">bool</span> <span class=\"title function_\">PostCObjectHelper</span><span class=\"params\">(Dart_Port port_id, Dart_CObject* message)</span> &#123;</span><br><span class=\"line\">  ApiMessageWriter writer;</span><br><span class=\"line\">  <span class=\"built_in\">std</span>::<span class=\"built_in\">unique_ptr</span>&lt;Message&gt; msg =</span><br><span class=\"line\">      writer.WriteCMessage(message, port_id, Message::kNormalPriority);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (msg == nullptr) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Post the message at the given port.</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> PortMap::PostMessage(<span class=\"built_in\">std</span>::move(msg));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里在向 Service Isolate发送事件,最终 Dart 成功接受到异步消息的回调。<br>关于 Isolate 这一块的处理可以参考：<a href=\"https://medium.com/@codinghive.dev/async-coding-with-dart-isolates-b09c5ec00f8b\">Async Coding With Dart: Isolates</a></p>\n<h2 id=\"三、Native-调用-Dart方法\"><a href=\"#三、Native-调用-Dart方法\" class=\"headerlink\" title=\"三、Native 调用 Dart方法 ?\"></a>三、Native 调用 Dart方法 ?</h2><p>对于 JNI 里面，我们需要调用 Java的方法，利用Java反射机制调用即可，如下所示：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">_env-&gt;CallStaticVoidMethod(j_class, j_method, arg1, arg2);</span><br></pre></td></tr></table></figure>\n<p>如果 Native 想要调用 Dart代码有类似的代码可以用么？翻遍了 Flutter相关的文档，都没有找到对应的方法可以直接去调用 Dart的方法，Dart Engine内部有 <a href=\"https://github.com/dart-lang/sdk/blob/master/runtime/include/dart_api.h\">dart_api.h</a>提供了<code>Dart_invoke()</code>方法，但单纯的导入 .h文件在项目中是无法链接到对应的方法的，这也就是为什么需要导入<a href=\"https://github.com/dart-lang/sdk/tree/master/runtime/include\">ffi_runtime_lib</a>相关的文件并执行 <code>Dart_InitializeApiDL()</code>，通过动态链接使得代码能够去调用 Dart 封装的相关方法。</p>\n<p>所以参考 Dart中 <code>InitDartApiDL</code>的方法，我们先对 Dart 中的函数进行注册，传递对应方法的指针，然后在 Native 中即可调用，理论上可行，后续会补上相关  demo。<br>当然这只是一种骚操作，如果有更好的方法能够用 Native 调用 Dart 欢迎讨论。</p>\n<h2 id=\"四、总结\"><a href=\"#四、总结\" class=\"headerlink\" title=\"四、总结\"></a>四、总结</h2><p>文章记录了 Dart 同步和异步调用 Native 相关的使用，异步具体的使用比上述的代码复杂，因为需要一个中介记录异步相关的回调方法，当得到真正的结果之后，利用id查找到对应的方法再执行回调方法。FFI 在 Native中执行 dart 方法，暂时没有比较好的解决方案<br>FFI 调用可查看 <a href=\"https://github.com/VomPom/flutter_ffi_tutorial\">Demo flutter_ffi_tutorial</a></p>\n","cover":null,"images":[],"content":"<p>在 Android的开发中，我们有 <a href=\"https://developer.android.com/training/articles/perf-jni\">JNI</a> 使得 Java可以调用本地应用或库。<br>Flutter 在前不久发布了 <a href=\"https://developers.googleblog.com/2021/03/announcing-flutter-2.html\">Flutter2</a>，更新了 <a href=\"https://dart.dev/guides/libraries/c-interop\">FFI</a> (我们是否可以把它叫做DNI呢？)进入了稳定状态,开发者可以更安心的使用其功能。<br>但是相关的文档依然很欠缺，导致使用起来有诸多的疑问，以及相关原理性的介绍比较少，所以整理记录一下。</p>\n<h2 id=\"一、Dart-同步调用-Native-方法\"><a href=\"#一、Dart-同步调用-Native-方法\" class=\"headerlink\" title=\"一、Dart 同步调用 Native 方法\"></a>一、Dart 同步调用 Native 方法</h2><p>我们以最简单的demo为例,请求一个有参无返回值的C方法<br>在 C/C++中有如下函数：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">extern</span> <span class=\"string\">&quot;C&quot;</span> __attribute__((visibility(<span class=\"string\">&quot;default&quot;</span>))) __attribute__((used))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">c_with_out_return_value</span><span class=\"params\">(<span class=\"type\">int</span> value)</span> &#123;</span><br><span class=\"line\">    LOG_D(<span class=\"string\">&quot;Got invoke value: %d&quot;</span>, value);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Dart:</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">final</span> DynamicLibrary ffiLib = Platform.isAndroid ? DynamicLibrary.open(<span class=\"string\">&#x27;lib_invoke.so&#x27;</span>) : DynamicLibrary.process();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">final</span> cMethod = ffiLib.lookupFunction&lt;Void <span class=\"built_in\">Function</span>(Int32 value), <span class=\"keyword\">void</span> <span class=\"built_in\">Function</span>(<span class=\"built_in\">int</span> value)&gt;(<span class=\"string\">&#x27;c_with_out_return_value&#x27;</span>);</span><br><span class=\"line\">cMethod(<span class=\"number\">123</span>);  </span><br></pre></td></tr></table></figure>\n<p>这样一次调用就完成了一次调用，传递了123到Native并执行了一次打印，同理相关有参有返回值的请求也都是这样做到的，那 Dart 和 Native内部具体怎样实现的呢？</p>\n<p><code>DynamicLibrary.open()</code> 最终执行的逻辑如下, 源码位于<a href=\"https://github.com/dart-lang/sdk/blob/master/runtime/lib/ffi_dynamic_library.cc\">ffi_dynamic_library.cc</a>：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">void</span>* <span class=\"title function_\">LoadExtensionLibrary</span><span class=\"params\">(<span class=\"type\">const</span> <span class=\"type\">char</span>* library_file)</span> &#123;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">if</span> defined(HOST_OS_LINUX) || defined(HOST_OS_MACOS) ||                        \\</span></span><br><span class=\"line\"><span class=\"meta\">    defined(HOST_OS_ANDROID) || defined(HOST_OS_FUCHSIA)</span></span><br><span class=\"line\">  <span class=\"type\">void</span>* handle = dlopen(library_file, RTLD_LAZY);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (handle == nullptr) &#123;</span><br><span class=\"line\">    <span class=\"type\">char</span>* error = dlerror();</span><br><span class=\"line\">    <span class=\"type\">const</span> String&amp; msg = String::Handle(</span><br><span class=\"line\">        String::NewFormatted(<span class=\"string\">&quot;Failed to load dynamic library (%s)&quot;</span>, error));</span><br><span class=\"line\">    Exceptions::ThrowArgumentError(msg);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> handle;</span><br><span class=\"line\">  ……</span><br></pre></td></tr></table></figure>\n<p>可以看到最终使用 <a href=\"https://pubs.opengroup.org/onlinepubs/009696699/functions/dlopen.html\">dlopen</a> 加载动态链接库，并返回句柄。</p>\n<p>拿到对应的动态链接库的句柄之后，就能使用相关方法进行操作了。<br>句柄主要包含以下两个方法：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//在内存中查找对应符号名的地址，与dlsym()功能相同</span></span><br><span class=\"line\"><span class=\"keyword\">external</span> Pointer&lt;T&gt; lookup&lt;T <span class=\"keyword\">extends</span> NativeType&gt;(<span class=\"built_in\">String</span> symbolName);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//1、去动态库中查找对应名称的函数 </span></span><br><span class=\"line\"><span class=\"comment\">//2、将 Native 类型的 C/C++ 函数转化为 Dart 的 Function 类型</span></span><br><span class=\"line\"><span class=\"keyword\">external</span> F lookupFunction&lt;T <span class=\"keyword\">extends</span> <span class=\"built_in\">Function</span>, F <span class=\"keyword\">extends</span> <span class=\"built_in\">Function</span>&gt;(<span class=\"built_in\">String</span> symbolName);</span><br></pre></td></tr></table></figure>\n<p>其中lookup()的最终实现主要使用了 <a href=\"https://pubs.opengroup.org/onlinepubs/009695399/functions/dlsym.html\">dlsym</a></p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">void</span>* <span class=\"title function_\">ResolveSymbol</span><span class=\"params\">(<span class=\"type\">void</span>* handle, <span class=\"type\">const</span> <span class=\"type\">char</span>* symbol)</span> &#123;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">if</span> defined(HOST_OS_LINUX) || defined(HOST_OS_MACOS) ||                       </span></span><br><span class=\"line\">    defined(HOST_OS_ANDROID) || defined(HOST_OS_FUCHSIA)</span><br><span class=\"line\">  dlerror();  <span class=\"comment\">// Clear any errors.</span></span><br><span class=\"line\">  <span class=\"type\">void</span>* pointer = dlsym(handle, symbol);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (pointer == nullptr) &#123;</span><br><span class=\"line\">    <span class=\"type\">char</span>* error = dlerror();</span><br><span class=\"line\">    <span class=\"type\">const</span> String&amp; msg = String::Handle(</span><br><span class=\"line\">        String::NewFormatted(<span class=\"string\">&quot;Failed to lookup symbol (%s)&quot;</span>, error));</span><br><span class=\"line\">    Exceptions::ThrowArgumentError(msg);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> pointer;</span><br></pre></td></tr></table></figure>\n<h2 id=\"二、Dart-异步调用-Native-方法\"><a href=\"#二、Dart-异步调用-Native-方法\" class=\"headerlink\" title=\"二、Dart 异步调用 Native 方法\"></a>二、Dart 异步调用 Native 方法</h2><p>在很多场景我们不能像上述同步方法那样，dart 进行一次请求之后立马得到结果，可能会有一些耗时操作，为了不让 Flutter 的UI线程卡住，我们进行异步请求。那如何实现异步请求呢？<br>对于异步实现，官方并没有很明确的文档，都得靠自己琢磨，在官方的讨论中 <a href=\"https://github.com/dart-lang/sdk/issues/37022\">https://github.com/dart-lang/sdk/issues/37022</a> 以及 <a href=\"https://github.com/flutter/flutter/issues/63255\">https://github.com/flutter/flutter/issues/63255</a> 提到一些解决方案:</p>\n<blockquote>\n<p>1.In your C++ code include include/dart_api_dl.h and include/dart_api_dl.cc from here <a href=\"https://github.com/dart-lang/sdk/blob/master/runtime/include/\">https://github.com/dart-lang/sdk/blob/master/runtime/include/</a> (they also depend on include/internal/*).</p>\n<p>2.From Dart call Dart_InitializeApiDL passing NativeApi.initializeApiDLData as an argument.</p>\n<p>3.On Dart side create a ReceivePort and pass port number of the corresponding SendPort to the native side (port.sendPort.nativePort).</p>\n<p>4.Now on C++ side you can use Dart_PostCObject_DL to send messages back to Dart side from any thread.</p>\n</blockquote>\n<p>按上述的操作进行实现，接下来具体分析一些里面的逻辑原理。<br>1、导入include/dart_api_dl.h include/dart_api_dl.cc 相关的文件并在 CMakeList.txt进行相关配置<br>2、从dart中 调用Native中 Dart_InitializeApiDL</p>\n<p>Dart:</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> main() &#123;</span><br><span class=\"line\">  initializeApi(NativeApi.initializeApiDLData);</span><br><span class=\"line\">  runApp(MyApp());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>C++:</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Initialize `dart_api_dl.h`</span></span><br><span class=\"line\">DART_EXPORT <span class=\"type\">intptr_t</span> <span class=\"title function_\">InitDartApiDL</span><span class=\"params\">(<span class=\"type\">void</span> *data)</span> &#123;</span><br><span class=\"line\">    LOG_D(<span class=\"string\">&quot;InitDartApiDL&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> Dart_InitializeApiDL(data);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>在 initializeApi(NativeApi.initializeApiDLData) 中 initializeApi 向 Native请求 <code>DART_EXPORT intptr_t InitDartApiDL(void *data)</code>方法，传入的参数就是在 <a href=\"https://github.com/dart-lang/sdk/blob/master/runtime/include/dart_api_dl.h\">dart_api_dl.h</a><br> DART_NATIVE_API_DL_SYMBOLS 以及 DART_API_DL_SYMBOLS 中的方法。</p>\n<p>NativeApi.initializeApiDLData 逻辑：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">const</span> DartApiEntry dart_api_entries[] = &#123;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> ENTRY(name, R, A)                                                      \\</span></span><br><span class=\"line\"><span class=\"meta\">  DartApiEntry&#123;#name, reinterpret_cast<span class=\"string\">&lt;void (*)()&gt;</span>(name)&#125;,</span></span><br><span class=\"line\">    DART_API_ALL_DL_SYMBOLS(ENTRY)</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">undef</span> ENTRY</span></span><br><span class=\"line\">        DartApiEntry&#123;nullptr, nullptr&#125;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">const</span> DartApi dart_api_data = &#123;</span><br><span class=\"line\">    DART_API_DL_MAJOR_VERSION, DART_API_DL_MINOR_VERSION, dart_api_entries&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">DEFINE_NATIVE_ENTRY(DartApiDLInitializeData, <span class=\"number\">0</span>, <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> Integer::New(reinterpret_cast&lt;<span class=\"type\">intptr_t</span>&gt;(&amp;dart_api_data));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>dart_api_dl中定义的方法：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> DART_NATIVE_API_DL_SYMBOLS(F)                                          \\</span></span><br><span class=\"line\"><span class=\"meta\">  <span class=\"comment\">/***** dart_native_api.h *****/</span>                                              \\</span></span><br><span class=\"line\"><span class=\"meta\">  <span class=\"comment\">/* Dart_Port */</span>                                                              \\</span></span><br><span class=\"line\"><span class=\"meta\">  F(Dart_PostCObject, bool, (Dart_Port_DL port_id, Dart_CObject * message))    \\</span></span><br><span class=\"line\"><span class=\"meta\">  F(Dart_PostInteger, bool, (Dart_Port_DL port_id, int64_t message))           \\</span></span><br><span class=\"line\"><span class=\"meta\">  .....</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// dart_api.h symbols can only be called on Dart threads.</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> DART_API_DL_SYMBOLS(F)                                                 \\</span></span><br><span class=\"line\"><span class=\"meta\">  <span class=\"comment\">/***** dart_api.h *****/</span>                                                     \\</span></span><br><span class=\"line\"><span class=\"meta\">  <span class=\"comment\">/* Errors */</span>                                                                 \\</span></span><br><span class=\"line\"><span class=\"meta\">  F(Dart_IsError, bool, (Dart_Handle handle))                                  \\</span></span><br><span class=\"line\"><span class=\"meta\">  F(Dart_IsApiError, bool, (Dart_Handle handle))                               \\</span></span><br><span class=\"line\"><span class=\"meta\">  .....</span></span><br></pre></td></tr></table></figure>\n<p>其实这上面的逻辑很简单，主要是为了让业务中的代码能够进行动态链接，从而调用到 Flutter SDK 中相关方法。</p>\n<p>3、第三步添加 ReceivePort 监听</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Work</span> <span class=\"keyword\">extends</span> <span class=\"title\">Opaque</span> </span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">void</span> requestExecuteCallback(<span class=\"built_in\">dynamic</span> message) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">final</span> <span class=\"built_in\">int</span> workAddress = message <span class=\"keyword\">as</span> <span class=\"built_in\">int</span>;</span><br><span class=\"line\">  <span class=\"keyword\">final</span> Pointer&lt;Work&gt; work = Pointer&lt;Work&gt;.fromAddress(workAddress);</span><br><span class=\"line\">  executeCallback(work);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">final</span> ReceivePort interactiveCppRequests = ReceivePort()..listen(requestExecuteCallback);</span><br></pre></td></tr></table></figure>\n<p>向 Native 发送带有 interactiveCppRequests.sendPort.nativePort 的数据，为native异步回调做准备。</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">Future&lt;<span class=\"built_in\">int</span>&gt; platformAsync(<span class=\"built_in\">int</span> value1, <span class=\"built_in\">int</span> value2) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">final</span> Completer&lt;<span class=\"built_in\">int</span>&gt; completer = Completer&lt;<span class=\"built_in\">int</span>&gt;();</span><br><span class=\"line\">  <span class=\"keyword\">final</span> <span class=\"built_in\">String</span> cid = uuid.v1();</span><br><span class=\"line\">  <span class=\"keyword\">final</span> Pointer&lt;Utf8&gt; cidPtr = cid.toNativeUtf8();</span><br><span class=\"line\">  completerMapping[cid] = completer;</span><br><span class=\"line\">  <span class=\"comment\">//生成一个nativePort，为native异步回调做准备</span></span><br><span class=\"line\">  <span class=\"keyword\">final</span> <span class=\"built_in\">int</span> nativePort = interactiveCppRequests.sendPort.nativePort; </span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">final</span> cMethod = ffiLib.lookupFunction&lt;</span><br><span class=\"line\">      Int32 <span class=\"built_in\">Function</span>(Pointer&lt;Utf8&gt; cId, Int64 sendPort, Int32 value1, Int32 value2,</span><br><span class=\"line\">          Pointer&lt;NativeFunction&lt;callback_type&gt;&gt; callbackBlock),</span><br><span class=\"line\">      <span class=\"built_in\">int</span> <span class=\"built_in\">Function</span>(Pointer&lt;Utf8&gt; cId, <span class=\"built_in\">int</span> sendPort, <span class=\"built_in\">int</span> value1, <span class=\"built_in\">int</span> value2,</span><br><span class=\"line\">          Pointer&lt;NativeFunction&lt;callback_type&gt;&gt; callbackBlock)&gt;(<span class=\"string\">&#x27;platform_async&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  cMethod(cidPtr, nativePort, value1, value2, Pointer.fromFunction&lt;callback_type&gt;(_callbackBlocking));</span><br><span class=\"line\">  <span class=\"keyword\">return</span> completer.future;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>4、当异步执行完成之后，在 Native 执行 Dart_PostCObject_DL 通知 Dart 已经得到结果<br>对于代码如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">response</span><span class=\"params\">(jint result)</span> </span>&#123;</span><br><span class=\"line\">    Work work = [_callback,result] &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (_callback != <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">            _callback( result);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"built_in\">LOG_E</span>(<span class=\"string\">&quot;_callback == null&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    <span class=\"comment\">// Copy to heap to make it outlive the function scope.</span></span><br><span class=\"line\">    <span class=\"type\">const</span> Work *work_ptr = <span class=\"keyword\">new</span> <span class=\"built_in\">Work</span>(work);</span><br><span class=\"line\">    <span class=\"built_in\">NotifyDart</span>(send_port, work_ptr);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">NotifyDart</span><span class=\"params\">(Dart_Port send_port, <span class=\"type\">const</span> Work *work)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"type\">const</span> <span class=\"keyword\">auto</span> work_address = <span class=\"built_in\">reinterpret_cast</span>&lt;<span class=\"type\">intptr_t</span>&gt;(work);</span><br><span class=\"line\">    Dart_CObject dart_object;</span><br><span class=\"line\">    dart_object.type = Dart_CObject_kInt64;</span><br><span class=\"line\">    dart_object.value.as_int64 = work_address;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">const</span> <span class=\"type\">bool</span> result = <span class=\"built_in\">Dart_PostCObject_DL</span>(send_port, &amp;dart_object);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!result) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">LOG_D</span>(<span class=\"string\">&quot;FFI C  :  Posting message to port failed.&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面的代码最核心的就是<code>Dart_PostCObject_DL()</code>这里真正调用的还是，<code>Dart_PostCObject()</code>，加_DL()表示动态链接的方法，为了防止与原先符号冲突。</p>\n<blockquote>\n<p>All symbols are postfixed with _DL to indicate that they are dynamically</p>\n<p>linked and to prevent conflicts with the original symbol.</p>\n</blockquote>\n<p>我们继续看看  <code>Dart_PostCObject()</code>真正做了什么，Dart_PostCObject()最终调用的方法如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">bool</span> <span class=\"title function_\">PostCObjectHelper</span><span class=\"params\">(Dart_Port port_id, Dart_CObject* message)</span> &#123;</span><br><span class=\"line\">  ApiMessageWriter writer;</span><br><span class=\"line\">  <span class=\"built_in\">std</span>::<span class=\"built_in\">unique_ptr</span>&lt;Message&gt; msg =</span><br><span class=\"line\">      writer.WriteCMessage(message, port_id, Message::kNormalPriority);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (msg == nullptr) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Post the message at the given port.</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> PortMap::PostMessage(<span class=\"built_in\">std</span>::move(msg));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里在向 Service Isolate发送事件,最终 Dart 成功接受到异步消息的回调。<br>关于 Isolate 这一块的处理可以参考：<a href=\"https://medium.com/@codinghive.dev/async-coding-with-dart-isolates-b09c5ec00f8b\">Async Coding With Dart: Isolates</a></p>\n<h2 id=\"三、Native-调用-Dart方法\"><a href=\"#三、Native-调用-Dart方法\" class=\"headerlink\" title=\"三、Native 调用 Dart方法 ?\"></a>三、Native 调用 Dart方法 ?</h2><p>对于 JNI 里面，我们需要调用 Java的方法，利用Java反射机制调用即可，如下所示：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">_env-&gt;CallStaticVoidMethod(j_class, j_method, arg1, arg2);</span><br></pre></td></tr></table></figure>\n<p>如果 Native 想要调用 Dart代码有类似的代码可以用么？翻遍了 Flutter相关的文档，都没有找到对应的方法可以直接去调用 Dart的方法，Dart Engine内部有 <a href=\"https://github.com/dart-lang/sdk/blob/master/runtime/include/dart_api.h\">dart_api.h</a>提供了<code>Dart_invoke()</code>方法，但单纯的导入 .h文件在项目中是无法链接到对应的方法的，这也就是为什么需要导入<a href=\"https://github.com/dart-lang/sdk/tree/master/runtime/include\">ffi_runtime_lib</a>相关的文件并执行 <code>Dart_InitializeApiDL()</code>，通过动态链接使得代码能够去调用 Dart 封装的相关方法。</p>\n<p>所以参考 Dart中 <code>InitDartApiDL</code>的方法，我们先对 Dart 中的函数进行注册，传递对应方法的指针，然后在 Native 中即可调用，理论上可行，后续会补上相关  demo。<br>当然这只是一种骚操作，如果有更好的方法能够用 Native 调用 Dart 欢迎讨论。</p>\n<h2 id=\"四、总结\"><a href=\"#四、总结\" class=\"headerlink\" title=\"四、总结\"></a>四、总结</h2><p>文章记录了 Dart 同步和异步调用 Native 相关的使用，异步具体的使用比上述的代码复杂，因为需要一个中介记录异步相关的回调方法，当得到真正的结果之后，利用id查找到对应的方法再执行回调方法。FFI 在 Native中执行 dart 方法，暂时没有比较好的解决方案<br>FFI 调用可查看 <a href=\"https://github.com/VomPom/flutter_ffi_tutorial\">Demo flutter_ffi_tutorial</a></p>\n","categories":[{"name":"技术文章","slug":"technology","api":"api/categories/technology.json"}],"tags":[{"name":"Flutter","slug":"Flutter","api":"api/tags/Flutter.json"}],"api":"api/posts/2021/04/18/FlutterFFI实践.json"}],"info":{"type":"index"}},"api":"api/posts/page.3.json"}