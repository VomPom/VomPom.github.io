{"data":{"index":4,"total":8,"posts":[{"title":"Flutter坑之FlutterFragment中SafeArea失效的问题","slug":"Flutter坑之FlutterFragment中SafeArea失效的问题","date":"2020-10-31T06:40:00.000Z","updated":"2025-05-20T11:46:57.000Z","comments":true,"url":"2020/10/31/Flutter坑之FlutterFragment中SafeArea失效的问题/","excerpt":"<p>最近有在做关于Android底部多tab下，对应多个Flutter Fragment的操作。又遇到一个比较坑的问题:FlutterFragment中的flutter页面的SafeArea失效（关于safeArea具体介绍参考官方<a href=\"https://api.flutter.dev/flutter/widgets/SafeArea-class.html\">SafeArea class</a>），简单举例说一下SafeArea的作用：如果你有一刘海屏的手机，如果你的flutter内容为全屏，假如你的内容在全屏最顶部，那么所谓的刘海将会盖住你所想要的内容，如下图所示：</p>\n<img width=\"50%\" src=\"https://cdn.julis.wang/blog/img/2020110113363517.png\">\n<p>这当然不是我们想要的，于是Flutter官方推出：SafeArea这个属性，在dart语言中只需要在你的widget最外层包裹SafeArea就好了。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@override</span></span><br><span class=\"line\">Widget <span class=\"title function_\">build</span><span class=\"params\">(BuildContext context)</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> Scaffold(</span><br><span class=\"line\">    body: SafeArea(</span><br><span class=\"line\">      child: TabBarView(</span><br><span class=\"line\">        controller: mController,</span><br><span class=\"line\">        children: &lt;Widget&gt;[]</span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>于是得到了正确的展示效果，如下图所示：</p>\n<img width=\"50%\" src=\"https://cdn.julis.wang/blog/img/20201101134229321.png\">\n<p>你以为这样就完了么？在多个Flutter Fragment中SafeArea的作用失效，尽管我在flutter中设置了SafeArea，但依然存在刘海盖住flutter content的情况。</p>\n<h1 id=\"原因分析：\"><a href=\"#原因分析：\" class=\"headerlink\" title=\"原因分析：\"></a>原因分析：</h1><p>这真的是一件很头疼的事情，对应的Flutter page在Flutter Activity中能够正常work，但是偏偏在Fluttter Fragment中就出问题了呢？于是又去看FlutterView源码，果然有收获！发现一个方法：<code>onApplyWindowInsets()</code>这里面有一大堆逻辑，很多都是关于处理 statusBar以及navigationBar，更惊喜地还发现了处理<a href=\"https://developer.android.google.cn/reference/android/view/DisplayCutout?hl=zh-cn\">DisplayCutout</a>的逻辑，这不就是刘海屏相关的类么！以下是部分代码逻辑：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> WindowInsets <span class=\"title function_\">onApplyWindowInsets</span><span class=\"params\">(WindowInsets insets)</span> &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">   <span class=\"keyword\">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.R) &#123;</span><br><span class=\"line\">     <span class=\"type\">int</span> <span class=\"variable\">mask</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">     <span class=\"keyword\">if</span> (navigationBarVisible) &#123;</span><br><span class=\"line\">       mask = mask | android.view.WindowInsets.Type.navigationBars();</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">     <span class=\"keyword\">if</span> (statusBarVisible) &#123;</span><br><span class=\"line\">       mask = mask | android.view.WindowInsets.Type.statusBars();</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">     <span class=\"comment\">// TODO(garyq): Expose the full rects of the display cutout.</span></span><br><span class=\"line\">     <span class=\"comment\">// Take the max of the display cutout insets and existing padding to merge them</span></span><br><span class=\"line\">     <span class=\"type\">DisplayCutout</span> <span class=\"variable\">cutout</span> <span class=\"operator\">=</span> insets.getDisplayCutout();</span><br><span class=\"line\">     <span class=\"keyword\">if</span> (cutout != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">       <span class=\"type\">Insets</span> <span class=\"variable\">waterfallInsets</span> <span class=\"operator\">=</span> cutout.getWaterfallInsets();</span><br><span class=\"line\">       mMetrics.physicalPaddingTop =</span><br><span class=\"line\">           Math.max(</span><br><span class=\"line\">               Math.max(mMetrics.physicalPaddingTop, waterfallInsets.top),</span><br><span class=\"line\">               cutout.getSafeInsetTop());</span><br><span class=\"line\">      ...</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">   &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">     <span class=\"comment\">// Status bar (top) and left/right system insets should partially obscure the content</span></span><br><span class=\"line\">     <span class=\"comment\">// (padding).</span></span><br><span class=\"line\">   ...</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   updateViewportMetrics();</span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"built_in\">super</span>.onApplyWindowInsets(insets);</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n<p>很明显这一块逻辑是处理刘海屏以及StatusBar相关的逻辑，于是进行相关的断点调试，发现FlutterFragment中的FlutterView的确是没有执行这个方法，对比同样在FlutterActivity中的FlutterView正常work并执行了这一串代码。</p>\n<p>！那这不就神奇了么？这一下子又让人头秃了，这一定又是跟Fragment的相关机制导致的，自己对Fragment的具体处理逻辑不太熟，于是各种Google，找到两篇有点类似的答案：<br><a href=\"https://stackoverflow.com/questions/31190612/fitssystemwindows-effect-gone-for-fragments-added-via-fragmenttransaction\">1、fitsSystemWindows effect gone for fragments added via FragmentTransaction</a><br><a href=\"https://blog.csdn.net/qq_35054800/article/details/82107053?utm_source=copy\">2、一个Activity中添加多个Fragment导致fitsSystemWindows无效的问题</a></p>\n<p>引入上面的解释说：</p>\n<blockquote>\n<p>当第一个Fragment添加到Activity中的时候，Activity寻找出有fitsSystemWindows的子布局为其预留出状态栏的空间，其实就是设置一个padding，而其他Fragment添加到Activity中的时候，因为状态栏空间的适配已经被消费过一次了，Activity并不会再次去添加这个padding</p>\n</blockquote>\n<p>虽然这里在进行fitsSystemWindows的操作，但是我们明确了一件事情：添加多个Fragment的时候，Activity对于padding相关操作只在第一个Fragment进行了相关处理逻辑。那么对应我们的FlutterFragment是否是同样的问题呢？？</p>\n<p>于是我进行了尝试，将Flutter Fragment放在Acitvity第一个需要展示的Fragment，经过尝试发现第一个FlutterFragment能正常work了！但之后的Flutter Fragment问题依然存在，那么我们可以肯定也就是说：<br><strong>在多FlutterFragment中的FlutterView，只有在作为Acitivty添加为第一个Fragment的情况下才会去调用 <code> onApplyWindowInsets(WindowInsets insets)</code> 方法去处理一些statusBar相关的操作逻辑。</strong><br>的确事实如此，经过尝试之后发现的确只会调用一次，那么如何解决呢？</p>\n<h1 id=\"解决方案：\"><a href=\"#解决方案：\" class=\"headerlink\" title=\"解决方案：\"></a>解决方案：</h1><p>参照上面的解决方案，可以写一个WindowInsetsFrameLayout继承FrameLayout，并<code>setOnHierarchyChangeListener()</code>监听Fragment的添加操作，在添加的时候执行 view的requestApplyInsets();</p>\n<p>当然对于我们的问题并没有这么麻烦，我们在自己的FlutterFragment中手动去执行flutterView.requestApplyInsets();只需要执行时机保证在flutter渲染之前执行（Safe Area通过获去Native端onApplyWindowInsets()中传过去的params来执行相关渲染）</p>\n<p>但还有一个问题：<code>flutterView.requestApplyInsets();</code>只能在Api大于20中使用，那么低于20呢？与其说低于20，不如直接说，19中怎么处理（Android 4.4 api 19引入的透明状态栏 、沉浸式相关），我们可以看到，在onApplyWindowInsets() 中最终是发送一个事件到flutter端，如下代码所示。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">sendViewportMetricsToFlutter</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!isAttachedToFlutterEngine()) &#123;</span><br><span class=\"line\">    Log.w(</span><br><span class=\"line\">        TAG,</span><br><span class=\"line\">        <span class=\"string\">&quot;Tried to send viewport metrics from Android to Flutter but this &quot;</span></span><br><span class=\"line\">            + <span class=\"string\">&quot;FlutterView was not attached to a FlutterEngine.&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  viewportMetrics.devicePixelRatio = getResources().getDisplayMetrics().density;</span><br><span class=\"line\">  flutterEngine.getRenderer().setViewportMetrics(viewportMetrics);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>那么对于Api 19就可以对相关数据进行反射调用，之后再讲数据发送到flutter端即可，那么大致逻辑如下所示：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">onViewCreated</span><span class=\"params\">(<span class=\"meta\">@NonNull</span> View view, <span class=\"meta\">@Nullable</span> Bundle savedInstanceState)</span> &#123;</span><br><span class=\"line\">     <span class=\"built_in\">super</span>.onViewCreated(view, savedInstanceState);</span><br><span class=\"line\">     <span class=\"keyword\">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.KITKAT_WATCH) &#123;</span><br><span class=\"line\">         flutterView.requestApplyInsets();</span><br><span class=\"line\">     &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">         adapterStatusBarBelowApi20();</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"总结：\"><a href=\"#总结：\" class=\"headerlink\" title=\"总结：\"></a>总结：</h1><p>1、这个问题在官方的FlutterFragment中也存在，但不知道为什么没有修复，可能他们真的不太重视混合开发吧，一心在纯flutter开发中。<br>2、关于为什么Fragment 相关操作逻辑只在第一个被Fragment被添加，这里涉及到了太多底层的东西，这里没有赘述，打算深入研究，写一篇新到blog中去介绍。<br>3、Flutter坑实在是太多了，很多问题都与Android原生机制相关，这不得不让人对原生系统机制进行深入学习。</p>\n","cover":null,"images":["https://cdn.julis.wang/blog/img/2020110113363517.png","https://cdn.julis.wang/blog/img/20201101134229321.png"],"content":"<p>最近有在做关于Android底部多tab下，对应多个Flutter Fragment的操作。又遇到一个比较坑的问题:FlutterFragment中的flutter页面的SafeArea失效（关于safeArea具体介绍参考官方<a href=\"https://api.flutter.dev/flutter/widgets/SafeArea-class.html\">SafeArea class</a>），简单举例说一下SafeArea的作用：如果你有一刘海屏的手机，如果你的flutter内容为全屏，假如你的内容在全屏最顶部，那么所谓的刘海将会盖住你所想要的内容，如下图所示：</p>\n<img width=\"50%\" src=\"https://cdn.julis.wang/blog/img/2020110113363517.png\">\n<p>这当然不是我们想要的，于是Flutter官方推出：SafeArea这个属性，在dart语言中只需要在你的widget最外层包裹SafeArea就好了。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@override</span></span><br><span class=\"line\">Widget <span class=\"title function_\">build</span><span class=\"params\">(BuildContext context)</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> Scaffold(</span><br><span class=\"line\">    body: SafeArea(</span><br><span class=\"line\">      child: TabBarView(</span><br><span class=\"line\">        controller: mController,</span><br><span class=\"line\">        children: &lt;Widget&gt;[]</span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>于是得到了正确的展示效果，如下图所示：</p>\n<img width=\"50%\" src=\"https://cdn.julis.wang/blog/img/20201101134229321.png\">\n<p>你以为这样就完了么？在多个Flutter Fragment中SafeArea的作用失效，尽管我在flutter中设置了SafeArea，但依然存在刘海盖住flutter content的情况。</p>\n<h1 id=\"原因分析：\"><a href=\"#原因分析：\" class=\"headerlink\" title=\"原因分析：\"></a>原因分析：</h1><p>这真的是一件很头疼的事情，对应的Flutter page在Flutter Activity中能够正常work，但是偏偏在Fluttter Fragment中就出问题了呢？于是又去看FlutterView源码，果然有收获！发现一个方法：<code>onApplyWindowInsets()</code>这里面有一大堆逻辑，很多都是关于处理 statusBar以及navigationBar，更惊喜地还发现了处理<a href=\"https://developer.android.google.cn/reference/android/view/DisplayCutout?hl=zh-cn\">DisplayCutout</a>的逻辑，这不就是刘海屏相关的类么！以下是部分代码逻辑：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> WindowInsets <span class=\"title function_\">onApplyWindowInsets</span><span class=\"params\">(WindowInsets insets)</span> &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">   <span class=\"keyword\">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.R) &#123;</span><br><span class=\"line\">     <span class=\"type\">int</span> <span class=\"variable\">mask</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">     <span class=\"keyword\">if</span> (navigationBarVisible) &#123;</span><br><span class=\"line\">       mask = mask | android.view.WindowInsets.Type.navigationBars();</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">     <span class=\"keyword\">if</span> (statusBarVisible) &#123;</span><br><span class=\"line\">       mask = mask | android.view.WindowInsets.Type.statusBars();</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">     <span class=\"comment\">// TODO(garyq): Expose the full rects of the display cutout.</span></span><br><span class=\"line\">     <span class=\"comment\">// Take the max of the display cutout insets and existing padding to merge them</span></span><br><span class=\"line\">     <span class=\"type\">DisplayCutout</span> <span class=\"variable\">cutout</span> <span class=\"operator\">=</span> insets.getDisplayCutout();</span><br><span class=\"line\">     <span class=\"keyword\">if</span> (cutout != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">       <span class=\"type\">Insets</span> <span class=\"variable\">waterfallInsets</span> <span class=\"operator\">=</span> cutout.getWaterfallInsets();</span><br><span class=\"line\">       mMetrics.physicalPaddingTop =</span><br><span class=\"line\">           Math.max(</span><br><span class=\"line\">               Math.max(mMetrics.physicalPaddingTop, waterfallInsets.top),</span><br><span class=\"line\">               cutout.getSafeInsetTop());</span><br><span class=\"line\">      ...</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">   &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">     <span class=\"comment\">// Status bar (top) and left/right system insets should partially obscure the content</span></span><br><span class=\"line\">     <span class=\"comment\">// (padding).</span></span><br><span class=\"line\">   ...</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   updateViewportMetrics();</span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"built_in\">super</span>.onApplyWindowInsets(insets);</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n<p>很明显这一块逻辑是处理刘海屏以及StatusBar相关的逻辑，于是进行相关的断点调试，发现FlutterFragment中的FlutterView的确是没有执行这个方法，对比同样在FlutterActivity中的FlutterView正常work并执行了这一串代码。</p>\n<p>！那这不就神奇了么？这一下子又让人头秃了，这一定又是跟Fragment的相关机制导致的，自己对Fragment的具体处理逻辑不太熟，于是各种Google，找到两篇有点类似的答案：<br><a href=\"https://stackoverflow.com/questions/31190612/fitssystemwindows-effect-gone-for-fragments-added-via-fragmenttransaction\">1、fitsSystemWindows effect gone for fragments added via FragmentTransaction</a><br><a href=\"https://blog.csdn.net/qq_35054800/article/details/82107053?utm_source=copy\">2、一个Activity中添加多个Fragment导致fitsSystemWindows无效的问题</a></p>\n<p>引入上面的解释说：</p>\n<blockquote>\n<p>当第一个Fragment添加到Activity中的时候，Activity寻找出有fitsSystemWindows的子布局为其预留出状态栏的空间，其实就是设置一个padding，而其他Fragment添加到Activity中的时候，因为状态栏空间的适配已经被消费过一次了，Activity并不会再次去添加这个padding</p>\n</blockquote>\n<p>虽然这里在进行fitsSystemWindows的操作，但是我们明确了一件事情：添加多个Fragment的时候，Activity对于padding相关操作只在第一个Fragment进行了相关处理逻辑。那么对应我们的FlutterFragment是否是同样的问题呢？？</p>\n<p>于是我进行了尝试，将Flutter Fragment放在Acitvity第一个需要展示的Fragment，经过尝试发现第一个FlutterFragment能正常work了！但之后的Flutter Fragment问题依然存在，那么我们可以肯定也就是说：<br><strong>在多FlutterFragment中的FlutterView，只有在作为Acitivty添加为第一个Fragment的情况下才会去调用 <code> onApplyWindowInsets(WindowInsets insets)</code> 方法去处理一些statusBar相关的操作逻辑。</strong><br>的确事实如此，经过尝试之后发现的确只会调用一次，那么如何解决呢？</p>\n<h1 id=\"解决方案：\"><a href=\"#解决方案：\" class=\"headerlink\" title=\"解决方案：\"></a>解决方案：</h1><p>参照上面的解决方案，可以写一个WindowInsetsFrameLayout继承FrameLayout，并<code>setOnHierarchyChangeListener()</code>监听Fragment的添加操作，在添加的时候执行 view的requestApplyInsets();</p>\n<p>当然对于我们的问题并没有这么麻烦，我们在自己的FlutterFragment中手动去执行flutterView.requestApplyInsets();只需要执行时机保证在flutter渲染之前执行（Safe Area通过获去Native端onApplyWindowInsets()中传过去的params来执行相关渲染）</p>\n<p>但还有一个问题：<code>flutterView.requestApplyInsets();</code>只能在Api大于20中使用，那么低于20呢？与其说低于20，不如直接说，19中怎么处理（Android 4.4 api 19引入的透明状态栏 、沉浸式相关），我们可以看到，在onApplyWindowInsets() 中最终是发送一个事件到flutter端，如下代码所示。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">sendViewportMetricsToFlutter</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!isAttachedToFlutterEngine()) &#123;</span><br><span class=\"line\">    Log.w(</span><br><span class=\"line\">        TAG,</span><br><span class=\"line\">        <span class=\"string\">&quot;Tried to send viewport metrics from Android to Flutter but this &quot;</span></span><br><span class=\"line\">            + <span class=\"string\">&quot;FlutterView was not attached to a FlutterEngine.&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  viewportMetrics.devicePixelRatio = getResources().getDisplayMetrics().density;</span><br><span class=\"line\">  flutterEngine.getRenderer().setViewportMetrics(viewportMetrics);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>那么对于Api 19就可以对相关数据进行反射调用，之后再讲数据发送到flutter端即可，那么大致逻辑如下所示：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">onViewCreated</span><span class=\"params\">(<span class=\"meta\">@NonNull</span> View view, <span class=\"meta\">@Nullable</span> Bundle savedInstanceState)</span> &#123;</span><br><span class=\"line\">     <span class=\"built_in\">super</span>.onViewCreated(view, savedInstanceState);</span><br><span class=\"line\">     <span class=\"keyword\">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.KITKAT_WATCH) &#123;</span><br><span class=\"line\">         flutterView.requestApplyInsets();</span><br><span class=\"line\">     &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">         adapterStatusBarBelowApi20();</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"总结：\"><a href=\"#总结：\" class=\"headerlink\" title=\"总结：\"></a>总结：</h1><p>1、这个问题在官方的FlutterFragment中也存在，但不知道为什么没有修复，可能他们真的不太重视混合开发吧，一心在纯flutter开发中。<br>2、关于为什么Fragment 相关操作逻辑只在第一个被Fragment被添加，这里涉及到了太多底层的东西，这里没有赘述，打算深入研究，写一篇新到blog中去介绍。<br>3、Flutter坑实在是太多了，很多问题都与Android原生机制相关，这不得不让人对原生系统机制进行深入学习。</p>\n","categories":[{"name":"技术文章","slug":"technology","api":"api/categories/technology.json"}],"tags":[{"name":"Flutter","slug":"Flutter","api":"api/tags/Flutter.json"}],"api":"api/posts/2020/10/31/Flutter坑之FlutterFragment中SafeArea失效的问题.json"},{"title":"Flutter坑之共享FlutterEngine页面切换无法点击","slug":"Flutter坑之共享FlutterEngine页面切换无法点击","date":"2020-09-21T11:22:00.000Z","updated":"2025-05-20T11:46:57.000Z","comments":true,"url":"2020/09/21/Flutter坑之共享FlutterEngine页面切换无法点击/","excerpt":"<p>最近在研究做Flutter一块相关的内容，方案上采用的是单FlutterEngine，全局Flutter元素共用一个FlutterEngine，对于使用单Engine遇到一个很大的坑，页面切换之后无法点击，页面就像卡死了一样，以下三种情况都会发生：</p>\n<p>第一种：两个FlutterFragment在tab中进行切换，假如AB代表两个FlutterFragment，当A切换到B，再从B切换到A的时候，页面就无法点击。</p>\n<p>第二种：在FlutterActivity中打开新的FlutterActivity，新的FlutterActivity页面跟上述的情况一样，也是无法点击。</p>\n<p>第三种：在Tab中打开FlutterFragment之后再打开FlutterActivity，情况一样，依然无法点击。</p>\n<p>如下动图所示：</p>\n<img src=\"https://cdn.julis.wang/blog/img/20200921223629331.gif\">\n<p>（来自issue <a href=\"https://github.com/flutter/flutter/issues/49950%EF%BC%89\">https://github.com/flutter/flutter/issues/49950）</a></p>\n<p>但他们有一个共同的特点：当页面卡死的时候，手动进入后台（打开任务管理或者home键退出）再回到前台，页面就会“刷新”，一切又变得正常了。那么推测：多半与跟页面Fragment和Activity的生命周期有关。我尝试了在进入页面后,再手动模拟“页面退出再回来的周期”，也就是先调用一次<code>onPause()</code>再调用一次<code>onResume()</code>，然而并没有什么卵用……</p>\n<img src=\"https://cdn.julis.wang/blog/img/20200921223648282.gif\">\n<p>可这是为什么呢？？太坑了……踏遍了千山万水也没有找到有人有解决方案，很多人都说别用共享引擎，但是想到 闲鱼Flutter_boost 和HelloBike的thrio框架也都是用的共享引擎啊，他们为什么没有问题？找了很久的解决方法，两天，甚至晚上做梦都梦在关于这个问题。真的是……难受。加了各种各样的群，也没有人能解答这个问题。终于……我去打印了两个Activity的生命周期，才发现事情的端倪。</p>\n<h3 id=\"关于Activity与Fragment的切换的生命周期\"><a href=\"#关于Activity与Fragment的切换的生命周期\" class=\"headerlink\" title=\"关于Activity与Fragment的切换的生命周期\"></a><strong>关于Activity与Fragment的切换的生命周期</strong></h3><p>这里向大家在简单介绍一下Activity和Fragment切换生命周期，相信大家都有被面试问过：现在有两个Activity A和B，在A打开B这一段时间Activity的生命周期变化情况：</p>\n<h6 id=\"A-onPause-B-onCreate-B-onStart-B-onResume-A-onStop\"><a href=\"#A-onPause-B-onCreate-B-onStart-B-onResume-A-onStop\" class=\"headerlink\" title=\"A.onPause() -&gt;B.onCreate()-&gt; B.onStart() -&gt;B.onResume() -&gt;A.onStop()\"></a>A.onPause() -&gt;B.onCreate()-&gt; B.onStart() -&gt;B.onResume() -&gt;A.onStop()</h6><p>A的onStop() 的调用情况分为两种：当设置Activity A的主题windowIsTranslucent属性为true，A Activity并不会调用onStop方法，只会调用onPause()方法。</p>\n<p>ok说完了Activity再说说Fragment，对于我们的问题：Fragment生命周期考虑tab间切换（也就是两个FlutterFragment之间的切换），两个Fragment的切换，并不会导致Fragment的onPause()和onStop()调用，只会调用<code>onHiddenChanged(boolean hidden)</code>，hiden为true表示该Fragment被隐藏了，false表示当前Fragment可见。</p>\n<h3 id=\"关于Flutter单Engine方案\"><a href=\"#关于Flutter单Engine方案\" class=\"headerlink\" title=\"关于Flutter单Engine方案\"></a><strong>关于Flutter单Engine方案</strong></h3><p>现在关于讲解Flutter单Engine方案也比较多，推荐去看这篇–&gt; <a href=\"https://zhuanlan.zhihu.com/p/38026271\">为追求高性能，我必须告诉你Flutter引擎线程的事实…</a> 关于对单Engine的讲解，单Engine方案，我们可以简单理解为：**所有应用中的FlutterView都是由同一个FlutterEngine来渲染的。**当然这看起来是废话，但这就是问题的关键，那么对于所有的FlutterView都是用的同一个FlutterEngine渲染，那么FlutterEngine是怎么去控制的呢？如果让你去设计，你会怎么设计呢？</p>\n<p>这篇博客–&gt;<a href=\"https://cloud.tencent.com/developer/article/1568737\">flutter单引擎方案</a>讲解了一种单Engine的实现方案，可以参考，不过其中也需要对Engine进行多次new，不过这并不是最重要的，我们需要明白的是：<strong>当FlutterEngine去渲染FlutterView B的时候，它需要attach再在B上，从FlutterView A detach掉，再返回FlutterView A的时候，它需要从FlutterView B上detach掉，再attach到A上。</strong></p>\n<h3 id=\"Flutter坑！\"><a href=\"#Flutter坑！\" class=\"headerlink\" title=\"Flutter坑！\"></a><strong>Flutter坑！</strong></h3><p>现在我们明白了生命周期的变化，我们接下来去看FlutterActivity中响应生命周期中的源码。对于FlutterActivity A打开FlutterActivity B，他们依次会调用：</p>\n<h6 id=\"A-onPause-B-onCreate-B-onStart-B-onResume-A-onStop-1\"><a href=\"#A-onPause-B-onCreate-B-onStart-B-onResume-A-onStop-1\" class=\"headerlink\" title=\"A.onPause() -&gt;B.onCreate()-&gt; B.onStart() -&gt;B.onResume() -&gt;A.onStop()\"></a>A.onPause() -&gt;B.onCreate()-&gt; B.onStart() -&gt;B.onResume() -&gt;A.onStop()</h6><p>我们来看看FlutterActivity在对应的生命周期里面做了什么,</p>\n<p>对于<strong>A.onPause()</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title function_\">onPause</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">super</span>.onPause();</span><br><span class=\"line\">  delegate.onPause();</span><br><span class=\"line\">  lifecycle.handleLifecycleEvent(Lifecycle.Event.ON_PAUSE);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们知道：FlutterActivity和Fragment主要由FlutterActivityAndFragmentDelegate来进行管理，这里我们主要关注delegate里面的内容</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> <span class=\"title function_\">onPause</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">  Log.v(TAG, <span class=\"string\">&quot;onPause()&quot;</span>);</span><br><span class=\"line\">  ensureAlive();</span><br><span class=\"line\">  flutterEngine.getLifecycleChannel().appIsInactive();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里是关键我们看到了flutterEngine与生命周期相关的代码，接下来我们看其他几个生命周期里面对于flutterEngine的Lifecycle管理情况</p>\n<p>对于**B.onCreate()**只进行了相关的view创建工作.</p>\n<p>对于**B.onStart()**中有执行<code>doInitialFlutterViewRun();</code>，其中比较关键的一句就是：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">if (host.getInitialRoute() != null) &#123;</span><br><span class=\"line\">  flutterEngine.getNavigationChannel().setInitialRoute(host.getInitialRoute());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>对于<strong>B.onResume()</strong> </p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> <span class=\"title function_\">onResume</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">  Log.v(TAG, <span class=\"string\">&quot;onResume()&quot;</span>);</span><br><span class=\"line\">  ensureAlive();</span><br><span class=\"line\">  flutterEngine.getLifecycleChannel().appIsResumed();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>最后是<strong>A.onStop()</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> <span class=\"title function_\">onStop</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">  Log.v(TAG, <span class=\"string\">&quot;onStop()&quot;</span>);</span><br><span class=\"line\">  ensureAlive();</span><br><span class=\"line\">  flutterEngine.getLifecycleChannel().appIsPaused();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>看到了A.onStop()，聪明的人应该都看出来问题了，我们重新整理一下从Activity A启动到B，flutterEngine相关的生命周期主要执行了以下流程：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">A.onPause() -&gt; flutterEngine.getLifecycleChannel().appIsInactive()</span><br><span class=\"line\"></span><br><span class=\"line\">B.onCreate()-&gt;  nothing.</span><br><span class=\"line\"></span><br><span class=\"line\">B.onStart() -&gt; flutterEngine.getNavigationChannel().setInitialRoute(host.getInitialRoute());</span><br><span class=\"line\"></span><br><span class=\"line\">B.onResume() -&gt; flutterEngine.getLifecycleChannel().appIsResumed();</span><br><span class=\"line\"></span><br><span class=\"line\">A.onStop()-&gt; flutterEngine.getLifecycleChannel().appIsPaused();</span><br></pre></td></tr></table></figure>\n\n<p>其实问题已经出来了：<strong>由于我们使用的是单FlutterEngine方案，那么上面生命周期中的flutterEngine为同一实例！</strong>，由于Activity的生命周期机制，前一个Activity的生命周期的onStop是在最后调用的，也就是这时候告诉了FlutterEngine: 这时候appIsPaused，你不用在渲染了，那么这时页面就会成一种“卡死”的状态！正常的生命周期这时候FlutterEngine应该是appIsResumed()。这也就能解释为什么退出到后台（调用了onPause()）再回来（调用onResume()）最终的FlutterEngine是调用了.appIsResumed();显示正常。</p>\n<p>于是找到问题了，那么如何解决呢？这还不简单，当然是去绕过不用去调用A.onStop()呀！怎么可能不用调用A.onStop() 呢？错了，不用去调用其中的delegate中的flutterEngine.getLifecycleChannel().appIsPaused();就好了，我这边的方案与Flutter_boost的方案一样，也对FlutterActivty的代码进行了重写，所以能比较灵活的去改动FlutterActivityAndFragmentDelegate。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> <span class=\"title function_\">onStop</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">  Log.v(TAG, <span class=\"string\">&quot;onStop()&quot;</span>);</span><br><span class=\"line\">  ensureAlive();</span><br><span class=\"line\">  <span class=\"comment\">// flutterEngine.getLifecycleChannel().appIsPaused();</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>对于Fragment的切换也是同样一个思路，就留着大家想一下吧。</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a><strong>总结</strong></h3><p>1、Activity A切换到B的生命周期（A不透明的情况下）：A.onPause() -&gt;B.onCreate()-&gt; B.onStart() -&gt;B.onResume() -&gt;A.onStop()</p>\n<p>2、至于flutterEngine.getLifecycleChannel().appIsPaused();内部具体做了什么事，还得具体去研究一下，字面上理解就是。</p>\n<p>3、Flutter混合原生做开发坑实在是太多了，官方也没有做相应的解决方案，有什么问题，一定要大胆的想，大胆的去尝试！</p>\n","cover":null,"images":["https://cdn.julis.wang/blog/img/20200921223629331.gif","https://cdn.julis.wang/blog/img/20200921223648282.gif"],"content":"<p>最近在研究做Flutter一块相关的内容，方案上采用的是单FlutterEngine，全局Flutter元素共用一个FlutterEngine，对于使用单Engine遇到一个很大的坑，页面切换之后无法点击，页面就像卡死了一样，以下三种情况都会发生：</p>\n<p>第一种：两个FlutterFragment在tab中进行切换，假如AB代表两个FlutterFragment，当A切换到B，再从B切换到A的时候，页面就无法点击。</p>\n<p>第二种：在FlutterActivity中打开新的FlutterActivity，新的FlutterActivity页面跟上述的情况一样，也是无法点击。</p>\n<p>第三种：在Tab中打开FlutterFragment之后再打开FlutterActivity，情况一样，依然无法点击。</p>\n<p>如下动图所示：</p>\n<img src=\"https://cdn.julis.wang/blog/img/20200921223629331.gif\">\n<p>（来自issue <a href=\"https://github.com/flutter/flutter/issues/49950%EF%BC%89\">https://github.com/flutter/flutter/issues/49950）</a></p>\n<p>但他们有一个共同的特点：当页面卡死的时候，手动进入后台（打开任务管理或者home键退出）再回到前台，页面就会“刷新”，一切又变得正常了。那么推测：多半与跟页面Fragment和Activity的生命周期有关。我尝试了在进入页面后,再手动模拟“页面退出再回来的周期”，也就是先调用一次<code>onPause()</code>再调用一次<code>onResume()</code>，然而并没有什么卵用……</p>\n<img src=\"https://cdn.julis.wang/blog/img/20200921223648282.gif\">\n<p>可这是为什么呢？？太坑了……踏遍了千山万水也没有找到有人有解决方案，很多人都说别用共享引擎，但是想到 闲鱼Flutter_boost 和HelloBike的thrio框架也都是用的共享引擎啊，他们为什么没有问题？找了很久的解决方法，两天，甚至晚上做梦都梦在关于这个问题。真的是……难受。加了各种各样的群，也没有人能解答这个问题。终于……我去打印了两个Activity的生命周期，才发现事情的端倪。</p>\n<h3 id=\"关于Activity与Fragment的切换的生命周期\"><a href=\"#关于Activity与Fragment的切换的生命周期\" class=\"headerlink\" title=\"关于Activity与Fragment的切换的生命周期\"></a><strong>关于Activity与Fragment的切换的生命周期</strong></h3><p>这里向大家在简单介绍一下Activity和Fragment切换生命周期，相信大家都有被面试问过：现在有两个Activity A和B，在A打开B这一段时间Activity的生命周期变化情况：</p>\n<h6 id=\"A-onPause-B-onCreate-B-onStart-B-onResume-A-onStop\"><a href=\"#A-onPause-B-onCreate-B-onStart-B-onResume-A-onStop\" class=\"headerlink\" title=\"A.onPause() -&gt;B.onCreate()-&gt; B.onStart() -&gt;B.onResume() -&gt;A.onStop()\"></a>A.onPause() -&gt;B.onCreate()-&gt; B.onStart() -&gt;B.onResume() -&gt;A.onStop()</h6><p>A的onStop() 的调用情况分为两种：当设置Activity A的主题windowIsTranslucent属性为true，A Activity并不会调用onStop方法，只会调用onPause()方法。</p>\n<p>ok说完了Activity再说说Fragment，对于我们的问题：Fragment生命周期考虑tab间切换（也就是两个FlutterFragment之间的切换），两个Fragment的切换，并不会导致Fragment的onPause()和onStop()调用，只会调用<code>onHiddenChanged(boolean hidden)</code>，hiden为true表示该Fragment被隐藏了，false表示当前Fragment可见。</p>\n<h3 id=\"关于Flutter单Engine方案\"><a href=\"#关于Flutter单Engine方案\" class=\"headerlink\" title=\"关于Flutter单Engine方案\"></a><strong>关于Flutter单Engine方案</strong></h3><p>现在关于讲解Flutter单Engine方案也比较多，推荐去看这篇–&gt; <a href=\"https://zhuanlan.zhihu.com/p/38026271\">为追求高性能，我必须告诉你Flutter引擎线程的事实…</a> 关于对单Engine的讲解，单Engine方案，我们可以简单理解为：**所有应用中的FlutterView都是由同一个FlutterEngine来渲染的。**当然这看起来是废话，但这就是问题的关键，那么对于所有的FlutterView都是用的同一个FlutterEngine渲染，那么FlutterEngine是怎么去控制的呢？如果让你去设计，你会怎么设计呢？</p>\n<p>这篇博客–&gt;<a href=\"https://cloud.tencent.com/developer/article/1568737\">flutter单引擎方案</a>讲解了一种单Engine的实现方案，可以参考，不过其中也需要对Engine进行多次new，不过这并不是最重要的，我们需要明白的是：<strong>当FlutterEngine去渲染FlutterView B的时候，它需要attach再在B上，从FlutterView A detach掉，再返回FlutterView A的时候，它需要从FlutterView B上detach掉，再attach到A上。</strong></p>\n<h3 id=\"Flutter坑！\"><a href=\"#Flutter坑！\" class=\"headerlink\" title=\"Flutter坑！\"></a><strong>Flutter坑！</strong></h3><p>现在我们明白了生命周期的变化，我们接下来去看FlutterActivity中响应生命周期中的源码。对于FlutterActivity A打开FlutterActivity B，他们依次会调用：</p>\n<h6 id=\"A-onPause-B-onCreate-B-onStart-B-onResume-A-onStop-1\"><a href=\"#A-onPause-B-onCreate-B-onStart-B-onResume-A-onStop-1\" class=\"headerlink\" title=\"A.onPause() -&gt;B.onCreate()-&gt; B.onStart() -&gt;B.onResume() -&gt;A.onStop()\"></a>A.onPause() -&gt;B.onCreate()-&gt; B.onStart() -&gt;B.onResume() -&gt;A.onStop()</h6><p>我们来看看FlutterActivity在对应的生命周期里面做了什么,</p>\n<p>对于<strong>A.onPause()</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title function_\">onPause</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">super</span>.onPause();</span><br><span class=\"line\">  delegate.onPause();</span><br><span class=\"line\">  lifecycle.handleLifecycleEvent(Lifecycle.Event.ON_PAUSE);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们知道：FlutterActivity和Fragment主要由FlutterActivityAndFragmentDelegate来进行管理，这里我们主要关注delegate里面的内容</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> <span class=\"title function_\">onPause</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">  Log.v(TAG, <span class=\"string\">&quot;onPause()&quot;</span>);</span><br><span class=\"line\">  ensureAlive();</span><br><span class=\"line\">  flutterEngine.getLifecycleChannel().appIsInactive();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里是关键我们看到了flutterEngine与生命周期相关的代码，接下来我们看其他几个生命周期里面对于flutterEngine的Lifecycle管理情况</p>\n<p>对于**B.onCreate()**只进行了相关的view创建工作.</p>\n<p>对于**B.onStart()**中有执行<code>doInitialFlutterViewRun();</code>，其中比较关键的一句就是：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">if (host.getInitialRoute() != null) &#123;</span><br><span class=\"line\">  flutterEngine.getNavigationChannel().setInitialRoute(host.getInitialRoute());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>对于<strong>B.onResume()</strong> </p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> <span class=\"title function_\">onResume</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">  Log.v(TAG, <span class=\"string\">&quot;onResume()&quot;</span>);</span><br><span class=\"line\">  ensureAlive();</span><br><span class=\"line\">  flutterEngine.getLifecycleChannel().appIsResumed();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>最后是<strong>A.onStop()</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> <span class=\"title function_\">onStop</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">  Log.v(TAG, <span class=\"string\">&quot;onStop()&quot;</span>);</span><br><span class=\"line\">  ensureAlive();</span><br><span class=\"line\">  flutterEngine.getLifecycleChannel().appIsPaused();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>看到了A.onStop()，聪明的人应该都看出来问题了，我们重新整理一下从Activity A启动到B，flutterEngine相关的生命周期主要执行了以下流程：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">A.onPause() -&gt; flutterEngine.getLifecycleChannel().appIsInactive()</span><br><span class=\"line\"></span><br><span class=\"line\">B.onCreate()-&gt;  nothing.</span><br><span class=\"line\"></span><br><span class=\"line\">B.onStart() -&gt; flutterEngine.getNavigationChannel().setInitialRoute(host.getInitialRoute());</span><br><span class=\"line\"></span><br><span class=\"line\">B.onResume() -&gt; flutterEngine.getLifecycleChannel().appIsResumed();</span><br><span class=\"line\"></span><br><span class=\"line\">A.onStop()-&gt; flutterEngine.getLifecycleChannel().appIsPaused();</span><br></pre></td></tr></table></figure>\n\n<p>其实问题已经出来了：<strong>由于我们使用的是单FlutterEngine方案，那么上面生命周期中的flutterEngine为同一实例！</strong>，由于Activity的生命周期机制，前一个Activity的生命周期的onStop是在最后调用的，也就是这时候告诉了FlutterEngine: 这时候appIsPaused，你不用在渲染了，那么这时页面就会成一种“卡死”的状态！正常的生命周期这时候FlutterEngine应该是appIsResumed()。这也就能解释为什么退出到后台（调用了onPause()）再回来（调用onResume()）最终的FlutterEngine是调用了.appIsResumed();显示正常。</p>\n<p>于是找到问题了，那么如何解决呢？这还不简单，当然是去绕过不用去调用A.onStop()呀！怎么可能不用调用A.onStop() 呢？错了，不用去调用其中的delegate中的flutterEngine.getLifecycleChannel().appIsPaused();就好了，我这边的方案与Flutter_boost的方案一样，也对FlutterActivty的代码进行了重写，所以能比较灵活的去改动FlutterActivityAndFragmentDelegate。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> <span class=\"title function_\">onStop</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">  Log.v(TAG, <span class=\"string\">&quot;onStop()&quot;</span>);</span><br><span class=\"line\">  ensureAlive();</span><br><span class=\"line\">  <span class=\"comment\">// flutterEngine.getLifecycleChannel().appIsPaused();</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>对于Fragment的切换也是同样一个思路，就留着大家想一下吧。</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a><strong>总结</strong></h3><p>1、Activity A切换到B的生命周期（A不透明的情况下）：A.onPause() -&gt;B.onCreate()-&gt; B.onStart() -&gt;B.onResume() -&gt;A.onStop()</p>\n<p>2、至于flutterEngine.getLifecycleChannel().appIsPaused();内部具体做了什么事，还得具体去研究一下，字面上理解就是。</p>\n<p>3、Flutter混合原生做开发坑实在是太多了，官方也没有做相应的解决方案，有什么问题，一定要大胆的想，大胆的去尝试！</p>\n","categories":[{"name":"技术文章","slug":"technology","api":"api/categories/technology.json"}],"tags":[{"name":"Flutter","slug":"Flutter","api":"api/tags/Flutter.json"}],"api":"api/posts/2020/09/21/Flutter坑之共享FlutterEngine页面切换无法点击.json"},{"title":"从Android返回键退出和直接杀死进程退出说起","slug":"从Android返回键退出和直接杀死进程退出说起","date":"2020-09-09T01:31:00.000Z","updated":"2025-05-20T11:46:57.000Z","comments":true,"url":"2020/09/09/从Android返回键退出和直接杀死进程退出说起/","excerpt":"<p>最近开发的时候，使用了一个单例模式，当我返回键退出App，再重新启动，发现App的确是从首页启动，但还没有执行为单例类设置数值的位置。可是！断点调试的时候发现这时候已经有了一个数据，并且是上一次运行留下的数据，当时觉得很神奇，明明根Activity已经执行了OnDestroy()，而且再启动的确是从首页过来的，讲道理应该是“everything will be new”，但是单例里面的数据仍然存在，这可是为什么呢？</p>\n<p>Google搜了一下，噢！恍然大悟，看到这一块的知识很久没有用就忘掉了，或者说对运行机制相关还不太熟悉吧，所以在此重新整理总结一份。</p>\n<h4 id=\"返回键退出和直接杀死进程退出的区别？\"><a href=\"#返回键退出和直接杀死进程退出的区别？\" class=\"headerlink\" title=\"返回键退出和直接杀死进程退出的区别？\"></a>返回键退出和直接杀死进程退出的区别？</h4><p><strong>直接杀死退出</strong>：所有的内存都会被回收，重新启动应用程序时，会重新调用Application的<code>OnCreate()</code>方法，会调用onSaveInstanceState方法。</p>\n<p><strong>返回键退出程序</strong>：退出程序后，一些加载过的静态变量并没有被回收，重新启动也不需要调用Application的OnCreate()方法。</p>\n<p>于是我们就知道，静态变量并没有被回收，而我们的单例模式实例就是静态变量，没有被回收，于是我们就知道为什么单例模式数据还存在了，于是在响应的位置对其数据进行释放。可是 why？这两者的差异究竟是什么导致的？我们要知其然，也要知其所以然。</p>\n<h4 id=\"关于直接杀死进程\"><a href=\"#关于直接杀死进程\" class=\"headerlink\" title=\"关于直接杀死进程\"></a>关于直接杀死进程</h4><p>这里我们应该很好去理解，Android中的每一个App都是运行在自己VM实例之中(沙盒)。每一个VM实例在linux中又是一个单独的进程，通过任务管理杀掉一个进程，那么对应进程里面的数据全部被回收掉。</p>\n<h4 id=\"关于返回键退出\"><a href=\"#关于返回键退出\" class=\"headerlink\" title=\"关于返回键退出\"></a>关于返回键退出</h4><p>通过对源码的追溯，如果不对onBackPressed()做特殊的处理，无论是AppCompatActivity还是android.app.Activity，发现都会通过执行onBackPressed(),最后到Activity的finish()方法，也就是说当App退出到根的时候，最终只是执行的是当前App根Activity的finish()方法，整个App“依然在运行”，只是看不到界面了，那么也就是说，如果在App中运行的Service之类的后台任务并没结束，仍然在运行。</p>\n<p>那为什么单例模里面的静态变量没有回收呢？如果问你的话，你怎么答？emmmmm……因为……它没有被销毁嘛，所以它还在。当然不能这么回答了，需要用理论依据来解释。</p>\n<h4 id=\"关于方法区与静态变量\"><a href=\"#关于方法区与静态变量\" class=\"headerlink\" title=\"关于方法区与静态变量\"></a>关于方法区与静态变量</h4><p>我们知道静态变量存在与JVM的方法区中，静态变量在类被加载的时候分配内存，Java虚拟机规范中说过可以不要求虚拟机在方法区实现垃圾收集，如下图所示：</p>\n<img src=\"https://cdn.julis.wang/blog/img/20200908231258604.png\">\n<p>那么我们是不是可以理解为方法区中不会进行垃圾回收？查到来自《深入理解Java虚拟机》中的解释：</p>\n<blockquote>\n<p>很多人以为方法区（或者HotSopt 虚拟机中的永久代）是没有垃圾收集的，Java虚拟机规范中确实说过可以不要求虚拟机在方法区实现垃圾收集，而且性价比一般较低，在对的新生代生一般能回收70%~95%的空间，而永久代远低于此。</p>\n<p>永久代的垃圾手机主要回收两部分内容：<strong>废弃常量</strong>和<strong>无用的类</strong>。 回收废弃常量与回收Java堆中的对象非常相似。以常量池中字面量的回收为例，若字符串“abc”已经进入常量池中，但当前系统没有任何String对象引用常量池中的“abc”常量，也没有其他地方引用该字面量，若发生内存回收，且必要的话，该“abc”就会被系统清理出常量池。常量池中其他的类（接口）、方法、字段的符号引用与此类似。</p>\n<p>无用的类需要满足3个条件：</p>\n<p>（1）该类所有的实例都已经被回收，即Java堆中不存在该类的任何实例；<br>（2）加载该类的ClassLoader已经被回收；<br>（3）该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</p>\n</blockquote>\n<p>那么对于我们的静态变量来说，如果不是我们手动处理的话设置实例为null的话，或其他操作的话，那么就不会满足上面的条件。那么静态变量会在什么时候被销毁呢？答案很简单了就：**静态变量在类被卸载的时候销毁，类在什么时候被卸载？在进程结束的时候。**那么这也自然能解释我最开始遇到的情况了，返回键返回结束App后进程并没有结束，当下一次再启动App的时候，进程并没有销毁而，因是同一个进程，所以单例中的数据依然存在。</p>\n","cover":null,"images":["https://cdn.julis.wang/blog/img/20200908231258604.png"],"content":"<p>最近开发的时候，使用了一个单例模式，当我返回键退出App，再重新启动，发现App的确是从首页启动，但还没有执行为单例类设置数值的位置。可是！断点调试的时候发现这时候已经有了一个数据，并且是上一次运行留下的数据，当时觉得很神奇，明明根Activity已经执行了OnDestroy()，而且再启动的确是从首页过来的，讲道理应该是“everything will be new”，但是单例里面的数据仍然存在，这可是为什么呢？</p>\n<p>Google搜了一下，噢！恍然大悟，看到这一块的知识很久没有用就忘掉了，或者说对运行机制相关还不太熟悉吧，所以在此重新整理总结一份。</p>\n<h4 id=\"返回键退出和直接杀死进程退出的区别？\"><a href=\"#返回键退出和直接杀死进程退出的区别？\" class=\"headerlink\" title=\"返回键退出和直接杀死进程退出的区别？\"></a>返回键退出和直接杀死进程退出的区别？</h4><p><strong>直接杀死退出</strong>：所有的内存都会被回收，重新启动应用程序时，会重新调用Application的<code>OnCreate()</code>方法，会调用onSaveInstanceState方法。</p>\n<p><strong>返回键退出程序</strong>：退出程序后，一些加载过的静态变量并没有被回收，重新启动也不需要调用Application的OnCreate()方法。</p>\n<p>于是我们就知道，静态变量并没有被回收，而我们的单例模式实例就是静态变量，没有被回收，于是我们就知道为什么单例模式数据还存在了，于是在响应的位置对其数据进行释放。可是 why？这两者的差异究竟是什么导致的？我们要知其然，也要知其所以然。</p>\n<h4 id=\"关于直接杀死进程\"><a href=\"#关于直接杀死进程\" class=\"headerlink\" title=\"关于直接杀死进程\"></a>关于直接杀死进程</h4><p>这里我们应该很好去理解，Android中的每一个App都是运行在自己VM实例之中(沙盒)。每一个VM实例在linux中又是一个单独的进程，通过任务管理杀掉一个进程，那么对应进程里面的数据全部被回收掉。</p>\n<h4 id=\"关于返回键退出\"><a href=\"#关于返回键退出\" class=\"headerlink\" title=\"关于返回键退出\"></a>关于返回键退出</h4><p>通过对源码的追溯，如果不对onBackPressed()做特殊的处理，无论是AppCompatActivity还是android.app.Activity，发现都会通过执行onBackPressed(),最后到Activity的finish()方法，也就是说当App退出到根的时候，最终只是执行的是当前App根Activity的finish()方法，整个App“依然在运行”，只是看不到界面了，那么也就是说，如果在App中运行的Service之类的后台任务并没结束，仍然在运行。</p>\n<p>那为什么单例模里面的静态变量没有回收呢？如果问你的话，你怎么答？emmmmm……因为……它没有被销毁嘛，所以它还在。当然不能这么回答了，需要用理论依据来解释。</p>\n<h4 id=\"关于方法区与静态变量\"><a href=\"#关于方法区与静态变量\" class=\"headerlink\" title=\"关于方法区与静态变量\"></a>关于方法区与静态变量</h4><p>我们知道静态变量存在与JVM的方法区中，静态变量在类被加载的时候分配内存，Java虚拟机规范中说过可以不要求虚拟机在方法区实现垃圾收集，如下图所示：</p>\n<img src=\"https://cdn.julis.wang/blog/img/20200908231258604.png\">\n<p>那么我们是不是可以理解为方法区中不会进行垃圾回收？查到来自《深入理解Java虚拟机》中的解释：</p>\n<blockquote>\n<p>很多人以为方法区（或者HotSopt 虚拟机中的永久代）是没有垃圾收集的，Java虚拟机规范中确实说过可以不要求虚拟机在方法区实现垃圾收集，而且性价比一般较低，在对的新生代生一般能回收70%~95%的空间，而永久代远低于此。</p>\n<p>永久代的垃圾手机主要回收两部分内容：<strong>废弃常量</strong>和<strong>无用的类</strong>。 回收废弃常量与回收Java堆中的对象非常相似。以常量池中字面量的回收为例，若字符串“abc”已经进入常量池中，但当前系统没有任何String对象引用常量池中的“abc”常量，也没有其他地方引用该字面量，若发生内存回收，且必要的话，该“abc”就会被系统清理出常量池。常量池中其他的类（接口）、方法、字段的符号引用与此类似。</p>\n<p>无用的类需要满足3个条件：</p>\n<p>（1）该类所有的实例都已经被回收，即Java堆中不存在该类的任何实例；<br>（2）加载该类的ClassLoader已经被回收；<br>（3）该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</p>\n</blockquote>\n<p>那么对于我们的静态变量来说，如果不是我们手动处理的话设置实例为null的话，或其他操作的话，那么就不会满足上面的条件。那么静态变量会在什么时候被销毁呢？答案很简单了就：**静态变量在类被卸载的时候销毁，类在什么时候被卸载？在进程结束的时候。**那么这也自然能解释我最开始遇到的情况了，返回键返回结束App后进程并没有结束，当下一次再启动App的时候，进程并没有销毁而，因是同一个进程，所以单例中的数据依然存在。</p>\n","categories":[{"name":"技术文章","slug":"technology","api":"api/categories/technology.json"}],"tags":[{"name":"安卓","slug":"Android","api":"api/tags/Android.json"}],"api":"api/posts/2020/09/09/从Android返回键退出和直接杀死进程退出说起.json"},{"title":"扇形等分-突然想到的一个数学问题","slug":"扇形等分-突然想到的一个数学问题","date":"2020-09-01T07:13:00.000Z","updated":"2025-05-20T11:46:57.000Z","comments":true,"url":"2020/09/01/扇形等分-突然想到的一个数学问题/","excerpt":"<p>note:博客有可能会因为一些 markdown 兼容性不支持，可以查看：<br><a href=\"https://www.douban.com/note/776327336/\">https://www.douban.com/note/776327336/</a></p>\n<p>如图所示，今天突然产生一个想法，如何对扇形进行非角度的平分，数学语言表达的话：我们有一角度为θ的扇形，已知半径为R,我们在R1、R2、R3…..Rn-1处对扇形进行n次分割，使得划分之后的部分面积相等，即S1&#x3D;S2&#x3D;S3….Sn-1&#x3D;Sn，求R之间的关系表达式。</p>\n<img src=\"https://cdn.julis.wang/blog/img/1521743510550.jpg\">\n<p>对于每个区域有：<br>$$<br>f(1)&#x3D;\\frac{ πθ(R_1)^2} {360}<br>$$</p>\n<p>$$<br>f(2)&#x3D;\\frac{ πθ(R_2)^2} {360} - f(1) &#x3D; \\frac{ πθ(R_2)^2} {360} - \\frac{ πθ(R_1)^2} {360}<br>$$</p>\n<p>$$<br>f(3)&#x3D;\\frac{ πθ(R_3)^2} {360} - f(2) &#x3D;  \\frac{ πθ(R_3)^2} {360} - \\frac{ πθ(R_2)^2} {360}<br>$$</p>\n<p>$$<br>……<br>$$</p>\n<p>$$<br>f(n)&#x3D;\\frac{ πθ(R_n)^2} {360}- f(n) &#x3D;  \\frac{ πθ(R_n)^2} {360} - \\frac{ πθ(R_{n-1})^2} {360}<br>$$<br>对于<br>$$<br>f(R_n)-f(R_{n-1}) &#x3D; \\frac{ πθ(R_n)^2} {360} - \\frac{ πθ(R_{n-1})^2} {360}<br>$$<br>由于<br>$$<br>f(R_1)&#x3D;f(R_2)&#x3D;f(R_3)……&#x3D;f(R_{n-1})&#x3D;f(R_n)<br>$$<br>即<br>$$<br>\\frac{ πθ(R_1)^2} {360}&#x3D;\\frac{ πθ(R_2)^2} {360} - \\frac{ πθ(R_1)^2} {360} &#x3D;\\frac{ πθ(R_3)^2} {360} - \\frac{ πθ(R_2)^2} {360} ……&#x3D; \\frac{ πθ(R_n)^2} {360} - \\frac{ πθ(R_{n-1})^2} {360}<br>$$<br>推出<br>$$<br>R_1^2&#x3D;R_2^2-R_1^2  \\longrightarrow R_2 &#x3D; \\frac  {R_1} {\\sqrt{2}}<br>$$</p>\n<p>$$<br>R_2^2&#x3D;R_3^2-R_2^2  \\longrightarrow R_3 &#x3D; \\frac  {R_2} {\\sqrt{2}} &#x3D;\\frac  {R_1} {\\sqrt{2} ^2}<br>$$</p>\n<p>$$<br>R_4 &#x3D; \\frac  {R_1} {\\sqrt{2} ^3}<br>\\<br>$$</p>\n<p>$$<br>……<br>$$</p>\n<p>$$<br>R_n&#x3D; \\frac  {R_1} {\\sqrt{2} ^{n-1}}<br>$$</p>\n<p>$$<br>对于R_1有\\frac{ πθ(R_1)^2} {360} &#x3D; \\frac{ πθ(R_n)^2} {360n} \\longrightarrow R_1&#x3D; \\frac R {\\sqrt {n}}<br>$$</p>\n<p>$$<br>Rn &#x3D;\\frac R {\\sqrt {n}({\\sqrt{2}) ^{n-1}} }<br>$$</p>\n<img src=\"https://cdn.julis.wang/blog/img/dc37c754ce6f4fd1ae224ac2a40416c0.png\">\n<p>从上的公式推导可以看出，对于“扇形”的平分也可以推广到圆的平分上面去，因为从公式中我们看到θ已经被约掉了。从晚上六七点想问题，到下班回家后，推导到了十一点，出来了结论，感觉还是蛮有趣的，遂记录一笔。</p>\n","cover":null,"images":["https://cdn.julis.wang/blog/img/1521743510550.jpg","https://cdn.julis.wang/blog/img/dc37c754ce6f4fd1ae224ac2a40416c0.png"],"content":"<p>note:博客有可能会因为一些 markdown 兼容性不支持，可以查看：<br><a href=\"https://www.douban.com/note/776327336/\">https://www.douban.com/note/776327336/</a></p>\n<p>如图所示，今天突然产生一个想法，如何对扇形进行非角度的平分，数学语言表达的话：我们有一角度为θ的扇形，已知半径为R,我们在R1、R2、R3…..Rn-1处对扇形进行n次分割，使得划分之后的部分面积相等，即S1&#x3D;S2&#x3D;S3….Sn-1&#x3D;Sn，求R之间的关系表达式。</p>\n<img src=\"https://cdn.julis.wang/blog/img/1521743510550.jpg\">\n<p>对于每个区域有：<br>$$<br>f(1)&#x3D;\\frac{ πθ(R_1)^2} {360}<br>$$</p>\n<p>$$<br>f(2)&#x3D;\\frac{ πθ(R_2)^2} {360} - f(1) &#x3D; \\frac{ πθ(R_2)^2} {360} - \\frac{ πθ(R_1)^2} {360}<br>$$</p>\n<p>$$<br>f(3)&#x3D;\\frac{ πθ(R_3)^2} {360} - f(2) &#x3D;  \\frac{ πθ(R_3)^2} {360} - \\frac{ πθ(R_2)^2} {360}<br>$$</p>\n<p>$$<br>……<br>$$</p>\n<p>$$<br>f(n)&#x3D;\\frac{ πθ(R_n)^2} {360}- f(n) &#x3D;  \\frac{ πθ(R_n)^2} {360} - \\frac{ πθ(R_{n-1})^2} {360}<br>$$<br>对于<br>$$<br>f(R_n)-f(R_{n-1}) &#x3D; \\frac{ πθ(R_n)^2} {360} - \\frac{ πθ(R_{n-1})^2} {360}<br>$$<br>由于<br>$$<br>f(R_1)&#x3D;f(R_2)&#x3D;f(R_3)……&#x3D;f(R_{n-1})&#x3D;f(R_n)<br>$$<br>即<br>$$<br>\\frac{ πθ(R_1)^2} {360}&#x3D;\\frac{ πθ(R_2)^2} {360} - \\frac{ πθ(R_1)^2} {360} &#x3D;\\frac{ πθ(R_3)^2} {360} - \\frac{ πθ(R_2)^2} {360} ……&#x3D; \\frac{ πθ(R_n)^2} {360} - \\frac{ πθ(R_{n-1})^2} {360}<br>$$<br>推出<br>$$<br>R_1^2&#x3D;R_2^2-R_1^2  \\longrightarrow R_2 &#x3D; \\frac  {R_1} {\\sqrt{2}}<br>$$</p>\n<p>$$<br>R_2^2&#x3D;R_3^2-R_2^2  \\longrightarrow R_3 &#x3D; \\frac  {R_2} {\\sqrt{2}} &#x3D;\\frac  {R_1} {\\sqrt{2} ^2}<br>$$</p>\n<p>$$<br>R_4 &#x3D; \\frac  {R_1} {\\sqrt{2} ^3}<br>\\<br>$$</p>\n<p>$$<br>……<br>$$</p>\n<p>$$<br>R_n&#x3D; \\frac  {R_1} {\\sqrt{2} ^{n-1}}<br>$$</p>\n<p>$$<br>对于R_1有\\frac{ πθ(R_1)^2} {360} &#x3D; \\frac{ πθ(R_n)^2} {360n} \\longrightarrow R_1&#x3D; \\frac R {\\sqrt {n}}<br>$$</p>\n<p>$$<br>Rn &#x3D;\\frac R {\\sqrt {n}({\\sqrt{2}) ^{n-1}} }<br>$$</p>\n<img src=\"https://cdn.julis.wang/blog/img/dc37c754ce6f4fd1ae224ac2a40416c0.png\">\n<p>从上的公式推导可以看出，对于“扇形”的平分也可以推广到圆的平分上面去，因为从公式中我们看到θ已经被约掉了。从晚上六七点想问题，到下班回家后，推导到了十一点，出来了结论，感觉还是蛮有趣的，遂记录一笔。</p>\n","categories":[{"name":"算法研究","slug":"算法研究","api":"api/categories/算法研究.json"}],"tags":[{"name":"数学","slug":"数学","api":"api/tags/数学.json"}],"api":"api/posts/2020/09/01/扇形等分-突然想到的一个数学问题.json"},{"title":"《头发--一部趣味人类史》 ","slug":"《头发-一部趣味人类史》","date":"2020-08-20T14:14:00.000Z","updated":"2025-05-20T11:46:57.000Z","comments":true,"url":"2020/08/20/《头发-一部趣味人类史》/","excerpt":"<p>作为程序员，经常听到与“秃头”这个词相结合起来，其实我是不太相信的，毕竟身边秃头的是极少的，可谁秃头跟程序员这个职业有必然联系么？如果有有必然联系那是为什么呢？</p>\n<p> 一直都有着好奇的心，可一直没有进行相关的了解查询，巧的之前在江西省图书馆发现了这本有趣的书，当时没有看完，后来直接在当当买了一本，真的是非常值的，大力推荐这本书。豆瓣编辑推荐语：</p>\n<blockquote>\n<p>本书是一部关于毛发的趣味文化史，行文轻松有趣，信息量庞大。它以头发为切入点，通过一段段有趣的故事，从历史、艺术、文化、社会、工业、科学等角度，勾勒了毛发在人类历史进程中扮演的种种角色：从头发起源的生物演变、令人困扰的毛发疾病，到毛发在人类社交过程中蕴含的丰富的政治、社会信息；从理发的历史到制造、使用假发的种种幕后故事，再到以获取毛发（皮）为动机，驱动贪婪的商人开辟新航路、改变世界历史。</p>\n</blockquote>\n<p>由于书中涉及的头发的知识面比较太广，细小的毛发居然有这么多我们不知道的事情，其中最有意思的莫过于理发师与外科手术的联系吧。</p>\n<p>我们都曾在理发店门口，见到过这样的东西，一根旋转的光柱，含有三种颜色：红、白、蓝。</p>\n<p><img src=\"http://5b0988e595225.cdn.sohucs.com/images/20190223/9e1f3705e7314bb89e90f4dbb19ff12f.jpeg\" alt=\"img\"></p>\n<p>理发店为什么会放这个东西呢？本书则就这一事情就有很详细地进行了讲解：在古代人眼里，理发与外科手术是一类事情，都是医治人的身体，在某种程度上来说，两者的意义是一样的。在一次会议之后，形成了一个新的职业–理发师兼外科医生。英国国王为表彰他们的重要贡献，专门成立了一个理发师公会，作为行业的典范，授予公会成员在伦敦拥有理发和外科手术的垄断权。但有一群专门的外科医生不满这个垄断权（因为外科医生觉得自己做手术能力是比理发修建更有技术些），于是他们无视垄断，又重新成立了一个公会叫：外科医生联合会。这两个公会之间就因为争夺生意而纠纷不断。最终两者的矛盾无法调和，最终在1745年，分道扬镳：分别创立了外科联合会与理发师联合会。</p>\n<p>对于理发师联合会，他们对于原本的“理发师兼外科医生”中的“外科医生”残留痕迹可能就是理发店外面的旋转柱了，代表着常见的放血术。为排出那些有毒的血液，理发师兼外科医生会切开血脉放血，然后用绷带包扎。在平时，理发师兼外科医生会把干净的白色绷带缠在杆子上，然后把杆子放在店前作为提供服务的标志。</p>\n<p>在最初，门口摆放这种柱子代表这家店，后来，他们不再摆放真的杆子和绷带，而是用仿照实物造型喷上油漆的柱子来代替：柱子有时会涂成红色和白色（代表动脉和绷带），有时会涂成红色、白色和蓝色（象征静脉），这根柱子便成为了能表明提供理发服务的标志。</p>\n","cover":null,"images":["http://5b0988e595225.cdn.sohucs.com/images/20190223/9e1f3705e7314bb89e90f4dbb19ff12f.jpeg"],"content":"<p>作为程序员，经常听到与“秃头”这个词相结合起来，其实我是不太相信的，毕竟身边秃头的是极少的，可谁秃头跟程序员这个职业有必然联系么？如果有有必然联系那是为什么呢？</p>\n<p> 一直都有着好奇的心，可一直没有进行相关的了解查询，巧的之前在江西省图书馆发现了这本有趣的书，当时没有看完，后来直接在当当买了一本，真的是非常值的，大力推荐这本书。豆瓣编辑推荐语：</p>\n<blockquote>\n<p>本书是一部关于毛发的趣味文化史，行文轻松有趣，信息量庞大。它以头发为切入点，通过一段段有趣的故事，从历史、艺术、文化、社会、工业、科学等角度，勾勒了毛发在人类历史进程中扮演的种种角色：从头发起源的生物演变、令人困扰的毛发疾病，到毛发在人类社交过程中蕴含的丰富的政治、社会信息；从理发的历史到制造、使用假发的种种幕后故事，再到以获取毛发（皮）为动机，驱动贪婪的商人开辟新航路、改变世界历史。</p>\n</blockquote>\n<p>由于书中涉及的头发的知识面比较太广，细小的毛发居然有这么多我们不知道的事情，其中最有意思的莫过于理发师与外科手术的联系吧。</p>\n<p>我们都曾在理发店门口，见到过这样的东西，一根旋转的光柱，含有三种颜色：红、白、蓝。</p>\n<p><img src=\"http://5b0988e595225.cdn.sohucs.com/images/20190223/9e1f3705e7314bb89e90f4dbb19ff12f.jpeg\" alt=\"img\"></p>\n<p>理发店为什么会放这个东西呢？本书则就这一事情就有很详细地进行了讲解：在古代人眼里，理发与外科手术是一类事情，都是医治人的身体，在某种程度上来说，两者的意义是一样的。在一次会议之后，形成了一个新的职业–理发师兼外科医生。英国国王为表彰他们的重要贡献，专门成立了一个理发师公会，作为行业的典范，授予公会成员在伦敦拥有理发和外科手术的垄断权。但有一群专门的外科医生不满这个垄断权（因为外科医生觉得自己做手术能力是比理发修建更有技术些），于是他们无视垄断，又重新成立了一个公会叫：外科医生联合会。这两个公会之间就因为争夺生意而纠纷不断。最终两者的矛盾无法调和，最终在1745年，分道扬镳：分别创立了外科联合会与理发师联合会。</p>\n<p>对于理发师联合会，他们对于原本的“理发师兼外科医生”中的“外科医生”残留痕迹可能就是理发店外面的旋转柱了，代表着常见的放血术。为排出那些有毒的血液，理发师兼外科医生会切开血脉放血，然后用绷带包扎。在平时，理发师兼外科医生会把干净的白色绷带缠在杆子上，然后把杆子放在店前作为提供服务的标志。</p>\n<p>在最初，门口摆放这种柱子代表这家店，后来，他们不再摆放真的杆子和绷带，而是用仿照实物造型喷上油漆的柱子来代替：柱子有时会涂成红色和白色（代表动脉和绷带），有时会涂成红色、白色和蓝色（象征静脉），这根柱子便成为了能表明提供理发服务的标志。</p>\n","categories":[{"name":"读书电影","slug":"movie","api":"api/categories/movie.json"}],"tags":[{"name":"读书","slug":"读书","api":"api/tags/读书.json"}],"api":"api/posts/2020/08/20/《头发-一部趣味人类史》.json"},{"title":"诗歌-《你是天上的星星》","slug":"诗歌-你是天上的星星","date":"2020-08-12T10:20:00.000Z","updated":"2025-08-25T14:11:48.421Z","comments":true,"url":"2020/08/12/诗歌-你是天上的星星/","excerpt":"<img src=/img/4b20e4f3bf134126953165c56558a2f8.png >","cover":null,"images":[],"content":"<img src=/img/4b20e4f3bf134126953165c56558a2f8.png >","categories":[{"name":"生活感想","slug":"life","api":"api/categories/life.json"}],"tags":[{"name":"诗歌","slug":"诗歌","api":"api/tags/诗歌.json"}],"api":"api/posts/2020/08/12/诗歌-你是天上的星星.json"},{"title":"《美丽的数学》-有趣的数学","slug":"《美丽的数学》-有趣的数学","date":"2020-07-25T15:07:00.000Z","updated":"2025-05-20T11:46:57.000Z","comments":true,"url":"2020/07/25/《美丽的数学》-有趣的数学/","excerpt":"<p>数学有趣而美妙。书名《美丽的数学》，封面设计得非常的棒，简单优美的线条组合组成了这一蜗牛壳形状，让我们还没有翻开书就已经看到了数学的美丽。这本书看的时间不太长，因为有很多内容已经比较熟悉了，比如斐波那契数列、费马、概率相关。不过更很多内容，让人很着迷。</p>\n<h4 id=\"一个奇迹般的等式\"><a href=\"#一个奇迹般的等式\" class=\"headerlink\" title=\"一个奇迹般的等式\"></a>一个奇迹般的等式</h4><p>我们都知道数学中有这样几个数字：<br>$$<br>\\pi  \\ \\ \\ e  \\ \\  i<br>$$<br>但你可知道他们之间也有一个等式关系：<br>$$<br>e^{i\\pi} + 1 &#x3D; 0<br>$$<br>这个方程真的很震撼，有一种得到“统一”的感觉，就像麦克斯韦<a href=\"https://baike.baidu.com/item/%E7%94%B5%E7%A3%81%E7%90%86%E8%AE%BA\">电磁理论</a>建立以后，光学也变成了电磁学的一个分支了，电学、磁学和光学得到了统一。看似没有关联的数字，但他们之间存在着这样的联系，就这一个简单的公式就能把数学中最常用的五个数学符号给统一起来了，不得不服气。</p>\n<h4 id=\"阶乘\"><a href=\"#阶乘\" class=\"headerlink\" title=\"阶乘\"></a>阶乘</h4><p>阶乘我们都很熟悉，也都知道该怎么去计算阶乘，公式很简单：<br>$$<br>N!&#x3D;1×2×3×…×(N-1)×N<br>$$<br>如果我们想计算1000！的阶乘呢？对于程序员来说，总是想到用代码去实习，代码大致这样：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">factorial</span><span class=\"params\">(<span class=\"type\">int</span> n)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">1</span>; i &lt;= n; i++) &#123;</span><br><span class=\"line\">        j *= i;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">   <span class=\"keyword\">return</span> j;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>但是对于1000！这样一个很大数，最终得到的结果是很大的，对于这样的代码的话，int绝对已经满足不了了，哪怕是long,long long int,但是暂且不考虑数据类型的容量。计算机在计算的时候，过程中会进行大量的运算，消耗了大量的性能，但我们最终只是需要一个结果值，而过程中的数据就变得不那么重要了，那么有没有简单的计算方式呢？当然有！又是一个神奇的公式：<br>$$<br>N!\\approx \\sqrt{2\\pi N} ( \\frac N　e)^N<br>$$<br>代码变成：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">ans=(<span class=\"type\">int</span>)(log10((<span class=\"number\">2</span>*PI*n))/<span class=\"number\">2</span>+n*log10((n/e))+<span class=\"number\">1</span>);</span><br></pre></td></tr></table></figure>\n\n<p>这样的代码相对而言计算的性能会小很多，虽然公式只是取到一个近似值，误差值在N越大的时候误差越小，在N&#x3D;1000的时候与真实数据的误差已经小于0.01%了，这对于进行大数据很有帮助。</p>\n<h5 id=\"对于0的阶乘等于1的疑问\"><a href=\"#对于0的阶乘等于1的疑问\" class=\"headerlink\" title=\"对于0的阶乘等于1的疑问\"></a>对于0的阶乘等于1的疑问</h5><p>书中关于0的阶乘的证明有个疑问，通过公式:<br>$$<br>N!&#x3D;N*(N-1)!<br>$$<br>N为自然数大于等于0</p>\n<p>因为1！&#x3D;1，根据公式有:<br>$$<br>1!&#x3D;1*0!<br>$$<br>推出0！&#x3D;1，这样看似乎没有问题</p>\n<p>然而将N&#x3D;0再带入公式:<br>$$<br>0!&#x3D; 0*(-1)!<br>$$<br>左边等于1，右边由于0乘以任何数都为0的情况下那么右边为0,左右则矛盾冲突了，那么利用N!&#x3D;N*(N-1)!来推导0！就有一定的局限性。</p>\n<h4 id=\"非传递性骰子\"><a href=\"#非传递性骰子\" class=\"headerlink\" title=\"非传递性骰子\"></a>非传递性骰子</h4><p>对于上面的内容的话，都是一些比较纯数学公式的，但这一节的内容好像与我们的生活有那么一些关系的，说实话这一节真的有点出人意料的，让我有一种怀疑人生的感觉。现在有三颗骰子A B C，每颗骰子上面的数字并不是 1 2 3 4 5 6，而是一些特定的数字比如我们定义这样三个骰子，有六面，每一面有不同的数字，三个骰子的数字都不一样，如下图</p>\n<table>\n<thead>\n<tr>\n<th>骰子</th>\n<th>一</th>\n<th>二</th>\n<th>三</th>\n<th>四</th>\n<th>五</th>\n<th>六</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>A</td>\n<td>2</td>\n<td>3</td>\n<td>4</td>\n<td>12</td>\n<td>16</td>\n<td>17</td>\n</tr>\n<tr>\n<td>B</td>\n<td>5</td>\n<td>6</td>\n<td>7</td>\n<td>8</td>\n<td>9</td>\n<td>18</td>\n</tr>\n<tr>\n<td>C</td>\n<td>1</td>\n<td>10</td>\n<td>12</td>\n<td>13</td>\n<td>14</td>\n<td>15</td>\n</tr>\n</tbody></table>\n<p>如果让你选这三个骰子中的一个去参与“赌博”，你会选哪一个呢？对于A骰子和B骰子，通过列表格我们可以知道：</p>\n<table>\n<thead>\n<tr>\n<th></th>\n<th>2</th>\n<th>3</th>\n<th>4</th>\n<th>12</th>\n<th>16</th>\n<th>17</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>5</td>\n<td>B</td>\n<td>B</td>\n<td>B</td>\n<td>A</td>\n<td>A</td>\n<td>A</td>\n</tr>\n<tr>\n<td>6</td>\n<td>B</td>\n<td>B</td>\n<td>B</td>\n<td>A</td>\n<td>A</td>\n<td>A</td>\n</tr>\n<tr>\n<td>7</td>\n<td>B</td>\n<td>B</td>\n<td>B</td>\n<td>A</td>\n<td>A</td>\n<td>A</td>\n</tr>\n<tr>\n<td>8</td>\n<td>B</td>\n<td>B</td>\n<td>B</td>\n<td>A</td>\n<td>A</td>\n<td>A</td>\n</tr>\n<tr>\n<td>9</td>\n<td>B</td>\n<td>B</td>\n<td>B</td>\n<td>A</td>\n<td>A</td>\n<td>A</td>\n</tr>\n<tr>\n<td>18</td>\n<td>B</td>\n<td>B</td>\n<td>B</td>\n<td>B</td>\n<td>B</td>\n<td>B</td>\n</tr>\n</tbody></table>\n<p>可以知道A获胜的概率也就是 15&#x2F;36 约等于 42%，B赢的概率会是：58%。 那么你肯定会选择B，因为它赢的概率会大一点。我们用相同的手段处理骰子B和C得到的的数据：B赢的概率是 11&#x2F;36 约等于 31%，C赢的概率是25&#x2F;36约等于 百分之69。那么你肯定会选择骰子C。</p>\n<p>好像在这样的三个骰子里面，A“最差”，C“最好”，然而对于A和C，C赢的概率真的会高一些么？！如果你继续通过上面列表格的方式你会发现，A和C比较的话，A赢的概率是 21&#x2F;36约等于 58%，C赢的概率是15&#x2F;36约等于42%。</p>\n<p>相信你如果不是有对概率论有学习过的话，一上来肯定是不相信的，然而事实就是这样的。这是因为A与B、B与C、A与C相互之间的比较产生的<strong>基本事件空间</strong>是不一样的，比如A和B比较是(2,5)(2,6)等36个基本事件，A和C又是另外36个基本事件，所以这个概率大小也不具有传递性。</p>\n<h5 id=\"最后\"><a href=\"#最后\" class=\"headerlink\" title=\"最后\"></a>最后</h5><p>对于这本书，我本以为会介绍这个的方程：<br>$$<br>r &#x3D;a( 1 - sin θ)<br>$$<br>因为这个方程有一个美丽的图形，而方程背后又有一个美丽的故事，感觉内容太适合这本书了，不知道为什么没有加入进去。</p>\n<p>总之这本书大部分内容都是初等数学相关的知识，看起来并不是特别的费劲，但是很多平常有经常用过的数或者公式都有其深深的内涵所在，当你对其中的原理证明进行了相关的了解之后，你会发出感叹，原来数学是如此的有趣美丽。</p>\n","cover":null,"images":[],"content":"<p>数学有趣而美妙。书名《美丽的数学》，封面设计得非常的棒，简单优美的线条组合组成了这一蜗牛壳形状，让我们还没有翻开书就已经看到了数学的美丽。这本书看的时间不太长，因为有很多内容已经比较熟悉了，比如斐波那契数列、费马、概率相关。不过更很多内容，让人很着迷。</p>\n<h4 id=\"一个奇迹般的等式\"><a href=\"#一个奇迹般的等式\" class=\"headerlink\" title=\"一个奇迹般的等式\"></a>一个奇迹般的等式</h4><p>我们都知道数学中有这样几个数字：<br>$$<br>\\pi  \\ \\ \\ e  \\ \\  i<br>$$<br>但你可知道他们之间也有一个等式关系：<br>$$<br>e^{i\\pi} + 1 &#x3D; 0<br>$$<br>这个方程真的很震撼，有一种得到“统一”的感觉，就像麦克斯韦<a href=\"https://baike.baidu.com/item/%E7%94%B5%E7%A3%81%E7%90%86%E8%AE%BA\">电磁理论</a>建立以后，光学也变成了电磁学的一个分支了，电学、磁学和光学得到了统一。看似没有关联的数字，但他们之间存在着这样的联系，就这一个简单的公式就能把数学中最常用的五个数学符号给统一起来了，不得不服气。</p>\n<h4 id=\"阶乘\"><a href=\"#阶乘\" class=\"headerlink\" title=\"阶乘\"></a>阶乘</h4><p>阶乘我们都很熟悉，也都知道该怎么去计算阶乘，公式很简单：<br>$$<br>N!&#x3D;1×2×3×…×(N-1)×N<br>$$<br>如果我们想计算1000！的阶乘呢？对于程序员来说，总是想到用代码去实习，代码大致这样：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">factorial</span><span class=\"params\">(<span class=\"type\">int</span> n)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">1</span>; i &lt;= n; i++) &#123;</span><br><span class=\"line\">        j *= i;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">   <span class=\"keyword\">return</span> j;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>但是对于1000！这样一个很大数，最终得到的结果是很大的，对于这样的代码的话，int绝对已经满足不了了，哪怕是long,long long int,但是暂且不考虑数据类型的容量。计算机在计算的时候，过程中会进行大量的运算，消耗了大量的性能，但我们最终只是需要一个结果值，而过程中的数据就变得不那么重要了，那么有没有简单的计算方式呢？当然有！又是一个神奇的公式：<br>$$<br>N!\\approx \\sqrt{2\\pi N} ( \\frac N　e)^N<br>$$<br>代码变成：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">ans=(<span class=\"type\">int</span>)(log10((<span class=\"number\">2</span>*PI*n))/<span class=\"number\">2</span>+n*log10((n/e))+<span class=\"number\">1</span>);</span><br></pre></td></tr></table></figure>\n\n<p>这样的代码相对而言计算的性能会小很多，虽然公式只是取到一个近似值，误差值在N越大的时候误差越小，在N&#x3D;1000的时候与真实数据的误差已经小于0.01%了，这对于进行大数据很有帮助。</p>\n<h5 id=\"对于0的阶乘等于1的疑问\"><a href=\"#对于0的阶乘等于1的疑问\" class=\"headerlink\" title=\"对于0的阶乘等于1的疑问\"></a>对于0的阶乘等于1的疑问</h5><p>书中关于0的阶乘的证明有个疑问，通过公式:<br>$$<br>N!&#x3D;N*(N-1)!<br>$$<br>N为自然数大于等于0</p>\n<p>因为1！&#x3D;1，根据公式有:<br>$$<br>1!&#x3D;1*0!<br>$$<br>推出0！&#x3D;1，这样看似乎没有问题</p>\n<p>然而将N&#x3D;0再带入公式:<br>$$<br>0!&#x3D; 0*(-1)!<br>$$<br>左边等于1，右边由于0乘以任何数都为0的情况下那么右边为0,左右则矛盾冲突了，那么利用N!&#x3D;N*(N-1)!来推导0！就有一定的局限性。</p>\n<h4 id=\"非传递性骰子\"><a href=\"#非传递性骰子\" class=\"headerlink\" title=\"非传递性骰子\"></a>非传递性骰子</h4><p>对于上面的内容的话，都是一些比较纯数学公式的，但这一节的内容好像与我们的生活有那么一些关系的，说实话这一节真的有点出人意料的，让我有一种怀疑人生的感觉。现在有三颗骰子A B C，每颗骰子上面的数字并不是 1 2 3 4 5 6，而是一些特定的数字比如我们定义这样三个骰子，有六面，每一面有不同的数字，三个骰子的数字都不一样，如下图</p>\n<table>\n<thead>\n<tr>\n<th>骰子</th>\n<th>一</th>\n<th>二</th>\n<th>三</th>\n<th>四</th>\n<th>五</th>\n<th>六</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>A</td>\n<td>2</td>\n<td>3</td>\n<td>4</td>\n<td>12</td>\n<td>16</td>\n<td>17</td>\n</tr>\n<tr>\n<td>B</td>\n<td>5</td>\n<td>6</td>\n<td>7</td>\n<td>8</td>\n<td>9</td>\n<td>18</td>\n</tr>\n<tr>\n<td>C</td>\n<td>1</td>\n<td>10</td>\n<td>12</td>\n<td>13</td>\n<td>14</td>\n<td>15</td>\n</tr>\n</tbody></table>\n<p>如果让你选这三个骰子中的一个去参与“赌博”，你会选哪一个呢？对于A骰子和B骰子，通过列表格我们可以知道：</p>\n<table>\n<thead>\n<tr>\n<th></th>\n<th>2</th>\n<th>3</th>\n<th>4</th>\n<th>12</th>\n<th>16</th>\n<th>17</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>5</td>\n<td>B</td>\n<td>B</td>\n<td>B</td>\n<td>A</td>\n<td>A</td>\n<td>A</td>\n</tr>\n<tr>\n<td>6</td>\n<td>B</td>\n<td>B</td>\n<td>B</td>\n<td>A</td>\n<td>A</td>\n<td>A</td>\n</tr>\n<tr>\n<td>7</td>\n<td>B</td>\n<td>B</td>\n<td>B</td>\n<td>A</td>\n<td>A</td>\n<td>A</td>\n</tr>\n<tr>\n<td>8</td>\n<td>B</td>\n<td>B</td>\n<td>B</td>\n<td>A</td>\n<td>A</td>\n<td>A</td>\n</tr>\n<tr>\n<td>9</td>\n<td>B</td>\n<td>B</td>\n<td>B</td>\n<td>A</td>\n<td>A</td>\n<td>A</td>\n</tr>\n<tr>\n<td>18</td>\n<td>B</td>\n<td>B</td>\n<td>B</td>\n<td>B</td>\n<td>B</td>\n<td>B</td>\n</tr>\n</tbody></table>\n<p>可以知道A获胜的概率也就是 15&#x2F;36 约等于 42%，B赢的概率会是：58%。 那么你肯定会选择B，因为它赢的概率会大一点。我们用相同的手段处理骰子B和C得到的的数据：B赢的概率是 11&#x2F;36 约等于 31%，C赢的概率是25&#x2F;36约等于 百分之69。那么你肯定会选择骰子C。</p>\n<p>好像在这样的三个骰子里面，A“最差”，C“最好”，然而对于A和C，C赢的概率真的会高一些么？！如果你继续通过上面列表格的方式你会发现，A和C比较的话，A赢的概率是 21&#x2F;36约等于 58%，C赢的概率是15&#x2F;36约等于42%。</p>\n<p>相信你如果不是有对概率论有学习过的话，一上来肯定是不相信的，然而事实就是这样的。这是因为A与B、B与C、A与C相互之间的比较产生的<strong>基本事件空间</strong>是不一样的，比如A和B比较是(2,5)(2,6)等36个基本事件，A和C又是另外36个基本事件，所以这个概率大小也不具有传递性。</p>\n<h5 id=\"最后\"><a href=\"#最后\" class=\"headerlink\" title=\"最后\"></a>最后</h5><p>对于这本书，我本以为会介绍这个的方程：<br>$$<br>r &#x3D;a( 1 - sin θ)<br>$$<br>因为这个方程有一个美丽的图形，而方程背后又有一个美丽的故事，感觉内容太适合这本书了，不知道为什么没有加入进去。</p>\n<p>总之这本书大部分内容都是初等数学相关的知识，看起来并不是特别的费劲，但是很多平常有经常用过的数或者公式都有其深深的内涵所在，当你对其中的原理证明进行了相关的了解之后，你会发出感叹，原来数学是如此的有趣美丽。</p>\n","categories":[{"name":"读书电影","slug":"movie","api":"api/categories/movie.json"}],"tags":[{"name":"数学","slug":"数学","api":"api/tags/数学.json"}],"api":"api/posts/2020/07/25/《美丽的数学》-有趣的数学.json"},{"title":"基于AndroidVideoCache的预加载","slug":"基于AndroidVideoCache的预加载","date":"2020-07-06T11:09:00.000Z","updated":"2025-09-15T13:07:12.918Z","comments":true,"url":"2020/07/06/基于AndroidVideoCache的预加载/","excerpt":"<p>最近有做需求关于视频缓存，了解到相关的开源库<a href=\"https://www.jianshu.com/p/dfc18278b053\">AndroidVideoCache</a>，\b一款市面上相对比较流行的视频缓存框架，而我想利用该框架进行视频缓存的处理，并且希望能够支持预加载。然而该框架作者在18年就已经停止了维护，所以留下了无限的编程空间给其他程序员，对于视频预加载，只搜到一篇<a href=\"https://www.jianshu.com/p/dfc18278b053\">《AndroidVideoCache源码详解以及改造系列-源码篇》</a>，然而点进该作者的博客列表，说好的预加载呢？？？后面也没有了下文，搜遍全网好像没有做AndroidVideoCache的预加载相关的事情，那么这样子的话……自己干吧。</p>\n<p>首先需要明白AndroidVideoCache的实现原理，推荐查看<a href=\"https://www.jianshu.com/p/4745de02dcdc\">《AndroidVideoCache-视频边播放边缓存的代理策略》</a>这里不再赘述。</p>\n<p>其实预加载的思路很简单，在进行一个播放视频后，再返回接下来需要预加载的视频url，启用后台线程去请求下载数据，不过中间涉及的细节逻辑比较多。</p>\n<h2 id=\"一、实现方案\"><a href=\"#一、实现方案\" class=\"headerlink\" title=\"一、实现方案\"></a>一、实现方案</h2><p>主要逻辑为：</p>\n<p>1、后台开启一个线程去请求并预加载一部分的数据</p>\n<p>2、可能需要预加载的数据大于&gt;1，利用队列先进入的先进行加载，加上前面的条件 使用HandlerThread再适合不过了。</p>\n<p>我们首先定义好需要去处理的任务情况：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">preload</span><span class=\"params\">( String method，Call call)</span> &#123;</span><br><span class=\"line\">       <span class=\"keyword\">switch</span> (method) &#123;</span><br><span class=\"line\">           <span class=\"keyword\">case</span> <span class=\"string\">&quot;addPreloadURL&quot;</span>:</span><br><span class=\"line\">               addPreloadURL(call); <span class=\"comment\">//添加url到预加载队列</span></span><br><span class=\"line\">               <span class=\"keyword\">break</span>;</span><br><span class=\"line\">           <span class=\"keyword\">case</span> <span class=\"string\">&quot;cancelPreloadURLIfNeeded&quot;</span>:</span><br><span class=\"line\">               cancelPreloadURLIfNeeded(call); <span class=\"comment\">//取消对应的url预加载（因为可能是立马需要播放这个视频，那么就不需要预加载了）</span></span><br><span class=\"line\">               <span class=\"keyword\">break</span>;</span><br><span class=\"line\">           <span class=\"keyword\">case</span> <span class=\"string\">&quot;cancelAnyPreloads&quot;</span>: </span><br><span class=\"line\">               cancelAnyPreLoads();<span class=\"comment\">//取消所有的预加载，主要是方便管理任务</span></span><br><span class=\"line\">               <span class=\"keyword\">break</span>;</span><br><span class=\"line\">           <span class=\"keyword\">default</span>:</span><br><span class=\"line\">           </span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n\n<p>那么对于每次的预加载逻辑基本上是这样的方法执行顺序：</p>\n<p> cancelPreloadURLIfNeeded()-&gt;addPreloadURL();   &#x2F;&#x2F;取消对应url加载的任务，因为有可能该url不需要再进行预加载了（参考抖音，当用户瞬间下滑几个视频，那么很多视频就需要跳过了不需要再进行预加载）</p>\n<p> cancelAnyPreLoads()-&gt;addPreloadURL();   &#x2F;&#x2F;取消对应url加载的任务（这时候需要立马播放最新的视频，那么就应该让出网速给该视频），之后再添加新一轮的预加载url。</p>\n<p>接下来具体的处理逻辑VideoPreLoader类，我直接放上所有的代码逻辑吧,为方便观察删除了一部分不太重要的逻辑，其实总体流程也比较简单。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">VideoPreLoader</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> Handler handler;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> HandlerThread handlerThread;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> List&lt;String&gt; cancelList = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"title function_\">VideoPreLoader</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    handlerThread = <span class=\"keyword\">new</span> <span class=\"title class_\">HandlerThread</span>(<span class=\"string\">&quot;VideoPreLoaderThread&quot;</span>);</span><br><span class=\"line\">    handlerThread.start();</span><br><span class=\"line\">    handler = <span class=\"keyword\">new</span> <span class=\"title class_\">Handler</span>(handlerThread.getLooper()) &#123;</span><br><span class=\"line\">      <span class=\"meta\">@Override</span></span><br><span class=\"line\">      <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">handleMessage</span><span class=\"params\">(Message msg)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">super</span>.handleMessage(msg);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">void</span> <span class=\"title function_\">addPreloadURL</span><span class=\"params\">(<span class=\"keyword\">final</span> VideoPreLoadModel data)</span> &#123;</span><br><span class=\"line\">    handler.post(<span class=\"keyword\">new</span> <span class=\"title class_\">Runnable</span>() &#123;</span><br><span class=\"line\">      <span class=\"meta\">@Override</span></span><br><span class=\"line\">      <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        realPreload(data);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">void</span> <span class=\"title function_\">cancelPreloadURLIfNeeded</span><span class=\"params\">(String url)</span> &#123;</span><br><span class=\"line\">    cancelList.add(url);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">void</span> <span class=\"title function_\">cancelAnyPreLoads</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    handler.removeCallbacksAndMessages(<span class=\"literal\">null</span>);</span><br><span class=\"line\">    cancelList.clear();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">realPreload</span><span class=\"params\">(VideoPreLoadModel data)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (data == <span class=\"literal\">null</span> || isCancel(data.originalUrl)) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"type\">HttpURLConnection</span> <span class=\"variable\">conn</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">      <span class=\"type\">URL</span> <span class=\"variable\">myURL</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">URL</span>(data.proxyUrl);</span><br><span class=\"line\">      conn = (HttpURLConnection) myURL.openConnection();</span><br><span class=\"line\">      conn.connect();</span><br><span class=\"line\">      <span class=\"type\">InputStream</span> <span class=\"variable\">is</span> <span class=\"operator\">=</span> conn.getInputStream();</span><br><span class=\"line\">      <span class=\"type\">byte</span>[] buf = <span class=\"keyword\">new</span> <span class=\"title class_\">byte</span>[<span class=\"number\">1024</span>];</span><br><span class=\"line\">      <span class=\"type\">int</span> <span class=\"variable\">downLoadedSize</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">      <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">numRead</span> <span class=\"operator\">=</span> is.read(buf);</span><br><span class=\"line\">        downLoadedSize += numRead;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (downLoadedSize &gt;= data.preLoadBytes || numRead == -<span class=\"number\">1</span>) &#123; <span class=\"comment\">//Reached  preload range or end of Input stream.</span></span><br><span class=\"line\">          <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125; <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>);</span><br><span class=\"line\">      is.close();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ....</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"type\">boolean</span> <span class=\"title function_\">isCancel</span><span class=\"params\">(String url)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (TextUtils.isEmpty(url)) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (String cancelUrl : cancelList) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (cancelUrl.equals(url)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>对于这段代码中其实有“两个”队列，一个是HandlerThread中的队列，熟悉消息机制的同学应该都能明白，内部是一个looper在不断地循环获取消息，当一个消息处理完毕之后才会处理下一个消息。我还定义了一个就是取消队列，因为HandlerThread中的任务我们不太好控制取消具体的任务，所以设置了一个取消队列，当之后的消息再需要执行的时候会首先判断是否是在取消队列里面，这样子就能做到对预加载队列逻辑的控制。</p>\n<h2 id=\"二、关于一些细节问题\"><a href=\"#二、关于一些细节问题\" class=\"headerlink\" title=\"二、关于一些细节问题\"></a>二、关于一些细节问题</h2><p>这样子我们在播放一个视频的时候，只需要传给我们接下来将会播放的视频的URL，我们就能对其预加载并缓存下来，但是会存在其他条件：</p>\n<h5 id=\"预加载的长度？\"><a href=\"#预加载的长度？\" class=\"headerlink\" title=\"预加载的长度？\"></a>预加载的长度？</h5><p>对于视频加载长度，我们很容易想到在视频url请求加入Range在header上面，比如</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">conn.addRequestProperty(<span class=\"string\">&quot;Range&quot;</span>, <span class=\"string\">&quot;0-102400&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n<p>我们只获取前102400 bytes，不用将整个视频全部进行预加载，我有进行这样的尝试，但是实际发现是有坑的。我做了很多尝试，发现不论怎么请求，拿到的 responseCode 虽然是206，但是 还是把数据给全部下载完了，这就有点不科学了！！</p>\n<p>最终去源码中才发现：源码有对range做正则匹配</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">Pattern</span> <span class=\"variable\">RANGE_HEADER_PATTERN</span> <span class=\"operator\">=</span> Pattern.compile(<span class=\"string\">&quot;[R,r]ange:[ ]?bytes=(\\\\d*)-&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"type\">long</span> <span class=\"title function_\">findRangeOffset</span><span class=\"params\">(String request)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">Matcher</span> <span class=\"variable\">matcher</span> <span class=\"operator\">=</span> RANGE_HEADER_PATTERN.matcher(request);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (matcher.find()) &#123;</span><br><span class=\"line\">            <span class=\"type\">String</span> <span class=\"variable\">rangeValue</span> <span class=\"operator\">=</span> matcher.group(<span class=\"number\">1</span>);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> Long.parseLong(rangeValue);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>看清楚了 <strong><em>“[R,r]ange:[ ]?bytes&#x3D;(\\d</em>)-“</strong>* 它只去匹配了前面的的，也就是说 我传入了 0-102400 它最终只当作是：Range：0- 来处理，导致addRequestProperty设置的range实现。坑！不过能理解作者为什么这么做，后面总结会讲到。没有办法只有使用最原始的方法进行判断了：在每次获取inputStream的时候进行判断是否达到预加载的大小，虽然有一定的性能开销，但是不去改源码的话也没有 办法了。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">      <span class=\"type\">int</span> <span class=\"variable\">numRead</span> <span class=\"operator\">=</span> is.read(buf);</span><br><span class=\"line\">      downLoadedSize += numRead;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (downLoadedSize &gt;= data.preLoadBytes || numRead == -<span class=\"number\">1</span>) &#123; <span class=\"comment\">//Reached  preload range or end of Input stream.</span></span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>);</span><br><span class=\"line\">    is.close();</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"三、总结\"><a href=\"#三、总结\" class=\"headerlink\" title=\"三、总结\"></a>三、总结</h2><p>本文主要讲了基于AndroidVideoCache的预加载具体实现原理，以及其中遇到的坑</p>\n<p>1、预加载主要通过HandlerThread去实现后台网络的访问以及缓存的处理逻辑</p>\n<p>2、加入取消队列去控制对应需要取消的任务</p>\n<p>3、对于预加载的size只能通过读取的时候进行判断，没有办法使用range去判断。其实很容易理解作者为什么正则要这样写，因为它只是一个视频缓存框架，主要是用来做“边播边存”，所以每次去进行请求的时候应该都是在原有的缓存之上去进行缓存数据处理，而缓存最终需要处理完的就是 content-size，不需要再去管Range中的结束范围了。</p>\n","cover":null,"images":[],"content":"<p>最近有做需求关于视频缓存，了解到相关的开源库<a href=\"https://www.jianshu.com/p/dfc18278b053\">AndroidVideoCache</a>，\b一款市面上相对比较流行的视频缓存框架，而我想利用该框架进行视频缓存的处理，并且希望能够支持预加载。然而该框架作者在18年就已经停止了维护，所以留下了无限的编程空间给其他程序员，对于视频预加载，只搜到一篇<a href=\"https://www.jianshu.com/p/dfc18278b053\">《AndroidVideoCache源码详解以及改造系列-源码篇》</a>，然而点进该作者的博客列表，说好的预加载呢？？？后面也没有了下文，搜遍全网好像没有做AndroidVideoCache的预加载相关的事情，那么这样子的话……自己干吧。</p>\n<p>首先需要明白AndroidVideoCache的实现原理，推荐查看<a href=\"https://www.jianshu.com/p/4745de02dcdc\">《AndroidVideoCache-视频边播放边缓存的代理策略》</a>这里不再赘述。</p>\n<p>其实预加载的思路很简单，在进行一个播放视频后，再返回接下来需要预加载的视频url，启用后台线程去请求下载数据，不过中间涉及的细节逻辑比较多。</p>\n<h2 id=\"一、实现方案\"><a href=\"#一、实现方案\" class=\"headerlink\" title=\"一、实现方案\"></a>一、实现方案</h2><p>主要逻辑为：</p>\n<p>1、后台开启一个线程去请求并预加载一部分的数据</p>\n<p>2、可能需要预加载的数据大于&gt;1，利用队列先进入的先进行加载，加上前面的条件 使用HandlerThread再适合不过了。</p>\n<p>我们首先定义好需要去处理的任务情况：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">preload</span><span class=\"params\">( String method，Call call)</span> &#123;</span><br><span class=\"line\">       <span class=\"keyword\">switch</span> (method) &#123;</span><br><span class=\"line\">           <span class=\"keyword\">case</span> <span class=\"string\">&quot;addPreloadURL&quot;</span>:</span><br><span class=\"line\">               addPreloadURL(call); <span class=\"comment\">//添加url到预加载队列</span></span><br><span class=\"line\">               <span class=\"keyword\">break</span>;</span><br><span class=\"line\">           <span class=\"keyword\">case</span> <span class=\"string\">&quot;cancelPreloadURLIfNeeded&quot;</span>:</span><br><span class=\"line\">               cancelPreloadURLIfNeeded(call); <span class=\"comment\">//取消对应的url预加载（因为可能是立马需要播放这个视频，那么就不需要预加载了）</span></span><br><span class=\"line\">               <span class=\"keyword\">break</span>;</span><br><span class=\"line\">           <span class=\"keyword\">case</span> <span class=\"string\">&quot;cancelAnyPreloads&quot;</span>: </span><br><span class=\"line\">               cancelAnyPreLoads();<span class=\"comment\">//取消所有的预加载，主要是方便管理任务</span></span><br><span class=\"line\">               <span class=\"keyword\">break</span>;</span><br><span class=\"line\">           <span class=\"keyword\">default</span>:</span><br><span class=\"line\">           </span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n\n<p>那么对于每次的预加载逻辑基本上是这样的方法执行顺序：</p>\n<p> cancelPreloadURLIfNeeded()-&gt;addPreloadURL();   &#x2F;&#x2F;取消对应url加载的任务，因为有可能该url不需要再进行预加载了（参考抖音，当用户瞬间下滑几个视频，那么很多视频就需要跳过了不需要再进行预加载）</p>\n<p> cancelAnyPreLoads()-&gt;addPreloadURL();   &#x2F;&#x2F;取消对应url加载的任务（这时候需要立马播放最新的视频，那么就应该让出网速给该视频），之后再添加新一轮的预加载url。</p>\n<p>接下来具体的处理逻辑VideoPreLoader类，我直接放上所有的代码逻辑吧,为方便观察删除了一部分不太重要的逻辑，其实总体流程也比较简单。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">VideoPreLoader</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> Handler handler;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> HandlerThread handlerThread;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> List&lt;String&gt; cancelList = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"title function_\">VideoPreLoader</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    handlerThread = <span class=\"keyword\">new</span> <span class=\"title class_\">HandlerThread</span>(<span class=\"string\">&quot;VideoPreLoaderThread&quot;</span>);</span><br><span class=\"line\">    handlerThread.start();</span><br><span class=\"line\">    handler = <span class=\"keyword\">new</span> <span class=\"title class_\">Handler</span>(handlerThread.getLooper()) &#123;</span><br><span class=\"line\">      <span class=\"meta\">@Override</span></span><br><span class=\"line\">      <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">handleMessage</span><span class=\"params\">(Message msg)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">super</span>.handleMessage(msg);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">void</span> <span class=\"title function_\">addPreloadURL</span><span class=\"params\">(<span class=\"keyword\">final</span> VideoPreLoadModel data)</span> &#123;</span><br><span class=\"line\">    handler.post(<span class=\"keyword\">new</span> <span class=\"title class_\">Runnable</span>() &#123;</span><br><span class=\"line\">      <span class=\"meta\">@Override</span></span><br><span class=\"line\">      <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        realPreload(data);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">void</span> <span class=\"title function_\">cancelPreloadURLIfNeeded</span><span class=\"params\">(String url)</span> &#123;</span><br><span class=\"line\">    cancelList.add(url);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">void</span> <span class=\"title function_\">cancelAnyPreLoads</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    handler.removeCallbacksAndMessages(<span class=\"literal\">null</span>);</span><br><span class=\"line\">    cancelList.clear();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">realPreload</span><span class=\"params\">(VideoPreLoadModel data)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (data == <span class=\"literal\">null</span> || isCancel(data.originalUrl)) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"type\">HttpURLConnection</span> <span class=\"variable\">conn</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">      <span class=\"type\">URL</span> <span class=\"variable\">myURL</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">URL</span>(data.proxyUrl);</span><br><span class=\"line\">      conn = (HttpURLConnection) myURL.openConnection();</span><br><span class=\"line\">      conn.connect();</span><br><span class=\"line\">      <span class=\"type\">InputStream</span> <span class=\"variable\">is</span> <span class=\"operator\">=</span> conn.getInputStream();</span><br><span class=\"line\">      <span class=\"type\">byte</span>[] buf = <span class=\"keyword\">new</span> <span class=\"title class_\">byte</span>[<span class=\"number\">1024</span>];</span><br><span class=\"line\">      <span class=\"type\">int</span> <span class=\"variable\">downLoadedSize</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">      <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">numRead</span> <span class=\"operator\">=</span> is.read(buf);</span><br><span class=\"line\">        downLoadedSize += numRead;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (downLoadedSize &gt;= data.preLoadBytes || numRead == -<span class=\"number\">1</span>) &#123; <span class=\"comment\">//Reached  preload range or end of Input stream.</span></span><br><span class=\"line\">          <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125; <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>);</span><br><span class=\"line\">      is.close();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ....</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"type\">boolean</span> <span class=\"title function_\">isCancel</span><span class=\"params\">(String url)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (TextUtils.isEmpty(url)) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (String cancelUrl : cancelList) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (cancelUrl.equals(url)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>对于这段代码中其实有“两个”队列，一个是HandlerThread中的队列，熟悉消息机制的同学应该都能明白，内部是一个looper在不断地循环获取消息，当一个消息处理完毕之后才会处理下一个消息。我还定义了一个就是取消队列，因为HandlerThread中的任务我们不太好控制取消具体的任务，所以设置了一个取消队列，当之后的消息再需要执行的时候会首先判断是否是在取消队列里面，这样子就能做到对预加载队列逻辑的控制。</p>\n<h2 id=\"二、关于一些细节问题\"><a href=\"#二、关于一些细节问题\" class=\"headerlink\" title=\"二、关于一些细节问题\"></a>二、关于一些细节问题</h2><p>这样子我们在播放一个视频的时候，只需要传给我们接下来将会播放的视频的URL，我们就能对其预加载并缓存下来，但是会存在其他条件：</p>\n<h5 id=\"预加载的长度？\"><a href=\"#预加载的长度？\" class=\"headerlink\" title=\"预加载的长度？\"></a>预加载的长度？</h5><p>对于视频加载长度，我们很容易想到在视频url请求加入Range在header上面，比如</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">conn.addRequestProperty(<span class=\"string\">&quot;Range&quot;</span>, <span class=\"string\">&quot;0-102400&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n<p>我们只获取前102400 bytes，不用将整个视频全部进行预加载，我有进行这样的尝试，但是实际发现是有坑的。我做了很多尝试，发现不论怎么请求，拿到的 responseCode 虽然是206，但是 还是把数据给全部下载完了，这就有点不科学了！！</p>\n<p>最终去源码中才发现：源码有对range做正则匹配</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">Pattern</span> <span class=\"variable\">RANGE_HEADER_PATTERN</span> <span class=\"operator\">=</span> Pattern.compile(<span class=\"string\">&quot;[R,r]ange:[ ]?bytes=(\\\\d*)-&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"type\">long</span> <span class=\"title function_\">findRangeOffset</span><span class=\"params\">(String request)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">Matcher</span> <span class=\"variable\">matcher</span> <span class=\"operator\">=</span> RANGE_HEADER_PATTERN.matcher(request);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (matcher.find()) &#123;</span><br><span class=\"line\">            <span class=\"type\">String</span> <span class=\"variable\">rangeValue</span> <span class=\"operator\">=</span> matcher.group(<span class=\"number\">1</span>);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> Long.parseLong(rangeValue);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>看清楚了 <strong><em>“[R,r]ange:[ ]?bytes&#x3D;(\\d</em>)-“</strong>* 它只去匹配了前面的的，也就是说 我传入了 0-102400 它最终只当作是：Range：0- 来处理，导致addRequestProperty设置的range实现。坑！不过能理解作者为什么这么做，后面总结会讲到。没有办法只有使用最原始的方法进行判断了：在每次获取inputStream的时候进行判断是否达到预加载的大小，虽然有一定的性能开销，但是不去改源码的话也没有 办法了。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">      <span class=\"type\">int</span> <span class=\"variable\">numRead</span> <span class=\"operator\">=</span> is.read(buf);</span><br><span class=\"line\">      downLoadedSize += numRead;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (downLoadedSize &gt;= data.preLoadBytes || numRead == -<span class=\"number\">1</span>) &#123; <span class=\"comment\">//Reached  preload range or end of Input stream.</span></span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>);</span><br><span class=\"line\">    is.close();</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"三、总结\"><a href=\"#三、总结\" class=\"headerlink\" title=\"三、总结\"></a>三、总结</h2><p>本文主要讲了基于AndroidVideoCache的预加载具体实现原理，以及其中遇到的坑</p>\n<p>1、预加载主要通过HandlerThread去实现后台网络的访问以及缓存的处理逻辑</p>\n<p>2、加入取消队列去控制对应需要取消的任务</p>\n<p>3、对于预加载的size只能通过读取的时候进行判断，没有办法使用range去判断。其实很容易理解作者为什么正则要这样写，因为它只是一个视频缓存框架，主要是用来做“边播边存”，所以每次去进行请求的时候应该都是在原有的缓存之上去进行缓存数据处理，而缓存最终需要处理完的就是 content-size，不需要再去管Range中的结束范围了。</p>\n","categories":[{"name":"技术文章","slug":"technology","api":"api/categories/technology.json"}],"tags":[{"name":"音视频","slug":"音视频","api":"api/tags/音视频.json"}],"api":"api/posts/2020/07/06/基于AndroidVideoCache的预加载.json"},{"title":"《82年生的金智英》","slug":"《82年生的金智英》","date":"2020-06-26T10:49:00.000Z","updated":"2025-05-20T11:46:57.000Z","comments":true,"url":"2020/06/26/《82年生的金智英》/","excerpt":"<p>今天一口气把《82年生的金智英》书和电影都看完了，电影的节奏是很压抑的，又是韩国一种“生病”的故事套路，因为有看过书，所以整部电影是带着期待感下去的，想去看看电影的结局到底是怎么样，和书中的结局有什么区别（书中其实没有结局，只是平淡地讲整个故事给叙述了一遍）。当第一次看到这书名的时候，以为这是一本以“金智英”为主体的个人成长奋斗故事。然而并没有那么简单……与其这是一部关于“金智英”的小说，倒不如说是一部关于韩国现实女性的纪录片。</p>\n<p>整本书按照时间顺序讲述金智英从一九八二年出生开始到二〇一五，故事按时分为几个章节：小学初中、高中大学、职场、婚后。在人生故事的每一个阶段，都充斥着对女性的不公，每个阶段讲述的故事大抵也是很普通的故事，没有十恶不赦的大恶人，让她受到伤害的是整个社会文化风气，这才是最揪心的。书以二〇一六最新的“治疗”结果结尾，也并没有说明‘病“好了，并叙述了作者自己周围女性的境遇，你我身边都有很多“金智英”。</p>\n<p>为什么主角叫“金智英”？因为在一九八二年出生的女性中，“金智英”是一个很常见的名字，在韩国“金智英”是一个很常见的名字，她代表了一众女性群体。然而书中的金智英在韩国，过得并不是最辛苦的，她有受到过良好的高等教育，她还有支持她的妈妈、赏识她的上司、关心她的老公、理解她的朋友，但她依然在社会中因为是“女性”，而艰难地挣扎着。</p>\n<p>看完整部书和电影，我一直有一种对生活在韩国的女性的遭遇的同情，也为生活在中国的女性而感到幸运。然而细想，真的是这样子么？也许自己不是女性，所以对很多都不太了解，但是自己也能感受到一些。举一个例子，曾在脉脉动态上有看到这样的简历介绍:结婚了，孩子两岁了，不打算要二胎。 简历介绍其实也透露出社会的现状，具体就不再细谈，懂的人自然懂。我们应该感激自己周围的女性，她们真的很不容易，也许是一些固化的思维，我们感受不到其中的细节罢了。</p>\n<p>但可悲的是，这本书被贴上了女性主义的标签，甚至女q主义者拿这本书当做“资本”，借用书中最后的译后记中</p>\n<blockquote>\n<p>艾玛·沃特森在国际妇女节中说的话，她重申自己的核心理念：“争取的是不是女权，而是两性的自由”。本书希望的是能够让更多的那行对于女性的处境有所了解，相互体谅，帮助彼此。希望世界变得更加美好，女生不再成为某些事件的筛选条件；而这需要女人的自觉与男人的换位思考。</p>\n</blockquote>\n","cover":null,"images":[],"content":"<p>今天一口气把《82年生的金智英》书和电影都看完了，电影的节奏是很压抑的，又是韩国一种“生病”的故事套路，因为有看过书，所以整部电影是带着期待感下去的，想去看看电影的结局到底是怎么样，和书中的结局有什么区别（书中其实没有结局，只是平淡地讲整个故事给叙述了一遍）。当第一次看到这书名的时候，以为这是一本以“金智英”为主体的个人成长奋斗故事。然而并没有那么简单……与其这是一部关于“金智英”的小说，倒不如说是一部关于韩国现实女性的纪录片。</p>\n<p>整本书按照时间顺序讲述金智英从一九八二年出生开始到二〇一五，故事按时分为几个章节：小学初中、高中大学、职场、婚后。在人生故事的每一个阶段，都充斥着对女性的不公，每个阶段讲述的故事大抵也是很普通的故事，没有十恶不赦的大恶人，让她受到伤害的是整个社会文化风气，这才是最揪心的。书以二〇一六最新的“治疗”结果结尾，也并没有说明‘病“好了，并叙述了作者自己周围女性的境遇，你我身边都有很多“金智英”。</p>\n<p>为什么主角叫“金智英”？因为在一九八二年出生的女性中，“金智英”是一个很常见的名字，在韩国“金智英”是一个很常见的名字，她代表了一众女性群体。然而书中的金智英在韩国，过得并不是最辛苦的，她有受到过良好的高等教育，她还有支持她的妈妈、赏识她的上司、关心她的老公、理解她的朋友，但她依然在社会中因为是“女性”，而艰难地挣扎着。</p>\n<p>看完整部书和电影，我一直有一种对生活在韩国的女性的遭遇的同情，也为生活在中国的女性而感到幸运。然而细想，真的是这样子么？也许自己不是女性，所以对很多都不太了解，但是自己也能感受到一些。举一个例子，曾在脉脉动态上有看到这样的简历介绍:结婚了，孩子两岁了，不打算要二胎。 简历介绍其实也透露出社会的现状，具体就不再细谈，懂的人自然懂。我们应该感激自己周围的女性，她们真的很不容易，也许是一些固化的思维，我们感受不到其中的细节罢了。</p>\n<p>但可悲的是，这本书被贴上了女性主义的标签，甚至女q主义者拿这本书当做“资本”，借用书中最后的译后记中</p>\n<blockquote>\n<p>艾玛·沃特森在国际妇女节中说的话，她重申自己的核心理念：“争取的是不是女权，而是两性的自由”。本书希望的是能够让更多的那行对于女性的处境有所了解，相互体谅，帮助彼此。希望世界变得更加美好，女生不再成为某些事件的筛选条件；而这需要女人的自觉与男人的换位思考。</p>\n</blockquote>\n","categories":[{"name":"读书电影","slug":"movie","api":"api/categories/movie.json"}],"tags":[{"name":"读书","slug":"读书","api":"api/tags/读书.json"}],"api":"api/posts/2020/06/26/《82年生的金智英》.json"},{"title":"WeakHashMap与Java引用相关","slug":"WeakHashMap与Java引用相关","date":"2020-06-22T03:19:00.000Z","updated":"2025-05-20T11:46:57.000Z","comments":true,"url":"2020/06/22/WeakHashMap与Java引用相关/","excerpt":"<p>记得在很久之前有写过一篇<a href=\"https://blog.csdn.net/u010107153/article/details/102821282\">《Java中的Reference解析》</a>，主要讲的是Java中的四种引用方式与引用队列，不过这些都是基础的理论知识，最近开发项目中有使用到WeakHashMap，对于Java的引用以及引用队列有了更深的了解，在此做个相关总结。</p>\n<h2 id=\"一、WeakHashMap的实现方式\"><a href=\"#一、WeakHashMap的实现方式\" class=\"headerlink\" title=\"一、WeakHashMap的实现方式\"></a>一、WeakHashMap的实现方式</h2><p>总体来说，WeakHashMap的底层数据结构与HashMap的实现差不多，都是用“拉链法”来实现，主要区别在于WeakHashMap的Entry 继承于WeakReference，并维护一个ReferenceQueue，使其具有了“弱引用的特性”，其构造方法可以看出：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">Entry(Object key, V value,ReferenceQueue&lt;Object&gt; queue,<span class=\"type\">int</span> hash, Entry&lt;K,V&gt; next) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">super</span>(key, queue); <span class=\"comment\">//这里比较关键</span></span><br><span class=\"line\">            ……</span><br><span class=\"line\">        &#125;</span><br></pre></td></tr></table></figure>\n<p>其中的super父类的代码实现为：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"title function_\">WeakReference</span><span class=\"params\">(T referent, ReferenceQueue&lt;? <span class=\"built_in\">super</span> T&gt; q)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">super</span>(referent, q);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>通过对父类的构造方法可以知道，WeakMap的key值为弱引用类型，回顾一下弱引用的特点：<strong>垃圾收集器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。</strong> 于是WeakHashMap的作用就凸显出来了：**对于数据中Key-value，key因为使用的弱引用会被回收，而value也会得到对应的释放。**以我这次的需求为例：key为Webview页面或者Flutter&#x2F;RN页面，value为调用native方法相关存储的对象。当页面需要关闭调webivew的时候，Webview应该要被释放，要不然会产生内存泄漏，当其被释放之后，对应的value也没有意义了，所以也需要被释放掉。</p>\n<p> 那么WeakHashMap是如何让value释放的呢？</p>\n<h2 id=\"二、WeakHashMap如何释放无用的Value\"><a href=\"#二、WeakHashMap如何释放无用的Value\" class=\"headerlink\" title=\"二、WeakHashMap如何释放无用的Value\"></a>二、WeakHashMap如何释放无用的Value</h2><p>要回收无用的Value，那么引用队列（ReferenceQueue）就派上用场了，回顾一下引用队列的作用：<strong>当一个引用（软引用、弱引用）关联到了一个引用队列后，当这个引用所引用的对象要被垃圾回收时，就会将它加入到所关联的引用队列中。</strong><br>所以判断一个引用对象是否已经被回收的一个现象就是，这个对象的引用是否被加入到了它所关联的引用队列。<br>那么对于WeakHashMap也是利用这一点特性，在其代码中put\\get等方法都有执行对应等检查</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> V <span class=\"title function_\">put</span><span class=\"params\">(K key, V value)</span> &#123;</span><br><span class=\"line\">       <span class=\"type\">Object</span> <span class=\"variable\">k</span> <span class=\"operator\">=</span> maskNull(key);</span><br><span class=\"line\">       <span class=\"type\">int</span> <span class=\"variable\">h</span> <span class=\"operator\">=</span> hash(k);</span><br><span class=\"line\">       Entry&lt;K,V&gt;[] tab = getTable(); <span class=\"comment\">//具体实现在getTable执行的expungeStaleEntries里面</span></span><br><span class=\"line\">       ……</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> V <span class=\"title function_\">get</span><span class=\"params\">(Object key)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">Object</span> <span class=\"variable\">k</span> <span class=\"operator\">=</span> maskNull(key);</span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">h</span> <span class=\"operator\">=</span> hash(k);</span><br><span class=\"line\">    Entry&lt;K,V&gt;[] tab = getTable();</span><br><span class=\"line\">    ……</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Expunges stale entries from the table.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">expungeStaleEntries</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (Object x; (x = queue.poll()) != <span class=\"literal\">null</span>; ) &#123; <span class=\"comment\">//这里的queue就是引用队列</span></span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span> (queue) &#123; </span><br><span class=\"line\">            <span class=\"meta\">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class=\"line\">                Entry&lt;K,V&gt; e = (Entry&lt;K,V&gt;) x;</span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> indexFor(e.hash, table.length);</span><br><span class=\"line\"></span><br><span class=\"line\">            Entry&lt;K,V&gt; prev = table[i];</span><br><span class=\"line\">            Entry&lt;K,V&gt; p = prev;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (p != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">                Entry&lt;K,V&gt; next = p.next;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (p == e) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (prev == e)</span><br><span class=\"line\">                        table[i] = next;</span><br><span class=\"line\">                    <span class=\"keyword\">else</span></span><br><span class=\"line\">                        prev.next = next;</span><br><span class=\"line\">                    <span class=\"comment\">// Must not null out e.next;</span></span><br><span class=\"line\">                    <span class=\"comment\">// stale entries may be in use by a HashIterator</span></span><br><span class=\"line\">                    e.value = <span class=\"literal\">null</span>; <span class=\"comment\">// Help GC</span></span><br><span class=\"line\">                    size--;</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                prev = p;</span><br><span class=\"line\">                p = next;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>从上面的代码逻辑可以很清楚的知道：WeakHashMap通过对引用队列的数据进行检查，对key被回收对象的对应Value进行了回收。</p>\n<h2 id=\"三、总结\"><a href=\"#三、总结\" class=\"headerlink\" title=\"三、总结\"></a>三、总结</h2><p>1、WeakHashMap的Entry 继承于WeakReference，并维护一个ReferenceQueue<br>2、在执行get\\put等相关数据操作的时候 会对数据进行相关处理，主要是清除掉无用对象对</p>\n","cover":null,"images":[],"content":"<p>记得在很久之前有写过一篇<a href=\"https://blog.csdn.net/u010107153/article/details/102821282\">《Java中的Reference解析》</a>，主要讲的是Java中的四种引用方式与引用队列，不过这些都是基础的理论知识，最近开发项目中有使用到WeakHashMap，对于Java的引用以及引用队列有了更深的了解，在此做个相关总结。</p>\n<h2 id=\"一、WeakHashMap的实现方式\"><a href=\"#一、WeakHashMap的实现方式\" class=\"headerlink\" title=\"一、WeakHashMap的实现方式\"></a>一、WeakHashMap的实现方式</h2><p>总体来说，WeakHashMap的底层数据结构与HashMap的实现差不多，都是用“拉链法”来实现，主要区别在于WeakHashMap的Entry 继承于WeakReference，并维护一个ReferenceQueue，使其具有了“弱引用的特性”，其构造方法可以看出：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">Entry(Object key, V value,ReferenceQueue&lt;Object&gt; queue,<span class=\"type\">int</span> hash, Entry&lt;K,V&gt; next) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">super</span>(key, queue); <span class=\"comment\">//这里比较关键</span></span><br><span class=\"line\">            ……</span><br><span class=\"line\">        &#125;</span><br></pre></td></tr></table></figure>\n<p>其中的super父类的代码实现为：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"title function_\">WeakReference</span><span class=\"params\">(T referent, ReferenceQueue&lt;? <span class=\"built_in\">super</span> T&gt; q)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">super</span>(referent, q);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>通过对父类的构造方法可以知道，WeakMap的key值为弱引用类型，回顾一下弱引用的特点：<strong>垃圾收集器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。</strong> 于是WeakHashMap的作用就凸显出来了：**对于数据中Key-value，key因为使用的弱引用会被回收，而value也会得到对应的释放。**以我这次的需求为例：key为Webview页面或者Flutter&#x2F;RN页面，value为调用native方法相关存储的对象。当页面需要关闭调webivew的时候，Webview应该要被释放，要不然会产生内存泄漏，当其被释放之后，对应的value也没有意义了，所以也需要被释放掉。</p>\n<p> 那么WeakHashMap是如何让value释放的呢？</p>\n<h2 id=\"二、WeakHashMap如何释放无用的Value\"><a href=\"#二、WeakHashMap如何释放无用的Value\" class=\"headerlink\" title=\"二、WeakHashMap如何释放无用的Value\"></a>二、WeakHashMap如何释放无用的Value</h2><p>要回收无用的Value，那么引用队列（ReferenceQueue）就派上用场了，回顾一下引用队列的作用：<strong>当一个引用（软引用、弱引用）关联到了一个引用队列后，当这个引用所引用的对象要被垃圾回收时，就会将它加入到所关联的引用队列中。</strong><br>所以判断一个引用对象是否已经被回收的一个现象就是，这个对象的引用是否被加入到了它所关联的引用队列。<br>那么对于WeakHashMap也是利用这一点特性，在其代码中put\\get等方法都有执行对应等检查</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> V <span class=\"title function_\">put</span><span class=\"params\">(K key, V value)</span> &#123;</span><br><span class=\"line\">       <span class=\"type\">Object</span> <span class=\"variable\">k</span> <span class=\"operator\">=</span> maskNull(key);</span><br><span class=\"line\">       <span class=\"type\">int</span> <span class=\"variable\">h</span> <span class=\"operator\">=</span> hash(k);</span><br><span class=\"line\">       Entry&lt;K,V&gt;[] tab = getTable(); <span class=\"comment\">//具体实现在getTable执行的expungeStaleEntries里面</span></span><br><span class=\"line\">       ……</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> V <span class=\"title function_\">get</span><span class=\"params\">(Object key)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">Object</span> <span class=\"variable\">k</span> <span class=\"operator\">=</span> maskNull(key);</span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">h</span> <span class=\"operator\">=</span> hash(k);</span><br><span class=\"line\">    Entry&lt;K,V&gt;[] tab = getTable();</span><br><span class=\"line\">    ……</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Expunges stale entries from the table.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">expungeStaleEntries</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (Object x; (x = queue.poll()) != <span class=\"literal\">null</span>; ) &#123; <span class=\"comment\">//这里的queue就是引用队列</span></span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span> (queue) &#123; </span><br><span class=\"line\">            <span class=\"meta\">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class=\"line\">                Entry&lt;K,V&gt; e = (Entry&lt;K,V&gt;) x;</span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> indexFor(e.hash, table.length);</span><br><span class=\"line\"></span><br><span class=\"line\">            Entry&lt;K,V&gt; prev = table[i];</span><br><span class=\"line\">            Entry&lt;K,V&gt; p = prev;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (p != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">                Entry&lt;K,V&gt; next = p.next;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (p == e) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (prev == e)</span><br><span class=\"line\">                        table[i] = next;</span><br><span class=\"line\">                    <span class=\"keyword\">else</span></span><br><span class=\"line\">                        prev.next = next;</span><br><span class=\"line\">                    <span class=\"comment\">// Must not null out e.next;</span></span><br><span class=\"line\">                    <span class=\"comment\">// stale entries may be in use by a HashIterator</span></span><br><span class=\"line\">                    e.value = <span class=\"literal\">null</span>; <span class=\"comment\">// Help GC</span></span><br><span class=\"line\">                    size--;</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                prev = p;</span><br><span class=\"line\">                p = next;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>从上面的代码逻辑可以很清楚的知道：WeakHashMap通过对引用队列的数据进行检查，对key被回收对象的对应Value进行了回收。</p>\n<h2 id=\"三、总结\"><a href=\"#三、总结\" class=\"headerlink\" title=\"三、总结\"></a>三、总结</h2><p>1、WeakHashMap的Entry 继承于WeakReference，并维护一个ReferenceQueue<br>2、在执行get\\put等相关数据操作的时候 会对数据进行相关处理，主要是清除掉无用对象对</p>\n","categories":[{"name":"技术文章","slug":"technology","api":"api/categories/technology.json"}],"tags":[{"name":"Java","slug":"java","api":"api/tags/java.json"}],"api":"api/posts/2020/06/22/WeakHashMap与Java引用相关.json"}],"info":{"type":"index"}},"api":"api/posts/page.4.json"}