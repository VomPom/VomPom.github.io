{"data":{"title":"3D LUT 滤镜 shader 源码分析","slug":"LUT-Shader-源码分析","description":"","date":"2022-11-24T03:36:00.000Z","updated":"2025-09-15T13:11:04.747Z","language":"zh-CN","comments":true,"url":"2022/11/24/LUT-Shader-源码分析/","cover":null,"images":[],"content":"<p>最近在做滤镜相关的渲染学习，目前大部分 LUT 滤镜代码实现都是参考由 GPUImage 提供的 LookupFilter 的逻辑，整个代码实现不多。参考网上的博文也有各种解释，参考了大量博文之后终于理解了，所以自己重新整理了一份，方便以后阅读理解，对整体代码的实现过程结合LUT的原理进行一个简单整理。</p>\n<h2 id=\"GPUImageLookupFilter-shader-源码\"><a href=\"#GPUImageLookupFilter-shader-源码\" class=\"headerlink\" title=\"GPUImageLookupFilter shader 源码\"></a>GPUImageLookupFilter shader 源码</h2><figure class=\"highlight glsl\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">varying</span> <span class=\"keyword\">highp</span> <span class=\"type\">vec2</span> textureCoordinate;      </span><br><span class=\"line\"><span class=\"keyword\">varying</span> <span class=\"keyword\">highp</span> <span class=\"type\">vec2</span> textureCoordinate2;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">uniform</span> <span class=\"type\">sampler2D</span> inputImageTexture;  <span class=\"comment\">// 目标纹理，对应原始资源</span></span><br><span class=\"line\"><span class=\"keyword\">uniform</span> <span class=\"type\">sampler2D</span> inputImageTexture2; <span class=\"comment\">// 查找表纹理，对应LUT图片</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">uniform</span> <span class=\"keyword\">lowp</span> <span class=\"type\">float</span> intensity;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> main()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">//获取原始图层颜色</span></span><br><span class=\"line\">    <span class=\"keyword\">highp</span> <span class=\"type\">vec4</span> textureColor = <span class=\"built_in\">texture2D</span>(inputImageTexture, textureCoordinate);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//获取蓝色通道颜色，textureColor.b 的范围为(0,1)，blueColor 范围为(0,63) </span></span><br><span class=\"line\">    <span class=\"keyword\">highp</span> <span class=\"type\">float</span> blueColor = textureColor.b * <span class=\"number\">63.0</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//quad1为查找颜色所在左边位置的小正方形</span></span><br><span class=\"line\">    <span class=\"keyword\">highp</span> <span class=\"type\">vec2</span> quad1;</span><br><span class=\"line\">    quad1.y = <span class=\"built_in\">floor</span>(<span class=\"built_in\">floor</span>(blueColor) / <span class=\"number\">8.0</span>);</span><br><span class=\"line\">    quad1.x = <span class=\"built_in\">floor</span>(blueColor) - (quad1.y * <span class=\"number\">8.0</span>);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//quad2为查找颜色所在右边位置的小正方形</span></span><br><span class=\"line\">    <span class=\"keyword\">highp</span> <span class=\"type\">vec2</span> quad2;</span><br><span class=\"line\">    quad2.y = <span class=\"built_in\">floor</span>(<span class=\"built_in\">ceil</span>(blueColor) / <span class=\"number\">8.0</span>);</span><br><span class=\"line\">    quad2.x = <span class=\"built_in\">ceil</span>(blueColor) - (quad2.y * <span class=\"number\">8.0</span>);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//获取到左边小方形里面的颜色值</span></span><br><span class=\"line\">    <span class=\"keyword\">highp</span> <span class=\"type\">vec2</span> texPos1;</span><br><span class=\"line\">    texPos1.x = (quad1.x * <span class=\"number\">0.125</span>) + <span class=\"number\">0.5</span>/<span class=\"number\">512.0</span> + ((<span class=\"number\">0.125</span> - <span class=\"number\">1.0</span>/<span class=\"number\">512.0</span>) * textureColor.r);</span><br><span class=\"line\">    texPos1.y = (quad1.y * <span class=\"number\">0.125</span>) + <span class=\"number\">0.5</span>/<span class=\"number\">512.0</span> + ((<span class=\"number\">0.125</span> - <span class=\"number\">1.0</span>/<span class=\"number\">512.0</span>) * textureColor.g);</span><br><span class=\"line\">    </span><br><span class=\"line\">   <span class=\"comment\">//获取到右边小方形里面的颜色值</span></span><br><span class=\"line\">    <span class=\"keyword\">highp</span> <span class=\"type\">vec2</span> texPos2;</span><br><span class=\"line\">    texPos2.x = (quad2.x * <span class=\"number\">0.125</span>) + <span class=\"number\">0.5</span>/<span class=\"number\">512.0</span> + ((<span class=\"number\">0.125</span> - <span class=\"number\">1.0</span>/<span class=\"number\">512.0</span>) * textureColor.r);</span><br><span class=\"line\">    texPos2.y = (quad2.y * <span class=\"number\">0.125</span>) + <span class=\"number\">0.5</span>/<span class=\"number\">512.0</span> + ((<span class=\"number\">0.125</span> - <span class=\"number\">1.0</span>/<span class=\"number\">512.0</span>) * textureColor.g);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//获取对应位置纹理的颜色 RGBA 值</span></span><br><span class=\"line\">    <span class=\"keyword\">lowp</span> <span class=\"type\">vec4</span> newColor1 = <span class=\"built_in\">texture2D</span>(inputImageTexture2, texPos1);</span><br><span class=\"line\">    <span class=\"keyword\">lowp</span> <span class=\"type\">vec4</span> newColor2 = <span class=\"built_in\">texture2D</span>(inputImageTexture2, texPos2);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//真正的颜色是 newColor1 和 newColor2 的混合</span></span><br><span class=\"line\">    <span class=\"keyword\">lowp</span> <span class=\"type\">vec4</span> newColor = <span class=\"built_in\">mix</span>(newColor1, newColor2, <span class=\"built_in\">fract</span>(blueColor));</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">gl_FragColor</span> = <span class=\"built_in\">mix</span>(textureColor, <span class=\"type\">vec4</span>(newColor.rgb, textureColor.w), intensity);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<p>整个源码的主要逻辑为：<strong>查找颜色所在位置的小正方形、查找小正方形内的具体颜色、颜色混合</strong>。上面注释已将具体的实现过程描述清楚，但与我们的 LUT 图片割裂，接下来结合 LUT 的实现原理以及具体的数据来形象地描述整个实现流程。</p>\n<p>假设我们输入的参数为：<br>textureColor &#x3D; ver4(.0, .0, 0.5, 1.0)</p>\n<h2 id=\"查找颜色所在位置的小正方形\"><a href=\"#查找颜色所在位置的小正方形\" class=\"headerlink\" title=\"查找颜色所在位置的小正方形\"></a>查找颜色所在位置的小正方形</h2><p>我们知道LUT有64个小正方形，目标是为了找到对应小正方形里面的对应的颜色，我们需要先确认是第几个小正方形，正是通过 textureColor.b * 63 查找</p>\n<p>带入<code>blueColor</code> -&gt; textureColor.b &#x3D; 0.5<br>对 <code>textureColor.b * 63.0</code> &#x3D; 31.5</p>\n<p>也就是说我们需要第 [31.5] 位置小正方形，但是索引(从0-63共64个)都是正数，对于 31.5 索引 我们该怎么确定是 31 还是第 32 个呢？GPUImage给出的一种插值方式就是两个都要，然后进行一次混合，从而使得值能够俊均匀的在两个小正方形色块中。</p>\n<p>具体逻辑为：</p>\n<p>quad1.y &#x3D; floor(floor(blueColor) &#x2F; 8.0) &#x3D; 3，确定为小方块在纵坐标索引3，也就是第4行。</p>\n<img src=\"https://cdn.julis.wang/blog/img/f2e1e14bc30c4e438664b90fa5ad8103.png?imageView2/2/w/500\">\n\n<p><code>quad1.x = floor(blueColor) - (quad1.y * 8.0) = 31 - 24 = 7</code></p>\n<p>也就确定了小方块为(3,7) 也就是第4排第8个。</p>\n<img src=\"https://cdn.julis.wang/blog/img/bc8a47389a654dbeb5e4fc5e5584d1f9.png?imageView2/2/w/500\">\n<p>同理，对于第2个小方块确定的位置为(4,0) 也就是第5排第1个。</p>\n<p> <code>quad2.y = floor(ceil(blueColor) / 8.0) = 4</code></p>\n<p> <code>quad2.x = ceil(blueColor) - (quad2.y * 8.0)= 0</code></p>\n<h2 id=\"查找小正方形内的具体颜色\"><a href=\"#查找小正方形内的具体颜色\" class=\"headerlink\" title=\"查找小正方形内的具体颜色\"></a>查找小正方形内的具体颜色</h2><p>已经获取到对应的方块了，接下来需要确定方块内的像素的位置了。一般一个LUT的大小为 512x512，由8x8小方块构成，也就是每个方块的的像素为64x64，如下图所示：</p>\n<img src=\"https://cdn.julis.wang/blog/img/a4d6f390dd7b41fab75b568b37fb1e08.png?imageView2/2/w/500\">\n<p>计算x坐标的逻辑为：</p>\n<p><code>texPos1.x = (quad1.x * 0.125) + 0.5/512.0 + ((0.125 - 1.0/512.0) * textureColor.r)</code></p>\n<p>这一段是相对比较难理解的，我们可以分几部分进行理解：</p>\n<p>第一部分：<strong>(quad1.x * 0.125)</strong></p>\n<p>  我们得到 quad1.x &#x3D; 7，也就是第8列，*0.125将坐标转化在(0,1)之间，也就是得到在01坐标系内如图红线的位置。</p>\n<img src=\"https://cdn.julis.wang/blog/img/56098332877d4724beae4000c4fdf5fa.png?imageView2/2/w/500\">\n<p>第二部分：<strong>((0.125 - 1.0&#x2F;512.0) * textureColor.r)</strong></p>\n<p>我们可以把它当成 <code>(63.0/512.0)* textureColor.r</code> , <code>63.0/512.0</code>代表着一个512x512中每个小方块的64份数据（为什么是63？别忘了0的存在），textureColor.r 数据在 0-1之间，这样就能确认在第一部分结果基础之上的偏移值。</p>\n<img src=\"https://cdn.julis.wang/blog/img/7b3cba46937a4be4b0e45bc3077d3aad.png?imageView2/2/w/500\">\n<p>第三部分：<strong>0.5&#x2F;512.0</strong></p>\n<p>这一部分主要是 +0.5 做四舍五入运算，为保证第512行取到的是511.5&#x2F;512，第1行取到的是 0.5&#x2F;512.0。</p>\n<p>同理，计算y的坐标，以及计算另一个小正方形内的位置是一样的。</p>\n<p>最后在通过对从两个小正方形获取到的颜色进行 mix，并返回给着色器，GPU再对原始图像进行每一个像素点绘制，从而实现滤镜的效果。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>LUT 对应的 Shader 执行过程主要为：<strong>查找颜色所在位置的小正方形、查找小正方形内的具体颜色、颜色混合</strong>，整个流程都比较好理解，但代码相对而言比较难理解，网上看了很多其他的大佬写的一些文章，最开始自己看的时候也是很难理解的，后面终于悟了，所以想通过自己的理解，尽力更形象地解释（虽然可能也没有很形象），如果还有什么疑问，欢迎一起交流学习。</p>\n","raw":"title: 3D LUT 滤镜 shader 源码分析\nauthor: 落叶挽歌\ntags:\n  - 音视频\ncategories:\n  - 技术文章\ndate: 2022-11-24 11:36:00\n---\n最近在做滤镜相关的渲染学习，目前大部分 LUT 滤镜代码实现都是参考由 GPUImage 提供的 LookupFilter 的逻辑，整个代码实现不多。参考网上的博文也有各种解释，参考了大量博文之后终于理解了，所以自己重新整理了一份，方便以后阅读理解，对整体代码的实现过程结合LUT的原理进行一个简单整理。\n\n\n\n## GPUImageLookupFilter shader 源码\n\n```glsl\n varying highp vec2 textureCoordinate;      \n varying highp vec2 textureCoordinate2;\n \n uniform sampler2D inputImageTexture;  // 目标纹理，对应原始资源\n uniform sampler2D inputImageTexture2; // 查找表纹理，对应LUT图片\n \n uniform lowp float intensity;\n \n void main()\n {\n     //获取原始图层颜色\n     highp vec4 textureColor = texture2D(inputImageTexture, textureCoordinate);\n     \n     //获取蓝色通道颜色，textureColor.b 的范围为(0,1)，blueColor 范围为(0,63) \n     highp float blueColor = textureColor.b * 63.0;\n     \n     //quad1为查找颜色所在左边位置的小正方形\n     highp vec2 quad1;\n     quad1.y = floor(floor(blueColor) / 8.0);\n     quad1.x = floor(blueColor) - (quad1.y * 8.0);\n     \n     //quad2为查找颜色所在右边位置的小正方形\n     highp vec2 quad2;\n     quad2.y = floor(ceil(blueColor) / 8.0);\n     quad2.x = ceil(blueColor) - (quad2.y * 8.0);\n     \n     //获取到左边小方形里面的颜色值\n     highp vec2 texPos1;\n     texPos1.x = (quad1.x * 0.125) + 0.5/512.0 + ((0.125 - 1.0/512.0) * textureColor.r);\n     texPos1.y = (quad1.y * 0.125) + 0.5/512.0 + ((0.125 - 1.0/512.0) * textureColor.g);\n     \n    //获取到右边小方形里面的颜色值\n     highp vec2 texPos2;\n     texPos2.x = (quad2.x * 0.125) + 0.5/512.0 + ((0.125 - 1.0/512.0) * textureColor.r);\n     texPos2.y = (quad2.y * 0.125) + 0.5/512.0 + ((0.125 - 1.0/512.0) * textureColor.g);\n     \n     //获取对应位置纹理的颜色 RGBA 值\n     lowp vec4 newColor1 = texture2D(inputImageTexture2, texPos1);\n     lowp vec4 newColor2 = texture2D(inputImageTexture2, texPos2);\n     \n     //真正的颜色是 newColor1 和 newColor2 的混合\n     lowp vec4 newColor = mix(newColor1, newColor2, fract(blueColor));\n\n     gl_FragColor = mix(textureColor, vec4(newColor.rgb, textureColor.w), intensity);\n }\n ```\n\n\n整个源码的主要逻辑为：**查找颜色所在位置的小正方形、查找小正方形内的具体颜色、颜色混合**。上面注释已将具体的实现过程描述清楚，但与我们的 LUT 图片割裂，接下来结合 LUT 的实现原理以及具体的数据来形象地描述整个实现流程。\n\n假设我们输入的参数为：\ntextureColor = ver4(.0, .0, 0.5, 1.0)\n\n## 查找颜色所在位置的小正方形\n\n我们知道LUT有64个小正方形，目标是为了找到对应小正方形里面的对应的颜色，我们需要先确认是第几个小正方形，正是通过 textureColor.b * 63 查找\n\n带入`blueColor` -> textureColor.b = 0.5\n对 `textureColor.b * 63.0` = 31.5\n\n也就是说我们需要第 [31.5] 位置小正方形，但是索引(从0-63共64个)都是正数，对于 31.5 索引 我们该怎么确定是 31 还是第 32 个呢？GPUImage给出的一种插值方式就是两个都要，然后进行一次混合，从而使得值能够俊均匀的在两个小正方形色块中。\n\n\n具体逻辑为：\n\nquad1.y = floor(floor(blueColor) / 8.0) = 3，确定为小方块在纵坐标索引3，也就是第4行。\n\n\n{% qnimg f2e1e14bc30c4e438664b90fa5ad8103.png extend:?imageView2/2/w/500 %}\n\n`quad1.x = floor(blueColor) - (quad1.y * 8.0) = 31 - 24 = 7`\n\n也就确定了小方块为(3,7) 也就是第4排第8个。\n\n\n{% qnimg bc8a47389a654dbeb5e4fc5e5584d1f9.png extend:?imageView2/2/w/500 %}\n同理，对于第2个小方块确定的位置为(4,0) 也就是第5排第1个。\n\n `quad2.y = floor(ceil(blueColor) / 8.0) = 4`\n\n `quad2.x = ceil(blueColor) - (quad2.y * 8.0)= 0`\n\n## 查找小正方形内的具体颜色\n\n已经获取到对应的方块了，接下来需要确定方块内的像素的位置了。一般一个LUT的大小为 512x512，由8x8小方块构成，也就是每个方块的的像素为64x64，如下图所示：\n\n{% qnimg a4d6f390dd7b41fab75b568b37fb1e08.png extend:?imageView2/2/w/500 %}\n计算x坐标的逻辑为：\n\n`texPos1.x = (quad1.x * 0.125) + 0.5/512.0 + ((0.125 - 1.0/512.0) * textureColor.r)`\n\n这一段是相对比较难理解的，我们可以分几部分进行理解：\n\n第一部分：**(quad1.x * 0.125)**\n\n  我们得到 quad1.x = 7，也就是第8列，*0.125将坐标转化在(0,1)之间，也就是得到在01坐标系内如图红线的位置。\n\n{% qnimg 56098332877d4724beae4000c4fdf5fa.png extend:?imageView2/2/w/500 %}\n第二部分：**((0.125 - 1.0/512.0) * textureColor.r)**\n\n我们可以把它当成 `(63.0/512.0)* textureColor.r` , `63.0/512.0`代表着一个512x512中每个小方块的64份数据（为什么是63？别忘了0的存在），textureColor.r 数据在 0-1之间，这样就能确认在第一部分结果基础之上的偏移值。\n\n{% qnimg 7b3cba46937a4be4b0e45bc3077d3aad.png extend:?imageView2/2/w/500 %}\n第三部分：**0.5/512.0**\n\n这一部分主要是 +0.5 做四舍五入运算，为保证第512行取到的是511.5/512，第1行取到的是 0.5/512.0。\n\n同理，计算y的坐标，以及计算另一个小正方形内的位置是一样的。\n\n最后在通过对从两个小正方形获取到的颜色进行 mix，并返回给着色器，GPU再对原始图像进行每一个像素点绘制，从而实现滤镜的效果。\n\n\n## 总结\n\nLUT 对应的 Shader 执行过程主要为：**查找颜色所在位置的小正方形、查找小正方形内的具体颜色、颜色混合**，整个流程都比较好理解，但代码相对而言比较难理解，网上看了很多其他的大佬写的一些文章，最开始自己看的时候也是很难理解的，后面终于悟了，所以想通过自己的理解，尽力更形象地解释（虽然可能也没有很形象），如果还有什么疑问，欢迎一起交流学习。","categories":[{"name":"技术文章","api":"api/categories/technology.json"}],"tags":[{"name":"音视频","api":"api/tags/音视频.json"}]},"api":"api/posts/2022/11/24/LUT-Shader-源码分析.json"}