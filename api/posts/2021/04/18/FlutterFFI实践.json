{"data":{"title":"Flutter FFI实践","slug":"FlutterFFI实践","description":"","date":"2021-04-18T02:34:00.000Z","updated":"2025-05-20T11:46:57.000Z","language":"zh-CN","comments":true,"url":"2021/04/18/FlutterFFI实践/","cover":null,"images":[],"content":"<p>在 Android的开发中，我们有 <a href=\"https://developer.android.com/training/articles/perf-jni\">JNI</a> 使得 Java可以调用本地应用或库。<br>Flutter 在前不久发布了 <a href=\"https://developers.googleblog.com/2021/03/announcing-flutter-2.html\">Flutter2</a>，更新了 <a href=\"https://dart.dev/guides/libraries/c-interop\">FFI</a> (我们是否可以把它叫做DNI呢？)进入了稳定状态,开发者可以更安心的使用其功能。<br>但是相关的文档依然很欠缺，导致使用起来有诸多的疑问，以及相关原理性的介绍比较少，所以整理记录一下。</p>\n<h2 id=\"一、Dart-同步调用-Native-方法\"><a href=\"#一、Dart-同步调用-Native-方法\" class=\"headerlink\" title=\"一、Dart 同步调用 Native 方法\"></a>一、Dart 同步调用 Native 方法</h2><p>我们以最简单的demo为例,请求一个有参无返回值的C方法<br>在 C&#x2F;C++中有如下函数：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">extern</span> <span class=\"string\">&quot;C&quot;</span> __attribute__((visibility(<span class=\"string\">&quot;default&quot;</span>))) __attribute__((used))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">c_with_out_return_value</span><span class=\"params\">(<span class=\"type\">int</span> value)</span> &#123;</span><br><span class=\"line\">    LOG_D(<span class=\"string\">&quot;Got invoke value: %d&quot;</span>, value);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>Dart:</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">final</span> DynamicLibrary ffiLib = Platform.isAndroid ? DynamicLibrary.open(<span class=\"string\">&#x27;lib_invoke.so&#x27;</span>) : DynamicLibrary.process();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">final</span> cMethod = ffiLib.lookupFunction&lt;Void <span class=\"built_in\">Function</span>(Int32 value), <span class=\"keyword\">void</span> <span class=\"built_in\">Function</span>(<span class=\"built_in\">int</span> value)&gt;(<span class=\"string\">&#x27;c_with_out_return_value&#x27;</span>);</span><br><span class=\"line\">cMethod(<span class=\"number\">123</span>);  </span><br></pre></td></tr></table></figure>\n\n<p>这样一次调用就完成了一次调用，传递了123到Native并执行了一次打印，同理相关有参有返回值的请求也都是这样做到的，那 Dart 和 Native内部具体怎样实现的呢？</p>\n<p><code>DynamicLibrary.open()</code> 最终执行的逻辑如下, 源码位于<a href=\"https://github.com/dart-lang/sdk/blob/master/runtime/lib/ffi_dynamic_library.cc\">ffi_dynamic_library.cc</a>：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">void</span>* <span class=\"title function_\">LoadExtensionLibrary</span><span class=\"params\">(<span class=\"type\">const</span> <span class=\"type\">char</span>* library_file)</span> &#123;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">if</span> defined(HOST_OS_LINUX) || defined(HOST_OS_MACOS) ||                        \\</span></span><br><span class=\"line\"><span class=\"meta\">    defined(HOST_OS_ANDROID) || defined(HOST_OS_FUCHSIA)</span></span><br><span class=\"line\">  <span class=\"type\">void</span>* handle = dlopen(library_file, RTLD_LAZY);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (handle == nullptr) &#123;</span><br><span class=\"line\">    <span class=\"type\">char</span>* error = dlerror();</span><br><span class=\"line\">    <span class=\"type\">const</span> String&amp; msg = String::Handle(</span><br><span class=\"line\">        String::NewFormatted(<span class=\"string\">&quot;Failed to load dynamic library (%s)&quot;</span>, error));</span><br><span class=\"line\">    Exceptions::ThrowArgumentError(msg);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> handle;</span><br><span class=\"line\">  ……</span><br></pre></td></tr></table></figure>\n\n<p>可以看到最终使用 <a href=\"https://pubs.opengroup.org/onlinepubs/009696699/functions/dlopen.html\">dlopen</a> 加载动态链接库，并返回句柄。</p>\n<p>拿到对应的动态链接库的句柄之后，就能使用相关方法进行操作了。<br>句柄主要包含以下两个方法：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//在内存中查找对应符号名的地址，与dlsym()功能相同</span></span><br><span class=\"line\"><span class=\"keyword\">external</span> Pointer&lt;T&gt; lookup&lt;T <span class=\"keyword\">extends</span> NativeType&gt;(<span class=\"built_in\">String</span> symbolName);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//1、去动态库中查找对应名称的函数 </span></span><br><span class=\"line\"><span class=\"comment\">//2、将 Native 类型的 C/C++ 函数转化为 Dart 的 Function 类型</span></span><br><span class=\"line\"><span class=\"keyword\">external</span> F lookupFunction&lt;T <span class=\"keyword\">extends</span> <span class=\"built_in\">Function</span>, F <span class=\"keyword\">extends</span> <span class=\"built_in\">Function</span>&gt;(<span class=\"built_in\">String</span> symbolName);</span><br></pre></td></tr></table></figure>\n\n<p>其中lookup()的最终实现主要使用了 <a href=\"https://pubs.opengroup.org/onlinepubs/009695399/functions/dlsym.html\">dlsym</a></p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">void</span>* <span class=\"title function_\">ResolveSymbol</span><span class=\"params\">(<span class=\"type\">void</span>* handle, <span class=\"type\">const</span> <span class=\"type\">char</span>* symbol)</span> &#123;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">if</span> defined(HOST_OS_LINUX) || defined(HOST_OS_MACOS) ||                       </span></span><br><span class=\"line\">    defined(HOST_OS_ANDROID) || defined(HOST_OS_FUCHSIA)</span><br><span class=\"line\">  dlerror();  <span class=\"comment\">// Clear any errors.</span></span><br><span class=\"line\">  <span class=\"type\">void</span>* pointer = dlsym(handle, symbol);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (pointer == nullptr) &#123;</span><br><span class=\"line\">    <span class=\"type\">char</span>* error = dlerror();</span><br><span class=\"line\">    <span class=\"type\">const</span> String&amp; msg = String::Handle(</span><br><span class=\"line\">        String::NewFormatted(<span class=\"string\">&quot;Failed to lookup symbol (%s)&quot;</span>, error));</span><br><span class=\"line\">    Exceptions::ThrowArgumentError(msg);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> pointer;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"二、Dart-异步调用-Native-方法\"><a href=\"#二、Dart-异步调用-Native-方法\" class=\"headerlink\" title=\"二、Dart 异步调用 Native 方法\"></a>二、Dart 异步调用 Native 方法</h2><p>在很多场景我们不能像上述同步方法那样，dart 进行一次请求之后立马得到结果，可能会有一些耗时操作，为了不让 Flutter 的UI线程卡住，我们进行异步请求。那如何实现异步请求呢？<br>对于异步实现，官方并没有很明确的文档，都得靠自己琢磨，在官方的讨论中 <a href=\"https://github.com/dart-lang/sdk/issues/37022\">https://github.com/dart-lang/sdk/issues/37022</a> 以及 <a href=\"https://github.com/flutter/flutter/issues/63255\">https://github.com/flutter/flutter/issues/63255</a> 提到一些解决方案:</p>\n<blockquote>\n<p>1.In your C++ code include include&#x2F;dart_api_dl.h and include&#x2F;dart_api_dl.cc from here <a href=\"https://github.com/dart-lang/sdk/blob/master/runtime/include/\">https://github.com/dart-lang/sdk/blob/master/runtime/include/</a> (they also depend on include&#x2F;internal&#x2F;*).</p>\n<p>2.From Dart call Dart_InitializeApiDL passing NativeApi.initializeApiDLData as an argument.</p>\n<p>3.On Dart side create a ReceivePort and pass port number of the corresponding SendPort to the native side (port.sendPort.nativePort).</p>\n<p>4.Now on C++ side you can use Dart_PostCObject_DL to send messages back to Dart side from any thread.</p>\n</blockquote>\n<p>按上述的操作进行实现，接下来具体分析一些里面的逻辑原理。<br>1、导入include&#x2F;dart_api_dl.h include&#x2F;dart_api_dl.cc 相关的文件并在 CMakeList.txt进行相关配置<br>2、从dart中 调用Native中 Dart_InitializeApiDL</p>\n<p>Dart:</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> main() &#123;</span><br><span class=\"line\">  initializeApi(NativeApi.initializeApiDLData);</span><br><span class=\"line\">  runApp(MyApp());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>C++:</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Initialize `dart_api_dl.h`</span></span><br><span class=\"line\">DART_EXPORT <span class=\"type\">intptr_t</span> <span class=\"title function_\">InitDartApiDL</span><span class=\"params\">(<span class=\"type\">void</span> *data)</span> &#123;</span><br><span class=\"line\">    LOG_D(<span class=\"string\">&quot;InitDartApiDL&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> Dart_InitializeApiDL(data);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>在 initializeApi(NativeApi.initializeApiDLData) 中 initializeApi 向 Native请求 <code>DART_EXPORT intptr_t InitDartApiDL(void *data)</code>方法，传入的参数就是在 <a href=\"https://github.com/dart-lang/sdk/blob/master/runtime/include/dart_api_dl.h\">dart_api_dl.h</a><br> DART_NATIVE_API_DL_SYMBOLS 以及 DART_API_DL_SYMBOLS 中的方法。</p>\n<p>NativeApi.initializeApiDLData 逻辑：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">const</span> DartApiEntry dart_api_entries[] = &#123;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> ENTRY(name, R, A)                                                      \\</span></span><br><span class=\"line\"><span class=\"meta\">  DartApiEntry&#123;#name, reinterpret_cast<span class=\"string\">&lt;void (*)()&gt;</span>(name)&#125;,</span></span><br><span class=\"line\">    DART_API_ALL_DL_SYMBOLS(ENTRY)</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">undef</span> ENTRY</span></span><br><span class=\"line\">        DartApiEntry&#123;nullptr, nullptr&#125;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">const</span> DartApi dart_api_data = &#123;</span><br><span class=\"line\">    DART_API_DL_MAJOR_VERSION, DART_API_DL_MINOR_VERSION, dart_api_entries&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">DEFINE_NATIVE_ENTRY(DartApiDLInitializeData, <span class=\"number\">0</span>, <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> Integer::New(reinterpret_cast&lt;<span class=\"type\">intptr_t</span>&gt;(&amp;dart_api_data));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>dart_api_dl中定义的方法：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> DART_NATIVE_API_DL_SYMBOLS(F)                                          \\</span></span><br><span class=\"line\"><span class=\"meta\">  <span class=\"comment\">/***** dart_native_api.h *****/</span>                                              \\</span></span><br><span class=\"line\"><span class=\"meta\">  <span class=\"comment\">/* Dart_Port */</span>                                                              \\</span></span><br><span class=\"line\"><span class=\"meta\">  F(Dart_PostCObject, bool, (Dart_Port_DL port_id, Dart_CObject * message))    \\</span></span><br><span class=\"line\"><span class=\"meta\">  F(Dart_PostInteger, bool, (Dart_Port_DL port_id, int64_t message))           \\</span></span><br><span class=\"line\"><span class=\"meta\">  .....</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// dart_api.h symbols can only be called on Dart threads.</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> DART_API_DL_SYMBOLS(F)                                                 \\</span></span><br><span class=\"line\"><span class=\"meta\">  <span class=\"comment\">/***** dart_api.h *****/</span>                                                     \\</span></span><br><span class=\"line\"><span class=\"meta\">  <span class=\"comment\">/* Errors */</span>                                                                 \\</span></span><br><span class=\"line\"><span class=\"meta\">  F(Dart_IsError, bool, (Dart_Handle handle))                                  \\</span></span><br><span class=\"line\"><span class=\"meta\">  F(Dart_IsApiError, bool, (Dart_Handle handle))                               \\</span></span><br><span class=\"line\"><span class=\"meta\">  .....</span></span><br></pre></td></tr></table></figure>\n\n<p>其实这上面的逻辑很简单，主要是为了让业务中的代码能够进行动态链接，从而调用到 Flutter SDK 中相关方法。</p>\n<p>3、第三步添加 ReceivePort 监听</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Work</span> <span class=\"keyword\">extends</span> <span class=\"title\">Opaque</span> </span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">void</span> requestExecuteCallback(<span class=\"built_in\">dynamic</span> message) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">final</span> <span class=\"built_in\">int</span> workAddress = message <span class=\"keyword\">as</span> <span class=\"built_in\">int</span>;</span><br><span class=\"line\">  <span class=\"keyword\">final</span> Pointer&lt;Work&gt; work = Pointer&lt;Work&gt;.fromAddress(workAddress);</span><br><span class=\"line\">  executeCallback(work);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">final</span> ReceivePort interactiveCppRequests = ReceivePort()..listen(requestExecuteCallback);</span><br></pre></td></tr></table></figure>\n\n<p>向 Native 发送带有 interactiveCppRequests.sendPort.nativePort 的数据，为native异步回调做准备。</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">Future&lt;<span class=\"built_in\">int</span>&gt; platformAsync(<span class=\"built_in\">int</span> value1, <span class=\"built_in\">int</span> value2) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">final</span> Completer&lt;<span class=\"built_in\">int</span>&gt; completer = Completer&lt;<span class=\"built_in\">int</span>&gt;();</span><br><span class=\"line\">  <span class=\"keyword\">final</span> <span class=\"built_in\">String</span> cid = uuid.v1();</span><br><span class=\"line\">  <span class=\"keyword\">final</span> Pointer&lt;Utf8&gt; cidPtr = cid.toNativeUtf8();</span><br><span class=\"line\">  completerMapping[cid] = completer;</span><br><span class=\"line\">  <span class=\"comment\">//生成一个nativePort，为native异步回调做准备</span></span><br><span class=\"line\">  <span class=\"keyword\">final</span> <span class=\"built_in\">int</span> nativePort = interactiveCppRequests.sendPort.nativePort; </span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">final</span> cMethod = ffiLib.lookupFunction&lt;</span><br><span class=\"line\">      Int32 <span class=\"built_in\">Function</span>(Pointer&lt;Utf8&gt; cId, Int64 sendPort, Int32 value1, Int32 value2,</span><br><span class=\"line\">          Pointer&lt;NativeFunction&lt;callback_type&gt;&gt; callbackBlock),</span><br><span class=\"line\">      <span class=\"built_in\">int</span> <span class=\"built_in\">Function</span>(Pointer&lt;Utf8&gt; cId, <span class=\"built_in\">int</span> sendPort, <span class=\"built_in\">int</span> value1, <span class=\"built_in\">int</span> value2,</span><br><span class=\"line\">          Pointer&lt;NativeFunction&lt;callback_type&gt;&gt; callbackBlock)&gt;(<span class=\"string\">&#x27;platform_async&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  cMethod(cidPtr, nativePort, value1, value2, Pointer.fromFunction&lt;callback_type&gt;(_callbackBlocking));</span><br><span class=\"line\">  <span class=\"keyword\">return</span> completer.future;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>4、当异步执行完成之后，在 Native 执行 Dart_PostCObject_DL 通知 Dart 已经得到结果<br>对于代码如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">response</span><span class=\"params\">(jint result)</span> </span>&#123;</span><br><span class=\"line\">    Work work = [_callback,result] &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (_callback != <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">            _callback( result);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"built_in\">LOG_E</span>(<span class=\"string\">&quot;_callback == null&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    <span class=\"comment\">// Copy to heap to make it outlive the function scope.</span></span><br><span class=\"line\">    <span class=\"type\">const</span> Work *work_ptr = <span class=\"keyword\">new</span> <span class=\"built_in\">Work</span>(work);</span><br><span class=\"line\">    <span class=\"built_in\">NotifyDart</span>(send_port, work_ptr);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">NotifyDart</span><span class=\"params\">(Dart_Port send_port, <span class=\"type\">const</span> Work *work)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"type\">const</span> <span class=\"keyword\">auto</span> work_address = <span class=\"built_in\">reinterpret_cast</span>&lt;<span class=\"type\">intptr_t</span>&gt;(work);</span><br><span class=\"line\">    Dart_CObject dart_object;</span><br><span class=\"line\">    dart_object.type = Dart_CObject_kInt64;</span><br><span class=\"line\">    dart_object.value.as_int64 = work_address;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">const</span> <span class=\"type\">bool</span> result = <span class=\"built_in\">Dart_PostCObject_DL</span>(send_port, &amp;dart_object);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!result) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">LOG_D</span>(<span class=\"string\">&quot;FFI C  :  Posting message to port failed.&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面的代码最核心的就是<code>Dart_PostCObject_DL()</code>这里真正调用的还是，<code>Dart_PostCObject()</code>，加_DL()表示动态链接的方法，为了防止与原先符号冲突。</p>\n<blockquote>\n<p>All symbols are postfixed with _DL to indicate that they are dynamically</p>\n<p>linked and to prevent conflicts with the original symbol.</p>\n</blockquote>\n<p>我们继续看看  <code>Dart_PostCObject()</code>真正做了什么，Dart_PostCObject()最终调用的方法如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">bool</span> <span class=\"title function_\">PostCObjectHelper</span><span class=\"params\">(Dart_Port port_id, Dart_CObject* message)</span> &#123;</span><br><span class=\"line\">  ApiMessageWriter writer;</span><br><span class=\"line\">  <span class=\"built_in\">std</span>::<span class=\"built_in\">unique_ptr</span>&lt;Message&gt; msg =</span><br><span class=\"line\">      writer.WriteCMessage(message, port_id, Message::kNormalPriority);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (msg == nullptr) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Post the message at the given port.</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> PortMap::PostMessage(<span class=\"built_in\">std</span>::move(msg));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里在向 Service Isolate发送事件,最终 Dart 成功接受到异步消息的回调。<br>关于 Isolate 这一块的处理可以参考：<a href=\"https://medium.com/@codinghive.dev/async-coding-with-dart-isolates-b09c5ec00f8b\">Async Coding With Dart: Isolates</a></p>\n<h2 id=\"三、Native-调用-Dart方法\"><a href=\"#三、Native-调用-Dart方法\" class=\"headerlink\" title=\"三、Native 调用 Dart方法 ?\"></a>三、Native 调用 Dart方法 ?</h2><p>对于 JNI 里面，我们需要调用 Java的方法，利用Java反射机制调用即可，如下所示：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">_env-&gt;CallStaticVoidMethod(j_class, j_method, arg1, arg2);</span><br></pre></td></tr></table></figure>\n\n<p>如果 Native 想要调用 Dart代码有类似的代码可以用么？翻遍了 Flutter相关的文档，都没有找到对应的方法可以直接去调用 Dart的方法，Dart Engine内部有 <a href=\"https://github.com/dart-lang/sdk/blob/master/runtime/include/dart_api.h\">dart_api.h</a>提供了<code>Dart_invoke()</code>方法，但单纯的导入 .h文件在项目中是无法链接到对应的方法的，这也就是为什么需要导入<a href=\"https://github.com/dart-lang/sdk/tree/master/runtime/include\">ffi_runtime_lib</a>相关的文件并执行 <code>Dart_InitializeApiDL()</code>，通过动态链接使得代码能够去调用 Dart 封装的相关方法。</p>\n<p>所以参考 Dart中 <code>InitDartApiDL</code>的方法，我们先对 Dart 中的函数进行注册，传递对应方法的指针，然后在 Native 中即可调用，理论上可行，后续会补上相关  demo。<br>当然这只是一种骚操作，如果有更好的方法能够用 Native 调用 Dart 欢迎讨论。</p>\n<h2 id=\"四、总结\"><a href=\"#四、总结\" class=\"headerlink\" title=\"四、总结\"></a>四、总结</h2><p>文章记录了 Dart 同步和异步调用 Native 相关的使用，异步具体的使用比上述的代码复杂，因为需要一个中介记录异步相关的回调方法，当得到真正的结果之后，利用id查找到对应的方法再执行回调方法。FFI 在 Native中执行 dart 方法，暂时没有比较好的解决方案<br>FFI 调用可查看 <a href=\"https://github.com/VomPom/flutter_ffi_tutorial\">Demo flutter_ffi_tutorial</a></p>\n","raw":"title: Flutter FFI实践\nauthor: 落叶挽歌\nthumbnail: >-\n  https://cdn.pixabay.com/photo/2016/10/16/16/33/dual-screen-1745705_1280.png\n\ntags:\n  - Flutter\ncategories:\n  - 技术文章\ndate: 2021-04-18 10:34:00\n---\n\n在 Android的开发中，我们有 [JNI](https://developer.android.com/training/articles/perf-jni) 使得 Java可以调用本地应用或库。\nFlutter 在前不久发布了 [Flutter2](https://developers.googleblog.com/2021/03/announcing-flutter-2.html)，更新了 [FFI](https://dart.dev/guides/libraries/c-interop) (我们是否可以把它叫做DNI呢？)进入了稳定状态,开发者可以更安心的使用其功能。\n但是相关的文档依然很欠缺，导致使用起来有诸多的疑问，以及相关原理性的介绍比较少，所以整理记录一下。\n\n## 一、Dart 同步调用 Native 方法\n\n我们以最简单的demo为例,请求一个有参无返回值的C方法\n在 C/C++中有如下函数：\n\n```c\nextern \"C\" __attribute__((visibility(\"default\"))) __attribute__((used))\n\nvoid c_with_out_return_value(int value) {\n    LOG_D(\"Got invoke value: %d\", value);\n}\n```\n\nDart:\n\n```dart\nfinal DynamicLibrary ffiLib = Platform.isAndroid ? DynamicLibrary.open('lib_invoke.so') : DynamicLibrary.process();\n\nfinal cMethod = ffiLib.lookupFunction<Void Function(Int32 value), void Function(int value)>('c_with_out_return_value');\ncMethod(123);  \n```\n\n这样一次调用就完成了一次调用，传递了123到Native并执行了一次打印，同理相关有参有返回值的请求也都是这样做到的，那 Dart 和 Native内部具体怎样实现的呢？\n\n`DynamicLibrary.open()` 最终执行的逻辑如下, 源码位于[ffi_dynamic_library.cc](https://github.com/dart-lang/sdk/blob/master/runtime/lib/ffi_dynamic_library.cc)：\n\n```c\nstatic void* LoadExtensionLibrary(const char* library_file) {\n#if defined(HOST_OS_LINUX) || defined(HOST_OS_MACOS) ||                        \\\n    defined(HOST_OS_ANDROID) || defined(HOST_OS_FUCHSIA)\n  void* handle = dlopen(library_file, RTLD_LAZY);\n  if (handle == nullptr) {\n    char* error = dlerror();\n    const String& msg = String::Handle(\n        String::NewFormatted(\"Failed to load dynamic library (%s)\", error));\n    Exceptions::ThrowArgumentError(msg);\n  }\n  return handle;\n  ……\n```\n\n可以看到最终使用 [dlopen](https://pubs.opengroup.org/onlinepubs/009696699/functions/dlopen.html) 加载动态链接库，并返回句柄。\n\n拿到对应的动态链接库的句柄之后，就能使用相关方法进行操作了。\n句柄主要包含以下两个方法：\n\n```dart\n//在内存中查找对应符号名的地址，与dlsym()功能相同\nexternal Pointer<T> lookup<T extends NativeType>(String symbolName);\n\n//1、去动态库中查找对应名称的函数 \n//2、将 Native 类型的 C/C++ 函数转化为 Dart 的 Function 类型\nexternal F lookupFunction<T extends Function, F extends Function>(String symbolName);\n```\n\n其中lookup()的最终实现主要使用了 [dlsym](https://pubs.opengroup.org/onlinepubs/009695399/functions/dlsym.html)\n\n```c\nstatic void* ResolveSymbol(void* handle, const char* symbol) {\n#if defined(HOST_OS_LINUX) || defined(HOST_OS_MACOS) ||                       \n    defined(HOST_OS_ANDROID) || defined(HOST_OS_FUCHSIA)\n  dlerror();  // Clear any errors.\n  void* pointer = dlsym(handle, symbol);\n  if (pointer == nullptr) {\n    char* error = dlerror();\n    const String& msg = String::Handle(\n        String::NewFormatted(\"Failed to lookup symbol (%s)\", error));\n    Exceptions::ThrowArgumentError(msg);\n  }\n  return pointer;\n```\n\n## 二、Dart 异步调用 Native 方法\n\n在很多场景我们不能像上述同步方法那样，dart 进行一次请求之后立马得到结果，可能会有一些耗时操作，为了不让 Flutter 的UI线程卡住，我们进行异步请求。那如何实现异步请求呢？\n对于异步实现，官方并没有很明确的文档，都得靠自己琢磨，在官方的讨论中 https://github.com/dart-lang/sdk/issues/37022 以及 https://github.com/flutter/flutter/issues/63255 提到一些解决方案:\n\n>1.In your C++ code include include/dart_api_dl.h and include/dart_api_dl.cc from here https://github.com/dart-lang/sdk/blob/master/runtime/include/ (they also depend on include/internal/*).\n>\n>2.From Dart call Dart_InitializeApiDL passing NativeApi.initializeApiDLData as an argument.\n>\n>3.On Dart side create a ReceivePort and pass port number of the corresponding SendPort to the native side (port.sendPort.nativePort).\n>\n>4.Now on C++ side you can use Dart_PostCObject_DL to send messages back to Dart side from any thread.\n\n按上述的操作进行实现，接下来具体分析一些里面的逻辑原理。\n1、导入include/dart_api_dl.h include/dart_api_dl.cc 相关的文件并在 CMakeList.txt进行相关配置\n2、从dart中 调用Native中 Dart_InitializeApiDL\n\nDart:\n\n```dart\nvoid main() {\n  initializeApi(NativeApi.initializeApiDLData);\n  runApp(MyApp());\n}\n```\n\nC++:\n\n```c\n// Initialize `dart_api_dl.h`\nDART_EXPORT intptr_t InitDartApiDL(void *data) {\n    LOG_D(\"InitDartApiDL\");\n    return Dart_InitializeApiDL(data);\n}\n\n```\n\n在 initializeApi(NativeApi.initializeApiDLData) 中 initializeApi 向 Native请求 `DART_EXPORT intptr_t InitDartApiDL(void *data)`方法，传入的参数就是在 [dart_api_dl.h](https://github.com/dart-lang/sdk/blob/master/runtime/include/dart_api_dl.h)\n DART_NATIVE_API_DL_SYMBOLS 以及 DART_API_DL_SYMBOLS 中的方法。\n\nNativeApi.initializeApiDLData 逻辑：\n\n```c\nstatic const DartApiEntry dart_api_entries[] = {\n#define ENTRY(name, R, A)                                                      \\\n  DartApiEntry{#name, reinterpret_cast<void (*)()>(name)},\n    DART_API_ALL_DL_SYMBOLS(ENTRY)\n#undef ENTRY\n        DartApiEntry{nullptr, nullptr}};\n\nstatic const DartApi dart_api_data = {\n    DART_API_DL_MAJOR_VERSION, DART_API_DL_MINOR_VERSION, dart_api_entries};\n\nDEFINE_NATIVE_ENTRY(DartApiDLInitializeData, 0, 0) {\n  return Integer::New(reinterpret_cast<intptr_t>(&dart_api_data));\n}\n\n```\n\ndart_api_dl中定义的方法：\n\n```c\n#define DART_NATIVE_API_DL_SYMBOLS(F)                                          \\\n  /***** dart_native_api.h *****/                                              \\\n  /* Dart_Port */                                                              \\\n  F(Dart_PostCObject, bool, (Dart_Port_DL port_id, Dart_CObject * message))    \\\n  F(Dart_PostInteger, bool, (Dart_Port_DL port_id, int64_t message))           \\\n  .....\n\n// dart_api.h symbols can only be called on Dart threads.\n#define DART_API_DL_SYMBOLS(F)                                                 \\\n  /***** dart_api.h *****/                                                     \\\n  /* Errors */                                                                 \\\n  F(Dart_IsError, bool, (Dart_Handle handle))                                  \\\n  F(Dart_IsApiError, bool, (Dart_Handle handle))                               \\\n  .....\n```\n\n其实这上面的逻辑很简单，主要是为了让业务中的代码能够进行动态链接，从而调用到 Flutter SDK 中相关方法。\n\n3、第三步添加 ReceivePort 监听\n\n```dart\nclass Work extends Opaque {}\n\nvoid requestExecuteCallback(dynamic message) {\n  final int workAddress = message as int;\n  final Pointer<Work> work = Pointer<Work>.fromAddress(workAddress);\n  executeCallback(work);\n}\n\nfinal ReceivePort interactiveCppRequests = ReceivePort()..listen(requestExecuteCallback);\n```\n\n向 Native 发送带有 interactiveCppRequests.sendPort.nativePort 的数据，为native异步回调做准备。\n\n\n```dart\n\nFuture<int> platformAsync(int value1, int value2) {\n  final Completer<int> completer = Completer<int>();\n  final String cid = uuid.v1();\n  final Pointer<Utf8> cidPtr = cid.toNativeUtf8();\n  completerMapping[cid] = completer;\n  //生成一个nativePort，为native异步回调做准备\n  final int nativePort = interactiveCppRequests.sendPort.nativePort; \n  \n  final cMethod = ffiLib.lookupFunction<\n      Int32 Function(Pointer<Utf8> cId, Int64 sendPort, Int32 value1, Int32 value2,\n          Pointer<NativeFunction<callback_type>> callbackBlock),\n      int Function(Pointer<Utf8> cId, int sendPort, int value1, int value2,\n          Pointer<NativeFunction<callback_type>> callbackBlock)>('platform_async');\n\n  cMethod(cidPtr, nativePort, value1, value2, Pointer.fromFunction<callback_type>(_callbackBlocking));\n  return completer.future;\n}\n```\n\n4、当异步执行完成之后，在 Native 执行 Dart_PostCObject_DL 通知 Dart 已经得到结果\n对于代码如下：\n\n```c++\nvoid response(jint result) {\n    Work work = [_callback,result] {\n        if (_callback != nullptr) {\n            _callback( result);\n        } else {\n            LOG_E(\"_callback == null\");\n        }\n    };\n    // Copy to heap to make it outlive the function scope.\n    const Work *work_ptr = new Work(work);\n    NotifyDart(send_port, work_ptr);\n}\n\nvoid NotifyDart(Dart_Port send_port, const Work *work) {\n    const auto work_address = reinterpret_cast<intptr_t>(work);\n    Dart_CObject dart_object;\n    dart_object.type = Dart_CObject_kInt64;\n    dart_object.value.as_int64 = work_address;\n\n    const bool result = Dart_PostCObject_DL(send_port, &dart_object);\n    if (!result) {\n        LOG_D(\"FFI C  :  Posting message to port failed.\");\n    }\n}\n```\n\n上面的代码最核心的就是`Dart_PostCObject_DL()`这里真正调用的还是，`Dart_PostCObject()`，加_DL()表示动态链接的方法，为了防止与原先符号冲突。\n\n>All symbols are postfixed with _DL to indicate that they are dynamically\n>\n>linked and to prevent conflicts with the original symbol.\n\n我们继续看看  `Dart_PostCObject()`真正做了什么，Dart_PostCObject()最终调用的方法如下：\n\n```c\n\nstatic bool PostCObjectHelper(Dart_Port port_id, Dart_CObject* message) {\n  ApiMessageWriter writer;\n  std::unique_ptr<Message> msg =\n      writer.WriteCMessage(message, port_id, Message::kNormalPriority);\n\n  if (msg == nullptr) {\n    return false;\n  }\n\n  // Post the message at the given port.\n  return PortMap::PostMessage(std::move(msg));\n}\n```\n\n这里在向 Service Isolate发送事件,最终 Dart 成功接受到异步消息的回调。\n关于 Isolate 这一块的处理可以参考：[Async Coding With Dart: Isolates](https://medium.com/@codinghive.dev/async-coding-with-dart-isolates-b09c5ec00f8b)\n\n## 三、Native 调用 Dart方法 ?\n\n对于 JNI 里面，我们需要调用 Java的方法，利用Java反射机制调用即可，如下所示：\n\n```java\n_env->CallStaticVoidMethod(j_class, j_method, arg1, arg2);\n```\n\n如果 Native 想要调用 Dart代码有类似的代码可以用么？翻遍了 Flutter相关的文档，都没有找到对应的方法可以直接去调用 Dart的方法，Dart Engine内部有 [dart_api.h](https://github.com/dart-lang/sdk/blob/master/runtime/include/dart_api.h)提供了`Dart_invoke()`方法，但单纯的导入 .h文件在项目中是无法链接到对应的方法的，这也就是为什么需要导入[ffi_runtime_lib](https://github.com/dart-lang/sdk/tree/master/runtime/include)相关的文件并执行 `Dart_InitializeApiDL()`，通过动态链接使得代码能够去调用 Dart 封装的相关方法。\n\n所以参考 Dart中 `InitDartApiDL`的方法，我们先对 Dart 中的函数进行注册，传递对应方法的指针，然后在 Native 中即可调用，理论上可行，后续会补上相关  demo。\n当然这只是一种骚操作，如果有更好的方法能够用 Native 调用 Dart 欢迎讨论。\n\n## 四、总结\n\n文章记录了 Dart 同步和异步调用 Native 相关的使用，异步具体的使用比上述的代码复杂，因为需要一个中介记录异步相关的回调方法，当得到真正的结果之后，利用id查找到对应的方法再执行回调方法。FFI 在 Native中执行 dart 方法，暂时没有比较好的解决方案\nFFI 调用可查看 [Demo flutter_ffi_tutorial](https://github.com/VomPom/flutter_ffi_tutorial)","categories":[{"name":"技术文章","api":"api/categories/technology.json"}],"tags":[{"name":"Flutter","api":"api/tags/Flutter.json"}]},"api":"api/posts/2021/04/18/FlutterFFI实践.json"}