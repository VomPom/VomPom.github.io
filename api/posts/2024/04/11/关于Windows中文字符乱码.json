{"data":{"title":"UTF-8字符编码相关","slug":"关于Windows中文字符乱码","description":"","date":"2024-04-11T06:23:00.000Z","updated":"2025-05-20T11:46:57.000Z","language":"zh-CN","comments":true,"url":"2024/04/11/关于Windows中文字符乱码/","cover":null,"images":[],"content":"<p>最近在 Windows 上开发一些逻辑的时候遇到一些关于中文的坑，中文路径会乱码，是由于 Window 系统默认的编码格式是 <strong>GBK</strong>，而传入的参数编码格式是 <strong>UTF-8</strong>，导致整个程序出错。后续使用了&#96;&#96;MultiByteToWideChar<code> 和</code>WideCharToMultiByte&#96; 方法对编码进行一次改变，从而避免了这个问题的产生。但不了解相关原因，经过一番学习，对相关的概念进行一些简单的总结，并对一些 api  的实现源码进行分析。</p>\n<h3 id=\"ASCII-码\"><a href=\"#ASCII-码\" class=\"headerlink\" title=\"ASCII 码\"></a>ASCII 码</h3><p> ASCII ( American Standard Code for Information Interchange)<br> 256个符号，从 00000000 到 11111111    </p>\n<h3 id=\"ANSI\"><a href=\"#ANSI\" class=\"headerlink\" title=\"ANSI\"></a>ANSI</h3><p>ANSI（American National Standards Institute，美国国家标准协会）编码：ANSI 编码是一种基于 8 位的字符编码。它包含了 128 个美国英语字符和其他 128 个特殊字符，共 256 个字符。ANSI 编码主要用于表示英语字符，但它的局限性在于无法表示其他语言的字符。为了解决这个问题，各国家和地区分别制定了自己的 ANSI 编码标准，但这又引入了新的问题，即不同编码之间的互不兼容。</p>\n<p>​       美国和西欧：Windows-1252<br>​       中文（简体）：GB2312 或 GBK<br>​       中文（繁体）：Big5<br>​       日文：Shift-JIS<br>​       韩文：EUC-KR   </p>\n<h3 id=\"Unicode\"><a href=\"#Unicode\" class=\"headerlink\" title=\"Unicode\"></a>Unicode</h3><p>为了解决字符编码之间的兼容性问题，Unicode 标准应运而生。Unicode 是一种包含世界上大多数字符的编码方案，它为每个字符分配一个唯一的数字（称为码点），无论在任何平台、程序或语言中，都可以表示这些字符。Unicode 有多种实现方式，如 UTF-8、UTF-16 和 UTF-32。UTF-8 是最常用的 Unicode 实现方式，它是一种变长编码，可以使用 1 到 4 个字节来表示一个字符，这使得它在存储和传输方面更加高效</p>\n<p>  “FE FF” 是 Unicode 字符串的字节顺序标记（Byte Order Mark，简称 BOM），用于表示字符串的字节顺序<br>  Unicode Little-Endian，”FF FE”<br>  Unicode Big-Endian，”FE FF”</p>\n<h3 id=\"UTF-8\"><a href=\"#UTF-8\" class=\"headerlink\" title=\"UTF-8\"></a>UTF-8</h3><p>UTF-8 是 Unicode 的实现方式之一  ，是一种变长编码，它使用 1 到 4 个字节（8 位）来表示一个字符</p>\n<p><strong>单字节</strong>   所有的ASCII 字符<br><strong>二字节</strong>  带有附加符号的拉丁文、希腊文、西里尔字母、亚美尼亚语、希伯来文、阿拉伯文、叙利亚文及它拿字母则需要二个字节编码                </p>\n<p><strong>三字节</strong> 基本等同于GBK，含21000多个汉字 </p>\n<p><strong>四字节</strong> 中日韩超大字符集里面的汉字，有5万多个</p>\n<p><strong>UTF-8编码对照表</strong></p>\n<table>\n<thead>\n<tr>\n<th>Unicode 符号范围   (十六进制)</th>\n<th>UTF-8编码方式（二进制）</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>0000 0000 ~ 0000 007F</td>\n<td>0xxxxxxx</td>\n</tr>\n<tr>\n<td>0000 0080 ~ 0000 07FF</td>\n<td>110xxxxx 10xxxxxx</td>\n</tr>\n<tr>\n<td>0000 0800 ~ 0000 FFFF</td>\n<td>1110xxxx 10xxxxxx 10xxxxxx</td>\n</tr>\n<tr>\n<td>0001 0000 ~ 0010 FFFF</td>\n<td>11110xxx 10xxxxxx 10xxxxxx 10xxxxxx</td>\n</tr>\n</tbody></table>\n<h3 id=\"源码阅读：Java-String-toUtf8\"><a href=\"#源码阅读：Java-String-toUtf8\" class=\"headerlink\" title=\"源码阅读：Java String toUtf8\"></a>源码阅读：Java String toUtf8</h3><p> Java 的 String 默认用 UTF-16 存储数据，String 类的方法<code>.getBytes(StandardCharsets.UTF_8)</code> 将指定的字符集将字符串编码为 byte 序列，并将结果存储到一个新的 byte 数组中。</p>\n<p>其主要逻辑在:<a href=\"https://android.googlesource.com/platform/libcore/+/master/luni/src/main/java/libcore/util/CharsetUtils.java#46\">CharsetUtils.java#toUtf8Bytes</a></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">native</span> <span class=\"type\">byte</span>[] toUtf8Bytes(String s, <span class=\"type\">int</span> offset, <span class=\"type\">int</span> length);</span><br></pre></td></tr></table></figure>\n\n<p>对应的最终实现：<a href=\"https://android.googlesource.com/platform/libcore/+/3e8abdd9bdca823a635aac3adacf71ef227b18e1/luni/src/main/native/java_nio_charset_Charsets.cpp#183\">java_nio_charset_Charsets.cpp#Charsets_toUtf8Bytes</a> </p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">static</span> jbyteArray <span class=\"title\">Charsets_toUtf8Bytes</span><span class=\"params\">(JNIEnv* env, jclass, jcharArray javaChars, jint offset, jint length)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// ....此处省略 一些检查逻辑</span></span><br><span class=\"line\">    <span class=\"type\">const</span> <span class=\"type\">int</span> end = offset + length;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = offset; i &lt; end; ++i) &#123;</span><br><span class=\"line\">        jint ch = chars[i];</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (ch &lt; <span class=\"number\">0x80</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 单字节直接放进去</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!out.<span class=\"built_in\">append</span>(ch)) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (ch &lt; <span class=\"number\">0x800</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 双字节</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!out.<span class=\"built_in\">append</span>((ch &gt;&gt; <span class=\"number\">6</span>) | <span class=\"number\">0xc0</span>) || !out.<span class=\"built_in\">append</span>((ch &amp; <span class=\"number\">0x3f</span>) | <span class=\"number\">0x80</span>)) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"built_in\">U16_IS_SURROGATE</span>(ch)) &#123;</span><br><span class=\"line\">          \t<span class=\"comment\">// ....此处省略 UTF-16 代理字符串相关的逻辑</span></span><br><span class=\"line\">            ch = <span class=\"built_in\">U16_GET_SUPPLEMENTARY</span>(high, low);</span><br><span class=\"line\">            <span class=\"comment\">// 四字节 </span></span><br><span class=\"line\">            jbyte b1 = (ch &gt;&gt; <span class=\"number\">18</span>) | <span class=\"number\">0xf0</span>;</span><br><span class=\"line\">            jbyte b2 = ((ch &gt;&gt; <span class=\"number\">12</span>) &amp; <span class=\"number\">0x3f</span>) | <span class=\"number\">0x80</span>;</span><br><span class=\"line\">            jbyte b3 = ((ch &gt;&gt; <span class=\"number\">6</span>) &amp; <span class=\"number\">0x3f</span>) | <span class=\"number\">0x80</span>;</span><br><span class=\"line\">            jbyte b4 = (ch &amp; <span class=\"number\">0x3f</span>) | <span class=\"number\">0x80</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!out.<span class=\"built_in\">append</span>(b1) || !out.<span class=\"built_in\">append</span>(b2) || !out.<span class=\"built_in\">append</span>(b3) || !out.<span class=\"built_in\">append</span>(b4)) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 三字节.</span></span><br><span class=\"line\">            jbyte b1 = (ch &gt;&gt; <span class=\"number\">12</span>) | <span class=\"number\">0xe0</span>;</span><br><span class=\"line\">            jbyte b2 = ((ch &gt;&gt; <span class=\"number\">6</span>) &amp; <span class=\"number\">0x3f</span>) | <span class=\"number\">0x80</span>;</span><br><span class=\"line\">            jbyte b3 = (ch &amp; <span class=\"number\">0x3f</span>) | <span class=\"number\">0x80</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!out.<span class=\"built_in\">append</span>(b1) || !out.<span class=\"built_in\">append</span>(b2) || !out.<span class=\"built_in\">append</span>(b3)) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> out.<span class=\"built_in\">toByteArray</span>();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>整体的逻辑非常的好理解：判断输入值的区间，并分成单双三四字节的处理逻辑，其中有处理 UTF-16 代理字符串相关的逻辑此处忽略，可以了解<a href=\"https://learn.microsoft.com/zh-cn/windows/win32/intl/surrogates-and-supplementary-characters\">代理项和增补字符</a>。对应单字节符号处理，直接将原始值返回即可，其他的字节就一个一个地获取，这里分析一下对于双字节的逻辑处理。获取第一个字节的逻辑为：<code>(ch &gt;&gt; 6) | 0xc0 </code>第二个字节逻辑为 <code>(ch &amp; 0x3f) | 0x80</code> </p>\n<ul>\n<li><p><code>(ch &gt;&gt; 6) | 0xc0</code></p>\n<p>第一个字节的前两位是 <code>11</code>（十六进制中的 <code>0xc0</code>），后面的 5 位是 Unicode 码点的高 5 位</p>\n</li>\n<li><p><code>(ch &amp; 0x3f) | 0x80</code></p>\n<p>第二个字节的前两位是 <code>10</code>（十六进制中的 <code>0x80</code>），后面的 6 位是 Unicode 码点的低 6 位</p>\n</li>\n</ul>\n<p>举例，希腊符号  <code>ε</code>(epsilon) 在 UTF-8 编码里面是用双字节表示， Unicode 为 <code>0x03B5</code>  对应二进制数据：<code>0000001110110101</code>，计算流程如下所示：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"># ε 0x03B5 to UTF-8 </span><br><span class=\"line\"></span><br><span class=\"line\"># 第一个字节 (ch &gt;&gt; 6) | 0xc0</span><br><span class=\"line\">0000001110110101 &gt;&gt; 6</span><br><span class=\"line\">      0000001110 | 0xc0 (11000000)</span><br><span class=\"line\">        11000000</span><br><span class=\"line\">             ||</span><br><span class=\"line\">        11001110</span><br><span class=\"line\">            0xCE</span><br><span class=\"line\"></span><br><span class=\"line\"># 第二个字节 (ch &amp; 0x3f) | 0x80</span><br><span class=\"line\">0000001110110101 &amp; 0x3f (111111)</span><br><span class=\"line\">          111111</span><br><span class=\"line\">          110101 | 0x80 (10000000)</span><br><span class=\"line\">        10000000</span><br><span class=\"line\">              ||</span><br><span class=\"line\">        10110101</span><br><span class=\"line\">            0xB5</span><br></pre></td></tr></table></figure>\n\n<p>从而计算出  <code>ε</code> 对应的 UTF-8 Encoding为<code>0xCE 0xB5</code></p>\n<h3 id=\"“锟斤拷”和“烫”\"><a href=\"#“锟斤拷”和“烫”\" class=\"headerlink\" title=\"“锟斤拷”和“烫”\"></a>“锟斤拷”和“烫”</h3><p><code>“锟斤拷”</code>通常发生在UTF-8 到 GBK 编码的转换中，在 UTF-8 编码中，”0xEF 0xBF 0xBD” 是一个特殊的字符，表示 REPLACEMENT CHARACTER（替换字符），当解码器在解码字节序列时遇到无法识别的字节或无效的编码时，通常会用 REPLACEMENT CHARACTER（U+FFFD）替换这些无效的字节 ，”0xEF 0xBF 0xBD” 在 GBK 里面则编码成 “锟斤拷”。</p>\n<p><code>“烫”</code> 则是由于在 Windows 操作系统中，开发者在使用调试器调试程序时，会发现未初始化的内存通常会被填充为0xCC，而”0xCC” 在 GBK 里面则编码成“烫”。</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>本文主要讨论了字符编码的一些基本概念和原理，包括 ASCII、ANSI、Unicode 和 UTF-8 编码，文章分析了 Java String 类的<code>.getBytes(StandardCharsets.UTF_8)</code>方法的实现源码，解释了将 Unicode 字符串转换为 UTF-8 编码字节序列的过程，最后介绍了一下 “锟斤拷”和”烫”为什么会被展示。</p>\n","raw":"title: UTF-8字符编码相关\nauthor: 落叶挽歌\ntags:\n  - UTF-8\ncategories: []\ndate: 2024-04-11 14:23:00\n---\n最近在 Windows 上开发一些逻辑的时候遇到一些关于中文的坑，中文路径会乱码，是由于 Window 系统默认的编码格式是 **GBK**，而传入的参数编码格式是 **UTF-8**，导致整个程序出错。后续使用了``MultiByteToWideChar` 和`WideCharToMultiByte` 方法对编码进行一次改变，从而避免了这个问题的产生。但不了解相关原因，经过一番学习，对相关的概念进行一些简单的总结，并对一些 api  的实现源码进行分析。\n\n### ASCII 码\n\n ASCII ( American Standard Code for Information Interchange)\n 256个符号，从 00000000 到 11111111    \n\n###  ANSI\n\nANSI（American National Standards Institute，美国国家标准协会）编码：ANSI 编码是一种基于 8 位的字符编码。它包含了 128 个美国英语字符和其他 128 个特殊字符，共 256 个字符。ANSI 编码主要用于表示英语字符，但它的局限性在于无法表示其他语言的字符。为了解决这个问题，各国家和地区分别制定了自己的 ANSI 编码标准，但这又引入了新的问题，即不同编码之间的互不兼容。\n\n​       美国和西欧：Windows-1252\n​       中文（简体）：GB2312 或 GBK\n​       中文（繁体）：Big5\n​       日文：Shift-JIS\n​       韩文：EUC-KR   \n\n### Unicode\n\n为了解决字符编码之间的兼容性问题，Unicode 标准应运而生。Unicode 是一种包含世界上大多数字符的编码方案，它为每个字符分配一个唯一的数字（称为码点），无论在任何平台、程序或语言中，都可以表示这些字符。Unicode 有多种实现方式，如 UTF-8、UTF-16 和 UTF-32。UTF-8 是最常用的 Unicode 实现方式，它是一种变长编码，可以使用 1 到 4 个字节来表示一个字符，这使得它在存储和传输方面更加高效\n\n  \"FE FF\" 是 Unicode 字符串的字节顺序标记（Byte Order Mark，简称 BOM），用于表示字符串的字节顺序\n  Unicode Little-Endian，\"FF FE\"\n  Unicode Big-Endian，\"FE FF\"\n\n### UTF-8\n\nUTF-8 是 Unicode 的实现方式之一  ，是一种变长编码，它使用 1 到 4 个字节（8 位）来表示一个字符\n\n**单字节**   所有的ASCII 字符                                                                                   \n**二字节**  带有附加符号的拉丁文、希腊文、西里尔字母、亚美尼亚语、希伯来文、阿拉伯文、叙利亚文及它拿字母则需要二个字节编码                \n\n**三字节** 基本等同于GBK，含21000多个汉字 \n\n**四字节** 中日韩超大字符集里面的汉字，有5万多个\n\n**UTF-8编码对照表**\n                                                                                                            \n| Unicode 符号范围   (十六进制) | UTF-8编码方式（二进制）             |\n| ----------------------------- | ----------------------------------- |\n| 0000 0000 ~ 0000 007F         | 0xxxxxxx                            |\n| 0000 0080 ~ 0000 07FF         | 110xxxxx 10xxxxxx                   |\n| 0000 0800 ~ 0000 FFFF         | 1110xxxx 10xxxxxx 10xxxxxx          |\n| 0001 0000 ~ 0010 FFFF         | 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx |\n\n\n\n\n\n### 源码阅读：Java String toUtf8\n\n Java 的 String 默认用 UTF-16 存储数据，String 类的方法`.getBytes(StandardCharsets.UTF_8)` 将指定的字符集将字符串编码为 byte 序列，并将结果存储到一个新的 byte 数组中。\n\n其主要逻辑在:[CharsetUtils.java#toUtf8Bytes](https://android.googlesource.com/platform/libcore/+/master/luni/src/main/java/libcore/util/CharsetUtils.java#46)\n\n```java\n public static native byte[] toUtf8Bytes(String s, int offset, int length);\n```\n\n对应的最终实现：[java_nio_charset_Charsets.cpp#Charsets_toUtf8Bytes](https://android.googlesource.com/platform/libcore/+/3e8abdd9bdca823a635aac3adacf71ef227b18e1/luni/src/main/native/java_nio_charset_Charsets.cpp#183) \n\n```c++\nstatic jbyteArray Charsets_toUtf8Bytes(JNIEnv* env, jclass, jcharArray javaChars, jint offset, jint length) {\n    // ....此处省略 一些检查逻辑\n    const int end = offset + length;\n    for (int i = offset; i < end; ++i) {\n        jint ch = chars[i];\n        if (ch < 0x80) {\n            // 单字节直接放进去\n            if (!out.append(ch)) {\n                return NULL;\n            }\n        } else if (ch < 0x800) {\n            // 双字节\n            if (!out.append((ch >> 6) | 0xc0) || !out.append((ch & 0x3f) | 0x80)) {\n                return NULL;\n            }\n        } else if (U16_IS_SURROGATE(ch)) {\n          \t// ....此处省略 UTF-16 代理字符串相关的逻辑\n            ch = U16_GET_SUPPLEMENTARY(high, low);\n            // 四字节 \n            jbyte b1 = (ch >> 18) | 0xf0;\n            jbyte b2 = ((ch >> 12) & 0x3f) | 0x80;\n            jbyte b3 = ((ch >> 6) & 0x3f) | 0x80;\n            jbyte b4 = (ch & 0x3f) | 0x80;\n            if (!out.append(b1) || !out.append(b2) || !out.append(b3) || !out.append(b4)) {\n                return NULL;\n            }\n        } else {\n            // 三字节.\n            jbyte b1 = (ch >> 12) | 0xe0;\n            jbyte b2 = ((ch >> 6) & 0x3f) | 0x80;\n            jbyte b3 = (ch & 0x3f) | 0x80;\n            if (!out.append(b1) || !out.append(b2) || !out.append(b3)) {\n                return NULL;\n            }\n        }\n    }\n    return out.toByteArray();\n}\n```\n\n整体的逻辑非常的好理解：判断输入值的区间，并分成单双三四字节的处理逻辑，其中有处理 UTF-16 代理字符串相关的逻辑此处忽略，可以了解[代理项和增补字符](https://learn.microsoft.com/zh-cn/windows/win32/intl/surrogates-and-supplementary-characters)。对应单字节符号处理，直接将原始值返回即可，其他的字节就一个一个地获取，这里分析一下对于双字节的逻辑处理。获取第一个字节的逻辑为：`(ch >> 6) | 0xc0 `第二个字节逻辑为 `(ch & 0x3f) | 0x80` \n\n- `(ch >> 6) | 0xc0`\n\n  第一个字节的前两位是 `11`（十六进制中的 `0xc0`），后面的 5 位是 Unicode 码点的高 5 位\n\n- `(ch & 0x3f) | 0x80`\n\n  第二个字节的前两位是 `10`（十六进制中的 `0x80`），后面的 6 位是 Unicode 码点的低 6 位\n\n举例，希腊符号  `ε`(epsilon) 在 UTF-8 编码里面是用双字节表示， Unicode 为 `0x03B5`  对应二进制数据：`0000001110110101`，计算流程如下所示：\n\n```\n# ε 0x03B5 to UTF-8 \n\n# 第一个字节 (ch >> 6) | 0xc0\n0000001110110101 >> 6\n      0000001110 | 0xc0 (11000000)\n        11000000\n             ||\n        11001110\n            0xCE\n\n# 第二个字节 (ch & 0x3f) | 0x80\n0000001110110101 & 0x3f (111111)\n          111111\n          110101 | 0x80 (10000000)\n        10000000\n              ||\n        10110101\n            0xB5\n```\n\n从而计算出  `ε` 对应的 UTF-8 Encoding为`0xCE 0xB5`\n\n### “锟斤拷”和“烫”\n\n`“锟斤拷”`通常发生在UTF-8 到 GBK 编码的转换中，在 UTF-8 编码中，\"0xEF 0xBF 0xBD\" 是一个特殊的字符，表示 REPLACEMENT CHARACTER（替换字符），当解码器在解码字节序列时遇到无法识别的字节或无效的编码时，通常会用 REPLACEMENT CHARACTER（U+FFFD）替换这些无效的字节 ，\"0xEF 0xBF 0xBD\" 在 GBK 里面则编码成 \"锟斤拷\"。\n\n`“烫”` 则是由于在 Windows 操作系统中，开发者在使用调试器调试程序时，会发现未初始化的内存通常会被填充为0xCC，而\"0xCC\" 在 GBK 里面则编码成“烫”。\n\n### 总结\n\n本文主要讨论了字符编码的一些基本概念和原理，包括 ASCII、ANSI、Unicode 和 UTF-8 编码，文章分析了 Java String 类的`.getBytes(StandardCharsets.UTF_8)`方法的实现源码，解释了将 Unicode 字符串转换为 UTF-8 编码字节序列的过程，最后介绍了一下 “锟斤拷”和”烫”为什么会被展示。\n\n","categories":[],"tags":[{"name":"UTF-8","api":"api/tags/UTF-8.json"}]},"api":"api/posts/2024/04/11/关于Windows中文字符乱码.json"}