{"data":{"index":2,"total":8,"posts":[{"title":"UTF-8字符编码相关","slug":"关于Windows中文字符乱码","date":"2024-04-11T06:23:00.000Z","updated":"2025-05-20T11:46:57.000Z","comments":true,"url":"2024/04/11/关于Windows中文字符乱码/","excerpt":"<p>最近在 Windows 上开发一些逻辑的时候遇到一些关于中文的坑，中文路径会乱码，是由于 Window 系统默认的编码格式是 <strong>GBK</strong>，而传入的参数编码格式是 <strong>UTF-8</strong>，导致整个程序出错。后续使用了<code>`MultiByteToWideChar</code> 和<code>WideCharToMultiByte</code> 方法对编码进行一次改变，从而避免了这个问题的产生。但不了解相关原因，经过一番学习，对相关的概念进行一些简单的总结，并对一些 api  的实现源码进行分析。</p>\n<h3 id=\"ASCII-码\"><a href=\"#ASCII-码\" class=\"headerlink\" title=\"ASCII 码\"></a>ASCII 码</h3><p> ASCII ( American Standard Code for Information Interchange)<br> 256个符号，从 00000000 到 11111111    </p>\n<h3 id=\"ANSI\"><a href=\"#ANSI\" class=\"headerlink\" title=\"ANSI\"></a>ANSI</h3><p>ANSI（American National Standards Institute，美国国家标准协会）编码：ANSI 编码是一种基于 8 位的字符编码。它包含了 128 个美国英语字符和其他 128 个特殊字符，共 256 个字符。ANSI 编码主要用于表示英语字符，但它的局限性在于无法表示其他语言的字符。为了解决这个问题，各国家和地区分别制定了自己的 ANSI 编码标准，但这又引入了新的问题，即不同编码之间的互不兼容。</p>\n<p>​       美国和西欧：Windows-1252<br>​       中文（简体）：GB2312 或 GBK<br>​       中文（繁体）：Big5<br>​       日文：Shift-JIS<br>​       韩文：EUC-KR   </p>\n<h3 id=\"Unicode\"><a href=\"#Unicode\" class=\"headerlink\" title=\"Unicode\"></a>Unicode</h3><p>为了解决字符编码之间的兼容性问题，Unicode 标准应运而生。Unicode 是一种包含世界上大多数字符的编码方案，它为每个字符分配一个唯一的数字（称为码点），无论在任何平台、程序或语言中，都可以表示这些字符。Unicode 有多种实现方式，如 UTF-8、UTF-16 和 UTF-32。UTF-8 是最常用的 Unicode 实现方式，它是一种变长编码，可以使用 1 到 4 个字节来表示一个字符，这使得它在存储和传输方面更加高效</p>\n<p>  “FE FF” 是 Unicode 字符串的字节顺序标记（Byte Order Mark，简称 BOM），用于表示字符串的字节顺序<br>  Unicode Little-Endian，”FF FE”<br>  Unicode Big-Endian，”FE FF”</p>\n<h3 id=\"UTF-8\"><a href=\"#UTF-8\" class=\"headerlink\" title=\"UTF-8\"></a>UTF-8</h3><p>UTF-8 是 Unicode 的实现方式之一  ，是一种变长编码，它使用 1 到 4 个字节（8 位）来表示一个字符</p>\n<p><strong>单字节</strong>   所有的ASCII 字符<br><strong>二字节</strong>  带有附加符号的拉丁文、希腊文、西里尔字母、亚美尼亚语、希伯来文、阿拉伯文、叙利亚文及它拿字母则需要二个字节编码                </p>\n<p><strong>三字节</strong> 基本等同于GBK，含21000多个汉字 </p>\n<p><strong>四字节</strong> 中日韩超大字符集里面的汉字，有5万多个</p>\n<p><strong>UTF-8编码对照表</strong></p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>Unicode 符号范围   (十六进制)</th>\n<th>UTF-8编码方式（二进制）</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>0000 0000 ~ 0000 007F</td>\n<td>0xxxxxxx</td>\n</tr>\n<tr>\n<td>0000 0080 ~ 0000 07FF</td>\n<td>110xxxxx 10xxxxxx</td>\n</tr>\n<tr>\n<td>0000 0800 ~ 0000 FFFF</td>\n<td>1110xxxx 10xxxxxx 10xxxxxx</td>\n</tr>\n<tr>\n<td>0001 0000 ~ 0010 FFFF</td>\n<td>11110xxx 10xxxxxx 10xxxxxx 10xxxxxx</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h3 id=\"源码阅读：Java-String-toUtf8\"><a href=\"#源码阅读：Java-String-toUtf8\" class=\"headerlink\" title=\"源码阅读：Java String toUtf8\"></a>源码阅读：Java String toUtf8</h3><p> Java 的 String 默认用 UTF-16 存储数据，String 类的方法<code>.getBytes(StandardCharsets.UTF_8)</code> 将指定的字符集将字符串编码为 byte 序列，并将结果存储到一个新的 byte 数组中。</p>\n<p>其主要逻辑在:<a href=\"https://android.googlesource.com/platform/libcore/+/master/luni/src/main/java/libcore/util/CharsetUtils.java#46\">CharsetUtils.java#toUtf8Bytes</a></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">native</span> <span class=\"type\">byte</span>[] toUtf8Bytes(String s, <span class=\"type\">int</span> offset, <span class=\"type\">int</span> length);</span><br></pre></td></tr></table></figure>\n<p>对应的最终实现：<a href=\"https://android.googlesource.com/platform/libcore/+/3e8abdd9bdca823a635aac3adacf71ef227b18e1/luni/src/main/native/java_nio_charset_Charsets.cpp#183\">java_nio_charset_Charsets.cpp#Charsets_toUtf8Bytes</a> </p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">static</span> jbyteArray <span class=\"title\">Charsets_toUtf8Bytes</span><span class=\"params\">(JNIEnv* env, jclass, jcharArray javaChars, jint offset, jint length)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// ....此处省略 一些检查逻辑</span></span><br><span class=\"line\">    <span class=\"type\">const</span> <span class=\"type\">int</span> end = offset + length;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = offset; i &lt; end; ++i) &#123;</span><br><span class=\"line\">        jint ch = chars[i];</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (ch &lt; <span class=\"number\">0x80</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 单字节直接放进去</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!out.<span class=\"built_in\">append</span>(ch)) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (ch &lt; <span class=\"number\">0x800</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 双字节</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!out.<span class=\"built_in\">append</span>((ch &gt;&gt; <span class=\"number\">6</span>) | <span class=\"number\">0xc0</span>) || !out.<span class=\"built_in\">append</span>((ch &amp; <span class=\"number\">0x3f</span>) | <span class=\"number\">0x80</span>)) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"built_in\">U16_IS_SURROGATE</span>(ch)) &#123;</span><br><span class=\"line\">          \t<span class=\"comment\">// ....此处省略 UTF-16 代理字符串相关的逻辑</span></span><br><span class=\"line\">            ch = <span class=\"built_in\">U16_GET_SUPPLEMENTARY</span>(high, low);</span><br><span class=\"line\">            <span class=\"comment\">// 四字节 </span></span><br><span class=\"line\">            jbyte b1 = (ch &gt;&gt; <span class=\"number\">18</span>) | <span class=\"number\">0xf0</span>;</span><br><span class=\"line\">            jbyte b2 = ((ch &gt;&gt; <span class=\"number\">12</span>) &amp; <span class=\"number\">0x3f</span>) | <span class=\"number\">0x80</span>;</span><br><span class=\"line\">            jbyte b3 = ((ch &gt;&gt; <span class=\"number\">6</span>) &amp; <span class=\"number\">0x3f</span>) | <span class=\"number\">0x80</span>;</span><br><span class=\"line\">            jbyte b4 = (ch &amp; <span class=\"number\">0x3f</span>) | <span class=\"number\">0x80</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!out.<span class=\"built_in\">append</span>(b1) || !out.<span class=\"built_in\">append</span>(b2) || !out.<span class=\"built_in\">append</span>(b3) || !out.<span class=\"built_in\">append</span>(b4)) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 三字节.</span></span><br><span class=\"line\">            jbyte b1 = (ch &gt;&gt; <span class=\"number\">12</span>) | <span class=\"number\">0xe0</span>;</span><br><span class=\"line\">            jbyte b2 = ((ch &gt;&gt; <span class=\"number\">6</span>) &amp; <span class=\"number\">0x3f</span>) | <span class=\"number\">0x80</span>;</span><br><span class=\"line\">            jbyte b3 = (ch &amp; <span class=\"number\">0x3f</span>) | <span class=\"number\">0x80</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!out.<span class=\"built_in\">append</span>(b1) || !out.<span class=\"built_in\">append</span>(b2) || !out.<span class=\"built_in\">append</span>(b3)) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> out.<span class=\"built_in\">toByteArray</span>();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>整体的逻辑非常的好理解：判断输入值的区间，并分成单双三四字节的处理逻辑，其中有处理 UTF-16 代理字符串相关的逻辑此处忽略，可以了解<a href=\"https://learn.microsoft.com/zh-cn/windows/win32/intl/surrogates-and-supplementary-characters\">代理项和增补字符</a>。对应单字节符号处理，直接将原始值返回即可，其他的字节就一个一个地获取，这里分析一下对于双字节的逻辑处理。获取第一个字节的逻辑为：<code>(ch &gt;&gt; 6) | 0xc0</code>第二个字节逻辑为 <code>(ch &amp; 0x3f) | 0x80</code> </p>\n<ul>\n<li><p><code>(ch &gt;&gt; 6) | 0xc0</code></p>\n<p>第一个字节的前两位是 <code>11</code>（十六进制中的 <code>0xc0</code>），后面的 5 位是 Unicode 码点的高 5 位</p>\n</li>\n<li><p><code>(ch &amp; 0x3f) | 0x80</code></p>\n<p>第二个字节的前两位是 <code>10</code>（十六进制中的 <code>0x80</code>），后面的 6 位是 Unicode 码点的低 6 位</p>\n</li>\n</ul>\n<p>举例，希腊符号  <code>ε</code>(epsilon) 在 UTF-8 编码里面是用双字节表示， Unicode 为 <code>0x03B5</code>  对应二进制数据：<code>0000001110110101</code>，计算流程如下所示：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"># ε 0x03B5 to UTF-8 </span><br><span class=\"line\"></span><br><span class=\"line\"># 第一个字节 (ch &gt;&gt; 6) | 0xc0</span><br><span class=\"line\">0000001110110101 &gt;&gt; 6</span><br><span class=\"line\">      0000001110 | 0xc0 (11000000)</span><br><span class=\"line\">        11000000</span><br><span class=\"line\">             ||</span><br><span class=\"line\">        11001110</span><br><span class=\"line\">            0xCE</span><br><span class=\"line\"></span><br><span class=\"line\"># 第二个字节 (ch &amp; 0x3f) | 0x80</span><br><span class=\"line\">0000001110110101 &amp; 0x3f (111111)</span><br><span class=\"line\">          111111</span><br><span class=\"line\">          110101 | 0x80 (10000000)</span><br><span class=\"line\">        10000000</span><br><span class=\"line\">              ||</span><br><span class=\"line\">        10110101</span><br><span class=\"line\">            0xB5</span><br></pre></td></tr></table></figure>\n<p>从而计算出  <code>ε</code> 对应的 UTF-8 Encoding为<code>0xCE 0xB5</code></p>\n<h3 id=\"“锟斤拷”和“烫”\"><a href=\"#“锟斤拷”和“烫”\" class=\"headerlink\" title=\"“锟斤拷”和“烫”\"></a>“锟斤拷”和“烫”</h3><p><code>“锟斤拷”</code>通常发生在UTF-8 到 GBK 编码的转换中，在 UTF-8 编码中，”0xEF 0xBF 0xBD” 是一个特殊的字符，表示 REPLACEMENT CHARACTER（替换字符），当解码器在解码字节序列时遇到无法识别的字节或无效的编码时，通常会用 REPLACEMENT CHARACTER（U+FFFD）替换这些无效的字节 ，”0xEF 0xBF 0xBD” 在 GBK 里面则编码成 “锟斤拷”。</p>\n<p><code>“烫”</code> 则是由于在 Windows 操作系统中，开发者在使用调试器调试程序时，会发现未初始化的内存通常会被填充为0xCC，而”0xCC” 在 GBK 里面则编码成“烫”。</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>本文主要讨论了字符编码的一些基本概念和原理，包括 ASCII、ANSI、Unicode 和 UTF-8 编码，文章分析了 Java String 类的<code>.getBytes(StandardCharsets.UTF_8)</code>方法的实现源码，解释了将 Unicode 字符串转换为 UTF-8 编码字节序列的过程，最后介绍了一下 “锟斤拷”和”烫”为什么会被展示。</p>\n","cover":null,"images":[],"content":"<p>最近在 Windows 上开发一些逻辑的时候遇到一些关于中文的坑，中文路径会乱码，是由于 Window 系统默认的编码格式是 <strong>GBK</strong>，而传入的参数编码格式是 <strong>UTF-8</strong>，导致整个程序出错。后续使用了<code>`MultiByteToWideChar</code> 和<code>WideCharToMultiByte</code> 方法对编码进行一次改变，从而避免了这个问题的产生。但不了解相关原因，经过一番学习，对相关的概念进行一些简单的总结，并对一些 api  的实现源码进行分析。</p>\n<h3 id=\"ASCII-码\"><a href=\"#ASCII-码\" class=\"headerlink\" title=\"ASCII 码\"></a>ASCII 码</h3><p> ASCII ( American Standard Code for Information Interchange)<br> 256个符号，从 00000000 到 11111111    </p>\n<h3 id=\"ANSI\"><a href=\"#ANSI\" class=\"headerlink\" title=\"ANSI\"></a>ANSI</h3><p>ANSI（American National Standards Institute，美国国家标准协会）编码：ANSI 编码是一种基于 8 位的字符编码。它包含了 128 个美国英语字符和其他 128 个特殊字符，共 256 个字符。ANSI 编码主要用于表示英语字符，但它的局限性在于无法表示其他语言的字符。为了解决这个问题，各国家和地区分别制定了自己的 ANSI 编码标准，但这又引入了新的问题，即不同编码之间的互不兼容。</p>\n<p>​       美国和西欧：Windows-1252<br>​       中文（简体）：GB2312 或 GBK<br>​       中文（繁体）：Big5<br>​       日文：Shift-JIS<br>​       韩文：EUC-KR   </p>\n<h3 id=\"Unicode\"><a href=\"#Unicode\" class=\"headerlink\" title=\"Unicode\"></a>Unicode</h3><p>为了解决字符编码之间的兼容性问题，Unicode 标准应运而生。Unicode 是一种包含世界上大多数字符的编码方案，它为每个字符分配一个唯一的数字（称为码点），无论在任何平台、程序或语言中，都可以表示这些字符。Unicode 有多种实现方式，如 UTF-8、UTF-16 和 UTF-32。UTF-8 是最常用的 Unicode 实现方式，它是一种变长编码，可以使用 1 到 4 个字节来表示一个字符，这使得它在存储和传输方面更加高效</p>\n<p>  “FE FF” 是 Unicode 字符串的字节顺序标记（Byte Order Mark，简称 BOM），用于表示字符串的字节顺序<br>  Unicode Little-Endian，”FF FE”<br>  Unicode Big-Endian，”FE FF”</p>\n<h3 id=\"UTF-8\"><a href=\"#UTF-8\" class=\"headerlink\" title=\"UTF-8\"></a>UTF-8</h3><p>UTF-8 是 Unicode 的实现方式之一  ，是一种变长编码，它使用 1 到 4 个字节（8 位）来表示一个字符</p>\n<p><strong>单字节</strong>   所有的ASCII 字符<br><strong>二字节</strong>  带有附加符号的拉丁文、希腊文、西里尔字母、亚美尼亚语、希伯来文、阿拉伯文、叙利亚文及它拿字母则需要二个字节编码                </p>\n<p><strong>三字节</strong> 基本等同于GBK，含21000多个汉字 </p>\n<p><strong>四字节</strong> 中日韩超大字符集里面的汉字，有5万多个</p>\n<p><strong>UTF-8编码对照表</strong></p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>Unicode 符号范围   (十六进制)</th>\n<th>UTF-8编码方式（二进制）</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>0000 0000 ~ 0000 007F</td>\n<td>0xxxxxxx</td>\n</tr>\n<tr>\n<td>0000 0080 ~ 0000 07FF</td>\n<td>110xxxxx 10xxxxxx</td>\n</tr>\n<tr>\n<td>0000 0800 ~ 0000 FFFF</td>\n<td>1110xxxx 10xxxxxx 10xxxxxx</td>\n</tr>\n<tr>\n<td>0001 0000 ~ 0010 FFFF</td>\n<td>11110xxx 10xxxxxx 10xxxxxx 10xxxxxx</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h3 id=\"源码阅读：Java-String-toUtf8\"><a href=\"#源码阅读：Java-String-toUtf8\" class=\"headerlink\" title=\"源码阅读：Java String toUtf8\"></a>源码阅读：Java String toUtf8</h3><p> Java 的 String 默认用 UTF-16 存储数据，String 类的方法<code>.getBytes(StandardCharsets.UTF_8)</code> 将指定的字符集将字符串编码为 byte 序列，并将结果存储到一个新的 byte 数组中。</p>\n<p>其主要逻辑在:<a href=\"https://android.googlesource.com/platform/libcore/+/master/luni/src/main/java/libcore/util/CharsetUtils.java#46\">CharsetUtils.java#toUtf8Bytes</a></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">native</span> <span class=\"type\">byte</span>[] toUtf8Bytes(String s, <span class=\"type\">int</span> offset, <span class=\"type\">int</span> length);</span><br></pre></td></tr></table></figure>\n<p>对应的最终实现：<a href=\"https://android.googlesource.com/platform/libcore/+/3e8abdd9bdca823a635aac3adacf71ef227b18e1/luni/src/main/native/java_nio_charset_Charsets.cpp#183\">java_nio_charset_Charsets.cpp#Charsets_toUtf8Bytes</a> </p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">static</span> jbyteArray <span class=\"title\">Charsets_toUtf8Bytes</span><span class=\"params\">(JNIEnv* env, jclass, jcharArray javaChars, jint offset, jint length)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// ....此处省略 一些检查逻辑</span></span><br><span class=\"line\">    <span class=\"type\">const</span> <span class=\"type\">int</span> end = offset + length;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = offset; i &lt; end; ++i) &#123;</span><br><span class=\"line\">        jint ch = chars[i];</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (ch &lt; <span class=\"number\">0x80</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 单字节直接放进去</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!out.<span class=\"built_in\">append</span>(ch)) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (ch &lt; <span class=\"number\">0x800</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 双字节</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!out.<span class=\"built_in\">append</span>((ch &gt;&gt; <span class=\"number\">6</span>) | <span class=\"number\">0xc0</span>) || !out.<span class=\"built_in\">append</span>((ch &amp; <span class=\"number\">0x3f</span>) | <span class=\"number\">0x80</span>)) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"built_in\">U16_IS_SURROGATE</span>(ch)) &#123;</span><br><span class=\"line\">          \t<span class=\"comment\">// ....此处省略 UTF-16 代理字符串相关的逻辑</span></span><br><span class=\"line\">            ch = <span class=\"built_in\">U16_GET_SUPPLEMENTARY</span>(high, low);</span><br><span class=\"line\">            <span class=\"comment\">// 四字节 </span></span><br><span class=\"line\">            jbyte b1 = (ch &gt;&gt; <span class=\"number\">18</span>) | <span class=\"number\">0xf0</span>;</span><br><span class=\"line\">            jbyte b2 = ((ch &gt;&gt; <span class=\"number\">12</span>) &amp; <span class=\"number\">0x3f</span>) | <span class=\"number\">0x80</span>;</span><br><span class=\"line\">            jbyte b3 = ((ch &gt;&gt; <span class=\"number\">6</span>) &amp; <span class=\"number\">0x3f</span>) | <span class=\"number\">0x80</span>;</span><br><span class=\"line\">            jbyte b4 = (ch &amp; <span class=\"number\">0x3f</span>) | <span class=\"number\">0x80</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!out.<span class=\"built_in\">append</span>(b1) || !out.<span class=\"built_in\">append</span>(b2) || !out.<span class=\"built_in\">append</span>(b3) || !out.<span class=\"built_in\">append</span>(b4)) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 三字节.</span></span><br><span class=\"line\">            jbyte b1 = (ch &gt;&gt; <span class=\"number\">12</span>) | <span class=\"number\">0xe0</span>;</span><br><span class=\"line\">            jbyte b2 = ((ch &gt;&gt; <span class=\"number\">6</span>) &amp; <span class=\"number\">0x3f</span>) | <span class=\"number\">0x80</span>;</span><br><span class=\"line\">            jbyte b3 = (ch &amp; <span class=\"number\">0x3f</span>) | <span class=\"number\">0x80</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!out.<span class=\"built_in\">append</span>(b1) || !out.<span class=\"built_in\">append</span>(b2) || !out.<span class=\"built_in\">append</span>(b3)) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> out.<span class=\"built_in\">toByteArray</span>();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>整体的逻辑非常的好理解：判断输入值的区间，并分成单双三四字节的处理逻辑，其中有处理 UTF-16 代理字符串相关的逻辑此处忽略，可以了解<a href=\"https://learn.microsoft.com/zh-cn/windows/win32/intl/surrogates-and-supplementary-characters\">代理项和增补字符</a>。对应单字节符号处理，直接将原始值返回即可，其他的字节就一个一个地获取，这里分析一下对于双字节的逻辑处理。获取第一个字节的逻辑为：<code>(ch &gt;&gt; 6) | 0xc0</code>第二个字节逻辑为 <code>(ch &amp; 0x3f) | 0x80</code> </p>\n<ul>\n<li><p><code>(ch &gt;&gt; 6) | 0xc0</code></p>\n<p>第一个字节的前两位是 <code>11</code>（十六进制中的 <code>0xc0</code>），后面的 5 位是 Unicode 码点的高 5 位</p>\n</li>\n<li><p><code>(ch &amp; 0x3f) | 0x80</code></p>\n<p>第二个字节的前两位是 <code>10</code>（十六进制中的 <code>0x80</code>），后面的 6 位是 Unicode 码点的低 6 位</p>\n</li>\n</ul>\n<p>举例，希腊符号  <code>ε</code>(epsilon) 在 UTF-8 编码里面是用双字节表示， Unicode 为 <code>0x03B5</code>  对应二进制数据：<code>0000001110110101</code>，计算流程如下所示：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"># ε 0x03B5 to UTF-8 </span><br><span class=\"line\"></span><br><span class=\"line\"># 第一个字节 (ch &gt;&gt; 6) | 0xc0</span><br><span class=\"line\">0000001110110101 &gt;&gt; 6</span><br><span class=\"line\">      0000001110 | 0xc0 (11000000)</span><br><span class=\"line\">        11000000</span><br><span class=\"line\">             ||</span><br><span class=\"line\">        11001110</span><br><span class=\"line\">            0xCE</span><br><span class=\"line\"></span><br><span class=\"line\"># 第二个字节 (ch &amp; 0x3f) | 0x80</span><br><span class=\"line\">0000001110110101 &amp; 0x3f (111111)</span><br><span class=\"line\">          111111</span><br><span class=\"line\">          110101 | 0x80 (10000000)</span><br><span class=\"line\">        10000000</span><br><span class=\"line\">              ||</span><br><span class=\"line\">        10110101</span><br><span class=\"line\">            0xB5</span><br></pre></td></tr></table></figure>\n<p>从而计算出  <code>ε</code> 对应的 UTF-8 Encoding为<code>0xCE 0xB5</code></p>\n<h3 id=\"“锟斤拷”和“烫”\"><a href=\"#“锟斤拷”和“烫”\" class=\"headerlink\" title=\"“锟斤拷”和“烫”\"></a>“锟斤拷”和“烫”</h3><p><code>“锟斤拷”</code>通常发生在UTF-8 到 GBK 编码的转换中，在 UTF-8 编码中，”0xEF 0xBF 0xBD” 是一个特殊的字符，表示 REPLACEMENT CHARACTER（替换字符），当解码器在解码字节序列时遇到无法识别的字节或无效的编码时，通常会用 REPLACEMENT CHARACTER（U+FFFD）替换这些无效的字节 ，”0xEF 0xBF 0xBD” 在 GBK 里面则编码成 “锟斤拷”。</p>\n<p><code>“烫”</code> 则是由于在 Windows 操作系统中，开发者在使用调试器调试程序时，会发现未初始化的内存通常会被填充为0xCC，而”0xCC” 在 GBK 里面则编码成“烫”。</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>本文主要讨论了字符编码的一些基本概念和原理，包括 ASCII、ANSI、Unicode 和 UTF-8 编码，文章分析了 Java String 类的<code>.getBytes(StandardCharsets.UTF_8)</code>方法的实现源码，解释了将 Unicode 字符串转换为 UTF-8 编码字节序列的过程，最后介绍了一下 “锟斤拷”和”烫”为什么会被展示。</p>\n","categories":[],"tags":[{"name":"UTF-8","slug":"UTF-8","api":"api/tags/UTF-8.json"}],"api":"api/posts/2024/04/11/关于Windows中文字符乱码.json"},{"title":"实现一个自定义 FFmpeg Filter","slug":"实现一个自定义FFmpeg-Filter","date":"2024-03-07T02:58:00.000Z","updated":"2025-09-15T13:07:48.846Z","comments":true,"url":"2024/03/07/实现一个自定义FFmpeg-Filter/","excerpt":"<p>此前在做  ffmpeg+某个第三库作为 filter 的集成，第三库是做AE特效相关的，与 ffmpeg 结合能让视频渲染效果大大提升。整体流程将第三方库作为 ffmpeg 的一个filter 形式进行结合，其中就涉及到 ffmpeg 的 filter 开发，本文即 对ffmpeg 的滤镜开发流程作一个总结。本文以实现一个视频垂直翻转的 filter 为例，ffmpeg 源码基于<a href=\"https://github.com/FFmpeg/FFmpeg/tree/release/6.1\">FFmpeg6.1</a> </p>\n<h2 id=\"实现自定义-Filter-流程\"><a href=\"#实现自定义-Filter-流程\" class=\"headerlink\" title=\"实现自定义 Filter 流程\"></a>实现自定义 Filter 流程</h2><ul>\n<li><p>编写 filter.c 文件</p>\n<p>一般视频滤镜以 vf_ 为前缀，视频滤镜以 af_ 为前缀，放在libavfilter目录下，参考其他 filter 代码逻辑，模块化配置相关参数，本文例以 vf_flip.c 实现视频的上下翻转</p>\n</li>\n<li><p>在 <code>libavfilter/allfilters.c</code> 注册</p>\n<p>例如：extern const AVFilter ff_vf_flip;  <code>ff_vf_flip</code>就是在 <code>vf_flip.c</code>的 filter 注册名称</p>\n</li>\n<li><p>修改 <code>libavfilter/Makefile</code> 添加编译配置： </p>\n<p>例如：OBJS-$(CONFIG_FLIP_FILTER)                   += vf_flip.o</p>\n</li>\n<li><p>编译打包</p>\n</li>\n</ul>\n<h2 id=\"编写-filter-c-文件\"><a href=\"#编写-filter-c-文件\" class=\"headerlink\" title=\"编写 filter.c 文件\"></a>编写 filter.c 文件</h2><h3 id=\"AVFilter主体\"><a href=\"#AVFilter主体\" class=\"headerlink\" title=\"AVFilter主体\"></a>AVFilter主体</h3><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">AVFilter</span> &#123;</span></span><br><span class=\"line\">  <span class=\"type\">const</span> <span class=\"type\">char</span> *name;</span><br><span class=\"line\">  <span class=\"type\">const</span> <span class=\"type\">char</span> *description;</span><br><span class=\"line\">  <span class=\"type\">const</span> AVFilterPad *inputs;</span><br><span class=\"line\">  <span class=\"type\">const</span> AVFilterPad *outputs;</span><br><span class=\"line\">  <span class=\"type\">const</span> AVClass *priv_class;</span><br><span class=\"line\">  <span class=\"type\">int</span> flags;</span><br><span class=\"line\">  <span class=\"type\">int</span> (*preinit)(AVFilterContext *ctx);</span><br><span class=\"line\">  <span class=\"type\">int</span> (*init)(AVFilterContext *ctx);</span><br><span class=\"line\">  <span class=\"type\">int</span> (*init_dict)(AVFilterContext *ctx, AVDictionary **options);</span><br><span class=\"line\">  <span class=\"type\">void</span> (*uninit)(AVFilterContext *ctx);</span><br><span class=\"line\">  <span class=\"type\">int</span> (*query_formats)(AVFilterContext *);</span><br><span class=\"line\">  <span class=\"type\">int</span> priv_size;   </span><br><span class=\"line\">  <span class=\"type\">int</span> flags_internal; </span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">AVFilter</span> *<span class=\"title\">next</span>;</span></span><br><span class=\"line\">  <span class=\"type\">int</span> (*process_command)(AVFilterContext *, <span class=\"type\">const</span> <span class=\"type\">char</span> *cmd, <span class=\"type\">const</span> <span class=\"type\">char</span> *arg, <span class=\"type\">char</span> *res, <span class=\"type\">int</span> res_len, <span class=\"type\">int</span> flags);</span><br><span class=\"line\">  <span class=\"type\">int</span> (*init_opaque)(AVFilterContext *ctx, <span class=\"type\">void</span> *opaque);</span><br><span class=\"line\">  <span class=\"type\">int</span> (*activate)(AVFilterContext *ctx);</span><br><span class=\"line\">&#125; AVFilter;</span><br></pre></td></tr></table></figure>\n<p>具体里面的属性作用可以参考：<a href=\"https://www.cnblogs.com/TaigaCon/p/10171464.html\">[ffmpeg] 定制滤波器</a>，可以根据需求实现里面的相关函数，接下来以一个最简单的 Filter 和一个较复杂一点的 Filter 举例。</p>\n<h3 id=\"最简单的-AVFilter\"><a href=\"#最简单的-AVFilter\" class=\"headerlink\" title=\"最简单的 AVFilter\"></a>最简单的 AVFilter</h3><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> &#123;</span></span><br><span class=\"line\">    <span class=\"type\">const</span> AVClass *<span class=\"class\"><span class=\"keyword\">class</span>;</span></span><br><span class=\"line\">&#125; NoopContext;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">int</span> <span class=\"title function_\">filter_frame</span><span class=\"params\">(AVFilterLink *link, AVFrame *frame)</span> &#123;</span><br><span class=\"line\">    av_log(<span class=\"literal\">NULL</span>, AV_LOG_INFO, <span class=\"string\">&quot;filter frame pts:%lld\\n&quot;</span>, frame-&gt;pts);</span><br><span class=\"line\">    NoopContext *noopContext = link-&gt;dst-&gt;priv;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ff_filter_frame(link-&gt;dst-&gt;outputs[<span class=\"number\">0</span>], frame);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">const</span> AVFilterPad noop_inputs[] = &#123;</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">                .name         = <span class=\"string\">&quot;default&quot;</span>,</span><br><span class=\"line\">                .type         = AVMEDIA_TYPE_VIDEO,</span><br><span class=\"line\">                .filter_frame = filter_frame,</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">const</span> AVFilterPad noop_outputs[] = &#123;</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">                .name = <span class=\"string\">&quot;default&quot;</span>,</span><br><span class=\"line\">                .type = AVMEDIA_TYPE_VIDEO,</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"type\">const</span> AVFilter ff_vf_noop = &#123;</span><br><span class=\"line\">        .name          = <span class=\"string\">&quot;noop&quot;</span>,</span><br><span class=\"line\">        .description   = NULL_IF_CONFIG_SMALL(<span class=\"string\">&quot;Pass the input video unchanged.&quot;</span>),</span><br><span class=\"line\">        .priv_size     = <span class=\"keyword\">sizeof</span>(NoopContext),</span><br><span class=\"line\">        FILTER_INPUTS(noop_inputs),</span><br><span class=\"line\">        FILTER_OUTPUTS(noop_outputs),</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>命令行运行：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">ffmpeg -i test.mp4 -vf &quot;noop&quot; noop.mp4</span><br></pre></td></tr></table></figure>\n<p> 正常输出文件（对原片没有做任何更改）,这个 filter 的作用是将输入的视频帧不做任何处理地传递给下一个过滤器，在处理每帧的时候会打印处理的 PTS，麻雀虽小五脏俱全，它包含了一个 AVFilter 基础的结构：</p>\n<ol>\n<li><p><strong><code>NoopContext</code></strong></p>\n<p>这是一个简单的结构体，包含一个指向 AVClass 的指针。在这个例子中，实际上没有使用到 NoopContext 结构体的任何成员，因为这个过滤器没有需要存储的私有数据。</p>\n</li>\n<li><p><strong><code>filter_frame</code></strong> </p>\n<p>这个函数的作用是处理输入的视频帧。在这个例子中，它只是打印帧的 PTS（Presentation Time Stamp，显示时间戳）并将帧传递给下一个过滤器，不对帧做任何修改。</p>\n</li>\n<li><p><strong><code>noop_inputs</code> 和 <code>noop_outputs</code></strong></p>\n<p>这两个数组定义了过滤器的输入和输出 Pad。在这个例子中，输入 Pad 类型为 AVMEDIA_TYPE_VIDEO，并关联了 <code>filter_frame</code> 函数。输出 Pad 也是 AVMEDIA_TYPE_VIDEO 类型，但没有关联任何函数，因为输出直接由 <code>filter_frame</code> 函数处理。</p>\n</li>\n<li><p><strong><code>ff_vf_noop</code></strong></p>\n<p>这是一个 AVFilter 结构体实例，包含了过滤器的名称、描述、私有数据大小以及输入和输出 Pad。在这个例子中，过滤器的名称为 “noop”，描述为 “Pass the input video unchanged.”，这也就是在执行：<code>ffmpeg -filters</code> 看到的 Filter描述内容。</p>\n</li>\n</ol>\n<p>接下来看一个稍微复杂的一个 AVFilter，实现一个视频的上下翻转</p>\n<h3 id=\"复杂一点的-AVFilter\"><a href=\"#复杂一点的-AVFilter\" class=\"headerlink\" title=\"复杂一点的 AVFilter\"></a>复杂一点的 AVFilter</h3><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">FlipContext</span> &#123;</span></span><br><span class=\"line\">    <span class=\"type\">const</span> AVClass *<span class=\"class\"><span class=\"keyword\">class</span>;</span></span><br><span class=\"line\">    <span class=\"type\">int</span> duration;</span><br><span class=\"line\">&#125; FlipContext;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> OFFSET(x) offsetof(FlipContext, x)</span></span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">const</span> AVOption flip_options[] = &#123;</span><br><span class=\"line\">        &#123;<span class=\"string\">&quot;duration&quot;</span>, <span class=\"string\">&quot;set flip duration&quot;</span>, OFFSET(duration), AV_OPT_TYPE_INT, &#123;.i64 = <span class=\"number\">0</span>&#125;, <span class=\"number\">0</span>, INT_MAX, .flags = AV_OPT_FLAG_FILTERING_PARAM&#125;,</span><br><span class=\"line\">        &#123;<span class=\"literal\">NULL</span>&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">static</span> av_cold <span class=\"type\">int</span> <span class=\"title function_\">flip_init</span><span class=\"params\">(AVFilterContext *ctx)</span> &#123;</span><br><span class=\"line\">    FlipContext *context = ctx-&gt;priv;</span><br><span class=\"line\">    av_log(<span class=\"literal\">NULL</span>, AV_LOG_ERROR, <span class=\"string\">&quot;Input duration: %d.\\n&quot;</span>, context-&gt;duration);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">static</span> av_cold <span class=\"type\">void</span> <span class=\"title function_\">flip_uninit</span><span class=\"params\">(AVFilterContext *ctx)</span> &#123;</span><br><span class=\"line\">    FlipContext *context = ctx-&gt;priv;</span><br><span class=\"line\">    <span class=\"comment\">// no-op 本例无需释放滤镜实例分配的内存、关闭文件、资源等</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 对输入的 AVFrame 进行翻转</span></span><br><span class=\"line\"><span class=\"type\">static</span> AVFrame *<span class=\"title function_\">flip_frame</span><span class=\"params\">(AVFilterContext *ctx, AVFrame *in_frame)</span> &#123;</span><br><span class=\"line\"> \t\tAVFilterLink *inlink = ctx-&gt;inputs[<span class=\"number\">0</span>];</span><br><span class=\"line\">    FlipContext *s = ctx-&gt;priv;</span><br><span class=\"line\">    <span class=\"type\">int64_t</span> pts = in_frame-&gt;pts;</span><br><span class=\"line\">    <span class=\"comment\">// 将时间戳（pts）转化以秒为单位的时间戳</span></span><br><span class=\"line\">    <span class=\"type\">float</span> time_s = TS2T(pts, inlink-&gt;time_base);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (time_s &gt; s-&gt;duration) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 超过对应的时间则直接输出in_frame</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> in_frame;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 创建输出帧并分配内存</span></span><br><span class=\"line\">    AVFrame *out_frame = av_frame_alloc();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!out_frame) &#123;</span><br><span class=\"line\">        av_frame_free(&amp;in_frame);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> out_frame;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 设置输出帧的属性</span></span><br><span class=\"line\">    out_frame-&gt;format = in_frame-&gt;format;</span><br><span class=\"line\">    out_frame-&gt;width = in_frame-&gt;width;</span><br><span class=\"line\">    out_frame-&gt;height = in_frame-&gt;height;</span><br><span class=\"line\">    out_frame-&gt;pts = in_frame-&gt;pts;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 分配输出帧的数据缓冲区</span></span><br><span class=\"line\">    <span class=\"type\">int</span> ret = av_frame_get_buffer(out_frame, <span class=\"number\">32</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ret &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        av_frame_free(&amp;in_frame);</span><br><span class=\"line\">        av_frame_free(&amp;out_frame);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> out_frame;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 这个示例仅适用于 YUV 格式的视频。对于其他格式（如 RGB）</span></span><br><span class=\"line\">    <span class=\"comment\">// 翻转输入帧的数据到输出帧</span></span><br><span class=\"line\">    <span class=\"comment\">// 翻转了 Y 分量，然后翻转了 U 和 V 分量</span></span><br><span class=\"line\">    <span class=\"comment\">//</span></span><br><span class=\"line\">    <span class=\"type\">uint8_t</span> *src_y = in_frame-&gt;data[<span class=\"number\">0</span>];</span><br><span class=\"line\">    <span class=\"type\">uint8_t</span> *src_u = in_frame-&gt;data[<span class=\"number\">1</span>];</span><br><span class=\"line\">    <span class=\"type\">uint8_t</span> *src_v = in_frame-&gt;data[<span class=\"number\">2</span>];</span><br><span class=\"line\">    <span class=\"type\">uint8_t</span> *dst_y = out_frame-&gt;data[<span class=\"number\">0</span>] + (in_frame-&gt;height - <span class=\"number\">1</span>) * out_frame-&gt;linesize[<span class=\"number\">0</span>];</span><br><span class=\"line\">    <span class=\"type\">uint8_t</span> *dst_u = out_frame-&gt;data[<span class=\"number\">1</span>] + (in_frame-&gt;height / <span class=\"number\">2</span> - <span class=\"number\">1</span>) * out_frame-&gt;linesize[<span class=\"number\">1</span>];</span><br><span class=\"line\">    <span class=\"type\">uint8_t</span> *dst_v = out_frame-&gt;data[<span class=\"number\">2</span>] + (in_frame-&gt;height / <span class=\"number\">2</span> - <span class=\"number\">1</span>) * out_frame-&gt;linesize[<span class=\"number\">2</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; in_frame-&gt;height; i++) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">memcpy</span>(dst_y, src_y, in_frame-&gt;width);</span><br><span class=\"line\">        src_y += in_frame-&gt;linesize[<span class=\"number\">0</span>];</span><br><span class=\"line\">        dst_y -= out_frame-&gt;linesize[<span class=\"number\">0</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (i &lt; in_frame-&gt;height / <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">memcpy</span>(dst_u, src_u, in_frame-&gt;width / <span class=\"number\">2</span>);</span><br><span class=\"line\">            <span class=\"built_in\">memcpy</span>(dst_v, src_v, in_frame-&gt;width / <span class=\"number\">2</span>);</span><br><span class=\"line\">            src_u += in_frame-&gt;linesize[<span class=\"number\">1</span>];</span><br><span class=\"line\">            src_v += in_frame-&gt;linesize[<span class=\"number\">2</span>];</span><br><span class=\"line\">            dst_u -= out_frame-&gt;linesize[<span class=\"number\">1</span>];</span><br><span class=\"line\">            dst_v -= out_frame-&gt;linesize[<span class=\"number\">2</span>];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> out_frame;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">int</span> <span class=\"title function_\">activate</span><span class=\"params\">(AVFilterContext *ctx)</span> &#123;</span><br><span class=\"line\">    AVFilterLink *inlink = ctx-&gt;inputs[<span class=\"number\">0</span>];</span><br><span class=\"line\">    AVFilterLink *outlink = ctx-&gt;outputs[<span class=\"number\">0</span>];</span><br><span class=\"line\">    AVFrame *in_frame = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    AVFrame *out_frame = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    <span class=\"type\">int</span> ret = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 获取输入帧</span></span><br><span class=\"line\">    ret = ff_inlink_consume_frame(inlink, &amp;in_frame);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ret &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 如果有输入帧，进行翻转处理</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (in_frame) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 对输出帧进行上下翻转处理</span></span><br><span class=\"line\">        out_frame = flip_frame(ctx, in_frame);</span><br><span class=\"line\">        <span class=\"comment\">// 将处理后的帧放入输出缓冲区</span></span><br><span class=\"line\">        ret = ff_filter_frame(outlink, out_frame);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (ret &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            av_frame_free(&amp;out_frame);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 如果没有输入帧，尝试请求一个新的输入帧</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!in_frame) &#123;</span><br><span class=\"line\">        ff_inlink_request_frame(inlink);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">int</span> status;</span><br><span class=\"line\">    <span class=\"type\">int64_t</span> pts;</span><br><span class=\"line\">    ret = ff_inlink_acknowledge_status(inlink, &amp;status, &amp;pts);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ret &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (status == AVERROR_EOF) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 输入链接已经结束，设置输出链接的状态为 EOF</span></span><br><span class=\"line\">        ff_outlink_set_status(outlink, AVERROR_EOF, pts);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">AVFILTER_DEFINE_CLASS(flip);</span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">const</span> AVFilterPad flip_inputs[] = &#123;</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">                .name = <span class=\"string\">&quot;default&quot;</span>,</span><br><span class=\"line\">                .type = AVMEDIA_TYPE_VIDEO,</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">const</span> AVFilterPad flip_outputs[] = &#123;</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">                .name = <span class=\"string\">&quot;default&quot;</span>,</span><br><span class=\"line\">                .type = AVMEDIA_TYPE_VIDEO,</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"type\">const</span> AVFilter ff_vf_flip = &#123;</span><br><span class=\"line\">        .name = <span class=\"string\">&quot;flip&quot;</span>,</span><br><span class=\"line\">        .description = NULL_IF_CONFIG_SMALL(<span class=\"string\">&quot;Flip the input video.&quot;</span>),</span><br><span class=\"line\">        .priv_size = <span class=\"keyword\">sizeof</span>(FlipContext),</span><br><span class=\"line\">        .priv_class = &amp;flip_class,</span><br><span class=\"line\">        .activate      = activate,</span><br><span class=\"line\">        .init = flip_init,</span><br><span class=\"line\">        .uninit = flip_uninit,</span><br><span class=\"line\">        FILTER_INPUTS(flip_inputs),</span><br><span class=\"line\">        FILTER_OUTPUTS(flip_outputs),</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>命令行运行：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">ffmpeg -i test.mp4 -filter_complex &quot;[0:v]flip=duration=5[out];&quot; -map &quot;[out]&quot; flip.mp4</span><br></pre></td></tr></table></figure>\n<p> 得到渲染好的视频，前5s是上下翻转的，后面的内容正常。</p>\n<p>相比于最简单的 AVFilter 多了几个实现：</p>\n<ol>\n<li><p><strong><code>AVOption flip_options</code></strong></p>\n<p>用于设置翻转持续时间的选项，外部命令配置可选输入<code>duration=5</code>，会自动对数据合法性进行校验。参数类型为 <code>AV_OPT_TYPE_INT</code>，默认值为 0，取值范围为 0 到 <code>INT_MAX</code>。<code>.flags</code> 设置为 <code>AV_OPT_FLAG_FILTERING_PARAM</code>，表示这是一个过滤参数。</p>\n</li>\n<li><p><strong><code>.priv_class</code></strong>  </p>\n<p>配置的<code>flip_class</code>实际是通过 <code>AVFILTER_DEFINE_CLASS(flip);</code> 宏实现的一个声明：见：<a href=\"https://github.com/FFmpeg/FFmpeg/blob/release/6.1/libavfilter/internal.h#L311\">internal.h#AVFILTER_DEFINE_CLASS_EXT</a></p>\n</li>\n<li><p><strong>`</strong>init<code>&amp;</code>uninit`**</p>\n<p>滤镜在初始化或者释放资源的时候将会调用</p>\n</li>\n<li><p><strong><code>activate</code></strong></p>\n<p>这个函数首先获取输入帧，然后调用 <code>flip_frame</code> 函数进行翻转操作，并将处理后的帧放入输出链接。如果没有输入帧，它会请求一个新的输入帧。最后，它会确认输入链接的状态，并根据需要设置输出链接的状态。</p>\n</li>\n</ol>\n<p>这个例子相比最简单的 filter 使用了 <code>activate</code> 函数 用于帧渲染，而不是使用 <code>filter_frame</code>去渲染，这两个方法有什么区别于联系呢？查看：<a href=\"##filter_frame(\">filter_frame和activate方法</a>和activate()函数)</p>\n<p>也能通过 <code>filter_frame</code>实现，对代码部分逻辑更新更改：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">const</span> AVFilterPad flip_inputs[] = &#123;</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">                .name = <span class=\"string\">&quot;default&quot;</span>,</span><br><span class=\"line\">                .type = AVMEDIA_TYPE_VIDEO,</span><br><span class=\"line\">                .filter_frame = filter_frame, <span class=\"comment\">//添加filter_frame 实现</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">const</span> AVFilter ff_vf_flip = &#123;</span><br><span class=\"line\">       ……</span><br><span class=\"line\">        .priv_class = &amp;flip_class,</span><br><span class=\"line\">       <span class=\"comment\">// .activate      = activate,</span></span><br><span class=\"line\">        .init = flip_init,</span><br><span class=\"line\">       ……</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">int</span> <span class=\"title function_\">filter_frame</span><span class=\"params\">(AVFilterLink *inlink, AVFrame *in)</span> &#123;</span><br><span class=\"line\">    AVFilterContext *ctx = inlink-&gt;dst;</span><br><span class=\"line\">    FlipContext *s = ctx-&gt;priv;</span><br><span class=\"line\">    AVFilterLink *outlink = ctx-&gt;outputs[<span class=\"number\">0</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">int64_t</span> pts = in-&gt;pts;</span><br><span class=\"line\">    <span class=\"comment\">// 将时间戳（pts）转化以秒为单位的时间戳</span></span><br><span class=\"line\">    <span class=\"type\">float</span> time_s = TS2T(pts, inlink-&gt;time_base);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (time_s &gt; s-&gt;duration) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 超过对应的时间则直接输出in_frame</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> ff_filter_frame(outlink, in);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        av_log(<span class=\"literal\">NULL</span>, AV_LOG_ERROR, <span class=\"string\">&quot;time_s s: %f.\\n&quot;</span>, time_s);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    AVFrame *out = flip_frame(ctx, in);</span><br><span class=\"line\">    <span class=\"comment\">// 释放输入帧</span></span><br><span class=\"line\">    av_frame_free(&amp;in);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 将输出帧传递给下一个滤镜</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> ff_filter_frame(outlink, out);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>命令行运行，得到的输出结果是一样的。</p>\n<h2 id=\"filter-frame-和activate-函数\"><a href=\"#filter-frame-和activate-函数\" class=\"headerlink\" title=\"filter_frame()和activate()函数\"></a>filter_frame()和activate()函数</h2><p>对于这点查了相关资料，看看源码相关的实现</p>\n<p>参考：<a href=\"https://www.ffmpeg.org/doxygen/5.0/filter__design_8txt.html\">https://www.ffmpeg.org/doxygen/5.0/filter__design_8txt.html</a></p>\n<blockquote>\n<p>The purpose of these rules is to ensure that frames flow in the filter graph without getting stuck and accumulating somewhere. Simple filters that output one frame for each input frame should not have to worry about it. There are two design for filters:one using the  <a href=\"https://www.ffmpeg.org/doxygen/5.0/vsink__nullsink_8c.html#aaa9a0e0f9de1464941d86a984cf77d37\">filter_frame</a>() and <a href=\"https://www.ffmpeg.org/doxygen/5.0/vsrc__mptestsrc_8c.html#a72949c8fcad3f201712a3569fc6888cb\">request_frame</a>() callbacks and the other using the activate() callback. The design using filter_frame() and request_frame() is legacy, but it is suitable for filters that have a single input and process one frame at a time. New filters with several inputs, that treat several frames at a time or that require a special treatment at EOF should probably use the design using activate(). activate ———— This method is called when something must be done in a filter</p>\n</blockquote>\n<p>大意，实现滤镜有两种实现方式：</p>\n<ul>\n<li><p><strong><code>filter_frame()</code></strong></p>\n<p>可以被认为是历史遗留产物。在早期的 AVFilter 设计中，<code>filter_frame()</code> 和 <code>request_frame()</code> 是主要用于处理输入帧和请求输出帧的回调函数。这种设计适用于简单的过滤器，例如单输入且每次处理一个帧的过滤器。</p>\n</li>\n<li><p><strong><code>activate()</code></strong></p>\n<p>随着 ffmpeg 和 AVFilter 的发展，处理需求变得越来越复杂，例如需要处理多个输入、一次处理多个帧或在文件结束（EOF）时进行特殊处理等。为了满足这些需求，引入了 <code>activate()</code> 函数，它提供了更灵活和强大的处理能力。因此，虽然 <code>filter_frame()</code> 在某些简单场景下仍然可以使用，但对于新的或复杂的过滤器，建议使用 <code>activate()</code> 函数。</p>\n</li>\n</ul>\n<p>如果两个方法都实现了，那他们谁会先执行呢？</p>\n<p>对应的源码处理逻辑： <a href=\"https://github.com/FFmpeg/FFmpeg/blob/release/6.1/libavfilter/avfilter.c#L1322\">avfilter.c</a></p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">ff_filter_activate</span><span class=\"params\">(AVFilterContext *filter)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> ret;</span><br><span class=\"line\">\t\t……</span><br><span class=\"line\">    ret = filter-&gt;filter-&gt;activate ? filter-&gt;filter-&gt;activate(filter) :</span><br><span class=\"line\">          ff_filter_activate_default(filter);</span><br><span class=\"line\">  \t……</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果配置了activate() 函数则执行，否则执行 ff_filter_activate_default()-&gt;ff_filter_frame_to_filter()-&gt;ff_filter_frame_framed() 最终执行到配置的 filter_frame() 方法。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">int</span> <span class=\"title function_\">ff_filter_frame_framed</span><span class=\"params\">(AVFilterLink *link, AVFrame *frame)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> (*filter_frame)(AVFilterLink *, AVFrame *);</span><br><span class=\"line\">    AVFilterContext *dstctx = link-&gt;dst;</span><br><span class=\"line\">    AVFilterPad *dst = link-&gt;dstpad;</span><br><span class=\"line\">    <span class=\"type\">int</span> ret;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!(filter_frame = dst-&gt;filter_frame))</span><br><span class=\"line\">        filter_frame = default_filter_frame;</span><br><span class=\"line\">    ……</span><br><span class=\"line\">    ret = filter_frame(link, frame);  <span class=\"comment\">// 最终调用到的地方</span></span><br><span class=\"line\">    link-&gt;frame_count_out++;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">fail:</span><br><span class=\"line\">    ……</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>本文介绍了 FFmpeg 滤镜开发的整体流程，如何编写 filter.c 文件，并以一个最简单的 AVFilter 和一个较为复杂的 AVFilter 为例，解析了滤镜开发的具体步骤和代码实现，并介绍了 filter_frame() 和 activate() 函数的区别与联系。</p>\n<p>在滤镜开发过程中，需要注意的是，filter_frame() 和 activate() 函数的使用取决于滤镜的复杂性。对于简单的滤镜，可以使用 filter_frame() 函数；而对于需要处理多个输入、一次处理多个帧或在文件结束（EOF）时进行特殊处理的复杂滤镜，建议使用 activate() 函数。</p>\n<p>文中的源码可以查看：<a href=\"https://github.com/VomPom/FFmpeg/commit/9176f58ae60e0b70e5708b25017f374deac9fae7\">add most simplest  AVFilter and a simple video flip filter.</a></p>\n<h3 id=\"参考：\"><a href=\"#参考：\" class=\"headerlink\" title=\"参考：\"></a>参考：</h3><p><a href=\"https://www.cnblogs.com/TaigaCon/p/10171464.html\">https://www.cnblogs.com/TaigaCon/p/10171464.html</a></p>\n<p><a href=\"https://www.cnblogs.com/ranson7zop/p/7728639.html\">https://www.cnblogs.com/ranson7zop/p/7728639.html</a></p>\n<p><a href=\"https://www.ffmpeg.org/doxygen/5.0/filter__design_8txt.html\">https://www.ffmpeg.org/doxygen/5.0/filter__design_8txt.html</a></p>\n","cover":null,"images":[],"content":"<p>此前在做  ffmpeg+某个第三库作为 filter 的集成，第三库是做AE特效相关的，与 ffmpeg 结合能让视频渲染效果大大提升。整体流程将第三方库作为 ffmpeg 的一个filter 形式进行结合，其中就涉及到 ffmpeg 的 filter 开发，本文即 对ffmpeg 的滤镜开发流程作一个总结。本文以实现一个视频垂直翻转的 filter 为例，ffmpeg 源码基于<a href=\"https://github.com/FFmpeg/FFmpeg/tree/release/6.1\">FFmpeg6.1</a> </p>\n<h2 id=\"实现自定义-Filter-流程\"><a href=\"#实现自定义-Filter-流程\" class=\"headerlink\" title=\"实现自定义 Filter 流程\"></a>实现自定义 Filter 流程</h2><ul>\n<li><p>编写 filter.c 文件</p>\n<p>一般视频滤镜以 vf_ 为前缀，视频滤镜以 af_ 为前缀，放在libavfilter目录下，参考其他 filter 代码逻辑，模块化配置相关参数，本文例以 vf_flip.c 实现视频的上下翻转</p>\n</li>\n<li><p>在 <code>libavfilter/allfilters.c</code> 注册</p>\n<p>例如：extern const AVFilter ff_vf_flip;  <code>ff_vf_flip</code>就是在 <code>vf_flip.c</code>的 filter 注册名称</p>\n</li>\n<li><p>修改 <code>libavfilter/Makefile</code> 添加编译配置： </p>\n<p>例如：OBJS-$(CONFIG_FLIP_FILTER)                   += vf_flip.o</p>\n</li>\n<li><p>编译打包</p>\n</li>\n</ul>\n<h2 id=\"编写-filter-c-文件\"><a href=\"#编写-filter-c-文件\" class=\"headerlink\" title=\"编写 filter.c 文件\"></a>编写 filter.c 文件</h2><h3 id=\"AVFilter主体\"><a href=\"#AVFilter主体\" class=\"headerlink\" title=\"AVFilter主体\"></a>AVFilter主体</h3><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">AVFilter</span> &#123;</span></span><br><span class=\"line\">  <span class=\"type\">const</span> <span class=\"type\">char</span> *name;</span><br><span class=\"line\">  <span class=\"type\">const</span> <span class=\"type\">char</span> *description;</span><br><span class=\"line\">  <span class=\"type\">const</span> AVFilterPad *inputs;</span><br><span class=\"line\">  <span class=\"type\">const</span> AVFilterPad *outputs;</span><br><span class=\"line\">  <span class=\"type\">const</span> AVClass *priv_class;</span><br><span class=\"line\">  <span class=\"type\">int</span> flags;</span><br><span class=\"line\">  <span class=\"type\">int</span> (*preinit)(AVFilterContext *ctx);</span><br><span class=\"line\">  <span class=\"type\">int</span> (*init)(AVFilterContext *ctx);</span><br><span class=\"line\">  <span class=\"type\">int</span> (*init_dict)(AVFilterContext *ctx, AVDictionary **options);</span><br><span class=\"line\">  <span class=\"type\">void</span> (*uninit)(AVFilterContext *ctx);</span><br><span class=\"line\">  <span class=\"type\">int</span> (*query_formats)(AVFilterContext *);</span><br><span class=\"line\">  <span class=\"type\">int</span> priv_size;   </span><br><span class=\"line\">  <span class=\"type\">int</span> flags_internal; </span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">AVFilter</span> *<span class=\"title\">next</span>;</span></span><br><span class=\"line\">  <span class=\"type\">int</span> (*process_command)(AVFilterContext *, <span class=\"type\">const</span> <span class=\"type\">char</span> *cmd, <span class=\"type\">const</span> <span class=\"type\">char</span> *arg, <span class=\"type\">char</span> *res, <span class=\"type\">int</span> res_len, <span class=\"type\">int</span> flags);</span><br><span class=\"line\">  <span class=\"type\">int</span> (*init_opaque)(AVFilterContext *ctx, <span class=\"type\">void</span> *opaque);</span><br><span class=\"line\">  <span class=\"type\">int</span> (*activate)(AVFilterContext *ctx);</span><br><span class=\"line\">&#125; AVFilter;</span><br></pre></td></tr></table></figure>\n<p>具体里面的属性作用可以参考：<a href=\"https://www.cnblogs.com/TaigaCon/p/10171464.html\">[ffmpeg] 定制滤波器</a>，可以根据需求实现里面的相关函数，接下来以一个最简单的 Filter 和一个较复杂一点的 Filter 举例。</p>\n<h3 id=\"最简单的-AVFilter\"><a href=\"#最简单的-AVFilter\" class=\"headerlink\" title=\"最简单的 AVFilter\"></a>最简单的 AVFilter</h3><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> &#123;</span></span><br><span class=\"line\">    <span class=\"type\">const</span> AVClass *<span class=\"class\"><span class=\"keyword\">class</span>;</span></span><br><span class=\"line\">&#125; NoopContext;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">int</span> <span class=\"title function_\">filter_frame</span><span class=\"params\">(AVFilterLink *link, AVFrame *frame)</span> &#123;</span><br><span class=\"line\">    av_log(<span class=\"literal\">NULL</span>, AV_LOG_INFO, <span class=\"string\">&quot;filter frame pts:%lld\\n&quot;</span>, frame-&gt;pts);</span><br><span class=\"line\">    NoopContext *noopContext = link-&gt;dst-&gt;priv;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ff_filter_frame(link-&gt;dst-&gt;outputs[<span class=\"number\">0</span>], frame);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">const</span> AVFilterPad noop_inputs[] = &#123;</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">                .name         = <span class=\"string\">&quot;default&quot;</span>,</span><br><span class=\"line\">                .type         = AVMEDIA_TYPE_VIDEO,</span><br><span class=\"line\">                .filter_frame = filter_frame,</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">const</span> AVFilterPad noop_outputs[] = &#123;</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">                .name = <span class=\"string\">&quot;default&quot;</span>,</span><br><span class=\"line\">                .type = AVMEDIA_TYPE_VIDEO,</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"type\">const</span> AVFilter ff_vf_noop = &#123;</span><br><span class=\"line\">        .name          = <span class=\"string\">&quot;noop&quot;</span>,</span><br><span class=\"line\">        .description   = NULL_IF_CONFIG_SMALL(<span class=\"string\">&quot;Pass the input video unchanged.&quot;</span>),</span><br><span class=\"line\">        .priv_size     = <span class=\"keyword\">sizeof</span>(NoopContext),</span><br><span class=\"line\">        FILTER_INPUTS(noop_inputs),</span><br><span class=\"line\">        FILTER_OUTPUTS(noop_outputs),</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>命令行运行：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">ffmpeg -i test.mp4 -vf &quot;noop&quot; noop.mp4</span><br></pre></td></tr></table></figure>\n<p> 正常输出文件（对原片没有做任何更改）,这个 filter 的作用是将输入的视频帧不做任何处理地传递给下一个过滤器，在处理每帧的时候会打印处理的 PTS，麻雀虽小五脏俱全，它包含了一个 AVFilter 基础的结构：</p>\n<ol>\n<li><p><strong><code>NoopContext</code></strong></p>\n<p>这是一个简单的结构体，包含一个指向 AVClass 的指针。在这个例子中，实际上没有使用到 NoopContext 结构体的任何成员，因为这个过滤器没有需要存储的私有数据。</p>\n</li>\n<li><p><strong><code>filter_frame</code></strong> </p>\n<p>这个函数的作用是处理输入的视频帧。在这个例子中，它只是打印帧的 PTS（Presentation Time Stamp，显示时间戳）并将帧传递给下一个过滤器，不对帧做任何修改。</p>\n</li>\n<li><p><strong><code>noop_inputs</code> 和 <code>noop_outputs</code></strong></p>\n<p>这两个数组定义了过滤器的输入和输出 Pad。在这个例子中，输入 Pad 类型为 AVMEDIA_TYPE_VIDEO，并关联了 <code>filter_frame</code> 函数。输出 Pad 也是 AVMEDIA_TYPE_VIDEO 类型，但没有关联任何函数，因为输出直接由 <code>filter_frame</code> 函数处理。</p>\n</li>\n<li><p><strong><code>ff_vf_noop</code></strong></p>\n<p>这是一个 AVFilter 结构体实例，包含了过滤器的名称、描述、私有数据大小以及输入和输出 Pad。在这个例子中，过滤器的名称为 “noop”，描述为 “Pass the input video unchanged.”，这也就是在执行：<code>ffmpeg -filters</code> 看到的 Filter描述内容。</p>\n</li>\n</ol>\n<p>接下来看一个稍微复杂的一个 AVFilter，实现一个视频的上下翻转</p>\n<h3 id=\"复杂一点的-AVFilter\"><a href=\"#复杂一点的-AVFilter\" class=\"headerlink\" title=\"复杂一点的 AVFilter\"></a>复杂一点的 AVFilter</h3><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">FlipContext</span> &#123;</span></span><br><span class=\"line\">    <span class=\"type\">const</span> AVClass *<span class=\"class\"><span class=\"keyword\">class</span>;</span></span><br><span class=\"line\">    <span class=\"type\">int</span> duration;</span><br><span class=\"line\">&#125; FlipContext;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> OFFSET(x) offsetof(FlipContext, x)</span></span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">const</span> AVOption flip_options[] = &#123;</span><br><span class=\"line\">        &#123;<span class=\"string\">&quot;duration&quot;</span>, <span class=\"string\">&quot;set flip duration&quot;</span>, OFFSET(duration), AV_OPT_TYPE_INT, &#123;.i64 = <span class=\"number\">0</span>&#125;, <span class=\"number\">0</span>, INT_MAX, .flags = AV_OPT_FLAG_FILTERING_PARAM&#125;,</span><br><span class=\"line\">        &#123;<span class=\"literal\">NULL</span>&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">static</span> av_cold <span class=\"type\">int</span> <span class=\"title function_\">flip_init</span><span class=\"params\">(AVFilterContext *ctx)</span> &#123;</span><br><span class=\"line\">    FlipContext *context = ctx-&gt;priv;</span><br><span class=\"line\">    av_log(<span class=\"literal\">NULL</span>, AV_LOG_ERROR, <span class=\"string\">&quot;Input duration: %d.\\n&quot;</span>, context-&gt;duration);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">static</span> av_cold <span class=\"type\">void</span> <span class=\"title function_\">flip_uninit</span><span class=\"params\">(AVFilterContext *ctx)</span> &#123;</span><br><span class=\"line\">    FlipContext *context = ctx-&gt;priv;</span><br><span class=\"line\">    <span class=\"comment\">// no-op 本例无需释放滤镜实例分配的内存、关闭文件、资源等</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 对输入的 AVFrame 进行翻转</span></span><br><span class=\"line\"><span class=\"type\">static</span> AVFrame *<span class=\"title function_\">flip_frame</span><span class=\"params\">(AVFilterContext *ctx, AVFrame *in_frame)</span> &#123;</span><br><span class=\"line\"> \t\tAVFilterLink *inlink = ctx-&gt;inputs[<span class=\"number\">0</span>];</span><br><span class=\"line\">    FlipContext *s = ctx-&gt;priv;</span><br><span class=\"line\">    <span class=\"type\">int64_t</span> pts = in_frame-&gt;pts;</span><br><span class=\"line\">    <span class=\"comment\">// 将时间戳（pts）转化以秒为单位的时间戳</span></span><br><span class=\"line\">    <span class=\"type\">float</span> time_s = TS2T(pts, inlink-&gt;time_base);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (time_s &gt; s-&gt;duration) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 超过对应的时间则直接输出in_frame</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> in_frame;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 创建输出帧并分配内存</span></span><br><span class=\"line\">    AVFrame *out_frame = av_frame_alloc();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!out_frame) &#123;</span><br><span class=\"line\">        av_frame_free(&amp;in_frame);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> out_frame;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 设置输出帧的属性</span></span><br><span class=\"line\">    out_frame-&gt;format = in_frame-&gt;format;</span><br><span class=\"line\">    out_frame-&gt;width = in_frame-&gt;width;</span><br><span class=\"line\">    out_frame-&gt;height = in_frame-&gt;height;</span><br><span class=\"line\">    out_frame-&gt;pts = in_frame-&gt;pts;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 分配输出帧的数据缓冲区</span></span><br><span class=\"line\">    <span class=\"type\">int</span> ret = av_frame_get_buffer(out_frame, <span class=\"number\">32</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ret &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        av_frame_free(&amp;in_frame);</span><br><span class=\"line\">        av_frame_free(&amp;out_frame);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> out_frame;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 这个示例仅适用于 YUV 格式的视频。对于其他格式（如 RGB）</span></span><br><span class=\"line\">    <span class=\"comment\">// 翻转输入帧的数据到输出帧</span></span><br><span class=\"line\">    <span class=\"comment\">// 翻转了 Y 分量，然后翻转了 U 和 V 分量</span></span><br><span class=\"line\">    <span class=\"comment\">//</span></span><br><span class=\"line\">    <span class=\"type\">uint8_t</span> *src_y = in_frame-&gt;data[<span class=\"number\">0</span>];</span><br><span class=\"line\">    <span class=\"type\">uint8_t</span> *src_u = in_frame-&gt;data[<span class=\"number\">1</span>];</span><br><span class=\"line\">    <span class=\"type\">uint8_t</span> *src_v = in_frame-&gt;data[<span class=\"number\">2</span>];</span><br><span class=\"line\">    <span class=\"type\">uint8_t</span> *dst_y = out_frame-&gt;data[<span class=\"number\">0</span>] + (in_frame-&gt;height - <span class=\"number\">1</span>) * out_frame-&gt;linesize[<span class=\"number\">0</span>];</span><br><span class=\"line\">    <span class=\"type\">uint8_t</span> *dst_u = out_frame-&gt;data[<span class=\"number\">1</span>] + (in_frame-&gt;height / <span class=\"number\">2</span> - <span class=\"number\">1</span>) * out_frame-&gt;linesize[<span class=\"number\">1</span>];</span><br><span class=\"line\">    <span class=\"type\">uint8_t</span> *dst_v = out_frame-&gt;data[<span class=\"number\">2</span>] + (in_frame-&gt;height / <span class=\"number\">2</span> - <span class=\"number\">1</span>) * out_frame-&gt;linesize[<span class=\"number\">2</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; in_frame-&gt;height; i++) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">memcpy</span>(dst_y, src_y, in_frame-&gt;width);</span><br><span class=\"line\">        src_y += in_frame-&gt;linesize[<span class=\"number\">0</span>];</span><br><span class=\"line\">        dst_y -= out_frame-&gt;linesize[<span class=\"number\">0</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (i &lt; in_frame-&gt;height / <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">memcpy</span>(dst_u, src_u, in_frame-&gt;width / <span class=\"number\">2</span>);</span><br><span class=\"line\">            <span class=\"built_in\">memcpy</span>(dst_v, src_v, in_frame-&gt;width / <span class=\"number\">2</span>);</span><br><span class=\"line\">            src_u += in_frame-&gt;linesize[<span class=\"number\">1</span>];</span><br><span class=\"line\">            src_v += in_frame-&gt;linesize[<span class=\"number\">2</span>];</span><br><span class=\"line\">            dst_u -= out_frame-&gt;linesize[<span class=\"number\">1</span>];</span><br><span class=\"line\">            dst_v -= out_frame-&gt;linesize[<span class=\"number\">2</span>];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> out_frame;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">int</span> <span class=\"title function_\">activate</span><span class=\"params\">(AVFilterContext *ctx)</span> &#123;</span><br><span class=\"line\">    AVFilterLink *inlink = ctx-&gt;inputs[<span class=\"number\">0</span>];</span><br><span class=\"line\">    AVFilterLink *outlink = ctx-&gt;outputs[<span class=\"number\">0</span>];</span><br><span class=\"line\">    AVFrame *in_frame = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    AVFrame *out_frame = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    <span class=\"type\">int</span> ret = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 获取输入帧</span></span><br><span class=\"line\">    ret = ff_inlink_consume_frame(inlink, &amp;in_frame);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ret &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 如果有输入帧，进行翻转处理</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (in_frame) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 对输出帧进行上下翻转处理</span></span><br><span class=\"line\">        out_frame = flip_frame(ctx, in_frame);</span><br><span class=\"line\">        <span class=\"comment\">// 将处理后的帧放入输出缓冲区</span></span><br><span class=\"line\">        ret = ff_filter_frame(outlink, out_frame);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (ret &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            av_frame_free(&amp;out_frame);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 如果没有输入帧，尝试请求一个新的输入帧</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!in_frame) &#123;</span><br><span class=\"line\">        ff_inlink_request_frame(inlink);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">int</span> status;</span><br><span class=\"line\">    <span class=\"type\">int64_t</span> pts;</span><br><span class=\"line\">    ret = ff_inlink_acknowledge_status(inlink, &amp;status, &amp;pts);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ret &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (status == AVERROR_EOF) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 输入链接已经结束，设置输出链接的状态为 EOF</span></span><br><span class=\"line\">        ff_outlink_set_status(outlink, AVERROR_EOF, pts);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">AVFILTER_DEFINE_CLASS(flip);</span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">const</span> AVFilterPad flip_inputs[] = &#123;</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">                .name = <span class=\"string\">&quot;default&quot;</span>,</span><br><span class=\"line\">                .type = AVMEDIA_TYPE_VIDEO,</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">const</span> AVFilterPad flip_outputs[] = &#123;</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">                .name = <span class=\"string\">&quot;default&quot;</span>,</span><br><span class=\"line\">                .type = AVMEDIA_TYPE_VIDEO,</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"type\">const</span> AVFilter ff_vf_flip = &#123;</span><br><span class=\"line\">        .name = <span class=\"string\">&quot;flip&quot;</span>,</span><br><span class=\"line\">        .description = NULL_IF_CONFIG_SMALL(<span class=\"string\">&quot;Flip the input video.&quot;</span>),</span><br><span class=\"line\">        .priv_size = <span class=\"keyword\">sizeof</span>(FlipContext),</span><br><span class=\"line\">        .priv_class = &amp;flip_class,</span><br><span class=\"line\">        .activate      = activate,</span><br><span class=\"line\">        .init = flip_init,</span><br><span class=\"line\">        .uninit = flip_uninit,</span><br><span class=\"line\">        FILTER_INPUTS(flip_inputs),</span><br><span class=\"line\">        FILTER_OUTPUTS(flip_outputs),</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>命令行运行：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">ffmpeg -i test.mp4 -filter_complex &quot;[0:v]flip=duration=5[out];&quot; -map &quot;[out]&quot; flip.mp4</span><br></pre></td></tr></table></figure>\n<p> 得到渲染好的视频，前5s是上下翻转的，后面的内容正常。</p>\n<p>相比于最简单的 AVFilter 多了几个实现：</p>\n<ol>\n<li><p><strong><code>AVOption flip_options</code></strong></p>\n<p>用于设置翻转持续时间的选项，外部命令配置可选输入<code>duration=5</code>，会自动对数据合法性进行校验。参数类型为 <code>AV_OPT_TYPE_INT</code>，默认值为 0，取值范围为 0 到 <code>INT_MAX</code>。<code>.flags</code> 设置为 <code>AV_OPT_FLAG_FILTERING_PARAM</code>，表示这是一个过滤参数。</p>\n</li>\n<li><p><strong><code>.priv_class</code></strong>  </p>\n<p>配置的<code>flip_class</code>实际是通过 <code>AVFILTER_DEFINE_CLASS(flip);</code> 宏实现的一个声明：见：<a href=\"https://github.com/FFmpeg/FFmpeg/blob/release/6.1/libavfilter/internal.h#L311\">internal.h#AVFILTER_DEFINE_CLASS_EXT</a></p>\n</li>\n<li><p><strong>`</strong>init<code>&amp;</code>uninit`**</p>\n<p>滤镜在初始化或者释放资源的时候将会调用</p>\n</li>\n<li><p><strong><code>activate</code></strong></p>\n<p>这个函数首先获取输入帧，然后调用 <code>flip_frame</code> 函数进行翻转操作，并将处理后的帧放入输出链接。如果没有输入帧，它会请求一个新的输入帧。最后，它会确认输入链接的状态，并根据需要设置输出链接的状态。</p>\n</li>\n</ol>\n<p>这个例子相比最简单的 filter 使用了 <code>activate</code> 函数 用于帧渲染，而不是使用 <code>filter_frame</code>去渲染，这两个方法有什么区别于联系呢？查看：<a href=\"##filter_frame(\">filter_frame和activate方法</a>和activate()函数)</p>\n<p>也能通过 <code>filter_frame</code>实现，对代码部分逻辑更新更改：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">const</span> AVFilterPad flip_inputs[] = &#123;</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">                .name = <span class=\"string\">&quot;default&quot;</span>,</span><br><span class=\"line\">                .type = AVMEDIA_TYPE_VIDEO,</span><br><span class=\"line\">                .filter_frame = filter_frame, <span class=\"comment\">//添加filter_frame 实现</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">const</span> AVFilter ff_vf_flip = &#123;</span><br><span class=\"line\">       ……</span><br><span class=\"line\">        .priv_class = &amp;flip_class,</span><br><span class=\"line\">       <span class=\"comment\">// .activate      = activate,</span></span><br><span class=\"line\">        .init = flip_init,</span><br><span class=\"line\">       ……</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">int</span> <span class=\"title function_\">filter_frame</span><span class=\"params\">(AVFilterLink *inlink, AVFrame *in)</span> &#123;</span><br><span class=\"line\">    AVFilterContext *ctx = inlink-&gt;dst;</span><br><span class=\"line\">    FlipContext *s = ctx-&gt;priv;</span><br><span class=\"line\">    AVFilterLink *outlink = ctx-&gt;outputs[<span class=\"number\">0</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">int64_t</span> pts = in-&gt;pts;</span><br><span class=\"line\">    <span class=\"comment\">// 将时间戳（pts）转化以秒为单位的时间戳</span></span><br><span class=\"line\">    <span class=\"type\">float</span> time_s = TS2T(pts, inlink-&gt;time_base);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (time_s &gt; s-&gt;duration) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 超过对应的时间则直接输出in_frame</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> ff_filter_frame(outlink, in);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        av_log(<span class=\"literal\">NULL</span>, AV_LOG_ERROR, <span class=\"string\">&quot;time_s s: %f.\\n&quot;</span>, time_s);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    AVFrame *out = flip_frame(ctx, in);</span><br><span class=\"line\">    <span class=\"comment\">// 释放输入帧</span></span><br><span class=\"line\">    av_frame_free(&amp;in);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 将输出帧传递给下一个滤镜</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> ff_filter_frame(outlink, out);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>命令行运行，得到的输出结果是一样的。</p>\n<h2 id=\"filter-frame-和activate-函数\"><a href=\"#filter-frame-和activate-函数\" class=\"headerlink\" title=\"filter_frame()和activate()函数\"></a>filter_frame()和activate()函数</h2><p>对于这点查了相关资料，看看源码相关的实现</p>\n<p>参考：<a href=\"https://www.ffmpeg.org/doxygen/5.0/filter__design_8txt.html\">https://www.ffmpeg.org/doxygen/5.0/filter__design_8txt.html</a></p>\n<blockquote>\n<p>The purpose of these rules is to ensure that frames flow in the filter graph without getting stuck and accumulating somewhere. Simple filters that output one frame for each input frame should not have to worry about it. There are two design for filters:one using the  <a href=\"https://www.ffmpeg.org/doxygen/5.0/vsink__nullsink_8c.html#aaa9a0e0f9de1464941d86a984cf77d37\">filter_frame</a>() and <a href=\"https://www.ffmpeg.org/doxygen/5.0/vsrc__mptestsrc_8c.html#a72949c8fcad3f201712a3569fc6888cb\">request_frame</a>() callbacks and the other using the activate() callback. The design using filter_frame() and request_frame() is legacy, but it is suitable for filters that have a single input and process one frame at a time. New filters with several inputs, that treat several frames at a time or that require a special treatment at EOF should probably use the design using activate(). activate ———— This method is called when something must be done in a filter</p>\n</blockquote>\n<p>大意，实现滤镜有两种实现方式：</p>\n<ul>\n<li><p><strong><code>filter_frame()</code></strong></p>\n<p>可以被认为是历史遗留产物。在早期的 AVFilter 设计中，<code>filter_frame()</code> 和 <code>request_frame()</code> 是主要用于处理输入帧和请求输出帧的回调函数。这种设计适用于简单的过滤器，例如单输入且每次处理一个帧的过滤器。</p>\n</li>\n<li><p><strong><code>activate()</code></strong></p>\n<p>随着 ffmpeg 和 AVFilter 的发展，处理需求变得越来越复杂，例如需要处理多个输入、一次处理多个帧或在文件结束（EOF）时进行特殊处理等。为了满足这些需求，引入了 <code>activate()</code> 函数，它提供了更灵活和强大的处理能力。因此，虽然 <code>filter_frame()</code> 在某些简单场景下仍然可以使用，但对于新的或复杂的过滤器，建议使用 <code>activate()</code> 函数。</p>\n</li>\n</ul>\n<p>如果两个方法都实现了，那他们谁会先执行呢？</p>\n<p>对应的源码处理逻辑： <a href=\"https://github.com/FFmpeg/FFmpeg/blob/release/6.1/libavfilter/avfilter.c#L1322\">avfilter.c</a></p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">ff_filter_activate</span><span class=\"params\">(AVFilterContext *filter)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> ret;</span><br><span class=\"line\">\t\t……</span><br><span class=\"line\">    ret = filter-&gt;filter-&gt;activate ? filter-&gt;filter-&gt;activate(filter) :</span><br><span class=\"line\">          ff_filter_activate_default(filter);</span><br><span class=\"line\">  \t……</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果配置了activate() 函数则执行，否则执行 ff_filter_activate_default()-&gt;ff_filter_frame_to_filter()-&gt;ff_filter_frame_framed() 最终执行到配置的 filter_frame() 方法。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">int</span> <span class=\"title function_\">ff_filter_frame_framed</span><span class=\"params\">(AVFilterLink *link, AVFrame *frame)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> (*filter_frame)(AVFilterLink *, AVFrame *);</span><br><span class=\"line\">    AVFilterContext *dstctx = link-&gt;dst;</span><br><span class=\"line\">    AVFilterPad *dst = link-&gt;dstpad;</span><br><span class=\"line\">    <span class=\"type\">int</span> ret;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!(filter_frame = dst-&gt;filter_frame))</span><br><span class=\"line\">        filter_frame = default_filter_frame;</span><br><span class=\"line\">    ……</span><br><span class=\"line\">    ret = filter_frame(link, frame);  <span class=\"comment\">// 最终调用到的地方</span></span><br><span class=\"line\">    link-&gt;frame_count_out++;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">fail:</span><br><span class=\"line\">    ……</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>本文介绍了 FFmpeg 滤镜开发的整体流程，如何编写 filter.c 文件，并以一个最简单的 AVFilter 和一个较为复杂的 AVFilter 为例，解析了滤镜开发的具体步骤和代码实现，并介绍了 filter_frame() 和 activate() 函数的区别与联系。</p>\n<p>在滤镜开发过程中，需要注意的是，filter_frame() 和 activate() 函数的使用取决于滤镜的复杂性。对于简单的滤镜，可以使用 filter_frame() 函数；而对于需要处理多个输入、一次处理多个帧或在文件结束（EOF）时进行特殊处理的复杂滤镜，建议使用 activate() 函数。</p>\n<p>文中的源码可以查看：<a href=\"https://github.com/VomPom/FFmpeg/commit/9176f58ae60e0b70e5708b25017f374deac9fae7\">add most simplest  AVFilter and a simple video flip filter.</a></p>\n<h3 id=\"参考：\"><a href=\"#参考：\" class=\"headerlink\" title=\"参考：\"></a>参考：</h3><p><a href=\"https://www.cnblogs.com/TaigaCon/p/10171464.html\">https://www.cnblogs.com/TaigaCon/p/10171464.html</a></p>\n<p><a href=\"https://www.cnblogs.com/ranson7zop/p/7728639.html\">https://www.cnblogs.com/ranson7zop/p/7728639.html</a></p>\n<p><a href=\"https://www.ffmpeg.org/doxygen/5.0/filter__design_8txt.html\">https://www.ffmpeg.org/doxygen/5.0/filter__design_8txt.html</a></p>\n","categories":[{"name":"技术文章","slug":"technology","api":"api/categories/technology.json"}],"tags":[{"name":"FFmpeg","slug":"FFmpeg","api":"api/tags/FFmpeg.json"},{"name":"音视频","slug":"音视频","api":"api/tags/音视频.json"}],"api":"api/posts/2024/03/07/实现一个自定义FFmpeg-Filter.json"},{"title":"RecyclerView自定义LayoutManager从0到1实践","slug":"自定义LayoutManager从0到1实践","date":"2023-10-31T11:19:00.000Z","updated":"2025-05-20T11:46:57.000Z","comments":true,"url":"2023/10/31/自定义LayoutManager从0到1实践/","excerpt":"<p>此前大部分涉及到 RecyclerView 页面的 LayoutManager基本上用系统提供的 LinearLayoutManager 、GridLayoutManager 就能解决，但在一些特殊场景上还是需要我们自定义  LayoutManager。之前基本上没有自己写过，在网上看各种源码各种文章，刚开始花了好多时间去理解整体流程，因为它们都给我一种非常非常复杂的感觉，包括相关的博客文章也是。经过一段时间摸索，也慢慢能理解为什么要那么复杂了，这的确不是特别容易入门。所以对整体的流程进行了一个拆解，尽量原子化一点，对自己学习的一个总结，也希望能帮助到一部分人能对  LayoutManager 入门。</p>\n<p>本文最终实现一个简单的 LinearLayoutManager（只支持 VERTICAL）方向，适合对 LayoutManager 整体流程的学习与理解，整体代码分为多个文件，每个文件都是对前一段代码的补充，方便理解，整体项目源码已提交 Github: <a href=\"https://github.com/VomPom/LayoutManagerGradually\">LayoutManagerGradually</a>，代码里面写了很多很多注释，如果不想浪费时间，可以直接看代码运行，跳过这篇文章，把每一个 LayoutManager 都跑一下体验结合代码看看。</p>\n<h2 id=\"自定义-LayoutManager-的必要元素\"><a href=\"#自定义-LayoutManager-的必要元素\" class=\"headerlink\" title=\"自定义 LayoutManager 的必要元素\"></a>自定义 LayoutManager 的必要元素</h2><ul>\n<li><p>继承 <code>RecyclerView.LayoutManager</code> 并实现 <code>generateDefaultLayoutParams()</code>方法</p>\n</li>\n<li><p>重写<code>onLayoutChildren</code> 第一次数据填充的时候数据添加</p>\n</li>\n<li><p>重写 <code>canScrollHorizontally()</code> 和<code>canScrollVertically()</code>方法设定支持滑动的方向</p>\n</li>\n<li><p>重写 <code>scrollHorizontallyBy()</code>和<code>scrollVerticallyBy()</code>方法，在滑动的时候对屏幕以外的 View 进行回收，以及填充即将滑动进入屏幕范围内的 View 进行填充</p>\n</li>\n<li><p>重写 <code>scrollToPosition()</code>和<code>smoothScrollToPosition()</code>方法支持</p>\n</li>\n</ul>\n<p>其中<code>onLayoutChildren</code> 和 <code>scrollHorizontallyBy/scrollVerticallyBy</code> 是最核心且最复杂的方法，这里稍微拎出来讲一下</p>\n<h3 id=\"onLayoutChildren\"><a href=\"#onLayoutChildren\" class=\"headerlink\" title=\"onLayoutChildren\"></a>onLayoutChildren</h3><p>这个方法类似于自定义 ViewGroup 的 onLayout() 方法，RecyclerView 的 LayoutManager.onLayoutChildren 在以下几个时机会被触发：</p>\n<ul>\n<li>当 <code>RecyclerView</code> 首次附加到窗口时</li>\n<li>当<code>Adapter</code>  的数据集发生变化</li>\n<li>当 <code>RecyclerView</code> 被 执行 <code>RequetLayout</code>的时候</li>\n<li>当 <code>LayoutManager</code> 发生变化时</li>\n</ul>\n<h3 id=\"scrollHorizontallyBy-scrollVerticallyBy\"><a href=\"#scrollHorizontallyBy-scrollVerticallyBy\" class=\"headerlink\" title=\"scrollHorizontallyBy/scrollVerticallyBy\"></a>scrollHorizontallyBy/scrollVerticallyBy</h3><p>方法的主要作用包括：</p>\n<ol>\n<li><p>更新 ItemView 的位置：根据传入的垂直滚动距离（dy 参数），更新子视图在屏幕上的位置。通常调用 <code>offsetChildrenVertical</code> 方法。</p>\n</li>\n<li><p>回收不可见的 ItemView：在滚动过程中，一些 ItemView 可能会离开屏幕，变得不可见。<code>scrollVerticallyBy</code> 方法需要负责回收这些子视图并将它们放入回收池，以便稍后复用。</p>\n</li>\n<li><p>添加新的 ItemView：在滚动过程中，新的 ItemView 可能需要显示在屏幕上。<code>scrollVerticallyBy</code> 方法需要从回收池中获取可复用的视图并将它们添加到屏幕上。这通常涉及到调用 <code>RecyclerView.Recycler</code> 的 <code>getViewForPosition</code> 方法。</p>\n</li>\n<li><p>返回实际滚动距离：由于 ItemView 的数量有限，滚动可能会受到限制。例如，当滚动到列表顶部或底部时，滚动可能会停止。在这种情况下，实际滚动的距离可能会小于传入的 <code>dy</code> 参数。<code>scrollVerticallyBy</code> 方法需要返回实际滚动的距离，以便 <code>RecyclerView</code> 可以正确地更新滚动条和触发滚动事件。</p>\n</li>\n</ol>\n<p>概念就简单讲这么多， talk is cheap show me the code，直接看代码理解会比较深刻</p>\n<h2 id=\"逐步实现\"><a href=\"#逐步实现\" class=\"headerlink\" title=\"逐步实现\"></a>逐步实现</h2><p>要实现一个可用的 LayoutManger 通常我们需要实现以下流程</p>\n<ul>\n<li>数据填充并且只需要填充屏幕范围内的 ItemView</li>\n<li>回收掉屏幕以外的 ItemView</li>\n<li>屏幕外 ItemView 再回到屏幕后，需要重新填充</li>\n<li>对滑动边界边界进行处理</li>\n<li>对 scrollToPosition 和 smoothScrollToPosition进行支持</li>\n</ul>\n<p>我们不用一上来就实现最终的效果，而是一步一步来，看看 LayoutManger 是怎么渐渐地变化，最终能跑起来的。</p>\n<h3 id=\"0-最简单的-LayoutManager\"><a href=\"#0-最简单的-LayoutManager\" class=\"headerlink\" title=\"0 最简单的 LayoutManager\"></a>0 最简单的 LayoutManager</h3><p>代码查看：<a href=\"https://github.com/VomPom/LayoutManagerGradually/tree/main/layoutmanager/src/main/java/com/julis/layoutmanager/series/MostSimpleLayoutManager.kt\">MostSimpleLayoutManager</a>，我们关注 <code>onLayoutChildren</code> 方法:</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onLayoutChildren</span><span class=\"params\">(recycler: <span class=\"type\">RecyclerView</span>.<span class=\"type\">Recycler</span>, state: <span class=\"type\">RecyclerView</span>.<span class=\"type\">State</span>?)</span></span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 垂直方向的偏移量</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> offsetTop = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"comment\">// 实际业务中最好不要这样一次性加载所有的数据，这里只是最简单地演示一下整体是如何工作的</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (itemIndex <span class=\"keyword\">in</span> <span class=\"number\">0</span> until itemCount) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 从适配器获取与给定位置关联的视图</span></span><br><span class=\"line\">        <span class=\"keyword\">val</span> itemView = recycler.getViewForPosition(itemIndex)</span><br><span class=\"line\">        <span class=\"comment\">// 将视图添加到 RecyclerView 中</span></span><br><span class=\"line\">        addView(itemView)</span><br><span class=\"line\">        <span class=\"comment\">// 测量并布局视图</span></span><br><span class=\"line\">        measureChildWithMargins(itemView, <span class=\"number\">0</span>, <span class=\"number\">0</span>)</span><br><span class=\"line\">        <span class=\"comment\">// 拿到宽高（包括ItemDecoration）</span></span><br><span class=\"line\">        <span class=\"keyword\">val</span> width = getDecoratedMeasuredWidth(itemView)</span><br><span class=\"line\">        <span class=\"keyword\">val</span> height = getDecoratedMeasuredHeight(itemView)</span><br><span class=\"line\">        <span class=\"comment\">// 对要添加的子 View 进行布局</span></span><br><span class=\"line\">        layoutDecorated(itemView, <span class=\"number\">0</span>, offsetTop, width, offsetTop + height)</span><br><span class=\"line\">        offsetTop += height</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面的代码主要演示了，如何利用<code>addView</code> <code>layoutDecorated</code>等方法，将 ItemView 添加到 RecyclerView 上。代码可见是 将所有的 ItemView（即使它在屏幕上不可见）一次性全部加载到了 RecyclerView上， 这里一般不这么做，只是这里这里只是最简单地演示一下整体是如何工作的。</p>\n<p>运行在手机上能看到这样的效果：Item数据已经被全部添加到界面上了，并且各个方向的滑动都支持。</p>\n<img src=\"https://cdn.julis.wang/blog/img/layoutmanager_gradually_0.gif?imageView2/2/w/300\">\n<h3 id=\"1-更合理的数据添加方式\"><a href=\"#1-更合理的数据添加方式\" class=\"headerlink\" title=\"1 更合理的数据添加方式\"></a>1 更合理的数据添加方式</h3><p>代码查看：<a href=\"https://github.com/VomPom/LayoutManagerGradually/tree/main/layoutmanager/src/main/java/com/julis/layoutmanager/series/LinearLayoutManager1\">LinearLayoutManager1.kt</a></p>\n<p>对最开始的代码进行优化，只在屏幕范围内的区域进行数据的添加，这样就不需要一次性将所有数据就添加上去，如果 Adapter 的 ItemCount 足够巨大，for all addView 的话，很容易就 OOM。</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onLayoutChildren</span><span class=\"params\">(recycler: <span class=\"type\">RecyclerView</span>.<span class=\"type\">Recycler</span>, state: <span class=\"type\">RecyclerView</span>.<span class=\"type\">State</span>)</span></span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 垂直方向上的的空间大小</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> remainSpace = height - paddingTop</span><br><span class=\"line\">    <span class=\"comment\">//垂直方向的偏移量</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> offsetTop = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> currentPosition = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (remainSpace &gt; <span class=\"number\">0</span> &amp;&amp; currentPosition &lt; state.itemCount) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 从适配器获取与给定位置关联的视图</span></span><br><span class=\"line\">        <span class=\"keyword\">val</span> itemView = recycler.getViewForPosition(currentPosition)</span><br><span class=\"line\">        <span class=\"comment\">// 将视图添加到 RecyclerView 中</span></span><br><span class=\"line\">        addView(itemView)</span><br><span class=\"line\">        <span class=\"comment\">// 测量并布局视图</span></span><br><span class=\"line\">        measureChildWithMargins(itemView, <span class=\"number\">0</span>, <span class=\"number\">0</span>)</span><br><span class=\"line\">        <span class=\"comment\">// 拿到宽高（包括ItemDecoration）</span></span><br><span class=\"line\">        <span class=\"keyword\">val</span> itemWidth = getDecoratedMeasuredWidth(itemView)</span><br><span class=\"line\">        <span class=\"keyword\">val</span> itemHeight = getDecoratedMeasuredHeight(itemView)</span><br><span class=\"line\">        <span class=\"comment\">// 对要添加的子 View 进行布局</span></span><br><span class=\"line\">        layoutDecorated(itemView, <span class=\"number\">0</span>, offsetTop, itemWidth, offsetTop + itemHeight)</span><br><span class=\"line\">        offsetTop += itemHeight</span><br><span class=\"line\">        currentPosition++</span><br><span class=\"line\">        <span class=\"comment\">// 可用空间减少</span></span><br><span class=\"line\">        remainSpace -= itemHeight</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-对屏幕外的View回收\"><a href=\"#2-对屏幕外的View回收\" class=\"headerlink\" title=\"2 对屏幕外的View回收\"></a>2 对屏幕外的View回收</h3><p>代码查看：<a href=\"https://github.com/VomPom/LayoutManagerGradually/tree/main/layoutmanager/src/main/java/com/julis/layoutmanager/series/LinearLayoutManager2.kt\">LinearLayoutManager2</a></p>\n<p>RecylerView 没有 recycler 怎么行呢？当 RecylerView 的 ItemView 滑出屏幕后我们需要对齐进行回收，实现的话需要在 <code>scrollVerticallyBy</code>中，比较复杂的逻辑就是怎么去判断：ItemView 在屏幕以外，最后利用：<code>removeAndRecycleView</code>方法进行回收</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">scrollVerticallyBy</span><span class=\"params\">(dy: <span class=\"type\">Int</span>, recycler: <span class=\"type\">RecyclerView</span>.<span class=\"type\">Recycler</span>, state: <span class=\"type\">RecyclerView</span>.<span class=\"type\">State</span>?)</span></span>: <span class=\"built_in\">Int</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 在这里处理上下的滚动逻辑，dy 表示滚动的距离</span></span><br><span class=\"line\">      <span class=\"comment\">// 平移所有子视图</span></span><br><span class=\"line\">      offsetChildrenVertical(-dy)</span><br><span class=\"line\">      <span class=\"comment\">// 如果实际滚动距离与 dy 相同，返回 dy；如果未滚动，返回 0</span></span><br><span class=\"line\">      recycleInvisibleView(dy, recycler)</span><br><span class=\"line\">      <span class=\"keyword\">return</span> dy</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 回收掉在界面上看不到的 ItemView</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> dy</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> recycler</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">recycleInvisibleView</span><span class=\"params\">(dy: <span class=\"type\">Int</span>, recycler: <span class=\"type\">RecyclerView</span>.<span class=\"type\">Recycler</span>)</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">val</span> totalSpace = orientationHelper.totalSpace</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 将要回收View的集合</span></span><br><span class=\"line\">    <span class=\"keyword\">val</span> recycleViews = hashSetOf&lt;View&gt;()</span><br><span class=\"line\">    <span class=\"comment\">// 从下往上滑</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (dy &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (i <span class=\"keyword\">in</span> <span class=\"number\">0</span> until childCount) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">val</span> child = getChildAt(i)!!</span><br><span class=\"line\">            <span class=\"comment\">// 从下往上滑从最上面的 item 开始计算</span></span><br><span class=\"line\">            <span class=\"keyword\">val</span> top = getDecoratedTop(child)</span><br><span class=\"line\">            <span class=\"comment\">// 判断最顶部的 item 是否已经完全不可见，如何可见，那说明底下的 item 也是可见</span></span><br><span class=\"line\">            <span class=\"keyword\">val</span> height = top - getDecoratedBottom(child)</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (height - top &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">break</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            recycleViews.add(child)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (dy &lt; <span class=\"number\">0</span>) &#123;   <span class=\"comment\">// 从上往下滑</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (i <span class=\"keyword\">in</span> childCount - <span class=\"number\">1</span> downTo <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">val</span> child = getChildAt(i)!!</span><br><span class=\"line\">            <span class=\"comment\">// 从上往下滑从最底部的 item 开始计算</span></span><br><span class=\"line\">            <span class=\"keyword\">val</span> bottom = getDecoratedBottom(child)</span><br><span class=\"line\">            <span class=\"comment\">// 判断最底部的 item 是否已经完全不可见，如何可见，那说明上面的 item 也是可见</span></span><br><span class=\"line\">            <span class=\"keyword\">val</span> height = bottom - getDecoratedTop(child)</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (bottom - totalSpace &lt; height) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">break</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            recycleViews.add(child)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 真正把 View 移除掉的逻辑</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (view <span class=\"keyword\">in</span> recycleViews) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// [removeAndRecycleView]</span></span><br><span class=\"line\">        <span class=\"comment\">// 用于从视图层次结构中删除某个视图，并将其资源回收，以便在需要时重新利用</span></span><br><span class=\"line\">        removeAndRecycleView(view, recycler)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    recycleViews.clear()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>运行在手机上能看到这样的效果：滑出屏幕外的ItemView 被回收掉了</p>\n<img src=\"https://cdn.julis.wang/blog/img/layoutmanager_gradually_2.gif?imageView2/2/w/300\">\n<h3 id=\"3-向上滑动的时View的填充\"><a href=\"#3-向上滑动的时View的填充\" class=\"headerlink\" title=\"3 向上滑动的时View的填充\"></a>3 向上滑动的时View的填充</h3><p>代码查看：<a href=\"https://github.com/VomPom/LayoutManagerGradually/tree/main/layoutmanager/src/main/java/com/julis/layoutmanager/series/LinearLayoutManager3.kt\">LinearLayoutManager3</a></p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">scrollVerticallyBy</span><span class=\"params\">(dy: <span class=\"type\">Int</span>, recycler: <span class=\"type\">RecyclerView</span>.<span class=\"type\">Recycler</span>, state: <span class=\"type\">RecyclerView</span>.<span class=\"type\">State</span>?)</span></span>: <span class=\"built_in\">Int</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 填充 view</span></span><br><span class=\"line\">    fillView(dy, recycler)</span><br><span class=\"line\">    <span class=\"comment\">// 移动 view</span></span><br><span class=\"line\">    offsetChildrenVertical(-dy)</span><br><span class=\"line\">    <span class=\"comment\">// 回收 View</span></span><br><span class=\"line\">    recycleInvisibleView(dy, recycler)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> dy</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 填充重新进入屏幕内的 ItemView</span></span><br><span class=\"line\"><span class=\"comment\"> *     getChildCount():childCount-&gt; 当前屏幕内RecyclerView展示的 ItemView 数量</span></span><br><span class=\"line\"><span class=\"comment\"> *     getItemCount():itemCount-&gt; 最大的 ItemView 数量，也就是 Adapter 传递的数据的数量</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">fillView</span><span class=\"params\">(dy: <span class=\"type\">Int</span>, recycler: <span class=\"type\">RecyclerView</span>.<span class=\"type\">Recycler</span>)</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">val</span> verticalSpace = orientationVerticalHelper.totalSpace</span><br><span class=\"line\">    <span class=\"keyword\">var</span> remainSpace = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> nextFillPosition = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"comment\">//垂直方向的偏移量</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> offsetTop = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> offsetLeft = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"comment\">// 从下往上滑，那么需要向底部添加数据</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (dy &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">val</span> anchorView = getChildAt(childCount - <span class=\"number\">1</span>) ?: <span class=\"keyword\">return</span></span><br><span class=\"line\">        <span class=\"keyword\">val</span> anchorPosition = getPosition(anchorView)</span><br><span class=\"line\">        <span class=\"keyword\">val</span> anchorBottom = getDecoratedBottom(anchorView)</span><br><span class=\"line\">        <span class=\"keyword\">val</span> anchorLeft = getDecoratedLeft(anchorView)</span><br><span class=\"line\">        remainSpace = verticalSpace - anchorBottom</span><br><span class=\"line\">        <span class=\"comment\">// 垂直可用的数据为&lt;0，意外着这时候屏幕底部的位置刚好在最底部的 ItemView 上，还需要向上滑动一点点...我们才能添加 View</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (remainSpace &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        nextFillPosition = anchorPosition + <span class=\"number\">1</span></span><br><span class=\"line\">        offsetTop = anchorBottom</span><br><span class=\"line\">        offsetLeft = anchorLeft</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (nextFillPosition &gt;= itemCount) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (dy &lt; <span class=\"number\">0</span>) &#123;  <span class=\"comment\">// 从上往下滑，那么需要向顶部添加数据</span></span><br><span class=\"line\">        <span class=\"comment\">//no-op 暂时不实现从上往下滑的底部数据填充</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (remainSpace &gt; <span class=\"number\">0</span> &amp;&amp; nextFillPosition &lt; itemCount) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 从适配器获取与给定位置关联的视图</span></span><br><span class=\"line\">        <span class=\"keyword\">val</span> itemView = recycler.getViewForPosition(nextFillPosition)</span><br><span class=\"line\">        <span class=\"comment\">// 将视图添加到 RecyclerView 中</span></span><br><span class=\"line\">        addView(itemView)</span><br><span class=\"line\">        <span class=\"comment\">// 测量并布局视图</span></span><br><span class=\"line\">        measureChildWithMargins(itemView, <span class=\"number\">0</span>, <span class=\"number\">0</span>)</span><br><span class=\"line\">        <span class=\"comment\">// 拿到宽高（包括ItemDecoration）</span></span><br><span class=\"line\">        <span class=\"keyword\">val</span> itemWidth = getDecoratedMeasuredWidth(itemView)</span><br><span class=\"line\">        <span class=\"keyword\">val</span> itemHeight = getDecoratedMeasuredHeight(itemView)</span><br><span class=\"line\">        <span class=\"comment\">// 对要添加的子 View 进行布局，相比onLayoutChildren 里面的实现添加了：offsetLeft（因为我们没有禁止掉 左右的滑动）</span></span><br><span class=\"line\">        <span class=\"comment\">// 试着把 offsetLeft 改成0，也就是最原始的样子，然后左右上下滑滑，你会有意外收获</span></span><br><span class=\"line\">        layoutDecorated(itemView, offsetLeft, offsetTop, itemWidth + offsetLeft, offsetTop + itemHeight)</span><br><span class=\"line\">        offsetTop += itemHeight</span><br><span class=\"line\">        nextFillPosition++</span><br><span class=\"line\">        <span class=\"comment\">// 可用空间减少</span></span><br><span class=\"line\">        remainSpace -= itemHeight</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>运行在手机上能看到这样的效果：向上滑动的时候，底部陆续有元素填充，但向下滑动的时候没有填充数据</p>\n<img src=\"https://cdn.julis.wang/blog/img/layoutmanager_gradually_3.gif?imageView2/2/w/300\">\n<h3 id=\"4-两个方向的View填充\"><a href=\"#4-两个方向的View填充\" class=\"headerlink\" title=\"4 两个方向的View填充\"></a>4 两个方向的View填充</h3><p>代码查看：<a href=\"https://github.com/VomPom/LayoutManagerGradually/tree/main/layoutmanager/src/main/java/com/julis/layoutmanager/series/LinearLayoutManager4.kt\">LinearLayoutManager4</a></p>\n<p>补齐从上往下滑之后添加的逻辑</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">fillView</span><span class=\"params\">(dy: <span class=\"type\">Int</span>, recycler: <span class=\"type\">RecyclerView</span>.<span class=\"type\">Recycler</span>)</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">val</span> verticalSpace = orientationVerticalHelper.totalSpace</span><br><span class=\"line\">    <span class=\"keyword\">var</span> remainSpace = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> nextFillPosition = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"comment\">//垂直方向的偏移量</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> offsetTop = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> offsetLeft = <span class=\"number\">0</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 从下往上滑，那么需要向底部添加数据</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (dy &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        ……</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (dy &lt; <span class=\"number\">0</span>) &#123;  <span class=\"comment\">// 从上往下滑，那么需要向顶部添加数据</span></span><br><span class=\"line\">        <span class=\"keyword\">val</span> anchorView = getChildAt(<span class=\"number\">0</span>) ?: <span class=\"keyword\">return</span></span><br><span class=\"line\">        <span class=\"keyword\">val</span> anchorPosition = getPosition(anchorView)</span><br><span class=\"line\">        <span class=\"keyword\">val</span> anchorTop = getDecoratedTop(anchorView)</span><br><span class=\"line\">        offsetLeft = getDecoratedLeft(anchorView)</span><br><span class=\"line\">        remainSpace = anchorTop</span><br><span class=\"line\">        <span class=\"comment\">// 垂直可用的数据为&lt;0，意外着这时候屏幕顶部的位置刚好在最底部的 ItemView 上，还需要向下滑动一点点...我们才能添加 View</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (anchorTop &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        nextFillPosition = anchorPosition - <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (nextFillPosition &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">val</span> itemHeight = getDecoratedMeasuredHeight(anchorView)</span><br><span class=\"line\">        <span class=\"comment\">// 新的布局的itemView 的顶部位置应该以 anchorTop - itemHeight 开始</span></span><br><span class=\"line\">        offsetTop = anchorTop - itemHeight</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (remainSpace &gt; <span class=\"number\">0</span> &amp;&amp;</span><br><span class=\"line\">        ((nextFillPosition &lt; itemCount) &amp;&amp; (nextFillPosition &gt;= <span class=\"number\">0</span>))</span><br><span class=\"line\">    ) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 从适配器获取与给定位置关联的视图</span></span><br><span class=\"line\">        <span class=\"keyword\">val</span> itemView = recycler.getViewForPosition(nextFillPosition)</span><br><span class=\"line\">        <span class=\"comment\">// 将视图添加到 RecyclerView 中k，从顶部添加的话，需要加到最前的位置</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (dy &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            addView(itemView)</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            addView(itemView, <span class=\"number\">0</span>)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        ……</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (dy &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            offsetTop += itemHeight</span><br><span class=\"line\">            nextFillPosition++</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            offsetTop -= itemHeight</span><br><span class=\"line\">            nextFillPosition--</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 可用空间减少</span></span><br><span class=\"line\">        remainSpace -= itemHeight</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>运行在手机上能看到这样的效果：向上或者滑动的时候，底部陆续都有元素填充</p>\n<img src=\"https://cdn.julis.wang/blog/img/layoutmanager_gradually_4.gif?imageView2/2/w/300\">\n<h3 id=\"5-对顶部和底部滑动边界处理\"><a href=\"#5-对顶部和底部滑动边界处理\" class=\"headerlink\" title=\"5 对顶部和底部滑动边界处理\"></a>5 对顶部和底部滑动边界处理</h3><p>代码查看：<a href=\"https://github.com/VomPom/LayoutManagerGradually/tree/main/layoutmanager/src/main/java/com/julis/layoutmanager/series/LinearLayoutManager5.kt\">LinearLayoutManager5</a></p>\n<p>对于前面的实现会发现会：不停地下滑或者上滑会留出来巨大的空白。这里对填充 View 的逻辑进行改造，需要进行边界检测。</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">scrollVerticallyBy</span><span class=\"params\">(dy: <span class=\"type\">Int</span>, recycler: <span class=\"type\">RecyclerView</span>.<span class=\"type\">Recycler</span>, state: <span class=\"type\">RecyclerView</span>.<span class=\"type\">State</span>?)</span></span>: <span class=\"built_in\">Int</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 填充 view</span></span><br><span class=\"line\">    <span class=\"keyword\">val</span> adjustedDy = fillView(dy, recycler)</span><br><span class=\"line\">    <span class=\"comment\">// 移动 view</span></span><br><span class=\"line\">    offsetChildrenVertical(-adjustedDy)</span><br><span class=\"line\">    <span class=\"comment\">// 回收 View</span></span><br><span class=\"line\">    recycleInvisibleView(adjustedDy, recycler)</span><br><span class=\"line\">    <span class=\"comment\">// 由于需要对边界进行限制，所以需要对原始的 dy 进行修正，这里不再直接返回 dy</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> adjustedDy</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>这里的整体注释我写在了代码里面，可以看图稍微理解一下，以向上滑动为例：假设这一次滑动的距离非常非常大(想象成10000像素)，如果直接滑动的话，我们有50个元素，每个元素高度100像素，最大高度也只有50x100=5000，那么滑动后一定会留下大量空区域。需要对当前传入的这 10000 像素做调整：只给到可滑动的最大距离，如果不能滑动了就返回0。</p>\n<img src=\"https://cdn.julis.wang/blog/img/5_scroll_limit.png\">\n<p>运行在手机上能看到这样的效果：向上或者滑动的时候，达到最大的位置时候是不能再滑动的。</p>\n<img src=\"https://cdn.julis.wang/blog/img/layoutmanager_gradually_5.gif?imageView2/2/w/300\">\n<h3 id=\"6-实现-scrollToPosition\"><a href=\"#6-实现-scrollToPosition\" class=\"headerlink\" title=\"6 实现 scrollToPosition\"></a>6 实现 scrollToPosition</h3><p>代码查看：<a href=\"https://github.com/VomPom/LayoutManagerGradually/tree/main/layoutmanager/src/main/java/com/julis/layoutmanager/series/LinearLayoutManager6.kt\">LinearLayoutManager6</a></p>\n<p>到这里这个 LinearLayoutManager 看着已经能正常运行了，但一般还需要支持<code>scrollToPosition</code> 和 <code>smoothScrollToPositio</code></p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">var</span> mPendingScrollPosition = RecyclerView.NO_POSITION</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">scrollToPosition</span><span class=\"params\">(position: <span class=\"type\">Int</span>)</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>.scrollToPosition(position)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (position &lt; <span class=\"number\">0</span> || position &gt;= itemCount) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    mPendingScrollPosition = position</span><br><span class=\"line\">    requestLayout()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onLayoutChildren</span><span class=\"params\">(recycler: <span class=\"type\">RecyclerView</span>.<span class=\"type\">Recycler</span>, state: <span class=\"type\">RecyclerView</span>.<span class=\"type\">State</span>)</span></span> &#123;</span><br><span class=\"line\">    ……</span><br><span class=\"line\">    <span class=\"keyword\">var</span> currentPosition = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mPendingScrollPosition != RecyclerView.NO_POSITION) &#123;</span><br><span class=\"line\">        currentPosition = mPendingScrollPosition</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (remainSpace &gt; <span class=\"number\">0</span> &amp;&amp; currentPosition &lt; state.itemCount) &#123;</span><br><span class=\"line\">      …… <span class=\"comment\">// 填充View 的逻辑</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>scrollToPosition</code> 的实现比较简单，如上代码所示：在 <code>scrollToPosition</code>  的时候记录一次目标position，再 requestLayout 一波，还记得之前有提到过：<code>onLayoutChildren</code> 会在 <code>requestLayout</code> 的时候调用一次，于是再将<code>onLayoutChildren</code>逻辑改写，不再从第0个元素开始，而是从目标位置进行布局。</p>\n<p>运行在手机上能看到这样的效果：点击 scrollTo30 将会滑动到 第30个位置。</p>\n<img src=\"https://cdn.julis.wang/blog/img/layoutmanager_gradually_6.gif?imageView2/2/w/300\">\n<h3 id=\"7-实现-smoothScrollToPosition\"><a href=\"#7-实现-smoothScrollToPosition\" class=\"headerlink\" title=\"7 实现 smoothScrollToPosition\"></a>7 实现 smoothScrollToPosition</h3><p>代码查看：<a href=\"https://github.com/VomPom/LayoutManagerGradually/tree/main/layoutmanager/src/main/java/com/julis/layoutmanager/series/LinearLayoutManager7.kt\">LinearLayoutManager7</a>  </p>\n<p>要实现自定义的 smoothScrollToPosition 动画效果，这一块如果要完全自己实现的话比较复杂，可以直接使用系统提供的 LinearSmoothScroller改造,也可以继承 RecyclerView.SmoothScroller 自定义，也可以完全不使用 SmoothScroller， 照着 SmoothScroller 的实现使用类似 ValueAnimator 自定义动画，添加动画 UpdateListener，在 onAnimationUpdate 的时候动态计算布局从而实现滑动动画,这里拿 LinearSmoothScroller 举例:</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">smoothScrollToPosition</span><span class=\"params\">(</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">    recyclerView: <span class=\"type\">RecyclerView</span>,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">    state: <span class=\"type\">RecyclerView</span>.<span class=\"type\">State</span>,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">    position: <span class=\"type\">Int</span></span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">)</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (position &gt;= itemCount || position &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">val</span> scroller: LinearSmoothScroller = <span class=\"keyword\">object</span> : LinearSmoothScroller(recyclerView.context) &#123;</span><br><span class=\"line\">        <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">         * 这个方法用于计算滚动到目标位置所需的滚动向量。滚动向量是一个二维向量，包含水平和垂直方向上的滚动距离</span></span><br><span class=\"line\"><span class=\"comment\">         *</span></span><br><span class=\"line\"><span class=\"comment\">         * <span class=\"doctag\">@param</span> targetPosition 滑动的目标位置</span></span><br><span class=\"line\"><span class=\"comment\">         * <span class=\"doctag\">@return</span>  返回一个 PointF 对象，表示滚动向量。</span></span><br><span class=\"line\"><span class=\"comment\">         *              PointF.x 表示水平方向上的滚动距离，</span></span><br><span class=\"line\"><span class=\"comment\">         *              PointF.y 表示垂直方向上的滚动距离</span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\">        <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">computeScrollVectorForPosition</span><span class=\"params\">(targetPosition: <span class=\"type\">Int</span>)</span></span>: PointF &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 查找到屏幕里显示的第 1 个元素与</span></span><br><span class=\"line\">            <span class=\"keyword\">val</span> firstChildPos = getPosition(getChildAt(<span class=\"number\">0</span>)!!)</span><br><span class=\"line\">            <span class=\"keyword\">val</span> direction = <span class=\"keyword\">if</span> (targetPosition &lt; firstChildPos) -<span class=\"number\">1</span> <span class=\"keyword\">else</span> <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"comment\">// x 左右滑动，由于我们只实现了垂直的滑动，所以 x方向为0即可</span></span><br><span class=\"line\">            <span class=\"comment\">// 整数代表正向移动，负数代表反向移动，这里的数值大小不重要，源码里面最终都会 normalize 归一化处理</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> PointF(<span class=\"number\">0f</span>, direction.toFloat())</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">         * 计算每像素速度</span></span><br><span class=\"line\"><span class=\"comment\">         *</span></span><br><span class=\"line\"><span class=\"comment\">         * <span class=\"doctag\">@param</span> displayMetrics</span></span><br><span class=\"line\"><span class=\"comment\">         * <span class=\"doctag\">@return</span> 返回每一像素的耗时，单位ms，假设返回值是1.0 代表着：1ms 内会滑动 1像素，1s会滑动1000像素</span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\">        <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">calculateSpeedPerPixel</span><span class=\"params\">(displayMetrics: <span class=\"type\">DisplayMetrics</span>?)</span></span>: <span class=\"built_in\">Float</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">super</span>.calculateSpeedPerPixel(displayMetrics)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">         * 滑动速度的插值（实现滑动速度随着滑动时间的变化）</span></span><br><span class=\"line\"><span class=\"comment\">         *</span></span><br><span class=\"line\"><span class=\"comment\">         * <span class=\"doctag\">@param</span> dx</span></span><br><span class=\"line\"><span class=\"comment\">         * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\">        <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">calculateTimeForDeceleration</span><span class=\"params\">(dx: <span class=\"type\">Int</span>)</span></span>: <span class=\"built_in\">Int</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">super</span>.calculateTimeForDeceleration(dx)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 很多方法可以使用，不再一一列举</span></span><br><span class=\"line\">        <span class=\"comment\">// ...</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    scroller.targetPosition = position</span><br><span class=\"line\">    <span class=\"comment\">// 执行默认动画的逻辑</span></span><br><span class=\"line\">    startSmoothScroll(scroller)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>运行在手机上能看到这样的效果：点击 smoothScrollTo30 将会有个动画效果滑动到第30个位置。</p>\n<img src=\"https://cdn.julis.wang/blog/img/layoutmanager_gradually_7.gif?imageView2/2/w/300\">\n<p>以上基本上一个自定义 LayoutManager 的雏形就已经完成了，虽然只实现了一个方向的滑动，但是其原理都是一样的，剩下的就是各种细节的打磨了，可以加各种自己想要的效果，比如：指定位置 放大一定的系数，或者更炫酷的滑动动画…</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>本文主要整理了自定义 LayoutManager 的必要元素，以及其核心方法 scrollHorizontallyBy/scrollVerticallyBy、onLayoutChildren 的作用与调用时机，接下对实现一个简单的 LinearLayoutManger 进行逻辑拆解，从最简单的不滑动回收和填充以及不含滑动边界检测，到最终一个具备基本功能的 LayoutManger</p>\n<p>源码：<a href=\"https://github.com/VomPom/LayoutManagerGradually\">https://github.com/VomPom/LayoutManagerGradually</a></p>\n<p>参考：</p>\n<p><a href=\"https://juejin.cn/post/6870770285247725581?searchId=202310181005138A6D82B1DEE9C47A9797#heading-23\">《看完这篇文章你还不会自定义LayoutManager，我吃X！》</a></p>\n<p><a href=\"https://github.com/MycroftWong/FlowLayoutManager/blob/master/LayoutManager%E5%88%86%E6%9E%90%E4%B8%8E%E5%AE%9E%E8%B7%B5.md\">《/LayoutManager分析与实践》</a></p>\n<p><a href=\"https://wiresareobsolete.com/2014/09/building-a-recyclerview-layoutmanager-part-1/\">Building a RecyclerView LayoutManager – Part 1</a></p>\n","cover":null,"images":["https://cdn.julis.wang/blog/img/layoutmanager_gradually_0.gif?imageView2/2/w/300","https://cdn.julis.wang/blog/img/layoutmanager_gradually_2.gif?imageView2/2/w/300","https://cdn.julis.wang/blog/img/layoutmanager_gradually_3.gif?imageView2/2/w/300","https://cdn.julis.wang/blog/img/layoutmanager_gradually_4.gif?imageView2/2/w/300","https://cdn.julis.wang/blog/img/5_scroll_limit.png","https://cdn.julis.wang/blog/img/layoutmanager_gradually_5.gif?imageView2/2/w/300","https://cdn.julis.wang/blog/img/layoutmanager_gradually_6.gif?imageView2/2/w/300","https://cdn.julis.wang/blog/img/layoutmanager_gradually_7.gif?imageView2/2/w/300"],"content":"<p>此前大部分涉及到 RecyclerView 页面的 LayoutManager基本上用系统提供的 LinearLayoutManager 、GridLayoutManager 就能解决，但在一些特殊场景上还是需要我们自定义  LayoutManager。之前基本上没有自己写过，在网上看各种源码各种文章，刚开始花了好多时间去理解整体流程，因为它们都给我一种非常非常复杂的感觉，包括相关的博客文章也是。经过一段时间摸索，也慢慢能理解为什么要那么复杂了，这的确不是特别容易入门。所以对整体的流程进行了一个拆解，尽量原子化一点，对自己学习的一个总结，也希望能帮助到一部分人能对  LayoutManager 入门。</p>\n<p>本文最终实现一个简单的 LinearLayoutManager（只支持 VERTICAL）方向，适合对 LayoutManager 整体流程的学习与理解，整体代码分为多个文件，每个文件都是对前一段代码的补充，方便理解，整体项目源码已提交 Github: <a href=\"https://github.com/VomPom/LayoutManagerGradually\">LayoutManagerGradually</a>，代码里面写了很多很多注释，如果不想浪费时间，可以直接看代码运行，跳过这篇文章，把每一个 LayoutManager 都跑一下体验结合代码看看。</p>\n<h2 id=\"自定义-LayoutManager-的必要元素\"><a href=\"#自定义-LayoutManager-的必要元素\" class=\"headerlink\" title=\"自定义 LayoutManager 的必要元素\"></a>自定义 LayoutManager 的必要元素</h2><ul>\n<li><p>继承 <code>RecyclerView.LayoutManager</code> 并实现 <code>generateDefaultLayoutParams()</code>方法</p>\n</li>\n<li><p>重写<code>onLayoutChildren</code> 第一次数据填充的时候数据添加</p>\n</li>\n<li><p>重写 <code>canScrollHorizontally()</code> 和<code>canScrollVertically()</code>方法设定支持滑动的方向</p>\n</li>\n<li><p>重写 <code>scrollHorizontallyBy()</code>和<code>scrollVerticallyBy()</code>方法，在滑动的时候对屏幕以外的 View 进行回收，以及填充即将滑动进入屏幕范围内的 View 进行填充</p>\n</li>\n<li><p>重写 <code>scrollToPosition()</code>和<code>smoothScrollToPosition()</code>方法支持</p>\n</li>\n</ul>\n<p>其中<code>onLayoutChildren</code> 和 <code>scrollHorizontallyBy/scrollVerticallyBy</code> 是最核心且最复杂的方法，这里稍微拎出来讲一下</p>\n<h3 id=\"onLayoutChildren\"><a href=\"#onLayoutChildren\" class=\"headerlink\" title=\"onLayoutChildren\"></a>onLayoutChildren</h3><p>这个方法类似于自定义 ViewGroup 的 onLayout() 方法，RecyclerView 的 LayoutManager.onLayoutChildren 在以下几个时机会被触发：</p>\n<ul>\n<li>当 <code>RecyclerView</code> 首次附加到窗口时</li>\n<li>当<code>Adapter</code>  的数据集发生变化</li>\n<li>当 <code>RecyclerView</code> 被 执行 <code>RequetLayout</code>的时候</li>\n<li>当 <code>LayoutManager</code> 发生变化时</li>\n</ul>\n<h3 id=\"scrollHorizontallyBy-scrollVerticallyBy\"><a href=\"#scrollHorizontallyBy-scrollVerticallyBy\" class=\"headerlink\" title=\"scrollHorizontallyBy/scrollVerticallyBy\"></a>scrollHorizontallyBy/scrollVerticallyBy</h3><p>方法的主要作用包括：</p>\n<ol>\n<li><p>更新 ItemView 的位置：根据传入的垂直滚动距离（dy 参数），更新子视图在屏幕上的位置。通常调用 <code>offsetChildrenVertical</code> 方法。</p>\n</li>\n<li><p>回收不可见的 ItemView：在滚动过程中，一些 ItemView 可能会离开屏幕，变得不可见。<code>scrollVerticallyBy</code> 方法需要负责回收这些子视图并将它们放入回收池，以便稍后复用。</p>\n</li>\n<li><p>添加新的 ItemView：在滚动过程中，新的 ItemView 可能需要显示在屏幕上。<code>scrollVerticallyBy</code> 方法需要从回收池中获取可复用的视图并将它们添加到屏幕上。这通常涉及到调用 <code>RecyclerView.Recycler</code> 的 <code>getViewForPosition</code> 方法。</p>\n</li>\n<li><p>返回实际滚动距离：由于 ItemView 的数量有限，滚动可能会受到限制。例如，当滚动到列表顶部或底部时，滚动可能会停止。在这种情况下，实际滚动的距离可能会小于传入的 <code>dy</code> 参数。<code>scrollVerticallyBy</code> 方法需要返回实际滚动的距离，以便 <code>RecyclerView</code> 可以正确地更新滚动条和触发滚动事件。</p>\n</li>\n</ol>\n<p>概念就简单讲这么多， talk is cheap show me the code，直接看代码理解会比较深刻</p>\n<h2 id=\"逐步实现\"><a href=\"#逐步实现\" class=\"headerlink\" title=\"逐步实现\"></a>逐步实现</h2><p>要实现一个可用的 LayoutManger 通常我们需要实现以下流程</p>\n<ul>\n<li>数据填充并且只需要填充屏幕范围内的 ItemView</li>\n<li>回收掉屏幕以外的 ItemView</li>\n<li>屏幕外 ItemView 再回到屏幕后，需要重新填充</li>\n<li>对滑动边界边界进行处理</li>\n<li>对 scrollToPosition 和 smoothScrollToPosition进行支持</li>\n</ul>\n<p>我们不用一上来就实现最终的效果，而是一步一步来，看看 LayoutManger 是怎么渐渐地变化，最终能跑起来的。</p>\n<h3 id=\"0-最简单的-LayoutManager\"><a href=\"#0-最简单的-LayoutManager\" class=\"headerlink\" title=\"0 最简单的 LayoutManager\"></a>0 最简单的 LayoutManager</h3><p>代码查看：<a href=\"https://github.com/VomPom/LayoutManagerGradually/tree/main/layoutmanager/src/main/java/com/julis/layoutmanager/series/MostSimpleLayoutManager.kt\">MostSimpleLayoutManager</a>，我们关注 <code>onLayoutChildren</code> 方法:</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onLayoutChildren</span><span class=\"params\">(recycler: <span class=\"type\">RecyclerView</span>.<span class=\"type\">Recycler</span>, state: <span class=\"type\">RecyclerView</span>.<span class=\"type\">State</span>?)</span></span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 垂直方向的偏移量</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> offsetTop = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"comment\">// 实际业务中最好不要这样一次性加载所有的数据，这里只是最简单地演示一下整体是如何工作的</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (itemIndex <span class=\"keyword\">in</span> <span class=\"number\">0</span> until itemCount) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 从适配器获取与给定位置关联的视图</span></span><br><span class=\"line\">        <span class=\"keyword\">val</span> itemView = recycler.getViewForPosition(itemIndex)</span><br><span class=\"line\">        <span class=\"comment\">// 将视图添加到 RecyclerView 中</span></span><br><span class=\"line\">        addView(itemView)</span><br><span class=\"line\">        <span class=\"comment\">// 测量并布局视图</span></span><br><span class=\"line\">        measureChildWithMargins(itemView, <span class=\"number\">0</span>, <span class=\"number\">0</span>)</span><br><span class=\"line\">        <span class=\"comment\">// 拿到宽高（包括ItemDecoration）</span></span><br><span class=\"line\">        <span class=\"keyword\">val</span> width = getDecoratedMeasuredWidth(itemView)</span><br><span class=\"line\">        <span class=\"keyword\">val</span> height = getDecoratedMeasuredHeight(itemView)</span><br><span class=\"line\">        <span class=\"comment\">// 对要添加的子 View 进行布局</span></span><br><span class=\"line\">        layoutDecorated(itemView, <span class=\"number\">0</span>, offsetTop, width, offsetTop + height)</span><br><span class=\"line\">        offsetTop += height</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面的代码主要演示了，如何利用<code>addView</code> <code>layoutDecorated</code>等方法，将 ItemView 添加到 RecyclerView 上。代码可见是 将所有的 ItemView（即使它在屏幕上不可见）一次性全部加载到了 RecyclerView上， 这里一般不这么做，只是这里这里只是最简单地演示一下整体是如何工作的。</p>\n<p>运行在手机上能看到这样的效果：Item数据已经被全部添加到界面上了，并且各个方向的滑动都支持。</p>\n<img src=\"https://cdn.julis.wang/blog/img/layoutmanager_gradually_0.gif?imageView2/2/w/300\">\n<h3 id=\"1-更合理的数据添加方式\"><a href=\"#1-更合理的数据添加方式\" class=\"headerlink\" title=\"1 更合理的数据添加方式\"></a>1 更合理的数据添加方式</h3><p>代码查看：<a href=\"https://github.com/VomPom/LayoutManagerGradually/tree/main/layoutmanager/src/main/java/com/julis/layoutmanager/series/LinearLayoutManager1\">LinearLayoutManager1.kt</a></p>\n<p>对最开始的代码进行优化，只在屏幕范围内的区域进行数据的添加，这样就不需要一次性将所有数据就添加上去，如果 Adapter 的 ItemCount 足够巨大，for all addView 的话，很容易就 OOM。</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onLayoutChildren</span><span class=\"params\">(recycler: <span class=\"type\">RecyclerView</span>.<span class=\"type\">Recycler</span>, state: <span class=\"type\">RecyclerView</span>.<span class=\"type\">State</span>)</span></span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 垂直方向上的的空间大小</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> remainSpace = height - paddingTop</span><br><span class=\"line\">    <span class=\"comment\">//垂直方向的偏移量</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> offsetTop = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> currentPosition = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (remainSpace &gt; <span class=\"number\">0</span> &amp;&amp; currentPosition &lt; state.itemCount) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 从适配器获取与给定位置关联的视图</span></span><br><span class=\"line\">        <span class=\"keyword\">val</span> itemView = recycler.getViewForPosition(currentPosition)</span><br><span class=\"line\">        <span class=\"comment\">// 将视图添加到 RecyclerView 中</span></span><br><span class=\"line\">        addView(itemView)</span><br><span class=\"line\">        <span class=\"comment\">// 测量并布局视图</span></span><br><span class=\"line\">        measureChildWithMargins(itemView, <span class=\"number\">0</span>, <span class=\"number\">0</span>)</span><br><span class=\"line\">        <span class=\"comment\">// 拿到宽高（包括ItemDecoration）</span></span><br><span class=\"line\">        <span class=\"keyword\">val</span> itemWidth = getDecoratedMeasuredWidth(itemView)</span><br><span class=\"line\">        <span class=\"keyword\">val</span> itemHeight = getDecoratedMeasuredHeight(itemView)</span><br><span class=\"line\">        <span class=\"comment\">// 对要添加的子 View 进行布局</span></span><br><span class=\"line\">        layoutDecorated(itemView, <span class=\"number\">0</span>, offsetTop, itemWidth, offsetTop + itemHeight)</span><br><span class=\"line\">        offsetTop += itemHeight</span><br><span class=\"line\">        currentPosition++</span><br><span class=\"line\">        <span class=\"comment\">// 可用空间减少</span></span><br><span class=\"line\">        remainSpace -= itemHeight</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-对屏幕外的View回收\"><a href=\"#2-对屏幕外的View回收\" class=\"headerlink\" title=\"2 对屏幕外的View回收\"></a>2 对屏幕外的View回收</h3><p>代码查看：<a href=\"https://github.com/VomPom/LayoutManagerGradually/tree/main/layoutmanager/src/main/java/com/julis/layoutmanager/series/LinearLayoutManager2.kt\">LinearLayoutManager2</a></p>\n<p>RecylerView 没有 recycler 怎么行呢？当 RecylerView 的 ItemView 滑出屏幕后我们需要对齐进行回收，实现的话需要在 <code>scrollVerticallyBy</code>中，比较复杂的逻辑就是怎么去判断：ItemView 在屏幕以外，最后利用：<code>removeAndRecycleView</code>方法进行回收</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">scrollVerticallyBy</span><span class=\"params\">(dy: <span class=\"type\">Int</span>, recycler: <span class=\"type\">RecyclerView</span>.<span class=\"type\">Recycler</span>, state: <span class=\"type\">RecyclerView</span>.<span class=\"type\">State</span>?)</span></span>: <span class=\"built_in\">Int</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 在这里处理上下的滚动逻辑，dy 表示滚动的距离</span></span><br><span class=\"line\">      <span class=\"comment\">// 平移所有子视图</span></span><br><span class=\"line\">      offsetChildrenVertical(-dy)</span><br><span class=\"line\">      <span class=\"comment\">// 如果实际滚动距离与 dy 相同，返回 dy；如果未滚动，返回 0</span></span><br><span class=\"line\">      recycleInvisibleView(dy, recycler)</span><br><span class=\"line\">      <span class=\"keyword\">return</span> dy</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 回收掉在界面上看不到的 ItemView</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> dy</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> recycler</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">recycleInvisibleView</span><span class=\"params\">(dy: <span class=\"type\">Int</span>, recycler: <span class=\"type\">RecyclerView</span>.<span class=\"type\">Recycler</span>)</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">val</span> totalSpace = orientationHelper.totalSpace</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 将要回收View的集合</span></span><br><span class=\"line\">    <span class=\"keyword\">val</span> recycleViews = hashSetOf&lt;View&gt;()</span><br><span class=\"line\">    <span class=\"comment\">// 从下往上滑</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (dy &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (i <span class=\"keyword\">in</span> <span class=\"number\">0</span> until childCount) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">val</span> child = getChildAt(i)!!</span><br><span class=\"line\">            <span class=\"comment\">// 从下往上滑从最上面的 item 开始计算</span></span><br><span class=\"line\">            <span class=\"keyword\">val</span> top = getDecoratedTop(child)</span><br><span class=\"line\">            <span class=\"comment\">// 判断最顶部的 item 是否已经完全不可见，如何可见，那说明底下的 item 也是可见</span></span><br><span class=\"line\">            <span class=\"keyword\">val</span> height = top - getDecoratedBottom(child)</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (height - top &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">break</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            recycleViews.add(child)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (dy &lt; <span class=\"number\">0</span>) &#123;   <span class=\"comment\">// 从上往下滑</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (i <span class=\"keyword\">in</span> childCount - <span class=\"number\">1</span> downTo <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">val</span> child = getChildAt(i)!!</span><br><span class=\"line\">            <span class=\"comment\">// 从上往下滑从最底部的 item 开始计算</span></span><br><span class=\"line\">            <span class=\"keyword\">val</span> bottom = getDecoratedBottom(child)</span><br><span class=\"line\">            <span class=\"comment\">// 判断最底部的 item 是否已经完全不可见，如何可见，那说明上面的 item 也是可见</span></span><br><span class=\"line\">            <span class=\"keyword\">val</span> height = bottom - getDecoratedTop(child)</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (bottom - totalSpace &lt; height) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">break</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            recycleViews.add(child)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 真正把 View 移除掉的逻辑</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (view <span class=\"keyword\">in</span> recycleViews) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// [removeAndRecycleView]</span></span><br><span class=\"line\">        <span class=\"comment\">// 用于从视图层次结构中删除某个视图，并将其资源回收，以便在需要时重新利用</span></span><br><span class=\"line\">        removeAndRecycleView(view, recycler)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    recycleViews.clear()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>运行在手机上能看到这样的效果：滑出屏幕外的ItemView 被回收掉了</p>\n<img src=\"https://cdn.julis.wang/blog/img/layoutmanager_gradually_2.gif?imageView2/2/w/300\">\n<h3 id=\"3-向上滑动的时View的填充\"><a href=\"#3-向上滑动的时View的填充\" class=\"headerlink\" title=\"3 向上滑动的时View的填充\"></a>3 向上滑动的时View的填充</h3><p>代码查看：<a href=\"https://github.com/VomPom/LayoutManagerGradually/tree/main/layoutmanager/src/main/java/com/julis/layoutmanager/series/LinearLayoutManager3.kt\">LinearLayoutManager3</a></p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">scrollVerticallyBy</span><span class=\"params\">(dy: <span class=\"type\">Int</span>, recycler: <span class=\"type\">RecyclerView</span>.<span class=\"type\">Recycler</span>, state: <span class=\"type\">RecyclerView</span>.<span class=\"type\">State</span>?)</span></span>: <span class=\"built_in\">Int</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 填充 view</span></span><br><span class=\"line\">    fillView(dy, recycler)</span><br><span class=\"line\">    <span class=\"comment\">// 移动 view</span></span><br><span class=\"line\">    offsetChildrenVertical(-dy)</span><br><span class=\"line\">    <span class=\"comment\">// 回收 View</span></span><br><span class=\"line\">    recycleInvisibleView(dy, recycler)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> dy</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 填充重新进入屏幕内的 ItemView</span></span><br><span class=\"line\"><span class=\"comment\"> *     getChildCount():childCount-&gt; 当前屏幕内RecyclerView展示的 ItemView 数量</span></span><br><span class=\"line\"><span class=\"comment\"> *     getItemCount():itemCount-&gt; 最大的 ItemView 数量，也就是 Adapter 传递的数据的数量</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">fillView</span><span class=\"params\">(dy: <span class=\"type\">Int</span>, recycler: <span class=\"type\">RecyclerView</span>.<span class=\"type\">Recycler</span>)</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">val</span> verticalSpace = orientationVerticalHelper.totalSpace</span><br><span class=\"line\">    <span class=\"keyword\">var</span> remainSpace = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> nextFillPosition = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"comment\">//垂直方向的偏移量</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> offsetTop = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> offsetLeft = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"comment\">// 从下往上滑，那么需要向底部添加数据</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (dy &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">val</span> anchorView = getChildAt(childCount - <span class=\"number\">1</span>) ?: <span class=\"keyword\">return</span></span><br><span class=\"line\">        <span class=\"keyword\">val</span> anchorPosition = getPosition(anchorView)</span><br><span class=\"line\">        <span class=\"keyword\">val</span> anchorBottom = getDecoratedBottom(anchorView)</span><br><span class=\"line\">        <span class=\"keyword\">val</span> anchorLeft = getDecoratedLeft(anchorView)</span><br><span class=\"line\">        remainSpace = verticalSpace - anchorBottom</span><br><span class=\"line\">        <span class=\"comment\">// 垂直可用的数据为&lt;0，意外着这时候屏幕底部的位置刚好在最底部的 ItemView 上，还需要向上滑动一点点...我们才能添加 View</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (remainSpace &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        nextFillPosition = anchorPosition + <span class=\"number\">1</span></span><br><span class=\"line\">        offsetTop = anchorBottom</span><br><span class=\"line\">        offsetLeft = anchorLeft</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (nextFillPosition &gt;= itemCount) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (dy &lt; <span class=\"number\">0</span>) &#123;  <span class=\"comment\">// 从上往下滑，那么需要向顶部添加数据</span></span><br><span class=\"line\">        <span class=\"comment\">//no-op 暂时不实现从上往下滑的底部数据填充</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (remainSpace &gt; <span class=\"number\">0</span> &amp;&amp; nextFillPosition &lt; itemCount) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 从适配器获取与给定位置关联的视图</span></span><br><span class=\"line\">        <span class=\"keyword\">val</span> itemView = recycler.getViewForPosition(nextFillPosition)</span><br><span class=\"line\">        <span class=\"comment\">// 将视图添加到 RecyclerView 中</span></span><br><span class=\"line\">        addView(itemView)</span><br><span class=\"line\">        <span class=\"comment\">// 测量并布局视图</span></span><br><span class=\"line\">        measureChildWithMargins(itemView, <span class=\"number\">0</span>, <span class=\"number\">0</span>)</span><br><span class=\"line\">        <span class=\"comment\">// 拿到宽高（包括ItemDecoration）</span></span><br><span class=\"line\">        <span class=\"keyword\">val</span> itemWidth = getDecoratedMeasuredWidth(itemView)</span><br><span class=\"line\">        <span class=\"keyword\">val</span> itemHeight = getDecoratedMeasuredHeight(itemView)</span><br><span class=\"line\">        <span class=\"comment\">// 对要添加的子 View 进行布局，相比onLayoutChildren 里面的实现添加了：offsetLeft（因为我们没有禁止掉 左右的滑动）</span></span><br><span class=\"line\">        <span class=\"comment\">// 试着把 offsetLeft 改成0，也就是最原始的样子，然后左右上下滑滑，你会有意外收获</span></span><br><span class=\"line\">        layoutDecorated(itemView, offsetLeft, offsetTop, itemWidth + offsetLeft, offsetTop + itemHeight)</span><br><span class=\"line\">        offsetTop += itemHeight</span><br><span class=\"line\">        nextFillPosition++</span><br><span class=\"line\">        <span class=\"comment\">// 可用空间减少</span></span><br><span class=\"line\">        remainSpace -= itemHeight</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>运行在手机上能看到这样的效果：向上滑动的时候，底部陆续有元素填充，但向下滑动的时候没有填充数据</p>\n<img src=\"https://cdn.julis.wang/blog/img/layoutmanager_gradually_3.gif?imageView2/2/w/300\">\n<h3 id=\"4-两个方向的View填充\"><a href=\"#4-两个方向的View填充\" class=\"headerlink\" title=\"4 两个方向的View填充\"></a>4 两个方向的View填充</h3><p>代码查看：<a href=\"https://github.com/VomPom/LayoutManagerGradually/tree/main/layoutmanager/src/main/java/com/julis/layoutmanager/series/LinearLayoutManager4.kt\">LinearLayoutManager4</a></p>\n<p>补齐从上往下滑之后添加的逻辑</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">fillView</span><span class=\"params\">(dy: <span class=\"type\">Int</span>, recycler: <span class=\"type\">RecyclerView</span>.<span class=\"type\">Recycler</span>)</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">val</span> verticalSpace = orientationVerticalHelper.totalSpace</span><br><span class=\"line\">    <span class=\"keyword\">var</span> remainSpace = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> nextFillPosition = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"comment\">//垂直方向的偏移量</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> offsetTop = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> offsetLeft = <span class=\"number\">0</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 从下往上滑，那么需要向底部添加数据</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (dy &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        ……</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (dy &lt; <span class=\"number\">0</span>) &#123;  <span class=\"comment\">// 从上往下滑，那么需要向顶部添加数据</span></span><br><span class=\"line\">        <span class=\"keyword\">val</span> anchorView = getChildAt(<span class=\"number\">0</span>) ?: <span class=\"keyword\">return</span></span><br><span class=\"line\">        <span class=\"keyword\">val</span> anchorPosition = getPosition(anchorView)</span><br><span class=\"line\">        <span class=\"keyword\">val</span> anchorTop = getDecoratedTop(anchorView)</span><br><span class=\"line\">        offsetLeft = getDecoratedLeft(anchorView)</span><br><span class=\"line\">        remainSpace = anchorTop</span><br><span class=\"line\">        <span class=\"comment\">// 垂直可用的数据为&lt;0，意外着这时候屏幕顶部的位置刚好在最底部的 ItemView 上，还需要向下滑动一点点...我们才能添加 View</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (anchorTop &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        nextFillPosition = anchorPosition - <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (nextFillPosition &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">val</span> itemHeight = getDecoratedMeasuredHeight(anchorView)</span><br><span class=\"line\">        <span class=\"comment\">// 新的布局的itemView 的顶部位置应该以 anchorTop - itemHeight 开始</span></span><br><span class=\"line\">        offsetTop = anchorTop - itemHeight</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (remainSpace &gt; <span class=\"number\">0</span> &amp;&amp;</span><br><span class=\"line\">        ((nextFillPosition &lt; itemCount) &amp;&amp; (nextFillPosition &gt;= <span class=\"number\">0</span>))</span><br><span class=\"line\">    ) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 从适配器获取与给定位置关联的视图</span></span><br><span class=\"line\">        <span class=\"keyword\">val</span> itemView = recycler.getViewForPosition(nextFillPosition)</span><br><span class=\"line\">        <span class=\"comment\">// 将视图添加到 RecyclerView 中k，从顶部添加的话，需要加到最前的位置</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (dy &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            addView(itemView)</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            addView(itemView, <span class=\"number\">0</span>)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        ……</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (dy &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            offsetTop += itemHeight</span><br><span class=\"line\">            nextFillPosition++</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            offsetTop -= itemHeight</span><br><span class=\"line\">            nextFillPosition--</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 可用空间减少</span></span><br><span class=\"line\">        remainSpace -= itemHeight</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>运行在手机上能看到这样的效果：向上或者滑动的时候，底部陆续都有元素填充</p>\n<img src=\"https://cdn.julis.wang/blog/img/layoutmanager_gradually_4.gif?imageView2/2/w/300\">\n<h3 id=\"5-对顶部和底部滑动边界处理\"><a href=\"#5-对顶部和底部滑动边界处理\" class=\"headerlink\" title=\"5 对顶部和底部滑动边界处理\"></a>5 对顶部和底部滑动边界处理</h3><p>代码查看：<a href=\"https://github.com/VomPom/LayoutManagerGradually/tree/main/layoutmanager/src/main/java/com/julis/layoutmanager/series/LinearLayoutManager5.kt\">LinearLayoutManager5</a></p>\n<p>对于前面的实现会发现会：不停地下滑或者上滑会留出来巨大的空白。这里对填充 View 的逻辑进行改造，需要进行边界检测。</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">scrollVerticallyBy</span><span class=\"params\">(dy: <span class=\"type\">Int</span>, recycler: <span class=\"type\">RecyclerView</span>.<span class=\"type\">Recycler</span>, state: <span class=\"type\">RecyclerView</span>.<span class=\"type\">State</span>?)</span></span>: <span class=\"built_in\">Int</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 填充 view</span></span><br><span class=\"line\">    <span class=\"keyword\">val</span> adjustedDy = fillView(dy, recycler)</span><br><span class=\"line\">    <span class=\"comment\">// 移动 view</span></span><br><span class=\"line\">    offsetChildrenVertical(-adjustedDy)</span><br><span class=\"line\">    <span class=\"comment\">// 回收 View</span></span><br><span class=\"line\">    recycleInvisibleView(adjustedDy, recycler)</span><br><span class=\"line\">    <span class=\"comment\">// 由于需要对边界进行限制，所以需要对原始的 dy 进行修正，这里不再直接返回 dy</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> adjustedDy</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>这里的整体注释我写在了代码里面，可以看图稍微理解一下，以向上滑动为例：假设这一次滑动的距离非常非常大(想象成10000像素)，如果直接滑动的话，我们有50个元素，每个元素高度100像素，最大高度也只有50x100=5000，那么滑动后一定会留下大量空区域。需要对当前传入的这 10000 像素做调整：只给到可滑动的最大距离，如果不能滑动了就返回0。</p>\n<img src=\"https://cdn.julis.wang/blog/img/5_scroll_limit.png\">\n<p>运行在手机上能看到这样的效果：向上或者滑动的时候，达到最大的位置时候是不能再滑动的。</p>\n<img src=\"https://cdn.julis.wang/blog/img/layoutmanager_gradually_5.gif?imageView2/2/w/300\">\n<h3 id=\"6-实现-scrollToPosition\"><a href=\"#6-实现-scrollToPosition\" class=\"headerlink\" title=\"6 实现 scrollToPosition\"></a>6 实现 scrollToPosition</h3><p>代码查看：<a href=\"https://github.com/VomPom/LayoutManagerGradually/tree/main/layoutmanager/src/main/java/com/julis/layoutmanager/series/LinearLayoutManager6.kt\">LinearLayoutManager6</a></p>\n<p>到这里这个 LinearLayoutManager 看着已经能正常运行了，但一般还需要支持<code>scrollToPosition</code> 和 <code>smoothScrollToPositio</code></p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">var</span> mPendingScrollPosition = RecyclerView.NO_POSITION</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">scrollToPosition</span><span class=\"params\">(position: <span class=\"type\">Int</span>)</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>.scrollToPosition(position)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (position &lt; <span class=\"number\">0</span> || position &gt;= itemCount) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    mPendingScrollPosition = position</span><br><span class=\"line\">    requestLayout()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onLayoutChildren</span><span class=\"params\">(recycler: <span class=\"type\">RecyclerView</span>.<span class=\"type\">Recycler</span>, state: <span class=\"type\">RecyclerView</span>.<span class=\"type\">State</span>)</span></span> &#123;</span><br><span class=\"line\">    ……</span><br><span class=\"line\">    <span class=\"keyword\">var</span> currentPosition = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mPendingScrollPosition != RecyclerView.NO_POSITION) &#123;</span><br><span class=\"line\">        currentPosition = mPendingScrollPosition</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (remainSpace &gt; <span class=\"number\">0</span> &amp;&amp; currentPosition &lt; state.itemCount) &#123;</span><br><span class=\"line\">      …… <span class=\"comment\">// 填充View 的逻辑</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>scrollToPosition</code> 的实现比较简单，如上代码所示：在 <code>scrollToPosition</code>  的时候记录一次目标position，再 requestLayout 一波，还记得之前有提到过：<code>onLayoutChildren</code> 会在 <code>requestLayout</code> 的时候调用一次，于是再将<code>onLayoutChildren</code>逻辑改写，不再从第0个元素开始，而是从目标位置进行布局。</p>\n<p>运行在手机上能看到这样的效果：点击 scrollTo30 将会滑动到 第30个位置。</p>\n<img src=\"https://cdn.julis.wang/blog/img/layoutmanager_gradually_6.gif?imageView2/2/w/300\">\n<h3 id=\"7-实现-smoothScrollToPosition\"><a href=\"#7-实现-smoothScrollToPosition\" class=\"headerlink\" title=\"7 实现 smoothScrollToPosition\"></a>7 实现 smoothScrollToPosition</h3><p>代码查看：<a href=\"https://github.com/VomPom/LayoutManagerGradually/tree/main/layoutmanager/src/main/java/com/julis/layoutmanager/series/LinearLayoutManager7.kt\">LinearLayoutManager7</a>  </p>\n<p>要实现自定义的 smoothScrollToPosition 动画效果，这一块如果要完全自己实现的话比较复杂，可以直接使用系统提供的 LinearSmoothScroller改造,也可以继承 RecyclerView.SmoothScroller 自定义，也可以完全不使用 SmoothScroller， 照着 SmoothScroller 的实现使用类似 ValueAnimator 自定义动画，添加动画 UpdateListener，在 onAnimationUpdate 的时候动态计算布局从而实现滑动动画,这里拿 LinearSmoothScroller 举例:</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">smoothScrollToPosition</span><span class=\"params\">(</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">    recyclerView: <span class=\"type\">RecyclerView</span>,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">    state: <span class=\"type\">RecyclerView</span>.<span class=\"type\">State</span>,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">    position: <span class=\"type\">Int</span></span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">)</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (position &gt;= itemCount || position &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">val</span> scroller: LinearSmoothScroller = <span class=\"keyword\">object</span> : LinearSmoothScroller(recyclerView.context) &#123;</span><br><span class=\"line\">        <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">         * 这个方法用于计算滚动到目标位置所需的滚动向量。滚动向量是一个二维向量，包含水平和垂直方向上的滚动距离</span></span><br><span class=\"line\"><span class=\"comment\">         *</span></span><br><span class=\"line\"><span class=\"comment\">         * <span class=\"doctag\">@param</span> targetPosition 滑动的目标位置</span></span><br><span class=\"line\"><span class=\"comment\">         * <span class=\"doctag\">@return</span>  返回一个 PointF 对象，表示滚动向量。</span></span><br><span class=\"line\"><span class=\"comment\">         *              PointF.x 表示水平方向上的滚动距离，</span></span><br><span class=\"line\"><span class=\"comment\">         *              PointF.y 表示垂直方向上的滚动距离</span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\">        <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">computeScrollVectorForPosition</span><span class=\"params\">(targetPosition: <span class=\"type\">Int</span>)</span></span>: PointF &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 查找到屏幕里显示的第 1 个元素与</span></span><br><span class=\"line\">            <span class=\"keyword\">val</span> firstChildPos = getPosition(getChildAt(<span class=\"number\">0</span>)!!)</span><br><span class=\"line\">            <span class=\"keyword\">val</span> direction = <span class=\"keyword\">if</span> (targetPosition &lt; firstChildPos) -<span class=\"number\">1</span> <span class=\"keyword\">else</span> <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"comment\">// x 左右滑动，由于我们只实现了垂直的滑动，所以 x方向为0即可</span></span><br><span class=\"line\">            <span class=\"comment\">// 整数代表正向移动，负数代表反向移动，这里的数值大小不重要，源码里面最终都会 normalize 归一化处理</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> PointF(<span class=\"number\">0f</span>, direction.toFloat())</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">         * 计算每像素速度</span></span><br><span class=\"line\"><span class=\"comment\">         *</span></span><br><span class=\"line\"><span class=\"comment\">         * <span class=\"doctag\">@param</span> displayMetrics</span></span><br><span class=\"line\"><span class=\"comment\">         * <span class=\"doctag\">@return</span> 返回每一像素的耗时，单位ms，假设返回值是1.0 代表着：1ms 内会滑动 1像素，1s会滑动1000像素</span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\">        <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">calculateSpeedPerPixel</span><span class=\"params\">(displayMetrics: <span class=\"type\">DisplayMetrics</span>?)</span></span>: <span class=\"built_in\">Float</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">super</span>.calculateSpeedPerPixel(displayMetrics)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">         * 滑动速度的插值（实现滑动速度随着滑动时间的变化）</span></span><br><span class=\"line\"><span class=\"comment\">         *</span></span><br><span class=\"line\"><span class=\"comment\">         * <span class=\"doctag\">@param</span> dx</span></span><br><span class=\"line\"><span class=\"comment\">         * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\">        <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">calculateTimeForDeceleration</span><span class=\"params\">(dx: <span class=\"type\">Int</span>)</span></span>: <span class=\"built_in\">Int</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">super</span>.calculateTimeForDeceleration(dx)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 很多方法可以使用，不再一一列举</span></span><br><span class=\"line\">        <span class=\"comment\">// ...</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    scroller.targetPosition = position</span><br><span class=\"line\">    <span class=\"comment\">// 执行默认动画的逻辑</span></span><br><span class=\"line\">    startSmoothScroll(scroller)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>运行在手机上能看到这样的效果：点击 smoothScrollTo30 将会有个动画效果滑动到第30个位置。</p>\n<img src=\"https://cdn.julis.wang/blog/img/layoutmanager_gradually_7.gif?imageView2/2/w/300\">\n<p>以上基本上一个自定义 LayoutManager 的雏形就已经完成了，虽然只实现了一个方向的滑动，但是其原理都是一样的，剩下的就是各种细节的打磨了，可以加各种自己想要的效果，比如：指定位置 放大一定的系数，或者更炫酷的滑动动画…</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>本文主要整理了自定义 LayoutManager 的必要元素，以及其核心方法 scrollHorizontallyBy/scrollVerticallyBy、onLayoutChildren 的作用与调用时机，接下对实现一个简单的 LinearLayoutManger 进行逻辑拆解，从最简单的不滑动回收和填充以及不含滑动边界检测，到最终一个具备基本功能的 LayoutManger</p>\n<p>源码：<a href=\"https://github.com/VomPom/LayoutManagerGradually\">https://github.com/VomPom/LayoutManagerGradually</a></p>\n<p>参考：</p>\n<p><a href=\"https://juejin.cn/post/6870770285247725581?searchId=202310181005138A6D82B1DEE9C47A9797#heading-23\">《看完这篇文章你还不会自定义LayoutManager，我吃X！》</a></p>\n<p><a href=\"https://github.com/MycroftWong/FlowLayoutManager/blob/master/LayoutManager%E5%88%86%E6%9E%90%E4%B8%8E%E5%AE%9E%E8%B7%B5.md\">《/LayoutManager分析与实践》</a></p>\n<p><a href=\"https://wiresareobsolete.com/2014/09/building-a-recyclerview-layoutmanager-part-1/\">Building a RecyclerView LayoutManager – Part 1</a></p>\n","categories":[],"tags":[{"name":"技术文章","slug":"technology","api":"api/tags/technology.json"}],"api":"api/posts/2023/10/31/自定义LayoutManager从0到1实践.json"},{"title":"Android 基于 J2V8 运行 JavasScript  实践","slug":"Android-J2V8-实践","date":"2023-09-30T13:11:00.000Z","updated":"2025-05-20T11:46:57.000Z","comments":true,"url":"2023/09/30/Android-J2V8-实践/","excerpt":"<p>V8 引擎是由 Google 开源的 JavaScript 引擎，Chrome 就是基于 V8 开发，V8 是跨平台的，J2V8 基于 V8 进行开发，使得 js 代码能够在 Android 平台上脱离 WebView 运行。目前，也有很多关于 Android J2V8 的文章，不过讲解不是特别细（可能也是我太菜了，看完了之后，依然遇到很多问题），自己在调研的过程中遇到很多坑，所以这里记录一下，本文主要记录整个 J2V8 框架的使用方法，以及一些坑。</p>\n<h2 id=\"一、Webpack-打包\"><a href=\"#一、Webpack-打包\" class=\"headerlink\" title=\"一、Webpack 打包\"></a>一、Webpack 打包</h2><p>通常业务逻辑的 js 文件是有多个的，我们需要借助一些打包工具将多个文件打包成一个 js 文件供 J2V8 使用，我们可以使用 Gulp、Webpack、Browserify，本文主要讲 Webpack 的使用。<br>主要流程如下：</p>\n<p><strong>编写基础逻辑并通过 <code>module.exports</code> 对外部提供</strong></p>\n<p><strong>编写 <code>index.js</code> 入口文件</strong><br><figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\">...</span><br><span class=\"line\"><span class=\"variable language_\">module</span>.<span class=\"property\">exports</span> = &#123;</span><br><span class=\"line\">  simpleFunc, complexFunc</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure><br><strong> 编写<code>webpack.config</code>打包配置</strong><br><figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"variable language_\">module</span>.<span class=\"property\">exports</span> = &#123;</span><br><span class=\"line\">  <span class=\"attr\">entry</span>: <span class=\"string\">&#x27;./src/example/index.js&#x27;</span>,</span><br><span class=\"line\">  <span class=\"attr\">output</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">library</span>: <span class=\"string\">&#x27;libExample&#x27;</span>,                 <span class=\"comment\">// j2v8 加载该lib</span></span><br><span class=\"line\">    <span class=\"attr\">path</span>: path.<span class=\"title function_\">resolve</span>(__dirname, <span class=\"string\">&#x27;dist&#x27;</span>),</span><br><span class=\"line\">    <span class=\"attr\">filename</span>: <span class=\"string\">&#x27;example.js&#x27;</span>,                <span class=\"comment\">// 导出指定命名的 js 文件 </span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  ...</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p><strong>执行 <code>webpack</code> 打包命令</strong><br><figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">./node_modules/.bin/webpack --config webpack.config.js</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"二、运行-JavaScript\"><a href=\"#二、运行-JavaScript\" class=\"headerlink\" title=\"二、运行 JavaScript\"></a>二、运行 JavaScript</h2><p>到这里我们已经有一份通过 Webpack 打包好的 js 文件了，要在 j2v8 中运行 JavaScript 文件，使用以下步骤：</p>\n<p><strong>1、创建一个 V8 实例</strong><br><figure class=\"highlight kotlin\"><table><tr><td class=\"code\"><pre><span class=\"line\">V8 v8 = V8.createV8Runtime();</span><br></pre></td></tr></table></figure><br><strong>2、读取 JavaScript 文件</strong><br><figure class=\"highlight kotlin\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> scriptStr = String(Files.readAllBytes(Paths.<span class=\"keyword\">get</span>(<span class=\"string\">&quot;example.js&quot;</span>)))</span><br></pre></td></tr></table></figure><br><strong>3、在 V8 实例中执行 JavaScript 代码</strong><br><figure class=\"highlight kotlin\"><table><tr><td class=\"code\"><pre><span class=\"line\">v8.executeScript(scriptStr);</span><br></pre></td></tr></table></figure><br>这一步已经让整个 js 文件运行起来，但我们还不能调用我们的方法</p>\n<p><strong>4、读取指定模块</strong></p>\n<p>由于是通过 Webpack 打包，在 Webpack 的 <code>output.library</code> 配置，选项用于将打包后的代码作为一个库(library)暴露出去，以便其他应用程序或模块可以使用它。<br><figure class=\"highlight kotlin\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> rootLib =v8.getObject(libName); <span class=\"comment\">// 这里的 libName 就是 output.library 配置的名字</span></span><br></pre></td></tr></table></figure><br>如果是访问模块的导出对象中的子对象，那么继续：<br><figure class=\"highlight kotlin\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> subLib =rootLib.getObject(subLibName); <span class=\"comment\">// 这里的 subLibName 是 index 文件中 module.exports 里面的模块名</span></span><br></pre></td></tr></table></figure><br> 如果子对象还有子对象，继续<code>.getObject</code> 即可</p>\n<p><strong>5、运行指定方法</strong></p>\n<p>接下来就简单了，直接通过如下方法执行 js 中的指定方法<br><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">executeVoidFunction</span><span class=\"params\">(String name, V8Array parameters)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> String <span class=\"title function_\">executeStringFunction</span><span class=\"params\">(String name, V8Array parameters)</span> </span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"type\">double</span> <span class=\"title function_\">executeDoubleFunction</span><span class=\"params\">(String name, V8Array parameters)</span> </span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">executeIntegerFunction</span><span class=\"params\">(String name, V8Array parameters)</span></span><br><span class=\"line\">……</span><br></pre></td></tr></table></figure></p>\n<p><code>V8Object</code> 提供了很多数据格式调用，不过都差不多，主要是在返回值那里帮你实现了数据的转化，如果不想用转化好的格式，希望自己来操作的话，使用<code>public V8Object executeObjectFunction()</code> 拿到返回值，自己去转化即可</p>\n<p><strong>6、释放资源</strong></p>\n<p>由于 V8 运行消耗较多的资源，执行结束的时候要将在过程中创建的所有的资源释放，避免导致内存泄漏。<br>V8提供了close方法，如果只使用 v8.close() 进行释放，或者未关闭过程中有用到 v8 runtime 的变量都会报如下错误，正确的做法是将所有资源进行关闭。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">java.lang.IllegalStateException: <span class=\"number\">3</span> Object(s) still exist in runtime</span><br></pre></td></tr></table></figure>\n<h2 id=\"三、进阶\"><a href=\"#三、进阶\" class=\"headerlink\" title=\"三、进阶\"></a>三、进阶</h2><p>通过以上的方式已经能执行很多逻辑了，但在实践过过程中发现：如何 js 的返回值是 Promise 的话不会等到最终的结果给我们，而是直接返回了一个 Promise 对象，以及看不到 <code>console.log</code> 打印的日志…… 诸如此类的问题需要解决，这里主要讲讲这两种方法的实现。</p>\n<p><strong>注册 Native 插件</strong></p>\n<p>J2V8 是一个基于 V8 引擎的 Java 库，它允许在 Java 中执行 JavaScript 代码。由于 J2V8 是在 Java 中运行的，它没有直接访问浏览器或控制台的能力，因此无法直接使用 console.log 函数来输出日志，总结 <strong>J2V8 不能实现以下功能：</strong></p>\n<blockquote>\n<ul>\n<li>浏览器 API：j2v8 是在 Java 中运行的，因此无法直接访问浏览器 API，如 DOM、BOM 等。这意味着 j2v8 无法直接操作网页内容、处理事件等</li>\n<li>文件系统访问：j2v8 在 Java 中运行，无法直接访问文件系统。如果需要访问文件系统，需要使用 Java 提供的文件操作 API。</li>\n<li>定时器：JavaScript 中有多种定时器函数，如 setTimeout、setInterval 等，可以在指定时间后执行代码。但 j2v8 无法实现这些定时器函数，因为它无法直接访问系统的计时器。</li>\n<li>Web Worker：Web Worker 是 JavaScript 中的一个特殊对象，可以在后台线程中执行代码，以避免阻塞主线程。但 j2v8 无法实现 Web Worker，因为它无法直接访问操作系统的线程。</li>\n<li>Node.js API：j2v8 主要是为了在 Java 中执行浏览器端的 JavaScript 代码而设计的，因此无法直接访问 Node.js API。如果需要在 Java 中执行 Node.js 代码，可以考虑使用 Nashorn 等其他工具。</li>\n</ul>\n</blockquote>\n<p>这里是 <code>console.log</code>的一个简单实现：</p>\n<p><code>V8Object</code> 是 J2V8 中的一个类，它代表了一个 JavaScript 对象，对于 <code>console.log</code> 我们可以将 <code>console</code> 看作一个对象，其有一个叫 <code>log</code> 的方法，要实现在 js 中打印日志到 Android Studio 控制台，如下即可：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">ConsolePlugin</span> &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    fun <span class=\"title function_\">log</span><span class=\"params\">(message: Any)</span> &#123;</span><br><span class=\"line\">        Log.d(<span class=\"string\">&quot;ConsolePlugin&quot;</span>, message.toString())</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    fun <span class=\"title function_\">register</span><span class=\"params\">(v8: V8)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">val</span> <span class=\"variable\">v8Console</span> <span class=\"operator\">=</span> V8Object(v8)</span><br><span class=\"line\">        <span class=\"comment\">// 第一个 log 表示 在 Java 中该方法的名字，第二个 log 表示在 JavaScript 中调用的名字 </span></span><br><span class=\"line\">        v8Console.registerJavaMethod(<span class=\"built_in\">this</span>, <span class=\"string\">&quot;log&quot;</span>, <span class=\"string\">&quot;log&quot;</span>, arrayOf&lt;Class&lt;*&gt;&gt;(Any::class.java))</span><br><span class=\"line\">        v8Console.setWeak()</span><br><span class=\"line\">        <span class=\"comment\">// 将含有叫&quot;log&quot;方法的一个对象加到运行环境中，该对象被命名为 &quot;console&quot;</span></span><br><span class=\"line\">        v8.add(<span class=\"string\">&quot;console&quot;</span>, v8Console)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">ConsolePlugin().register(v8)</span><br></pre></td></tr></table></figure>\n<p>具体代码可参考:<a href=\"https://github.com/VomPom/J2V8_tutorial\">J2V8_tutorial</a></p>\n<h4 id=\"执行返回值是-Promise-类型的方法\"><a href=\"#执行返回值是-Promise-类型的方法\" class=\"headerlink\" title=\"执行返回值是 Promise 类型的方法\"></a>执行返回值是 Promise 类型的方法</h4><p>之前将的方法调用都是返回数据为基础类型，由于在 Java/kotlin 中没有<code>Promise</code>类型的方法，所以对于 <code>Promise</code> 方法我们需要进行一些特殊处理，我们通过使用 <code>CountDownLatch</code> 可以来实现一个 “异步变同步” 的操作，我们需要考虑的是如何接受到 <code>resolve</code> <code>rejcet</code>的调用，js 中 Promise 的方法使用如下：<br><figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"title class_\">PromiseMethod</span>().<span class=\"title function_\">then</span>(<span class=\"function\">(<span class=\"params\">result</span>)=&gt;</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// success got result</span></span><br><span class=\"line\">  &#125;).<span class=\"title function_\">catch</span>(<span class=\"function\">(<span class=\"params\">e</span>)=&gt;</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// error...</span></span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure><br>在 J2V8中一样的实现</p>\n<p><strong>获取返回的 Promise 对象</strong><br><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">val</span> <span class=\"variable\">promiseObj</span> <span class=\"operator\">=</span> v8.executeFunction(functionName, v8Array) as V8Object</span><br></pre></td></tr></table></figure><br><strong>执行 Promise 对象的 then 和 catch 方法 </strong><br><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">jsPromise.apply &#123;</span><br><span class=\"line\">        <span class=\"type\">val</span> <span class=\"variable\">onResolveParameter</span> <span class=\"operator\">=</span> V8Array(v8).push(onResolve)</span><br><span class=\"line\">        <span class=\"type\">val</span> <span class=\"variable\">onRejectParameter</span> <span class=\"operator\">=</span> V8Array(v8).push(onReject)</span><br><span class=\"line\">        executeVoidFunction(<span class=\"string\">&quot;then&quot;</span>, onResolveParameter)</span><br><span class=\"line\">        executeVoidFunction(<span class=\"string\">&quot;catch&quot;</span>, onRejectParameter)</span><br><span class=\"line\">        ....</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure><br>其中 onResolve<br><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">val</span> <span class=\"variable\">onResolve</span> <span class=\"operator\">=</span> V8Function(jsRuntime) &#123; receiver, parameters -&gt;</span><br><span class=\"line\">        ……</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure><br>具体代码可参考:<a href=\"https://github.com/VomPom/J2V8_tutorial\">J2V8_tutorial</a></p>\n<h2 id=\"四、总结\"><a href=\"#四、总结\" class=\"headerlink\" title=\"四、总结\"></a>四、总结</h2><p>以上基本上能解决大部分 Android 调用 js的代码逻辑了，这里对整体执行的流程进行一个总结</p>\n<p>1、通过 webpack 对多个 .js 文件打包<br>2、初始化 V8 环境并加载 .js 文件<br>3、注册 Java 方法，供 js 进行调用<br>4、读取指定的模板<br>5、执行目标 js 方法，并释放 v8 执行过程中产生的资源</p>\n<h3 id=\"踩过的一些坑\"><a href=\"#踩过的一些坑\" class=\"headerlink\" title=\"踩过的一些坑\"></a>踩过的一些坑</h3><p>1、<code>java.lang.UnsupportedOperationException: StartNodeJS Not Supported.</code></p>\n<p>这个库有一个 <code>NodeJS.createNodeJS()</code>方法，以为是完美结合 NodeJs 的，查了下不太支持 Android，不过也有人提出解决方法：<a href=\"https://stackoverflow.com/questions/42574824/how-to-use-nodejs-in-android-using-j2v8\">https://stackoverflow.com/questions/42574824/how-to-use-nodejs-in-android-using-j2v8</a></p>\n<p>2、<code>java.lang.IllegalStateException: 3 Object(s) still exist in runtime</code></p>\n<p>这是调用 `v8.close`` 总是会遇到的问题，一定需要确保使用了 v8 Runtime 过程变量有被释放掉，可能有时候不知道具体哪个变量没有被释放</p>\n<p>3、<code>setTimeout、setInterval</code> 无效</p>\n<p>这是我最开始遇到的问题，简单想着“既然能执行js代码，那 setTimeout、setInterval 这些方法都是 js 最普通的方法应该没问题吧”，如果有一些平时在 js 很常见的操作如果无法执行，最好 check 一下 J2V8 是否支持</p>\n<p>4、Undefined 相关</p>\n<p>虽然源码里面通过了一个 Undefined 的类，但是不能直接使用，如果方法返回的 Undefined，通过 <code>V8Object</code> 的 <code>isUndefined()</code> 去判断</p>\n<h3 id=\"引用\"><a href=\"#引用\" class=\"headerlink\" title=\"引用\"></a>引用</h3><p>[1]J2V8 <a href=\"https://eclipsesource.com/blogs/tutorials/getting-started-with-j2v8/\">https://eclipsesource.com/blogs/tutorials/getting-started-with-j2v8/</a></p>\n<p>[2] Registering Java Callbacks with J2V8 <a href=\"https://eclipsesource.com/blogs/2015/06/06/registering-java-callbacks-with-j2v8/\">https://eclipsesource.com/blogs/2015/06/06/registering-java-callbacks-with-j2v8/</a></p>\n<p>[3] Simple JS in Node.js <a href=\"https://yenhuang.gitbooks.io/android-development-note/content/wrap-js-library/simple-js-with-nodejs.html\">https://yenhuang.gitbooks.io/android-development-note/content/wrap-js-library/simple-js-with-nodejs.html</a></p>\n","cover":null,"images":[],"content":"<p>V8 引擎是由 Google 开源的 JavaScript 引擎，Chrome 就是基于 V8 开发，V8 是跨平台的，J2V8 基于 V8 进行开发，使得 js 代码能够在 Android 平台上脱离 WebView 运行。目前，也有很多关于 Android J2V8 的文章，不过讲解不是特别细（可能也是我太菜了，看完了之后，依然遇到很多问题），自己在调研的过程中遇到很多坑，所以这里记录一下，本文主要记录整个 J2V8 框架的使用方法，以及一些坑。</p>\n<h2 id=\"一、Webpack-打包\"><a href=\"#一、Webpack-打包\" class=\"headerlink\" title=\"一、Webpack 打包\"></a>一、Webpack 打包</h2><p>通常业务逻辑的 js 文件是有多个的，我们需要借助一些打包工具将多个文件打包成一个 js 文件供 J2V8 使用，我们可以使用 Gulp、Webpack、Browserify，本文主要讲 Webpack 的使用。<br>主要流程如下：</p>\n<p><strong>编写基础逻辑并通过 <code>module.exports</code> 对外部提供</strong></p>\n<p><strong>编写 <code>index.js</code> 入口文件</strong><br><figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\">...</span><br><span class=\"line\"><span class=\"variable language_\">module</span>.<span class=\"property\">exports</span> = &#123;</span><br><span class=\"line\">  simpleFunc, complexFunc</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure><br><strong> 编写<code>webpack.config</code>打包配置</strong><br><figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"variable language_\">module</span>.<span class=\"property\">exports</span> = &#123;</span><br><span class=\"line\">  <span class=\"attr\">entry</span>: <span class=\"string\">&#x27;./src/example/index.js&#x27;</span>,</span><br><span class=\"line\">  <span class=\"attr\">output</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">library</span>: <span class=\"string\">&#x27;libExample&#x27;</span>,                 <span class=\"comment\">// j2v8 加载该lib</span></span><br><span class=\"line\">    <span class=\"attr\">path</span>: path.<span class=\"title function_\">resolve</span>(__dirname, <span class=\"string\">&#x27;dist&#x27;</span>),</span><br><span class=\"line\">    <span class=\"attr\">filename</span>: <span class=\"string\">&#x27;example.js&#x27;</span>,                <span class=\"comment\">// 导出指定命名的 js 文件 </span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  ...</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p><strong>执行 <code>webpack</code> 打包命令</strong><br><figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">./node_modules/.bin/webpack --config webpack.config.js</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"二、运行-JavaScript\"><a href=\"#二、运行-JavaScript\" class=\"headerlink\" title=\"二、运行 JavaScript\"></a>二、运行 JavaScript</h2><p>到这里我们已经有一份通过 Webpack 打包好的 js 文件了，要在 j2v8 中运行 JavaScript 文件，使用以下步骤：</p>\n<p><strong>1、创建一个 V8 实例</strong><br><figure class=\"highlight kotlin\"><table><tr><td class=\"code\"><pre><span class=\"line\">V8 v8 = V8.createV8Runtime();</span><br></pre></td></tr></table></figure><br><strong>2、读取 JavaScript 文件</strong><br><figure class=\"highlight kotlin\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> scriptStr = String(Files.readAllBytes(Paths.<span class=\"keyword\">get</span>(<span class=\"string\">&quot;example.js&quot;</span>)))</span><br></pre></td></tr></table></figure><br><strong>3、在 V8 实例中执行 JavaScript 代码</strong><br><figure class=\"highlight kotlin\"><table><tr><td class=\"code\"><pre><span class=\"line\">v8.executeScript(scriptStr);</span><br></pre></td></tr></table></figure><br>这一步已经让整个 js 文件运行起来，但我们还不能调用我们的方法</p>\n<p><strong>4、读取指定模块</strong></p>\n<p>由于是通过 Webpack 打包，在 Webpack 的 <code>output.library</code> 配置，选项用于将打包后的代码作为一个库(library)暴露出去，以便其他应用程序或模块可以使用它。<br><figure class=\"highlight kotlin\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> rootLib =v8.getObject(libName); <span class=\"comment\">// 这里的 libName 就是 output.library 配置的名字</span></span><br></pre></td></tr></table></figure><br>如果是访问模块的导出对象中的子对象，那么继续：<br><figure class=\"highlight kotlin\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> subLib =rootLib.getObject(subLibName); <span class=\"comment\">// 这里的 subLibName 是 index 文件中 module.exports 里面的模块名</span></span><br></pre></td></tr></table></figure><br> 如果子对象还有子对象，继续<code>.getObject</code> 即可</p>\n<p><strong>5、运行指定方法</strong></p>\n<p>接下来就简单了，直接通过如下方法执行 js 中的指定方法<br><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">executeVoidFunction</span><span class=\"params\">(String name, V8Array parameters)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> String <span class=\"title function_\">executeStringFunction</span><span class=\"params\">(String name, V8Array parameters)</span> </span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"type\">double</span> <span class=\"title function_\">executeDoubleFunction</span><span class=\"params\">(String name, V8Array parameters)</span> </span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">executeIntegerFunction</span><span class=\"params\">(String name, V8Array parameters)</span></span><br><span class=\"line\">……</span><br></pre></td></tr></table></figure></p>\n<p><code>V8Object</code> 提供了很多数据格式调用，不过都差不多，主要是在返回值那里帮你实现了数据的转化，如果不想用转化好的格式，希望自己来操作的话，使用<code>public V8Object executeObjectFunction()</code> 拿到返回值，自己去转化即可</p>\n<p><strong>6、释放资源</strong></p>\n<p>由于 V8 运行消耗较多的资源，执行结束的时候要将在过程中创建的所有的资源释放，避免导致内存泄漏。<br>V8提供了close方法，如果只使用 v8.close() 进行释放，或者未关闭过程中有用到 v8 runtime 的变量都会报如下错误，正确的做法是将所有资源进行关闭。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">java.lang.IllegalStateException: <span class=\"number\">3</span> Object(s) still exist in runtime</span><br></pre></td></tr></table></figure>\n<h2 id=\"三、进阶\"><a href=\"#三、进阶\" class=\"headerlink\" title=\"三、进阶\"></a>三、进阶</h2><p>通过以上的方式已经能执行很多逻辑了，但在实践过过程中发现：如何 js 的返回值是 Promise 的话不会等到最终的结果给我们，而是直接返回了一个 Promise 对象，以及看不到 <code>console.log</code> 打印的日志…… 诸如此类的问题需要解决，这里主要讲讲这两种方法的实现。</p>\n<p><strong>注册 Native 插件</strong></p>\n<p>J2V8 是一个基于 V8 引擎的 Java 库，它允许在 Java 中执行 JavaScript 代码。由于 J2V8 是在 Java 中运行的，它没有直接访问浏览器或控制台的能力，因此无法直接使用 console.log 函数来输出日志，总结 <strong>J2V8 不能实现以下功能：</strong></p>\n<blockquote>\n<ul>\n<li>浏览器 API：j2v8 是在 Java 中运行的，因此无法直接访问浏览器 API，如 DOM、BOM 等。这意味着 j2v8 无法直接操作网页内容、处理事件等</li>\n<li>文件系统访问：j2v8 在 Java 中运行，无法直接访问文件系统。如果需要访问文件系统，需要使用 Java 提供的文件操作 API。</li>\n<li>定时器：JavaScript 中有多种定时器函数，如 setTimeout、setInterval 等，可以在指定时间后执行代码。但 j2v8 无法实现这些定时器函数，因为它无法直接访问系统的计时器。</li>\n<li>Web Worker：Web Worker 是 JavaScript 中的一个特殊对象，可以在后台线程中执行代码，以避免阻塞主线程。但 j2v8 无法实现 Web Worker，因为它无法直接访问操作系统的线程。</li>\n<li>Node.js API：j2v8 主要是为了在 Java 中执行浏览器端的 JavaScript 代码而设计的，因此无法直接访问 Node.js API。如果需要在 Java 中执行 Node.js 代码，可以考虑使用 Nashorn 等其他工具。</li>\n</ul>\n</blockquote>\n<p>这里是 <code>console.log</code>的一个简单实现：</p>\n<p><code>V8Object</code> 是 J2V8 中的一个类，它代表了一个 JavaScript 对象，对于 <code>console.log</code> 我们可以将 <code>console</code> 看作一个对象，其有一个叫 <code>log</code> 的方法，要实现在 js 中打印日志到 Android Studio 控制台，如下即可：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">ConsolePlugin</span> &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    fun <span class=\"title function_\">log</span><span class=\"params\">(message: Any)</span> &#123;</span><br><span class=\"line\">        Log.d(<span class=\"string\">&quot;ConsolePlugin&quot;</span>, message.toString())</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    fun <span class=\"title function_\">register</span><span class=\"params\">(v8: V8)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">val</span> <span class=\"variable\">v8Console</span> <span class=\"operator\">=</span> V8Object(v8)</span><br><span class=\"line\">        <span class=\"comment\">// 第一个 log 表示 在 Java 中该方法的名字，第二个 log 表示在 JavaScript 中调用的名字 </span></span><br><span class=\"line\">        v8Console.registerJavaMethod(<span class=\"built_in\">this</span>, <span class=\"string\">&quot;log&quot;</span>, <span class=\"string\">&quot;log&quot;</span>, arrayOf&lt;Class&lt;*&gt;&gt;(Any::class.java))</span><br><span class=\"line\">        v8Console.setWeak()</span><br><span class=\"line\">        <span class=\"comment\">// 将含有叫&quot;log&quot;方法的一个对象加到运行环境中，该对象被命名为 &quot;console&quot;</span></span><br><span class=\"line\">        v8.add(<span class=\"string\">&quot;console&quot;</span>, v8Console)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">ConsolePlugin().register(v8)</span><br></pre></td></tr></table></figure>\n<p>具体代码可参考:<a href=\"https://github.com/VomPom/J2V8_tutorial\">J2V8_tutorial</a></p>\n<h4 id=\"执行返回值是-Promise-类型的方法\"><a href=\"#执行返回值是-Promise-类型的方法\" class=\"headerlink\" title=\"执行返回值是 Promise 类型的方法\"></a>执行返回值是 Promise 类型的方法</h4><p>之前将的方法调用都是返回数据为基础类型，由于在 Java/kotlin 中没有<code>Promise</code>类型的方法，所以对于 <code>Promise</code> 方法我们需要进行一些特殊处理，我们通过使用 <code>CountDownLatch</code> 可以来实现一个 “异步变同步” 的操作，我们需要考虑的是如何接受到 <code>resolve</code> <code>rejcet</code>的调用，js 中 Promise 的方法使用如下：<br><figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"title class_\">PromiseMethod</span>().<span class=\"title function_\">then</span>(<span class=\"function\">(<span class=\"params\">result</span>)=&gt;</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// success got result</span></span><br><span class=\"line\">  &#125;).<span class=\"title function_\">catch</span>(<span class=\"function\">(<span class=\"params\">e</span>)=&gt;</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// error...</span></span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure><br>在 J2V8中一样的实现</p>\n<p><strong>获取返回的 Promise 对象</strong><br><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">val</span> <span class=\"variable\">promiseObj</span> <span class=\"operator\">=</span> v8.executeFunction(functionName, v8Array) as V8Object</span><br></pre></td></tr></table></figure><br><strong>执行 Promise 对象的 then 和 catch 方法 </strong><br><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">jsPromise.apply &#123;</span><br><span class=\"line\">        <span class=\"type\">val</span> <span class=\"variable\">onResolveParameter</span> <span class=\"operator\">=</span> V8Array(v8).push(onResolve)</span><br><span class=\"line\">        <span class=\"type\">val</span> <span class=\"variable\">onRejectParameter</span> <span class=\"operator\">=</span> V8Array(v8).push(onReject)</span><br><span class=\"line\">        executeVoidFunction(<span class=\"string\">&quot;then&quot;</span>, onResolveParameter)</span><br><span class=\"line\">        executeVoidFunction(<span class=\"string\">&quot;catch&quot;</span>, onRejectParameter)</span><br><span class=\"line\">        ....</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure><br>其中 onResolve<br><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">val</span> <span class=\"variable\">onResolve</span> <span class=\"operator\">=</span> V8Function(jsRuntime) &#123; receiver, parameters -&gt;</span><br><span class=\"line\">        ……</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure><br>具体代码可参考:<a href=\"https://github.com/VomPom/J2V8_tutorial\">J2V8_tutorial</a></p>\n<h2 id=\"四、总结\"><a href=\"#四、总结\" class=\"headerlink\" title=\"四、总结\"></a>四、总结</h2><p>以上基本上能解决大部分 Android 调用 js的代码逻辑了，这里对整体执行的流程进行一个总结</p>\n<p>1、通过 webpack 对多个 .js 文件打包<br>2、初始化 V8 环境并加载 .js 文件<br>3、注册 Java 方法，供 js 进行调用<br>4、读取指定的模板<br>5、执行目标 js 方法，并释放 v8 执行过程中产生的资源</p>\n<h3 id=\"踩过的一些坑\"><a href=\"#踩过的一些坑\" class=\"headerlink\" title=\"踩过的一些坑\"></a>踩过的一些坑</h3><p>1、<code>java.lang.UnsupportedOperationException: StartNodeJS Not Supported.</code></p>\n<p>这个库有一个 <code>NodeJS.createNodeJS()</code>方法，以为是完美结合 NodeJs 的，查了下不太支持 Android，不过也有人提出解决方法：<a href=\"https://stackoverflow.com/questions/42574824/how-to-use-nodejs-in-android-using-j2v8\">https://stackoverflow.com/questions/42574824/how-to-use-nodejs-in-android-using-j2v8</a></p>\n<p>2、<code>java.lang.IllegalStateException: 3 Object(s) still exist in runtime</code></p>\n<p>这是调用 `v8.close`` 总是会遇到的问题，一定需要确保使用了 v8 Runtime 过程变量有被释放掉，可能有时候不知道具体哪个变量没有被释放</p>\n<p>3、<code>setTimeout、setInterval</code> 无效</p>\n<p>这是我最开始遇到的问题，简单想着“既然能执行js代码，那 setTimeout、setInterval 这些方法都是 js 最普通的方法应该没问题吧”，如果有一些平时在 js 很常见的操作如果无法执行，最好 check 一下 J2V8 是否支持</p>\n<p>4、Undefined 相关</p>\n<p>虽然源码里面通过了一个 Undefined 的类，但是不能直接使用，如果方法返回的 Undefined，通过 <code>V8Object</code> 的 <code>isUndefined()</code> 去判断</p>\n<h3 id=\"引用\"><a href=\"#引用\" class=\"headerlink\" title=\"引用\"></a>引用</h3><p>[1]J2V8 <a href=\"https://eclipsesource.com/blogs/tutorials/getting-started-with-j2v8/\">https://eclipsesource.com/blogs/tutorials/getting-started-with-j2v8/</a></p>\n<p>[2] Registering Java Callbacks with J2V8 <a href=\"https://eclipsesource.com/blogs/2015/06/06/registering-java-callbacks-with-j2v8/\">https://eclipsesource.com/blogs/2015/06/06/registering-java-callbacks-with-j2v8/</a></p>\n<p>[3] Simple JS in Node.js <a href=\"https://yenhuang.gitbooks.io/android-development-note/content/wrap-js-library/simple-js-with-nodejs.html\">https://yenhuang.gitbooks.io/android-development-note/content/wrap-js-library/simple-js-with-nodejs.html</a></p>\n","categories":[{"name":"技术文章","slug":"technology","api":"api/categories/technology.json"}],"tags":[{"name":"JavaScript","slug":"JavaScript","api":"api/tags/JavaScript.json"}],"api":"api/posts/2023/09/30/Android-J2V8-实践.json"},{"title":"[转]《数字化视频技术概述》","slug":"转-《数字化视频技术概述》","date":"2023-09-15T12:11:00.000Z","updated":"2025-09-15T13:30:00.946Z","comments":true,"url":"2023/09/15/转-《数字化视频技术概述》/","excerpt":"<p>自己从事在音视频领域的边缘，音视频领域存在太多的专业术语，一下子搞懂是不可能的，这个项目 <a href=\"https://github.com/leandromoreira/digital_video_introduction\">digital_video_introduction</a> 来自 github 的一个开源项目，目前接近有 16k 的 star 了，从最基础的图像概念开始，逐步深入到视频、编解码器、传输和流媒体，适合反复学习阅读。<br>主要内容包括：<br>图像基础： 介绍了图像是如何被计算机理解和存储的，包括像素、分辨率、色彩空间（如 RGB 和 YUV）以及色度采样（如 4:2:0）。<br>视频： 将视频定义为一系列帧在时间上的连续，并引出了帧率（FPS）的概念。<br>编解码器（Codec）： 详细介绍了视频压缩的原理，包括帧内预测、帧间预测（I、P、B 帧）、运动补偿、宏块、熵编码、量化和变换。文章特别提到了 FFmpeg，并提供了如何使用它进行视频编码和转码的实例。<br>容器格式（Container）： 解释了容器格式（如 MP4、MKV）的作用，它们用于封装视频流、音频流和元数据。</p>\n<p>原文链接: <a href=\"https://github.com/leandromoreira/digital_video_introduction\">https://github.com/leandromoreira/digital_video_introduction</a></p>\n","cover":null,"images":[],"content":"<p>自己从事在音视频领域的边缘，音视频领域存在太多的专业术语，一下子搞懂是不可能的，这个项目 <a href=\"https://github.com/leandromoreira/digital_video_introduction\">digital_video_introduction</a> 来自 github 的一个开源项目，目前接近有 16k 的 star 了，从最基础的图像概念开始，逐步深入到视频、编解码器、传输和流媒体，适合反复学习阅读。<br>主要内容包括：<br>图像基础： 介绍了图像是如何被计算机理解和存储的，包括像素、分辨率、色彩空间（如 RGB 和 YUV）以及色度采样（如 4:2:0）。<br>视频： 将视频定义为一系列帧在时间上的连续，并引出了帧率（FPS）的概念。<br>编解码器（Codec）： 详细介绍了视频压缩的原理，包括帧内预测、帧间预测（I、P、B 帧）、运动补偿、宏块、熵编码、量化和变换。文章特别提到了 FFmpeg，并提供了如何使用它进行视频编码和转码的实例。<br>容器格式（Container）： 解释了容器格式（如 MP4、MKV）的作用，它们用于封装视频流、音频流和元数据。</p>\n<p>原文链接: <a href=\"https://github.com/leandromoreira/digital_video_introduction\">https://github.com/leandromoreira/digital_video_introduction</a></p>\n","categories":[],"tags":[{"name":"音视频","slug":"音视频","api":"api/tags/音视频.json"}],"api":"api/posts/2023/09/15/转-《数字化视频技术概述》.json"},{"title":"[转]OpenGL黑屏及渲染不出来的常见原因总结","slug":"转-OpenGL黑屏及渲染不出来的常见原因总结","date":"2023-01-15T04:18:00.000Z","updated":"2025-11-25T02:49:22.233Z","comments":true,"url":"2023/01/15/转-OpenGL黑屏及渲染不出来的常见原因总结/","excerpt":"<p>最近在做 Unitiy 与原生渲染相关的研究学习，对于OpenGL这块自己也是接触不多，有很多的坑需要自己去踩，做的过程中遇到最多的问题是：<strong>渲染黑屏</strong> 在掘金上搜到这篇文章<a href=\"https://juejin.cn/post/6844903910742687751\">《OpenGL黑屏及渲染不出来的常见原因总结》</a>很不错，于是记录转载过来，方便日后学习以及问题排查。</p>\n<p>原文链接：<br><a href=\"https://juejin.cn/post/6844903910742687751\">https://juejin.cn/post/6844903910742687751</a></p>\n<h2 id=\"原文\"><a href=\"#原文\" class=\"headerlink\" title=\"原文\"></a>原文</h2><p>做OpenGL开发的同学，想必一定碰到过黑屏的问题，特别是刚接触OpenGL的同学，可能会觉得黑屏问题让人相当头疼，因为OpenGL的查错没有一般编程时那么简单，我们通常是利用glGetError()这个API来获取错误码，但这个方法获取的错误是调用这个方法时，已经产生的错误，它有可能是很久之前产生的，这样查越来还是比较不方便的，而且，有些黑屏以及渲染不出来的情况下，glGetError()也不会报任何错。</p>\n<p>在给大家总结常见的黑屏原因之前，我们先来铺垫一下基础知识，其实屏幕也是一块frame buffer，但它比较特殊，是0号<code>frame buffer</code>，我们如果自己申请frame buffer的话，得到的id是大于0的。那么frame buffer它就会有自己的颜色，如果不特意设置的话，它就是黑色的，因此如果我们渲染操作未正确执行，什么也没渲染出来，自然看到了底色的黑色。</p>\n<p>我们也可以通过<code>glClearColor()+glClear()</code>来设置消除颜色及执行消除操作，来将一个frame buffer清成某种颜色。因此，如果你将frame buffer清成了别的颜色，但其它渲染操作未正确执行，你有可能也不是黑屏，而是你设置的消除颜色，这里也一并总结了，统成为黑屏，同时也包括其它一些不正确的情形。<br>如果不是渲染到屏幕上，是渲染到一个离屏的frame buffer上，同样也会遇到各种黑掉或者渲染不出来的情况，有些原因会同时导致上屏和离屏都黑，有些只影响其中一种情况。</p>\n<p>下面给大家总结一下：</p>\n<ul>\n<li><strong>调用线程的Context不正确</strong></li>\n</ul>\n<p>OpenGL的API在调用时需要有正确的上下文，在Android中称为<code>EGL Context</code>，IOS中是<code>EAGL Context</code>，其它平台有其它平台的叫法，但原理类似。一个线程需要跟EGL Context绑定才能正确使用OpenGL的API，否则调用不会有任何效果，具体可参考我的一篇文章：<a href=\"https://juejin.cn/post/6844903858380996616\">《OpenGL ES 高级进阶：EGL及GL线程》</a>。</p>\n<blockquote>\n<p>【转载注】这也是我碰到的第一个坑，因为从 Unity 调用到 Android 侧的时候，gl渲染线程和 Unity 线程不一致。我花了很大的精力去排查前面shader相关的渲染问题，一直没有注意这个问题，所以浪费了大量时间。我个人认为这个问题需要像使用一门新语言的时候要先确保它能打印出”Hello World”一样，是整个流程的前提。</p>\n</blockquote>\n<ul>\n<li><strong>GL Program不正确</strong></li>\n</ul>\n<p>OpenGL渲染需要通过GL Program，它就是一个程序，和我们的普通程序是一个道理，只不过它是运行在GPU上的，如果它不正确了，那自然就渲染不出正确的结果，常见的不正确原因为shader编译失败，通常是因为语法错误，可以用glGetShaderInfoLog()来在编译之后查看相关shader信息，以及在Link后用glGetProgramInfoLog()查看相关program信息，如果得到的信息为空，则说明没有错。</p>\n<ul>\n<li><strong>没有use program</strong></li>\n</ul>\n<p>渲染前需要通过glUseProgran设置本次渲染所用的program，如果未设置则无法执行到对应的shader，自然无法渲染出来。</p>\n<ul>\n<li><strong>未调用glDrawXXX()</strong></li>\n</ul>\n<p>要渲染出来东西，必须调用glDrawXXX()，一般很少出现没调的情况，一般都是低级失误，最好也排查一下。</p>\n<p>对于底层是多buffer实现的surface，渲染后未进行swap buffer<br>常见的是双buffer，此时有一个back buffer和一个front buffer，front buffer是正在显存的这个，back buffer是正在渲染的，如果draw call后没有swap buffer，那back buffer不会呈现出来，因此渲染不出来，这里是特定上屏，如果渲染不是要上屏，则无需考虑这个问题。</p>\n<ul>\n<li><strong>frame buffer的attachment不正确</strong></li>\n</ul>\n<p>在离屏渲染情况下，当我们要渲染到一个frame buffer上，这个frame buffer必须正确绑定了attachment，否则相当于frame buffer是个空壳，它没有任何可用于承载渲染结果的空间。</p>\n<ul>\n<li><strong>顶点attribute值设置错误</strong></li>\n</ul>\n<p>顶点关系到渲染到什么位置，如果设置错误导致渲染的位置在可视范围之外，那么就看不到了，这里的范围是什么呢？如果直接用NDC坐标渲染，那就是-1~1,如果是用世界坐标来渲染，那就要看具体设置的投影矩阵，详细原理可参考我的另一篇文章《OpenGL 3D渲染技术：坐标系及矩阵变换》。</p>\n<p>attribute未启用<br>我们通过想要设置一个attribute的值，需要获取这个attribute的location，并通过glVertexAttribPointer()给它设置值，但别忘了需要使用glGetAttribLocation()来启用这个location，不然设置了也没有用，默认是不启用的。</p>\n<ul>\n<li><strong>VAO/VBO未绑定或者绑定错误</strong></li>\n</ul>\n<p>如果是用VAO/VBO的方式渲染，在渲染前要绑定正确的VAO/VBO，否则等于没指定或者指定错了顶点，就渲染不出来了。</p>\n<ul>\n<li><strong>VAO/VBO方式渲染之后未重置，后面接着用非VAO/VBO方式渲染</strong></li>\n</ul>\n<p>在用VAO/VBO方式渲染之后如果未重置，那么顶点绑定的还是VAO/VBO指定的顶点，此时如果再用普通的glVertexAttribPointer()的方式指定顶点渲染，那用法上会冲突，因为VAO/VBO的方式要求glVertexAttribPointer()函数不指定顶点数据，而普通用法中glVertexAttribPointer()又要指定顶点数据，此时容易造成顶点混乱，渲染结果不正确。</p>\n<p>View Port设置错误<br>View Port即视口，可以理解成我们通过一个窗口去看见OpenGL世界坐标系里渲染的景物，就像我们通过窗口看到室外的景物一样，如果这个窗口没设置或者设置不正确，也会导致看不到东西，一般情况下，我们会将它设置为surface的大小，这样渲染出来的东西就刚好填满这个surface。</p>\n<ul>\n<li><strong>没有渲染到0号frame buffer</strong></li>\n</ul>\n<p>有时候渲染操作有很多步，想做完这些步骤后，再将做好的结果显示的屏幕上，这时就会用一些frame buffer来做离屏渲染，但在最后一步渲染到屏幕上时，需要将frame buffer绑定回0号，才能上屏。</p>\n<ul>\n<li><strong>渲染了一个不正确的纹理</strong></li>\n</ul>\n<p>例如我们希望对一个纹理做一些处理然后渲染出来，但如果这个纹理本身是不正确的，例如前面的步骤出了一些错，导致给过来的纹理id不正确，比如是0，或者纹理id是正确的，但这个纹理是全黑的或者空的，也会导致黑屏。</p>\n<ul>\n<li><strong>glDrawXXX()方法传递的顶点数不正确</strong></li>\n</ul>\n<p>我们在调用glDrawXXX()，会设置顶点数组的开始位置和数量，如果设置不正确，导致传递的顶点是0个，也会导致渲染不出来任何东西。</p>\n<ul>\n<li><strong>顶点buffer的position不正确</strong></li>\n</ul>\n<p>这一点主要是针对java及kotlin，glVertexAttribPointer()接受数据时是通过一个buffer，而我们往buffer是put数据后，buffer的position会相应地往后移动，因此在调用glVertexAttribPointer()之前，记得将position设回到0，否则它将从末尾开始取数据，当然就取不到了。</p>\n<ul>\n<li><strong>面剔除的原因</strong></li>\n</ul>\n<p>如果开启了cull face，那么会按你指定的cull方式来剔除指定顶点旋转顺序的三角面片，如果视线方向看过去的刚好被剔除了，自然就看不见了。</p>\n<ul>\n<li><strong>未开启颜色混合渲染了有透明度的纹理</strong></li>\n</ul>\n<p>OpenGL默认是不开启颜色混合的，这会导致透明的部分通常会被渲染成黑色，而不是透出下面的颜色，具体可以参数我的一篇文章：《OpenGL ES 高级进阶：颜色混合》。</p>\n<h3 id=\"转载者新增【主要面向Android】\"><a href=\"#转载者新增【主要面向Android】\" class=\"headerlink\" title=\"转载者新增【主要面向Android】\"></a>转载者新增【主要面向Android】</h3><ul>\n<li>eglCreateWindowSurface 创建 EGLSurface 时机不正确</li>\n</ul>\n<p>传递对应的 surface 参数的时候，需要 TextureView  onSurfaceTextureAvailable 方法被调用过，才能使用 TextureView 的 surface 执行 eglCreateWindowSurface</p>\n<p>原文作者：程序员kenney</p>\n<p>原文链接：<a href=\"https://juejin.cn/post/6844903910742687751\">https://juejin.cn/post/6844903910742687751</a></p>\n<p>来源：稀土掘金</p>\n","cover":null,"images":[],"content":"<p>最近在做 Unitiy 与原生渲染相关的研究学习，对于OpenGL这块自己也是接触不多，有很多的坑需要自己去踩，做的过程中遇到最多的问题是：<strong>渲染黑屏</strong> 在掘金上搜到这篇文章<a href=\"https://juejin.cn/post/6844903910742687751\">《OpenGL黑屏及渲染不出来的常见原因总结》</a>很不错，于是记录转载过来，方便日后学习以及问题排查。</p>\n<p>原文链接：<br><a href=\"https://juejin.cn/post/6844903910742687751\">https://juejin.cn/post/6844903910742687751</a></p>\n<h2 id=\"原文\"><a href=\"#原文\" class=\"headerlink\" title=\"原文\"></a>原文</h2><p>做OpenGL开发的同学，想必一定碰到过黑屏的问题，特别是刚接触OpenGL的同学，可能会觉得黑屏问题让人相当头疼，因为OpenGL的查错没有一般编程时那么简单，我们通常是利用glGetError()这个API来获取错误码，但这个方法获取的错误是调用这个方法时，已经产生的错误，它有可能是很久之前产生的，这样查越来还是比较不方便的，而且，有些黑屏以及渲染不出来的情况下，glGetError()也不会报任何错。</p>\n<p>在给大家总结常见的黑屏原因之前，我们先来铺垫一下基础知识，其实屏幕也是一块frame buffer，但它比较特殊，是0号<code>frame buffer</code>，我们如果自己申请frame buffer的话，得到的id是大于0的。那么frame buffer它就会有自己的颜色，如果不特意设置的话，它就是黑色的，因此如果我们渲染操作未正确执行，什么也没渲染出来，自然看到了底色的黑色。</p>\n<p>我们也可以通过<code>glClearColor()+glClear()</code>来设置消除颜色及执行消除操作，来将一个frame buffer清成某种颜色。因此，如果你将frame buffer清成了别的颜色，但其它渲染操作未正确执行，你有可能也不是黑屏，而是你设置的消除颜色，这里也一并总结了，统成为黑屏，同时也包括其它一些不正确的情形。<br>如果不是渲染到屏幕上，是渲染到一个离屏的frame buffer上，同样也会遇到各种黑掉或者渲染不出来的情况，有些原因会同时导致上屏和离屏都黑，有些只影响其中一种情况。</p>\n<p>下面给大家总结一下：</p>\n<ul>\n<li><strong>调用线程的Context不正确</strong></li>\n</ul>\n<p>OpenGL的API在调用时需要有正确的上下文，在Android中称为<code>EGL Context</code>，IOS中是<code>EAGL Context</code>，其它平台有其它平台的叫法，但原理类似。一个线程需要跟EGL Context绑定才能正确使用OpenGL的API，否则调用不会有任何效果，具体可参考我的一篇文章：<a href=\"https://juejin.cn/post/6844903858380996616\">《OpenGL ES 高级进阶：EGL及GL线程》</a>。</p>\n<blockquote>\n<p>【转载注】这也是我碰到的第一个坑，因为从 Unity 调用到 Android 侧的时候，gl渲染线程和 Unity 线程不一致。我花了很大的精力去排查前面shader相关的渲染问题，一直没有注意这个问题，所以浪费了大量时间。我个人认为这个问题需要像使用一门新语言的时候要先确保它能打印出”Hello World”一样，是整个流程的前提。</p>\n</blockquote>\n<ul>\n<li><strong>GL Program不正确</strong></li>\n</ul>\n<p>OpenGL渲染需要通过GL Program，它就是一个程序，和我们的普通程序是一个道理，只不过它是运行在GPU上的，如果它不正确了，那自然就渲染不出正确的结果，常见的不正确原因为shader编译失败，通常是因为语法错误，可以用glGetShaderInfoLog()来在编译之后查看相关shader信息，以及在Link后用glGetProgramInfoLog()查看相关program信息，如果得到的信息为空，则说明没有错。</p>\n<ul>\n<li><strong>没有use program</strong></li>\n</ul>\n<p>渲染前需要通过glUseProgran设置本次渲染所用的program，如果未设置则无法执行到对应的shader，自然无法渲染出来。</p>\n<ul>\n<li><strong>未调用glDrawXXX()</strong></li>\n</ul>\n<p>要渲染出来东西，必须调用glDrawXXX()，一般很少出现没调的情况，一般都是低级失误，最好也排查一下。</p>\n<p>对于底层是多buffer实现的surface，渲染后未进行swap buffer<br>常见的是双buffer，此时有一个back buffer和一个front buffer，front buffer是正在显存的这个，back buffer是正在渲染的，如果draw call后没有swap buffer，那back buffer不会呈现出来，因此渲染不出来，这里是特定上屏，如果渲染不是要上屏，则无需考虑这个问题。</p>\n<ul>\n<li><strong>frame buffer的attachment不正确</strong></li>\n</ul>\n<p>在离屏渲染情况下，当我们要渲染到一个frame buffer上，这个frame buffer必须正确绑定了attachment，否则相当于frame buffer是个空壳，它没有任何可用于承载渲染结果的空间。</p>\n<ul>\n<li><strong>顶点attribute值设置错误</strong></li>\n</ul>\n<p>顶点关系到渲染到什么位置，如果设置错误导致渲染的位置在可视范围之外，那么就看不到了，这里的范围是什么呢？如果直接用NDC坐标渲染，那就是-1~1,如果是用世界坐标来渲染，那就要看具体设置的投影矩阵，详细原理可参考我的另一篇文章《OpenGL 3D渲染技术：坐标系及矩阵变换》。</p>\n<p>attribute未启用<br>我们通过想要设置一个attribute的值，需要获取这个attribute的location，并通过glVertexAttribPointer()给它设置值，但别忘了需要使用glGetAttribLocation()来启用这个location，不然设置了也没有用，默认是不启用的。</p>\n<ul>\n<li><strong>VAO/VBO未绑定或者绑定错误</strong></li>\n</ul>\n<p>如果是用VAO/VBO的方式渲染，在渲染前要绑定正确的VAO/VBO，否则等于没指定或者指定错了顶点，就渲染不出来了。</p>\n<ul>\n<li><strong>VAO/VBO方式渲染之后未重置，后面接着用非VAO/VBO方式渲染</strong></li>\n</ul>\n<p>在用VAO/VBO方式渲染之后如果未重置，那么顶点绑定的还是VAO/VBO指定的顶点，此时如果再用普通的glVertexAttribPointer()的方式指定顶点渲染，那用法上会冲突，因为VAO/VBO的方式要求glVertexAttribPointer()函数不指定顶点数据，而普通用法中glVertexAttribPointer()又要指定顶点数据，此时容易造成顶点混乱，渲染结果不正确。</p>\n<p>View Port设置错误<br>View Port即视口，可以理解成我们通过一个窗口去看见OpenGL世界坐标系里渲染的景物，就像我们通过窗口看到室外的景物一样，如果这个窗口没设置或者设置不正确，也会导致看不到东西，一般情况下，我们会将它设置为surface的大小，这样渲染出来的东西就刚好填满这个surface。</p>\n<ul>\n<li><strong>没有渲染到0号frame buffer</strong></li>\n</ul>\n<p>有时候渲染操作有很多步，想做完这些步骤后，再将做好的结果显示的屏幕上，这时就会用一些frame buffer来做离屏渲染，但在最后一步渲染到屏幕上时，需要将frame buffer绑定回0号，才能上屏。</p>\n<ul>\n<li><strong>渲染了一个不正确的纹理</strong></li>\n</ul>\n<p>例如我们希望对一个纹理做一些处理然后渲染出来，但如果这个纹理本身是不正确的，例如前面的步骤出了一些错，导致给过来的纹理id不正确，比如是0，或者纹理id是正确的，但这个纹理是全黑的或者空的，也会导致黑屏。</p>\n<ul>\n<li><strong>glDrawXXX()方法传递的顶点数不正确</strong></li>\n</ul>\n<p>我们在调用glDrawXXX()，会设置顶点数组的开始位置和数量，如果设置不正确，导致传递的顶点是0个，也会导致渲染不出来任何东西。</p>\n<ul>\n<li><strong>顶点buffer的position不正确</strong></li>\n</ul>\n<p>这一点主要是针对java及kotlin，glVertexAttribPointer()接受数据时是通过一个buffer，而我们往buffer是put数据后，buffer的position会相应地往后移动，因此在调用glVertexAttribPointer()之前，记得将position设回到0，否则它将从末尾开始取数据，当然就取不到了。</p>\n<ul>\n<li><strong>面剔除的原因</strong></li>\n</ul>\n<p>如果开启了cull face，那么会按你指定的cull方式来剔除指定顶点旋转顺序的三角面片，如果视线方向看过去的刚好被剔除了，自然就看不见了。</p>\n<ul>\n<li><strong>未开启颜色混合渲染了有透明度的纹理</strong></li>\n</ul>\n<p>OpenGL默认是不开启颜色混合的，这会导致透明的部分通常会被渲染成黑色，而不是透出下面的颜色，具体可以参数我的一篇文章：《OpenGL ES 高级进阶：颜色混合》。</p>\n<h3 id=\"转载者新增【主要面向Android】\"><a href=\"#转载者新增【主要面向Android】\" class=\"headerlink\" title=\"转载者新增【主要面向Android】\"></a>转载者新增【主要面向Android】</h3><ul>\n<li>eglCreateWindowSurface 创建 EGLSurface 时机不正确</li>\n</ul>\n<p>传递对应的 surface 参数的时候，需要 TextureView  onSurfaceTextureAvailable 方法被调用过，才能使用 TextureView 的 surface 执行 eglCreateWindowSurface</p>\n<p>原文作者：程序员kenney</p>\n<p>原文链接：<a href=\"https://juejin.cn/post/6844903910742687751\">https://juejin.cn/post/6844903910742687751</a></p>\n<p>来源：稀土掘金</p>\n","categories":[{"name":"技术文章","slug":"technology","api":"api/categories/technology.json"}],"tags":[{"name":"音视频","slug":"音视频","api":"api/tags/音视频.json"},{"name":"OpenGL","slug":"OpenGL","api":"api/tags/OpenGL.json"}],"api":"api/posts/2023/01/15/转-OpenGL黑屏及渲染不出来的常见原因总结.json"},{"title":"FFmpeg.so 编译总结","slug":"FFmpeg-so-编译整理","date":"2023-01-09T02:36:00.000Z","updated":"2025-05-20T11:46:57.000Z","comments":true,"url":"2023/01/09/FFmpeg-so-编译整理/","excerpt":"<p>此前项目一直使用的 FFmpeg.so 是我从其他团队项目中直接复制过来的，但原来的项目团队不再维护这个库，其中 x264 模块由于一些版权问题需要剔除，所以需要自己重新编译。在编译的过程中踩了很多坑，以及编译 congfigure 有太多的配置，如何减少整体编译出来的大小也是需要花点精力的，本文主要记录编译流程以及相关配置介绍。</p>\n<h2 id=\"编译介绍\"><a href=\"#编译介绍\" class=\"headerlink\" title=\"编译介绍\"></a>编译介绍</h2><p>自己编译主要参考<a href=\"https://github.com/Timdk857/Android-Architecture-knowledge-2-/blob/master/Android%20%E9%9F%B3%E8%A7%86%E9%A2%91%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97/Android-%E9%9F%B3%E8%A7%86%E9%A2%91%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97-(%E5%9B%9B\">《一键编译32_64位FFmpeg.4.2.2》</a>-%E4%B8%80%E9%94%AE%E7%BC%96%E8%AF%91-32-64-%E4%BD%8D-FFmpeg-4-2-2.md)，最开始的时候自己一直在 Mac M1 上编译，各种流程也是一比一复刻，但是仍然会有各种问题出现，最常见的就是：</p>\n<blockquote>\n<p>aarch64-linux-android21-clang is unable to create an executable file.<br>C compiler test failed.</p>\n</blockquote>\n<p>我反复检查了自己的 NDK 的配置，确保是正确的，文章也有提及处理方式，但是尝试下来都无效，在网上搜了一大篇解决方式，也都无效。不过我看他们很多都是用 Linux 系统进行的编译，遂改为使用 Linux 编译，再重新尝试，似乎没有那些个奇奇怪怪的错误了，也打出了最终的包，最后的 so 大小也符合要求。</p>\n<h3 id=\"编译环境\"><a href=\"#编译环境\" class=\"headerlink\" title=\"编译环境\"></a>编译环境</h3><ul>\n<li>CentOS 7</li>\n<li><a href=\"https://ffmpeg.org/releases/ffmpeg-4.2.2.tar.bz2\">ffmpeg-4.2.2</a></li>\n<li><a href=\"https://github.com/android/ndk/wiki/Unsupported-Downloads\">android-ndk-r20b-linux-x86_64.zip</a></li>\n</ul>\n<h3 id=\"编译脚本\"><a href=\"#编译脚本\" class=\"headerlink\" title=\"编译脚本\"></a>编译脚本</h3><p>这是我的一份编译脚本，我的需求是进行本地视频抽帧，所以不需要像滤镜、编码、音频相关的配置，只需要视频解码相关的配置，具体配置在下一节有讲解。</p>\n<figure class=\"highlight powershell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#!/bin/bash</span></span><br><span class=\"line\">export NDK=.../android<span class=\"literal\">-ndk-r20b</span></span><br><span class=\"line\">TOOLCHAIN=<span class=\"variable\">$NDK</span>/toolchains/llvm/prebuilt/linux<span class=\"literal\">-x86_64</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">build_android</span></span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">./configure \\ </span><br><span class=\"line\"><span class=\"literal\">--prefix</span>=<span class=\"variable\">$PREFIX</span> \\ </span><br><span class=\"line\"><span class=\"literal\">--enable-neon</span> \\ </span><br><span class=\"line\"><span class=\"literal\">--disable-x86asm</span> \\ </span><br><span class=\"line\"><span class=\"literal\">--disable-hwaccels</span> \\ </span><br><span class=\"line\"><span class=\"literal\">--disable-gpl</span> \\ </span><br><span class=\"line\"><span class=\"literal\">--disable-nonfree</span> \\ </span><br><span class=\"line\"><span class=\"literal\">--disable-version3</span> \\ </span><br><span class=\"line\"><span class=\"literal\">--disable-postproc</span> \\ </span><br><span class=\"line\"><span class=\"literal\">--disable-bsfs</span> \\ </span><br><span class=\"line\"><span class=\"literal\">--disable-protocols</span> \\ </span><br><span class=\"line\"><span class=\"literal\">--enable-protocol</span>=file \\ </span><br><span class=\"line\"><span class=\"literal\">--disable-indevs</span> \\ </span><br><span class=\"line\"><span class=\"literal\">--disable-outdevs</span> \\ </span><br><span class=\"line\"><span class=\"literal\">--disable-debug</span> \\ </span><br><span class=\"line\"><span class=\"literal\">--enable-small</span> \\ </span><br><span class=\"line\"><span class=\"literal\">--enable-jni</span> \\ </span><br><span class=\"line\"><span class=\"literal\">--disable-mediacodec</span> \\ </span><br><span class=\"line\"><span class=\"literal\">--disable-decoder</span>=h264_mediacodec \\ </span><br><span class=\"line\"><span class=\"literal\">--enable-swscale</span> \\ </span><br><span class=\"line\"><span class=\"literal\">--enable-static</span> \\ </span><br><span class=\"line\"><span class=\"literal\">--disable-shared</span> \\ </span><br><span class=\"line\"><span class=\"literal\">--disable-filters</span> \\ </span><br><span class=\"line\"><span class=\"literal\">--disable-avfilter</span> \\ </span><br><span class=\"line\"><span class=\"literal\">--disable-encoders</span> \\ </span><br><span class=\"line\"><span class=\"literal\">--disable-muxers</span> \\ </span><br><span class=\"line\"><span class=\"literal\">--disable-demuxers</span> \\ </span><br><span class=\"line\"><span class=\"literal\">--enable-demuxer</span>=avi \\ </span><br><span class=\"line\"><span class=\"literal\">--enable-demuxer</span>=flv \\ </span><br><span class=\"line\"><span class=\"literal\">--enable-demuxer</span>=h261 \\ </span><br><span class=\"line\"><span class=\"literal\">--enable-demuxer</span>=h263 \\ </span><br><span class=\"line\"><span class=\"literal\">--enable-demuxer</span>=h264 \\ </span><br><span class=\"line\"><span class=\"literal\">--enable-demuxer</span>=hevc \\ </span><br><span class=\"line\"><span class=\"literal\">--enable-demuxer</span>=mov \\ </span><br><span class=\"line\"><span class=\"literal\">--enable-demuxer</span>=m4v \\ </span><br><span class=\"line\"><span class=\"literal\">--disable-decoders</span> \\ </span><br><span class=\"line\"><span class=\"literal\">--enable-decoder</span>=h263 \\ </span><br><span class=\"line\"><span class=\"literal\">--enable-decoder</span>=h263i \\ </span><br><span class=\"line\"><span class=\"literal\">--enable-decoder</span>=h263p \\ </span><br><span class=\"line\"><span class=\"literal\">--enable-decoder</span>=h264 \\ </span><br><span class=\"line\"><span class=\"literal\">--enable-decoder</span>=hevc \\ </span><br><span class=\"line\"><span class=\"literal\">--enable-decoder</span>=flv \\ </span><br><span class=\"line\"><span class=\"literal\">--enable-decoder</span>=mpeg4 \\ </span><br><span class=\"line\"><span class=\"literal\">--disable-parsers</span> \\ </span><br><span class=\"line\"><span class=\"literal\">--enable-parser</span>=h264 \\ </span><br><span class=\"line\"><span class=\"literal\">--enable-parser</span>=h261 \\ </span><br><span class=\"line\"><span class=\"literal\">--enable-parser</span>=h263 \\ </span><br><span class=\"line\"><span class=\"literal\">--enable-parser</span>=mpeg4video \\ </span><br><span class=\"line\"><span class=\"literal\">--enable-parser</span>=mpegvideo \\ </span><br><span class=\"line\"><span class=\"literal\">--disable-htmlpages</span> \\ </span><br><span class=\"line\"><span class=\"literal\">--disable-manpages</span> \\ </span><br><span class=\"line\"><span class=\"literal\">--disable-podpages</span> \\ </span><br><span class=\"line\"><span class=\"literal\">--disable-txtpages</span> \\ </span><br><span class=\"line\"><span class=\"literal\">--disable-vaapi</span> \\ </span><br><span class=\"line\"><span class=\"literal\">--disable-v4l2-m2m</span> \\ </span><br><span class=\"line\"><span class=\"literal\">--disable-nvdec</span> \\ </span><br><span class=\"line\"><span class=\"literal\">--disable-nvenc</span> \\ </span><br><span class=\"line\"><span class=\"literal\">--disable-ffnvcodec</span> \\ </span><br><span class=\"line\"><span class=\"literal\">--disable-dxva2</span> \\ </span><br><span class=\"line\"><span class=\"literal\">--disable-d3d11va</span> \\ </span><br><span class=\"line\"><span class=\"literal\">--disable-cuvid</span> \\ </span><br><span class=\"line\"><span class=\"literal\">--disable-cuda-llvm</span> \\ </span><br><span class=\"line\"><span class=\"literal\">--disable-cuda-nvcc</span> \\ </span><br><span class=\"line\"><span class=\"literal\">--disable-audiotoolbox</span> \\ </span><br><span class=\"line\"><span class=\"literal\">--disable-amf</span> \\ </span><br><span class=\"line\"><span class=\"literal\">--disable-iconv</span> \\ </span><br><span class=\"line\"><span class=\"literal\">--disable-libxcb</span> \\ </span><br><span class=\"line\"><span class=\"literal\">--disable-libxcb-shm</span> \\ </span><br><span class=\"line\"><span class=\"literal\">--disable-libxcb-xfixes</span> \\ </span><br><span class=\"line\"><span class=\"literal\">--disable-libxcb-shape</span> \\ </span><br><span class=\"line\"><span class=\"literal\">--disable-lzma</span> \\ </span><br><span class=\"line\"><span class=\"literal\">--disable-sdl2</span> \\ </span><br><span class=\"line\"><span class=\"literal\">--disable-securetransport</span> \\ </span><br><span class=\"line\"><span class=\"literal\">--disable-xlib</span> \\ </span><br><span class=\"line\"><span class=\"literal\">--disable-zlib</span> \\ </span><br><span class=\"line\"><span class=\"literal\">--disable-programs</span> \\ </span><br><span class=\"line\"><span class=\"literal\">--disable-ffmpeg</span> \\ </span><br><span class=\"line\"><span class=\"literal\">--disable-ffplay</span> \\ </span><br><span class=\"line\"><span class=\"literal\">--disable-ffprobe</span> \\ </span><br><span class=\"line\"><span class=\"literal\">--disable-avdevice</span> \\ </span><br><span class=\"line\"><span class=\"literal\">--disable-symver</span> \\ </span><br><span class=\"line\"><span class=\"literal\">--cross-prefix</span>=<span class=\"variable\">$CROSS_PREFIX</span> \\ </span><br><span class=\"line\"><span class=\"literal\">--target-os</span>=android \\ </span><br><span class=\"line\"><span class=\"literal\">--arch</span>=<span class=\"variable\">$ARCH</span> \\ </span><br><span class=\"line\"><span class=\"literal\">--cpu</span>=<span class=\"variable\">$CPU</span> \\ </span><br><span class=\"line\"><span class=\"literal\">--cc</span>=<span class=\"variable\">$CC</span> \\ </span><br><span class=\"line\"><span class=\"literal\">--cxx</span>=<span class=\"variable\">$CXX</span> \\ </span><br><span class=\"line\"><span class=\"literal\">--enable-cross-compile</span> \\ </span><br><span class=\"line\"><span class=\"literal\">--sysroot</span>=<span class=\"variable\">$SYSROOT</span> \\ </span><br><span class=\"line\"><span class=\"literal\">--extra-cflags</span>=<span class=\"string\">&quot;-Os -fpic <span class=\"variable\">$OPTIMIZE_CFLAGS</span>&quot;</span> \\ </span><br><span class=\"line\"><span class=\"literal\">--extra-ldflags</span>=<span class=\"string\">&quot;<span class=\"variable\">$ADDI_LDFLAGS</span>&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">make clean</span><br><span class=\"line\">make <span class=\"literal\">-j16</span></span><br><span class=\"line\">make install</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#arm64-v8a</span></span><br><span class=\"line\">ARCH=arm64</span><br><span class=\"line\">CPU=armv8<span class=\"literal\">-a</span></span><br><span class=\"line\">API=<span class=\"number\">21</span></span><br><span class=\"line\">CC=<span class=\"variable\">$TOOLCHAIN</span>/bin/aarch64<span class=\"literal\">-linux-android</span><span class=\"variable\">$API</span><span class=\"literal\">-clang</span></span><br><span class=\"line\">CXX=<span class=\"variable\">$TOOLCHAIN</span>/bin/aarch64<span class=\"literal\">-linux-android</span><span class=\"variable\">$API</span><span class=\"literal\">-clang</span>++</span><br><span class=\"line\">SYSROOT=<span class=\"variable\">$NDK</span>/toolchains/llvm/prebuilt/linux<span class=\"literal\">-x86_64</span>/sysroot</span><br><span class=\"line\">CROSS_PREFIX=<span class=\"variable\">$TOOLCHAIN</span>/bin/aarch64<span class=\"literal\">-linux-android-</span></span><br><span class=\"line\">PREFIX=<span class=\"variable\">$</span>(<span class=\"built_in\">pwd</span>)/android/<span class=\"variable\">$CPU</span></span><br><span class=\"line\">OPTIMIZE_CFLAGS=<span class=\"string\">&quot;-march=<span class=\"variable\">$CPU</span>&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">build_android</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#armv7-a</span></span><br><span class=\"line\">ARCH=arm</span><br><span class=\"line\">CPU=armv7<span class=\"literal\">-a</span></span><br><span class=\"line\">API=<span class=\"number\">21</span></span><br><span class=\"line\">CC=<span class=\"variable\">$TOOLCHAIN</span>/bin/armv7a<span class=\"literal\">-linux-androideabi</span><span class=\"variable\">$API</span><span class=\"literal\">-clang</span></span><br><span class=\"line\">CXX=<span class=\"variable\">$TOOLCHAIN</span>/bin/armv7a<span class=\"literal\">-linux-androideabi</span><span class=\"variable\">$API</span><span class=\"literal\">-clang</span>++</span><br><span class=\"line\">SYSROOT=<span class=\"variable\">$NDK</span>/toolchains/llvm/prebuilt/linux<span class=\"literal\">-x86_64</span>/sysroot</span><br><span class=\"line\">CROSS_PREFIX=<span class=\"variable\">$TOOLCHAIN</span>/bin/arm<span class=\"literal\">-linux-androideabi-</span></span><br><span class=\"line\">PREFIX=<span class=\"variable\">$</span>(<span class=\"built_in\">pwd</span>)/android/<span class=\"variable\">$CPU</span></span><br><span class=\"line\">OPTIMIZE_CFLAGS=<span class=\"string\">&quot;-mfloat-abi=softfp -mfpu=vfp -marm -march=<span class=\"variable\">$CPU</span> &quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">build_android</span><br></pre></td></tr></table></figure>\n<h2 id=\"配置介绍\"><a href=\"#配置介绍\" class=\"headerlink\" title=\"配置介绍\"></a>配置介绍</h2><p>通过执行 <code>./configure --help</code> 能得到所有的配置选项，整个配置也非常好理解，通过 list-xxx 可以知道有哪些子选项，然后再通过 <code>--disable-xxx</code>,或者 <code>--enable-xxx</code> 进行关闭或者打开。以解码为例：</p>\n<figure class=\"highlight powershell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"literal\">--disable-decoders</span>       <span class=\"comment\"># 先关闭所有的解码器</span></span><br><span class=\"line\"><span class=\"literal\">--enable-decoder</span>=flv     <span class=\"comment\"># 然后只打开flv、mpeg4 的支持</span></span><br><span class=\"line\"><span class=\"literal\">--enable-decoder</span>=mpeg4 </span><br></pre></td></tr></table></figure>\n<p>对于<code>--enable-decoder=xxx</code>中的xxx可以通过 <code>./configure --list-decoders</code> 进行查看，同理 <code>encoders</code> <code>demuxers</code> <code>muxers</code> 等都是类似的处理，通过 <code>--help</code> 可以通过 <code>list--xxx</code> 查看不同功能的可以支持的配置，主要有以下：</p>\n<figure class=\"highlight powershell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"literal\">--list-decoders</span>          show all available decoders</span><br><span class=\"line\"><span class=\"literal\">--list-encoders</span>          show all available encoders</span><br><span class=\"line\"><span class=\"literal\">--list-hwaccels</span>          show all available hardware accelerators</span><br><span class=\"line\"><span class=\"literal\">--list-demuxers</span>          show all available demuxers</span><br><span class=\"line\"><span class=\"literal\">--list-muxers</span>            show all available muxers</span><br><span class=\"line\"><span class=\"literal\">--list-parsers</span>           show all available parsers</span><br><span class=\"line\"><span class=\"literal\">--list-protocols</span>         show all available protocols</span><br><span class=\"line\"><span class=\"literal\">--list-bsfs</span>              show all available bitstream filters</span><br><span class=\"line\"><span class=\"literal\">--list-indevs</span>            show all available input devices</span><br><span class=\"line\"><span class=\"literal\">--list-outdevs</span>           show all available output devices</span><br><span class=\"line\"><span class=\"literal\">--list-filters</span>           show all available filters</span><br></pre></td></tr></table></figure>\n<p>其他的配置就是一些实际性的开关配置，列一些常用的配置：</p>\n<p>配置产物为静态库(.a)或者动态库(.so)</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">--enable-static         do not build static libraries [no]</span><br><span class=\"line\">--enable-shared         build shared libraries [no]</span><br></pre></td></tr></table></figure>\n<p>配置减少包大小<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">--enable-small           optimize for size instead of speed</span><br></pre></td></tr></table></figure></p>\n<p><code>--enable-small</code> 的配置项，其实是在config.h里声称了CONFIG_SMALL选项，然后代码内根据CONFIG_SMALL做了一些调整，比如某些string类型就被省掉了，还有一些内置生成的table, 体积也被裁减掉了，用速度换体积。比如这里：<br><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">if</span> CONFIG_SMALL</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> CRC_TABLE_SIZE 257</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">else</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> CRC_TABLE_SIZE 1024</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span></span></span><br></pre></td></tr></table></figure></p>\n<p>配置FFmpeg协议，由于我们使用本地文件，需要再加一个： <code>--enable-protocol=file</code>，要不然解码会报协议相关错误</p>\n<figure class=\"highlight powershell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"literal\">--disable-protocols</span>      disable all protocols</span><br></pre></td></tr></table></figure>\n<p>我们只需要在代码中使用 FFmpeg，所以直接禁用命令行工具<br><figure class=\"highlight powershell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"literal\">--disable-programs</span>       <span class=\"keyword\">do</span> not build command line programs</span><br><span class=\"line\"><span class=\"literal\">--disable-ffmpeg</span>         disable ffmpeg build</span><br><span class=\"line\"><span class=\"literal\">--disable-ffplay</span>         disable ffplay build</span><br><span class=\"line\"><span class=\"literal\">--disable-ffprobe</span>        disable ffprobe build</span><br></pre></td></tr></table></figure></p>\n<p>还有几个比较重要的就是，主要是<br><figure class=\"highlight powershell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"literal\">--disable-avdevice</span>       disable libavdevice build</span><br><span class=\"line\"><span class=\"literal\">--disable-swresample</span>     disable libswresample build</span><br><span class=\"line\"><span class=\"literal\">--disable-swscale</span>        disable libswscale build</span><br><span class=\"line\"><span class=\"literal\">--disable-postproc</span>       disable libpostproc build</span><br><span class=\"line\"><span class=\"literal\">--disable-avfilter</span>       disable libavfilter build</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"编译遇见的坑\"><a href=\"#编译遇见的坑\" class=\"headerlink\" title=\"编译遇见的坑\"></a>编译遇见的坑</h2><p><strong>1、aarch64-linux-android21-clang is unable to create an executable file.<br>C compiler test failed.</strong></p>\n<p>这个问题是困扰我最久的，按照解决方法：<br>原因 1： FFmpeg 4.2.2 版本默认使用了 clang 进行编译<br>解决：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">//1\\. 修改 configure 文件</span><br><span class=\"line\">vim configure</span><br><span class=\"line\">//2\\. 把 默认的 clang 修改为 gcc</span><br><span class=\"line\">if test &quot;$target_os&quot; = android; then</span><br><span class=\"line\">   # cc_default=&quot;clang&quot;</span><br><span class=\"line\">\t\t cc_default=&quot;gcc&quot;</span><br><span class=\"line\">fi</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>原因2，检查路径是否正确，主要是 NDK 的位置，以及不同 NDK 相关库可能存在一定的丢失。</p>\n<p>这个问题我在 macOS 上未解决，<strong>换用 CentOS 没有出现过这个编译问题</strong>。</p>\n<p><strong>2、 编译包大小一直不变</strong></p>\n<p>最开始我正常编译的时候发现怎么改配置，最后的包大小都没有发生变化，但是命令行里面各种流程又是在走，最终也有产物。这里一定要关注在执行了编译脚本之后，查看最开始的日志，看看具体是一些什么错，这里日志会刷得很快，如果包大小一直没有发生变化的话，可以执行完之后快速停止，看看是什么错。一般就是<code>C compiler test failed.</code> 或者找不到你的配置，改对即可。正常编译，会在开始后列出你的编译配置。</p>\n<p><strong>3、x86asm 相关的问题</strong></p>\n<p>编译的时候遇到一些 x86asm 的错，按照文章所说即可</p>\n","cover":null,"images":[],"content":"<p>此前项目一直使用的 FFmpeg.so 是我从其他团队项目中直接复制过来的，但原来的项目团队不再维护这个库，其中 x264 模块由于一些版权问题需要剔除，所以需要自己重新编译。在编译的过程中踩了很多坑，以及编译 congfigure 有太多的配置，如何减少整体编译出来的大小也是需要花点精力的，本文主要记录编译流程以及相关配置介绍。</p>\n<h2 id=\"编译介绍\"><a href=\"#编译介绍\" class=\"headerlink\" title=\"编译介绍\"></a>编译介绍</h2><p>自己编译主要参考<a href=\"https://github.com/Timdk857/Android-Architecture-knowledge-2-/blob/master/Android%20%E9%9F%B3%E8%A7%86%E9%A2%91%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97/Android-%E9%9F%B3%E8%A7%86%E9%A2%91%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97-(%E5%9B%9B\">《一键编译32_64位FFmpeg.4.2.2》</a>-%E4%B8%80%E9%94%AE%E7%BC%96%E8%AF%91-32-64-%E4%BD%8D-FFmpeg-4-2-2.md)，最开始的时候自己一直在 Mac M1 上编译，各种流程也是一比一复刻，但是仍然会有各种问题出现，最常见的就是：</p>\n<blockquote>\n<p>aarch64-linux-android21-clang is unable to create an executable file.<br>C compiler test failed.</p>\n</blockquote>\n<p>我反复检查了自己的 NDK 的配置，确保是正确的，文章也有提及处理方式，但是尝试下来都无效，在网上搜了一大篇解决方式，也都无效。不过我看他们很多都是用 Linux 系统进行的编译，遂改为使用 Linux 编译，再重新尝试，似乎没有那些个奇奇怪怪的错误了，也打出了最终的包，最后的 so 大小也符合要求。</p>\n<h3 id=\"编译环境\"><a href=\"#编译环境\" class=\"headerlink\" title=\"编译环境\"></a>编译环境</h3><ul>\n<li>CentOS 7</li>\n<li><a href=\"https://ffmpeg.org/releases/ffmpeg-4.2.2.tar.bz2\">ffmpeg-4.2.2</a></li>\n<li><a href=\"https://github.com/android/ndk/wiki/Unsupported-Downloads\">android-ndk-r20b-linux-x86_64.zip</a></li>\n</ul>\n<h3 id=\"编译脚本\"><a href=\"#编译脚本\" class=\"headerlink\" title=\"编译脚本\"></a>编译脚本</h3><p>这是我的一份编译脚本，我的需求是进行本地视频抽帧，所以不需要像滤镜、编码、音频相关的配置，只需要视频解码相关的配置，具体配置在下一节有讲解。</p>\n<figure class=\"highlight powershell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#!/bin/bash</span></span><br><span class=\"line\">export NDK=.../android<span class=\"literal\">-ndk-r20b</span></span><br><span class=\"line\">TOOLCHAIN=<span class=\"variable\">$NDK</span>/toolchains/llvm/prebuilt/linux<span class=\"literal\">-x86_64</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">build_android</span></span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">./configure \\ </span><br><span class=\"line\"><span class=\"literal\">--prefix</span>=<span class=\"variable\">$PREFIX</span> \\ </span><br><span class=\"line\"><span class=\"literal\">--enable-neon</span> \\ </span><br><span class=\"line\"><span class=\"literal\">--disable-x86asm</span> \\ </span><br><span class=\"line\"><span class=\"literal\">--disable-hwaccels</span> \\ </span><br><span class=\"line\"><span class=\"literal\">--disable-gpl</span> \\ </span><br><span class=\"line\"><span class=\"literal\">--disable-nonfree</span> \\ </span><br><span class=\"line\"><span class=\"literal\">--disable-version3</span> \\ </span><br><span class=\"line\"><span class=\"literal\">--disable-postproc</span> \\ </span><br><span class=\"line\"><span class=\"literal\">--disable-bsfs</span> \\ </span><br><span class=\"line\"><span class=\"literal\">--disable-protocols</span> \\ </span><br><span class=\"line\"><span class=\"literal\">--enable-protocol</span>=file \\ </span><br><span class=\"line\"><span class=\"literal\">--disable-indevs</span> \\ </span><br><span class=\"line\"><span class=\"literal\">--disable-outdevs</span> \\ </span><br><span class=\"line\"><span class=\"literal\">--disable-debug</span> \\ </span><br><span class=\"line\"><span class=\"literal\">--enable-small</span> \\ </span><br><span class=\"line\"><span class=\"literal\">--enable-jni</span> \\ </span><br><span class=\"line\"><span class=\"literal\">--disable-mediacodec</span> \\ </span><br><span class=\"line\"><span class=\"literal\">--disable-decoder</span>=h264_mediacodec \\ </span><br><span class=\"line\"><span class=\"literal\">--enable-swscale</span> \\ </span><br><span class=\"line\"><span class=\"literal\">--enable-static</span> \\ </span><br><span class=\"line\"><span class=\"literal\">--disable-shared</span> \\ </span><br><span class=\"line\"><span class=\"literal\">--disable-filters</span> \\ </span><br><span class=\"line\"><span class=\"literal\">--disable-avfilter</span> \\ </span><br><span class=\"line\"><span class=\"literal\">--disable-encoders</span> \\ </span><br><span class=\"line\"><span class=\"literal\">--disable-muxers</span> \\ </span><br><span class=\"line\"><span class=\"literal\">--disable-demuxers</span> \\ </span><br><span class=\"line\"><span class=\"literal\">--enable-demuxer</span>=avi \\ </span><br><span class=\"line\"><span class=\"literal\">--enable-demuxer</span>=flv \\ </span><br><span class=\"line\"><span class=\"literal\">--enable-demuxer</span>=h261 \\ </span><br><span class=\"line\"><span class=\"literal\">--enable-demuxer</span>=h263 \\ </span><br><span class=\"line\"><span class=\"literal\">--enable-demuxer</span>=h264 \\ </span><br><span class=\"line\"><span class=\"literal\">--enable-demuxer</span>=hevc \\ </span><br><span class=\"line\"><span class=\"literal\">--enable-demuxer</span>=mov \\ </span><br><span class=\"line\"><span class=\"literal\">--enable-demuxer</span>=m4v \\ </span><br><span class=\"line\"><span class=\"literal\">--disable-decoders</span> \\ </span><br><span class=\"line\"><span class=\"literal\">--enable-decoder</span>=h263 \\ </span><br><span class=\"line\"><span class=\"literal\">--enable-decoder</span>=h263i \\ </span><br><span class=\"line\"><span class=\"literal\">--enable-decoder</span>=h263p \\ </span><br><span class=\"line\"><span class=\"literal\">--enable-decoder</span>=h264 \\ </span><br><span class=\"line\"><span class=\"literal\">--enable-decoder</span>=hevc \\ </span><br><span class=\"line\"><span class=\"literal\">--enable-decoder</span>=flv \\ </span><br><span class=\"line\"><span class=\"literal\">--enable-decoder</span>=mpeg4 \\ </span><br><span class=\"line\"><span class=\"literal\">--disable-parsers</span> \\ </span><br><span class=\"line\"><span class=\"literal\">--enable-parser</span>=h264 \\ </span><br><span class=\"line\"><span class=\"literal\">--enable-parser</span>=h261 \\ </span><br><span class=\"line\"><span class=\"literal\">--enable-parser</span>=h263 \\ </span><br><span class=\"line\"><span class=\"literal\">--enable-parser</span>=mpeg4video \\ </span><br><span class=\"line\"><span class=\"literal\">--enable-parser</span>=mpegvideo \\ </span><br><span class=\"line\"><span class=\"literal\">--disable-htmlpages</span> \\ </span><br><span class=\"line\"><span class=\"literal\">--disable-manpages</span> \\ </span><br><span class=\"line\"><span class=\"literal\">--disable-podpages</span> \\ </span><br><span class=\"line\"><span class=\"literal\">--disable-txtpages</span> \\ </span><br><span class=\"line\"><span class=\"literal\">--disable-vaapi</span> \\ </span><br><span class=\"line\"><span class=\"literal\">--disable-v4l2-m2m</span> \\ </span><br><span class=\"line\"><span class=\"literal\">--disable-nvdec</span> \\ </span><br><span class=\"line\"><span class=\"literal\">--disable-nvenc</span> \\ </span><br><span class=\"line\"><span class=\"literal\">--disable-ffnvcodec</span> \\ </span><br><span class=\"line\"><span class=\"literal\">--disable-dxva2</span> \\ </span><br><span class=\"line\"><span class=\"literal\">--disable-d3d11va</span> \\ </span><br><span class=\"line\"><span class=\"literal\">--disable-cuvid</span> \\ </span><br><span class=\"line\"><span class=\"literal\">--disable-cuda-llvm</span> \\ </span><br><span class=\"line\"><span class=\"literal\">--disable-cuda-nvcc</span> \\ </span><br><span class=\"line\"><span class=\"literal\">--disable-audiotoolbox</span> \\ </span><br><span class=\"line\"><span class=\"literal\">--disable-amf</span> \\ </span><br><span class=\"line\"><span class=\"literal\">--disable-iconv</span> \\ </span><br><span class=\"line\"><span class=\"literal\">--disable-libxcb</span> \\ </span><br><span class=\"line\"><span class=\"literal\">--disable-libxcb-shm</span> \\ </span><br><span class=\"line\"><span class=\"literal\">--disable-libxcb-xfixes</span> \\ </span><br><span class=\"line\"><span class=\"literal\">--disable-libxcb-shape</span> \\ </span><br><span class=\"line\"><span class=\"literal\">--disable-lzma</span> \\ </span><br><span class=\"line\"><span class=\"literal\">--disable-sdl2</span> \\ </span><br><span class=\"line\"><span class=\"literal\">--disable-securetransport</span> \\ </span><br><span class=\"line\"><span class=\"literal\">--disable-xlib</span> \\ </span><br><span class=\"line\"><span class=\"literal\">--disable-zlib</span> \\ </span><br><span class=\"line\"><span class=\"literal\">--disable-programs</span> \\ </span><br><span class=\"line\"><span class=\"literal\">--disable-ffmpeg</span> \\ </span><br><span class=\"line\"><span class=\"literal\">--disable-ffplay</span> \\ </span><br><span class=\"line\"><span class=\"literal\">--disable-ffprobe</span> \\ </span><br><span class=\"line\"><span class=\"literal\">--disable-avdevice</span> \\ </span><br><span class=\"line\"><span class=\"literal\">--disable-symver</span> \\ </span><br><span class=\"line\"><span class=\"literal\">--cross-prefix</span>=<span class=\"variable\">$CROSS_PREFIX</span> \\ </span><br><span class=\"line\"><span class=\"literal\">--target-os</span>=android \\ </span><br><span class=\"line\"><span class=\"literal\">--arch</span>=<span class=\"variable\">$ARCH</span> \\ </span><br><span class=\"line\"><span class=\"literal\">--cpu</span>=<span class=\"variable\">$CPU</span> \\ </span><br><span class=\"line\"><span class=\"literal\">--cc</span>=<span class=\"variable\">$CC</span> \\ </span><br><span class=\"line\"><span class=\"literal\">--cxx</span>=<span class=\"variable\">$CXX</span> \\ </span><br><span class=\"line\"><span class=\"literal\">--enable-cross-compile</span> \\ </span><br><span class=\"line\"><span class=\"literal\">--sysroot</span>=<span class=\"variable\">$SYSROOT</span> \\ </span><br><span class=\"line\"><span class=\"literal\">--extra-cflags</span>=<span class=\"string\">&quot;-Os -fpic <span class=\"variable\">$OPTIMIZE_CFLAGS</span>&quot;</span> \\ </span><br><span class=\"line\"><span class=\"literal\">--extra-ldflags</span>=<span class=\"string\">&quot;<span class=\"variable\">$ADDI_LDFLAGS</span>&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">make clean</span><br><span class=\"line\">make <span class=\"literal\">-j16</span></span><br><span class=\"line\">make install</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#arm64-v8a</span></span><br><span class=\"line\">ARCH=arm64</span><br><span class=\"line\">CPU=armv8<span class=\"literal\">-a</span></span><br><span class=\"line\">API=<span class=\"number\">21</span></span><br><span class=\"line\">CC=<span class=\"variable\">$TOOLCHAIN</span>/bin/aarch64<span class=\"literal\">-linux-android</span><span class=\"variable\">$API</span><span class=\"literal\">-clang</span></span><br><span class=\"line\">CXX=<span class=\"variable\">$TOOLCHAIN</span>/bin/aarch64<span class=\"literal\">-linux-android</span><span class=\"variable\">$API</span><span class=\"literal\">-clang</span>++</span><br><span class=\"line\">SYSROOT=<span class=\"variable\">$NDK</span>/toolchains/llvm/prebuilt/linux<span class=\"literal\">-x86_64</span>/sysroot</span><br><span class=\"line\">CROSS_PREFIX=<span class=\"variable\">$TOOLCHAIN</span>/bin/aarch64<span class=\"literal\">-linux-android-</span></span><br><span class=\"line\">PREFIX=<span class=\"variable\">$</span>(<span class=\"built_in\">pwd</span>)/android/<span class=\"variable\">$CPU</span></span><br><span class=\"line\">OPTIMIZE_CFLAGS=<span class=\"string\">&quot;-march=<span class=\"variable\">$CPU</span>&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">build_android</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#armv7-a</span></span><br><span class=\"line\">ARCH=arm</span><br><span class=\"line\">CPU=armv7<span class=\"literal\">-a</span></span><br><span class=\"line\">API=<span class=\"number\">21</span></span><br><span class=\"line\">CC=<span class=\"variable\">$TOOLCHAIN</span>/bin/armv7a<span class=\"literal\">-linux-androideabi</span><span class=\"variable\">$API</span><span class=\"literal\">-clang</span></span><br><span class=\"line\">CXX=<span class=\"variable\">$TOOLCHAIN</span>/bin/armv7a<span class=\"literal\">-linux-androideabi</span><span class=\"variable\">$API</span><span class=\"literal\">-clang</span>++</span><br><span class=\"line\">SYSROOT=<span class=\"variable\">$NDK</span>/toolchains/llvm/prebuilt/linux<span class=\"literal\">-x86_64</span>/sysroot</span><br><span class=\"line\">CROSS_PREFIX=<span class=\"variable\">$TOOLCHAIN</span>/bin/arm<span class=\"literal\">-linux-androideabi-</span></span><br><span class=\"line\">PREFIX=<span class=\"variable\">$</span>(<span class=\"built_in\">pwd</span>)/android/<span class=\"variable\">$CPU</span></span><br><span class=\"line\">OPTIMIZE_CFLAGS=<span class=\"string\">&quot;-mfloat-abi=softfp -mfpu=vfp -marm -march=<span class=\"variable\">$CPU</span> &quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">build_android</span><br></pre></td></tr></table></figure>\n<h2 id=\"配置介绍\"><a href=\"#配置介绍\" class=\"headerlink\" title=\"配置介绍\"></a>配置介绍</h2><p>通过执行 <code>./configure --help</code> 能得到所有的配置选项，整个配置也非常好理解，通过 list-xxx 可以知道有哪些子选项，然后再通过 <code>--disable-xxx</code>,或者 <code>--enable-xxx</code> 进行关闭或者打开。以解码为例：</p>\n<figure class=\"highlight powershell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"literal\">--disable-decoders</span>       <span class=\"comment\"># 先关闭所有的解码器</span></span><br><span class=\"line\"><span class=\"literal\">--enable-decoder</span>=flv     <span class=\"comment\"># 然后只打开flv、mpeg4 的支持</span></span><br><span class=\"line\"><span class=\"literal\">--enable-decoder</span>=mpeg4 </span><br></pre></td></tr></table></figure>\n<p>对于<code>--enable-decoder=xxx</code>中的xxx可以通过 <code>./configure --list-decoders</code> 进行查看，同理 <code>encoders</code> <code>demuxers</code> <code>muxers</code> 等都是类似的处理，通过 <code>--help</code> 可以通过 <code>list--xxx</code> 查看不同功能的可以支持的配置，主要有以下：</p>\n<figure class=\"highlight powershell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"literal\">--list-decoders</span>          show all available decoders</span><br><span class=\"line\"><span class=\"literal\">--list-encoders</span>          show all available encoders</span><br><span class=\"line\"><span class=\"literal\">--list-hwaccels</span>          show all available hardware accelerators</span><br><span class=\"line\"><span class=\"literal\">--list-demuxers</span>          show all available demuxers</span><br><span class=\"line\"><span class=\"literal\">--list-muxers</span>            show all available muxers</span><br><span class=\"line\"><span class=\"literal\">--list-parsers</span>           show all available parsers</span><br><span class=\"line\"><span class=\"literal\">--list-protocols</span>         show all available protocols</span><br><span class=\"line\"><span class=\"literal\">--list-bsfs</span>              show all available bitstream filters</span><br><span class=\"line\"><span class=\"literal\">--list-indevs</span>            show all available input devices</span><br><span class=\"line\"><span class=\"literal\">--list-outdevs</span>           show all available output devices</span><br><span class=\"line\"><span class=\"literal\">--list-filters</span>           show all available filters</span><br></pre></td></tr></table></figure>\n<p>其他的配置就是一些实际性的开关配置，列一些常用的配置：</p>\n<p>配置产物为静态库(.a)或者动态库(.so)</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">--enable-static         do not build static libraries [no]</span><br><span class=\"line\">--enable-shared         build shared libraries [no]</span><br></pre></td></tr></table></figure>\n<p>配置减少包大小<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">--enable-small           optimize for size instead of speed</span><br></pre></td></tr></table></figure></p>\n<p><code>--enable-small</code> 的配置项，其实是在config.h里声称了CONFIG_SMALL选项，然后代码内根据CONFIG_SMALL做了一些调整，比如某些string类型就被省掉了，还有一些内置生成的table, 体积也被裁减掉了，用速度换体积。比如这里：<br><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">if</span> CONFIG_SMALL</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> CRC_TABLE_SIZE 257</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">else</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> CRC_TABLE_SIZE 1024</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span></span></span><br></pre></td></tr></table></figure></p>\n<p>配置FFmpeg协议，由于我们使用本地文件，需要再加一个： <code>--enable-protocol=file</code>，要不然解码会报协议相关错误</p>\n<figure class=\"highlight powershell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"literal\">--disable-protocols</span>      disable all protocols</span><br></pre></td></tr></table></figure>\n<p>我们只需要在代码中使用 FFmpeg，所以直接禁用命令行工具<br><figure class=\"highlight powershell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"literal\">--disable-programs</span>       <span class=\"keyword\">do</span> not build command line programs</span><br><span class=\"line\"><span class=\"literal\">--disable-ffmpeg</span>         disable ffmpeg build</span><br><span class=\"line\"><span class=\"literal\">--disable-ffplay</span>         disable ffplay build</span><br><span class=\"line\"><span class=\"literal\">--disable-ffprobe</span>        disable ffprobe build</span><br></pre></td></tr></table></figure></p>\n<p>还有几个比较重要的就是，主要是<br><figure class=\"highlight powershell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"literal\">--disable-avdevice</span>       disable libavdevice build</span><br><span class=\"line\"><span class=\"literal\">--disable-swresample</span>     disable libswresample build</span><br><span class=\"line\"><span class=\"literal\">--disable-swscale</span>        disable libswscale build</span><br><span class=\"line\"><span class=\"literal\">--disable-postproc</span>       disable libpostproc build</span><br><span class=\"line\"><span class=\"literal\">--disable-avfilter</span>       disable libavfilter build</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"编译遇见的坑\"><a href=\"#编译遇见的坑\" class=\"headerlink\" title=\"编译遇见的坑\"></a>编译遇见的坑</h2><p><strong>1、aarch64-linux-android21-clang is unable to create an executable file.<br>C compiler test failed.</strong></p>\n<p>这个问题是困扰我最久的，按照解决方法：<br>原因 1： FFmpeg 4.2.2 版本默认使用了 clang 进行编译<br>解决：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">//1\\. 修改 configure 文件</span><br><span class=\"line\">vim configure</span><br><span class=\"line\">//2\\. 把 默认的 clang 修改为 gcc</span><br><span class=\"line\">if test &quot;$target_os&quot; = android; then</span><br><span class=\"line\">   # cc_default=&quot;clang&quot;</span><br><span class=\"line\">\t\t cc_default=&quot;gcc&quot;</span><br><span class=\"line\">fi</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>原因2，检查路径是否正确，主要是 NDK 的位置，以及不同 NDK 相关库可能存在一定的丢失。</p>\n<p>这个问题我在 macOS 上未解决，<strong>换用 CentOS 没有出现过这个编译问题</strong>。</p>\n<p><strong>2、 编译包大小一直不变</strong></p>\n<p>最开始我正常编译的时候发现怎么改配置，最后的包大小都没有发生变化，但是命令行里面各种流程又是在走，最终也有产物。这里一定要关注在执行了编译脚本之后，查看最开始的日志，看看具体是一些什么错，这里日志会刷得很快，如果包大小一直没有发生变化的话，可以执行完之后快速停止，看看是什么错。一般就是<code>C compiler test failed.</code> 或者找不到你的配置，改对即可。正常编译，会在开始后列出你的编译配置。</p>\n<p><strong>3、x86asm 相关的问题</strong></p>\n<p>编译的时候遇到一些 x86asm 的错，按照文章所说即可</p>\n","categories":[],"tags":[{"name":"FFmpeg","slug":"FFmpeg","api":"api/tags/FFmpeg.json"}],"api":"api/posts/2023/01/09/FFmpeg-so-编译整理.json"},{"title":"3D LUT 滤镜 shader 源码分析","slug":"LUT-Shader-源码分析","date":"2022-11-24T03:36:00.000Z","updated":"2025-09-15T13:11:04.747Z","comments":true,"url":"2022/11/24/LUT-Shader-源码分析/","excerpt":"<p>最近在做滤镜相关的渲染学习，目前大部分 LUT 滤镜代码实现都是参考由 GPUImage 提供的 LookupFilter 的逻辑，整个代码实现不多。参考网上的博文也有各种解释，参考了大量博文之后终于理解了，所以自己重新整理了一份，方便以后阅读理解，对整体代码的实现过程结合LUT的原理进行一个简单整理。</p>\n<h2 id=\"GPUImageLookupFilter-shader-源码\"><a href=\"#GPUImageLookupFilter-shader-源码\" class=\"headerlink\" title=\"GPUImageLookupFilter shader 源码\"></a>GPUImageLookupFilter shader 源码</h2><figure class=\"highlight glsl\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">varying</span> <span class=\"keyword\">highp</span> <span class=\"type\">vec2</span> textureCoordinate;      </span><br><span class=\"line\"><span class=\"keyword\">varying</span> <span class=\"keyword\">highp</span> <span class=\"type\">vec2</span> textureCoordinate2;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">uniform</span> <span class=\"type\">sampler2D</span> inputImageTexture;  <span class=\"comment\">// 目标纹理，对应原始资源</span></span><br><span class=\"line\"><span class=\"keyword\">uniform</span> <span class=\"type\">sampler2D</span> inputImageTexture2; <span class=\"comment\">// 查找表纹理，对应LUT图片</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">uniform</span> <span class=\"keyword\">lowp</span> <span class=\"type\">float</span> intensity;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> main()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">//获取原始图层颜色</span></span><br><span class=\"line\">    <span class=\"keyword\">highp</span> <span class=\"type\">vec4</span> textureColor = <span class=\"built_in\">texture2D</span>(inputImageTexture, textureCoordinate);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//获取蓝色通道颜色，textureColor.b 的范围为(0,1)，blueColor 范围为(0,63) </span></span><br><span class=\"line\">    <span class=\"keyword\">highp</span> <span class=\"type\">float</span> blueColor = textureColor.b * <span class=\"number\">63.0</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//quad1为查找颜色所在左边位置的小正方形</span></span><br><span class=\"line\">    <span class=\"keyword\">highp</span> <span class=\"type\">vec2</span> quad1;</span><br><span class=\"line\">    quad1.y = <span class=\"built_in\">floor</span>(<span class=\"built_in\">floor</span>(blueColor) / <span class=\"number\">8.0</span>);</span><br><span class=\"line\">    quad1.x = <span class=\"built_in\">floor</span>(blueColor) - (quad1.y * <span class=\"number\">8.0</span>);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//quad2为查找颜色所在右边位置的小正方形</span></span><br><span class=\"line\">    <span class=\"keyword\">highp</span> <span class=\"type\">vec2</span> quad2;</span><br><span class=\"line\">    quad2.y = <span class=\"built_in\">floor</span>(<span class=\"built_in\">ceil</span>(blueColor) / <span class=\"number\">8.0</span>);</span><br><span class=\"line\">    quad2.x = <span class=\"built_in\">ceil</span>(blueColor) - (quad2.y * <span class=\"number\">8.0</span>);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//获取到左边小方形里面的颜色值</span></span><br><span class=\"line\">    <span class=\"keyword\">highp</span> <span class=\"type\">vec2</span> texPos1;</span><br><span class=\"line\">    texPos1.x = (quad1.x * <span class=\"number\">0.125</span>) + <span class=\"number\">0.5</span>/<span class=\"number\">512.0</span> + ((<span class=\"number\">0.125</span> - <span class=\"number\">1.0</span>/<span class=\"number\">512.0</span>) * textureColor.r);</span><br><span class=\"line\">    texPos1.y = (quad1.y * <span class=\"number\">0.125</span>) + <span class=\"number\">0.5</span>/<span class=\"number\">512.0</span> + ((<span class=\"number\">0.125</span> - <span class=\"number\">1.0</span>/<span class=\"number\">512.0</span>) * textureColor.g);</span><br><span class=\"line\">    </span><br><span class=\"line\">   <span class=\"comment\">//获取到右边小方形里面的颜色值</span></span><br><span class=\"line\">    <span class=\"keyword\">highp</span> <span class=\"type\">vec2</span> texPos2;</span><br><span class=\"line\">    texPos2.x = (quad2.x * <span class=\"number\">0.125</span>) + <span class=\"number\">0.5</span>/<span class=\"number\">512.0</span> + ((<span class=\"number\">0.125</span> - <span class=\"number\">1.0</span>/<span class=\"number\">512.0</span>) * textureColor.r);</span><br><span class=\"line\">    texPos2.y = (quad2.y * <span class=\"number\">0.125</span>) + <span class=\"number\">0.5</span>/<span class=\"number\">512.0</span> + ((<span class=\"number\">0.125</span> - <span class=\"number\">1.0</span>/<span class=\"number\">512.0</span>) * textureColor.g);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//获取对应位置纹理的颜色 RGBA 值</span></span><br><span class=\"line\">    <span class=\"keyword\">lowp</span> <span class=\"type\">vec4</span> newColor1 = <span class=\"built_in\">texture2D</span>(inputImageTexture2, texPos1);</span><br><span class=\"line\">    <span class=\"keyword\">lowp</span> <span class=\"type\">vec4</span> newColor2 = <span class=\"built_in\">texture2D</span>(inputImageTexture2, texPos2);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//真正的颜色是 newColor1 和 newColor2 的混合</span></span><br><span class=\"line\">    <span class=\"keyword\">lowp</span> <span class=\"type\">vec4</span> newColor = <span class=\"built_in\">mix</span>(newColor1, newColor2, <span class=\"built_in\">fract</span>(blueColor));</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">gl_FragColor</span> = <span class=\"built_in\">mix</span>(textureColor, <span class=\"type\">vec4</span>(newColor.rgb, textureColor.w), intensity);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>整个源码的主要逻辑为：<strong>查找颜色所在位置的小正方形、查找小正方形内的具体颜色、颜色混合</strong>。上面注释已将具体的实现过程描述清楚，但与我们的 LUT 图片割裂，接下来结合 LUT 的实现原理以及具体的数据来形象地描述整个实现流程。</p>\n<p>假设我们输入的参数为：<br>textureColor = ver4(.0, .0, 0.5, 1.0)</p>\n<h2 id=\"查找颜色所在位置的小正方形\"><a href=\"#查找颜色所在位置的小正方形\" class=\"headerlink\" title=\"查找颜色所在位置的小正方形\"></a>查找颜色所在位置的小正方形</h2><p>我们知道LUT有64个小正方形，目标是为了找到对应小正方形里面的对应的颜色，我们需要先确认是第几个小正方形，正是通过 textureColor.b * 63 查找</p>\n<p>带入<code>blueColor</code> -&gt; textureColor.b = 0.5<br>对 <code>textureColor.b * 63.0</code> = 31.5</p>\n<p>也就是说我们需要第 [31.5] 位置小正方形，但是索引(从0-63共64个)都是正数，对于 31.5 索引 我们该怎么确定是 31 还是第 32 个呢？GPUImage给出的一种插值方式就是两个都要，然后进行一次混合，从而使得值能够俊均匀的在两个小正方形色块中。</p>\n<p>具体逻辑为：</p>\n<p>quad1.y = floor(floor(blueColor) / 8.0) = 3，确定为小方块在纵坐标索引3，也就是第4行。</p>\n<img src=\"https://cdn.julis.wang/blog/img/f2e1e14bc30c4e438664b90fa5ad8103.png?imageView2/2/w/500\">\n<p><code>quad1.x = floor(blueColor) - (quad1.y * 8.0) = 31 - 24 = 7</code></p>\n<p>也就确定了小方块为(3,7) 也就是第4排第8个。</p>\n<img src=\"https://cdn.julis.wang/blog/img/bc8a47389a654dbeb5e4fc5e5584d1f9.png?imageView2/2/w/500\">\n<p>同理，对于第2个小方块确定的位置为(4,0) 也就是第5排第1个。</p>\n<p> <code>quad2.y = floor(ceil(blueColor) / 8.0) = 4</code></p>\n<p> <code>quad2.x = ceil(blueColor) - (quad2.y * 8.0)= 0</code></p>\n<h2 id=\"查找小正方形内的具体颜色\"><a href=\"#查找小正方形内的具体颜色\" class=\"headerlink\" title=\"查找小正方形内的具体颜色\"></a>查找小正方形内的具体颜色</h2><p>已经获取到对应的方块了，接下来需要确定方块内的像素的位置了。一般一个LUT的大小为 512x512，由8x8小方块构成，也就是每个方块的的像素为64x64，如下图所示：</p>\n<img src=\"https://cdn.julis.wang/blog/img/a4d6f390dd7b41fab75b568b37fb1e08.png?imageView2/2/w/500\">\n<p>计算x坐标的逻辑为：</p>\n<p><code>texPos1.x = (quad1.x * 0.125) + 0.5/512.0 + ((0.125 - 1.0/512.0) * textureColor.r)</code></p>\n<p>这一段是相对比较难理解的，我们可以分几部分进行理解：</p>\n<p>第一部分：<strong>(quad1.x * 0.125)</strong></p>\n<p>  我们得到 quad1.x = 7，也就是第8列，*0.125将坐标转化在(0,1)之间，也就是得到在01坐标系内如图红线的位置。</p>\n<img src=\"https://cdn.julis.wang/blog/img/56098332877d4724beae4000c4fdf5fa.png?imageView2/2/w/500\">\n<p>第二部分：<strong>((0.125 - 1.0/512.0) * textureColor.r)</strong></p>\n<p>我们可以把它当成 <code>(63.0/512.0)* textureColor.r</code> , <code>63.0/512.0</code>代表着一个512x512中每个小方块的64份数据（为什么是63？别忘了0的存在），textureColor.r 数据在 0-1之间，这样就能确认在第一部分结果基础之上的偏移值。</p>\n<img src=\"https://cdn.julis.wang/blog/img/7b3cba46937a4be4b0e45bc3077d3aad.png?imageView2/2/w/500\">\n<p>第三部分：<strong>0.5/512.0</strong></p>\n<p>这一部分主要是 +0.5 做四舍五入运算，为保证第512行取到的是511.5/512，第1行取到的是 0.5/512.0。</p>\n<p>同理，计算y的坐标，以及计算另一个小正方形内的位置是一样的。</p>\n<p>最后在通过对从两个小正方形获取到的颜色进行 mix，并返回给着色器，GPU再对原始图像进行每一个像素点绘制，从而实现滤镜的效果。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>LUT 对应的 Shader 执行过程主要为：<strong>查找颜色所在位置的小正方形、查找小正方形内的具体颜色、颜色混合</strong>，整个流程都比较好理解，但代码相对而言比较难理解，网上看了很多其他的大佬写的一些文章，最开始自己看的时候也是很难理解的，后面终于悟了，所以想通过自己的理解，尽力更形象地解释（虽然可能也没有很形象），如果还有什么疑问，欢迎一起交流学习。</p>\n","cover":null,"images":["https://cdn.julis.wang/blog/img/f2e1e14bc30c4e438664b90fa5ad8103.png?imageView2/2/w/500","https://cdn.julis.wang/blog/img/bc8a47389a654dbeb5e4fc5e5584d1f9.png?imageView2/2/w/500","https://cdn.julis.wang/blog/img/a4d6f390dd7b41fab75b568b37fb1e08.png?imageView2/2/w/500","https://cdn.julis.wang/blog/img/56098332877d4724beae4000c4fdf5fa.png?imageView2/2/w/500","https://cdn.julis.wang/blog/img/7b3cba46937a4be4b0e45bc3077d3aad.png?imageView2/2/w/500"],"content":"<p>最近在做滤镜相关的渲染学习，目前大部分 LUT 滤镜代码实现都是参考由 GPUImage 提供的 LookupFilter 的逻辑，整个代码实现不多。参考网上的博文也有各种解释，参考了大量博文之后终于理解了，所以自己重新整理了一份，方便以后阅读理解，对整体代码的实现过程结合LUT的原理进行一个简单整理。</p>\n<h2 id=\"GPUImageLookupFilter-shader-源码\"><a href=\"#GPUImageLookupFilter-shader-源码\" class=\"headerlink\" title=\"GPUImageLookupFilter shader 源码\"></a>GPUImageLookupFilter shader 源码</h2><figure class=\"highlight glsl\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">varying</span> <span class=\"keyword\">highp</span> <span class=\"type\">vec2</span> textureCoordinate;      </span><br><span class=\"line\"><span class=\"keyword\">varying</span> <span class=\"keyword\">highp</span> <span class=\"type\">vec2</span> textureCoordinate2;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">uniform</span> <span class=\"type\">sampler2D</span> inputImageTexture;  <span class=\"comment\">// 目标纹理，对应原始资源</span></span><br><span class=\"line\"><span class=\"keyword\">uniform</span> <span class=\"type\">sampler2D</span> inputImageTexture2; <span class=\"comment\">// 查找表纹理，对应LUT图片</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">uniform</span> <span class=\"keyword\">lowp</span> <span class=\"type\">float</span> intensity;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> main()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">//获取原始图层颜色</span></span><br><span class=\"line\">    <span class=\"keyword\">highp</span> <span class=\"type\">vec4</span> textureColor = <span class=\"built_in\">texture2D</span>(inputImageTexture, textureCoordinate);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//获取蓝色通道颜色，textureColor.b 的范围为(0,1)，blueColor 范围为(0,63) </span></span><br><span class=\"line\">    <span class=\"keyword\">highp</span> <span class=\"type\">float</span> blueColor = textureColor.b * <span class=\"number\">63.0</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//quad1为查找颜色所在左边位置的小正方形</span></span><br><span class=\"line\">    <span class=\"keyword\">highp</span> <span class=\"type\">vec2</span> quad1;</span><br><span class=\"line\">    quad1.y = <span class=\"built_in\">floor</span>(<span class=\"built_in\">floor</span>(blueColor) / <span class=\"number\">8.0</span>);</span><br><span class=\"line\">    quad1.x = <span class=\"built_in\">floor</span>(blueColor) - (quad1.y * <span class=\"number\">8.0</span>);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//quad2为查找颜色所在右边位置的小正方形</span></span><br><span class=\"line\">    <span class=\"keyword\">highp</span> <span class=\"type\">vec2</span> quad2;</span><br><span class=\"line\">    quad2.y = <span class=\"built_in\">floor</span>(<span class=\"built_in\">ceil</span>(blueColor) / <span class=\"number\">8.0</span>);</span><br><span class=\"line\">    quad2.x = <span class=\"built_in\">ceil</span>(blueColor) - (quad2.y * <span class=\"number\">8.0</span>);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//获取到左边小方形里面的颜色值</span></span><br><span class=\"line\">    <span class=\"keyword\">highp</span> <span class=\"type\">vec2</span> texPos1;</span><br><span class=\"line\">    texPos1.x = (quad1.x * <span class=\"number\">0.125</span>) + <span class=\"number\">0.5</span>/<span class=\"number\">512.0</span> + ((<span class=\"number\">0.125</span> - <span class=\"number\">1.0</span>/<span class=\"number\">512.0</span>) * textureColor.r);</span><br><span class=\"line\">    texPos1.y = (quad1.y * <span class=\"number\">0.125</span>) + <span class=\"number\">0.5</span>/<span class=\"number\">512.0</span> + ((<span class=\"number\">0.125</span> - <span class=\"number\">1.0</span>/<span class=\"number\">512.0</span>) * textureColor.g);</span><br><span class=\"line\">    </span><br><span class=\"line\">   <span class=\"comment\">//获取到右边小方形里面的颜色值</span></span><br><span class=\"line\">    <span class=\"keyword\">highp</span> <span class=\"type\">vec2</span> texPos2;</span><br><span class=\"line\">    texPos2.x = (quad2.x * <span class=\"number\">0.125</span>) + <span class=\"number\">0.5</span>/<span class=\"number\">512.0</span> + ((<span class=\"number\">0.125</span> - <span class=\"number\">1.0</span>/<span class=\"number\">512.0</span>) * textureColor.r);</span><br><span class=\"line\">    texPos2.y = (quad2.y * <span class=\"number\">0.125</span>) + <span class=\"number\">0.5</span>/<span class=\"number\">512.0</span> + ((<span class=\"number\">0.125</span> - <span class=\"number\">1.0</span>/<span class=\"number\">512.0</span>) * textureColor.g);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//获取对应位置纹理的颜色 RGBA 值</span></span><br><span class=\"line\">    <span class=\"keyword\">lowp</span> <span class=\"type\">vec4</span> newColor1 = <span class=\"built_in\">texture2D</span>(inputImageTexture2, texPos1);</span><br><span class=\"line\">    <span class=\"keyword\">lowp</span> <span class=\"type\">vec4</span> newColor2 = <span class=\"built_in\">texture2D</span>(inputImageTexture2, texPos2);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//真正的颜色是 newColor1 和 newColor2 的混合</span></span><br><span class=\"line\">    <span class=\"keyword\">lowp</span> <span class=\"type\">vec4</span> newColor = <span class=\"built_in\">mix</span>(newColor1, newColor2, <span class=\"built_in\">fract</span>(blueColor));</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">gl_FragColor</span> = <span class=\"built_in\">mix</span>(textureColor, <span class=\"type\">vec4</span>(newColor.rgb, textureColor.w), intensity);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>整个源码的主要逻辑为：<strong>查找颜色所在位置的小正方形、查找小正方形内的具体颜色、颜色混合</strong>。上面注释已将具体的实现过程描述清楚，但与我们的 LUT 图片割裂，接下来结合 LUT 的实现原理以及具体的数据来形象地描述整个实现流程。</p>\n<p>假设我们输入的参数为：<br>textureColor = ver4(.0, .0, 0.5, 1.0)</p>\n<h2 id=\"查找颜色所在位置的小正方形\"><a href=\"#查找颜色所在位置的小正方形\" class=\"headerlink\" title=\"查找颜色所在位置的小正方形\"></a>查找颜色所在位置的小正方形</h2><p>我们知道LUT有64个小正方形，目标是为了找到对应小正方形里面的对应的颜色，我们需要先确认是第几个小正方形，正是通过 textureColor.b * 63 查找</p>\n<p>带入<code>blueColor</code> -&gt; textureColor.b = 0.5<br>对 <code>textureColor.b * 63.0</code> = 31.5</p>\n<p>也就是说我们需要第 [31.5] 位置小正方形，但是索引(从0-63共64个)都是正数，对于 31.5 索引 我们该怎么确定是 31 还是第 32 个呢？GPUImage给出的一种插值方式就是两个都要，然后进行一次混合，从而使得值能够俊均匀的在两个小正方形色块中。</p>\n<p>具体逻辑为：</p>\n<p>quad1.y = floor(floor(blueColor) / 8.0) = 3，确定为小方块在纵坐标索引3，也就是第4行。</p>\n<img src=\"https://cdn.julis.wang/blog/img/f2e1e14bc30c4e438664b90fa5ad8103.png?imageView2/2/w/500\">\n<p><code>quad1.x = floor(blueColor) - (quad1.y * 8.0) = 31 - 24 = 7</code></p>\n<p>也就确定了小方块为(3,7) 也就是第4排第8个。</p>\n<img src=\"https://cdn.julis.wang/blog/img/bc8a47389a654dbeb5e4fc5e5584d1f9.png?imageView2/2/w/500\">\n<p>同理，对于第2个小方块确定的位置为(4,0) 也就是第5排第1个。</p>\n<p> <code>quad2.y = floor(ceil(blueColor) / 8.0) = 4</code></p>\n<p> <code>quad2.x = ceil(blueColor) - (quad2.y * 8.0)= 0</code></p>\n<h2 id=\"查找小正方形内的具体颜色\"><a href=\"#查找小正方形内的具体颜色\" class=\"headerlink\" title=\"查找小正方形内的具体颜色\"></a>查找小正方形内的具体颜色</h2><p>已经获取到对应的方块了，接下来需要确定方块内的像素的位置了。一般一个LUT的大小为 512x512，由8x8小方块构成，也就是每个方块的的像素为64x64，如下图所示：</p>\n<img src=\"https://cdn.julis.wang/blog/img/a4d6f390dd7b41fab75b568b37fb1e08.png?imageView2/2/w/500\">\n<p>计算x坐标的逻辑为：</p>\n<p><code>texPos1.x = (quad1.x * 0.125) + 0.5/512.0 + ((0.125 - 1.0/512.0) * textureColor.r)</code></p>\n<p>这一段是相对比较难理解的，我们可以分几部分进行理解：</p>\n<p>第一部分：<strong>(quad1.x * 0.125)</strong></p>\n<p>  我们得到 quad1.x = 7，也就是第8列，*0.125将坐标转化在(0,1)之间，也就是得到在01坐标系内如图红线的位置。</p>\n<img src=\"https://cdn.julis.wang/blog/img/56098332877d4724beae4000c4fdf5fa.png?imageView2/2/w/500\">\n<p>第二部分：<strong>((0.125 - 1.0/512.0) * textureColor.r)</strong></p>\n<p>我们可以把它当成 <code>(63.0/512.0)* textureColor.r</code> , <code>63.0/512.0</code>代表着一个512x512中每个小方块的64份数据（为什么是63？别忘了0的存在），textureColor.r 数据在 0-1之间，这样就能确认在第一部分结果基础之上的偏移值。</p>\n<img src=\"https://cdn.julis.wang/blog/img/7b3cba46937a4be4b0e45bc3077d3aad.png?imageView2/2/w/500\">\n<p>第三部分：<strong>0.5/512.0</strong></p>\n<p>这一部分主要是 +0.5 做四舍五入运算，为保证第512行取到的是511.5/512，第1行取到的是 0.5/512.0。</p>\n<p>同理，计算y的坐标，以及计算另一个小正方形内的位置是一样的。</p>\n<p>最后在通过对从两个小正方形获取到的颜色进行 mix，并返回给着色器，GPU再对原始图像进行每一个像素点绘制，从而实现滤镜的效果。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>LUT 对应的 Shader 执行过程主要为：<strong>查找颜色所在位置的小正方形、查找小正方形内的具体颜色、颜色混合</strong>，整个流程都比较好理解，但代码相对而言比较难理解，网上看了很多其他的大佬写的一些文章，最开始自己看的时候也是很难理解的，后面终于悟了，所以想通过自己的理解，尽力更形象地解释（虽然可能也没有很形象），如果还有什么疑问，欢迎一起交流学习。</p>\n","categories":[{"name":"技术文章","slug":"technology","api":"api/categories/technology.json"}],"tags":[{"name":"音视频","slug":"音视频","api":"api/tags/音视频.json"}],"api":"api/posts/2022/11/24/LUT-Shader-源码分析.json"},{"title":"Unity 实现利用 Andorid 能力进行视频渲染播放","slug":"Unity-实现利用-Andorid-能力进行视频渲染播放","date":"2022-10-25T02:00:00.000Z","updated":"2025-09-15T13:10:48.829Z","comments":true,"url":"2022/10/25/Unity-实现利用-Andorid-能力进行视频渲染播放/","excerpt":"<p>在 Unity 中使用 Android 侧提供的视频渲染相关的能力，有两种方案可选：</p>\n<p>第一种是将渲染播放页单独做一个页面，在 Unity事件交互的时候打开对应 Activity 页面，或者获取到 Unity 创建的 Acitivity 动态添加 View。</p>\n<p>第二种是只借助 Android 的渲染能力，将数据渲染到 Unity 的控件上。</p>\n<p>两种方案各有优劣，第一种大大地减少了播放器相关的开发工作量，整个页面逻辑可以实现复用，但是交互页面的话 iOS/Android 需要写两套。第二种实现成本相对较高，但是交互可以由 Unity 侧进行，只是播放器使用封装好的 plugin 进行，能达到交互相对较统一，本文也主要是讲述该方案的实现。</p>\n<h2 id=\"Android-平台基本播放逻辑\"><a href=\"#Android-平台基本播放逻辑\" class=\"headerlink\" title=\"Android 平台基本播放逻辑\"></a>Android 平台基本播放逻辑</h2><p>在正式开发改造之前，对 Android 侧的一个播放器渲染流程进行简单的介绍，以 MediaPlayer 为例，利用 MediaPlayer 进行视频解码渲染，并将视频最后输出到 SurfaceView 上,一次播放器视频渲染到View上的的主要代码流程为：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">initPlayer</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">MediaPlayer</span> <span class=\"variable\">mediaPlayer</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">MediaPlayer</span>();</span><br><span class=\"line\">    <span class=\"type\">SurfaceView</span> <span class=\"variable\">surfaceView</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">SurfaceView</span>(activity);</span><br><span class=\"line\">    surfaceHolder = surfaceView.getHolder();</span><br><span class=\"line\">    surfaceHolder.addCallback(^ &#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">surfaceCreated</span><span class=\"params\">(SurfaceHolder holder)</span> &#123;</span><br><span class=\"line\">            <span class=\"type\">Surface</span> <span class=\"variable\">surface</span> <span class=\"operator\">=</span> holder.getSurface();</span><br><span class=\"line\">            mediaPlayer.setSurface(surface);</span><br><span class=\"line\">            mediaPlayer.prepareAsync();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">         ……</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    mediaPlayer.setDataSource(URI...);</span><br><span class=\"line\">    mediaPlayer.setOnPreparedListener(mp -&gt; mp.start());   </span><br><span class=\"line\">&#125;  </span><br></pre></td></tr></table></figure>\n<p>对于渲染 <code>mediaPlayer.setSurface(surface)</code> 设为播放器解码数据的接受器，Surface 来自于 SurfaceView。</p>\n<p>播放器是将数据图形绘制在 Surface 对象上，Surface中会关联一个 BufferQueue 用于提供图像数据缓存，SurfaceFlinger 会把 Surface 对应的图像层混合在一起，将其输出到 FrameBuffer 中（Framebuffer就是一块内存区域，它通常是显示驱动的内部缓冲区在内存中的映射），最后在屏幕上看到合成的图像。</p>\n<p>整个流程引入外部大佬的一张图所示：</p>\n<img src=\"https://cdn.julis.wang/blog/img/k3u1fbpfcp.jpg\">\n<h2 id=\"Unity-中的一些改造\"><a href=\"#Unity-中的一些改造\" class=\"headerlink\" title=\"Unity 中的一些改造\"></a>Unity 中的一些改造</h2><p>上面的流程最终是通过播放器解码渲染到 SurfaceView 上，当然，你可以通过获取到 UnityPlayer 对应的 Acitivity 将这个 SurfaceView 动态添加到当前界面，实现“在 Unity 中利用 Android 能力进行视频渲染”。</p>\n<p>所以需要对其进行改造，我们的目的是实现 Android 播放器数据渲染到 Untiy 的组件中。实现这一过程需要借助 FBO(Frame Buffer Object) 的能力。</p>\n<h3 id=\"（一）FBO\"><a href=\"#（一）FBO\" class=\"headerlink\" title=\"（一）FBO\"></a>（一）FBO</h3><p>在 OpenGL 渲染管线中几何数据和纹理经过变换和一些测试处理，最后以二维像素的形式显示在屏幕上。OpenGL管线的最终渲染目的地被称作帧缓存(framebuffer)，OpenGL渲染管线的最终位置是在帧缓冲区中，默认情况下 OpenGL 使用的是窗口系统提供的帧缓冲区。</p>\n<p>但有些场景是不想要直接渲染到窗口上的(例如加视频特效)，于是 OpenGL 提供了一种方式来创建额外的帧缓冲区对象(FBO)。使用帧缓冲区对象，OpenGL 可以将原先绘制到窗口提供的帧缓冲区重定向到 FBO 之中。FBO本身不是一块内存，没有空间，真正存储东西，可实际读写的是依附于FBO的东西：纹理(texture)和渲染缓存(renderbuffer)，依附的方式，是一个二维数组来管理，结构如图所示：</p>\n<p><img src=\"https://www.songho.ca/opengl/files/gl_fbo01.png?height=278&amp;width=380\" alt=\"\"></p>\n<h3 id=\"（二）具体实现\"><a href=\"#（二）具体实现\" class=\"headerlink\" title=\"（二）具体实现\"></a>（二）具体实现</h3><p>使用 FBO 我们可以将渲染目标渲染到其他的空间，我们目的是将播放器解码后的数据渲染到 Unity 控件的纹理空间中。<br>渲染播放器将输出到 FBO 中，FBO 指向 Unity 控件数据的输入，从而实现：Android 的播放器输出数据显示到 Unity 的控件中。</p>\n<h3 id=\"（三）从渲染输出数据到外部纹理\"><a href=\"#（三）从渲染输出数据到外部纹理\" class=\"headerlink\" title=\"（三）从渲染输出数据到外部纹理\"></a>（三）从渲染输出数据到外部纹理</h3><p>由于 <code>mediaPlayer.setSurface(surface)</code> 对应的 Surface 来源于 SurafaceView，会直接渲染到屏幕上，这里我们需要使用 构造一个新的 SurfaceTexture 以将图像流式传输到给定的 OpenGL 纹理;</p>\n<p>要获取到播放器渲染得数据，需要借助 SurfaceTexture ，SurfaceTexture 是Surface 和 OpenGL ES 纹理的结合，其对图像流的处理并不直接显示，而是从图像流中捕获帧作为 OpenGL 的外部纹理，图像流来自相机预览和视频解码。</p>\n<p>SurfaceTexture 创建的 Surface 是数据的生产者，而 SurfaceTexture 是对应的消费者，Surface 接收媒体数据并将数据发送到 SurfaceTexture，当调用 updateTexImage 的时候，创建SurfaceTexture 的纹理对象相应的内容将更新为最新图像帧，也就是会将图像帧转换为 GL 纹理，并将该纹理绑定到 GL_TEXTURE_EXTERNAL_OES 纹理对象上。具体实现逻辑参考：<a href=\"https://juejin.cn/post/7012517274768179236\">Android Opengl OES 纹理渲染到 GL_TEXTURE_2D</a></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">SurfaceTexture</span> <span class=\"variable\">surfaceTexture</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">SurfaceTexture</span>(videoTextureId);</span><br><span class=\"line\">player.setUpSurface(<span class=\"keyword\">new</span> <span class=\"title class_\">Surface</span>(surfaceTexture), width, height);</span><br><span class=\"line\">surfaceTexture.setDefaultBufferSize(width, height);</span><br><span class=\"line\">surfaceTexture.setOnFrameAvailableListener(surfaceTexture -&gt; &#123;……&#125;);;</span><br></pre></td></tr></table></figure>\n<p>其中 videoTextureId 来源于创建的 OES 纹理：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"type\">int</span> <span class=\"title function_\">createOESTextureID</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span>[] texture = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[<span class=\"number\">1</span>];</span><br><span class=\"line\">        <span class=\"comment\">// 创建纹理对象，一个容器对象，保存渲染所需要的纹理数据，例如：图像数据</span></span><br><span class=\"line\">        <span class=\"comment\">//在OpenGL 中纹理对象是一个无符号整数，是一个纹理对象的句柄</span></span><br><span class=\"line\">        GLES30.glGenTextures(texture.length, texture, <span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 绑定纹理ID到纹理单元的纹理目标上</span></span><br><span class=\"line\">        GLES30.glBindTexture(GLES11Ext.GL_TEXTURE_EXTERNAL_OES, texture[<span class=\"number\">0</span>]);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 设置纹理参数</span></span><br><span class=\"line\">        ……</span><br><span class=\"line\"></span><br><span class=\"line\">        GLES30.glGenerateMipmap(GLES11Ext.GL_TEXTURE_EXTERNAL_OES);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> texture[<span class=\"number\">0</span>];</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"（四）FBO纹理数据到-Unity-的纹理数据\"><a href=\"#（四）FBO纹理数据到-Unity-的纹理数据\" class=\"headerlink\" title=\"（四）FBO纹理数据到 Unity 的纹理数据\"></a>（四）FBO纹理数据到 Unity 的纹理数据</h3><p>学习了解到Unity中可以使用 RawImage 或者 quad 等相关控件可以显示纹理，这里以 RawImage 为例。在 Unity 脚本编写初始化的逻辑，构造一个 Texture2D 对象，将句柄传递到 Android，并赋值给 RawImage，并将texture id 传递到 Android 平台，完成一次渲染的重定向。<br><figure class=\"highlight c#\"><table><tr><td class=\"code\"><pre><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">InitPlayer</span>()</span></span><br><span class=\"line\"> &#123;    </span><br><span class=\"line\">    Texture2D texture2D = <span class=\"keyword\">new</span> Texture2D(width, height, TextureFormat.RGB24, <span class=\"literal\">false</span>, <span class=\"literal\">false</span>);</span><br><span class=\"line\">    androidObj.Call(<span class=\"string\">&quot;init&quot;</span>, (<span class=\"built_in\">int</span>)texture2D.GetNativeTexturePtr(), width, height);</span><br><span class=\"line\">    RawImage.texture = texture2D;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>创建FBO<br><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"type\">int</span> <span class=\"title function_\">createFBO</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">int</span>[] fbo = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[<span class=\"number\">1</span>];</span><br><span class=\"line\">    GLES30.glGenFramebuffers(fbo.length, fbo, <span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> fbo[<span class=\"number\">0</span>];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>为<code>SurfaceTexture</code> 设置了 <code>OnFrameAvailableListener</code> 后，当有新的图形流数据生成之后，就可以通过  <code>mSurfaceTexture.updateTexImage()</code> 将当前图片流更新到纹理所关联的OpenGLES中纹理，并绘制 FBO.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">publc <span class=\"keyword\">void</span> <span class=\"title function_\">draw</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//1. 绑定 FrameBuffer 到当前的绘制环境上， 后续 GL 绘制都会到这个 framebuffer</span></span><br><span class=\"line\">    GLES20.glBindFramebuffer(GLES20.GL_FRAMEBUFFER, fbo[<span class=\"number\">0</span>]);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//2.把一个2D纹理作为帧缓冲区附着</span></span><br><span class=\"line\">    <span class=\"comment\">//即所有渲染操作的结果将会被储存在 unityTextureId 对应的纹理图像中</span></span><br><span class=\"line\">    GLES20.glFramebufferTexture2D(GLES20.GL_FRAMEBUFFER, GLES20.GL_COLOR_ATTACHMENT0, GLES20.GL_TEXTURE_2D, unityTextureId, <span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//绑定指定纹理到当前激活的纹理单元</span></span><br><span class=\"line\">    GLES20.glBindTexture(GLES11Ext.GL_TEXTURE_EXTERNAL_OES, videoTextureId);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//…… 省略 Opengl 绘制的常规流程</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这一步是最关键的，实现了将 FBO 的输出指向 Unity 里面创建的纹理，也就实现了 Android 渲染与 Unity 之间的数据打通。</p>\n<p>这里的 unityTextureId 来源于在 Unity 中初始化的 <code>(int)texture2D.GetNativeTexturePtr()</code>值。</p>\n<p>整体的流程为：</p>\n<img src=\"https://cdn.julis.wang/blog/img/bb890ed53d3e449391813b46e6dbec4e.png\">\n<p>效果图：</p>\n<img width=\"40%\" src=\"https://cdn.julis.wang/blog/img/e9b8deec9acf448b8498471b287a2536.gif\">\n<p>图中播放视频区域为 Unity 的 RawImage 控件，渲染的视频通过 Pag 等相关素材由渲染SDK合成。</p>\n<p>如图所示，视频画面正常地进行渲染，图中有两个区域展示了视频画面，上面的使用的 Quad 组件，下面是用的 RawImage，流程都一直，只是在 Unity 使用 Texture2D 的时候通过 <code>Quad.mainTexture = texture2D</code> 赋值。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>本文主要讲了 Unity 利用 Android 提供的能力进行视频相关的特效渲染的方案，总体正常运行。还需要一些优化，例如对 <code>Multithreaded Rendering</code>配置还未支持，以及一些逻辑可能受限于游戏侧的配置，例如图形渲染的配置使用的 OpenGL3.0，如果使用 OpenGL2.0 或者 Vulkan，还需要单独调整相关逻辑。</p>\n","cover":null,"images":["https://cdn.julis.wang/blog/img/k3u1fbpfcp.jpg","https://www.songho.ca/opengl/files/gl_fbo01.png?height=278&amp;width=380","https://cdn.julis.wang/blog/img/bb890ed53d3e449391813b46e6dbec4e.png","https://cdn.julis.wang/blog/img/e9b8deec9acf448b8498471b287a2536.gif"],"content":"<p>在 Unity 中使用 Android 侧提供的视频渲染相关的能力，有两种方案可选：</p>\n<p>第一种是将渲染播放页单独做一个页面，在 Unity事件交互的时候打开对应 Activity 页面，或者获取到 Unity 创建的 Acitivity 动态添加 View。</p>\n<p>第二种是只借助 Android 的渲染能力，将数据渲染到 Unity 的控件上。</p>\n<p>两种方案各有优劣，第一种大大地减少了播放器相关的开发工作量，整个页面逻辑可以实现复用，但是交互页面的话 iOS/Android 需要写两套。第二种实现成本相对较高，但是交互可以由 Unity 侧进行，只是播放器使用封装好的 plugin 进行，能达到交互相对较统一，本文也主要是讲述该方案的实现。</p>\n<h2 id=\"Android-平台基本播放逻辑\"><a href=\"#Android-平台基本播放逻辑\" class=\"headerlink\" title=\"Android 平台基本播放逻辑\"></a>Android 平台基本播放逻辑</h2><p>在正式开发改造之前，对 Android 侧的一个播放器渲染流程进行简单的介绍，以 MediaPlayer 为例，利用 MediaPlayer 进行视频解码渲染，并将视频最后输出到 SurfaceView 上,一次播放器视频渲染到View上的的主要代码流程为：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">initPlayer</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">MediaPlayer</span> <span class=\"variable\">mediaPlayer</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">MediaPlayer</span>();</span><br><span class=\"line\">    <span class=\"type\">SurfaceView</span> <span class=\"variable\">surfaceView</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">SurfaceView</span>(activity);</span><br><span class=\"line\">    surfaceHolder = surfaceView.getHolder();</span><br><span class=\"line\">    surfaceHolder.addCallback(^ &#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">surfaceCreated</span><span class=\"params\">(SurfaceHolder holder)</span> &#123;</span><br><span class=\"line\">            <span class=\"type\">Surface</span> <span class=\"variable\">surface</span> <span class=\"operator\">=</span> holder.getSurface();</span><br><span class=\"line\">            mediaPlayer.setSurface(surface);</span><br><span class=\"line\">            mediaPlayer.prepareAsync();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">         ……</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    mediaPlayer.setDataSource(URI...);</span><br><span class=\"line\">    mediaPlayer.setOnPreparedListener(mp -&gt; mp.start());   </span><br><span class=\"line\">&#125;  </span><br></pre></td></tr></table></figure>\n<p>对于渲染 <code>mediaPlayer.setSurface(surface)</code> 设为播放器解码数据的接受器，Surface 来自于 SurfaceView。</p>\n<p>播放器是将数据图形绘制在 Surface 对象上，Surface中会关联一个 BufferQueue 用于提供图像数据缓存，SurfaceFlinger 会把 Surface 对应的图像层混合在一起，将其输出到 FrameBuffer 中（Framebuffer就是一块内存区域，它通常是显示驱动的内部缓冲区在内存中的映射），最后在屏幕上看到合成的图像。</p>\n<p>整个流程引入外部大佬的一张图所示：</p>\n<img src=\"https://cdn.julis.wang/blog/img/k3u1fbpfcp.jpg\">\n<h2 id=\"Unity-中的一些改造\"><a href=\"#Unity-中的一些改造\" class=\"headerlink\" title=\"Unity 中的一些改造\"></a>Unity 中的一些改造</h2><p>上面的流程最终是通过播放器解码渲染到 SurfaceView 上，当然，你可以通过获取到 UnityPlayer 对应的 Acitivity 将这个 SurfaceView 动态添加到当前界面，实现“在 Unity 中利用 Android 能力进行视频渲染”。</p>\n<p>所以需要对其进行改造，我们的目的是实现 Android 播放器数据渲染到 Untiy 的组件中。实现这一过程需要借助 FBO(Frame Buffer Object) 的能力。</p>\n<h3 id=\"（一）FBO\"><a href=\"#（一）FBO\" class=\"headerlink\" title=\"（一）FBO\"></a>（一）FBO</h3><p>在 OpenGL 渲染管线中几何数据和纹理经过变换和一些测试处理，最后以二维像素的形式显示在屏幕上。OpenGL管线的最终渲染目的地被称作帧缓存(framebuffer)，OpenGL渲染管线的最终位置是在帧缓冲区中，默认情况下 OpenGL 使用的是窗口系统提供的帧缓冲区。</p>\n<p>但有些场景是不想要直接渲染到窗口上的(例如加视频特效)，于是 OpenGL 提供了一种方式来创建额外的帧缓冲区对象(FBO)。使用帧缓冲区对象，OpenGL 可以将原先绘制到窗口提供的帧缓冲区重定向到 FBO 之中。FBO本身不是一块内存，没有空间，真正存储东西，可实际读写的是依附于FBO的东西：纹理(texture)和渲染缓存(renderbuffer)，依附的方式，是一个二维数组来管理，结构如图所示：</p>\n<p><img src=\"https://www.songho.ca/opengl/files/gl_fbo01.png?height=278&amp;width=380\" alt=\"\"></p>\n<h3 id=\"（二）具体实现\"><a href=\"#（二）具体实现\" class=\"headerlink\" title=\"（二）具体实现\"></a>（二）具体实现</h3><p>使用 FBO 我们可以将渲染目标渲染到其他的空间，我们目的是将播放器解码后的数据渲染到 Unity 控件的纹理空间中。<br>渲染播放器将输出到 FBO 中，FBO 指向 Unity 控件数据的输入，从而实现：Android 的播放器输出数据显示到 Unity 的控件中。</p>\n<h3 id=\"（三）从渲染输出数据到外部纹理\"><a href=\"#（三）从渲染输出数据到外部纹理\" class=\"headerlink\" title=\"（三）从渲染输出数据到外部纹理\"></a>（三）从渲染输出数据到外部纹理</h3><p>由于 <code>mediaPlayer.setSurface(surface)</code> 对应的 Surface 来源于 SurafaceView，会直接渲染到屏幕上，这里我们需要使用 构造一个新的 SurfaceTexture 以将图像流式传输到给定的 OpenGL 纹理;</p>\n<p>要获取到播放器渲染得数据，需要借助 SurfaceTexture ，SurfaceTexture 是Surface 和 OpenGL ES 纹理的结合，其对图像流的处理并不直接显示，而是从图像流中捕获帧作为 OpenGL 的外部纹理，图像流来自相机预览和视频解码。</p>\n<p>SurfaceTexture 创建的 Surface 是数据的生产者，而 SurfaceTexture 是对应的消费者，Surface 接收媒体数据并将数据发送到 SurfaceTexture，当调用 updateTexImage 的时候，创建SurfaceTexture 的纹理对象相应的内容将更新为最新图像帧，也就是会将图像帧转换为 GL 纹理，并将该纹理绑定到 GL_TEXTURE_EXTERNAL_OES 纹理对象上。具体实现逻辑参考：<a href=\"https://juejin.cn/post/7012517274768179236\">Android Opengl OES 纹理渲染到 GL_TEXTURE_2D</a></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">SurfaceTexture</span> <span class=\"variable\">surfaceTexture</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">SurfaceTexture</span>(videoTextureId);</span><br><span class=\"line\">player.setUpSurface(<span class=\"keyword\">new</span> <span class=\"title class_\">Surface</span>(surfaceTexture), width, height);</span><br><span class=\"line\">surfaceTexture.setDefaultBufferSize(width, height);</span><br><span class=\"line\">surfaceTexture.setOnFrameAvailableListener(surfaceTexture -&gt; &#123;……&#125;);;</span><br></pre></td></tr></table></figure>\n<p>其中 videoTextureId 来源于创建的 OES 纹理：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"type\">int</span> <span class=\"title function_\">createOESTextureID</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span>[] texture = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[<span class=\"number\">1</span>];</span><br><span class=\"line\">        <span class=\"comment\">// 创建纹理对象，一个容器对象，保存渲染所需要的纹理数据，例如：图像数据</span></span><br><span class=\"line\">        <span class=\"comment\">//在OpenGL 中纹理对象是一个无符号整数，是一个纹理对象的句柄</span></span><br><span class=\"line\">        GLES30.glGenTextures(texture.length, texture, <span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 绑定纹理ID到纹理单元的纹理目标上</span></span><br><span class=\"line\">        GLES30.glBindTexture(GLES11Ext.GL_TEXTURE_EXTERNAL_OES, texture[<span class=\"number\">0</span>]);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 设置纹理参数</span></span><br><span class=\"line\">        ……</span><br><span class=\"line\"></span><br><span class=\"line\">        GLES30.glGenerateMipmap(GLES11Ext.GL_TEXTURE_EXTERNAL_OES);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> texture[<span class=\"number\">0</span>];</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"（四）FBO纹理数据到-Unity-的纹理数据\"><a href=\"#（四）FBO纹理数据到-Unity-的纹理数据\" class=\"headerlink\" title=\"（四）FBO纹理数据到 Unity 的纹理数据\"></a>（四）FBO纹理数据到 Unity 的纹理数据</h3><p>学习了解到Unity中可以使用 RawImage 或者 quad 等相关控件可以显示纹理，这里以 RawImage 为例。在 Unity 脚本编写初始化的逻辑，构造一个 Texture2D 对象，将句柄传递到 Android，并赋值给 RawImage，并将texture id 传递到 Android 平台，完成一次渲染的重定向。<br><figure class=\"highlight c#\"><table><tr><td class=\"code\"><pre><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">InitPlayer</span>()</span></span><br><span class=\"line\"> &#123;    </span><br><span class=\"line\">    Texture2D texture2D = <span class=\"keyword\">new</span> Texture2D(width, height, TextureFormat.RGB24, <span class=\"literal\">false</span>, <span class=\"literal\">false</span>);</span><br><span class=\"line\">    androidObj.Call(<span class=\"string\">&quot;init&quot;</span>, (<span class=\"built_in\">int</span>)texture2D.GetNativeTexturePtr(), width, height);</span><br><span class=\"line\">    RawImage.texture = texture2D;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>创建FBO<br><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"type\">int</span> <span class=\"title function_\">createFBO</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">int</span>[] fbo = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[<span class=\"number\">1</span>];</span><br><span class=\"line\">    GLES30.glGenFramebuffers(fbo.length, fbo, <span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> fbo[<span class=\"number\">0</span>];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>为<code>SurfaceTexture</code> 设置了 <code>OnFrameAvailableListener</code> 后，当有新的图形流数据生成之后，就可以通过  <code>mSurfaceTexture.updateTexImage()</code> 将当前图片流更新到纹理所关联的OpenGLES中纹理，并绘制 FBO.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">publc <span class=\"keyword\">void</span> <span class=\"title function_\">draw</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//1. 绑定 FrameBuffer 到当前的绘制环境上， 后续 GL 绘制都会到这个 framebuffer</span></span><br><span class=\"line\">    GLES20.glBindFramebuffer(GLES20.GL_FRAMEBUFFER, fbo[<span class=\"number\">0</span>]);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//2.把一个2D纹理作为帧缓冲区附着</span></span><br><span class=\"line\">    <span class=\"comment\">//即所有渲染操作的结果将会被储存在 unityTextureId 对应的纹理图像中</span></span><br><span class=\"line\">    GLES20.glFramebufferTexture2D(GLES20.GL_FRAMEBUFFER, GLES20.GL_COLOR_ATTACHMENT0, GLES20.GL_TEXTURE_2D, unityTextureId, <span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//绑定指定纹理到当前激活的纹理单元</span></span><br><span class=\"line\">    GLES20.glBindTexture(GLES11Ext.GL_TEXTURE_EXTERNAL_OES, videoTextureId);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//…… 省略 Opengl 绘制的常规流程</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这一步是最关键的，实现了将 FBO 的输出指向 Unity 里面创建的纹理，也就实现了 Android 渲染与 Unity 之间的数据打通。</p>\n<p>这里的 unityTextureId 来源于在 Unity 中初始化的 <code>(int)texture2D.GetNativeTexturePtr()</code>值。</p>\n<p>整体的流程为：</p>\n<img src=\"https://cdn.julis.wang/blog/img/bb890ed53d3e449391813b46e6dbec4e.png\">\n<p>效果图：</p>\n<img width=\"40%\" src=\"https://cdn.julis.wang/blog/img/e9b8deec9acf448b8498471b287a2536.gif\">\n<p>图中播放视频区域为 Unity 的 RawImage 控件，渲染的视频通过 Pag 等相关素材由渲染SDK合成。</p>\n<p>如图所示，视频画面正常地进行渲染，图中有两个区域展示了视频画面，上面的使用的 Quad 组件，下面是用的 RawImage，流程都一直，只是在 Unity 使用 Texture2D 的时候通过 <code>Quad.mainTexture = texture2D</code> 赋值。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>本文主要讲了 Unity 利用 Android 提供的能力进行视频相关的特效渲染的方案，总体正常运行。还需要一些优化，例如对 <code>Multithreaded Rendering</code>配置还未支持，以及一些逻辑可能受限于游戏侧的配置，例如图形渲染的配置使用的 OpenGL3.0，如果使用 OpenGL2.0 或者 Vulkan，还需要单独调整相关逻辑。</p>\n","categories":[{"name":"技术文章","slug":"technology","api":"api/categories/technology.json"}],"tags":[{"name":"音视频","slug":"音视频","api":"api/tags/音视频.json"},{"name":"Unity","slug":"Unity","api":"api/tags/Unity.json"}],"api":"api/posts/2022/10/25/Unity-实现利用-Andorid-能力进行视频渲染播放.json"},{"title":"我写了一个场所码小工具（上海实用）","slug":"写了一个场所码小工具","date":"2022-07-03T15:14:00.000Z","updated":"2025-05-20T11:46:57.000Z","comments":true,"url":"2022/07/03/写了一个场所码小工具/","excerpt":"<p>随着新冠疫情的常态化，以上海为例，出示健康码、扫码场所码已经成了每天进出地铁、公司必备操作。对于上班工作，每天的场所码都是同一个地点，对应的场所码图片也不会发生变化，每次扫场所码的时候要不就是前面有很多人一起挤着，或者遇到下雨天不方便等情况。对于我自己而言，我会把场所码保存下来，方便下一次“扫场所码”，但由于存在图库，每次依然需要打开支付宝或者微信选择对应的图片进行扫描，所以就做了个工具，实现：<strong>一键打开健康码、自动保存场所码、一键打开存储的场所码。</strong></p>\n<h2 id=\"小工具使用\"><a href=\"#小工具使用\" class=\"headerlink\" title=\"小工具使用\"></a>小工具使用</h2> <img width=\"40%\" src=\"https://cdn.julis.wang/blog/img/af7fdb3bd9884abf9e8bacfa04936511.png\">\n<p>如图所示提供两个按钮：</p>\n<ul>\n<li>扫一扫 </li>\n</ul>\n<p>扫一扫主要是为了扫场所码，它会扫码对应的二维码图片进行扫描（或者从相册进行读取），识别到对应的场所码信息会自动跳转到支付宝（当前只支持打开支付宝的场所码），并将这一次的结果保存到数据库中。如果下次需要同一个场所码，可以从列表中选择对应的场所码数据并点击直接跳转到场所码，不需要再进行手动扫描。</p>\n<ul>\n<li>健康码</li>\n</ul>\n<p>主要是实现一键打开健康码功能</p>\n<p>对于场所码的信息，在第一次添加的过程中会弹出提示框提示修改场所码的信息进行备注，当然也可以在对应的类目左滑进行编辑操作。</p>\n  <img width=\"40%\" src=\"https://cdn.julis.wang/blog/img/94555e91ef1f4a51942f1a80c349e6d6.png\">\n  <img width=\"40%\" src=\"https://cdn.julis.wang/blog/img/0d09051321934a7e8936209a94b6d110.png\">\n<h2 id=\"下载\"><a href=\"#下载\" class=\"headerlink\" title=\"下载\"></a>下载</h2><p>整个实现是使用Flutter写的，能实现跨平台，但由于iOS需要开发者证书相关上架AppStore较为麻烦，暂时没法进行分发。</p>\n<p>Android 同学可以扫描下面的二维码进行体验使用，或者点击 <a href=\"https://www.pgyer.com/W4La\">场所码小助手</a>去该页面下载</p>\n<p><img src=\"https://www.pgyer.com/app/qrcode/W4La\" width = 40% alt=\"图片名称\" align=center /></p>\n","cover":null,"images":["https://cdn.julis.wang/blog/img/af7fdb3bd9884abf9e8bacfa04936511.png","https://cdn.julis.wang/blog/img/94555e91ef1f4a51942f1a80c349e6d6.png","https://cdn.julis.wang/blog/img/0d09051321934a7e8936209a94b6d110.png","https://www.pgyer.com/app/qrcode/W4La"],"content":"<p>随着新冠疫情的常态化，以上海为例，出示健康码、扫码场所码已经成了每天进出地铁、公司必备操作。对于上班工作，每天的场所码都是同一个地点，对应的场所码图片也不会发生变化，每次扫场所码的时候要不就是前面有很多人一起挤着，或者遇到下雨天不方便等情况。对于我自己而言，我会把场所码保存下来，方便下一次“扫场所码”，但由于存在图库，每次依然需要打开支付宝或者微信选择对应的图片进行扫描，所以就做了个工具，实现：<strong>一键打开健康码、自动保存场所码、一键打开存储的场所码。</strong></p>\n<h2 id=\"小工具使用\"><a href=\"#小工具使用\" class=\"headerlink\" title=\"小工具使用\"></a>小工具使用</h2> <img width=\"40%\" src=\"https://cdn.julis.wang/blog/img/af7fdb3bd9884abf9e8bacfa04936511.png\">\n<p>如图所示提供两个按钮：</p>\n<ul>\n<li>扫一扫 </li>\n</ul>\n<p>扫一扫主要是为了扫场所码，它会扫码对应的二维码图片进行扫描（或者从相册进行读取），识别到对应的场所码信息会自动跳转到支付宝（当前只支持打开支付宝的场所码），并将这一次的结果保存到数据库中。如果下次需要同一个场所码，可以从列表中选择对应的场所码数据并点击直接跳转到场所码，不需要再进行手动扫描。</p>\n<ul>\n<li>健康码</li>\n</ul>\n<p>主要是实现一键打开健康码功能</p>\n<p>对于场所码的信息，在第一次添加的过程中会弹出提示框提示修改场所码的信息进行备注，当然也可以在对应的类目左滑进行编辑操作。</p>\n  <img width=\"40%\" src=\"https://cdn.julis.wang/blog/img/94555e91ef1f4a51942f1a80c349e6d6.png\">\n  <img width=\"40%\" src=\"https://cdn.julis.wang/blog/img/0d09051321934a7e8936209a94b6d110.png\">\n<h2 id=\"下载\"><a href=\"#下载\" class=\"headerlink\" title=\"下载\"></a>下载</h2><p>整个实现是使用Flutter写的，能实现跨平台，但由于iOS需要开发者证书相关上架AppStore较为麻烦，暂时没法进行分发。</p>\n<p>Android 同学可以扫描下面的二维码进行体验使用，或者点击 <a href=\"https://www.pgyer.com/W4La\">场所码小助手</a>去该页面下载</p>\n<p><img src=\"https://www.pgyer.com/app/qrcode/W4La\" width = 40% alt=\"图片名称\" align=center /></p>\n","categories":[],"tags":[],"api":"api/posts/2022/07/03/写了一个场所码小工具.json"}],"info":{"type":"index"}},"api":"api/posts/page.2.json"}