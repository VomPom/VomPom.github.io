{"data":{"title":"Flutter坑之FlutterFragment中SafeArea失效的问题","slug":"Flutter坑之FlutterFragment中SafeArea失效的问题","description":"","date":"2020-10-31T06:40:00.000Z","updated":"2025-05-20T11:46:57.000Z","language":"zh-CN","comments":true,"url":"2020/10/31/Flutter坑之FlutterFragment中SafeArea失效的问题/","cover":null,"images":[],"content":"<p>最近有在做关于Android底部多tab下，对应多个Flutter Fragment的操作。又遇到一个比较坑的问题:FlutterFragment中的flutter页面的SafeArea失效（关于safeArea具体介绍参考官方<a href=\"https://api.flutter.dev/flutter/widgets/SafeArea-class.html\">SafeArea class</a>），简单举例说一下SafeArea的作用：如果你有一刘海屏的手机，如果你的flutter内容为全屏，假如你的内容在全屏最顶部，那么所谓的刘海将会盖住你所想要的内容，如下图所示：</p>\n<img width=\"50%\" src=\"https://cdn.julis.wang/blog/img/2020110113363517.png\">\n<p>这当然不是我们想要的，于是Flutter官方推出：SafeArea这个属性，在dart语言中只需要在你的widget最外层包裹SafeArea就好了。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@override</span></span><br><span class=\"line\">Widget <span class=\"title function_\">build</span><span class=\"params\">(BuildContext context)</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> Scaffold(</span><br><span class=\"line\">    body: SafeArea(</span><br><span class=\"line\">      child: TabBarView(</span><br><span class=\"line\">        controller: mController,</span><br><span class=\"line\">        children: &lt;Widget&gt;[]</span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>于是得到了正确的展示效果，如下图所示：</p>\n<img width=\"50%\" src=\"https://cdn.julis.wang/blog/img/20201101134229321.png\">\n<p>你以为这样就完了么？在多个Flutter Fragment中SafeArea的作用失效，尽管我在flutter中设置了SafeArea，但依然存在刘海盖住flutter content的情况。</p>\n<h1 id=\"原因分析：\"><a href=\"#原因分析：\" class=\"headerlink\" title=\"原因分析：\"></a>原因分析：</h1><p>这真的是一件很头疼的事情，对应的Flutter page在Flutter Activity中能够正常work，但是偏偏在Fluttter Fragment中就出问题了呢？于是又去看FlutterView源码，果然有收获！发现一个方法：<code>onApplyWindowInsets()</code>这里面有一大堆逻辑，很多都是关于处理 statusBar以及navigationBar，更惊喜地还发现了处理<a href=\"https://developer.android.google.cn/reference/android/view/DisplayCutout?hl=zh-cn\">DisplayCutout</a>的逻辑，这不就是刘海屏相关的类么！以下是部分代码逻辑：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> WindowInsets <span class=\"title function_\">onApplyWindowInsets</span><span class=\"params\">(WindowInsets insets)</span> &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">   <span class=\"keyword\">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.R) &#123;</span><br><span class=\"line\">     <span class=\"type\">int</span> <span class=\"variable\">mask</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">     <span class=\"keyword\">if</span> (navigationBarVisible) &#123;</span><br><span class=\"line\">       mask = mask | android.view.WindowInsets.Type.navigationBars();</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">     <span class=\"keyword\">if</span> (statusBarVisible) &#123;</span><br><span class=\"line\">       mask = mask | android.view.WindowInsets.Type.statusBars();</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">     <span class=\"comment\">// TODO(garyq): Expose the full rects of the display cutout.</span></span><br><span class=\"line\">     <span class=\"comment\">// Take the max of the display cutout insets and existing padding to merge them</span></span><br><span class=\"line\">     <span class=\"type\">DisplayCutout</span> <span class=\"variable\">cutout</span> <span class=\"operator\">=</span> insets.getDisplayCutout();</span><br><span class=\"line\">     <span class=\"keyword\">if</span> (cutout != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">       <span class=\"type\">Insets</span> <span class=\"variable\">waterfallInsets</span> <span class=\"operator\">=</span> cutout.getWaterfallInsets();</span><br><span class=\"line\">       mMetrics.physicalPaddingTop =</span><br><span class=\"line\">           Math.max(</span><br><span class=\"line\">               Math.max(mMetrics.physicalPaddingTop, waterfallInsets.top),</span><br><span class=\"line\">               cutout.getSafeInsetTop());</span><br><span class=\"line\">      ...</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">   &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">     <span class=\"comment\">// Status bar (top) and left/right system insets should partially obscure the content</span></span><br><span class=\"line\">     <span class=\"comment\">// (padding).</span></span><br><span class=\"line\">   ...</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   updateViewportMetrics();</span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"built_in\">super</span>.onApplyWindowInsets(insets);</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n<p>很明显这一块逻辑是处理刘海屏以及StatusBar相关的逻辑，于是进行相关的断点调试，发现FlutterFragment中的FlutterView的确是没有执行这个方法，对比同样在FlutterActivity中的FlutterView正常work并执行了这一串代码。</p>\n<p>！那这不就神奇了么？这一下子又让人头秃了，这一定又是跟Fragment的相关机制导致的，自己对Fragment的具体处理逻辑不太熟，于是各种Google，找到两篇有点类似的答案：<br><a href=\"https://stackoverflow.com/questions/31190612/fitssystemwindows-effect-gone-for-fragments-added-via-fragmenttransaction\">1、fitsSystemWindows effect gone for fragments added via FragmentTransaction</a><br><a href=\"https://blog.csdn.net/qq_35054800/article/details/82107053?utm_source=copy\">2、一个Activity中添加多个Fragment导致fitsSystemWindows无效的问题</a></p>\n<p>引入上面的解释说：</p>\n<blockquote>\n<p>当第一个Fragment添加到Activity中的时候，Activity寻找出有fitsSystemWindows的子布局为其预留出状态栏的空间，其实就是设置一个padding，而其他Fragment添加到Activity中的时候，因为状态栏空间的适配已经被消费过一次了，Activity并不会再次去添加这个padding</p>\n</blockquote>\n<p>虽然这里在进行fitsSystemWindows的操作，但是我们明确了一件事情：添加多个Fragment的时候，Activity对于padding相关操作只在第一个Fragment进行了相关处理逻辑。那么对应我们的FlutterFragment是否是同样的问题呢？？</p>\n<p>于是我进行了尝试，将Flutter Fragment放在Acitvity第一个需要展示的Fragment，经过尝试发现第一个FlutterFragment能正常work了！但之后的Flutter Fragment问题依然存在，那么我们可以肯定也就是说：<br><strong>在多FlutterFragment中的FlutterView，只有在作为Acitivty添加为第一个Fragment的情况下才会去调用 <code> onApplyWindowInsets(WindowInsets insets)</code> 方法去处理一些statusBar相关的操作逻辑。</strong><br>的确事实如此，经过尝试之后发现的确只会调用一次，那么如何解决呢？</p>\n<h1 id=\"解决方案：\"><a href=\"#解决方案：\" class=\"headerlink\" title=\"解决方案：\"></a>解决方案：</h1><p>参照上面的解决方案，可以写一个WindowInsetsFrameLayout继承FrameLayout，并<code>setOnHierarchyChangeListener()</code>监听Fragment的添加操作，在添加的时候执行 view的requestApplyInsets();</p>\n<p>当然对于我们的问题并没有这么麻烦，我们在自己的FlutterFragment中手动去执行flutterView.requestApplyInsets();只需要执行时机保证在flutter渲染之前执行（Safe Area通过获去Native端onApplyWindowInsets()中传过去的params来执行相关渲染）</p>\n<p>但还有一个问题：<code>flutterView.requestApplyInsets();</code>只能在Api大于20中使用，那么低于20呢？与其说低于20，不如直接说，19中怎么处理（Android 4.4 api 19引入的透明状态栏 、沉浸式相关），我们可以看到，在onApplyWindowInsets() 中最终是发送一个事件到flutter端，如下代码所示。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">sendViewportMetricsToFlutter</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!isAttachedToFlutterEngine()) &#123;</span><br><span class=\"line\">    Log.w(</span><br><span class=\"line\">        TAG,</span><br><span class=\"line\">        <span class=\"string\">&quot;Tried to send viewport metrics from Android to Flutter but this &quot;</span></span><br><span class=\"line\">            + <span class=\"string\">&quot;FlutterView was not attached to a FlutterEngine.&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  viewportMetrics.devicePixelRatio = getResources().getDisplayMetrics().density;</span><br><span class=\"line\">  flutterEngine.getRenderer().setViewportMetrics(viewportMetrics);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>那么对于Api 19就可以对相关数据进行反射调用，之后再讲数据发送到flutter端即可，那么大致逻辑如下所示：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">onViewCreated</span><span class=\"params\">(<span class=\"meta\">@NonNull</span> View view, <span class=\"meta\">@Nullable</span> Bundle savedInstanceState)</span> &#123;</span><br><span class=\"line\">     <span class=\"built_in\">super</span>.onViewCreated(view, savedInstanceState);</span><br><span class=\"line\">     <span class=\"keyword\">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.KITKAT_WATCH) &#123;</span><br><span class=\"line\">         flutterView.requestApplyInsets();</span><br><span class=\"line\">     &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">         adapterStatusBarBelowApi20();</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"总结：\"><a href=\"#总结：\" class=\"headerlink\" title=\"总结：\"></a>总结：</h1><p>1、这个问题在官方的FlutterFragment中也存在，但不知道为什么没有修复，可能他们真的不太重视混合开发吧，一心在纯flutter开发中。<br>2、关于为什么Fragment 相关操作逻辑只在第一个被Fragment被添加，这里涉及到了太多底层的东西，这里没有赘述，打算深入研究，写一篇新到blog中去介绍。<br>3、Flutter坑实在是太多了，很多问题都与Android原生机制相关，这不得不让人对原生系统机制进行深入学习。</p>\n","raw":"title: Flutter坑之FlutterFragment中SafeArea失效的问题\nauthor: 落叶挽歌\nthumbnail: 'https://cdn.pixabay.com/photo/2016/09/04/14/49/church-1644171_1280.jpg'\ntags:\n  - Flutter\ncategories:\n  - 技术文章\ndate: 2020-10-31 14:40:00\n---\n\n最近有在做关于Android底部多tab下，对应多个Flutter Fragment的操作。又遇到一个比较坑的问题:FlutterFragment中的flutter页面的SafeArea失效（关于safeArea具体介绍参考官方[SafeArea class](https://api.flutter.dev/flutter/widgets/SafeArea-class.html)），简单举例说一下SafeArea的作用：如果你有一刘海屏的手机，如果你的flutter内容为全屏，假如你的内容在全屏最顶部，那么所谓的刘海将会盖住你所想要的内容，如下图所示：\n{% qnimg 2020110113363517.png width:50% %}\n这当然不是我们想要的，于是Flutter官方推出：SafeArea这个属性，在dart语言中只需要在你的widget最外层包裹SafeArea就好了。\n\n```java\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      body: SafeArea(\n        child: TabBarView(\n          controller: mController,\n          children: <Widget>[]\n    );\n  }\n```\n于是得到了正确的展示效果，如下图所示：\n\n{% qnimg 20201101134229321.png width:50% %}\n你以为这样就完了么？在多个Flutter Fragment中SafeArea的作用失效，尽管我在flutter中设置了SafeArea，但依然存在刘海盖住flutter content的情况。\n\n# 原因分析：\n这真的是一件很头疼的事情，对应的Flutter page在Flutter Activity中能够正常work，但是偏偏在Fluttter Fragment中就出问题了呢？于是又去看FlutterView源码，果然有收获！发现一个方法：`onApplyWindowInsets()`这里面有一大堆逻辑，很多都是关于处理 statusBar以及navigationBar，更惊喜地还发现了处理[DisplayCutout](https://developer.android.google.cn/reference/android/view/DisplayCutout?hl=zh-cn)的逻辑，这不就是刘海屏相关的类么！以下是部分代码逻辑：\n\n```java\n public final WindowInsets onApplyWindowInsets(WindowInsets insets) {\n     ...\n    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.R) {\n      int mask = 0;\n      if (navigationBarVisible) {\n        mask = mask | android.view.WindowInsets.Type.navigationBars();\n      }\n      if (statusBarVisible) {\n        mask = mask | android.view.WindowInsets.Type.statusBars();\n      }\n     ...\n      // TODO(garyq): Expose the full rects of the display cutout.\n      // Take the max of the display cutout insets and existing padding to merge them\n      DisplayCutout cutout = insets.getDisplayCutout();\n      if (cutout != null) {\n        Insets waterfallInsets = cutout.getWaterfallInsets();\n        mMetrics.physicalPaddingTop =\n            Math.max(\n                Math.max(mMetrics.physicalPaddingTop, waterfallInsets.top),\n                cutout.getSafeInsetTop());\n       ...\n      }\n    } else {\n      // Status bar (top) and left/right system insets should partially obscure the content\n      // (padding).\n    ...\n    }\n\n    updateViewportMetrics();\n    return super.onApplyWindowInsets(insets);\n  }\n```\n很明显这一块逻辑是处理刘海屏以及StatusBar相关的逻辑，于是进行相关的断点调试，发现FlutterFragment中的FlutterView的确是没有执行这个方法，对比同样在FlutterActivity中的FlutterView正常work并执行了这一串代码。\n\n！那这不就神奇了么？这一下子又让人头秃了，这一定又是跟Fragment的相关机制导致的，自己对Fragment的具体处理逻辑不太熟，于是各种Google，找到两篇有点类似的答案：\n[1、fitsSystemWindows effect gone for fragments added via FragmentTransaction](https://stackoverflow.com/questions/31190612/fitssystemwindows-effect-gone-for-fragments-added-via-fragmenttransaction)\n[2、一个Activity中添加多个Fragment导致fitsSystemWindows无效的问题](https://blog.csdn.net/qq_35054800/article/details/82107053?utm_source=copy)\n\n引入上面的解释说：\n\n> 当第一个Fragment添加到Activity中的时候，Activity寻找出有fitsSystemWindows的子布局为其预留出状态栏的空间，其实就是设置一个padding，而其他Fragment添加到Activity中的时候，因为状态栏空间的适配已经被消费过一次了，Activity并不会再次去添加这个padding\n\n虽然这里在进行fitsSystemWindows的操作，但是我们明确了一件事情：添加多个Fragment的时候，Activity对于padding相关操作只在第一个Fragment进行了相关处理逻辑。那么对应我们的FlutterFragment是否是同样的问题呢？？\n\n于是我进行了尝试，将Flutter Fragment放在Acitvity第一个需要展示的Fragment，经过尝试发现第一个FlutterFragment能正常work了！但之后的Flutter Fragment问题依然存在，那么我们可以肯定也就是说：\n**在多FlutterFragment中的FlutterView，只有在作为Acitivty添加为第一个Fragment的情况下才会去调用 ` onApplyWindowInsets(WindowInsets insets)` 方法去处理一些statusBar相关的操作逻辑。**\n的确事实如此，经过尝试之后发现的确只会调用一次，那么如何解决呢？\n\n# 解决方案：\n参照上面的解决方案，可以写一个WindowInsetsFrameLayout继承FrameLayout，并`setOnHierarchyChangeListener()`监听Fragment的添加操作，在添加的时候执行 view的requestApplyInsets();\n\n当然对于我们的问题并没有这么麻烦，我们在自己的FlutterFragment中手动去执行flutterView.requestApplyInsets();只需要执行时机保证在flutter渲染之前执行（Safe Area通过获去Native端onApplyWindowInsets()中传过去的params来执行相关渲染）\n\n但还有一个问题：`flutterView.requestApplyInsets();`只能在Api大于20中使用，那么低于20呢？与其说低于20，不如直接说，19中怎么处理（Android 4.4 api 19引入的透明状态栏 、沉浸式相关），我们可以看到，在onApplyWindowInsets() 中最终是发送一个事件到flutter端，如下代码所示。\n\n```java\n  private void sendViewportMetricsToFlutter() {\n    if (!isAttachedToFlutterEngine()) {\n      Log.w(\n          TAG,\n          \"Tried to send viewport metrics from Android to Flutter but this \"\n              + \"FlutterView was not attached to a FlutterEngine.\");\n      return;\n    }\n\n    viewportMetrics.devicePixelRatio = getResources().getDisplayMetrics().density;\n    flutterEngine.getRenderer().setViewportMetrics(viewportMetrics);\n  }\n```\n那么对于Api 19就可以对相关数据进行反射调用，之后再讲数据发送到flutter端即可，那么大致逻辑如下所示：\n\n```java\n   public void onViewCreated(@NonNull View view, @Nullable Bundle savedInstanceState) {\n        super.onViewCreated(view, savedInstanceState);\n        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT_WATCH) {\n            flutterView.requestApplyInsets();\n        } else {\n            adapterStatusBarBelowApi20();\n        }\n    }\n```\n\n# 总结：\n1、这个问题在官方的FlutterFragment中也存在，但不知道为什么没有修复，可能他们真的不太重视混合开发吧，一心在纯flutter开发中。\n2、关于为什么Fragment 相关操作逻辑只在第一个被Fragment被添加，这里涉及到了太多底层的东西，这里没有赘述，打算深入研究，写一篇新到blog中去介绍。\n3、Flutter坑实在是太多了，很多问题都与Android原生机制相关，这不得不让人对原生系统机制进行深入学习。","categories":[{"name":"技术文章","api":"api/categories/technology.json"}],"tags":[{"name":"Flutter","api":"api/tags/Flutter.json"}]},"api":"api/posts/2020/10/31/Flutter坑之FlutterFragment中SafeArea失效的问题.json"}