{"data":{"title":"WeakHashMap与Java引用相关","slug":"WeakHashMap与Java引用相关","description":"","date":"2020-06-22T03:19:00.000Z","updated":"2025-05-20T11:46:57.000Z","language":"zh-CN","comments":true,"url":"2020/06/22/WeakHashMap与Java引用相关/","cover":null,"images":[],"content":"<p>记得在很久之前有写过一篇<a href=\"https://blog.csdn.net/u010107153/article/details/102821282\">《Java中的Reference解析》</a>，主要讲的是Java中的四种引用方式与引用队列，不过这些都是基础的理论知识，最近开发项目中有使用到WeakHashMap，对于Java的引用以及引用队列有了更深的了解，在此做个相关总结。</p>\n<h2 id=\"一、WeakHashMap的实现方式\"><a href=\"#一、WeakHashMap的实现方式\" class=\"headerlink\" title=\"一、WeakHashMap的实现方式\"></a>一、WeakHashMap的实现方式</h2><p>总体来说，WeakHashMap的底层数据结构与HashMap的实现差不多，都是用“拉链法”来实现，主要区别在于WeakHashMap的Entry 继承于WeakReference，并维护一个ReferenceQueue，使其具有了“弱引用的特性”，其构造方法可以看出：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">Entry(Object key, V value,ReferenceQueue&lt;Object&gt; queue,<span class=\"type\">int</span> hash, Entry&lt;K,V&gt; next) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">super</span>(key, queue); <span class=\"comment\">//这里比较关键</span></span><br><span class=\"line\">            ……</span><br><span class=\"line\">        &#125;</span><br></pre></td></tr></table></figure>\n<p>其中的super父类的代码实现为：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"title function_\">WeakReference</span><span class=\"params\">(T referent, ReferenceQueue&lt;? <span class=\"built_in\">super</span> T&gt; q)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">super</span>(referent, q);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>通过对父类的构造方法可以知道，WeakMap的key值为弱引用类型，回顾一下弱引用的特点：<strong>垃圾收集器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。</strong> 于是WeakHashMap的作用就凸显出来了：**对于数据中Key-value，key因为使用的弱引用会被回收，而value也会得到对应的释放。**以我这次的需求为例：key为Webview页面或者Flutter&#x2F;RN页面，value为调用native方法相关存储的对象。当页面需要关闭调webivew的时候，Webview应该要被释放，要不然会产生内存泄漏，当其被释放之后，对应的value也没有意义了，所以也需要被释放掉。</p>\n<p> 那么WeakHashMap是如何让value释放的呢？</p>\n<h2 id=\"二、WeakHashMap如何释放无用的Value\"><a href=\"#二、WeakHashMap如何释放无用的Value\" class=\"headerlink\" title=\"二、WeakHashMap如何释放无用的Value\"></a>二、WeakHashMap如何释放无用的Value</h2><p>要回收无用的Value，那么引用队列（ReferenceQueue）就派上用场了，回顾一下引用队列的作用：<strong>当一个引用（软引用、弱引用）关联到了一个引用队列后，当这个引用所引用的对象要被垃圾回收时，就会将它加入到所关联的引用队列中。</strong><br>所以判断一个引用对象是否已经被回收的一个现象就是，这个对象的引用是否被加入到了它所关联的引用队列。<br>那么对于WeakHashMap也是利用这一点特性，在其代码中put\\get等方法都有执行对应等检查</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> V <span class=\"title function_\">put</span><span class=\"params\">(K key, V value)</span> &#123;</span><br><span class=\"line\">       <span class=\"type\">Object</span> <span class=\"variable\">k</span> <span class=\"operator\">=</span> maskNull(key);</span><br><span class=\"line\">       <span class=\"type\">int</span> <span class=\"variable\">h</span> <span class=\"operator\">=</span> hash(k);</span><br><span class=\"line\">       Entry&lt;K,V&gt;[] tab = getTable(); <span class=\"comment\">//具体实现在getTable执行的expungeStaleEntries里面</span></span><br><span class=\"line\">       ……</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> V <span class=\"title function_\">get</span><span class=\"params\">(Object key)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">Object</span> <span class=\"variable\">k</span> <span class=\"operator\">=</span> maskNull(key);</span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">h</span> <span class=\"operator\">=</span> hash(k);</span><br><span class=\"line\">    Entry&lt;K,V&gt;[] tab = getTable();</span><br><span class=\"line\">    ……</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Expunges stale entries from the table.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">expungeStaleEntries</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (Object x; (x = queue.poll()) != <span class=\"literal\">null</span>; ) &#123; <span class=\"comment\">//这里的queue就是引用队列</span></span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span> (queue) &#123; </span><br><span class=\"line\">            <span class=\"meta\">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class=\"line\">                Entry&lt;K,V&gt; e = (Entry&lt;K,V&gt;) x;</span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> indexFor(e.hash, table.length);</span><br><span class=\"line\"></span><br><span class=\"line\">            Entry&lt;K,V&gt; prev = table[i];</span><br><span class=\"line\">            Entry&lt;K,V&gt; p = prev;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (p != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">                Entry&lt;K,V&gt; next = p.next;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (p == e) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (prev == e)</span><br><span class=\"line\">                        table[i] = next;</span><br><span class=\"line\">                    <span class=\"keyword\">else</span></span><br><span class=\"line\">                        prev.next = next;</span><br><span class=\"line\">                    <span class=\"comment\">// Must not null out e.next;</span></span><br><span class=\"line\">                    <span class=\"comment\">// stale entries may be in use by a HashIterator</span></span><br><span class=\"line\">                    e.value = <span class=\"literal\">null</span>; <span class=\"comment\">// Help GC</span></span><br><span class=\"line\">                    size--;</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                prev = p;</span><br><span class=\"line\">                p = next;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>从上面的代码逻辑可以很清楚的知道：WeakHashMap通过对引用队列的数据进行检查，对key被回收对象的对应Value进行了回收。</p>\n<h2 id=\"三、总结\"><a href=\"#三、总结\" class=\"headerlink\" title=\"三、总结\"></a>三、总结</h2><p>1、WeakHashMap的Entry 继承于WeakReference，并维护一个ReferenceQueue<br>2、在执行get\\put等相关数据操作的时候 会对数据进行相关处理，主要是清除掉无用对象对</p>\n","raw":"title: WeakHashMap与Java引用相关\nauthor: 落叶挽歌\nthumbnail: 'https://cdn.pixabay.com/photo/2016/04/07/22/17/rope-1314964_960_720.jpg'\ntags:\n  - Java\ncategories:\n  - 技术文章\ndate: 2020-06-22 11:19:00\n---\n记得在很久之前有写过一篇[《Java中的Reference解析》](https://blog.csdn.net/u010107153/article/details/102821282)，主要讲的是Java中的四种引用方式与引用队列，不过这些都是基础的理论知识，最近开发项目中有使用到WeakHashMap，对于Java的引用以及引用队列有了更深的了解，在此做个相关总结。\n\n## 一、WeakHashMap的实现方式\n总体来说，WeakHashMap的底层数据结构与HashMap的实现差不多，都是用“拉链法”来实现，主要区别在于WeakHashMap的Entry 继承于WeakReference，并维护一个ReferenceQueue，使其具有了“弱引用的特性”，其构造方法可以看出：\n\n```java\nEntry(Object key, V value,ReferenceQueue<Object> queue,int hash, Entry<K,V> next) {\n            super(key, queue); //这里比较关键\n            ……\n        }\n```\n其中的super父类的代码实现为：\n\n```java\npublic WeakReference(T referent, ReferenceQueue<? super T> q) {\n        super(referent, q);\n    }\n```\n通过对父类的构造方法可以知道，WeakMap的key值为弱引用类型，回顾一下弱引用的特点：**垃圾收集器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。** 于是WeakHashMap的作用就凸显出来了：**对于数据中Key-value，key因为使用的弱引用会被回收，而value也会得到对应的释放。**以我这次的需求为例：key为Webview页面或者Flutter/RN页面，value为调用native方法相关存储的对象。当页面需要关闭调webivew的时候，Webview应该要被释放，要不然会产生内存泄漏，当其被释放之后，对应的value也没有意义了，所以也需要被释放掉。\n\n 那么WeakHashMap是如何让value释放的呢？\n\n\n## 二、WeakHashMap如何释放无用的Value\n要回收无用的Value，那么引用队列（ReferenceQueue）就派上用场了，回顾一下引用队列的作用：**当一个引用（软引用、弱引用）关联到了一个引用队列后，当这个引用所引用的对象要被垃圾回收时，就会将它加入到所关联的引用队列中。**\n所以判断一个引用对象是否已经被回收的一个现象就是，这个对象的引用是否被加入到了它所关联的引用队列。\n那么对于WeakHashMap也是利用这一点特性，在其代码中put\\get等方法都有执行对应等检查\n\n```java\n public V put(K key, V value) {\n        Object k = maskNull(key);\n        int h = hash(k);\n        Entry<K,V>[] tab = getTable(); //具体实现在getTable执行的expungeStaleEntries里面\n        ……\n```\n\n```java\n    public V get(Object key) {\n        Object k = maskNull(key);\n        int h = hash(k);\n        Entry<K,V>[] tab = getTable();\n        ……\n```\n\n```java\n    /**\n     * Expunges stale entries from the table.\n     */\n    private void expungeStaleEntries() {\n        for (Object x; (x = queue.poll()) != null; ) { //这里的queue就是引用队列\n            synchronized (queue) { \n                @SuppressWarnings(\"unchecked\")\n                    Entry<K,V> e = (Entry<K,V>) x;\n                int i = indexFor(e.hash, table.length);\n\n                Entry<K,V> prev = table[i];\n                Entry<K,V> p = prev;\n                while (p != null) {\n                    Entry<K,V> next = p.next;\n                    if (p == e) {\n                        if (prev == e)\n                            table[i] = next;\n                        else\n                            prev.next = next;\n                        // Must not null out e.next;\n                        // stale entries may be in use by a HashIterator\n                        e.value = null; // Help GC\n                        size--;\n                        break;\n                    }\n                    prev = p;\n                    p = next;\n                }\n            }\n        }\n    }\n```\n从上面的代码逻辑可以很清楚的知道：WeakHashMap通过对引用队列的数据进行检查，对key被回收对象的对应Value进行了回收。\n\n## 三、总结\n1、WeakHashMap的Entry 继承于WeakReference，并维护一个ReferenceQueue\n2、在执行get\\put等相关数据操作的时候 会对数据进行相关处理，主要是清除掉无用对象对\n","categories":[{"name":"技术文章","api":"api/categories/technology.json"}],"tags":[{"name":"Java","api":"api/tags/java.json"}]},"api":"api/posts/2020/06/22/WeakHashMap与Java引用相关.json"}