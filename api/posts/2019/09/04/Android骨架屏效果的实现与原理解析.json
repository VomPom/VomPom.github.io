{"data":{"title":"Android骨架屏效果的实现与原理解析","slug":"Android骨架屏效果的实现与原理解析","description":"","date":"2019-09-04T09:50:00.000Z","updated":"2025-05-20T11:46:57.000Z","language":"zh-CN","comments":true,"url":"2019/09/04/Android骨架屏效果的实现与原理解析/","cover":null,"images":[],"content":"<p>大家在使用淘宝的时候，如下图所示有遇到这样的效果，其会只展示一部分骨架大致图，等数据加载完毕之后再展示真正的页面数据。与菊花图相比起来，这样的实现能更好的提升用户的体验，这种效果称做：Skeleton Screen Loading，中文叫做<strong>骨架屏</strong>，本文主要记录其实现过程。</p>\n<h2 id=\"1、骨架屏的实现方式\"><a href=\"#1、骨架屏的实现方式\" class=\"headerlink\" title=\"1、骨架屏的实现方式\"></a>1、骨架屏的实现方式</h2><img src=\"https://cdn.julis.wang/blog/img/b911cd8e3eba7fdc4bea89ad6cb07bf4a7d.png\">\n<p>在现在主流的骨架屏实现效果中有两种方式：</p>\n<ul>\n<li><p>通过View或者Adapter的替换来实现骨架屏效果。可以参考<a href=\"https://github.com/sharish/ShimmerRecyclerView\">ShimmerRecyclerView</a>、<a href=\"https://github.com/ethanhua/Skeleton\">Skeleton</a>及<a href=\"https://github.com/willowtreeapps/spruce-android\">spruce-android</a>。</p>\n</li>\n<li><p>自定义一个View来对布局中的View进行一层包裹，当加载数据时则根据View来绘制骨架，否则显示正常UI，参考<a href=\"https://github.com/rasoulmiri/Skeleton\">Skeleton Android</a>。</p>\n</li>\n</ul>\n<p>这些开源库中，自己比较喜欢今天<strong>Skeleton</strong>这个开源库，总结了有如下一些优缺点：</p>\n<p><strong>优点：</strong></p>\n<ol>\n<li>代码方案实现及使用方式简单，通过替换View和Adapter实现效果，使用Builder设计模式来构造。</li>\n<li>代码耦合程度不高。没有复杂的设计模式，使得代码结构清晰明了。</li>\n<li>骨架屏的效果使用相对于较灵活，可以对整个布局实现骨架屏效果，也可以对单一View实现骨架屏效果。</li>\n</ol>\n<p><strong>缺点：</strong></p>\n<ol>\n<li>需要对每个骨架屏效果单独写一套xml布局。</li>\n<li>使用的removeView和addView对 原有布局的view进行替换，存在一定的风险性</li>\n<li>必须清晰的知道所bind的View类型，存在一定的类型转化问题。</li>\n<li>依赖了shimmerlayout第三方库</li>\n</ol>\n<h2 id=\"2、Skeleton解读\"><a href=\"#2、Skeleton解读\" class=\"headerlink\" title=\"2、Skeleton解读\"></a>2、Skeleton解读</h2><p><strong>一、Skeleton的使用方式</strong></p>\n<p>展示骨架屏效果：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">View</span> <span class=\"variable\">rootView</span> <span class=\"operator\">=</span> findViewById(R.id.rootView);</span><br><span class=\"line\">skeletonScreen = Skeleton.bind(rootView)</span><br><span class=\"line\">           .load(R.layout.activity_view_skeleton)<span class=\"comment\">//骨架屏UI</span></span><br><span class=\"line\">           .duration(<span class=\"number\">1000</span>)<span class=\"comment\">//动画时间，以毫秒为单位</span></span><br><span class=\"line\">           .shimmer(<span class=\"literal\">true</span>)<span class=\"comment\">//是否开启动画</span></span><br><span class=\"line\">           .color(R.color.shimmer_color)<span class=\"comment\">//shimmer的颜色</span></span><br><span class=\"line\">           .angle(<span class=\"number\">30</span>)<span class=\"comment\">//shimmer的倾斜角度</span></span><br><span class=\"line\">           .show();</span><br></pre></td></tr></table></figure>\n<p>关闭骨架屏效果并展示原有View：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">skeletonScreen.hide()</span><br></pre></td></tr></table></figure>\n\n<p><strong>流程：</strong></p>\n<p> <strong>1. 选择需要替换的目标view<br> 2. 将骨架效果xml与目标view进行绑定<br> 3. 添加一些效果属性，比如：动画时间、是否开启展示动画、动画颜色等<br> 4. 在合适的实际关闭骨架屏效果</strong></p>\n<p><strong>二、Skeleton源码实现</strong></p>\n<p>Skeleton提供两个绑定方法，分别绑定普通View与RecyclerView，分别返回对应的Builder</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Skeleton</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> RecyclerViewSkeletonScreen.Builder <span class=\"title function_\">bind</span><span class=\"params\">(RecyclerView recyclerView)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">RecyclerViewSkeletonScreen</span>.Builder(recyclerView);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> ViewSkeletonScreen.Builder <span class=\"title function_\">bind</span><span class=\"params\">(View view)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ViewSkeletonScreen</span>.Builder(view);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们首先来看看如何实现与普通View绑定，构造方法中传入目标View，并对shimmer动画效果设置默认的颜色，在Builder里面我们可以看到各种相关参数的设定。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"title function_\">Builder</span><span class=\"params\">(View view)</span> &#123;</span><br><span class=\"line\">\t<span class=\"built_in\">this</span>.mView = view;</span><br><span class=\"line\">\t<span class=\"built_in\">this</span>.mShimmerColor = ContextCompat.getColor(mView.getContext(), R.color.shimmer_color);</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<p>接下来再到show的步骤，主要实现还是由ViewSkeletonScreen来实现</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> ViewSkeletonScreen <span class=\"title function_\">show</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">ViewSkeletonScreen</span> <span class=\"variable\">skeletonScreen</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ViewSkeletonScreen</span>(<span class=\"built_in\">this</span>);</span><br><span class=\"line\">    skeletonScreen.show();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> skeletonScreen;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>其中ViewSkeletonScreen与绑定的RecyclerViewSkeletonScreen都实现了SkeletonScreen接口，SkeletonScreen有两个接口方法分别是   </p>\n<pre><code>void show();\nvoid hide();\n</code></pre>\n<p>对于ViewSkeletonScreen.show()进入源码，这里出现一个比较重要的类<code>ViewReplacer</code>，等下再进行解析，通过show的源码清楚的知道逻辑：<br><strong>1、生成骨架效果View<br>2、利用生成的View替换目标View。</strong><br>其中生成骨架效果View阶段主要还是通过LayoutInflater去加载传入mSkeletonResID</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">show</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">       <span class=\"type\">View</span> <span class=\"variable\">skeletonLoadingView</span> <span class=\"operator\">=</span> generateSkeletonLoadingView();</span><br><span class=\"line\">       <span class=\"keyword\">if</span> (skeletonLoadingView != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">           mViewReplacer.replace(skeletonLoadingView);</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n<p>接下来主要讲解ViewReplacer类，其构造方法传入目标View</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"title function_\">ViewReplacer</span><span class=\"params\">(View sourceView)</span> &#123;</span><br><span class=\"line\">     mSourceView = sourceView;</span><br><span class=\"line\">     mSourceViewLayoutParams = mSourceView.getLayoutParams();</span><br><span class=\"line\">     mCurrentView = mSourceView;</span><br><span class=\"line\">     mSourceViewId = mSourceView.getId();</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n<p>其比较重要的方法有两个：<code>replace()</code> 和 <code>restore()</code> 这两个方法分别为SkeletonScreen 的show()和hide()的最终实现，首先看<code>replace()</code>方法，有两个方法重载，分别传入<code>targetViewResID</code>或者<code>targetView</code>，最终还是会走到<code>replace(View targetView)</code>中。<br>其主要逻辑为：</p>\n<p> <strong>1. 判断所替换的View和骨架屏效果View是否为同一个View<br> 2. remove掉在父布局中的目标View<br> 3. 将骨架屏效果View添加到目标View的父布局中</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">replace</span><span class=\"params\">(<span class=\"type\">int</span> targetViewResID)</span> &#123;</span><br><span class=\"line\">       <span class=\"keyword\">if</span> (mTargetViewResID == targetViewResID) &#123;</span><br><span class=\"line\">           <span class=\"keyword\">return</span>;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       <span class=\"keyword\">if</span> (init()) &#123;</span><br><span class=\"line\">           mTargetViewResID = targetViewResID;</span><br><span class=\"line\">           replace(LayoutInflater.from(mSourceView.getContext()).inflate(mTargetViewResID, mSourceParentView, <span class=\"literal\">false</span>));</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">replace</span><span class=\"params\">(View targetView)</span> &#123;</span><br><span class=\"line\">       <span class=\"keyword\">if</span> (mCurrentView == targetView) &#123;</span><br><span class=\"line\">           <span class=\"keyword\">return</span>;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       <span class=\"keyword\">if</span> (targetView.getParent() != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">           ((ViewGroup) targetView.getParent()).removeView(targetView);</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       <span class=\"keyword\">if</span> (init()) &#123;</span><br><span class=\"line\">           mTargetView = targetView;</span><br><span class=\"line\">           mSourceParentView.removeView(mCurrentView);</span><br><span class=\"line\">           mTargetView.setId(mSourceViewId);</span><br><span class=\"line\">           mSourceParentView.addView(mTargetView, mSourceViewIndexInParent, mSourceViewLayoutParams);</span><br><span class=\"line\">           mCurrentView = mTargetView;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n\n<p>在执行添加到目标View的父布局中，有执行一个init方法，主要做两件事：</p>\n<p> <strong>1. 获取目标View的父View<br> 2. 找到目标View在父View 中的位置索引，为之后添加骨架屏View到父View中做铺垫</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"type\">boolean</span> <span class=\"title function_\">init</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">     <span class=\"keyword\">if</span> (mSourceParentView == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">         mSourceParentView = (ViewGroup) mSourceView.getParent();</span><br><span class=\"line\">         <span class=\"keyword\">if</span> (mSourceParentView == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">             Log.e(TAG, <span class=\"string\">&quot;the source view have not attach to any view&quot;</span>);</span><br><span class=\"line\">             <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">         <span class=\"type\">int</span> <span class=\"variable\">count</span> <span class=\"operator\">=</span> mSourceParentView.getChildCount();</span><br><span class=\"line\">         <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">index</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; index &lt; count; index++) &#123;</span><br><span class=\"line\">             <span class=\"keyword\">if</span> (mSourceView == mSourceParentView.getChildAt(index)) &#123;</span><br><span class=\"line\">                 mSourceViewIndexInParent = index;</span><br><span class=\"line\">                 <span class=\"keyword\">break</span>;</span><br><span class=\"line\">             &#125;</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">     <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n<p>至此对普通View的骨架屏效果实现流程已经完全梳理完成，那对于<code>RecyclerView</code>呢？其实两者实现逻辑差不多，主要有两个差异：</p>\n<ol>\n<li>在<code>RecyclerViewSkeletonScreen</code>的Builder中，相比ViewSkeletonScreen多了一个adapter()方法，传入目标<code>RecyclerView</code>的<code>Adapter</code></li>\n<li>在show的时候对目标<code>RecyclerView</code>的adapter进行替换，使用骨架屏效果的adapter。hide的时候恢复为原先的Adapter</li>\n</ol>\n<h2 id=\"3、总结\"><a href=\"#3、总结\" class=\"headerlink\" title=\"3、总结\"></a>3、总结</h2><ol>\n<li>Skeleton的原理主要是通过替换目标View和RecyclerView的Adapter</li>\n<li>在Skeleton的使用过程中最需要关心的两个问题是：show()和hide()的时机</li>\n<li>对于整个页面的骨架屏效果实现，个人推荐在布局中添加一个全屏的空View盖在原先内容上</li>\n<li>注意一些异常情况下的hide()，要不然整个页面就“假死”状态了。</li>\n</ol>\n<p>参考：<br><a href=\"https://juejin.im/post/5c789a4ce51d457c042d3b31\">https://juejin.im/post/5c789a4ce51d457c042d3b31</a></p>\n","raw":"title: Android骨架屏效果的实现与原理解析\nauthor: 落叶挽歌\nthumbnail: 'https://cdn.pixabay.com/photo/2016/10/28/00/42/machine-1776925_960_720.jpg'\ntags:\n  - Android\ncategories:\n  - 技术文章\ndate: 2019-09-04 17:50:00\n---\n\n\n大家在使用淘宝的时候，如下图所示有遇到这样的效果，其会只展示一部分骨架大致图，等数据加载完毕之后再展示真正的页面数据。与菊花图相比起来，这样的实现能更好的提升用户的体验，这种效果称做：Skeleton Screen Loading，中文叫做**骨架屏**，本文主要记录其实现过程。\n\n## 1、骨架屏的实现方式\n\n{% qnimg b911cd8e3eba7fdc4bea89ad6cb07bf4a7d.png %}\n在现在主流的骨架屏实现效果中有两种方式：\n\n - 通过View或者Adapter的替换来实现骨架屏效果。可以参考[ShimmerRecyclerView](https://github.com/sharish/ShimmerRecyclerView)、[Skeleton](https://github.com/ethanhua/Skeleton)及[spruce-android](https://github.com/willowtreeapps/spruce-android)。\n\n - 自定义一个View来对布局中的View进行一层包裹，当加载数据时则根据View来绘制骨架，否则显示正常UI，参考[Skeleton Android](https://github.com/rasoulmiri/Skeleton)。\n\n这些开源库中，自己比较喜欢今天**Skeleton**这个开源库，总结了有如下一些优缺点：\n\n**优点：**\n\n 1. 代码方案实现及使用方式简单，通过替换View和Adapter实现效果，使用Builder设计模式来构造。\n 2. 代码耦合程度不高。没有复杂的设计模式，使得代码结构清晰明了。\n 3. 骨架屏的效果使用相对于较灵活，可以对整个布局实现骨架屏效果，也可以对单一View实现骨架屏效果。\n\n**缺点：**\n\n 1. 需要对每个骨架屏效果单独写一套xml布局。\n 2. 使用的removeView和addView对 原有布局的view进行替换，存在一定的风险性\n 3. 必须清晰的知道所bind的View类型，存在一定的类型转化问题。\n 4. 依赖了shimmerlayout第三方库\n\n## 2、Skeleton解读\n\n**一、Skeleton的使用方式**\n\n展示骨架屏效果：\n```java\n    View rootView = findViewById(R.id.rootView);\n    skeletonScreen = Skeleton.bind(rootView)\n               .load(R.layout.activity_view_skeleton)//骨架屏UI\n               .duration(1000)//动画时间，以毫秒为单位\n               .shimmer(true)//是否开启动画\n               .color(R.color.shimmer_color)//shimmer的颜色\n               .angle(30)//shimmer的倾斜角度\n               .show();\n```\n关闭骨架屏效果并展示原有View：\n```java\n   \tskeletonScreen.hide()\n```\n\n**流程：**\n\n **1. 选择需要替换的目标view\n 2. 将骨架效果xml与目标view进行绑定\n 3. 添加一些效果属性，比如：动画时间、是否开启展示动画、动画颜色等\n 4. 在合适的实际关闭骨架屏效果**\n\n\n**二、Skeleton源码实现**\n\nSkeleton提供两个绑定方法，分别绑定普通View与RecyclerView，分别返回对应的Builder\n```java\npublic class Skeleton {\n    public static RecyclerViewSkeletonScreen.Builder bind(RecyclerView recyclerView) {\n        return new RecyclerViewSkeletonScreen.Builder(recyclerView);\n    }\n    public static ViewSkeletonScreen.Builder bind(View view) {\n        return new ViewSkeletonScreen.Builder(view);\n    }\n}\n```\n我们首先来看看如何实现与普通View绑定，构造方法中传入目标View，并对shimmer动画效果设置默认的颜色，在Builder里面我们可以看到各种相关参数的设定。\n```java\npublic Builder(View view) {\n\tthis.mView = view;\n\tthis.mShimmerColor = ContextCompat.getColor(mView.getContext(), R.color.shimmer_color);\n  }\n```\n接下来再到show的步骤，主要实现还是由ViewSkeletonScreen来实现\n```java\n public ViewSkeletonScreen show() {\n     ViewSkeletonScreen skeletonScreen = new ViewSkeletonScreen(this);\n     skeletonScreen.show();\n     return skeletonScreen;\n }\n```\n其中ViewSkeletonScreen与绑定的RecyclerViewSkeletonScreen都实现了SkeletonScreen接口，SkeletonScreen有两个接口方法分别是   \n\n    void show();\n    void hide();\n\n对于ViewSkeletonScreen.show()进入源码，这里出现一个比较重要的类`ViewReplacer`，等下再进行解析，通过show的源码清楚的知道逻辑：\n**1、生成骨架效果View  \n2、利用生成的View替换目标View。**\n其中生成骨架效果View阶段主要还是通过LayoutInflater去加载传入mSkeletonResID\n\n```java\n @Override\n public void show() {\n        View skeletonLoadingView = generateSkeletonLoadingView();\n        if (skeletonLoadingView != null) {\n            mViewReplacer.replace(skeletonLoadingView);\n        }\n    }\n```\n接下来主要讲解ViewReplacer类，其构造方法传入目标View\n\n```java\n   public ViewReplacer(View sourceView) {\n        mSourceView = sourceView;\n        mSourceViewLayoutParams = mSourceView.getLayoutParams();\n        mCurrentView = mSourceView;\n        mSourceViewId = mSourceView.getId();\n    }\n```\n其比较重要的方法有两个：`replace()` 和 `restore()` 这两个方法分别为SkeletonScreen 的show()和hide()的最终实现，首先看`replace()`方法，有两个方法重载，分别传入`targetViewResID`或者`targetView`，最终还是会走到`replace(View targetView)`中。\n其主要逻辑为：\n\n **1. 判断所替换的View和骨架屏效果View是否为同一个View\n 2. remove掉在父布局中的目标View\n 3. 将骨架屏效果View添加到目标View的父布局中**\n\n```java\n public void replace(int targetViewResID) {\n        if (mTargetViewResID == targetViewResID) {\n            return;\n        }\n        if (init()) {\n            mTargetViewResID = targetViewResID;\n            replace(LayoutInflater.from(mSourceView.getContext()).inflate(mTargetViewResID, mSourceParentView, false));\n        }\n    }\n\n    public void replace(View targetView) {\n        if (mCurrentView == targetView) {\n            return;\n        }\n        if (targetView.getParent() != null) {\n            ((ViewGroup) targetView.getParent()).removeView(targetView);\n        }\n        if (init()) {\n            mTargetView = targetView;\n            mSourceParentView.removeView(mCurrentView);\n            mTargetView.setId(mSourceViewId);\n            mSourceParentView.addView(mTargetView, mSourceViewIndexInParent, mSourceViewLayoutParams);\n            mCurrentView = mTargetView;\n        }\n    }\n```\n\n在执行添加到目标View的父布局中，有执行一个init方法，主要做两件事：\n\n **1. 获取目标View的父View\n 2. 找到目标View在父View 中的位置索引，为之后添加骨架屏View到父View中做铺垫**\n\n```java\n   private boolean init() {\n        if (mSourceParentView == null) {\n            mSourceParentView = (ViewGroup) mSourceView.getParent();\n            if (mSourceParentView == null) {\n                Log.e(TAG, \"the source view have not attach to any view\");\n                return false;\n            }\n            int count = mSourceParentView.getChildCount();\n            for (int index = 0; index < count; index++) {\n                if (mSourceView == mSourceParentView.getChildAt(index)) {\n                    mSourceViewIndexInParent = index;\n                    break;\n                }\n            }\n        }\n        return true;\n    }\n```\n至此对普通View的骨架屏效果实现流程已经完全梳理完成，那对于`RecyclerView`呢？其实两者实现逻辑差不多，主要有两个差异：\n\n 1. 在`RecyclerViewSkeletonScreen`的Builder中，相比ViewSkeletonScreen多了一个adapter()方法，传入目标`RecyclerView`的`Adapter`\n 2. 在show的时候对目标`RecyclerView`的adapter进行替换，使用骨架屏效果的adapter。hide的时候恢复为原先的Adapter\n\n\n\n\n## 3、总结\n\n 1. Skeleton的原理主要是通过替换目标View和RecyclerView的Adapter\n 2. 在Skeleton的使用过程中最需要关心的两个问题是：show()和hide()的时机\n 3. 对于整个页面的骨架屏效果实现，个人推荐在布局中添加一个全屏的空View盖在原先内容上\n 4. 注意一些异常情况下的hide()，要不然整个页面就“假死”状态了。\n\n\n参考：\nhttps://juejin.im/post/5c789a4ce51d457c042d3b31","categories":[{"name":"技术文章","api":"api/categories/technology.json"}],"tags":[{"name":"Android","api":"api/tags/Android.json"}]},"api":"api/posts/2019/09/04/Android骨架屏效果的实现与原理解析.json"}