{"data":{"title":"一款快速生成安卓shape的插件--NoCodeShape","slug":"一款快速生成Android-shape的插件-NoCodeShape","description":"","date":"2019-11-27T08:06:00.000Z","updated":"2025-05-20T11:46:57.000Z","language":"zh-CN","comments":true,"url":"2019/11/27/一款快速生成Android-shape的插件-NoCodeShape/","cover":null,"images":[],"content":"<p>NoCodeShape 是一个能可视化界面操作生成Android中Shape.xml的Android Studio插件。对于新手能更好的去接受Android中相对应的属性，对于资深程序员则能简化操作，快速生成shape.xml。项目已经开源 <a href=\"https://github.com/VomPom/NoCodeShape\">NoCodeShape</a></p>\n<h1 id=\"二、NoCodeShape使用方法\"><a href=\"#二、NoCodeShape使用方法\" class=\"headerlink\" title=\"二、NoCodeShape使用方法\"></a>二、NoCodeShape使用方法</h1><h2 id=\"1-下载和安装\"><a href=\"#1-下载和安装\" class=\"headerlink\" title=\"1. 下载和安装\"></a>1. 下载和安装</h2><p>同一般的Android Studio插件下载一样，可以直接<code>Preferences-&gt;Plugins</code> 搜索 <code>NoCodeShape</code>搜索出来结果直接安装再重启即可。</p>\n<img width=\"60%\" src=\"https://cdn.julis.wang/blog/img/20191126190001658.png\">\n<p>也可以去jetbrains插件管理的官网下载各个版本的插件<br><a href=\"https://plugins.jetbrains.com/plugin/13325-nocodeshape/versions\">https://plugins.jetbrains.com/plugin/13325-nocodeshape/versions</a><br>然后<code>Preferences-&gt;Plugins</code> 再Install plugins from disk从本地安装</p>\n<h2 id=\"2-如何使用\"><a href=\"#2-如何使用\" class=\"headerlink\" title=\"2. 如何使用\"></a>2. 如何使用</h2><p>在新建一个shape.xml文件后，右键选择NoCodeShape或者直接按快捷键Common+U</p>\n<img src=\"https://cdn.julis.wang/blog/img/20191126192542676.png\">\n<p>然后选择自己想要的属性，随着点击事件的进行会生成相关xml代码，并在Android Studio右边有对应的shape形状的展示。如果对应shape.xml有相关属性，NoCodeShape也会生成对应shape.xml属性的操作界面，非常方便。<br>示例：</p>\n<img src=\"https://cdn.julis.wang/blog/img/20191126192336117.gif\">\n<h1 id=\"三、实现原理\"><a href=\"#三、实现原理\" class=\"headerlink\" title=\"三、实现原理\"></a>三、实现原理</h1><p>实现原理总体来说并不复杂，主要是界面相关操作逻辑比较繁琐。</p>\n<p>对于新生成的一个shape.xml来说只需要弹出一个新的操作界面，用户只需要点击对应模块的属性即可。项目使用了<code>单例模式+Bulider建造者模式</code>去管理各个Shape属性，分别生成 <code>Shape、Solid、Corners、Stroke、Gradient</code>的单例，其内部拥有一个Builder用来去承各类型的具体属性。</p>\n<p>  通过界面的操作，对其内部的<code>Builder</code>进行数据的填充，最后在完成各类操作后，将各类型中的Builder中的所有属性提取出并生成一份完整的xml字符串并将其粘贴到Android Studio的操作界面上。</p>\n<p>实现主要分为两大类：</p>\n<h2 id=\"1-拼接生成xml字符串\"><a href=\"#1-拼接生成xml字符串\" class=\"headerlink\" title=\"1. 拼接生成xml字符串\"></a>1. 拼接生成xml字符串</h2><p>字符串拼接算是其中最复杂的部分，一是各shape的类型拥有较多数据，其中一些属性有逻辑存在性，二是生成最终Android Studio的xml字符串的时候格式存在比较多的处理。对于各类属性都继承于<code>BaseXml</code>，其内部拥有一个静态内部<code>Builder</code>类，以相对简单的Solid类来举例，如下所示：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Solid</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">BaseXml</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Builder builder;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"type\">Solid</span> <span class=\"variable\">instance</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Solid <span class=\"title function_\">getInstance</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (instance == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            builder = <span class=\"keyword\">new</span> <span class=\"title class_\">Builder</span>();</span><br><span class=\"line\">            instance = <span class=\"keyword\">new</span> <span class=\"title class_\">Solid</span>();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\"> <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Builder</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">BaseBuilder</span> &#123;</span><br><span class=\"line\">        String color;</span><br><span class=\"line\">        String colorValue;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">setColor</span><span class=\"params\">(String color)</span> &#123;</span><br><span class=\"line\">            <span class=\"built_in\">this</span>.colorValue = color;</span><br><span class=\"line\">            <span class=\"built_in\">this</span>.color = getAttrWithOutUnitStr(<span class=\"string\">&quot;color&quot;</span>, color);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"keyword\">public</span> String <span class=\"title function_\">getBuilderString</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> StringUtils.getString(color);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">clearData</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">            StringUtils.clearObjectData(<span class=\"built_in\">this</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">analysisAttribute</span><span class=\"params\">(Attributes attributes)</span> &#123;</span><br><span class=\"line\">            Solid.getInstance().setChecked(<span class=\"literal\">true</span>);</span><br><span class=\"line\">            setColor(attributes.getValue(<span class=\"string\">&quot;android:color&quot;</span>));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>其类继承于抽象类BaseXml，代码如下所示：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">class</span> <span class=\"title class_\">BaseXml</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">boolean</span> <span class=\"variable\">isChecked</span> <span class=\"operator\">=</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">getCloser</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot; /&gt;&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">getStartTag</span><span class=\"params\">()</span> &#123; </span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">generateXmlString</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">protected</span> String <span class=\"title function_\">getLineFeedString</span><span class=\"params\">()</span> &#123; </span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;\\n&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">isChecked</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> isChecked;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> BaseXml <span class=\"title function_\">setChecked</span><span class=\"params\">(<span class=\"type\">boolean</span> checked)</span> &#123;</span><br><span class=\"line\">        isChecked = checked;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>抽象类提取出来在字符串拼接阶段，各类型常用的基本操作，例如：返回“&lt;solid”这类的开始标签，” &#x2F;&gt;”结束标签等</p>\n<p>其内部<code>BaseXml</code>拥有对应类拥有的所有属性的常用操作，其继承与抽象类<code>BaseBuilder</code>，代码如下所示</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">class</span> <span class=\"title class_\">BaseBuilder</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> String <span class=\"title function_\">getBuilderString</span><span class=\"params\">()</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title function_\">clearData</span><span class=\"params\">()</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title function_\">analysisAttribute</span><span class=\"params\">(Attributes attributes)</span>;</span><br><span class=\"line\">    <span class=\"keyword\">protected</span> <span class=\"keyword\">final</span> String <span class=\"title function_\">getAttrWithUnitStr</span><span class=\"params\">(String attributeType, String value)</span> &#123;</span><br><span class=\"line\">        String unit;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (TextUtils.isEmpty(value)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"string\">&quot;&quot;</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (value.contains(<span class=\"string\">&quot;px&quot;</span>) || value.contains(<span class=\"string\">&quot;dp&quot;</span>)) &#123;</span><br><span class=\"line\">            unit = <span class=\"string\">&quot;&quot;</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            unit = DefaultData.UNIT;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;android:&quot;</span> + attributeType + <span class=\"string\">&quot;=\\&quot;&quot;</span> + value + unit + <span class=\"string\">&quot;\\&quot;&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">protected</span> <span class=\"keyword\">final</span> String <span class=\"title function_\">getAttrWithOutUnitStr</span><span class=\"params\">(String attributeType, String value)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (TextUtils.isEmpty(value)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"string\">&quot;&quot;</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;android:&quot;</span> + attributeType + <span class=\"string\">&quot;=\\&quot;&quot;</span> + value + <span class=\"string\">&quot;\\&quot;&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">protected</span> <span class=\"keyword\">final</span> String <span class=\"title function_\">getValueOutUnit</span><span class=\"params\">(String value)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (TextUtils.isEmpty(value)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> value;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> value.replace(<span class=\"string\">&quot;dp&quot;</span>, <span class=\"string\">&quot;&quot;</span>).replace(<span class=\"string\">&quot;px&quot;</span>, <span class=\"string\">&quot;&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>BaseBuilder内部封装了一些属性的常用操作，例如生成：<code>android:color=&quot;#FFFFFF&quot;</code>这样的字符串，获取是否带有单位的字串等。<br>并提供三个抽象方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> String <span class=\"title function_\">getBuilderString</span><span class=\"params\">()</span>; <span class=\"comment\">//获取Builder中所有属性拼接好的字符串</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title function_\">clearData</span><span class=\"params\">()</span>; <span class=\"comment\">//清空Builder内部属性值</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title function_\">analysisAttribute</span><span class=\"params\">(Attributes attributes)</span>; <span class=\"comment\">//分析xml数据中的值，这个在第二大点“将原有shape.xml字符串转化为对应操作界面”中将会讲到</span></span><br></pre></td></tr></table></figure>\n\n<p>以上是基本数据的构造，在最后在控件交互的地方会调用<code>CommonAction</code>类的<code>refreshAndWriteData</code>：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">abstract</span> <span class=\"keyword\">class</span> <span class=\"title class_\">CommonAction</span> &#123;</span><br><span class=\"line\">    JComponent component;</span><br><span class=\"line\">    NoShapeDialog noShapeDialog;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">void</span> <span class=\"title function_\">refreshAndWriteData</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        NoCodeShapeAction.callWriteData();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>最后会调用基本的Action中的<code>writeData()</code>方法，其具体逻辑为</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">    * 数据写入xml文件</span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">   <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">writeData</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">       <span class=\"keyword\">final</span> <span class=\"type\">Document</span> <span class=\"variable\">document</span> <span class=\"operator\">=</span> FileDocumentManager.getInstance().getDocument(file);</span><br><span class=\"line\">       <span class=\"keyword\">if</span> (document == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">           <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">               <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Exception</span>(<span class=\"string\">&quot;Document对象为空&quot;</span>);</span><br><span class=\"line\">           &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">               e.printStackTrace();</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">           <span class=\"keyword\">return</span>;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       <span class=\"keyword\">new</span> <span class=\"title class_\">WriteCommandAction</span>.Simple(project) &#123;</span><br><span class=\"line\">           <span class=\"meta\">@Override</span></span><br><span class=\"line\">           <span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">               document.setText(XMLString.getInstance().generateXmlString());</span><br><span class=\"line\">               <span class=\"comment\">//formatCode();</span></span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">       &#125;.execute();</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>利用<code>XMLString.getInstance().generateXmlString()</code>获取各操作类型的所有属性将其拼接为一份完整的shape.xml文件的字段，最后调用插件系统的相关命令将字符串粘贴在系统对应的输入框中。</p>\n<h2 id=\"2-将原有shape-xml字符串转化为对应操作界面\"><a href=\"#2-将原有shape-xml字符串转化为对应操作界面\" class=\"headerlink\" title=\"2. 将原有shape.xml字符串转化为对应操作界面\"></a>2. 将原有shape.xml字符串转化为对应操作界面</h2><p>上面已经讲述类如何拼接生成xml字符串并将其粘贴到Android Studio界面上，此外NoCodeShape不仅支持新生成的shape.xml，同样也支持对旧shape.xml进行修改的能力。与第一步相比较主要多了一步读取Android Studio xml文档并将其转化为对应操作界面的过程。其主要是在操作界面初始化之前执行了如下方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">initSax</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">       <span class=\"type\">String</span> <span class=\"variable\">text</span> <span class=\"operator\">=</span> FileDocumentManager.getInstance().getDocument(file).getText();</span><br><span class=\"line\">       <span class=\"type\">ShapeSaxHandler</span> <span class=\"variable\">handler</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ShapeSaxHandler</span>();</span><br><span class=\"line\">       <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">           handler.createViewList(text);</span><br><span class=\"line\">       &#125; <span class=\"keyword\">catch</span> (ParserConfigurationException e) &#123;</span><br><span class=\"line\">           e.printStackTrace();</span><br><span class=\"line\">       &#125; <span class=\"keyword\">catch</span> (SAXException e) &#123;</span><br><span class=\"line\">           e.printStackTrace();</span><br><span class=\"line\">       &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">           e.printStackTrace();</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n<p>利用ShapeSaxHandler去解析xml里面的元素，参考了<a href=\"https://github.com/laobie/FindViewByMe\">FindViewByMe</a>的解析原理。</p>\n<p>具体操作逻辑如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">createViewList</span><span class=\"params\">(String string)</span> <span class=\"keyword\">throws</span> ParserConfigurationException, SAXException, IOException &#123;</span><br><span class=\"line\">      <span class=\"type\">InputStream</span> <span class=\"variable\">xmlStream</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ByteArrayInputStream</span>(string.getBytes(<span class=\"string\">&quot;UTF-8&quot;</span>));</span><br><span class=\"line\">      <span class=\"type\">SAXParserFactory</span> <span class=\"variable\">factory</span> <span class=\"operator\">=</span> SAXParserFactory.newInstance();</span><br><span class=\"line\">      <span class=\"type\">SAXParser</span> <span class=\"variable\">parser</span> <span class=\"operator\">=</span> factory.newSAXParser();</span><br><span class=\"line\">      parser.parse(xmlStream, <span class=\"built_in\">this</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">startDocument</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> SAXException &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (shapePartList == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">          shapePartList = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;ShapePart&gt;();</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">startElement</span><span class=\"params\">(String uri, String localName, String qName, Attributes attributes)</span> <span class=\"keyword\">throws</span> SAXException &#123;</span><br><span class=\"line\">      <span class=\"keyword\">switch</span> (qName) &#123;</span><br><span class=\"line\">          <span class=\"keyword\">case</span> <span class=\"string\">&quot;shape&quot;</span>:</span><br><span class=\"line\">              Shape.getInstance().getBuilder().analysisAttribute(attributes);</span><br><span class=\"line\">              <span class=\"keyword\">break</span>;</span><br><span class=\"line\">          <span class=\"keyword\">case</span> <span class=\"string\">&quot;stroke&quot;</span>:</span><br><span class=\"line\">              Stroke.getInstance().getBuilder().analysisAttribute(attributes);</span><br><span class=\"line\">              <span class=\"keyword\">break</span>;</span><br><span class=\"line\">          <span class=\"keyword\">case</span> <span class=\"string\">&quot;solid&quot;</span>:</span><br><span class=\"line\">             Solid.getInstance().getBuilder().analysisAttribute(attributes);</span><br><span class=\"line\">              <span class=\"keyword\">break</span>;</span><br><span class=\"line\">          <span class=\"keyword\">case</span> <span class=\"string\">&quot;gradient&quot;</span>:</span><br><span class=\"line\">              Gradient.getInstance().getBuilder().analysisAttribute(attributes);</span><br><span class=\"line\">              <span class=\"keyword\">break</span>;</span><br><span class=\"line\">          <span class=\"keyword\">case</span> <span class=\"string\">&quot;corners&quot;</span>:</span><br><span class=\"line\">              Corners.getInstance().getBuilder().analysisAttribute(attributes);</span><br><span class=\"line\">              <span class=\"keyword\">break</span>;</span><br><span class=\"line\">          <span class=\"keyword\">default</span>:</span><br><span class=\"line\">              <span class=\"keyword\">break</span>;</span><br><span class=\"line\">      &#125;</span><br></pre></td></tr></table></figure>\n<p>逻辑其实很清楚，主要对startTag的判断，然后通过调用 <code>public abstract void analysisAttribute(Attributes attributes);</code>的方法对相应的 类型的Buidler进行一个赋值操作。</p>\n<p>以Stroke为例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">analysisAttribute</span><span class=\"params\">(Attributes attributes)</span> &#123;</span><br><span class=\"line\">            Stroke.getInstance().setChecked(<span class=\"literal\">true</span>);</span><br><span class=\"line\">            setColor(attributes.getValue(<span class=\"string\">&quot;android:color&quot;</span>));</span><br><span class=\"line\">            setDashGap(attributes.getValue(<span class=\"string\">&quot;android:dashGap&quot;</span>));</span><br><span class=\"line\">            setWidth(attributes.getValue(<span class=\"string\">&quot;android:width&quot;</span>));</span><br><span class=\"line\">            setDashWidth(attributes.getValue(<span class=\"string\">&quot;android:dashWidth&quot;</span>));</span><br><span class=\"line\">        &#125;</span><br></pre></td></tr></table></figure>\n<p>主要是获取到其中的属性，并对初始化的界面进行一些操作(例如选中或者赋值相关操作)。</p>\n<h1 id=\"四、总结\"><a href=\"#四、总结\" class=\"headerlink\" title=\"四、总结\"></a>四、总结</h1><p>这个插件算是自己第一次做一个相对较实用的插件，都是利用工作的空闲事件进行编写，前前后后进行了将近一个月，其中收获颇多，但也踩过了各种各样的坑。在开发过程中由于相关文档较少，通过阅读官方文档还是有点小吃力，不过一步步还是走了下来，自己也得到了成长。其中坑也都添平了，但由于一些基础技术的欠缺，比如对Java GUI界面编程不太熟悉，导致开发过程中有很大一段时间都在跟界面作对，因此后面有机会将去深入了解Java的界面编程，争取能够将页面交互能够做到更好。</p>\n<p>另外由于自身开发精力的原因，不能将插件做到完美，目前插件中还有如下几个问题：</p>\n<p>1、Gradient中对应相关逻辑还需要再优化<br>2、还未支持Size跟Pading（从自身所处环境考虑用得较少，所以暂未支持）<br>3、对于颜色选择器默认打开后不支持对本地颜色字符串处理<br>4、存在大量的界面操作逻辑代码，需要优化</p>\n<p>最后，希望大家能在使用过程中提出相关的意见或建议，也欢迎能一起加入到开发中，从而能将该插件做得更加完美。</p>\n<p>项目地址：</p>\n<p><a href=\"https://github.com/VomPom/NoCodeShape\">https://github.com/VomPom/NoCodeShape</a></p>\n","raw":"title: 一款快速生成安卓shape的插件--NoCodeShape\nauthor: 落叶挽歌\nthumbnail: 'https://cdn.pixabay.com/photo/2017/09/25/11/55/cyberspace-2784907_960_720.jpg'\ntags:\n  - 插件\ncategories:\n  - 技术文章\ndate: 2019-11-27 16:06:00\n---\n\n\nNoCodeShape 是一个能可视化界面操作生成Android中Shape.xml的Android Studio插件。对于新手能更好的去接受Android中相对应的属性，对于资深程序员则能简化操作，快速生成shape.xml。项目已经开源 [NoCodeShape](https://github.com/VomPom/NoCodeShape)\n\n# 二、NoCodeShape使用方法\n\n## 1. 下载和安装\n\n同一般的Android Studio插件下载一样，可以直接`Preferences->Plugins` 搜索 `NoCodeShape`搜索出来结果直接安装再重启即可。\n{% qnimg 20191126190001658.png width:60% %}\n也可以去jetbrains插件管理的官网下载各个版本的插件\n[https://plugins.jetbrains.com/plugin/13325-nocodeshape/versions](https://plugins.jetbrains.com/plugin/13325-nocodeshape/versions)  \n然后`Preferences->Plugins` 再Install plugins from disk从本地安装\n\n\n## 2. 如何使用\n\n在新建一个shape.xml文件后，右键选择NoCodeShape或者直接按快捷键Common+U\n\n{% qnimg 20191126192542676.png %}\n然后选择自己想要的属性，随着点击事件的进行会生成相关xml代码，并在Android Studio右边有对应的shape形状的展示。如果对应shape.xml有相关属性，NoCodeShape也会生成对应shape.xml属性的操作界面，非常方便。\n示例：\n\n{% qnimg 20191126192336117.gif %}\n# 三、实现原理\n\n\n\n实现原理总体来说并不复杂，主要是界面相关操作逻辑比较繁琐。\n\n对于新生成的一个shape.xml来说只需要弹出一个新的操作界面，用户只需要点击对应模块的属性即可。项目使用了`单例模式+Bulider建造者模式`去管理各个Shape属性，分别生成 `Shape、Solid、Corners、Stroke、Gradient`的单例，其内部拥有一个Builder用来去承各类型的具体属性。\n\n  通过界面的操作，对其内部的`Builder`进行数据的填充，最后在完成各类操作后，将各类型中的Builder中的所有属性提取出并生成一份完整的xml字符串并将其粘贴到Android Studio的操作界面上。\n  \n实现主要分为两大类：\n\n## 1. 拼接生成xml字符串\n\n字符串拼接算是其中最复杂的部分，一是各shape的类型拥有较多数据，其中一些属性有逻辑存在性，二是生成最终Android Studio的xml字符串的时候格式存在比较多的处理。对于各类属性都继承于`BaseXml`，其内部拥有一个静态内部`Builder`类，以相对简单的Solid类来举例，如下所示：\n\n```java\npublic class Solid extends BaseXml {\n\n    private static Builder builder;\n    private static Solid instance = null;\n\n    public static Solid getInstance() {\n        if (instance == null) {\n            builder = new Builder();\n            instance = new Solid();\n        }\n        return instance;\n    }\n    \n public static class Builder extends BaseBuilder {\n        String color;\n        String colorValue;\n\n        public void setColor(String color) {\n            this.colorValue = color;\n            this.color = getAttrWithOutUnitStr(\"color\", color);\n        }\n        @Override\n        public String getBuilderString() {\n            return StringUtils.getString(color);\n        }\n\n        @Override\n        public void clearData() {\n            StringUtils.clearObjectData(this);\n        }\n\n        @Override\n        public void analysisAttribute(Attributes attributes) {\n            Solid.getInstance().setChecked(true);\n            setColor(attributes.getValue(\"android:color\"));\n        }\n    }\n```\n其类继承于抽象类BaseXml，代码如下所示：\n```java\npublic abstract class BaseXml {\n    private boolean isChecked = false;\n    public String getCloser() {\n        return \" />\";\n    }\n    public String getStartTag() { \n        return \"\";\n    }\n    public String generateXmlString() {\n        return \"\";\n    }\n    protected String getLineFeedString() { \n        return \"\\n\";\n    }\n    public boolean isChecked() {\n        return isChecked;\n    }\n    public BaseXml setChecked(boolean checked) {\n        isChecked = checked;\n        return this;\n    }\n}\n```\n抽象类提取出来在字符串拼接阶段，各类型常用的基本操作，例如：返回“<solid”这类的开始标签，\" />\"结束标签等\n\n其内部`BaseXml`拥有对应类拥有的所有属性的常用操作，其继承与抽象类`BaseBuilder`，代码如下所示\n\n```java\npublic abstract class BaseBuilder {\n    public abstract String getBuilderString();\n    public abstract void clearData();\n    public abstract void analysisAttribute(Attributes attributes);\n    protected final String getAttrWithUnitStr(String attributeType, String value) {\n        String unit;\n        if (TextUtils.isEmpty(value)) {\n            return \"\";\n        }\n        if (value.contains(\"px\") || value.contains(\"dp\")) {\n            unit = \"\";\n        } else {\n            unit = DefaultData.UNIT;\n        }\n        return \"android:\" + attributeType + \"=\\\"\" + value + unit + \"\\\"\";\n    }\n    protected final String getAttrWithOutUnitStr(String attributeType, String value) {\n        if (TextUtils.isEmpty(value)) {\n            return \"\";\n        }\n        return \"android:\" + attributeType + \"=\\\"\" + value + \"\\\"\";\n    }\n    protected final String getValueOutUnit(String value) {\n        if (TextUtils.isEmpty(value)) {\n            return value;\n        }\n        return value.replace(\"dp\", \"\").replace(\"px\", \"\");\n    }\n}\n\n```\nBaseBuilder内部封装了一些属性的常用操作，例如生成：`android:color=\"#FFFFFF\"`这样的字符串，获取是否带有单位的字串等。\n并提供三个抽象方法：\n\n```java\n   public abstract String getBuilderString(); //获取Builder中所有属性拼接好的字符串\n   public abstract void clearData(); //清空Builder内部属性值\n   public abstract void analysisAttribute(Attributes attributes); //分析xml数据中的值，这个在第二大点“将原有shape.xml字符串转化为对应操作界面”中将会讲到\n```\n\n以上是基本数据的构造，在最后在控件交互的地方会调用`CommonAction`类的`refreshAndWriteData`：\n\n```java\nabstract class CommonAction {\n    JComponent component;\n    NoShapeDialog noShapeDialog;\n\n    void refreshAndWriteData() {\n        NoCodeShapeAction.callWriteData();\n    }\n}\n```\n最后会调用基本的Action中的`writeData()`方法，其具体逻辑为\n```java\n /**\n     * 数据写入xml文件\n     */\n    private static void writeData() {\n        final Document document = FileDocumentManager.getInstance().getDocument(file);\n        if (document == null) {\n            try {\n                throw new Exception(\"Document对象为空\");\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n            return;\n        }\n        new WriteCommandAction.Simple(project) {\n            @Override\n            protected void run() {\n                document.setText(XMLString.getInstance().generateXmlString());\n                //formatCode();\n            }\n        }.execute();\n    }\n\n```\n利用`XMLString.getInstance().generateXmlString()`获取各操作类型的所有属性将其拼接为一份完整的shape.xml文件的字段，最后调用插件系统的相关命令将字符串粘贴在系统对应的输入框中。\n\n## 2. 将原有shape.xml字符串转化为对应操作界面\n\n\t\n\n上面已经讲述类如何拼接生成xml字符串并将其粘贴到Android Studio界面上，此外NoCodeShape不仅支持新生成的shape.xml，同样也支持对旧shape.xml进行修改的能力。与第一步相比较主要多了一步读取Android Studio xml文档并将其转化为对应操作界面的过程。其主要是在操作界面初始化之前执行了如下方法：\n\n```java\n private void initSax() {\n        String text = FileDocumentManager.getInstance().getDocument(file).getText();\n        ShapeSaxHandler handler = new ShapeSaxHandler();\n        try {\n            handler.createViewList(text);\n        } catch (ParserConfigurationException e) {\n            e.printStackTrace();\n        } catch (SAXException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n```\n利用ShapeSaxHandler去解析xml里面的元素，参考了[FindViewByMe](https://github.com/laobie/FindViewByMe)的解析原理。\n\n具体操作逻辑如下：\n\n```java\n  public void createViewList(String string) throws ParserConfigurationException, SAXException, IOException {\n        InputStream xmlStream = new ByteArrayInputStream(string.getBytes(\"UTF-8\"));\n        SAXParserFactory factory = SAXParserFactory.newInstance();\n        SAXParser parser = factory.newSAXParser();\n        parser.parse(xmlStream, this);\n    }\n    @Override\n    public void startDocument() throws SAXException {\n        if (shapePartList == null) {\n            shapePartList = new ArrayList<ShapePart>();\n        }\n    }\n    @Override\n    public void startElement(String uri, String localName, String qName, Attributes attributes) throws SAXException {\n        switch (qName) {\n            case \"shape\":\n                Shape.getInstance().getBuilder().analysisAttribute(attributes);\n                break;\n            case \"stroke\":\n                Stroke.getInstance().getBuilder().analysisAttribute(attributes);\n                break;\n            case \"solid\":\n               Solid.getInstance().getBuilder().analysisAttribute(attributes);\n                break;\n            case \"gradient\":\n                Gradient.getInstance().getBuilder().analysisAttribute(attributes);\n                break;\n            case \"corners\":\n                Corners.getInstance().getBuilder().analysisAttribute(attributes);\n                break;\n            default:\n                break;\n        }\n```\n逻辑其实很清楚，主要对startTag的判断，然后通过调用 `public abstract void analysisAttribute(Attributes attributes);`的方法对相应的 类型的Buidler进行一个赋值操作。\n\n以Stroke为例：\n\n```java\n@Override\n        public void analysisAttribute(Attributes attributes) {\n            Stroke.getInstance().setChecked(true);\n            setColor(attributes.getValue(\"android:color\"));\n            setDashGap(attributes.getValue(\"android:dashGap\"));\n            setWidth(attributes.getValue(\"android:width\"));\n            setDashWidth(attributes.getValue(\"android:dashWidth\"));\n        }\n```\n主要是获取到其中的属性，并对初始化的界面进行一些操作(例如选中或者赋值相关操作)。\n\n\n\n# 四、总结\n这个插件算是自己第一次做一个相对较实用的插件，都是利用工作的空闲事件进行编写，前前后后进行了将近一个月，其中收获颇多，但也踩过了各种各样的坑。在开发过程中由于相关文档较少，通过阅读官方文档还是有点小吃力，不过一步步还是走了下来，自己也得到了成长。其中坑也都添平了，但由于一些基础技术的欠缺，比如对Java GUI界面编程不太熟悉，导致开发过程中有很大一段时间都在跟界面作对，因此后面有机会将去深入了解Java的界面编程，争取能够将页面交互能够做到更好。\n\n另外由于自身开发精力的原因，不能将插件做到完美，目前插件中还有如下几个问题：\n\n1、Gradient中对应相关逻辑还需要再优化\n2、还未支持Size跟Pading（从自身所处环境考虑用得较少，所以暂未支持）\n3、对于颜色选择器默认打开后不支持对本地颜色字符串处理\n4、存在大量的界面操作逻辑代码，需要优化\n\n\n最后，希望大家能在使用过程中提出相关的意见或建议，也欢迎能一起加入到开发中，从而能将该插件做得更加完美。\n\n项目地址：\n\n[https://github.com/VomPom/NoCodeShape](https://github.com/VomPom/NoCodeShape)","categories":[{"name":"技术文章","api":"api/categories/technology.json"}],"tags":[{"name":"插件","api":"api/tags/插件.json"}]},"api":"api/posts/2019/11/27/一款快速生成Android-shape的插件-NoCodeShape.json"}