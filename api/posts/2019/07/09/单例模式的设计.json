{"data":{"title":"单例模式的设计","slug":"单例模式的设计","description":"","date":"2019-07-09T01:56:00.000Z","updated":"2025-05-20T11:46:57.000Z","language":"zh-CN","comments":true,"url":"2019/07/09/单例模式的设计/","cover":null,"images":[],"content":"<p>原文回答于知乎(<a href=\"https://www.zhihu.com/question/277243683/answer/392772061\">如何把一段简单的代码变复杂？ - 落叶挽歌的回答</a>)</p>\n<p>我们都知道单例模式很简单，大概是这样：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//单线程单例模式实现</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Singleton</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Singleton instance=<span class=\"literal\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Singleton <span class=\"title function_\">getInstance</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(<span class=\"literal\">null</span>==instance)&#123;</span><br><span class=\"line\">            instance = <span class=\"keyword\">new</span> <span class=\"title class_\">Singleton</span>();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>但是呢，在多线程条件下getInstance()并不是一个原子操作。由于代码没有使用任何同步机制，因此该线程可能会出现线程交错的情形：在instance还是null的时候，如果两个线程同时执行到 if(null&#x3D;&#x3D;instance)那么会创建两个实例，从而违背了初衷。于是通过简单加锁来解决这种问题：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//简单加锁实现单例模式</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Singleton</span>  &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Singleton instance=<span class=\"literal\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Singleton <span class=\"title function_\">getInstance</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span> (Singleton.class)&#123;<span class=\"comment\">//加入synchronized同步</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(<span class=\"literal\">null</span>==instance)&#123;</span><br><span class=\"line\">                instance = <span class=\"keyword\">new</span> <span class=\"title class_\">Singleton</span>();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这种方式实现单例模式固然安全，但意味着每次调用 getInstance()都会申请锁，为了避免开销，我们想到了另一种办法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//基于双重检查锁定的错误单例模式实现</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Singleton</span>  &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Singleton instance=<span class=\"literal\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Singleton <span class=\"title function_\">getInstance</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(<span class=\"literal\">null</span>==instance)&#123;<span class=\"comment\">//先检查是否为null，再执行之上的代码</span></span><br><span class=\"line\">            <span class=\"keyword\">synchronized</span> (Singleton.class)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(<span class=\"literal\">null</span>==instance)&#123;</span><br><span class=\"line\">                    instance = <span class=\"keyword\">new</span> <span class=\"title class_\">Singleton</span>();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>通过这种方法，虽然第一次检查对变量instance的访问没有加锁从而使竞态仍然可能存在，它似乎避免了锁的开销又保障了线程的安全。然后对 instance &#x3D; new Singleton();进行伪代码独立子操作：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">obj=allocate(Singleton.class);<span class=\"comment\">//1、分配对象所需的存储空间</span></span><br><span class=\"line\">invokeConstructor(obj);<span class=\"comment\">//2、初始化obj的引用对象</span></span><br><span class=\"line\">instance=obj;<span class=\"comment\">//3、将对象引用写入共享变量</span></span><br></pre></td></tr></table></figure>\n<p>由于重排序的规则，临界区内的操作可以再临界区内重排序，因此JIT编译器可能将上述子操作重排序为：1-&gt;3-&gt;2，即在初始化对象之前将对象引用写入实例变量instace。由于锁对有序性的保障是有条件的，而操作1读取intance变量的时候并没有加锁，因此重排序是对1操作是有影响的：该线程可能看到一个未初始化（或者为初始化完毕）的实例，即intance不为null。于是该线程直接就直接返回这个instance变量所引用的实例，而实例可能是未初始化完毕的，这就是可能导致程序出错。明白问题的原因之后，解决方法也不难想到了：<strong>只需将instance变量加入volatile修饰则可</strong>。于是代码变成：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//基于双重检查锁定的正确单例模式实现</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Singleton</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">volatile</span> Singleton instance=<span class=\"literal\">null</span>;<span class=\"comment\">//加入volatile修饰</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Singleton <span class=\"title function_\">getInstance</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(<span class=\"literal\">null</span>==instance)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">synchronized</span> (Singleton.class)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(<span class=\"literal\">null</span>==instance)&#123;</span><br><span class=\"line\">                    instance = <span class=\"keyword\">new</span> <span class=\"title class_\">Singleton</span>();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>到此为止，才正确实现安全的“单例模式”。</p>\n<p>参考：《黄文海-Java多线程编程实战指南（核心篇）》</p>\n","raw":"title: 单例模式的设计\nauthor: 落叶挽歌\nthumbnail: 'https://cdn.pixabay.com/photo/2016/06/29/22/02/city-1487891_960_720.jpg'\ntags:\n  - 设计模式\ncategories:\n  - 技术文章\ndate: 2019-07-09 09:56:00\n---\n原文回答于知乎([如何把一段简单的代码变复杂？ - 落叶挽歌的回答](https://www.zhihu.com/question/277243683/answer/392772061))\n\n我们都知道单例模式很简单，大概是这样：\n\n```java\n//单线程单例模式实现\npublic class Singleton {\n    private static Singleton instance=null;\n    public static Singleton getInstance() {\n        if(null==instance){\n            instance = new Singleton();\n        }\n        return instance;\n    }\n}\n```\n\n但是呢，在多线程条件下getInstance()并不是一个原子操作。由于代码没有使用任何同步机制，因此该线程可能会出现线程交错的情形：在instance还是null的时候，如果两个线程同时执行到 if(null==instance)那么会创建两个实例，从而违背了初衷。于是通过简单加锁来解决这种问题：\n```java\n//简单加锁实现单例模式\npublic class Singleton  {\n    private static Singleton instance=null;\n    public static Singleton getInstance() {\n        synchronized (Singleton.class){//加入synchronized同步\n            if(null==instance){\n                instance = new Singleton();\n            }\n            return instance;\n        }\n    }\n}\n```\n这种方式实现单例模式固然安全，但意味着每次调用 getInstance()都会申请锁，为了避免开销，我们想到了另一种办法：\n```java\n//基于双重检查锁定的错误单例模式实现\npublic class Singleton  {\n    private static Singleton instance=null;\n    public static Singleton getInstance() {\n        if(null==instance){//先检查是否为null，再执行之上的代码\n            synchronized (Singleton.class){\n                if(null==instance){\n                    instance = new Singleton();\n                }\n            }\n        }\n        return instance;\n    }\n}\n```\n通过这种方法，虽然第一次检查对变量instance的访问没有加锁从而使竞态仍然可能存在，它似乎避免了锁的开销又保障了线程的安全。然后对 instance = new Singleton();进行伪代码独立子操作：\n```java\nobj=allocate(Singleton.class);//1、分配对象所需的存储空间\ninvokeConstructor(obj);//2、初始化obj的引用对象\ninstance=obj;//3、将对象引用写入共享变量\n```\n由于重排序的规则，临界区内的操作可以再临界区内重排序，因此JIT编译器可能将上述子操作重排序为：1->3->2，即在初始化对象之前将对象引用写入实例变量instace。由于锁对有序性的保障是有条件的，而操作1读取intance变量的时候并没有加锁，因此重排序是对1操作是有影响的：该线程可能看到一个未初始化（或者为初始化完毕）的实例，即intance不为null。于是该线程直接就直接返回这个instance变量所引用的实例，而实例可能是未初始化完毕的，这就是可能导致程序出错。明白问题的原因之后，解决方法也不难想到了：**只需将instance变量加入volatile修饰则可**。于是代码变成：\n```java\n//基于双重检查锁定的正确单例模式实现\npublic class Singleton {\n    private static volatile Singleton instance=null;//加入volatile修饰\n    public static Singleton getInstance() {\n        if(null==instance){\n            synchronized (Singleton.class){\n                if(null==instance){\n                    instance = new Singleton();\n                }\n            }\n        }\n        return instance;\n    }\n}\n```\n到此为止，才正确实现安全的“单例模式”。\n\n参考：《黄文海-Java多线程编程实战指南（核心篇）》","categories":[{"name":"技术文章","api":"api/categories/technology.json"}],"tags":[{"name":"设计模式","api":"api/tags/design.json"}]},"api":"api/posts/2019/07/09/单例模式的设计.json"}