{"data":{"title":"Android监听截屏事件之媒体读取的探索","slug":"Android监听截屏事件之媒体读取的探索","description":"","date":"2019-07-02T09:58:00.000Z","updated":"2025-05-20T11:46:57.000Z","language":"zh-CN","comments":true,"url":"2019/07/02/Android监听截屏事件之媒体读取的探索/","cover":null,"images":[],"content":"<p>最近做了一个需求：监听用户截屏，然后生成相关海报。<br>参考了<a href=\"https://blog.csdn.net/xietansheng/article/details/52692163\" title=\"Android 截屏事件监听\">Android 截屏事件监听</a>的文章，大致思路是：</p>\n<p>1、利用ContentObserver用来监听指定Uri的所有资源变化,当媒体库中有相关图片新增的时候，则发送相关的通知。</p>\n<p>2、得到回调的Uri后，借助ContentResolver在媒体数据库中查询最后一条数据</p>\n<p>3、对数据做一些过滤。比如短时间重复截屏的情况以及其他App也插入了媒体文件等情况做处理。</p>\n<p>不过有一些适配性的问题：</p>\n<p>1、截屏后读取文件数据库后获取到件的绝对路径后，利用“screenshot”等关键字判断是否是截屏图片，并不能适配所有手机截屏的命名规则，以及其他应用同时间产生带有“screenshot”等关键词的文件也会有问题。</p>\n<p>2、在某些型号手机中(现遇到Vivo)从数据库中读取的文件并不是获取到的最新的截屏文件，而且其他目录的文件，这里就有些难以理解了，所以今天取探究一下媒体数据库的读取。</p>\n<p>其中ContentObserver如下代码所示：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">   * 媒体内容观察者(观察媒体数据库的改变)</span></span><br><span class=\"line\"><span class=\"comment\">   */</span></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">class</span> <span class=\"title class_\">MediaContentObserver</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">ContentObserver</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">private</span> Uri mContentUri;</span><br><span class=\"line\">      <span class=\"keyword\">public</span> <span class=\"title function_\">MediaContentObserver</span><span class=\"params\">(Uri contentUri, Handler handler)</span> &#123;</span><br><span class=\"line\">          <span class=\"built_in\">super</span>(handler);</span><br><span class=\"line\">          mContentUri = contentUri;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      [<span class=\"meta\">@Override</span>](https:<span class=\"comment\">//my.oschina.net/u/1162528)</span></span><br><span class=\"line\">      <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">onChange</span><span class=\"params\">(<span class=\"type\">boolean</span> selfChange)</span> &#123;</span><br><span class=\"line\">          <span class=\"built_in\">super</span>.onChange(selfChange);</span><br><span class=\"line\">          handleMediaContentChange(mContentUri);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<p>其中获取最后一次更新的媒体文件时的代码(为便于查看 删除了判空处理代码)：<br> <figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">\t<span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">    * 处理媒体数据库的内容改变</span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">   <span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">handleMediaContentChange</span><span class=\"params\">(Uri contentUri)</span> &#123;</span><br><span class=\"line\">       <span class=\"type\">Cursor</span> <span class=\"variable\">cursor</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">       <span class=\"comment\">/** 读取媒体数据库时需要读取的列 */</span></span><br><span class=\"line\">       <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String[] MEDIA_PROJECTIONS =  &#123;</span><br><span class=\"line\">           MediaStore.Images.ImageColumns.DATA,</span><br><span class=\"line\">           MediaStore.Images.ImageColumns.DATE_TAKEN &#125;;</span><br><span class=\"line\">       <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">           <span class=\"comment\">// 数据改变时查询数据库中最后加入的一条数据</span></span><br><span class=\"line\">           cursor = mContext.getContentResolver().query(</span><br><span class=\"line\">                   contentUri,</span><br><span class=\"line\">                    MEDIA_PROJECTIONS,</span><br><span class=\"line\">                   <span class=\"literal\">null</span>,</span><br><span class=\"line\">                   <span class=\"literal\">null</span>,</span><br><span class=\"line\">                   MediaStore.Images.ImageColumns.DATE_ADDED + <span class=\"string\">&quot; desc limit 1&quot;</span></span><br><span class=\"line\">           );</span><br><span class=\"line\">           <span class=\"comment\">// 获取各列的索引</span></span><br><span class=\"line\">           <span class=\"type\">int</span> <span class=\"variable\">dataIndex</span> <span class=\"operator\">=</span> cursor.getColumnIndex(MediaStore.Images.ImageColumns.DATA);</span><br><span class=\"line\">           <span class=\"type\">int</span> <span class=\"variable\">dateTakenIndex</span> <span class=\"operator\">=</span> cursor.getColumnIndex(MediaStore.Images.ImageColumns.DATE_TAKEN);</span><br><span class=\"line\"></span><br><span class=\"line\">           <span class=\"comment\">// 获取行数据</span></span><br><span class=\"line\">           <span class=\"type\">String</span> <span class=\"variable\">data</span> <span class=\"operator\">=</span> cursor.getString(dataIndex);</span><br><span class=\"line\">           <span class=\"type\">long</span> <span class=\"variable\">dateTaken</span> <span class=\"operator\">=</span> cursor.getLong(dateTakenIndex);</span><br><span class=\"line\"></span><br><span class=\"line\">           <span class=\"comment\">// 处理获取到的第一行数据</span></span><br><span class=\"line\">           handleMediaRowData(data, dateTaken);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>这次的目的主要探究的是从数据库获取相关信息的过程</p>\n<p><strong>1、Android 的多媒体如何存储？</strong></p>\n<p>Android的多媒体文件主要存储在 &#x2F;data&#x2F;data&#x2F;com.android.providers.media&#x2F;databases 目录下，该目录下有连个db文件：</p>\n<p>内部存储数据库文件：internal.db</p>\n<p>存储卡数据库：external-XXXX.db</p>\n<p>媒体文件的操作主要是围绕着这两个数据库来进行，这两个数据库的结构是一样的。</p>\n<p>这两个数据库包含这些表：<br>album_art 、audio 、search 、album_info 、audio_genres、 searchhelpertitle、albums、 audio_genres_map、 thumbnails、<br>android_metadata、 audio_meta、 video、artist_info 、audio_playlists 、videothumbnails、artists 、audio_playlists_map、<br>artists_albums_map 、images</p>\n<p><strong>2、表的结构</strong><br>对于Images表：主要存储images信息。表结构如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">CREATE TABLE <span class=\"title function_\">images</span> <span class=\"params\">(</span></span><br><span class=\"line\"><span class=\"params\">   _id INTEGER PRIMARY KEY, </span></span><br><span class=\"line\"><span class=\"params\">   _data TEXT,</span></span><br><span class=\"line\"><span class=\"params\">   _size INTEGER,</span></span><br><span class=\"line\"><span class=\"params\">   _display_name TEXT,</span></span><br><span class=\"line\"><span class=\"params\">   mime_type TEXT,</span></span><br><span class=\"line\"><span class=\"params\">   title TEXT, </span></span><br><span class=\"line\"><span class=\"params\">   date_added INTEGER, </span></span><br><span class=\"line\"><span class=\"params\">   date_modified INTEGER,</span></span><br><span class=\"line\"><span class=\"params\">   description TEXT,</span></span><br><span class=\"line\"><span class=\"params\">   picasa_id TEXT,</span></span><br><span class=\"line\"><span class=\"params\">   isprivate INTEGER,</span></span><br><span class=\"line\"><span class=\"params\">   latitude DOUBLE, </span></span><br><span class=\"line\"><span class=\"params\">   longitude DOUBLE, </span></span><br><span class=\"line\"><span class=\"params\">   datetaken INTEGER, </span></span><br><span class=\"line\"><span class=\"params\">   orientation INTEGER, </span></span><br><span class=\"line\"><span class=\"params\">   mini_thumb_magic INTEGER, </span></span><br><span class=\"line\"><span class=\"params\">   bucket_id TEXT, </span></span><br><span class=\"line\"><span class=\"params\">   bucket_display_name TEXT )</span>;</span><br></pre></td></tr></table></figure>\n\n<p>各字段所表示意思，如图所示：</p>\n<img src=\"https://cdn.julis.wang/blog/img/2eb1be5d3ece2831fa9ca6d00678bf520a7.jpg\">\n\n<p><em>图片来自：<a href=\"https://blog.csdn.net/love_xsq/article/details/50387747\" title=\"Android MediaProvider数据库模式说明\">Android MediaProvider数据库模式说明</a></em></p>\n<p>所以在截屏监听数据的时候所读取的数据库返回值，分别为：</p>\n<p>_data  :图片据对路径</p>\n<p>datetaken：取子EXIF照片拍摄事件，空的话为文件修改时间</p>\n<pre><code>  private static final String[] MEDIA_PROJECTIONS =  &#123;\n        MediaStore.Images.ImageColumns.DATA,\n        MediaStore.Images.ImageColumns.DATE_TAKEN &#125;;\n</code></pre>\n<p>在查询过程中构造的数据库代码为：</p>\n<pre><code>public final Cursor query (Uri uri, \n\tString[] projection,\n\tString selection, \n\tString[] selectionArgs, \n\tString sortOrder)\n</code></pre>\n<p>&#96;<br>其中对应的构造参数官方解释为：</p>\n<blockquote>\n<p>uri\tThe URI, using the content:&#x2F;&#x2F; scheme, for the content to retrieve.</p>\n</blockquote>\n<blockquote>\n<p>projection\tA list of which columns to return. Passing null will return all columns, which is inefficient.  </p>\n</blockquote>\n<blockquote>\n<p>selection\tA filter declaring which rows to return, formatted as an SQL WHERE clause (excluding the WHERE itself). Passing null will return all rows for the given URI.</p>\n</blockquote>\n<blockquote>\n<p>selectionArgs\tYou may include ?s in selection, which will be replaced by the values from selectionArgs, in the order that they appear in the selection. The values will be bound as Strings.</p>\n</blockquote>\n<blockquote>\n<p>sortOrder\tHow to order the rows, formatted as an SQL ORDER BY clause (excluding the ORDER BY itself). Passing null will use the default sort order, which may be unordered.</p>\n</blockquote>\n<hr>\n<p>所以参数依次为：<br>所要查找的目标、所要的返回值、条件限制(类似sql中where)、匹配项、排序规则</p>\n<p>所以这里的查询就显而易见了：获取最新图片数据库下data和datatoken列的数据</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">cursor = mContext.getContentResolver().query(</span><br><span class=\"line\">                 contentUri,</span><br><span class=\"line\">                 MEDIA_PROJECTIONS,</span><br><span class=\"line\">                 <span class=\"literal\">null</span>,</span><br><span class=\"line\">                 <span class=\"literal\">null</span>,</span><br><span class=\"line\">                 MediaStore.Images.ImageColumns.DATE_ADDED + <span class=\"string\">&quot; desc limit 1&quot;</span></span><br><span class=\"line\">         );</span><br></pre></td></tr></table></figure>\n<p>然而…并不能解释vivo手机为什么查找出来不是最新截图的图片的问题</p>\n","raw":"title: Android监听截屏事件之媒体读取的探索\nauthor: 落叶挽歌\nthumbnail: 'https://cdn.pixabay.com/photo/2018/02/16/10/52/beverage-3157395_960_720.jpg'\ntags:\n  - 安卓\ncategories:\n  - 技术文章\ndate: 2019-07-02 17:58:00\n---\n最近做了一个需求：监听用户截屏，然后生成相关海报。\n参考了[Android 截屏事件监听](https://blog.csdn.net/xietansheng/article/details/52692163 \"Android 截屏事件监听\")的文章，大致思路是：\n\n1、利用ContentObserver用来监听指定Uri的所有资源变化,当媒体库中有相关图片新增的时候，则发送相关的通知。\n\n2、得到回调的Uri后，借助ContentResolver在媒体数据库中查询最后一条数据\n\n3、对数据做一些过滤。比如短时间重复截屏的情况以及其他App也插入了媒体文件等情况做处理。\n\n不过有一些适配性的问题：\n\n1、截屏后读取文件数据库后获取到件的绝对路径后，利用“screenshot”等关键字判断是否是截屏图片，并不能适配所有手机截屏的命名规则，以及其他应用同时间产生带有“screenshot”等关键词的文件也会有问题。\n\n2、在某些型号手机中(现遇到Vivo)从数据库中读取的文件并不是获取到的最新的截屏文件，而且其他目录的文件，这里就有些难以理解了，所以今天取探究一下媒体数据库的读取。\n\n其中ContentObserver如下代码所示：\n```java\n\t /**\n     * 媒体内容观察者(观察媒体数据库的改变)\n     */\n    private class MediaContentObserver extends ContentObserver {\n        private Uri mContentUri;\n        public MediaContentObserver(Uri contentUri, Handler handler) {\n            super(handler);\n            mContentUri = contentUri;\n        }\n        [@Override](https://my.oschina.net/u/1162528)\n        public void onChange(boolean selfChange) {\n            super.onChange(selfChange);\n            handleMediaContentChange(mContentUri);\n        }\n    }\n```\n\t\n其中获取最后一次更新的媒体文件时的代码(为便于查看 删除了判空处理代码)：\n ```java\n \t/**\n     * 处理媒体数据库的内容改变\n     */\n    private void handleMediaContentChange(Uri contentUri) {\n        Cursor cursor = null;\n        /** 读取媒体数据库时需要读取的列 */\n        private static final String[] MEDIA_PROJECTIONS =  {\n            MediaStore.Images.ImageColumns.DATA,\n            MediaStore.Images.ImageColumns.DATE_TAKEN };\n        try {\n            // 数据改变时查询数据库中最后加入的一条数据\n            cursor = mContext.getContentResolver().query(\n                    contentUri,\n                     MEDIA_PROJECTIONS,\n                    null,\n                    null,\n                    MediaStore.Images.ImageColumns.DATE_ADDED + \" desc limit 1\"\n            );\n            // 获取各列的索引\n            int dataIndex = cursor.getColumnIndex(MediaStore.Images.ImageColumns.DATA);\n            int dateTakenIndex = cursor.getColumnIndex(MediaStore.Images.ImageColumns.DATE_TAKEN);\n\n            // 获取行数据\n            String data = cursor.getString(dataIndex);\n            long dateTaken = cursor.getLong(dateTakenIndex);\n\n            // 处理获取到的第一行数据\n            handleMediaRowData(data, dateTaken);\n\t}\n```\t\n这次的目的主要探究的是从数据库获取相关信息的过程\n\n**1、Android 的多媒体如何存储？**\n\nAndroid的多媒体文件主要存储在 /data/data/com.android.providers.media/databases 目录下，该目录下有连个db文件：\n\n内部存储数据库文件：internal.db\n\n存储卡数据库：external-XXXX.db\n\n媒体文件的操作主要是围绕着这两个数据库来进行，这两个数据库的结构是一样的。\n\n这两个数据库包含这些表：\nalbum_art 、audio 、search 、album_info 、audio_genres、 searchhelpertitle、albums、 audio_genres_map、 thumbnails、\nandroid_metadata、 audio_meta、 video、artist_info 、audio_playlists 、videothumbnails、artists 、audio_playlists_map、\nartists_albums_map 、images\n\n**2、表的结构**\n对于Images表：主要存储images信息。表结构如下：\n```java\n\tCREATE TABLE images (\n    _id INTEGER PRIMARY KEY, \n    _data TEXT,\n    _size INTEGER,\n    _display_name TEXT,\n    mime_type TEXT,\n    title TEXT, \n    date_added INTEGER, \n    date_modified INTEGER,\n    description TEXT,\n    picasa_id TEXT,\n    isprivate INTEGER,\n    latitude DOUBLE, \n    longitude DOUBLE, \n    datetaken INTEGER, \n    orientation INTEGER, \n    mini_thumb_magic INTEGER, \n    bucket_id TEXT, \n    bucket_display_name TEXT );\n```\n\n各字段所表示意思，如图所示：\n\n{% qnimg 2eb1be5d3ece2831fa9ca6d00678bf520a7.jpg %}\n\n*图片来自：[Android MediaProvider数据库模式说明](https://blog.csdn.net/love_xsq/article/details/50387747 \"Android MediaProvider数据库模式说明\")*\n\n所以在截屏监听数据的时候所读取的数据库返回值，分别为：\n\n_data  :图片据对路径\n\ndatetaken：取子EXIF照片拍摄事件，空的话为文件修改时间\n\n      private static final String[] MEDIA_PROJECTIONS =  {\n            MediaStore.Images.ImageColumns.DATA,\n            MediaStore.Images.ImageColumns.DATE_TAKEN };\n\n\n在查询过程中构造的数据库代码为：\n\n\tpublic final Cursor query (Uri uri, \n\t\tString[] projection,\n\t\tString selection, \n\t\tString[] selectionArgs, \n\t\tString sortOrder)\n`\n其中对应的构造参数官方解释为：\n\n> uri\tThe URI, using the content:// scheme, for the content to retrieve.\n\n> projection\tA list of which columns to return. Passing null will return all columns, which is inefficient.  \n\n> selection\tA filter declaring which rows to return, formatted as an SQL WHERE clause (excluding the WHERE itself). Passing null will return all rows for the given URI.\n\n> selectionArgs\tYou may include ?s in selection, which will be replaced by the values from selectionArgs, in the order that they appear in the selection. The values will be bound as Strings.\n\n> sortOrder\tHow to order the rows, formatted as an SQL ORDER BY clause (excluding the ORDER BY itself). Passing null will use the default sort order, which may be unordered.\n\n--------------------- \n\n所以参数依次为：\n所要查找的目标、所要的返回值、条件限制(类似sql中where)、匹配项、排序规则\n\n所以这里的查询就显而易见了：获取最新图片数据库下data和datatoken列的数据\n```java\n \t cursor = mContext.getContentResolver().query(\n                    contentUri,\n                    MEDIA_PROJECTIONS,\n                    null,\n                    null,\n                    MediaStore.Images.ImageColumns.DATE_ADDED + \" desc limit 1\"\n            );\n```\n然而...并不能解释vivo手机为什么查找出来不是最新截图的图片的问题","categories":[{"name":"技术文章","api":"api/categories/technology.json"}],"tags":[{"name":"安卓","api":"api/tags/Android.json"}]},"api":"api/posts/2019/07/02/Android监听截屏事件之媒体读取的探索.json"}