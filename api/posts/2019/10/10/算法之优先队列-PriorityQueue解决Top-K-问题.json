{"data":{"title":"(转)算法之优先队列 PriorityQueue解决Top K 问题","slug":"算法之优先队列-PriorityQueue解决Top-K-问题","description":"","date":"2019-10-10T01:51:00.000Z","updated":"2025-05-20T11:46:57.000Z","language":"zh-CN","comments":true,"url":"2019/10/10/算法之优先队列-PriorityQueue解决Top-K-问题/","cover":null,"images":[],"content":"<p>转自：<a href=\"https://www.jianshu.com/p/a4a1984fc4ff\">https://www.jianshu.com/p/a4a1984fc4ff</a></p>\n<p>解决方法：<br>维护一个大小为 K 的小顶堆，依次将数据放入堆中，当堆的大小满了的时候，只需要将堆顶元素与下一个数比较：如果大于堆顶元素，则将当前的堆顶元素抛弃，并将该元素插入堆中。遍历完全部数据，Top K 的元素也自然都在堆里面了。</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/8807674-d32bc53ef9cadc8d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/770/format/webp\"></p>\n<p>当然，如果是求前 K 个最小的数，只需要改为大顶堆即可</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/8807674-e67fb606d0f5766a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/776/format/webp\"></p>\n<p> 将数据插入堆  95 大于 20，进行替换 95 下沉，维持小顶堆<br>对于海量数据，我们不需要一次性将全部数据取出来，可以一次只取一部分，因为我们只需要将数据一个个拿来与堆顶比较。</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/8807674-15eac9a1c7fb75e2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/788/format/webp\"></p>\n<p>另外还有一个优势就是对于动态数组，我们可以一直都维护一个 K 大小的小顶堆，当有数据被添加到集合中时，我们就直接拿它与堆顶的元素对比。这样，无论任何时候需要查询当前的前 K 大数据，我们都可以里立刻返回给他。</p>\n<p>整个操作中，遍历数组需要 O(n) 的时间复杂度，一次堆化操作需要 O(logK)，加起来就是 O(nlogK) 的复杂度，换个角度来看，如果 K 远小于 n 的话， O(nlogK) 其实就接近于 O(n) 了，甚至会更快，因此也是十分高效的。</p>\n<p>最后，对于 Java，我们可以直接使用优先队列 PriorityQueue 来实现一个小顶堆，这里给个代码：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">public static List&lt;Integer&gt; solutionByHeap(int[] input, int k) &#123;</span><br><span class=\"line\">        List&lt;Integer&gt; list = new ArrayList&lt;&gt;();</span><br><span class=\"line\">        if (k &gt; input.length || k == 0) &#123;</span><br><span class=\"line\">            return list;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        Queue&lt;Integer&gt; queue = new PriorityQueue&lt;&gt;();</span><br><span class=\"line\">        for (int num : input) &#123;</span><br><span class=\"line\">            if (queue.size() &lt; k) &#123;</span><br><span class=\"line\">                queue.add(num);</span><br><span class=\"line\">            &#125; else if (queue.peek() &lt; num) &#123;</span><br><span class=\"line\">                queue.poll();</span><br><span class=\"line\">                queue.add(num);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        while (k-- &gt; 0) &#123;</span><br><span class=\"line\">            list.add(queue.poll());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return list;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>","raw":"title: (转)算法之优先队列 PriorityQueue解决Top K 问题\nauthor: 落叶挽歌\nthumbnail: 'https://cdn.pixabay.com/photo/2015/12/27/05/48/turntable-1109588_960_720.jpg'\ntags:\n  - 算法\ncategories:\n  - 算法研究\ndate: 2019-10-10 09:51:00\n---\n转自：https://www.jianshu.com/p/a4a1984fc4ff\n\n\n解决方法：\n维护一个大小为 K 的小顶堆，依次将数据放入堆中，当堆的大小满了的时候，只需要将堆顶元素与下一个数比较：如果大于堆顶元素，则将当前的堆顶元素抛弃，并将该元素插入堆中。遍历完全部数据，Top K 的元素也自然都在堆里面了。\n\n![](https://upload-images.jianshu.io/upload_images/8807674-d32bc53ef9cadc8d.png?imageMogr2/auto-orient/strip|imageView2/2/w/770/format/webp)\n\n当然，如果是求前 K 个最小的数，只需要改为大顶堆即可\n\n![](https://upload-images.jianshu.io/upload_images/8807674-e67fb606d0f5766a.png?imageMogr2/auto-orient/strip|imageView2/2/w/776/format/webp)\n\n 将数据插入堆  95 大于 20，进行替换 95 下沉，维持小顶堆\n对于海量数据，我们不需要一次性将全部数据取出来，可以一次只取一部分，因为我们只需要将数据一个个拿来与堆顶比较。\n\n![](https://upload-images.jianshu.io/upload_images/8807674-15eac9a1c7fb75e2.png?imageMogr2/auto-orient/strip|imageView2/2/w/788/format/webp)\n\n另外还有一个优势就是对于动态数组，我们可以一直都维护一个 K 大小的小顶堆，当有数据被添加到集合中时，我们就直接拿它与堆顶的元素对比。这样，无论任何时候需要查询当前的前 K 大数据，我们都可以里立刻返回给他。\n\n整个操作中，遍历数组需要 O(n) 的时间复杂度，一次堆化操作需要 O(logK)，加起来就是 O(nlogK) 的复杂度，换个角度来看，如果 K 远小于 n 的话， O(nlogK) 其实就接近于 O(n) 了，甚至会更快，因此也是十分高效的。\n\n最后，对于 Java，我们可以直接使用优先队列 PriorityQueue 来实现一个小顶堆，这里给个代码：\n\n```\npublic static List<Integer> solutionByHeap(int[] input, int k) {\n        List<Integer> list = new ArrayList<>();\n        if (k > input.length || k == 0) {\n            return list;\n        }\n        Queue<Integer> queue = new PriorityQueue<>();\n        for (int num : input) {\n            if (queue.size() < k) {\n                queue.add(num);\n            } else if (queue.peek() < num) {\n                queue.poll();\n                queue.add(num);\n            }\n        }\n        while (k-- > 0) {\n            list.add(queue.poll());\n        }\n        return list;\n    }\n```","categories":[{"name":"算法研究","api":"api/categories/算法研究.json"}],"tags":[{"name":"算法","api":"api/tags/algorithm.json"}]},"api":"api/posts/2019/10/10/算法之优先队列-PriorityQueue解决Top-K-问题.json"}