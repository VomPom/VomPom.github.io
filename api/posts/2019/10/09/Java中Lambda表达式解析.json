{"data":{"title":"Java中Lambda表达式解析","slug":"Java中Lambda表达式解析","description":"","date":"2019-10-09T10:55:00.000Z","updated":"2025-05-20T11:46:57.000Z","language":"zh-CN","comments":true,"url":"2019/10/09/Java中Lambda表达式解析/","cover":null,"images":[],"content":"<p>在大部分开发者看来，Lambda 表达式只是一种语法糖，简化了书写匿名内部类的写法。实际上Lambda表达式并不仅仅是匿名内部类的语法糖，JVM内部是通过invokedynamic指令来实现Lambda表达式的，与内部类的实现有很大的差异。本文主要记录lambda的实现原理。</p>\n<h2 id=\"一、函数式接口\"><a href=\"#一、函数式接口\" class=\"headerlink\" title=\"一、函数式接口\"></a><strong>一、函数式接口</strong></h2><p>众所周知Javascript具有一个强大的特性：<strong>闭包</strong>。Java中最接近闭包概念的东西就是lambda表达式了，而Lambda为Java添加了缺失函数式编程的特点。所以什么是函数是接口呢？</p>\n<p>函数式接口需满足以下两个条件：</p>\n<ol>\n<li>它是接口</li>\n<li>这个接口<strong>有且仅有一个抽象方法</strong></li>\n</ol>\n<p>例如我们常用的：Runnable、View.OnClickListener、Comparable等都是函数式接口，因为它们都只有一个方法，而且都是抽象的。虽然只有一个抽象方法，是不是就意味着只能有一个方法呢？实际并不是，虽然有且仅有一个抽象方法，但是可以有多个非抽象方法的接口。</p>\n<p>嗯？！Java接口中难道还可以定义非抽象方法么？平时我们的接口大概长这样：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">IdiomSubmitListener</span> &#123;</span><br><span class=\"line\">   \t<span class=\"keyword\">void</span> <span class=\"title function_\">verifyResult</span><span class=\"params\">(String result)</span>;</span><br><span class=\"line\">   \t<span class=\"keyword\">void</span> <span class=\"title function_\">onSuceess</span><span class=\"params\">()</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>那接口的非抽象方法是啥？原来在JDK 1.8 对于接口而言具有以下新特性：<br><strong>接口可以定义非抽象方法，但必须使用default或者staic关键字来修饰</strong><br>具体细节点可以参考 <a href=\"https://blog.csdn.net/austral/article/details/53402476\">JAVA 8新特性 允许接口定义非抽象方法 快速入门案例</a></p>\n<p>如果一个接口符合函数式接口的定义，那么我们就可以在该接口上面声明FunctionalInterface注解，用来表示该接口是一个函数式接口，并按照函数式接口的规范在编译的时候对该接口进行检查。</p>\n<p>当然如果某个接口只有一个抽象方法，但我们并没有给该接口声明FunctionalInterface注解，那么编译器依旧会将该接口看做是函数式接口。</p>\n<p>那Lambda表达式跟函数式接口又有什么关联呢？<br>在JDK 1.8中，Lambda表达式是对象，而不是函数，它们必须依附于一类特别的对象类型–函数式接口。</p>\n<p>因此可以说 在JDK 1.8中，Lambda表达式就是一个函数式接口的实例。<br><strong>所以如果一个实例是函数式接口的实例，那么该对象就可以用Lambda表达式来表示</strong></p>\n<h2 id=\"二、Lambda表达式与匿名内部类\"><a href=\"#二、Lambda表达式与匿名内部类\" class=\"headerlink\" title=\"二、Lambda表达式与匿名内部类\"></a><strong>二、Lambda表达式与匿名内部类</strong></h2><p>我们知道代码IDE如果是在JDK1.8的环境下，使用匿名内部类作为一个参数传入到方法中，编译器会提示我们：<code>Anonymous new Runnable() can be replaced with lambda</code>，匿名内部类XXX可以替换为lambda表达式。</p>\n<p>如下所示，匿名内部类 Runnable是一个函数式接口的实例，所以我们可以用lambda表达式来将之替换，从而将代码变得更加简洁。<br><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly9vc2NpbWcub3NjaGluYS5uZXQvb3NjbmV0Lzc4YzgxZWMyZjkzMmE5MDhmOTcxM2NiZGM5ODRkOGFhMWI2LmpwZw?x-oss-process=image/format,png\"></p>\n<img src=\"https://cdn.julis.wang/blog/img/20191009170329915.png\">\n<p>那么我们是否就认为：Lambda表达式只是为匿名内部类中提供的一种语法糖，他们有什么区别呢？底层原理是完全一样的呢？</p>\n<p>他们主要区别如下：</p>\n<p>1、关键字this。匿名内部类的this指向匿名类，而Lambda表达式的this指向被Lambda包围的外部类</p>\n<p>2、编译方式。Java编译器将Lambda表达式编译成类的私有方法，使用Java7的invokedynamic字节码动态绑定这个方法。而匿名内部类将编译成<strong>外部类$数字编号</strong>的新类。这也造成第1点关键字this指向不同地方的原因。</p>\n<h2 id=\"三、Lambda实现原理\"><a href=\"#三、Lambda实现原理\" class=\"headerlink\" title=\"三、Lambda实现原理\"></a><strong>三、Lambda实现原理</strong></h2><p>我们知道如果使用匿名内部类，编译期间会生成一个外部类$数字编号的类，如图所示：</p>\n<img src=\"https://cdn.julis.wang/blog/img/20191009172403269.png\">\n\n<p>而如果使用Lambda表达式进行编译后并没有生成新类。</p>\n<img src=\"https://cdn.julis.wang/blog/img/20191009172455212.png\">\n<p>我们对Lambda表达式生成的class文件使用：javap -p -v Test.class 进行反编译生成如下内容，为便于观察，删除了一些无用内容</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">wang</span>.julis.jwbase.basecompact.Test</span><br><span class=\"line\"></span><br><span class=\"line\">Constant pool:</span><br><span class=\"line\">   #<span class=\"number\">1</span> = Methodref          #<span class=\"number\">9.</span>#<span class=\"number\">18</span>         <span class=\"comment\">// java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> wang.julis.jwbase.basecompact.Test();</span><br><span class=\"line\">    descriptor: ()V</span><br><span class=\"line\">    flags: (<span class=\"number\">0x0001</span>) ACC_PUBLIC</span><br><span class=\"line\">    Code:</span><br><span class=\"line\">      stack=<span class=\"number\">1</span>, locals=<span class=\"number\">1</span>, args_size=<span class=\"number\">1</span></span><br><span class=\"line\">         <span class=\"number\">0</span>: aload_0</span><br><span class=\"line\">         <span class=\"number\">1</span>: invokespecial #<span class=\"number\">1</span>                  <span class=\"comment\">// Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class=\"line\">         <span class=\"number\">4</span>: <span class=\"keyword\">return</span></span><br><span class=\"line\">      LineNumberTable:</span><br><span class=\"line\">        line <span class=\"number\">12</span>: <span class=\"number\">0</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">testLambda</span><span class=\"params\">()</span>;</span><br><span class=\"line\">    descriptor: ()V</span><br><span class=\"line\">    flags: (<span class=\"number\">0x0002</span>) ACC_PRIVATE</span><br><span class=\"line\">    Code:</span><br><span class=\"line\">      stack=<span class=\"number\">3</span>, locals=<span class=\"number\">1</span>, args_size=<span class=\"number\">1</span></span><br><span class=\"line\">         <span class=\"number\">0</span>: <span class=\"keyword\">new</span>           #<span class=\"number\">2</span>                  <span class=\"comment\">// class java/lang/Thread</span></span><br><span class=\"line\">         <span class=\"number\">3</span>: dup</span><br><span class=\"line\">         <span class=\"number\">4</span>: invokedynamic #<span class=\"number\">3</span>,  <span class=\"number\">0</span>              <span class=\"comment\">// InvokeDynamic #0:run:()Ljava/lang/Runnable;</span></span><br><span class=\"line\">         <span class=\"number\">9</span>: invokespecial #<span class=\"number\">4</span>                  <span class=\"comment\">// Method java/lang/Thread.&quot;&lt;init&gt;&quot;:(Ljava/lang/Runnable;)V</span></span><br><span class=\"line\">        <span class=\"number\">12</span>: pop</span><br><span class=\"line\">        <span class=\"number\">13</span>: <span class=\"keyword\">return</span></span><br><span class=\"line\">      LineNumberTable:</span><br><span class=\"line\">        line <span class=\"number\">14</span>: <span class=\"number\">0</span></span><br><span class=\"line\">        line <span class=\"number\">18</span>: <span class=\"number\">13</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> lambda$testLambda$<span class=\"number\">0</span>();</span><br><span class=\"line\">    descriptor: ()V</span><br><span class=\"line\">    flags: (<span class=\"number\">0x100a</span>) ACC_PRIVATE, ACC_STATIC, ACC_SYNTHETIC</span><br><span class=\"line\">    Code:</span><br><span class=\"line\">      stack=<span class=\"number\">2</span>, locals=<span class=\"number\">0</span>, args_size=<span class=\"number\">0</span></span><br><span class=\"line\">         <span class=\"number\">0</span>: getstatic     #<span class=\"number\">5</span>                  <span class=\"comment\">// Field java/lang/System.out:Ljava/io/PrintStream;</span></span><br><span class=\"line\">         <span class=\"number\">3</span>: ldc           #<span class=\"number\">6</span>                  <span class=\"comment\">// String lambda</span></span><br><span class=\"line\">         <span class=\"number\">5</span>: invokevirtual #<span class=\"number\">7</span>                  <span class=\"comment\">// Method java/io/PrintStream.println:(Ljava/lang/String;)V</span></span><br><span class=\"line\">         <span class=\"number\">8</span>: <span class=\"keyword\">return</span></span><br><span class=\"line\">      LineNumberTable:</span><br><span class=\"line\">        line <span class=\"number\">15</span>: <span class=\"number\">0</span></span><br><span class=\"line\">        line <span class=\"number\">16</span>: <span class=\"number\">8</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">SourceFile: <span class=\"string\">&quot;Test.java&quot;</span></span><br><span class=\"line\">InnerClasses:</span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> #<span class=\"number\">50</span>= #<span class=\"number\">49</span> of #<span class=\"number\">53</span>;    <span class=\"comment\">// Lookup=class java/lang/invoke/MethodHandles$Lookup of class java/lang/invoke/MethodHandles</span></span><br><span class=\"line\">BootstrapMethods:</span><br><span class=\"line\">  <span class=\"number\">0</span>: #<span class=\"number\">21</span> REF_invokeStatic java/lang/invoke/LambdaMetafactory.metafactory:(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite;</span><br><span class=\"line\">    Method arguments:</span><br><span class=\"line\">      #<span class=\"number\">22</span> ()V</span><br><span class=\"line\">      #<span class=\"number\">23</span> REF_invokeStatic wang/julis/jwbase/basecompact/Test.lambda$testLambda$<span class=\"number\">0</span>:()V</span><br><span class=\"line\">      #<span class=\"number\">22</span> ()V</span><br></pre></td></tr></table></figure>\n<p>从反编译的结果我们可以看到：</p>\n<p>1、编译期间自动生成私有静态类<code>lambda$testLambda$0</code>而这里面就就是lambda的具体实现逻辑</p>\n<p>2、使用invokedynamic去执行lambda表达式 关于invokedynamic命令具体细节可以参考： <a href=\"https://time.geekbang.org/column/article/12564\">08 | JVM是怎么实现invokedynamic的？（上）</a></p>\n<p>3、lambda表达式编译后并没有生成外部类$数字编号的类</p>\n<h2 id=\"总结：\"><a href=\"#总结：\" class=\"headerlink\" title=\"总结：\"></a>总结：</h2><p>1、函数式接口：有且仅有一个抽象方法，可以用非抽象方法1.8后支持</p>\n<p>2、匿名内部类的this指向匿名类，而Lambda表达式的this指向被Lambda包围的外部类</p>\n<p>3、lambda表达式编译后不会生成外部类$数字编号的类</p>\n<p>4、Java编译器将Lambda表达式编译成类的私有方法，使用Java7的invokedynamic字节码动态绑定这个方法。</p>\n<p>参考：<br>1、《深入探索Android热修复技术原理》2.3.8章节<br>2、<a href=\"https://blog.csdn.net/zw19910924/article/details/75907348\">Java8 lambda表达式、函数式接口、方法引用</a></p>\n","raw":"title: Java中Lambda表达式解析\nauthor: 落叶挽歌\nthumbnail: 'https://cdn.pixabay.com/photo/2016/12/09/22/10/programming-1896158_960_720.jpg'\ntags:\n  - Java\ncategories:\n  - 技术文章\ndate: 2019-10-09 18:55:00\n---\n在大部分开发者看来，Lambda 表达式只是一种语法糖，简化了书写匿名内部类的写法。实际上Lambda表达式并不仅仅是匿名内部类的语法糖，JVM内部是通过invokedynamic指令来实现Lambda表达式的，与内部类的实现有很大的差异。本文主要记录lambda的实现原理。\n\n\n\n## **一、函数式接口**\n\n众所周知Javascript具有一个强大的特性：**闭包**。Java中最接近闭包概念的东西就是lambda表达式了，而Lambda为Java添加了缺失函数式编程的特点。所以什么是函数是接口呢？\n\n函数式接口需满足以下两个条件：\n1. 它是接口\n2. 这个接口**有且仅有一个抽象方法**\n\n例如我们常用的：Runnable、View.OnClickListener、Comparable等都是函数式接口，因为它们都只有一个方法，而且都是抽象的。虽然只有一个抽象方法，是不是就意味着只能有一个方法呢？实际并不是，虽然有且仅有一个抽象方法，但是可以有多个非抽象方法的接口。\n\n嗯？！Java接口中难道还可以定义非抽象方法么？平时我们的接口大概长这样：\n```java\n\tpublic interface IdiomSubmitListener {\n    \tvoid verifyResult(String result);\n    \tvoid onSuceess();\n\t}\n```\n那接口的非抽象方法是啥？原来在JDK 1.8 对于接口而言具有以下新特性：\n**接口可以定义非抽象方法，但必须使用default或者staic关键字来修饰**\n具体细节点可以参考 [JAVA 8新特性 允许接口定义非抽象方法 快速入门案例](https://blog.csdn.net/austral/article/details/53402476)\n\n如果一个接口符合函数式接口的定义，那么我们就可以在该接口上面声明FunctionalInterface注解，用来表示该接口是一个函数式接口，并按照函数式接口的规范在编译的时候对该接口进行检查。\n\n当然如果某个接口只有一个抽象方法，但我们并没有给该接口声明FunctionalInterface注解，那么编译器依旧会将该接口看做是函数式接口。\n\n那Lambda表达式跟函数式接口又有什么关联呢？\n在JDK 1.8中，Lambda表达式是对象，而不是函数，它们必须依附于一类特别的对象类型--函数式接口。\n\n因此可以说 在JDK 1.8中，Lambda表达式就是一个函数式接口的实例。\n**所以如果一个实例是函数式接口的实例，那么该对象就可以用Lambda表达式来表示**\n\n\n## **二、Lambda表达式与匿名内部类**\n\n我们知道代码IDE如果是在JDK1.8的环境下，使用匿名内部类作为一个参数传入到方法中，编译器会提示我们：`Anonymous new Runnable() can be replaced with lambda`，匿名内部类XXX可以替换为lambda表达式。\n\n如下所示，匿名内部类 Runnable是一个函数式接口的实例，所以我们可以用lambda表达式来将之替换，从而将代码变得更加简洁。\n![](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9vc2NpbWcub3NjaGluYS5uZXQvb3NjbmV0Lzc4YzgxZWMyZjkzMmE5MDhmOTcxM2NiZGM5ODRkOGFhMWI2LmpwZw?x-oss-process=image/format,png)\n\n{% qnimg 20191009170329915.png %}\n那么我们是否就认为：Lambda表达式只是为匿名内部类中提供的一种语法糖，他们有什么区别呢？底层原理是完全一样的呢？\n\n他们主要区别如下：\n\n1、关键字this。匿名内部类的this指向匿名类，而Lambda表达式的this指向被Lambda包围的外部类\n\n2、编译方式。Java编译器将Lambda表达式编译成类的私有方法，使用Java7的invokedynamic字节码动态绑定这个方法。而匿名内部类将编译成**外部类$数字编号**的新类。这也造成第1点关键字this指向不同地方的原因。\n\n\n\n\n## **三、Lambda实现原理**\n我们知道如果使用匿名内部类，编译期间会生成一个外部类$数字编号的类，如图所示：\n\n{% qnimg 20191009172403269.png %}\n\n而如果使用Lambda表达式进行编译后并没有生成新类。\n\n{% qnimg 20191009172455212.png %}\n我们对Lambda表达式生成的class文件使用：javap -p -v Test.class 进行反编译生成如下内容，为便于观察，删除了一些无用内容\n```java\npublic class wang.julis.jwbase.basecompact.Test\n\nConstant pool:\n   #1 = Methodref          #9.#18         // java/lang/Object.\"<init>\":()V\n{\n  public wang.julis.jwbase.basecompact.Test();\n    descriptor: ()V\n    flags: (0x0001) ACC_PUBLIC\n    Code:\n      stack=1, locals=1, args_size=1\n         0: aload_0\n         1: invokespecial #1                  // Method java/lang/Object.\"<init>\":()V\n         4: return\n      LineNumberTable:\n        line 12: 0\n\n  private void testLambda();\n    descriptor: ()V\n    flags: (0x0002) ACC_PRIVATE\n    Code:\n      stack=3, locals=1, args_size=1\n         0: new           #2                  // class java/lang/Thread\n         3: dup\n         4: invokedynamic #3,  0              // InvokeDynamic #0:run:()Ljava/lang/Runnable;\n         9: invokespecial #4                  // Method java/lang/Thread.\"<init>\":(Ljava/lang/Runnable;)V\n        12: pop\n        13: return\n      LineNumberTable:\n        line 14: 0\n        line 18: 13\n\n  private static void lambda$testLambda$0();\n    descriptor: ()V\n    flags: (0x100a) ACC_PRIVATE, ACC_STATIC, ACC_SYNTHETIC\n    Code:\n      stack=2, locals=0, args_size=0\n         0: getstatic     #5                  // Field java/lang/System.out:Ljava/io/PrintStream;\n         3: ldc           #6                  // String lambda\n         5: invokevirtual #7                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V\n         8: return\n      LineNumberTable:\n        line 15: 0\n        line 16: 8\n}\nSourceFile: \"Test.java\"\nInnerClasses:\n  public static final #50= #49 of #53;    // Lookup=class java/lang/invoke/MethodHandles$Lookup of class java/lang/invoke/MethodHandles\nBootstrapMethods:\n  0: #21 REF_invokeStatic java/lang/invoke/LambdaMetafactory.metafactory:(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite;\n    Method arguments:\n      #22 ()V\n      #23 REF_invokeStatic wang/julis/jwbase/basecompact/Test.lambda$testLambda$0:()V\n      #22 ()V\n```\n从反编译的结果我们可以看到：\n\n1、编译期间自动生成私有静态类`lambda$testLambda$0`而这里面就就是lambda的具体实现逻辑\n\n2、使用invokedynamic去执行lambda表达式 关于invokedynamic命令具体细节可以参考： [08 | JVM是怎么实现invokedynamic的？（上）](https://time.geekbang.org/column/article/12564)\n\n3、lambda表达式编译后并没有生成外部类$数字编号的类\n\n\n\n\n## 总结：\n\n1、函数式接口：有且仅有一个抽象方法，可以用非抽象方法1.8后支持\n\n2、匿名内部类的this指向匿名类，而Lambda表达式的this指向被Lambda包围的外部类\n\n3、lambda表达式编译后不会生成外部类$数字编号的类\n\n4、Java编译器将Lambda表达式编译成类的私有方法，使用Java7的invokedynamic字节码动态绑定这个方法。\n\n\n参考：\n1、《深入探索Android热修复技术原理》2.3.8章节\n2、[Java8 lambda表达式、函数式接口、方法引用](https://blog.csdn.net/zw19910924/article/details/75907348)","categories":[{"name":"技术文章","api":"api/categories/technology.json"}],"tags":[{"name":"Java","api":"api/tags/java.json"}]},"api":"api/posts/2019/10/09/Java中Lambda表达式解析.json"}