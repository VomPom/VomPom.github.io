{"data":{"title":"Java中的Reference解析","slug":"Java四种引用","description":"","date":"2019-10-30T11:45:00.000Z","updated":"2025-05-20T11:46:57.000Z","language":"zh-CN","comments":true,"url":"2019/10/30/Java四种引用/","cover":null,"images":[],"content":"<p>Java执行GC判断对象是否存活有两种方式其中一种是<strong>引用计数</strong>。</p>\n<p><strong>引用计数</strong>：Java堆中每一个对象都有一个引用计数属性，引用每新增1次计数加1，引用每释放1次计数减1。</p>\n<p>在JDK 1.2以前的版本中，若一个对象不被任何变量引用，那么程序就无法再使用这个对象。也就是说，只有对象处于(reachable)可达状态，程序才能使用它。</p>\n<p>从JDK 1.2版本开始，对象的引用被划分为4种级别，从而使程序能更加灵活地控制对象的生命周期。这4种级别由高到低依次为：<code>强引用、软引用、弱引用和虚引用</code>，本文主要讲解各个引用的用途以及引用队列的作用。</p>\n<h2 id=\"1、强引用（StrongReference）\"><a href=\"#1、强引用（StrongReference）\" class=\"headerlink\" title=\"1、强引用（StrongReference）\"></a>1、强引用（StrongReference）</h2><p>强引用指的是程序代码中普遍存在的，类似如下代码</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">Object</span> <span class=\"variable\">object</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Object</span>();</span><br></pre></td></tr></table></figure>\n<p><em><strong>当内存空间不足时，只要强引用还在，Java虚拟机会抛出OutOfMemoryError错误，使程序异常终止，也不会靠回收强引用的对象来解决内存不足的问题。</strong></em></p>\n<p>如果强引用对象不使用时，需要弱化从而使GC能够回收，如下所示：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">object = <span class=\"literal\">null</span>;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2、软引用（SoftReference）\"><a href=\"#2、软引用（SoftReference）\" class=\"headerlink\" title=\"2、软引用（SoftReference）\"></a>2、软引用（SoftReference）</h2><p><em><strong>软引用是用来描述一些有用但并不是必需的对象。对于软引用关联着的对象，在系统将要发生内存溢出异常之前，将会把这些对象列进回首范围之中进行第二次回收。如果这次回收还没有足够的内存，才会抛出内存溢出异常。</strong></em></p>\n<p>这一点可以很好地用来解决OOM的问题，并且这个特性很适合用来实现缓存：比如网页缓存、图片缓存等，软引用可用来实现内存敏感的高速缓存。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 强引用</span></span><br><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">strongReference</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">String</span>(<span class=\"string\">&quot;abc&quot;</span>);</span><br><span class=\"line\"><span class=\"comment\">// 软引用</span></span><br><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">str</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">String</span>(<span class=\"string\">&quot;abc&quot;</span>);</span><br><span class=\"line\">SoftReference&lt;String&gt; softReference = <span class=\"keyword\">new</span> <span class=\"title class_\">SoftReference</span>&lt;String&gt;(str);</span><br></pre></td></tr></table></figure>\n\n<p>软引用可以和一个引用队列(ReferenceQueue)联合使用。如果软引用所引用对象被垃圾回收，JAVA虚拟机就会把这个软引用加入到与之关联的引用队列中。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">ReferenceQueue&lt;String&gt; referenceQueue = <span class=\"keyword\">new</span> <span class=\"title class_\">ReferenceQueue</span>&lt;&gt;();</span><br><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">str</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">String</span>(<span class=\"string\">&quot;abc&quot;</span>);</span><br><span class=\"line\">SoftReference&lt;String&gt; softReference = <span class=\"keyword\">new</span> <span class=\"title class_\">SoftReference</span>&lt;&gt;(str, referenceQueue);</span><br><span class=\"line\">str = <span class=\"literal\">null</span>;</span><br><span class=\"line\"><span class=\"comment\">// Notify GC</span></span><br><span class=\"line\">System.gc();</span><br><span class=\"line\">System.out.println(softReference.get()); <span class=\"comment\">// abc</span></span><br><span class=\"line\">Reference&lt;? <span class=\"keyword\">extends</span> <span class=\"title class_\">String</span>&gt; reference = referenceQueue.poll();</span><br><span class=\"line\">System.out.println(reference); <span class=\"comment\">//null</span></span><br></pre></td></tr></table></figure>\n\n<p>注意：软引用对象是在jvm内存不够的时候才会被回收，我们调用System.gc()方法只是起通知作用，JVM什么时候扫描回收对象是JVM自己的状态决定的。就算扫描到软引用对象也不一定会回收它，只有内存不够的时候才会回收。</p>\n<p>当内存不足时，JVM首先将软引用中的对象引用置为<code>null</code>，然后通知垃圾回收器进行回收：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span>(JVM内存不足) &#123;</span><br><span class=\"line\">     <span class=\"comment\">// 将软引用中的对象引用置为null</span></span><br><span class=\"line\">     str = <span class=\"literal\">null</span>;</span><br><span class=\"line\">     <span class=\"comment\">// 通知垃圾回收器进行回收</span></span><br><span class=\"line\">     System.gc();</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n<p>也就是说，垃圾收集线程会在虚拟机抛出<code>OutOfMemoryError</code>之前回收软引用对象，而且虚拟机会尽可能优先回收长时间闲置不用的软引用对象。对那些刚构建的或刚使用过的较新的软对象会被虚拟机尽可能保留，这就是引入引用队列ReferenceQueue的原因，后面会具体讲解。</p>\n<h2 id=\"3、弱引用（WeakReference）\"><a href=\"#3、弱引用（WeakReference）\" class=\"headerlink\" title=\"3、弱引用（WeakReference）\"></a>3、弱引用（WeakReference）</h2><p><em><strong>弱引用也是用来描述非必需对象的，但是它的强度比软引用更弱一些，被弱引用关联的<br>对象只能生存到下一次垃圾收集发生之前。当垃圾收集器工作时，无论当前内存是否足够，<br>都会回收掉只被弱引用关联的对象。</strong></em></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">str</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">String</span>(<span class=\"string\">&quot;abc&quot;</span>);</span><br><span class=\"line\">WeakReference&lt;String&gt; weakReference = <span class=\"keyword\">new</span> <span class=\"title class_\">WeakReference</span>&lt;&gt;(str);</span><br><span class=\"line\">str = <span class=\"literal\">null</span>;</span><br></pre></td></tr></table></figure>\n<p>复制代码JVM首先将软引用中的对象引用置为null，然后通知垃圾回收器进行回收：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">str = <span class=\"literal\">null</span>;</span><br><span class=\"line\">System.gc();</span><br></pre></td></tr></table></figure>\n\n<p>注意：如果一个对象是偶尔(很少)的使用，并且希望在使用时随时就能获取到，但又不想影响此对象的垃圾收集，那么你应该用Weak Reference来记住此对象。</p>\n<p>下面的代码会让一个弱引用再次变为一个强引用：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">str</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">String</span>(<span class=\"string\">&quot;abc&quot;</span>);</span><br><span class=\"line\">WeakReference&lt;String&gt; weakReference = <span class=\"keyword\">new</span> <span class=\"title class_\">WeakReference</span>&lt;&gt;(str);</span><br><span class=\"line\"><span class=\"comment\">// 弱引用转强引用</span></span><br><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">strongReference</span> <span class=\"operator\">=</span> weakReference.get();</span><br></pre></td></tr></table></figure>\n\n<p>同样，弱引用可以和一个引用队列(ReferenceQueue)联合使用，如果弱引用所引用的对象被垃圾回收，Java虚拟机就会把这个弱引用加入到与之关联的引用队列中。</p>\n<h2 id=\"4、虚引用（PhantomReference）\"><a href=\"#4、虚引用（PhantomReference）\" class=\"headerlink\" title=\"4、虚引用（PhantomReference）\"></a>4、虚引用（PhantomReference）</h2><p><em><strong>虚引用也称为幽灵引用或者幻影引用，它是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生命周期构成影响，也无法通过虚引用获得一个对象实例。</strong></em></p>\n<p>虚引用主要用来<strong>跟踪对象被垃圾回收器回收的活动</strong>，虚引用与软引用和弱引用的一个区别在于：</p>\n<blockquote>\n<p>虚引用必须和引用队列(ReferenceQueue)联合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">str</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">String</span>(<span class=\"string\">&quot;abc&quot;</span>);</span><br><span class=\"line\"><span class=\"type\">ReferenceQueue</span> <span class=\"variable\">queue</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ReferenceQueue</span>();</span><br><span class=\"line\"><span class=\"comment\">// 创建虚引用，要求必须与一个引用队列关联</span></span><br><span class=\"line\"><span class=\"type\">PhantomReference</span> <span class=\"variable\">pr</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">PhantomReference</span>(str, queue);</span><br></pre></td></tr></table></figure>\n<p>程序可以通过判断引用队列中是否已经加入了虚引用，来了解被引用的对象是否将要进行垃圾回收。如果程序发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动。</p>\n<h2 id=\"5、引用队列（ReferenceQueue）\"><a href=\"#5、引用队列（ReferenceQueue）\" class=\"headerlink\" title=\"5、引用队列（ReferenceQueue）\"></a>5、引用队列（ReferenceQueue）</h2><p>在前面软引用、弱引用和虚引用都有讲到引用队列，那引用队列具体是做什么的呢？<br>官方对于引用队列类的注释是：</p>\n<blockquote>\n<p> Reference queues, to which registered reference objects are appended by the garbage collector after the appropriate reachability changes are detected.<br> 译为：引用队列是将垃圾收集器在监测到适当的可达性更改后将已注册的引用对象添加到该队列。</p>\n</blockquote>\n<p>对于软引用和弱引用和虚引用，我们希望当一个对象被gc掉的时候通知用户线程，进行额外的处理时，就需要使用引用队列了。<code>ReferenceQueue</code>即这样的一个对象，当一个obj被gc掉之后，其相应的包装类，即ref对象会被放入queue中。我们可以从queue中获取到相应的对象信息，同时进行额外的处理。比如反向操作，数据清理等。</p>\n<p>查看源码发现ReferenceQueue的代码结构并不复杂，从源码上看，实际上ReferenceQueue只是名义上的引用队列，它只保存了Reference链表的头(head)节点，并且提供了队列出队入队删除操作，而Reference实际上本身提供单向链表的功能，也就是说Reference通过成员属性next构建单向链表，而链表的操作是委托给ReferenceQueue完成。详细参考：<a href=\"https://www.throwable.club/2019/02/16/java-reference/#ReferenceQueue\">深入理解JDK中的Reference原理和源码实现</a></p>\n<img src=\"https://cdn.julis.wang/blog/img/20191030191550407.png\">\n<h2 id=\"6、总结\"><a href=\"#6、总结\" class=\"headerlink\" title=\"6、总结\"></a>6、总结</h2><p>1、Java中四种引用的级别和强度由高到低依次为：<code>强引用 -&gt; 软引用 -&gt; 弱引用 -&gt; 虚引用</code></p>\n<p>2、ReferenceQueue引用队列用来记录被回收的引用为用户线程做额外操作作铺垫</p>\n<p>3、对各种引用回收时间、用途、生成时间作总结：</p>\n<img src=\"https://cdn.julis.wang/blog/img/78afb9b4d86f5feef01ac947f96baee331c.jpg\">\n<p>参考：</p>\n<p>1、《深入理解Java虚拟机》</p>\n<p>2、<a href=\"https://www.throwable.club/2019/02/16/java-reference/#ReferenceQueue\">深入理解JDK中的Reference原理和源码实现</a></p>\n<p>3、<a href=\"https://juejin.im/post/5b82c02df265da436152f5ad\">理解Java的强引用、软引用、弱引用和虚引用</a></p>\n","raw":"title: Java中的Reference解析\nauthor: 落叶挽歌\nthumbnail: 'https://cdn.pixabay.com/photo/2016/08/09/13/21/coffee-1580595_960_720.jpg'\ntags:\n  - Java\ncategories:\n  - 技术文章\ndate: 2019-10-30 19:45:00\n---\n\n\nJava执行GC判断对象是否存活有两种方式其中一种是**引用计数**。\n\n**引用计数**：Java堆中每一个对象都有一个引用计数属性，引用每新增1次计数加1，引用每释放1次计数减1。\n\n在JDK 1.2以前的版本中，若一个对象不被任何变量引用，那么程序就无法再使用这个对象。也就是说，只有对象处于(reachable)可达状态，程序才能使用它。\n\n从JDK 1.2版本开始，对象的引用被划分为4种级别，从而使程序能更加灵活地控制对象的生命周期。这4种级别由高到低依次为：`强引用、软引用、弱引用和虚引用`，本文主要讲解各个引用的用途以及引用队列的作用。\n\n## 1、强引用（StrongReference）\n强引用指的是程序代码中普遍存在的，类似如下代码\n```java\nObject object = new Object();\n```\n***当内存空间不足时，只要强引用还在，Java虚拟机会抛出OutOfMemoryError错误，使程序异常终止，也不会靠回收强引用的对象来解决内存不足的问题。***\n\n如果强引用对象不使用时，需要弱化从而使GC能够回收，如下所示：\n```java\nobject = null;\n```\n\n## 2、软引用（SoftReference）\n\n***软引用是用来描述一些有用但并不是必需的对象。对于软引用关联着的对象，在系统将要发生内存溢出异常之前，将会把这些对象列进回首范围之中进行第二次回收。如果这次回收还没有足够的内存，才会抛出内存溢出异常。***\n\n这一点可以很好地用来解决OOM的问题，并且这个特性很适合用来实现缓存：比如网页缓存、图片缓存等，软引用可用来实现内存敏感的高速缓存。\n\n```java\n  // 强引用\n  String strongReference = new String(\"abc\");\n  // 软引用\n  String str = new String(\"abc\");\n  SoftReference<String> softReference = new SoftReference<String>(str);\n```\n\n软引用可以和一个引用队列(ReferenceQueue)联合使用。如果软引用所引用对象被垃圾回收，JAVA虚拟机就会把这个软引用加入到与之关联的引用队列中。\n  \n```java\n    ReferenceQueue<String> referenceQueue = new ReferenceQueue<>();\n    String str = new String(\"abc\");\n    SoftReference<String> softReference = new SoftReference<>(str, referenceQueue);\n    str = null;\n    // Notify GC\n    System.gc();\n    System.out.println(softReference.get()); // abc\n    Reference<? extends String> reference = referenceQueue.poll();\n    System.out.println(reference); //null\n```\n\n注意：软引用对象是在jvm内存不够的时候才会被回收，我们调用System.gc()方法只是起通知作用，JVM什么时候扫描回收对象是JVM自己的状态决定的。就算扫描到软引用对象也不一定会回收它，只有内存不够的时候才会回收。\n\n当内存不足时，JVM首先将软引用中的对象引用置为`null`，然后通知垃圾回收器进行回收：\n```java\n   if(JVM内存不足) {\n        // 将软引用中的对象引用置为null\n        str = null;\n        // 通知垃圾回收器进行回收\n        System.gc();\n    }\n```\n也就是说，垃圾收集线程会在虚拟机抛出`OutOfMemoryError`之前回收软引用对象，而且虚拟机会尽可能优先回收长时间闲置不用的软引用对象。对那些刚构建的或刚使用过的较新的软对象会被虚拟机尽可能保留，这就是引入引用队列ReferenceQueue的原因，后面会具体讲解。\n\n\n## 3、弱引用（WeakReference）\n***弱引用也是用来描述非必需对象的，但是它的强度比软引用更弱一些，被弱引用关联的\n对象只能生存到下一次垃圾收集发生之前。当垃圾收集器工作时，无论当前内存是否足够，\n都会回收掉只被弱引用关联的对象。***\n\n```java\nString str = new String(\"abc\");\nWeakReference<String> weakReference = new WeakReference<>(str);\nstr = null;\n```\n复制代码JVM首先将软引用中的对象引用置为null，然后通知垃圾回收器进行回收：\n```java\nstr = null;\nSystem.gc();\n```\n\n注意：如果一个对象是偶尔(很少)的使用，并且希望在使用时随时就能获取到，但又不想影响此对象的垃圾收集，那么你应该用Weak Reference来记住此对象。\n\n下面的代码会让一个弱引用再次变为一个强引用：\n\n```java\nString str = new String(\"abc\");\nWeakReference<String> weakReference = new WeakReference<>(str);\n// 弱引用转强引用\nString strongReference = weakReference.get();\n```\n\n同样，弱引用可以和一个引用队列(ReferenceQueue)联合使用，如果弱引用所引用的对象被垃圾回收，Java虚拟机就会把这个弱引用加入到与之关联的引用队列中。\n\n## 4、虚引用（PhantomReference）\n***虚引用也称为幽灵引用或者幻影引用，它是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生命周期构成影响，也无法通过虚引用获得一个对象实例。***\n\n虚引用主要用来**跟踪对象被垃圾回收器回收的活动**，虚引用与软引用和弱引用的一个区别在于：\n> 虚引用必须和引用队列(ReferenceQueue)联合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。\n\n```java\nString str = new String(\"abc\");\nReferenceQueue queue = new ReferenceQueue();\n// 创建虚引用，要求必须与一个引用队列关联\nPhantomReference pr = new PhantomReference(str, queue);\n```\n程序可以通过判断引用队列中是否已经加入了虚引用，来了解被引用的对象是否将要进行垃圾回收。如果程序发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动。\n\n## 5、引用队列（ReferenceQueue）\n在前面软引用、弱引用和虚引用都有讲到引用队列，那引用队列具体是做什么的呢？\n官方对于引用队列类的注释是：\n\n>  Reference queues, to which registered reference objects are appended by the garbage collector after the appropriate reachability changes are detected.\n>  译为：引用队列是将垃圾收集器在监测到适当的可达性更改后将已注册的引用对象添加到该队列。\n> \n对于软引用和弱引用和虚引用，我们希望当一个对象被gc掉的时候通知用户线程，进行额外的处理时，就需要使用引用队列了。`ReferenceQueue`即这样的一个对象，当一个obj被gc掉之后，其相应的包装类，即ref对象会被放入queue中。我们可以从queue中获取到相应的对象信息，同时进行额外的处理。比如反向操作，数据清理等。\n\n查看源码发现ReferenceQueue的代码结构并不复杂，从源码上看，实际上ReferenceQueue只是名义上的引用队列，它只保存了Reference链表的头(head)节点，并且提供了队列出队入队删除操作，而Reference实际上本身提供单向链表的功能，也就是说Reference通过成员属性next构建单向链表，而链表的操作是委托给ReferenceQueue完成。详细参考：[深入理解JDK中的Reference原理和源码实现](https://www.throwable.club/2019/02/16/java-reference/#ReferenceQueue)\n\n{% qnimg 20191030191550407.png %}\n## 6、总结\n1、Java中四种引用的级别和强度由高到低依次为：`强引用 -> 软引用 -> 弱引用 -> 虚引用`\n\n2、ReferenceQueue引用队列用来记录被回收的引用为用户线程做额外操作作铺垫\n\n3、对各种引用回收时间、用途、生成时间作总结：\n{% qnimg 78afb9b4d86f5feef01ac947f96baee331c.jpg %}\n参考：\n\n1、《深入理解Java虚拟机》\n\n2、[深入理解JDK中的Reference原理和源码实现](https://www.throwable.club/2019/02/16/java-reference/#ReferenceQueue)\n\n3、[理解Java的强引用、软引用、弱引用和虚引用](https://juejin.im/post/5b82c02df265da436152f5ad)","categories":[{"name":"技术文章","api":"api/categories/technology.json"}],"tags":[{"name":"Java","api":"api/tags/java.json"}]},"api":"api/posts/2019/10/30/Java四种引用.json"}