{"data":{"title":"Android 插件化之ClassLoader","slug":"Android-插件化之ClassLoader","description":"","date":"2019-08-26T08:47:00.000Z","updated":"2025-05-20T11:46:57.000Z","language":"zh-CN","comments":true,"url":"2019/08/26/Android-插件化之ClassLoader/","cover":null,"images":[],"content":"<p><strong>插件化要解决的三个核心问题：类加载、资源加载、组件生命周期管理。</strong></p>\n<p>在Android插件化中其原理实际是 Java ClassLoader的原理，此博文主要对Android插件化中类加载中的DexClassLoader做总结，便于之后对Android插件化的理解学习。</p>\n<p>Android的Dalvik虚拟机和Java虚拟机的运行原理相同都是将对应的java类加载在内存中运行。而Java虚拟机是加载class文件，也可以将一段二进制流通过defineClass方法生产Class进行加载。Dalvik虚拟机加载的dex文件。dex文件是Android对与Class文件做的优化，以便于提高手机的性能。可以想象dex为class文件的一个压缩文件。dex在Android中的加载和class在jvm中的相同都是基于双亲委派模型，都是调用ClassLoader的loadClass方法加载类。</p>\n<h2 id=\"1、DexClassLoader和PathClassLoader区别\"><a href=\"#1、DexClassLoader和PathClassLoader区别\" class=\"headerlink\" title=\"1、DexClassLoader和PathClassLoader区别\"></a><strong>1、DexClassLoader和PathClassLoader区别</strong></h2><p>Android 也有自己的 ClassLoader，分为 <code>DexClassLoader</code>和<code>PathClassLoader</code>，这两者有什么区别和关联呢？</p>\n<p>阅读源码可以看到两者的构造方法分别为：</p>\n<pre><code>public class PathClassLoader extends BaseDexClassLoader &#123;\n    public PathClassLoader(String dexPath, ClassLoader parent) &#123;\n        super(dexPath, null, null, parent);\n    &#125;\n    public PathClassLoader(String dexPath, String libraryPath,\n            ClassLoader parent) &#123;\n        super(dexPath, null, libraryPath, parent);\n    &#125;\n&#125;\n\npublic class DexClassLoader extends BaseDexClassLoader &#123;\n    public DexClassLoader(String dexPath, String optimizedDirectory,\n            String libraryPath, ClassLoader parent) &#123;\n        super(dexPath, new File(optimizedDirectory), libraryPath, parent);\n    &#125;\n&#125;\n</code></pre>\n<p>可以发现<code>DexClassLoader</code> 比 <code>PathClassLoader</code> 多一个参数<code>String optimizedDirectory</code>，那这个参数具体做什么的呢？继续查看源码我们可以知道<code>optimizedDirectory</code>是用来缓存我们需要加载的dex文件的，并创建一个<code>DexFile</code>对象，如果它为null，那么会直接使用dex文件原有的路径来创建DexFile 对象，其具体体现在如下代码区域：</p>\n<pre><code>private static DexFile loadDexFile(File file, File optimizedDirectory)\n        throws IOException &#123;\n    if (optimizedDirectory == null) &#123;\n        return new DexFile(file);\n    &#125; else &#123;\n        String optimizedPath = optimizedPathFor(file, optimizedDirectory);\n        return DexFile.loadDex(file.getPath(), optimizedPath, 0);\n    &#125;\n&#125;\n</code></pre>\n<p>因此两者区别在于 <code>PathClassLoader</code> 不能直接从 zip 包中得到 dex，因此只支持直接操作 dex 文件或者已经安装过的 apk。而 <code>DexClassLoader</code> 可以加载外部的 apk、jar 或 dex文件，并且会在指定的 outpath 路径存放其 dex 文件。所以在插件化中我们使用<code>DexClassLoader</code>来加载class的，接下来讲解<code>DexClassLoader</code>的用法。</p>\n<h2 id=\"2、DexClassLoader用法\"><a href=\"#2、DexClassLoader用法\" class=\"headerlink\" title=\"2、DexClassLoader用法\"></a><strong>2、DexClassLoader用法</strong></h2><p>其构造方法为：</p>\n<pre><code>DexClassLoader(\n\tString dexPath, \n\t\tString optimizedDirectory, \n\tString librarySearchPath,\n \tClassLoader parent)\n</code></pre>\n<p><code>dexPath</code>:被解压的apk路径，不能为空。<br><code>optimizedDirectory</code>：解压后的.dex文件的存储路径，不能为空。这个路径强烈建议使用应用程序的私有路径，不要放到sdcard上，否则代码容易被注入攻击。<br><code>libraryPath</code>：os库的存放路径，可以为空，若有os库，必须填写。<br><code>parent</code>：父亲加载器，一般为context.getClassLoader(),使用当前上下文的类加载器。</p>\n<p>接下来讲解具体使用流程：</p>\n<p>1、新建一个名为plugin的project，其中新建一个<code>Bean</code>类，只有一个方法<code>getName()</code>返回一个字符串“My App”，然后对plugin这个工程打包为apk，将apk放在主工程的asser目录中。</p>\n<img src=\"https://cdn.julis.wang/blog/img/20190827104738557.png\">\n<p>2、构造Classloader</p>\n<pre><code>  File extractFile = getFileStreamPath(&quot;app-debug.apk&quot;);\n  String dexPath = extractFile.getPath();\n  File fileRelease = getDir(&quot;dex&quot;, 0);\n  ClassLoader classLoader = new DexClassLoader(dexPath, fileRelease.getAbsolutePath(), null, getClassLoader());\n</code></pre>\n<p>3、利用构造好的Classloader反射调用插件类中的方法</p>\n<pre><code>  Class mLoadClassBean;\n  try &#123;\n        mLoadClassBean = classLoader.loadClass(&quot;com.example.plugin.Bean&quot;);\n        Object beanObject = mLoadClassBean.newInstance();\n        Method getNameMethod = mLoadClassBean.getMethod(&quot;getName&quot;);\n        getNameMethod.setAccessible(true);\n        String name = (String) getNameMethod.invoke(beanObject);\n        Log.e(&quot;julis&quot;, name);\n    &#125; catch(Exception e) &#123;\n        e.printStackTrace();\n    &#125;\n    \n</code></pre>\n<p>成功打印出结果：</p>\n<img src=\"https://cdn.julis.wang/blog/img/20190827143354781.png\">\n<p>参考：</p>\n<p><a href=\"https://www.jianshu.com/p/4b4f1fa6633c\">https://www.jianshu.com/p/4b4f1fa6633c</a></p>\n<p><a href=\"https://www.jianshu.com/p/53aa2de20cf8\">https://www.jianshu.com/p/53aa2de20cf8</a></p>\n<p><a href=\"https://cloud.tencent.com/developer/article/1071815\">https://cloud.tencent.com/developer/article/1071815</a></p>\n","raw":"title: Android 插件化之ClassLoader\nauthor: 落叶挽歌\nthumbnail: 'https://cdn.pixabay.com/photo/2016/05/16/20/44/technology-1396677_960_720.jpg'\ntags:\n  - 插件化\ncategories:\n  - 技术文章\ndate: 2019-08-26 16:47:00\n---\n\n**插件化要解决的三个核心问题：类加载、资源加载、组件生命周期管理。**\n\n在Android插件化中其原理实际是 Java ClassLoader的原理，此博文主要对Android插件化中类加载中的DexClassLoader做总结，便于之后对Android插件化的理解学习。\n\nAndroid的Dalvik虚拟机和Java虚拟机的运行原理相同都是将对应的java类加载在内存中运行。而Java虚拟机是加载class文件，也可以将一段二进制流通过defineClass方法生产Class进行加载。Dalvik虚拟机加载的dex文件。dex文件是Android对与Class文件做的优化，以便于提高手机的性能。可以想象dex为class文件的一个压缩文件。dex在Android中的加载和class在jvm中的相同都是基于双亲委派模型，都是调用ClassLoader的loadClass方法加载类。\n\n\n## **1、DexClassLoader和PathClassLoader区别**\n\n \nAndroid 也有自己的 ClassLoader，分为 `DexClassLoader`和`PathClassLoader`，这两者有什么区别和关联呢？\n\n阅读源码可以看到两者的构造方法分别为：\n\n    public class PathClassLoader extends BaseDexClassLoader {\n        public PathClassLoader(String dexPath, ClassLoader parent) {\n            super(dexPath, null, null, parent);\n        }\n        public PathClassLoader(String dexPath, String libraryPath,\n                ClassLoader parent) {\n            super(dexPath, null, libraryPath, parent);\n        }\n    }\n   \n    public class DexClassLoader extends BaseDexClassLoader {\n        public DexClassLoader(String dexPath, String optimizedDirectory,\n                String libraryPath, ClassLoader parent) {\n            super(dexPath, new File(optimizedDirectory), libraryPath, parent);\n        }\n    }\n\n可以发现`DexClassLoader` 比 `PathClassLoader` 多一个参数`String optimizedDirectory`，那这个参数具体做什么的呢？继续查看源码我们可以知道`optimizedDirectory`是用来缓存我们需要加载的dex文件的，并创建一个`DexFile`对象，如果它为null，那么会直接使用dex文件原有的路径来创建DexFile 对象，其具体体现在如下代码区域：\n\n    private static DexFile loadDexFile(File file, File optimizedDirectory)\n            throws IOException {\n        if (optimizedDirectory == null) {\n            return new DexFile(file);\n        } else {\n            String optimizedPath = optimizedPathFor(file, optimizedDirectory);\n            return DexFile.loadDex(file.getPath(), optimizedPath, 0);\n        }\n    }\n\n因此两者区别在于 `PathClassLoader` 不能直接从 zip 包中得到 dex，因此只支持直接操作 dex 文件或者已经安装过的 apk。而 `DexClassLoader` 可以加载外部的 apk、jar 或 dex文件，并且会在指定的 outpath 路径存放其 dex 文件。所以在插件化中我们使用`DexClassLoader`来加载class的，接下来讲解`DexClassLoader`的用法。\n\n## **2、DexClassLoader用法**\n其构造方法为：\n\n    DexClassLoader(\n    \tString dexPath, \n   \t\tString optimizedDirectory, \n    \tString librarySearchPath,\n     \tClassLoader parent)\n\n\n`dexPath`:被解压的apk路径，不能为空。\n`optimizedDirectory`：解压后的.dex文件的存储路径，不能为空。这个路径强烈建议使用应用程序的私有路径，不要放到sdcard上，否则代码容易被注入攻击。\n`libraryPath`：os库的存放路径，可以为空，若有os库，必须填写。\n`parent`：父亲加载器，一般为context.getClassLoader(),使用当前上下文的类加载器。\n\n接下来讲解具体使用流程：\n\n1、新建一个名为plugin的project，其中新建一个`Bean`类，只有一个方法`getName()`返回一个字符串“My App\"，然后对plugin这个工程打包为apk，将apk放在主工程的asser目录中。\n\n{% qnimg 20190827104738557.png %}\n2、构造Classloader\n\n      File extractFile = getFileStreamPath(\"app-debug.apk\");\n      String dexPath = extractFile.getPath();\n      File fileRelease = getDir(\"dex\", 0);\n      ClassLoader classLoader = new DexClassLoader(dexPath, fileRelease.getAbsolutePath(), null, getClassLoader());\n3、利用构造好的Classloader反射调用插件类中的方法\n\n      Class mLoadClassBean;\n      try {\n            mLoadClassBean = classLoader.loadClass(\"com.example.plugin.Bean\");\n            Object beanObject = mLoadClassBean.newInstance();\n            Method getNameMethod = mLoadClassBean.getMethod(\"getName\");\n            getNameMethod.setAccessible(true);\n            String name = (String) getNameMethod.invoke(beanObject);\n            Log.e(\"julis\", name);\n        } catch(Exception e) {\n            e.printStackTrace();\n        }\n        \n成功打印出结果：\n\n{% qnimg 20190827143354781.png %}\n参考：\n\nhttps://www.jianshu.com/p/4b4f1fa6633c\n\nhttps://www.jianshu.com/p/53aa2de20cf8\n\nhttps://cloud.tencent.com/developer/article/1071815\n","categories":[{"name":"技术文章","api":"api/categories/technology.json"}],"tags":[{"name":"插件化","api":"api/tags/plugins.json"}]},"api":"api/posts/2019/08/26/Android-插件化之ClassLoader.json"}