{"data":{"title":"从奶酪夹心饼干生产中来学习Android 中的gradle构建","slug":"从奶酪夹心饼干生产中来学习Android-中的gradle","description":"","date":"2019-12-18T11:48:00.000Z","updated":"2025-05-20T11:46:57.000Z","language":"zh-CN","comments":true,"url":"2019/12/18/从奶酪夹心饼干生产中来学习Android-中的gradle/","cover":null,"images":[],"content":"<p>最近终于有机会做一些关于Android plugin相关的东西，之前虽然有学习过<code>《Android 权威指南》</code>一书，但是并没有进行一个实战操作，都是一些理论相关的学习。最近做了一个plugin主要是为了提取class文件里面的注解信息然后讲起搜集并上传。在实践中回过头发现很多知识都已经遗忘，所以本文对相关一些比较核心的知识进行一个回顾与梳理。</p>\n<h2 id=\"一、Gradle概述\"><a href=\"#一、Gradle概述\" class=\"headerlink\" title=\"一、Gradle概述\"></a>一、Gradle概述</h2><img src=\"https://cdn.julis.wang/blog/img/20191218190829347.png\">\n\n<p>在Android开发中，Gradle是每个开发者都会接触的，Gradle 是一个非常优秀的项目构建工具。这是大家都知道的，但是又有啥用呢？</p>\n<p>最开始的时候很难理解gradle到底是干什么的，相关知识都比较离散，所以很多东西没有串起来，从而导致理解起来比较困难。</p>\n<p>我自己总结就是：<strong>Gradle是一个构建工具，它存在的目的是产生一套“流水线”，对于安卓开发而言这个流水线就是从本地的编写代码以及资源整合到最终生成的产品过程。</strong></p>\n<p>用一个很形象的例子举例，我们现在要生产一包奶酪夹心饼干，于是我们得定义一个生产顺序：先让有的地方去生成饼干，有的地方生成出来奶酪，之后再让两块饼干夹着一块奶酪，最后再将它们装进一个小包装袋里面。</p>\n<p>另一种情况：如果我想在奶酪中加一点果酱，那么我们不需要重新建立一套生产线，只需要在两块饼干与奶酪结合的过程中修改一下加入果酱的流程。</p>\n<p>再另一种情况：如果我生产出来的奶酪夹心饼干不需要包装，那只需要在最后一个步骤让它另外走一条线路，毕竟没有包装的又不是不能吃，对吧？</p>\n<img src=\"https://cdn.julis.wang/blog/img/20191218143302953.png\">\n<p>如上图所示，我们定义了三种流程，每种流程最后的产出物是不一样的，因为流程的“<strong>初始化</strong>”的东西是不一样的以及过程中的“<strong>配置</strong>”，所以“<strong>执行</strong>”的时候就不一样。</p>\n<p>对比我们安卓开发：本地的Java文件以及资源文件就是对应的饼干以及奶酪，最终生成的面向用户的apk文件就是包装好的奶酪夹心饼干。</p>\n<p>如果我们想打Debug包，那么就像是一个散装的饼干，我们能自己用用，但是还不能面向用户，如果想打Release包那么就是最终的产品形态能直接面向用户。</p>\n<p>上面的例子讲得比较长，其实主要想让更多人能够更好地去理解gradle的用处。</p>\n<p>当我们每次点击Android Studio的 run运行按钮之后，会看到控制台输出一大堆相关日志，例如下图所示：</p>\n<img width=\"60%\" src=\"https://cdn.julis.wang/blog/img/20191218110343253.png\">\n\n<p>其实这些都是系统为我们封装好的一些task<br>点击 run 按钮，就相当于执行了一次 Gradle Task，一般来说，是Task <code>assembleDebug</code>或者Task <code>assembleRelease</code></p>\n<p>Gradle是目前Android主流的构建工具，无论通过命令行还是通过AndroidStudio来build，最终都是通过Gradle来实现的。以及Android领域的探索已经越来越深，不少技术领域如插件化、热修复、构建系统等都对Gradle有相关的需要。</p>\n<h2 id=\"二、Groovy\"><a href=\"#二、Groovy\" class=\"headerlink\" title=\"二、Groovy\"></a>二、Groovy</h2><p>知道了Gradle的用处之后，我们很形象的知道Gradle是为了去产生一个流水线。那这个流水线是利用什么做到的呢？对于奶酪饼干生产的工厂他们是不同的车间机械工具直接的逻辑组装。而对于Gradle则是利用<code>groovy</code>语言编写出来的相关脚本从而来进行一个编译相关的配置。这里不再具体描述groovy语言的具体用法，这里我列举出来几个自己认为比较重要的几个技术点。</p>\n<p><strong>1、Closure（闭包）</strong><br><code>闭包</code>是的groovy语言具有，而Java语言不具有的特性，有人说Lambda表达式就是闭包，但是两则还是有一定的差异的，有兴趣的同学可以去看看这篇<a href=\"https://editor.csdn.net/md/?articleId=102466814\">Java中Lambda表达式解析</a></p>\n<p>定义闭的语意 ：</p>\n<blockquote>\n<p><strong>{ [closureParameters -&gt; ] statements }</strong></p>\n</blockquote>\n<p>其中<code>[closureParameters-&gt;]</code>代表参数，多参数用逗号分割，用<code>-&gt;</code>隔开参数与内容，没有参数可以不写<code>-&gt;</code>例如我们精彩在.gradle文件里面看到这样的内容：</p>\n<img src=\"https://cdn.julis.wang/blog/img/20191218150133412.png\">\n\n<p>其中<code>projcet</code>就是<code>[closureParameters-&gt;]</code>，<code>-&gt;</code>之后的<code>respositories</code>就是statements，对于这段代码而言，statements里面又是一个闭包，如果改写成Java的样子就更形象了：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> <span class=\"title function_\">subprojercts</span><span class=\"params\">(Project projct)</span> &#123;</span><br><span class=\"line\">\tdoSomething....</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<p><strong>2、方法的输入参数优化</strong><br>groovy中定义的函数，如果至少有一个参数，在调用的时候可以省略括号。比如这样</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">def <span class=\"title function_\">func</span><span class=\"params\">(String a)</span>&#123;</span><br><span class=\"line\">  println(a)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">func &#x27;hello&#x27;</span><br></pre></td></tr></table></figure>\n<p>在gradle有大量省略括号调用函数的例子，比如</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">defaultConfig &#123;</span><br><span class=\"line\">        minSdkVersion rootProject.ext.minSdkVersion</span><br><span class=\"line\">        targetSdkVersion rootProject.targetSdkVersion</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>比如这里minSdkVersion 和 targetSdkVersion 其实就是调用了两个函数,传入了不同的参数，在AndroidStudio里面可以点进去查看函数实现</p>\n<p>当然如果某个函数没有参数，那就不能省略括号，否则会当成一个变量使用</p>\n<p><strong>3、类的Property</strong></p>\n<p>如果类的成员变量没有加任何权限访问，则称为<code>Property</code>, 否则是<code>Field</code>，filed和Java中的成员变量相同，但是<code>Property</code>的话，它是一个private field和getter setter的集合，也就是说groovy会自动生成getter setter方法，因此在类外面的代码，都是会透明的调用getter和setter方法。</p>\n<p><strong>4、Trait</strong></p>\n<p>特性使用关键字 trait 声明，可以拥有普通成员和抽象成员。例如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">trait MessageHandler &#123;</span><br><span class=\"line\">    <span class=\"comment\">//  属性</span></span><br><span class=\"line\">    <span class=\"type\">int</span> minLenght</span><br><span class=\"line\">    <span class=\"comment\">//  方法</span></span><br><span class=\"line\">    <span class=\"comment\">//  普通方法</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span> <span class=\"title function_\">echo</span><span class=\"params\">(String msg)</span> &#123;</span><br><span class=\"line\">        println(msg)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//  抽象方法</span></span><br><span class=\"line\">    <span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title function_\">show</span><span class=\"params\">(String msg)</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">trait AnotherMessageHandler &#123;</span><br><span class=\"line\">    <span class=\"comment\">//  抽象方法</span></span><br><span class=\"line\">    <span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title function_\">show</span><span class=\"params\">(String msg)</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Message</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">AnotherMessageHandler</span>, MessageHandler &#123;</span><br><span class=\"line\">.......</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Groovy 中特质本质上是运行时对接口的实现，所以其方法的访问控制符只支持 public 和 private。从代码的书写可以看出来<code>trait</code>又像java中的<code>abstract</code>类又像<code>interface</code>。<br>说他像<code>interface</code>是因为从编写上看就是使用了<code>implements</code>关键字，但是接口又不能使用普通方法。说他像抽象类，因为其内部使用了<code>abstract</code>定义抽象方法。但是它又能<code>implements</code>多个，而达到“多继承”的特性。因此它不是接口，也不是抽象类，它是 <code>trait</code>。</p>\n<h2 id=\"三、Gradle的依赖\"><a href=\"#三、Gradle的依赖\" class=\"headerlink\" title=\"三、Gradle的依赖\"></a>三、Gradle的依赖</h2><p>我们继续回到上面奶酪夹心饼干的生产上面，在产出奶酪夹心饼干之前，我们需要分别生产好单独的饼干与奶酪。假如我们的饼干原料有很多种，姑且我们叫他饼干v1，饼干v2……饼干vn ，奶酪也有很多种，我们叫它奶酪v1，奶酪v2……奶酪vn。那这么多种具体生产起来就应该有相关的选择，在Android开发中各种库都被单独抽了出来，只需要单独声明出来需要用哪个库即可。</p>\n<p>我们平时看的的<code>dependencies</code>如下所示</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">dependencies &#123;</span><br><span class=\"line\">    implementation <span class=\"title function_\">fileTree</span><span class=\"params\">(dir: <span class=\"string\">&#x27;libs&#x27;</span>, include: [<span class=\"string\">&#x27;*.jar&#x27;</span>])</span></span><br><span class=\"line\">    implementation <span class=\"string\">&#x27;com.android.support:appcompat-v7:28.0.0&#x27;</span></span><br><span class=\"line\">    implementation <span class=\"string\">&#x27;com.victor:lib:1.0.4&#x27;</span></span><br><span class=\"line\">    api <span class=\"string\">&#x27;com.android.support:recyclerview-v7:28.0.0&#x27;</span></span><br><span class=\"line\">    implementation <span class=\"string\">&#x27;com.google.code.gson:gson:2.8.6&#x27;</span></span><br><span class=\"line\">    implementation(<span class=\"string\">&#x27;com.wanjian:sak:0.1.0&#x27;</span>) &#123;</span><br><span class=\"line\">        exclude group: <span class=\"string\">&#x27;com.android.support&#x27;</span>, <span class=\"keyword\">module</span>: <span class=\"string\">&#x27;appcompat-v7&#x27;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>1、依赖配置</strong><br>Gradle依赖的配置中主要使用以下关键字，摘自<a href=\"https://developer.android.com/studio/build/dependencies?hl=zh-cn\">谷歌官方Gradle文档-&gt;添加编译依赖项</a></p>\n<p><strong>implementation</strong><br>Gradle 会将依赖项添加到编译类路径，并将依赖项打包到编译输出。不过，当您的模块配置 implementation 依赖项时，会让 Gradle 了解您不希望该模块在编译时将该依赖项泄露给其他模块。也就是说，其他模块只有在运行时才能使用该依赖项。</p>\n<p><strong>api</strong><br>Gradle 会将依赖项添加到编译类路径和编译输出。当一个模块包含 api 依赖项时，会让 Gradle 了解该模块要以传递方式将该依赖项导出到其他模块，以便这些模块在运行时和编译时都可以使用该依赖项</p>\n<p><strong>annotationProcessor</strong><br>要添加对作为注解处理器的库的依赖关系，您必须使用 annotationProcessor 配置将其添加到注解处理器类路径。这是因为，使用此配置可以将编译类路径与注解处理器类路径分开，从而提高编译性能。如果 Gradle 在编译类路径上找到注解处理器，则会禁用避免编译功能，这样会对编译时间产生负面影响（Gradle 5.0 及更高版本会忽略在编译类路径上找到的注解处理器）。</p>\n<p><strong>2、依赖的传递与冲突</strong><br>\t在Maven仓库中，构件通过POM（一种XML文件）来描述相关信息以及传递性依赖。Gradle 可以通过分析该文件获取获取所以依赖以及依赖的依赖和依赖的依赖的依赖，为了更加直观的表述，可以通过下面的输出结果了解。\n\t</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">+--- com.github.hotchemi:permissionsdispatcher:<span class=\"number\">2.2</span><span class=\"number\">.0</span></span><br><span class=\"line\">|    \\--- com.android.support:support-v4:<span class=\"number\">23.1</span><span class=\"number\">.1</span> -&gt; <span class=\"number\">28.0</span><span class=\"number\">.0</span></span><br><span class=\"line\">|         +--- com.android.support:support-compat:<span class=\"number\">28.0</span><span class=\"number\">.0</span></span><br><span class=\"line\">|         |    +--- com.android.support:support-annotations:<span class=\"number\">28.0</span><span class=\"number\">.0</span></span><br><span class=\"line\">|         |    +--- com.android.support:collections:<span class=\"number\">28.0</span><span class=\"number\">.0</span></span><br><span class=\"line\">|         |    |    \\--- com.android.support:support-annotations:<span class=\"number\">28.0</span><span class=\"number\">.0</span></span><br><span class=\"line\">|         |    +--- android.arch.lifecycle:runtime:<span class=\"number\">1.1</span><span class=\"number\">.1</span></span><br><span class=\"line\">|         |    |    +--- android.arch.lifecycle:common:<span class=\"number\">1.1</span><span class=\"number\">.1</span></span><br><span class=\"line\">|         |    |    |    \\--- com.android.support:support-annotations:<span class=\"number\">26.1</span><span class=\"number\">.0</span> -&gt; <span class=\"number\">28.0</span><span class=\"number\">.0</span></span><br><span class=\"line\">|         |    |    +--- android.arch.core:common:<span class=\"number\">1.1</span><span class=\"number\">.1</span></span><br><span class=\"line\">|         |    |    |    \\--- com.android.support:support-annotations:<span class=\"number\">26.1</span><span class=\"number\">.0</span> -&gt; <span class=\"number\">28.0</span><span class=\"number\">.0</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>我依赖hotchemi:permissionsdispatcher这个库，而它内部又陆陆续续地依赖了后面的一大堆。借助Gradle的传递性依赖特性，你无需再你的脚本中把这些依赖都声明一遍，你只需要简单的一行，Gradle便会帮你将传递性依赖一起下载下来。</p>\n<p>然而问题来了这里面依赖了：<code>android.arch.core:common:1.1.1</code>  而我本地其他地方又使用了<code>android.arch.core:common:1.0.0</code>老版本。那我该如何去做这件事呢？</p>\n<p>于是便有了如下关键词：<br><strong>exclude<br>force<br>transitive</strong></p>\n<p>具体作用如下代码所示</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">implementation (<span class=\"string\">&#x27;com.google.code.gson:gson:2.8.6&#x27;</span>) &#123;</span><br><span class=\"line\">    force = <span class=\"literal\">true</span> <span class=\"comment\">//强制使用这个版本的库</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">implementation (<span class=\"string\">&#x27;de.hdodenhof:circleimageview:3.0.1&#x27;</span>) &#123;</span><br><span class=\"line\">    transitive = <span class=\"literal\">true</span> <span class=\"comment\">//防止向外暴露</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">implementation(<span class=\"string\">&#x27;com.wanjian:sak:0.1.0&#x27;</span>) &#123;</span><br><span class=\"line\">    exclude group: <span class=\"string\">&#x27;com.android.support&#x27;</span>, <span class=\"keyword\">module</span>: <span class=\"string\">&#x27;appcompat-v7&#x27;</span> <span class=\"comment\">//排除里面不需要的库</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"四、Gradle的Task构建与执行\"><a href=\"#四、Gradle的Task构建与执行\" class=\"headerlink\" title=\"四、Gradle的Task构建与执行\"></a>四、Gradle的Task构建与执行</h2><p>再回到生产饼干的例子上面来，最开始我们定义了一些流程，然后再让机器以该流程去执行。</p>\n<p>比如先准备两块饼干再与奶酪进行加工生成夹心饼干，最后再加入包装。这是一条正确的流水，我们不可能让加入包装在加工生成夹心饼干之前。于是我们得定义一些约束，让其有正确的执行顺序。或者我们像加入果酱，那么就应该对原始的流程进行一些添加。</p>\n<p>对于Gradle中，我们以Task为单位，类比生产奶酪饼干，生成饼干是一个专门的Task，生成奶酪也是一个专门的Task，加工成夹心也是一个Task……对于Android开发，将java文件编译为class，再到最后的dex生成都是Task</p>\n<p>在Task的构建与执行中主要分为三个流程：</p>\n<p><strong>初始化（Initialization）</strong><br>settings.gradle确定参与构建的module<br>为每个module创建Project对象实例</p>\n<p><strong>配置（Configuration ）</strong><br>build.gradle脚本执行，配置对应project实例<br>创建有向无环图<br>通过finalizedBy指定后续<br>通过must&#x2F;shouldRunAfter约束执行顺序</p>\n<p><strong>执行（Execution ）</strong><br>根据关系图执行task<br>监听器</p>\n<p>主要流程如图所示（图片摘自<a href=\"https://www.jianshu.com/p/0acdb31eef2d\">https://www.jianshu.com/p/0acdb31eef2d</a>）：</p>\n<img src=\"https://cdn.julis.wang/blog/img/20191218190105218.png\">\n\n<h2 id=\"五、Gradle插件\"><a href=\"#五、Gradle插件\" class=\"headerlink\" title=\"五、Gradle插件\"></a>五、Gradle插件</h2><p>继续奶酪夹心饼干的故事，如果夹心饼干模样规规矩矩没有花纹，岂不是很low？于是工厂专门研发了一款能让饼干产生纹路的机器，并在加工成夹心饼干之前将纹路印到饼干上面去，假如这台机器我们把它叫做“印花纹机”，是一个能从整个生产流程中独立的出来的机器，这台“印花纹机”也能用在生产其他的饼干上。</p>\n<p>对应在我们的Android开发中，在构建流程中我们抽离出来一些功能，将其独立开来，这就是plugin，这里不再讲解plugin的编写相关操作，可以参考<a href=\"https://juejin.im/post/5cc5929bf265da036706b350\">Gradle 自定义 plugin</a></p>\n<p><strong>1、插件分类</strong></p>\n<p><strong>脚本插件</strong><br>顾名思义，如下图所示我们将对应的插件脚本中加入相关插件的逻辑，如下图所示，“other.gradle”便是一个插件</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">apply from: <span class=\"string\">&#x27;other.gradle&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>二进制插件</strong><br>二进制插件就是实现了 org.gradle.api.Plugin 接口的插件，每个 Java Gradle 插件都有一个 plugin id，可以通过如下方式使用一个 Java 插件：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">apply plugin : <span class=\"string\">&#x27;maven&#x27;</span></span><br></pre></td></tr></table></figure>\n<p>通过上述代码就将 Java 插件应用到我们的项目中了，其中 <code>maven</code> 是 Java 插件的 plugin id，对于 Gradle 自带的核心插件都有唯一的 plugin id</p>\n<p><strong>2、打包方式</strong><br>\t\t\t<br><strong>build script</strong><br>在插件分类中我们提到有<code>apply from: &#39;other.gradle&#39;</code> 其中<code>other.gradle</code>就是一个打包好的build script</p>\n<p><strong>buildSrc</strong><br>将插件写在工程根目录下的buildSrc目录下，这样可以在多个模块之间复用该插件。<br>buildSrc是Gradle在项目中配置自定义插件的默认目录，但它并不是标准的Android工程目录，所以使用这种方式需要我们事先手动创建一个buildSrc目录</p>\n<img width=\"60%\" src=\"https://cdn.julis.wang/blog/img/20191218194223783.png\">\n\n<p><strong>独立项目</strong>\t<br>创建独立的插件项目具有更强的灵活性，能让更多的工程使用这个插件，但流程也会相对复杂一点.这里不再具体讲解，可以参考<a href=\"https://juejin.im/post/5cc5929bf265da036706b350\">Gradle 自定义 plugin</a></p>\n<p>参考资料：</p>\n<p><a href=\"https://www.jianshu.com/p/6dc2074480b8\">https://www.jianshu.com/p/6dc2074480b8</a><br><a href=\"https://www.jianshu.com/p/bcaf9a269d96\">https://www.jianshu.com/p/bcaf9a269d96</a><br><a href=\"https://juejin.im/entry/59918304518825489151732d\">https://juejin.im/entry/59918304518825489151732d</a><br><a href=\"https://www.jianshu.com/p/0acdb31eef2d\">https://www.jianshu.com/p/0acdb31eef2d</a><br><a href=\"https://juejin.im/post/5cc5929bf265da036706b350\">https://juejin.im/post/5cc5929bf265da036706b350</a><br><a href=\"https://doc.yonyoucloud.com/doc/wiki/project/GradleUserGuide-Wiki/gradle_plugins/binary_plugins.html\">https://doc.yonyoucloud.com/doc/wiki/project/GradleUserGuide-Wiki/gradle_plugins/binary_plugins.html</a></p>\n","raw":"title: 从奶酪夹心饼干生产中来学习Android 中的gradle构建\nauthor: 落叶挽歌\nthumbnail: 'https://cdn.pixabay.com/photo/2016/04/24/21/07/oreos-1350632_960_720.jpg'\ntags:\n  - Android\ncategories:\n  - 技术文章\ndate: 2019-12-18 19:48:00\n---\n\n最近终于有机会做一些关于Android plugin相关的东西，之前虽然有学习过`《Android 权威指南》`一书，但是并没有进行一个实战操作，都是一些理论相关的学习。最近做了一个plugin主要是为了提取class文件里面的注解信息然后讲起搜集并上传。在实践中回过头发现很多知识都已经遗忘，所以本文对相关一些比较核心的知识进行一个回顾与梳理。\n\n## 一、Gradle概述\n\n{% qnimg 20191218190829347.png %}\n\n在Android开发中，Gradle是每个开发者都会接触的，Gradle 是一个非常优秀的项目构建工具。这是大家都知道的，但是又有啥用呢？\n\n最开始的时候很难理解gradle到底是干什么的，相关知识都比较离散，所以很多东西没有串起来，从而导致理解起来比较困难。\n\n我自己总结就是：**Gradle是一个构建工具，它存在的目的是产生一套“流水线”，对于安卓开发而言这个流水线就是从本地的编写代码以及资源整合到最终生成的产品过程。**\n\n用一个很形象的例子举例，我们现在要生产一包奶酪夹心饼干，于是我们得定义一个生产顺序：先让有的地方去生成饼干，有的地方生成出来奶酪，之后再让两块饼干夹着一块奶酪，最后再将它们装进一个小包装袋里面。\n\n另一种情况：如果我想在奶酪中加一点果酱，那么我们不需要重新建立一套生产线，只需要在两块饼干与奶酪结合的过程中修改一下加入果酱的流程。\n\n再另一种情况：如果我生产出来的奶酪夹心饼干不需要包装，那只需要在最后一个步骤让它另外走一条线路，毕竟没有包装的又不是不能吃，对吧？\n{% qnimg 20191218143302953.png %}\n如上图所示，我们定义了三种流程，每种流程最后的产出物是不一样的，因为流程的“**初始化**”的东西是不一样的以及过程中的“**配置**”，所以“**执行**”的时候就不一样。\n\n对比我们安卓开发：本地的Java文件以及资源文件就是对应的饼干以及奶酪，最终生成的面向用户的apk文件就是包装好的奶酪夹心饼干。\n\n如果我们想打Debug包，那么就像是一个散装的饼干，我们能自己用用，但是还不能面向用户，如果想打Release包那么就是最终的产品形态能直接面向用户。\n\n上面的例子讲得比较长，其实主要想让更多人能够更好地去理解gradle的用处。\n\n当我们每次点击Android Studio的 run运行按钮之后，会看到控制台输出一大堆相关日志，例如下图所示：\n\n{% qnimg 20191218110343253.png width:60% %}\n\n其实这些都是系统为我们封装好的一些task\n点击 run 按钮，就相当于执行了一次 Gradle Task，一般来说，是Task `assembleDebug`或者Task `assembleRelease`\n\nGradle是目前Android主流的构建工具，无论通过命令行还是通过AndroidStudio来build，最终都是通过Gradle来实现的。以及Android领域的探索已经越来越深，不少技术领域如插件化、热修复、构建系统等都对Gradle有相关的需要。\n\n\n## 二、Groovy\n\n知道了Gradle的用处之后，我们很形象的知道Gradle是为了去产生一个流水线。那这个流水线是利用什么做到的呢？对于奶酪饼干生产的工厂他们是不同的车间机械工具直接的逻辑组装。而对于Gradle则是利用`groovy`语言编写出来的相关脚本从而来进行一个编译相关的配置。这里不再具体描述groovy语言的具体用法，这里我列举出来几个自己认为比较重要的几个技术点。\n\n**1、Closure（闭包）**\n`闭包`是的groovy语言具有，而Java语言不具有的特性，有人说Lambda表达式就是闭包，但是两则还是有一定的差异的，有兴趣的同学可以去看看这篇[Java中Lambda表达式解析](https://editor.csdn.net/md/?articleId=102466814)\n\n定义闭的语意 ：\n\n> **{ [closureParameters -> ] statements }**\n\n其中`[closureParameters->]`代表参数，多参数用逗号分割，用`->`隔开参数与内容，没有参数可以不写`->`例如我们精彩在.gradle文件里面看到这样的内容：\n\n{% qnimg 20191218150133412.png %}\n\n其中`projcet`就是`[closureParameters->]`，`->`之后的`respositories`就是statements，对于这段代码而言，statements里面又是一个闭包，如果改写成Java的样子就更形象了：\n\n```java\nvoid subprojercts(Project projct) {\n\tdoSomething....\n}\n```\n\n\n**2、方法的输入参数优化**\ngroovy中定义的函数，如果至少有一个参数，在调用的时候可以省略括号。比如这样\n\n```java\ndef func(String a){\n  println(a)\n}\n```\n```\nfunc 'hello'\n```\n在gradle有大量省略括号调用函数的例子，比如\n\n```java\ndefaultConfig {\n        minSdkVersion rootProject.ext.minSdkVersion\n        targetSdkVersion rootProject.targetSdkVersion\n}\n```\n\n比如这里minSdkVersion 和 targetSdkVersion 其实就是调用了两个函数,传入了不同的参数，在AndroidStudio里面可以点进去查看函数实现\n\n当然如果某个函数没有参数，那就不能省略括号，否则会当成一个变量使用\n\n**3、类的Property**\n\n如果类的成员变量没有加任何权限访问，则称为`Property`, 否则是`Field`，filed和Java中的成员变量相同，但是`Property`的话，它是一个private field和getter setter的集合，也就是说groovy会自动生成getter setter方法，因此在类外面的代码，都是会透明的调用getter和setter方法。\n\n\n**4、Trait**\n\n特性使用关键字 trait 声明，可以拥有普通成员和抽象成员。例如：\n```java\n\ntrait MessageHandler {\n    //  属性\n    int minLenght\n    //  方法\n    //  普通方法\n    void echo(String msg) {\n        println(msg)\n    }\n    //  抽象方法\n    abstract void show(String msg)\n}\ntrait AnotherMessageHandler {\n    //  抽象方法\n    abstract void show(String msg)\n}\n\nclass Message implements AnotherMessageHandler, MessageHandler {\n.......\n}\n```\nGroovy 中特质本质上是运行时对接口的实现，所以其方法的访问控制符只支持 public 和 private。从代码的书写可以看出来`trait`又像java中的`abstract`类又像`interface`。\n说他像`interface`是因为从编写上看就是使用了`implements`关键字，但是接口又不能使用普通方法。说他像抽象类，因为其内部使用了`abstract`定义抽象方法。但是它又能`implements`多个，而达到“多继承”的特性。因此它不是接口，也不是抽象类，它是 `trait`。\n\n## 三、Gradle的依赖\n我们继续回到上面奶酪夹心饼干的生产上面，在产出奶酪夹心饼干之前，我们需要分别生产好单独的饼干与奶酪。假如我们的饼干原料有很多种，姑且我们叫他饼干v1，饼干v2……饼干vn ，奶酪也有很多种，我们叫它奶酪v1，奶酪v2……奶酪vn。那这么多种具体生产起来就应该有相关的选择，在Android开发中各种库都被单独抽了出来，只需要单独声明出来需要用哪个库即可。\n\n我们平时看的的`dependencies`如下所示\n\n```java\ndependencies {\n    implementation fileTree(dir: 'libs', include: ['*.jar'])\n    implementation 'com.android.support:appcompat-v7:28.0.0'\n    implementation 'com.victor:lib:1.0.4'\n    api 'com.android.support:recyclerview-v7:28.0.0'\n    implementation 'com.google.code.gson:gson:2.8.6'\n    implementation('com.wanjian:sak:0.1.0') {\n        exclude group: 'com.android.support', module: 'appcompat-v7'\n    }\n}\n```\n\n**1、依赖配置**\nGradle依赖的配置中主要使用以下关键字，摘自[谷歌官方Gradle文档->添加编译依赖项](https://developer.android.com/studio/build/dependencies?hl=zh-cn)\n\n**implementation**\nGradle 会将依赖项添加到编译类路径，并将依赖项打包到编译输出。不过，当您的模块配置 implementation 依赖项时，会让 Gradle 了解您不希望该模块在编译时将该依赖项泄露给其他模块。也就是说，其他模块只有在运行时才能使用该依赖项。\n\n**api**\nGradle 会将依赖项添加到编译类路径和编译输出。当一个模块包含 api 依赖项时，会让 Gradle 了解该模块要以传递方式将该依赖项导出到其他模块，以便这些模块在运行时和编译时都可以使用该依赖项\n\n**annotationProcessor**\n要添加对作为注解处理器的库的依赖关系，您必须使用 annotationProcessor 配置将其添加到注解处理器类路径。这是因为，使用此配置可以将编译类路径与注解处理器类路径分开，从而提高编译性能。如果 Gradle 在编译类路径上找到注解处理器，则会禁用避免编译功能，这样会对编译时间产生负面影响（Gradle 5.0 及更高版本会忽略在编译类路径上找到的注解处理器）。\n\n\n\n**2、依赖的传递与冲突**\n\t在Maven仓库中，构件通过POM（一种XML文件）来描述相关信息以及传递性依赖。Gradle 可以通过分析该文件获取获取所以依赖以及依赖的依赖和依赖的依赖的依赖，为了更加直观的表述，可以通过下面的输出结果了解。\n\t\n```java\n+--- com.github.hotchemi:permissionsdispatcher:2.2.0\n|    \\--- com.android.support:support-v4:23.1.1 -> 28.0.0\n|         +--- com.android.support:support-compat:28.0.0\n|         |    +--- com.android.support:support-annotations:28.0.0\n|         |    +--- com.android.support:collections:28.0.0\n|         |    |    \\--- com.android.support:support-annotations:28.0.0\n|         |    +--- android.arch.lifecycle:runtime:1.1.1\n|         |    |    +--- android.arch.lifecycle:common:1.1.1\n|         |    |    |    \\--- com.android.support:support-annotations:26.1.0 -> 28.0.0\n|         |    |    +--- android.arch.core:common:1.1.1\n|         |    |    |    \\--- com.android.support:support-annotations:26.1.0 -> 28.0.0\n\n```\n我依赖hotchemi:permissionsdispatcher这个库，而它内部又陆陆续续地依赖了后面的一大堆。借助Gradle的传递性依赖特性，你无需再你的脚本中把这些依赖都声明一遍，你只需要简单的一行，Gradle便会帮你将传递性依赖一起下载下来。\n\n然而问题来了这里面依赖了：`android.arch.core:common:1.1.1`  而我本地其他地方又使用了`android.arch.core:common:1.0.0`老版本。那我该如何去做这件事呢？\n\n于是便有了如下关键词：\n**exclude\nforce\ntransitive**\n\n具体作用如下代码所示\n\n```java\n    implementation ('com.google.code.gson:gson:2.8.6') {\n        force = true //强制使用这个版本的库\n    }\n    implementation ('de.hdodenhof:circleimageview:3.0.1') {\n        transitive = true //防止向外暴露\n    }\n    implementation('com.wanjian:sak:0.1.0') {\n        exclude group: 'com.android.support', module: 'appcompat-v7' //排除里面不需要的库\n    }\n```\n\n## 四、Gradle的Task构建与执行\n再回到生产饼干的例子上面来，最开始我们定义了一些流程，然后再让机器以该流程去执行。\n\n比如先准备两块饼干再与奶酪进行加工生成夹心饼干，最后再加入包装。这是一条正确的流水，我们不可能让加入包装在加工生成夹心饼干之前。于是我们得定义一些约束，让其有正确的执行顺序。或者我们像加入果酱，那么就应该对原始的流程进行一些添加。\n\n对于Gradle中，我们以Task为单位，类比生产奶酪饼干，生成饼干是一个专门的Task，生成奶酪也是一个专门的Task，加工成夹心也是一个Task……对于Android开发，将java文件编译为class，再到最后的dex生成都是Task\n\n在Task的构建与执行中主要分为三个流程：\n\n**初始化（Initialization）**\nsettings.gradle确定参与构建的module\n为每个module创建Project对象实例\n\n**配置（Configuration ）**\nbuild.gradle脚本执行，配置对应project实例\n创建有向无环图\n通过finalizedBy指定后续\n通过must/shouldRunAfter约束执行顺序\n\n**执行（Execution ）**\n根据关系图执行task\n监听器\n\n主要流程如图所示（图片摘自[https://www.jianshu.com/p/0acdb31eef2d](https://www.jianshu.com/p/0acdb31eef2d)）：\n\n{% qnimg 20191218190105218.png %}\n\n## 五、Gradle插件\n继续奶酪夹心饼干的故事，如果夹心饼干模样规规矩矩没有花纹，岂不是很low？于是工厂专门研发了一款能让饼干产生纹路的机器，并在加工成夹心饼干之前将纹路印到饼干上面去，假如这台机器我们把它叫做“印花纹机”，是一个能从整个生产流程中独立的出来的机器，这台“印花纹机”也能用在生产其他的饼干上。\n\n对应在我们的Android开发中，在构建流程中我们抽离出来一些功能，将其独立开来，这就是plugin，这里不再讲解plugin的编写相关操作，可以参考[Gradle 自定义 plugin](https://juejin.im/post/5cc5929bf265da036706b350)\n\n**1、插件分类**\n\n**脚本插件**\n顾名思义，如下图所示我们将对应的插件脚本中加入相关插件的逻辑，如下图所示，“other.gradle”便是一个插件\n\n```java\napply from: 'other.gradle'\n```\n\n**二进制插件**\n二进制插件就是实现了 org.gradle.api.Plugin 接口的插件，每个 Java Gradle 插件都有一个 plugin id，可以通过如下方式使用一个 Java 插件：\n\n```java\napply plugin : 'maven'\n```\n通过上述代码就将 Java 插件应用到我们的项目中了，其中 `maven` 是 Java 插件的 plugin id，对于 Gradle 自带的核心插件都有唯一的 plugin id\n\n\n**2、打包方式**\n\t\t\t\n**build script**\n在插件分类中我们提到有`apply from: 'other.gradle'` 其中`other.gradle`就是一个打包好的build script\n\n**buildSrc**\n将插件写在工程根目录下的buildSrc目录下，这样可以在多个模块之间复用该插件。\nbuildSrc是Gradle在项目中配置自定义插件的默认目录，但它并不是标准的Android工程目录，所以使用这种方式需要我们事先手动创建一个buildSrc目录\n\n{% qnimg 20191218194223783.png width:60% %}\n\n**独立项目**\t\n创建独立的插件项目具有更强的灵活性，能让更多的工程使用这个插件，但流程也会相对复杂一点.这里不再具体讲解，可以参考[Gradle 自定义 plugin](https://juejin.im/post/5cc5929bf265da036706b350)\n\n\n\n\n参考资料：\n\nhttps://www.jianshu.com/p/6dc2074480b8\nhttps://www.jianshu.com/p/bcaf9a269d96\nhttps://juejin.im/entry/59918304518825489151732d\nhttps://www.jianshu.com/p/0acdb31eef2d\nhttps://juejin.im/post/5cc5929bf265da036706b350\nhttps://doc.yonyoucloud.com/doc/wiki/project/GradleUserGuide-Wiki/gradle_plugins/binary_plugins.html","categories":[{"name":"技术文章","api":"api/categories/technology.json"}],"tags":[{"name":"Android","api":"api/tags/Android.json"}]},"api":"api/posts/2019/12/18/从奶酪夹心饼干生产中来学习Android-中的gradle.json"}