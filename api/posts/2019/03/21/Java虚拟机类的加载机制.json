{"data":{"title":"Java虚拟机类的加载机制","slug":"Java虚拟机类的加载机制","description":"","date":"2019-03-21T01:35:00.000Z","updated":"2025-05-20T11:46:57.000Z","language":"zh-CN","comments":true,"url":"2019/03/21/Java虚拟机类的加载机制/","cover":null,"images":[],"content":"<p><strong>什么是虚拟机类的加载机制？</strong></p>\n<blockquote>\n<p>虚拟机把描述类的数据从class文件加载到内存，并对数据进行校验，转换，解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这就是虚拟机的类加载机制。</p>\n</blockquote>\n<p>类从加载到虚拟机的内存中开始，直到卸载出内存为止，整个生命周期为：</p>\n<ul>\n<li><p>加载（loading）</p>\n</li>\n<li><p>验证（verification）</p>\n</li>\n<li><p>准备(preparation)</p>\n</li>\n<li><p>解析(resolution)</p>\n</li>\n<li><p>初始化(initialization)</p>\n</li>\n<li><p>使用(using)</p>\n</li>\n<li><p>卸载（unloading）</p>\n</li>\n</ul>\n<p>其中 验证、准备、解析部分统称为连接</p>\n<img src=\"https://cdn.julis.wang/blog/img/6870166cdec78b95356d73621e32757829b.jpg\">\n<p>接下来依次讲解，各个步骤所做的事</p>\n<h2 id=\"第一部分-加载\"><a href=\"#第一部分-加载\" class=\"headerlink\" title=\"第一部分 加载\"></a><strong>第一部分 加载</strong></h2><hr>\n<p>“加载”是“类加载”的一个阶段，注意区分概念。类的加载由<strong>类加载器</strong>（后面介绍）加载主要完成三件事情：</p>\n<p><strong>1、通过一个类的全限定名来获取其定义的二进制字节流。</strong></p>\n<p><strong>2、将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。</strong></p>\n<p><strong>3、在Java堆中生成一个代表这个类的java.lang.Class对象，作为对方法区中这些数据的访问入口。</strong></p>\n<blockquote>\n<p>加载阶段完成后，虚拟机外部的二进制字节流将按照虚拟机所需的格式存储在方法区中，同时在内存中实例化一个java.lang.Class的实例对象。相对于HotSpot，这个实例对象比较特殊，虽然是一个对象，但并没有放置在堆中，而是放置在方法区中。这个对象将作为程序访问方法区中这些类数据的外部接口。</p>\n</blockquote>\n<h2 id=\"第二部分-验证\"><a href=\"#第二部分-验证\" class=\"headerlink\" title=\"第二部分 验证\"></a><strong>第二部分 验证</strong></h2><hr>\n<p>这一步主要是确保Class文件的字节流符合虚拟机的规范</p>\n<p>主要验证以下几个部分：</p>\n<p><strong>1、文件格式验证</strong><br>验证是否以魔数开头、主次版本号是否在当前虚拟机处理范围内…</p>\n<p>这一验证阶段主要是保证输入的字节流能正确地解析并存储与方法区内，格式上符合Java类型信息的要求。只有通过这个阶段，字节流才会进入内存的方法区中存储，后面的三个验证方式也都是给予方法区中的数据验证，不再会操作字节流。</p>\n<p><strong>2、元数据验证</strong>  验证这个类是否有父类、这个类是否继承了不允许继承的类…</p>\n<p>该阶段主要对类的元数据进行语义校验，保证符合java语言规范的元数据信息。</p>\n<p><strong>3、字节码验证</strong></p>\n<p>最复杂的一个阶段，主要目的是通过数据流和控制流分析，确定程序语义是否合法、符合逻辑。</p>\n<p><strong>4、符号引用验证</strong> </p>\n<p>这个阶段的校验发生在虚拟机将符号引用转化为直接引用的时候，这个转化动作发生在连接的解析阶段。目的是确保解析动作正常执行，如果无法通过验证，将抛出 IllegalAccessError、NoSuchFieldError、NoSuchMethodError等异常。</p>\n<h2 id=\"第三部分-准备\"><a href=\"#第三部分-准备\" class=\"headerlink\" title=\"第三部分 准备\"></a><strong>第三部分 准备</strong></h2><hr>\n<p>准备阶段是正式为类变量分配内存并设置<strong>类变量初始值</strong>的阶段，这些变量所实用的内存将在<strong>方法区</strong>中进行分配。</p>\n<p><strong>这时候的分配仅仅是类变量(staic修饰的变量)，而实例变量将会在对象实例化时随对象一起分配在Java对中。</strong></p>\n<p>假设一个类变量为：public static int count &#x3D; 10;这时候会分配0，而不是10，分配10是在程序编译后。</p>\n<h2 id=\"第四部分-解析\"><a href=\"#第四部分-解析\" class=\"headerlink\" title=\"第四部分 解析\"></a><strong>第四部分 解析</strong></h2><hr>\n<p>解析阶段是虚拟机将常量池的符号引用替换为直接引用的阶段</p>\n<p><strong>1、类或者接口的的解析</strong></p>\n<p><strong>2、字段解析</strong></p>\n<p><strong>3、类方法解析</strong></p>\n<p><strong>4、接口方法解析</strong></p>\n<blockquote>\n<p><strong>符号引用</strong>与虚拟机实现的布局无关，引用的目标并不一定要已经加载到内存中。各种虚拟机实现的内存布局可以各不相同，但是它们能接受的符号引用必须是一致的，因为符号引用的字面量形式明确定义在Java虚拟机规范的Class文件格式中。</p>\n</blockquote>\n<blockquote>\n<p><strong>直接引用</strong>可以是指向目标的指针，相对偏移量或是一个能间接定位到目标的句柄。如果有了直接引用，那引用的目标必定已经在内存中存在。</p>\n</blockquote>\n<h2 id=\"第五部分-初始化\"><a href=\"#第五部分-初始化\" class=\"headerlink\" title=\"第五部分 初始化\"></a><strong>第五部分 初始化</strong></h2><hr>\n<p>在准备阶段，变量已经被分配赋值过初始值，在初始化阶段根据代码的逻辑初始化真实的变量和其他资源。</p>\n<h2 id=\"关于类加载器\"><a href=\"#关于类加载器\" class=\"headerlink\" title=\"关于类加载器\"></a><strong>关于类加载器</strong></h2><hr>\n<p><strong>什么是类加载器？</strong></p>\n<p>在“加载”阶段中，通过一个类的全限定名来获取其定义的二进制字节流。这一动作是放到了Java虚拟机外部去实现的，是为了方便让应用自己去决定如何获取所需要的类，实现这个动作的功能是常说的“类加载器（ClassLoader）”</p>\n<p>类加载器主要有三种：</p>\n<p><strong>1.启动类加载器(Bootstrap ClassLoader)</strong></p>\n<pre><code>负责加载&lt;JAVA_HOME&gt;\\lib\n</code></pre>\n<p><strong>2.扩展类加载器(Exension ClassLoader)</strong></p>\n<pre><code>负责加载&lt;JAVA_HOME&gt;\\lib\\ext\n</code></pre>\n<p><strong>3.应用程序类加载器(Applicaion ClassLoader)</strong></p>\n<pre><code>负责加载ClassPath上指定的类库\n</code></pre>\n<p><strong>类加载器工作原理</strong></p>\n<p>介绍类加载器原理之前，必须得了解<strong>双亲委派模型</strong>(Parents Delegation Model)</p>\n<blockquote>\n<p>双亲委派模式的工作原理的是：如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行，如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器，如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载。</p>\n</blockquote>\n<img src=\"https://cdn.julis.wang/blog/img/853820dea41988382e4e0872063ec33315e.jpg\">\n\n<p>如图所示，这种层次结构关系被称为<strong>双亲委派模型</strong><br>以下为其实现代码，集中在java.lang.ClassLoader中的loadClass()方法中</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">protected</span> Class&lt;?&gt; loadClass(String name, <span class=\"type\">boolean</span> resolve)</span><br><span class=\"line\">      <span class=\"keyword\">throws</span> ClassNotFoundException</span><br><span class=\"line\">  \t&#123;</span><br><span class=\"line\">      <span class=\"keyword\">synchronized</span> (getClassLoadingLock(name)) &#123;</span><br><span class=\"line\">          <span class=\"comment\">// First, check if the class has already been loaded</span></span><br><span class=\"line\"><span class=\"comment\">//首先检查类是否被加载</span></span><br><span class=\"line\">          Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class=\"line\">          <span class=\"keyword\">if</span> (c == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">              <span class=\"type\">long</span> <span class=\"variable\">t0</span> <span class=\"operator\">=</span> System.nanoTime();</span><br><span class=\"line\">              <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                  <span class=\"keyword\">if</span> (parent != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">\t<span class=\"comment\">//如果有父加载器，则先委托父加载，否则由启动类加载器加载，如果启动类加载器没有找到，则返回null</span></span><br><span class=\"line\">                      c = parent.loadClass(name, <span class=\"literal\">false</span>);</span><br><span class=\"line\">                  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                      c = findBootstrapClassOrNull(name);</span><br><span class=\"line\">                  &#125;</span><br><span class=\"line\">              &#125; <span class=\"keyword\">catch</span> (ClassNotFoundException e) &#123;</span><br><span class=\"line\">                  <span class=\"comment\">// ClassNotFoundException thrown if class not found</span></span><br><span class=\"line\">                  <span class=\"comment\">// from the non-null parent class loader</span></span><br><span class=\"line\">\t<span class=\"comment\">//这里的ClassNotFoundException来自父加载器</span></span><br><span class=\"line\">              &#125;</span><br><span class=\"line\">              <span class=\"keyword\">if</span> (c == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">                  <span class=\"comment\">// If still not found, then invoke findClass in order</span></span><br><span class=\"line\">                  <span class=\"comment\">// to find the class.</span></span><br><span class=\"line\">\t<span class=\"comment\">//在父类Classloader还没办法加载的时候</span></span><br><span class=\"line\">\t<span class=\"comment\">//再调用本身的findclass方法来加载类</span></span><br><span class=\"line\">                  <span class=\"type\">long</span> <span class=\"variable\">t1</span> <span class=\"operator\">=</span> System.nanoTime();</span><br><span class=\"line\">                  c = findClass(name);</span><br><span class=\"line\">              &#125;</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">          <span class=\"keyword\">if</span> (resolve) &#123;</span><br><span class=\"line\">              resolveClass(c);</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">          <span class=\"keyword\">return</span> c;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<p>代码的逻辑很清楚：</p>\n<blockquote>\n<p><strong>先加载类是否已经被加载过，若没有则调用父的loadClass()方法，如果父 类加载器为空，则使用启动类加载器作为父加载器，如果父 类加载器加载失败，再调用自己的findClass()方法进行加载</strong></p>\n</blockquote>\n","raw":"title: Java虚拟机类的加载机制\nauthor: 落叶挽歌\nthumbnail: 'https://images.pexels.com/photos/340152/pexels-photo-340152.jpeg?auto=compress&cs=tinysrgb&dpr=2&h=650&w=940'\ntags:\n  - Java\ncategories:\n  - 技术文章\ndate: 2019-03-21 09:35:00\n---\n**什么是虚拟机类的加载机制？**\n> 虚拟机把描述类的数据从class文件加载到内存，并对数据进行校验，转换，解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这就是虚拟机的类加载机制。\n\n\n类从加载到虚拟机的内存中开始，直到卸载出内存为止，整个生命周期为：\n\n- 加载（loading）\n\n- 验证（verification）\n\n- 准备(preparation)\n\n- 解析(resolution)\n\n- 初始化(initialization)\n\n- 使用(using)\n\n- 卸载（unloading）\n\n其中 验证、准备、解析部分统称为连接\n\n{% qnimg 6870166cdec78b95356d73621e32757829b.jpg %}\n接下来依次讲解，各个步骤所做的事\n\n**第一部分 加载**\n------------\n\n------------\n\n\n“加载”是“类加载”的一个阶段，注意区分概念。类的加载由**类加载器**（后面介绍）加载主要完成三件事情：\n\n**1、通过一个类的全限定名来获取其定义的二进制字节流。**\n\n**2、将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。**\n\n**3、在Java堆中生成一个代表这个类的java.lang.Class对象，作为对方法区中这些数据的访问入口。**\n> 加载阶段完成后，虚拟机外部的二进制字节流将按照虚拟机所需的格式存储在方法区中，同时在内存中实例化一个java.lang.Class的实例对象。相对于HotSpot，这个实例对象比较特殊，虽然是一个对象，但并没有放置在堆中，而是放置在方法区中。这个对象将作为程序访问方法区中这些类数据的外部接口。\n\n\n**第二部分 验证**\n------------\n\n------------\n这一步主要是确保Class文件的字节流符合虚拟机的规范\n\n主要验证以下几个部分：\n\n**1、文件格式验证**\n验证是否以魔数开头、主次版本号是否在当前虚拟机处理范围内...\n\n这一验证阶段主要是保证输入的字节流能正确地解析并存储与方法区内，格式上符合Java类型信息的要求。只有通过这个阶段，字节流才会进入内存的方法区中存储，后面的三个验证方式也都是给予方法区中的数据验证，不再会操作字节流。\n\n**2、元数据验证**  验证这个类是否有父类、这个类是否继承了不允许继承的类...\n\n该阶段主要对类的元数据进行语义校验，保证符合java语言规范的元数据信息。\n\n**3、字节码验证**\n\n最复杂的一个阶段，主要目的是通过数据流和控制流分析，确定程序语义是否合法、符合逻辑。\n\n**4、符号引用验证** \n\n这个阶段的校验发生在虚拟机将符号引用转化为直接引用的时候，这个转化动作发生在连接的解析阶段。目的是确保解析动作正常执行，如果无法通过验证，将抛出 IllegalAccessError、NoSuchFieldError、NoSuchMethodError等异常。\n\n\n**第三部分 准备**\n------------\n\n------------\n准备阶段是正式为类变量分配内存并设置**类变量初始值**的阶段，这些变量所实用的内存将在**方法区**中进行分配。\n\n**这时候的分配仅仅是类变量(staic修饰的变量)，而实例变量将会在对象实例化时随对象一起分配在Java对中。**\n\n假设一个类变量为：public static int count = 10;这时候会分配0，而不是10，分配10是在程序编译后。\n\n**第四部分 解析**\n------------\n\n------------\n解析阶段是虚拟机将常量池的符号引用替换为直接引用的阶段\n\n**1、类或者接口的的解析**\n\n**2、字段解析**\n\n**3、类方法解析**\n\n**4、接口方法解析**\n\n> **符号引用**与虚拟机实现的布局无关，引用的目标并不一定要已经加载到内存中。各种虚拟机实现的内存布局可以各不相同，但是它们能接受的符号引用必须是一致的，因为符号引用的字面量形式明确定义在Java虚拟机规范的Class文件格式中。\n\n> **直接引用**可以是指向目标的指针，相对偏移量或是一个能间接定位到目标的句柄。如果有了直接引用，那引用的目标必定已经在内存中存在。\n\n**第五部分 初始化**\n------------\n\n------------\n在准备阶段，变量已经被分配赋值过初始值，在初始化阶段根据代码的逻辑初始化真实的变量和其他资源。\n\n\n\n\n**关于类加载器**\n------------\n\n------------\n\n\n**什么是类加载器？**\n\n在“加载”阶段中，通过一个类的全限定名来获取其定义的二进制字节流。这一动作是放到了Java虚拟机外部去实现的，是为了方便让应用自己去决定如何获取所需要的类，实现这个动作的功能是常说的“类加载器（ClassLoader）”\n\n类加载器主要有三种：\n\n**1.启动类加载器(Bootstrap ClassLoader)**\n\n    负责加载<JAVA_HOME>\\lib\n\t\n**2.扩展类加载器(Exension ClassLoader)**\n\n\t负责加载<JAVA_HOME>\\lib\\ext\n\t\n**3.应用程序类加载器(Applicaion ClassLoader)**\n\n\t负责加载ClassPath上指定的类库\n\n\n\n**类加载器工作原理**\n\n介绍类加载器原理之前，必须得了解**双亲委派模型**(Parents Delegation Model)\n>双亲委派模式的工作原理的是：如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行，如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器，如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载。\n\n{% qnimg 853820dea41988382e4e0872063ec33315e.jpg %}\n\n如图所示，这种层次结构关系被称为**双亲委派模型**\n以下为其实现代码，集中在java.lang.ClassLoader中的loadClass()方法中\n```java\n \t\n\t\tprotected Class<?> loadClass(String name, boolean resolve)\n        throws ClassNotFoundException\n    \t{\n        synchronized (getClassLoadingLock(name)) {\n            // First, check if the class has already been loaded\n\t\t//首先检查类是否被加载\n            Class<?> c = findLoadedClass(name);\n            if (c == null) {\n                long t0 = System.nanoTime();\n                try {\n                    if (parent != null) {\n\t\t\t//如果有父加载器，则先委托父加载，否则由启动类加载器加载，如果启动类加载器没有找到，则返回null\n                        c = parent.loadClass(name, false);\n                    } else {\n                        c = findBootstrapClassOrNull(name);\n                    }\n                } catch (ClassNotFoundException e) {\n                    // ClassNotFoundException thrown if class not found\n                    // from the non-null parent class loader\n\t\t\t//这里的ClassNotFoundException来自父加载器\n                }\n                if (c == null) {\n                    // If still not found, then invoke findClass in order\n                    // to find the class.\n\t\t\t//在父类Classloader还没办法加载的时候\n\t\t\t//再调用本身的findclass方法来加载类\n                    long t1 = System.nanoTime();\n                    c = findClass(name);\n                }\n            }\n            if (resolve) {\n                resolveClass(c);\n            }\n            return c;\n        }\n    }\n```\n代码的逻辑很清楚：\n\n> **先加载类是否已经被加载过，若没有则调用父的loadClass()方法，如果父 类加载器为空，则使用启动类加载器作为父加载器，如果父 类加载器加载失败，再调用自己的findClass()方法进行加载**\n\n\n\n\n\n","categories":[{"name":"技术文章","api":"api/categories/technology.json"}],"tags":[{"name":"Java","api":"api/tags/java.json"}]},"api":"api/posts/2019/03/21/Java虚拟机类的加载机制.json"}