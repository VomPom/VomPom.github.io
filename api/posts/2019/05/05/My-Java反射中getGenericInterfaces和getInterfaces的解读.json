{"data":{"title":"Java反射中getGenericInterfaces和getInterfaces的解读","slug":"My-Java反射中getGenericInterfaces和getInterfaces的解读","description":"","date":"2019-05-05T11:12:00.000Z","updated":"2025-05-20T11:46:57.000Z","language":"zh-CN","comments":true,"url":"2019/05/05/My-Java反射中getGenericInterfaces和getInterfaces的解读/","cover":null,"images":[],"content":"<p>今天在做解析网络请求后得到的数据的转化的时候用到了：getGenericInterfaces这个方法。<br> <figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">\t</span><br><span class=\"line\"> <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">  * 获取回调接口中 T 的具体类型</span></span><br><span class=\"line\"><span class=\"comment\">  *</span></span><br><span class=\"line\"><span class=\"comment\">  * <span class=\"doctag\">@param</span> clazz</span></span><br><span class=\"line\"><span class=\"comment\">  * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\">   <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Type <span class=\"title function_\">getTType</span><span class=\"params\">(Class clazz)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//以Type的形式返回本类直接实现的接口.</span></span><br><span class=\"line\">    Type[] types = clazz.getGenericInterfaces();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (types.length &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//返回表示此类型实际类型参数的 Type 对象的数组</span></span><br><span class=\"line\">        Type[] interfacesTypes = ((ParameterizedType) types[<span class=\"number\">0</span>]).getActualTypeArguments();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> interfacesTypes[<span class=\"number\">0</span>];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\t\n\t\n\t</p>\n<p>其中回调接口为：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"title class_\">RequestListener</span> &lt;&gt; () &#123;</span><br><span class=\"line\">     <span class=\"meta\">@Override</span></span><br><span class=\"line\">     <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">onSuccess</span> <span class=\"params\">(List result)</span>&#123;</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">     <span class=\"comment\">//在解析数据的时候这样操作，目的是为了对所有返回的数据进行数据转化为所指定的类型：</span></span><br><span class=\"line\"></span><br><span class=\"line\">     <span class=\"type\">Type</span> <span class=\"variable\">type</span> <span class=\"operator\">=</span> getTType(requestListener.getClass());</span><br><span class=\"line\">     <span class=\"comment\">//泛型是实体或者List等类型</span></span><br><span class=\"line\">     <span class=\"type\">T</span> <span class=\"variable\">t</span> <span class=\"operator\">=</span> JsonUtils.fromJson(resultString, type);</span><br><span class=\"line\">     requestListener.onSuccess(t);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>类RequestListener为：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">RequestListener</span> &#123;</span><br><span class=\"line\">   \t<span class=\"keyword\">void</span> <span class=\"title function_\">onSuccess</span><span class=\"params\">(T result)</span>;</span><br><span class=\"line\">   \t<span class=\"keyword\">void</span> <span class=\"title function_\">onError</span><span class=\"params\">(Exception e)</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>使用Gson进行json的解析，T fromJson(String json, Type typeOfT);那么怎么才能获取到RequestListener中的的类型呢？<br>于是我们从接口获取参数化类型处理。</p>\n<p>官方文档解释</p>\n<p>getGenericInterfaces：</p>\n<blockquote>\n<p>Returns the {@code Type}s representing the interfaces directly implemented by the class or interface represented by this object.释意：返回表示由此对象表示的类或接口直接实现的接口的{@code Type}。</p>\n</blockquote>\n<p>getInterfaces：</p>\n<blockquote>\n<p>Determines the interfaces implemented by the class or interface represented by this object.<br> 释意：返回由此对象表示的类或接口实现的接口。</p>\n</blockquote>\n<p>从解释上面来看出来了，差异在于“接口实现的接口的Type”，接下来用具体示例来解释区别</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Food</span>&#123;</span><br><span class=\"line\">    String foodName;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">Eat</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">void</span> <span class=\"title function_\">eat</span><span class=\"params\">(String things)</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">Run</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Dog</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Eat</span>,Run&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span> &#123; &#125;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">eat</span><span class=\"params\">(String things)</span> &#123; &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">Class</span> <span class=\"variable\">clazz</span> <span class=\"operator\">=</span> Dog.class;</span><br><span class=\"line\">    Type[] genericInterfaces = clazz.getGenericInterfaces();</span><br><span class=\"line\">    Class[] interfaces = clazz.getInterfaces();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<pre><code>运行结果\n&#123;% qnimg 245442107557694aef0f07c25be0740187c.jpg %&#125;\n</code></pre>\n<p>我们可以看到，clazz.getGenericInterfaces()与clazz.getInterfaces()并没有任何差异。因为 并没有：“实现的接口的Type”</p>\n<p>接下来看另一段代码,我们对Eat接口改造一下，增加一个参数化类型</p>\n<pre class=\" language-language-java\"><code class=\"language-language-java\">    private class Food&#123;\n        String foodName;\n    &#125;\n    private interface Eat&#123;\n        void eat(T things);\n    &#125;\n    private interface Run&#123;\n        void run();\n    &#125;\n\n    private class Dog implements Eat,Run&#123;\n        @Override\n        public void run() &#123; &#125;\n        @Override\n        public void eat(Food things) &#123; &#125;\n    &#125;\n    private void main() &#123;\n        Class clazz = Dog.class;\n        Type[] genericInterfaces = clazz.getGenericInterfaces();\n        Class[] interfaces = clazz.getInterfaces();\n    &#125;\n</code></pre>\n<pre><code>运行结果：\n</code></pre>\n<img src=\"https://cdn.julis.wang/blog/img/1e8dd5258232de0b459be594f9793283c0a.jpg\">","raw":"layout: photo\ntitle: Java反射中getGenericInterfaces和getInterfaces的解读\nthumbnail: >-\n  https://images.pexels.com/photos/248515/pexels-photo-248515.png?auto=compress&cs=tinysrgb&dpr=2&h=650&w=940\ntags:\n  - 网络\ncategories:\n  - 技术文章\ndate: 2019-05-05 19:12:00\n---\n今天在做解析网络请求后得到的数据的转化的时候用到了：getGenericInterfaces这个方法。\n ```java \t\t\n\t\n     /**\n      * 获取回调接口中 T 的具体类型\n      *\n      * @param clazz\n      * @return\n      */\n       public static Type getTType(Class clazz) {\n        //以Type的形式返回本类直接实现的接口.\n        Type[] types = clazz.getGenericInterfaces();\n        if (types.length > 0) {\n            //返回表示此类型实际类型参数的 Type 对象的数组\n            Type[] interfacesTypes = ((ParameterizedType) types[0]).getActualTypeArguments();\n            return interfacesTypes[0];\n        }\n        return null;\n    }\n```\t\n\t\n\t\n\t\n\n其中回调接口为：\n```java\n       new RequestListener <> () {\n            @Override\n            public void onSuccess (List result){\n            }\n            //在解析数据的时候这样操作，目的是为了对所有返回的数据进行数据转化为所指定的类型：\n\n            Type type = getTType(requestListener.getClass());\n            //泛型是实体或者List等类型\n            T t = JsonUtils.fromJson(resultString, type);\n            requestListener.onSuccess(t);\n       }\n```\n类RequestListener为：\n```java\n\tpublic interface RequestListener {\n    \tvoid onSuccess(T result);\n    \tvoid onError(Exception e);\n\t}\n```\n使用Gson进行json的解析，T fromJson(String json, Type typeOfT);那么怎么才能获取到RequestListener中的的类型呢？\n于是我们从接口获取参数化类型处理。\n\n官方文档解释\n\ngetGenericInterfaces：\n\n> Returns the {@code Type}s representing the interfaces directly implemented by the class or interface represented by this object.释意：返回表示由此对象表示的类或接口直接实现的接口的{@code Type}。\n\ngetInterfaces：\n\n> Determines the interfaces implemented by the class or interface represented by this object.\n 释意：返回由此对象表示的类或接口实现的接口。\n\n从解释上面来看出来了，差异在于“接口实现的接口的Type”，接下来用具体示例来解释区别\n```java\n    private class Food{\n        String foodName;\n    }\n    private interface Eat{\n        void eat(String things);\n    }\n    private interface Run{\n        void run();\n    }\n    private class Dog implements Eat,Run{\n        @Override\n        public void run() { }\n        @Override\n        public void eat(String things) { }\n    }\n    private void main() {\n        Class clazz = Dog.class;\n        Type[] genericInterfaces = clazz.getGenericInterfaces();\n        Class[] interfaces = clazz.getInterfaces();\n    }\n```\n\t运行结果\n\t{% qnimg 245442107557694aef0f07c25be0740187c.jpg %}\n\t\n\n我们可以看到，clazz.getGenericInterfaces()与clazz.getInterfaces()并没有任何差异。因为 并没有：“实现的接口的Type”\n\n接下来看另一段代码,我们对Eat接口改造一下，增加一个参数化类型\n```java\n    private class Food{\n        String foodName;\n    }\n    private interface Eat{\n        void eat(T things);\n    }\n    private interface Run{\n        void run();\n    }\n\n    private class Dog implements Eat,Run{\n        @Override\n        public void run() { }\n        @Override\n        public void eat(Food things) { }\n    }\n    private void main() {\n        Class clazz = Dog.class;\n        Type[] genericInterfaces = clazz.getGenericInterfaces();\n        Class[] interfaces = clazz.getInterfaces();\n    }\n```    \n\t运行结果：\n\n{% qnimg 1e8dd5258232de0b459be594f9793283c0a.jpg %}","categories":[{"name":"技术文章","api":"api/categories/technology.json"}],"tags":[{"name":"网络","api":"api/tags/网络.json"}]},"api":"api/posts/2019/05/05/My-Java反射中getGenericInterfaces和getInterfaces的解读.json"}