{"data":{"title":"基于Volley框架的返回数据的范型处理","slug":"基于Volley框架的返回数据的范型处理","description":"","date":"2019-05-13T06:56:00.000Z","updated":"2025-05-20T11:46:57.000Z","language":"zh-CN","comments":true,"url":"2019/05/13/基于Volley框架的返回数据的范型处理/","cover":null,"images":[],"content":"<p>在平时最普通的Volley的网络请求中，我们StringRequest是这样请求网络数据的：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">StringRequest</span> <span class=\"variable\">stringRequest</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">StringRequest</span>(<span class=\"string\">&quot;http://www.baidu.com&quot;</span>,</span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">Response</span>.Listener&lt;String&gt;() &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">onResponse</span><span class=\"params\">(String response)</span> &#123;</span><br><span class=\"line\">                Log.d(<span class=\"string\">&quot;TAG&quot;</span>, response);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;, <span class=\"keyword\">new</span> <span class=\"title class_\">Response</span>.ErrorListener() &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">onErrorResponse</span><span class=\"params\">(VolleyError error)</span> &#123;</span><br><span class=\"line\">        Log.e(<span class=\"string\">&quot;TAG&quot;</span>, error.getMessage(), error);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>注意在onResponse的时候是拿到的string类型，拿到string后对其再进行相关的解析，我们是否是可以对其直接封装然后拿到具体想要类型的model数据结构呢？所以对其网络请求架构进行一次封装，到达如下效果：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">GetGoodDetailByGidRequest</span> <span class=\"variable\">getGoodDetailByGidRequest</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">GetGoodDetailByGidRequest</span>(mCouponId,</span><br><span class=\"line\">              <span class=\"keyword\">new</span> <span class=\"title class_\">RequestListener</span>&lt;List&lt;CouponModel&gt;&gt;() &#123;</span><br><span class=\"line\">                  <span class=\"meta\">@Override</span></span><br><span class=\"line\">                  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">onSuccess</span><span class=\"params\">(List&lt;CouponModel&gt; result)</span> &#123;</span><br><span class=\"line\">                  &#125;</span><br><span class=\"line\">                  <span class=\"meta\">@Override</span></span><br><span class=\"line\">                  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">onError</span><span class=\"params\">(Exception e)</span> &#123;</span><br><span class=\"line\">                      e.printStackTrace();</span><br><span class=\"line\">                      stopLoadingDialog();</span><br><span class=\"line\">                  &#125;</span><br><span class=\"line\">              &#125;);</span><br></pre></td></tr></table></figure>\n<p>这里我们在构造Request的时候指定了返回数据的类型，这样的话就方便了我们在写业务的时候直接使用解析好的数据结构，具体如何做到的呢？</p>\n<p><strong>一、让每个Request基于一个带有范型请求类</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">class</span> <span class=\"title class_\">BaseApiRequest</span>&lt;T&gt;  </span><br></pre></td></tr></table></figure>\n<p>这里的T就是目标请求期望的model类<br>在具体实现的时候继承基类，并指定返回类型，下面是一个例子：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">GetGoodDetailByGidRequest</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">BaseApiRequest</span>&lt;List&lt;CouponModel&gt;&gt; &#123;</span><br><span class=\"line\">   \t<span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">String</span> <span class=\"variable\">url</span> <span class=\"operator\">=</span> CURL.GoodDetailURL;</span><br><span class=\"line\">   \t<span class=\"keyword\">public</span> <span class=\"title function_\">GetGoodDetailByGidRequest</span><span class=\"params\">(String goodId, RequestListener&lt;List&lt;CouponModel&gt;&gt; requestListener)</span> &#123;</span><br><span class=\"line\">       \t\t<span class=\"built_in\">super</span>(requestListener);</span><br><span class=\"line\">       \t\t<span class=\"built_in\">this</span>.mUrlParams.put(<span class=\"string\">&quot;id&quot;</span>, goodId);</span><br><span class=\"line\">   \t&#125;</span><br><span class=\"line\">   \t<span class=\"meta\">@Override</span></span><br><span class=\"line\">   \t<span class=\"keyword\">public</span> String <span class=\"title function_\">getBaseUrl</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">       \t\t<span class=\"keyword\">return</span> url;</span><br><span class=\"line\">  \t\t &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>二、在基类中构造网络请求</strong>\t</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">protected</span> StringRequest <span class=\"title function_\">getStringRequest</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">     <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">StringRequest</span>(requestMethod, getRequestUrl(),</span><br><span class=\"line\">             response -&gt; parseJson(response),</span><br><span class=\"line\">             error -&gt; requestListener.onError(error)) &#123;</span><br><span class=\"line\">         <span class=\"meta\">@Override</span></span><br><span class=\"line\">         <span class=\"keyword\">protected</span> Map&lt;String, String&gt; <span class=\"title function_\">getParams</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">             <span class=\"keyword\">return</span> mEntityParams;</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">     &#125;;</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n<p>在此处实现可以看到Request在基类中进行，然后分别处理返回结果</p>\n<p><strong>三、对返回结果进行解析</strong>\t</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">parseJson</span><span class=\"params\">(String response)</span> &#123;</span><br><span class=\"line\">      <span class=\"type\">int</span> <span class=\"variable\">responseCode</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">      <span class=\"type\">int</span> <span class=\"variable\">errorCode</span> <span class=\"operator\">=</span> <span class=\"number\">400</span>;</span><br><span class=\"line\">      <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">          <span class=\"type\">JSONObject</span> <span class=\"variable\">jsonObject</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">JSONObject</span>(response);</span><br><span class=\"line\"></span><br><span class=\"line\">          <span class=\"type\">String</span> <span class=\"variable\">resultString</span> <span class=\"operator\">=</span> jsonObject.getString(<span class=\"string\">&quot;data&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">          <span class=\"keyword\">if</span> (jsonObject.has(<span class=\"string\">&quot;code&quot;</span>)) &#123;</span><br><span class=\"line\">              responseCode = jsonObject.getInt(<span class=\"string\">&quot;code&quot;</span>);</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">          <span class=\"keyword\">if</span> (jsonObject.has(<span class=\"string\">&quot;error&quot;</span>)) &#123;</span><br><span class=\"line\">              errorCode = jsonObject.getInt(<span class=\"string\">&quot;error&quot;</span>);</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">          <span class=\"keyword\">if</span> (responseCode == <span class=\"number\">200</span> || errorCode == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">              <span class=\"keyword\">if</span> (!TextUtils.isEmpty(response)) &#123;</span><br><span class=\"line\">                  <span class=\"type\">Type</span> <span class=\"variable\">type</span> <span class=\"operator\">=</span> getTType(requestListener.getClass());</span><br><span class=\"line\">                  <span class=\"comment\">//泛型是实体或者List等类型</span></span><br><span class=\"line\">                  <span class=\"type\">T</span> <span class=\"variable\">t</span> <span class=\"operator\">=</span> JsonUtils.fromJson(resultString, type);</span><br><span class=\"line\">                  requestListener.onSuccess(t);</span><br><span class=\"line\">                  <span class=\"keyword\">return</span>;</span><br><span class=\"line\">              &#125;</span><br><span class=\"line\">              ToastUtils.showToast(<span class=\"string\">&quot;Data is empty!&quot;</span>);</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">          ToastUtils.showToast(<span class=\"string\">&quot;Response code is error.&quot;</span>);</span><br><span class=\"line\">          requestListener.onError(<span class=\"keyword\">new</span> <span class=\"title class_\">ParseError</span>());</span><br><span class=\"line\">      &#125; <span class=\"keyword\">catch</span> (JSONException e) &#123;</span><br><span class=\"line\">          ToastUtils.showToast(e.toString());</span><br><span class=\"line\">          e.printStackTrace();</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<p>这里是最关键的一步，由于和后端约定好相关返回字段，那么只需要解析字段中目标model的数据，其中比较重要的是这段代码</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">\t<span class=\"type\">Type</span> <span class=\"variable\">type</span> <span class=\"operator\">=</span> getTType(requestListener.getClass());</span><br><span class=\"line\">    <span class=\"comment\">//泛型是实体或者List等类型</span></span><br><span class=\"line\">     <span class=\"type\">T</span> <span class=\"variable\">t</span> <span class=\"operator\">=</span> JsonUtils.fromJson(resultString, type);</span><br><span class=\"line\">     requestListener.onSuccess(t);</span><br><span class=\"line\">```\t </span><br><span class=\"line\">通过封装好的 JsonUtils将String转化为对应的model类型，我们知道json转实体对象的时候，需要指明其类type，那这里的type是如何获取到的呢？</span><br><span class=\"line\"></span><br><span class=\"line\">其中getTType ()的具体实现为：</span><br><span class=\"line\"> ```java</span><br><span class=\"line\">     <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Type <span class=\"title function_\">getTType</span><span class=\"params\">(Class&lt;?&gt; clazz)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//以Type的形式返回本类直接实现的接口.</span></span><br><span class=\"line\">        Type[] types = clazz.getGenericInterfaces();</span><br><span class=\"line\">        clazz.getInterfaces();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (types.length &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//返回表示此类型实际类型参数的 Type 对象的数组</span></span><br><span class=\"line\">            Type[] interfacesTypes = ((ParameterizedType) types[<span class=\"number\">0</span>]).getActualTypeArguments();</span><br><span class=\"line\">            <span class=\"keyword\">return</span> interfacesTypes[<span class=\"number\">0</span>];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>通过次方法能够获取到请求实现中所指明的请求类型，其中getGenericInterfaces等相关原理可以阅读：<a href=\"https://my.oschina.net/617669559/blog/3012228\">https://my.oschina.net/617669559/blog/3012228</a></p>\n<p>所以对于\t</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">GetGoodDetailByGidRequest</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">BaseApiRequest</span>&lt;List&lt;CouponModel&gt;&gt;</span><br></pre></td></tr></table></figure>\n<p>那么获取到的就是List<CouponModel>类型</p>\n<p><strong>四、通过Listener回调相关解析结果</strong>\t</p>\n<p>拿到解析好的result并回调给构造Request方法中的listener使用</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">T</span> <span class=\"variable\">t</span> <span class=\"operator\">=</span> JsonUtils.fromJson(resultString, type);</span><br><span class=\"line\">requestListener.onSuccess(t);</span><br></pre></td></tr></table></figure>\n<p>这样对整个网络请求后的返回数据直接进行解析方便多了。</p>\n<p><strong>总结：</strong></p>\n<p>1、本文最主要是对基本Request类进行改造，以达到不需要每次重复写解析返回的String数据</p>\n<p>2、在获取目标的类的类型的时候，主要是去获取基类中的“T”类型</p>\n<p>3、设计不仅适用用Volley同样适用于其他类似的网络请求框架</p>\n","raw":"title: 基于Volley框架的返回数据的范型处理\nauthor: 落叶挽歌\nthumbnail: 'https://images.pexels.com/photos/574077/pexels-photo-574077.jpeg?auto=compress&cs=tinysrgb&dpr=2&h=650&w=940'\ntags:\n  - 安卓\ncategories:\n  - 技术文章\ndate: 2019-05-13 14:56:00\n---\n在平时最普通的Volley的网络请求中，我们StringRequest是这样请求网络数据的：\n```java\n    StringRequest stringRequest = new StringRequest(\"http://www.baidu.com\",\n            new Response.Listener<String>() {\n                @Override\n                public void onResponse(String response) {\n                    Log.d(\"TAG\", response);\n                }\n            }, new Response.ErrorListener() {\n        @Override\n        public void onErrorResponse(VolleyError error) {\n            Log.e(\"TAG\", error.getMessage(), error);\n        }\n```\n注意在onResponse的时候是拿到的string类型，拿到string后对其再进行相关的解析，我们是否是可以对其直接封装然后拿到具体想要类型的model数据结构呢？所以对其网络请求架构进行一次封装，到达如下效果：\n```java\n \tGetGoodDetailByGidRequest getGoodDetailByGidRequest = new GetGoodDetailByGidRequest(mCouponId,\n                new RequestListener<List<CouponModel>>() {\n                    @Override\n                    public void onSuccess(List<CouponModel> result) {\n                    }\n                    @Override\n                    public void onError(Exception e) {\n                        e.printStackTrace();\n                        stopLoadingDialog();\n                    }\n                });\n```\n这里我们在构造Request的时候指定了返回数据的类型，这样的话就方便了我们在写业务的时候直接使用解析好的数据结构，具体如何做到的呢？\n\n**一、让每个Request基于一个带有范型请求类**\n```java\n\tpublic abstract class BaseApiRequest<T>  \n```\t\n这里的T就是目标请求期望的model类\n在具体实现的时候继承基类，并指定返回类型，下面是一个例子：\n```java\n\tpublic class GetGoodDetailByGidRequest extends BaseApiRequest<List<CouponModel>> {\n    \tpublic static final String url = CURL.GoodDetailURL;\n    \tpublic GetGoodDetailByGidRequest(String goodId, RequestListener<List<CouponModel>> requestListener) {\n        \t\tsuper(requestListener);\n        \t\tthis.mUrlParams.put(\"id\", goodId);\n    \t}\n    \t@Override\n    \tpublic String getBaseUrl() {\n        \t\treturn url;\n   \t\t }\n\t}\n```\n**二、在基类中构造网络请求**\t\n```java\n  \tprotected StringRequest getStringRequest() {\n        return new StringRequest(requestMethod, getRequestUrl(),\n                response -> parseJson(response),\n                error -> requestListener.onError(error)) {\n            @Override\n            protected Map<String, String> getParams() {\n                return mEntityParams;\n            }\n        };\n    }\n```\n在此处实现可以看到Request在基类中进行，然后分别处理返回结果\n\n**三、对返回结果进行解析**\t\n```java\n\t\tprivate void parseJson(String response) {\n        int responseCode = 0;\n        int errorCode = 400;\n        try {\n            JSONObject jsonObject = new JSONObject(response);\n\n            String resultString = jsonObject.getString(\"data\");\n\n            if (jsonObject.has(\"code\")) {\n                responseCode = jsonObject.getInt(\"code\");\n            }\n            if (jsonObject.has(\"error\")) {\n                errorCode = jsonObject.getInt(\"error\");\n            }\n\n            if (responseCode == 200 || errorCode == 0) {\n                if (!TextUtils.isEmpty(response)) {\n                    Type type = getTType(requestListener.getClass());\n                    //泛型是实体或者List等类型\n                    T t = JsonUtils.fromJson(resultString, type);\n                    requestListener.onSuccess(t);\n                    return;\n                }\n                ToastUtils.showToast(\"Data is empty!\");\n            }\n            ToastUtils.showToast(\"Response code is error.\");\n            requestListener.onError(new ParseError());\n        } catch (JSONException e) {\n            ToastUtils.showToast(e.toString());\n            e.printStackTrace();\n        }\n    }\n```\n这里是最关键的一步，由于和后端约定好相关返回字段，那么只需要解析字段中目标model的数据，其中比较重要的是这段代码\n```java\n\tType type = getTType(requestListener.getClass());\n    //泛型是实体或者List等类型\n     T t = JsonUtils.fromJson(resultString, type);\n     requestListener.onSuccess(t);\n```\t \n通过封装好的 JsonUtils将String转化为对应的model类型，我们知道json转实体对象的时候，需要指明其类type，那这里的type是如何获取到的呢？\n\n其中getTType ()的具体实现为：\n ```java\n     public static Type getTType(Class<?> clazz) {\n        //以Type的形式返回本类直接实现的接口.\n        Type[] types = clazz.getGenericInterfaces();\n        clazz.getInterfaces();\n        if (types.length > 0) {\n            //返回表示此类型实际类型参数的 Type 对象的数组\n            Type[] interfacesTypes = ((ParameterizedType) types[0]).getActualTypeArguments();\n            return interfacesTypes[0];\n        }\n        return null;\n    }\n```\n通过次方法能够获取到请求实现中所指明的请求类型，其中getGenericInterfaces等相关原理可以阅读：https://my.oschina.net/617669559/blog/3012228\n\n所以对于\t\n```java\n\tpublic class GetGoodDetailByGidRequest extends BaseApiRequest<List<CouponModel>>\n```\t\n那么获取到的就是List<CouponModel>类型\n\n**四、通过Listener回调相关解析结果**\t\n\n拿到解析好的result并回调给构造Request方法中的listener使用\n```java\t\nT t = JsonUtils.fromJson(resultString, type);\nrequestListener.onSuccess(t);\n```\n\t\n这样对整个网络请求后的返回数据直接进行解析方便多了。\n\n**总结：**\n\n1、本文最主要是对基本Request类进行改造，以达到不需要每次重复写解析返回的String数据\n\n2、在获取目标的类的类型的时候，主要是去获取基类中的“T”类型\n\n3、设计不仅适用用Volley同样适用于其他类似的网络请求框架\n","categories":[{"name":"技术文章","api":"api/categories/technology.json"}],"tags":[{"name":"安卓","api":"api/tags/Android.json"}]},"api":"api/posts/2019/05/13/基于Volley框架的返回数据的范型处理.json"}