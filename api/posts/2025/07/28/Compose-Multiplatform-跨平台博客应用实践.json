{"data":{"title":"[Compose Multiplatform]跨平台博客应用实践","slug":"Compose-Multiplatform-跨平台博客应用实践","description":"","date":"2025-07-28T12:28:00.000Z","updated":"2025-07-28T14:51:23.535Z","language":"zh-CN","comments":true,"url":"2025/07/28/Compose-Multiplatform-跨平台博客应用实践/","cover":null,"images":[],"content":"<h2 id=\"用-CMP-构建跨平台博客应用：一次-Kotlin-的全栈实践\"><a href=\"#用-CMP-构建跨平台博客应用：一次-Kotlin-的全栈实践\" class=\"headerlink\" title=\"用 CMP 构建跨平台博客应用：一次 Kotlin 的全栈实践\"></a>用 CMP 构建跨平台博客应用：一次 Kotlin 的全栈实践</h2><p>在追求高效开发的时代，跨平台技术已成为移动应用开发的主流选择，此前基于鸿蒙的开发平台开发 <a href=\"https://julis.wang/2025/05/16/%E9%B8%BF%E8%92%99-%E5%86%99%E4%BA%86%E4%B8%AA%E5%9F%BA%E4%BA%8EHexo%E5%8D%9A%E5%AE%A2%E7%9A%84%E9%B8%BF%E8%92%99App/\">blog_harmony</a>，将自己博客文章进行展示。本文将介绍基于 <strong>CMP(Compose Multiplatform)</strong> 构建的开源博客应用 <a href=\"https://github.com/VomPom/blog_kmp\">blog_kmp</a>，展示如何用 Kotlin 实现跨平台的应用开发。</p>\n<h3 id=\"Compose-Multiplatform\"><a href=\"#Compose-Multiplatform\" class=\"headerlink\" title=\"Compose Multiplatform\"></a>Compose Multiplatform</h3><p>Compose Multiplatform 是 JetBrains 推出的声明式 UI 框架，基于 Jetpack Compose 扩展而来：</p>\n<ul>\n<li><strong>核心优势</strong>：用同一套 Kotlin 代码构建 Android、iOS、Desktop 和 Web 应用</li>\n<li><strong>开发效率</strong>：实时预览、热重载加速开发迭代</li>\n<li><strong>原生性能</strong>：通过 Skia 渲染引擎实现接近原生体验</li>\n<li><strong>共享逻辑</strong>：业务逻辑、网络请求、状态管理可 100% 复用</li>\n</ul>\n<h3 id=\"项目架构与技术栈\"><a href=\"#项目架构与技术栈\" class=\"headerlink\" title=\"项目架构与技术栈\"></a>项目架构与技术栈</h3><p>blog_kmp 采用分层架构设计，核心模块包括：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"code\"><pre><span class=\"line\">shared/</span><br><span class=\"line\">├── src/commonMain/kotlin/  # 共享业务逻辑</span><br><span class=\"line\">│   ├── <span class=\"keyword\">data</span>/               # 数据层</span><br><span class=\"line\">│   ├── domain/             # 领域模型</span><br><span class=\"line\">│   └── presentation/       # UI状态管理</span><br><span class=\"line\">├── src/androidMain/        # Android 平台代码</span><br><span class=\"line\">└── src/iosMain/            # iOS 平台适配</span><br><span class=\"line\">├── composeApp</span><br><span class=\"line\">│   ├── build.gradle.kts</span><br><span class=\"line\">│   └── src</span><br><span class=\"line\">│       ├── androidMain     # Android 平台代码</span><br><span class=\"line\">│       ├── commonMain      # 共享业务逻辑</span><br><span class=\"line\">│            ├── App.kt     # 界面展示入口</span><br><span class=\"line\">│            ├── <span class=\"keyword\">data</span>       # 数据层</span><br><span class=\"line\">│            │   ├── api        # 网络请求</span><br><span class=\"line\">│            │   ├── di         # koin 依赖注入</span><br><span class=\"line\">│            │   ├── model      # model 数据</span><br><span class=\"line\">│            │   └── repository # 数据缓存管理</span><br><span class=\"line\">│            │</span><br><span class=\"line\">│            ├── navigation  # 页面间导航管理</span><br><span class=\"line\">│            ├── platform    # 通过对各个平台抽象的接口 </span><br><span class=\"line\">│            └── ui          # 通用 UI 逻辑</span><br><span class=\"line\">│</span><br><span class=\"line\">│       ├── desktopMain     # Desktop 平台适配</span><br><span class=\"line\">│       └── iosMain         # iOS 平台适配</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"功能预览\"><a href=\"#功能预览\" class=\"headerlink\" title=\"功能预览\"></a>功能预览</h2><h3 id=\"Android\"><a href=\"#Android\" class=\"headerlink\" title=\"Android\"></a>Android</h3><p><img src=\"https://cdn.julis.wang/github/blog_cmp/android.png\"></p>\n<h4 id=\"深色模式\"><a href=\"#深色模式\" class=\"headerlink\" title=\"深色模式\"></a>深色模式</h4><p><img src=\"https://cdn.julis.wang/github/blog_cmp/dark.png\"></p>\n<h3 id=\"iOS\"><a href=\"#iOS\" class=\"headerlink\" title=\"iOS\"></a>iOS</h3><p><img src=\"https://cdn.julis.wang/github/blog_cmp/ios.png\"></p>\n<h3 id=\"Desktop\"><a href=\"#Desktop\" class=\"headerlink\" title=\"Desktop\"></a>Desktop</h3><p><img src=\"https://cdn.julis.wang/github/blog_cmp/desktop.png\"></p>\n<h4 id=\"主要技术栈\"><a href=\"#主要技术栈\" class=\"headerlink\" title=\"主要技术栈\"></a>主要技术栈</h4><ol>\n<li><strong>Ktor 客户端</strong> - 网络请求</li>\n</ol>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> httpClient = HttpClient &#123;</span><br><span class=\"line\">    install(ContentNegotiation) &#123;</span><br><span class=\"line\">        json(Json &#123; ignoreUnknownKeys = <span class=\"literal\">true</span> &#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">suspend</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">loadPosts</span><span class=\"params\">()</span></span>: List&lt;Post&gt; = </span><br><span class=\"line\">    httpClient.<span class=\"keyword\">get</span>(<span class=\"string\">&quot;https://cdn.julis/api/posts&quot;</span>).body()</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li><strong>DataStore</strong> - 跨平台数据库</li>\n</ol>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> dataKey = stringPreferencesKey(key)</span><br><span class=\"line\"><span class=\"keyword\">val</span> result = dataStore.<span class=\"keyword\">data</span></span><br><span class=\"line\">    .<span class=\"keyword\">catch</span> &#123; exception -&gt;</span><br><span class=\"line\">        <span class=\"comment\">// dataStore.data throws an IOException when an error is encountered when reading data</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (exception <span class=\"keyword\">is</span> IOException) &#123;</span><br><span class=\"line\">            emit(emptyPreferences())</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> exception</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    .map &#123; preferences -&gt;</span><br><span class=\"line\">        <span class=\"keyword\">val</span> <span class=\"keyword\">data</span>: String? = preferences[dataKey]</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">data</span> == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"literal\">null</span></span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (isJson) Json.decodeFromString&lt;T&gt;(<span class=\"keyword\">data</span>) <span class=\"keyword\">else</span> (<span class=\"keyword\">data</span> <span class=\"keyword\">as</span> T)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li><strong>Koin</strong> - 依赖注入</li>\n</ol>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> sharedModule = module &#123;</span><br><span class=\"line\">    single&lt;PostRepository&gt; &#123; PostRepositoryImpl(<span class=\"keyword\">get</span>()) &#125;</span><br><span class=\"line\">    viewModel &#123; PostViewModel(<span class=\"keyword\">get</span>()) &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"4\">\n<li><strong>Kotlinx.Serialization</strong> - JSON 解析</li>\n</ol>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Serializable</span></span><br><span class=\"line\"><span class=\"keyword\">data</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Post</span>(</span><br><span class=\"line\">    <span class=\"keyword\">val</span> id: String,</span><br><span class=\"line\">    <span class=\"keyword\">val</span> title: String,</span><br><span class=\"line\">    <span class=\"keyword\">val</span> content: String</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n\n<ol start=\"5\">\n<li><strong>compose-webview-multiplatform</strong> - WebView 浏览器<br>使用的第三方开发<a href=\"https://github.com/KevinnZou/compose-webview-multiplatform\">compose-webview-multiplatform</a>基于 <a href=\"https://github.com/chromiumembedded/java-cef\">java-cef</a>开发，不过这个library 在 desktop 平台表现不是太好，待完善。</li>\n</ol>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> state = rememberWebViewState(postUrl)</span><br><span class=\"line\"> WebView(state = state,modifier = Modifier.fillMaxSize())            </span><br></pre></td></tr></table></figure>\n\n\n<h3 id=\"平台特定实现\"><a href=\"#平台特定实现\" class=\"headerlink\" title=\"平台特定实现\"></a>平台特定实现</h3><p>UI 层面三端能够使用同一份代码，但为了体验，可能需要针对不同的设计，在桌面端可以设计更好地体验UI。这里避免不了 if-else 的UI逻辑，以及一些依赖各种系统的 api 需要单独实现，比如：深色模式监听、资源存储路径、系统信息、状态栏颜色等。</p>\n<p><strong>Android 端</strong><br>Android 特定的功能结合使用起来非常的简单，毕竟都是有血缘关系的。可以使用 AndroidView 直接渲染原生的 UI 页面。</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"code\"><pre><span class=\"line\">AndroidView(</span><br><span class=\"line\">      modifier = Modifier.fillMaxSize(),</span><br><span class=\"line\">      factory = &#123; context -&gt;</span><br><span class=\"line\">          MyView(context) &#125;</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      update = &#123; view -&gt;&#125;</span><br><span class=\"line\">  )</span><br></pre></td></tr></table></figure>\n\n<p><strong>iOS 端</strong><br>iOS端主要需要 XCode 进行配合，还需要关注开发者账号相关的信息等，其他与 Android 端实现没有太大的差异。</p>\n<p><strong>桌面端</strong><br>利用 Compose Desktop 的窗口管理，可以实现窗口多开。</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> = application &#123;</span><br><span class=\"line\">    Window(onCloseRequest = ::exitApplication) &#123;</span><br><span class=\"line\">        DesktopAppTheme &#123; AppContent() &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<h3 id=\"🚀-性能优化实践\"><a href=\"#🚀-性能优化实践\" class=\"headerlink\" title=\"🚀 性能优化实践\"></a>🚀 性能优化实践</h3><ol>\n<li><strong>分页加载</strong>：实现懒加载防止长列表卡顿</li>\n</ol>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"code\"><pre><span class=\"line\">LazyColumn &#123;</span><br><span class=\"line\">    itemsIndexed(posts) &#123; _, post -&gt;</span><br><span class=\"line\">        PostItem(post)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    item &#123; <span class=\"keyword\">if</span> (loading) LoadingIndicator() &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li><strong>本地缓存</strong>：DataStore 离线存储 + Ktor 缓存策略</li>\n</ol>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"code\"><pre><span class=\"line\">HttpClient &#123;</span><br><span class=\"line\">    install(HttpCache) <span class=\"comment\">// 启用 HTTP 缓存</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li><strong>图像处理</strong>：搭配 Coil 实现高效图片加载</li>\n</ol>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"code\"><pre><span class=\"line\">AsyncImage(</span><br><span class=\"line\">    modifier = Modifier.size(<span class=\"number\">80.</span>dp)</span><br><span class=\"line\">        .shadow(</span><br><span class=\"line\">            elevation = <span class=\"number\">5.</span>dp,</span><br><span class=\"line\">            shape = CircleShape,</span><br><span class=\"line\">            spotColor = Color.Black</span><br><span class=\"line\">        )</span><br><span class=\"line\">        .clip(CircleShape)</span><br><span class=\"line\">        .clickable &#123; &#125;,</span><br><span class=\"line\">    model = AppConfig.AVATAR,</span><br><span class=\"line\">    contentDescription = AppConfig.AVATAR,</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n<h3 id=\"开发经验总结\"><a href=\"#开发经验总结\" class=\"headerlink\" title=\"开发经验总结\"></a>开发经验总结</h3><ol>\n<li><p><strong>UI界面</strong><br>  使用 <a href=\"https://developer.android.com/compose\">Compose</a> 进行界面布局开发，声明性编程范式相比于传统的 xml 布局开发，高效很多，使用也很方便。使用了这种方式，传统的 UI 开发方式再也回不去了。</p>\n</li>\n<li><p><strong>状态管理</strong><br>使用 <code>mutableStateOf</code> 实现响应式更新，或者使用 <code>derivedStateOf</code> 实现派生状态的处理。</p>\n</li>\n</ol>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> pagIndex <span class=\"keyword\">by</span> remember &#123; mutableStateOf(<span class=\"number\">0</span>) &#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> errorState <span class=\"keyword\">by</span> remember &#123; mutableStateOf&lt;String?&gt;(<span class=\"literal\">null</span>) &#125;   </span><br><span class=\"line\"><span class=\"keyword\">val</span> themeState <span class=\"keyword\">by</span> mineViewModel.appTheme.collectAsState()</span><br><span class=\"line\"><span class=\"keyword\">val</span> uiChecked <span class=\"keyword\">by</span> remember(themeState) &#123; derivedStateOf &#123; themeState == ThemeConstants.DARK &#125; &#125;</span><br></pre></td></tr></table></figure>\n\n\n<ol start=\"3\">\n<li><strong>导航</strong></li>\n</ol>\n<p>实现 <code>Compose Navigator</code> 统一路由管理</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> gotoDebug: () -&gt; <span class=\"built_in\">Unit</span> = &#123;</span><br><span class=\"line\">    navController.navigate(Routes.Debug())</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">val</span> goToPostDetail: (Post) -&gt; <span class=\"built_in\">Unit</span> = &#123; it -&gt;</span><br><span class=\"line\">    navController.navigate(Routes.PostDetail(title = it.title, it.url))</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ol start=\"4\">\n<li><strong>Kotlin Flow</strong><br>简化异步编程，让网络请求的代码看起来更直观</li>\n</ol>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">loadAllPost</span><span class=\"params\">()</span></span>: Flow&lt;List&lt;PostV2&gt;&gt; = load(<span class=\"string\">&quot;allPosts&quot;</span>) &#123;</span><br><span class=\"line\">    postApi.getAllPost()?.<span class=\"keyword\">data</span> ?: emptyList()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">suspend</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">getAllPost</span><span class=\"params\">()</span></span>: SearchResponse? = request&lt;SearchResponse&gt;(getUrl(<span class=\"string\">&quot;api/search.json&quot;</span>))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">suspend</span> <span class=\"keyword\">inline</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"type\">&lt;<span class=\"keyword\">reified</span> T&gt;</span> <span class=\"title\">request</span><span class=\"params\">(url: <span class=\"type\">String</span>)</span></span>: T? &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        client.<span class=\"keyword\">get</span>(url).body()</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (e: Exception) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (e <span class=\"keyword\">is</span> CancellationException) <span class=\"keyword\">throw</span> e</span><br><span class=\"line\">        e.printStackTrace()</span><br><span class=\"line\">        <span class=\"literal\">null</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>经过一番各种折腾，将很多在工作上无法使用的能力（Koin、Flow、DataStore……）都体验使用了一下，在业余的时间完成了基于博客文章构建的 App 在三个平台上的开发，实际上最初我也想搭建 WebJs 的平台的，后面删除掉了，因为涉及到 web 平台开发的各种库相比客户端少很多，兼容起来也比较费劲。KMP&#x2F;CMP 这块技术确实是能很大地节省开发人力，多端使用同一份UI逻辑代码，部分逻辑也可以用 kotlin 统一进行封装，后续维护也会方便很多。但这里有个缺点就是涉及到的库所需要的 kotlin&#x2F;Java 版本要求比较高，除非开发一些独立的 App，否则公司里的项目想基于这些技术去实现不太大可能。以及如果所需要的能力比较依赖与原生，比如音视频领域就有一定的局限性，总体来讲更适合偏交互业务的开发。</p>\n<p><strong>项目源码</strong>: <a href=\"https://github.com/VomPom/blog_kmp\">https://github.com/VomPom/blog_kmp</a>  </p>\n","raw":"\ntitle: '[Compose Multiplatform]跨平台博客应用实践'\nauthor: 落叶挽歌\ntags:\n  - KMP\ncategories:\n  - 思考总结\ndate: 2025-07-28 20:28:00\n---\n\n\n## 用 CMP 构建跨平台博客应用：一次 Kotlin 的全栈实践\n\n在追求高效开发的时代，跨平台技术已成为移动应用开发的主流选择，此前基于鸿蒙的开发平台开发 [blog_harmony](https://julis.wang/2025/05/16/%E9%B8%BF%E8%92%99-%E5%86%99%E4%BA%86%E4%B8%AA%E5%9F%BA%E4%BA%8EHexo%E5%8D%9A%E5%AE%A2%E7%9A%84%E9%B8%BF%E8%92%99App/)，将自己博客文章进行展示。本文将介绍基于 **CMP(Compose Multiplatform)** 构建的开源博客应用 [blog_kmp](https://github.com/VomPom/blog_kmp)，展示如何用 Kotlin 实现跨平台的应用开发。\n\n### Compose Multiplatform \nCompose Multiplatform 是 JetBrains 推出的声明式 UI 框架，基于 Jetpack Compose 扩展而来：\n- **核心优势**：用同一套 Kotlin 代码构建 Android、iOS、Desktop 和 Web 应用\n- **开发效率**：实时预览、热重载加速开发迭代\n- **原生性能**：通过 Skia 渲染引擎实现接近原生体验\n- **共享逻辑**：业务逻辑、网络请求、状态管理可 100% 复用\n\n### 项目架构与技术栈\nblog_kmp 采用分层架构设计，核心模块包括：\n\n```kotlin\nshared/\n├── src/commonMain/kotlin/  # 共享业务逻辑\n│   ├── data/               # 数据层\n│   ├── domain/             # 领域模型\n│   └── presentation/       # UI状态管理\n├── src/androidMain/        # Android 平台代码\n└── src/iosMain/            # iOS 平台适配\n├── composeApp\n│   ├── build.gradle.kts\n│   └── src\n│       ├── androidMain     # Android 平台代码\n│       ├── commonMain      # 共享业务逻辑\n│            ├── App.kt     # 界面展示入口\n│            ├── data       # 数据层\n│            │   ├── api        # 网络请求\n│            │   ├── di         # koin 依赖注入\n│            │   ├── model      # model 数据\n│            │   └── repository # 数据缓存管理\n│            │\n│            ├── navigation  # 页面间导航管理\n│            ├── platform    # 通过对各个平台抽象的接口 \n│            └── ui          # 通用 UI 逻辑\n│\n│       ├── desktopMain     # Desktop 平台适配\n│       └── iosMain         # iOS 平台适配\n```\n\n## 功能预览\n\n### Android\n![](https://cdn.julis.wang/github/blog_cmp/android.png)\n\n#### 深色模式\n![](https://cdn.julis.wang/github/blog_cmp/dark.png)\n\n### iOS\n\n![](https://cdn.julis.wang/github/blog_cmp/ios.png)\n### Desktop\n\n![](https://cdn.julis.wang/github/blog_cmp/desktop.png)\n\n#### 主要技术栈\n1. **Ktor 客户端** - 网络请求\n```kotlin\nval httpClient = HttpClient {\n    install(ContentNegotiation) {\n        json(Json { ignoreUnknownKeys = true })\n    }\n}\nsuspend fun loadPosts(): List<Post> = \n    httpClient.get(\"https://cdn.julis/api/posts\").body()\n```\n\n2. **DataStore** - 跨平台数据库\n```kotlin\nval dataKey = stringPreferencesKey(key)\nval result = dataStore.data\n    .catch { exception ->\n        // dataStore.data throws an IOException when an error is encountered when reading data\n        if (exception is IOException) {\n            emit(emptyPreferences())\n        } else {\n            throw exception\n        }\n    }\n    .map { preferences ->\n        val data: String? = preferences[dataKey]\n        if (data == null) {\n            null\n        } else {\n            if (isJson) Json.decodeFromString<T>(data) else (data as T)\n        }\n    }\n```\n\n3. **Koin** - 依赖注入\n```kotlin\nval sharedModule = module {\n    single<PostRepository> { PostRepositoryImpl(get()) }\n    viewModel { PostViewModel(get()) }\n}\n```\n\n4. **Kotlinx.Serialization** - JSON 解析\n```kotlin\n@Serializable\ndata class Post(\n    val id: String,\n    val title: String,\n    val content: String\n)\n```\n\n5. **compose-webview-multiplatform** - WebView 浏览器\n使用的第三方开发[compose-webview-multiplatform](https://github.com/KevinnZou/compose-webview-multiplatform)基于 [java-cef](https://github.com/chromiumembedded/java-cef)开发，不过这个library 在 desktop 平台表现不是太好，待完善。\n```kotlin\nval state = rememberWebViewState(postUrl)\n WebView(state = state,modifier = Modifier.fillMaxSize())            \n```\n\n\n### 平台特定实现\nUI 层面三端能够使用同一份代码，但为了体验，可能需要针对不同的设计，在桌面端可以设计更好地体验UI。这里避免不了 if-else 的UI逻辑，以及一些依赖各种系统的 api 需要单独实现，比如：深色模式监听、资源存储路径、系统信息、状态栏颜色等。\n\n**Android 端**  \nAndroid 特定的功能结合使用起来非常的简单，毕竟都是有血缘关系的。可以使用 AndroidView 直接渲染原生的 UI 页面。\n\n```kotlin\n  AndroidView(\n        modifier = Modifier.fillMaxSize(),\n        factory = { context ->\n            MyView(context) }\n        },\n        update = { view ->}\n    )\n```\n\n**iOS 端**  \niOS端主要需要 XCode 进行配合，还需要关注开发者账号相关的信息等，其他与 Android 端实现没有太大的差异。\n\n\n**桌面端**  \n利用 Compose Desktop 的窗口管理，可以实现窗口多开。\n```kotlin\nfun main() = application {\n    Window(onCloseRequest = ::exitApplication) {\n        DesktopAppTheme { AppContent() }\n    }\n}\n```\n\n\n### 🚀 性能优化实践\n1. **分页加载**：实现懒加载防止长列表卡顿\n```kotlin\nLazyColumn {\n    itemsIndexed(posts) { _, post ->\n        PostItem(post)\n    }\n    item { if (loading) LoadingIndicator() }\n}\n```\n\n2. **本地缓存**：DataStore 离线存储 + Ktor 缓存策略\n```kotlin\nHttpClient {\n    install(HttpCache) // 启用 HTTP 缓存\n}\n```\n\n3. **图像处理**：搭配 Coil 实现高效图片加载\n```kotlin\nAsyncImage(\n    modifier = Modifier.size(80.dp)\n        .shadow(\n            elevation = 5.dp,\n            shape = CircleShape,\n            spotColor = Color.Black\n        )\n        .clip(CircleShape)\n        .clickable { },\n    model = AppConfig.AVATAR,\n    contentDescription = AppConfig.AVATAR,\n)\n```\n### 开发经验总结\n1. **UI界面**\n  使用 [Compose](https://developer.android.com/compose) 进行界面布局开发，声明性编程范式相比于传统的 xml 布局开发，高效很多，使用也很方便。使用了这种方式，传统的 UI 开发方式再也回不去了。\n\n2. **状态管理**\n使用 `mutableStateOf` 实现响应式更新，或者使用 `derivedStateOf` 实现派生状态的处理。\n```kotlin\nvar pagIndex by remember { mutableStateOf(0) }\nvar errorState by remember { mutableStateOf<String?>(null) }   \nval themeState by mineViewModel.appTheme.collectAsState()\nval uiChecked by remember(themeState) { derivedStateOf { themeState == ThemeConstants.DARK } }\n```\n\n\n3. **导航**\n\n实现 `Compose Navigator` 统一路由管理\n```kotlin\n  val gotoDebug: () -> Unit = {\n      navController.navigate(Routes.Debug())\n  }\n\n  val goToPostDetail: (Post) -> Unit = { it ->\n      navController.navigate(Routes.PostDetail(title = it.title, it.url))\n  }\n\n```\n\n4. **Kotlin Flow**\n简化异步编程，让网络请求的代码看起来更直观\n```kotlin\nfun loadAllPost(): Flow<List<PostV2>> = load(\"allPosts\") {\n    postApi.getAllPost()?.data ?: emptyList()\n}\nsuspend fun getAllPost(): SearchResponse? = request<SearchResponse>(getUrl(\"api/search.json\"))\n\nprivate suspend inline fun <reified T> request(url: String): T? {\n    return try {\n        client.get(url).body()\n    } catch (e: Exception) {\n        if (e is CancellationException) throw e\n        e.printStackTrace()\n        null\n    }\n}\n```\n\n### 总结\n经过一番各种折腾，将很多在工作上无法使用的能力（Koin、Flow、DataStore……）都体验使用了一下，在业余的时间完成了基于博客文章构建的 App 在三个平台上的开发，实际上最初我也想搭建 WebJs 的平台的，后面删除掉了，因为涉及到 web 平台开发的各种库相比客户端少很多，兼容起来也比较费劲。KMP/CMP 这块技术确实是能很大地节省开发人力，多端使用同一份UI逻辑代码，部分逻辑也可以用 kotlin 统一进行封装，后续维护也会方便很多。但这里有个缺点就是涉及到的库所需要的 kotlin/Java 版本要求比较高，除非开发一些独立的 App，否则公司里的项目想基于这些技术去实现不太大可能。以及如果所需要的能力比较依赖与原生，比如音视频领域就有一定的局限性，总体来讲更适合偏交互业务的开发。\n\n\n**项目源码**: https://github.com/VomPom/blog_kmp  ","categories":[{"name":"思考总结","api":"api/categories/thinking.json"}],"tags":[{"name":"KMP","api":"api/tags/KMP.json"}]},"api":"api/posts/2025/07/28/Compose-Multiplatform-跨平台博客应用实践.json"}