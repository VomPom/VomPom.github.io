{"data":{"title":"手写一个精简版Koin：深入理解依赖注入核心原理","slug":"Koin-源码理解相关","description":"","date":"2025-08-25T13:08:00.000Z","updated":"2025-08-25T13:44:34.603Z","language":"zh-CN","comments":true,"url":"2025/08/25/Koin-源码理解相关/","cover":null,"images":[],"content":"<p>在现代 Android 应用开发中，依赖注入（Dependency Injection, DI）已成为构建松耦合、可测试代码的重要技术。Koin 作为一个轻量级的Kotlin依赖注入框架，因其简洁的DSL和易用性深受开发者喜爱。最近对其源码进行学习了解，通过手写一个极度精简的 Koin 核心代码，来透彻理解Koin的注册、解析和参数传递机制。</p>\n<blockquote>\n<p><strong>本文代码基于 Koin 源码思想实现，仅用于学习核心原理，并非 Koin官 方代码。</strong></p>\n</blockquote>\n<h2 id=\"核心概念与项目结构\"><a href=\"#核心概念与项目结构\" class=\"headerlink\" title=\"核心概念与项目结构\"></a>核心概念与项目结构</h2><p>下图是基于 koin 4.1 解析的 主要类UML图，可以比较清晰地看看各个类之间的关系</p>\n<img src=\"https://cdn.julis.wang/blog/img/koin_uml.png\"> \n<p>power by <a href=\"https://www.mermaidchart.com/\">mermaidchart</a></p>\n<p>主要类：</p>\n<ul>\n<li><strong><code>KoinApplication</code></strong>: Koin启动的入口，负责初始化容器和加载模块。</li>\n<li><strong><code>Koin</code></strong>: 核心容器，持有实例注册表 InstanceRegistry 和作用域注册表 ScopeRegistry。</li>\n<li><strong><code>Module</code></strong>: 定义依赖的地方，存放了所有的 bean 定义 BeanDefinition 与 InstanceFactory。</li>\n<li><strong><code>BeanDefinition</code></strong>: 对一个依赖项的定义，包括其类型、限定符、所属作用域以及创建它的 lambda 表达式。</li>\n<li><strong><code>InstanceFactory</code></strong>: 负责根据 <code>BeanDefinition</code> 创建实例的核心工厂，分为 <code>SingleFactory</code> (单例)、<code>FactoryFactory</code> (工厂模式) 和 <code>ScopeFactory</code> (作用域内单例)。</li>\n<li><strong><code>Scope</code></strong>: 作用域，用于管理特定生命周期内的实例。</li>\n<li><strong><code>ParametersHolder</code></strong>: 参数容器，用于在获取实例时动态传递参数。</li>\n</ul>\n<h2 id=\"手写-koin-代码介绍\"><a href=\"#手写-koin-代码介绍\" class=\"headerlink\" title=\"手写 koin 代码介绍\"></a>手写 koin 代码介绍</h2><p>基于对源码的理解和参考，实现了 koin 的基本功能，整体分成三部分：简单 single 数据存取、包含 scope 能力、动态参数能力，分成三个文件夹，顺序123是基于前面带代码累加的。</p>\n<p><strong>简单 single 数据存取</strong><br>代码实现在：<a href=\"https://github.com/VomPom/JProject/blob/master/app/src/main/java/wang/julis/jproject/example/source/koin/noScope1/KoinWithoutScope.kt\">KoinWithoutScope.kt</a></p>\n<p>这是一份最简单的代码，大概200行不到，基本上包含了 koin 的核心思想：启动时注册组件定义。解析时，先查作用域缓存，命中则直接返回。未命中则递归解析其依赖项，调用工厂函数创建实例，最后返回实例。</p>\n<p>从这也能看出来 koin 的缺点：Koin 启动时 (startKoin) 需要将所有模块的定义 (BeanDefinition) 注册到容器中。实例数量过多会显著增加启动注册过程的耗时，影响应用启动速度。由于每个实例都会对应一个 BeanDefinition 以及 Factory ，内存占用会相应地上升。</p>\n<p>整个流程简单来讲就是生成一个 map，通过 key 获取对于的数据。</p>\n<p><strong>Scope 能力</strong><br>代码实现在：<a href=\"https://github.com/VomPom/JProject/blob/master/app/src/main/java/wang/julis/jproject/example/source/koin/scope2/KoinWithScope.kt\">KoinWithScope.kt</a></p>\n<p>这一份是在之前的能力上进行添加，此前将所有的数据都注册到 “root” 这个容器内，全局通用，但为了将不同作用域分开，需要引入 scope 的概念。</p>\n<p>简单理解就是在通过 key 获取的 map 里面的数据的时候，这个 key 是有一定的规则的，核心逻辑在这里：<br> <figure class=\"highlight kotlin\"><table><tr><td class=\"code\"><pre><span class=\"line\"> <span class=\"keyword\">inline</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">indexKey</span><span class=\"params\">(clazz: <span class=\"type\">KClass</span>&lt;*&gt;, typeQualifier: <span class=\"type\">String</span>?, scopeQualifier: <span class=\"type\">String</span>)</span></span>: String &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> buildString &#123;</span><br><span class=\"line\">        append(clazz.java.name)</span><br><span class=\"line\">        append(<span class=\"string\">&#x27;:&#x27;</span>)</span><br><span class=\"line\">        append(typeQualifier ?: <span class=\"string\">&quot;&quot;</span>)</span><br><span class=\"line\">        append(<span class=\"string\">&#x27;:&#x27;</span>)</span><br><span class=\"line\">        append(scopeQualifier)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br> 不同的 scope 实际上也就是获取的 key 值的不同。</p>\n<p><strong>动态参数能力</strong><br>代码实现在：<a href=\"https://github.com/VomPom/JProject/blob/master/app/src/main/java/wang/julis/jproject/example/source/koin/parameter3/KoinWithParameter.kt\">KoinWithParameter.kt</a></p>\n<p>最后在 scope 的基础上实现了一个比较重要的能力-动态参数能力，通过这个能力可以让有实例能够在运行的时候根据参数动态创建。这个能力也是像在安卓 Activity&#x2F;Fragment 里面 viewmodel() 实现依赖注入的必要实现。 </p>\n<p>简单理解就是在 get() 的时候将参数传入到获取实例的调用链中，在运行时执行注册的 Lambda 函数invoke时候将作为参数传递到构造方法中去。这里单独拎出来实现是因为这个参数传递影响到整个流程的逻辑，为了上上面的两个能力逻辑更简单清晰，单独在这一部分实现。</p>\n<h2 id=\"Koin-的注册流程（Declaration）\"><a href=\"#Koin-的注册流程（Declaration）\" class=\"headerlink\" title=\"Koin 的注册流程（Declaration）\"></a>Koin 的注册流程（Declaration）</h2><p>注册是DI容器工作的第一步。通过 <code>startKoin</code> 和 <code>module</code> DSL来声明依赖。</p>\n<h3 id=\"启动-Koin-与模块加载\"><a href=\"#启动-Koin-与模块加载\" class=\"headerlink\" title=\"启动 Koin 与模块加载\"></a>启动 Koin 与模块加载</h3><p>整个启动加载流程将 kotlin 的语法糖用到了极致，也就使得整个代码看起来是如此的简洁。</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> myApp = startKoin &#123;</span><br><span class=\"line\">    modules(appModule)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 定义一个模块</span></span><br><span class=\"line\"><span class=\"keyword\">val</span> appModule = module &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 注册一个单例，其构造需要一個 Int 参数</span></span><br><span class=\"line\">    single &#123; (<span class=\"keyword\">data</span>: <span class=\"built_in\">Int</span>) -&gt; ComponentInt(<span class=\"keyword\">data</span>) &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 注册一个工厂（每次获取都是新实例），其构造需要 Int 和 Float 参数</span></span><br><span class=\"line\">    factory &#123; (data1: <span class=\"built_in\">Int</span>, data2: <span class=\"built_in\">Float</span>) -&gt; ComponentIntFloat(data1, data2) &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>流程剖析：</strong></p>\n<p><strong><code>startKoin</code></strong><br>这是一个顶级函数，它调用 <code>GlobalContext.startKoin</code>，创建并初始化一个 <code>KoinApplication</code> 对象。</p>\n<p><strong><code>modules(...)</code></strong><br><code>KoinApplication</code> 的方法，它将传入的 <code>Module</code> 列表交给 <code>Koin</code> 实例的 <code>loadModels</code> 方法处理。</p>\n<p><strong><code>module &#123; ... &#125;</code></strong><br>DSL函数，它创建一个 <code>Module</code> 对象，并执行其中的配置lambda。</p>\n<p><strong><code>single/factory/scope</code></strong><br><code>Module</code> 的扩展函数。它们的作用是：</p>\n<ul>\n<li>使用 <code>_createDefinition</code> 将 lambda 表达式包装成一个 <code>BeanDefinition</code>对象。</li>\n<li>使用 <code>_InstanceFactory</code> 将 <code>BeanDefinition</code> 包装成对应的 <code>InstanceFactory</code>。</li>\n<li>调用 <code>indexPrimaryType</code>，生成一个<strong>唯一的Key</strong>（格式：<code>类名:限定符:作用域</code>），并将 <code>Factory</code> 存入 <code>Module.mappings</code> 这个 <code>HashMap</code> 中。</li>\n</ul>\n<p><strong>最终存储</strong><br><code>Koin</code> 的 <code>InstanceRegistry</code> 会遍历所有 <code>Module</code>，将它们 <code>mappings</code> 中的全部 <code>Factory</code> 都合并到自己的 <code>_instances</code>（一个 <code>ConcurrentHashMap</code>）中。</p>\n<p>至此，所有依赖的定义都已注册到容器中，静待获取。</p>\n<h2 id=\"Koin的实例获取流程（Retrieval）\"><a href=\"#Koin的实例获取流程（Retrieval）\" class=\"headerlink\" title=\"Koin的实例获取流程（Retrieval）\"></a>Koin的实例获取流程（Retrieval）</h2><figure class=\"highlight kotlin\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 获取无参依赖（普通方式）</span></span><br><span class=\"line\"><span class=\"keyword\">val</span> component = <span class=\"keyword\">get</span>&lt;Component&gt;()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 通过 scope 作用域限定进行获取</span></span><br><span class=\"line\"><span class=\"keyword\">val</span> scope = koin.createScope(<span class=\"string\">&quot;scope&quot;</span>, scopeQualifier)</span><br><span class=\"line\"><span class=\"keyword\">val</span> component = scope.<span class=\"keyword\">get</span>&lt;Component&gt;()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 通过需要动态参数的获取</span></span><br><span class=\"line\"><span class=\"keyword\">val</span> componentWithArgs = <span class=\"keyword\">get</span>&lt;ComponentInt&gt; &#123; parametersOf(<span class=\"number\">42</span>) &#125;</span><br><span class=\"line\"><span class=\"keyword\">val</span> componentWithMultiArgs = <span class=\"keyword\">get</span>&lt;ComponentIntFloat&gt; &#123; parametersOf(<span class=\"number\">101</span>, <span class=\"number\">3.14f</span>) &#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"流程剖析\"><a href=\"#流程剖析\" class=\"headerlink\" title=\"流程剖析\"></a>流程剖析</h3><p><strong><code>Scope.get&lt;T&gt;</code></strong></p>\n<p>这是 <code>Scope</code> 的一个扩展函数。它首先创建一个 <code>ResolutionContext</code>，封装了当前作用域、要解析的类型、限定符以及最重要的——<strong>参数持有器 <code>ParametersHolder</code></strong>（由 <code>parametersOf</code> 函数创建）。</p>\n<p> <strong>解析上下文（ResolutionContext）</strong></p>\n<p> 这个上下文对象包含了解析一个实例所需的所有信息。</p>\n<p><strong>核心解析器（CoreResolver）</strong><br><code>get</code> 操作会委托给 <code>Koin</code> 的 <code>CoreResolver</code>进行处理。源码里面对于查找顺序有非常清晰的层次体现：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"type\">&lt;T&gt;</span> <span class=\"title\">resolveFromContext</span><span class=\"params\">(scope : <span class=\"type\">Scope</span>, instanceContext: <span class=\"type\">ResolutionContext</span>)</span></span>: T &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> resolveFromContextOrNull(scope,instanceContext) ?: throwNoDefinitionFound(instanceContext)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"type\">&lt;T&gt;</span> <span class=\"title\">resolveFromContextOrNull</span><span class=\"params\">(scope : <span class=\"type\">Scope</span>, instanceContext: <span class=\"type\">ResolutionContext</span>, lookupParent : <span class=\"type\">Boolean</span> = <span class=\"literal\">true</span>)</span></span>: T? &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> resolveFromInjectedParameters(instanceContext)</span><br><span class=\"line\">          ?: resolveFromRegistry(scope,instanceContext)</span><br><span class=\"line\">          ?: resolveFromStackedParameters(scope,instanceContext)</span><br><span class=\"line\">          ?: resolveFromScopeSource(scope,instanceContext)</span><br><span class=\"line\">          ?: resolveFromScopeArchetype(scope,instanceContext)</span><br><span class=\"line\">          ?: <span class=\"keyword\">if</span> (lookupParent) resolveFromParentScopes(scope,instanceContext) <span class=\"keyword\">else</span> <span class=\"literal\">null</span></span><br><span class=\"line\">          ?: resolveInExtensions(scope,instanceContext)</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n\n<p> <strong>查找工厂</strong></p>\n<ul>\n<li><code>Resolver</code> 会调用 <code>InstanceRegistry.resolveDefinition</code>。</li>\n<li>该方法使用和注册时<strong>相同的算法</strong>生成Key（类名:限定符:作用域），然后从 <code>_instances</code> 中查找对应的 <code>InstanceFactory</code>。</li>\n</ul>\n<p> <strong>创建实例</strong></p>\n<ul>\n<li><p>找到 <code>Factory</code> 后，调用其 <code>get(context: ResolutionContext)</code> 方法。</p>\n</li>\n<li><p><code>Factory</code> 会调用自己的 <code>create</code> 方法。<strong>关键一步来了</strong>：在 <code>create</code> 方法中，会执行 <code>BeanDefinition.definition.invoke(context.scope, parameters)</code>。这其实就是执行了之前注册的 lambda：<code>&#123; (data: Int) -&gt; ComponentInt(data) &#125;</code>。</p>\n</li>\n<li><p><strong>参数传递</strong>：这里的 <code>parameters</code> 就是在 <code>get</code> 时传入的 <code>ParametersHolder</code>。Lambda 的参数 <code>(data: Int)</code> 会从 <code>ParametersHolder</code> 中按顺序（或使用解构）取出值</p>\n</li>\n</ul>\n<p><strong>返回实例</strong></p>\n<p>工厂将创建好的实例返回给调用者。</p>\n<p>对于 <code>SingleFactory</code>，它会将第一次创建出来的实例缓存起来，后续调用直接返回缓存实例。<code>FactoryFactory</code> 则每次都会执行 <code>create</code> 方法。</p>\n<h2 id=\"其他技术\"><a href=\"#其他技术\" class=\"headerlink\" title=\"其他技术\"></a>其他技术</h2><h3 id=\"DslMarker-的作用\"><a href=\"#DslMarker-的作用\" class=\"headerlink\" title=\"@DslMarker 的作用\"></a>@DslMarker 的作用</h3><p>在实现的过程中发现如下图所示：koin 的代码有颜色分层，能比较清晰地看到各个 block 之间的差异，自己写的代码全部是白色。</p>\n<img src=\"https://cdn.julis.wang/blog/img/koin_color_contrast.png\"> \n\n\n<p>代码开头定义了三个注解：<code>@KoinApplicationDslMarker</code>, <code>@KoinDslMarker</code>, <code>@OptionDslMarker</code>。这是Kotlin DSL的<strong>安全卫士</strong>。</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@DslMarker</span></span><br><span class=\"line\"><span class=\"keyword\">annotation</span> <span class=\"keyword\">class</span> <span class=\"title class_\">KoinDslMarker</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@KoinDslMarker</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Module</span> &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">single</span><span class=\"params\">(...)</span></span> &#123; ... &#125; <span class=\"comment\">// 这个single在DSL里</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@KoinDslMarker</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">KoinApplication</span> &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">modules</span><span class=\"params\">(...)</span></span> &#123; ... &#125; <span class=\"comment\">// 这个modules在DSL里</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">test</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    startKoin &#123;</span><br><span class=\"line\">        modules(...) <span class=\"comment\">// 正确：在 KoinApplication 的 lambda 里</span></span><br><span class=\"line\">        single &#123; ... &#125; <span class=\"comment\">// 编译错误！@DslMarker 阻止了隐式地使用外部 Receiver (Module)</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>@DslMarker</code> 实际的作用是防止在嵌套的DSL Lambda中，意外地调用到外层 Receiver 的方法，从而让DSL书写更加清晰和安全。代码颜色是由 IDE 提供的效果。在代码中加上几个注解之后，效果如图所示：</p>\n<img src=\"https://cdn.julis.wang/blog/img/koin_color_annotation.png\"> \n<p>跟 koin 的颜色不太一致，不过能明显看到代码有分层，应该是由于 koin 对 annotation 也有处理，这里没有再深入研究。</p>\n<h3 id=\"2-优雅的参数传递与解构\"><a href=\"#2-优雅的参数传递与解构\" class=\"headerlink\" title=\"2. 优雅的参数传递与解构\"></a>2. 优雅的参数传递与解构</h3><p>这个逻辑复刻了Koin的动态参数特性。</p>\n<ul>\n<li><strong><code>ParametersHolder</code></strong>：一个轻量的参数容器，内部用一个 <code>List&lt;Any?&gt;</code> 存储参数。</li>\n<li><strong><code>parametersOf</code></strong>：辅助函数，优雅地创建 <code>ParametersHolder</code>。</li>\n<li><strong>解构声明（Destructuring Declaration）</strong>：<code>ParametersHolder</code> 重写了 <code>component1()</code> 到 <code>component5()</code> 操作符。这使得在定义lambda时，可以直接用 <code>(a: A, b: B)</code> 的形式来接收参数，而不是手动调用 <code>parameters.get&lt;X&gt;(0)</code>。</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 注册端：看起来就像普通函数</span></span><br><span class=\"line\">single &#123; (id: <span class=\"built_in\">Int</span>, name: String) -&gt; User(id, name) &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 获取端：传递参数非常直观</span></span><br><span class=\"line\"><span class=\"keyword\">val</span> user = <span class=\"keyword\">get</span>&lt;User&gt; &#123; parametersOf(<span class=\"number\">123</span>, <span class=\"string\">&quot;Julius&quot;</span>) &#125;</span><br></pre></td></tr></table></figure>\n<p>这种设计极大地提升了API的简洁性和可读性。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>通过这个手写的迷你Koin，可以深刻地理解到，一个现代DI容器的核心无非是解决两个问题：</p>\n<ol>\n<li><strong>如何注册（Declaration）</strong>：通过DSL将依赖的创建方式（Lambda）以键值对的形式保存到一个全局的注册表中。</li>\n<li><strong>如何获取（Retrieval）</strong>：根据请求的类型、限定符和作用域生成Key，从注册表中找到对应的创建工厂，并调用它来生成实例。支持通过参数容器实现动态传参。</li>\n</ol>\n<p>除此之外，诸如 <code>@DslMarker</code> 保证DSL安全、<strong>解构</strong>实现参数优雅传递，都是构建一个健壮、易用框架的关键技术。</p>\n<p>虽然这个实现省略了Koin的许多高级功能（如完整的Scope生命周期管理、属性注入、Android特定支持等），但它已经囊括了最核心、最精妙的设计思想，再理解其他的模块也会简单很多。</p>\n<p>实现的所有源码位于：<a href=\"https://github.com/VomPom/JProject/tree/master/app/src/main/java/wang/julis/jproject/example/source/koin\">JProject&#x2F;source&#x2F;koin</a></p>\n","raw":"title: 手写一个精简版Koin：深入理解依赖注入核心原理\nauthor: 落叶挽歌\ntags:\n  - koin\ncategories:\n  - 技术文章\ndate: 2025-08-25 21:08:00\n---\n\n在现代 Android 应用开发中，依赖注入（Dependency Injection, DI）已成为构建松耦合、可测试代码的重要技术。Koin 作为一个轻量级的Kotlin依赖注入框架，因其简洁的DSL和易用性深受开发者喜爱。最近对其源码进行学习了解，通过手写一个极度精简的 Koin 核心代码，来透彻理解Koin的注册、解析和参数传递机制。\n\n> **本文代码基于 Koin 源码思想实现，仅用于学习核心原理，并非 Koin官 方代码。**\n\n## 核心概念与项目结构\n下图是基于 koin 4.1 解析的 主要类UML图，可以比较清晰地看看各个类之间的关系\n{% qnimg koin_uml.png %} \npower by [mermaidchart](https://www.mermaidchart.com/)\n\n主要类：\n\n- **`KoinApplication`**: Koin启动的入口，负责初始化容器和加载模块。\n- **`Koin`**: 核心容器，持有实例注册表 InstanceRegistry 和作用域注册表 ScopeRegistry。\n- **`Module`**: 定义依赖的地方，存放了所有的 bean 定义 BeanDefinition 与 InstanceFactory。\n- **`BeanDefinition`**: 对一个依赖项的定义，包括其类型、限定符、所属作用域以及创建它的 lambda 表达式。\n- **`InstanceFactory`**: 负责根据 `BeanDefinition` 创建实例的核心工厂，分为 `SingleFactory` (单例)、`FactoryFactory` (工厂模式) 和 `ScopeFactory` (作用域内单例)。\n- **`Scope`**: 作用域，用于管理特定生命周期内的实例。\n- **`ParametersHolder`**: 参数容器，用于在获取实例时动态传递参数。\n\n\n## 手写 koin 代码介绍\n基于对源码的理解和参考，实现了 koin 的基本功能，整体分成三部分：简单 single 数据存取、包含 scope 能力、动态参数能力，分成三个文件夹，顺序123是基于前面带代码累加的。\n\n**简单 single 数据存取**\n代码实现在：[KoinWithoutScope.kt](https://github.com/VomPom/JProject/blob/master/app/src/main/java/wang/julis/jproject/example/source/koin/noScope1/KoinWithoutScope.kt)\n\n这是一份最简单的代码，大概200行不到，基本上包含了 koin 的核心思想：启动时注册组件定义。解析时，先查作用域缓存，命中则直接返回。未命中则递归解析其依赖项，调用工厂函数创建实例，最后返回实例。\n\n从这也能看出来 koin 的缺点：Koin 启动时 (startKoin) 需要将所有模块的定义 (BeanDefinition) 注册到容器中。实例数量过多会显著增加启动注册过程的耗时，影响应用启动速度。由于每个实例都会对应一个 BeanDefinition 以及 Factory ，内存占用会相应地上升。\n\n整个流程简单来讲就是生成一个 map，通过 key 获取对于的数据。\n\n**Scope 能力**\n代码实现在：[KoinWithScope.kt](https://github.com/VomPom/JProject/blob/master/app/src/main/java/wang/julis/jproject/example/source/koin/scope2/KoinWithScope.kt)\n\n这一份是在之前的能力上进行添加，此前将所有的数据都注册到 “root” 这个容器内，全局通用，但为了将不同作用域分开，需要引入 scope 的概念。\n\n简单理解就是在通过 key 获取的 map 里面的数据的时候，这个 key 是有一定的规则的，核心逻辑在这里：\n ```kotlin\n inline fun indexKey(clazz: KClass<*>, typeQualifier: String?, scopeQualifier: String): String {\n    return buildString {\n        append(clazz.java.name)\n        append(':')\n        append(typeQualifier ?: \"\")\n        append(':')\n        append(scopeQualifier)\n    }\n}\n ```\n 不同的 scope 实际上也就是获取的 key 值的不同。\n\n**动态参数能力**\n代码实现在：[KoinWithParameter.kt](https://github.com/VomPom/JProject/blob/master/app/src/main/java/wang/julis/jproject/example/source/koin/parameter3/KoinWithParameter.kt)\n\n最后在 scope 的基础上实现了一个比较重要的能力-动态参数能力，通过这个能力可以让有实例能够在运行的时候根据参数动态创建。这个能力也是像在安卓 Activity/Fragment 里面 viewmodel() 实现依赖注入的必要实现。 \n\n简单理解就是在 get() 的时候将参数传入到获取实例的调用链中，在运行时执行注册的 Lambda 函数invoke时候将作为参数传递到构造方法中去。这里单独拎出来实现是因为这个参数传递影响到整个流程的逻辑，为了上上面的两个能力逻辑更简单清晰，单独在这一部分实现。\n\n\n## Koin 的注册流程（Declaration）\n\n注册是DI容器工作的第一步。通过 `startKoin` 和 `module` DSL来声明依赖。\n\n### 启动 Koin 与模块加载\n整个启动加载流程将 kotlin 的语法糖用到了极致，也就使得整个代码看起来是如此的简洁。\n\n```kotlin\nval myApp = startKoin {\n    modules(appModule)\n}\n\n// 定义一个模块\nval appModule = module {\n    // 注册一个单例，其构造需要一個 Int 参数\n    single { (data: Int) -> ComponentInt(data) }\n    // 注册一个工厂（每次获取都是新实例），其构造需要 Int 和 Float 参数\n    factory { (data1: Int, data2: Float) -> ComponentIntFloat(data1, data2) }\n}\n```\n\n**流程剖析：**\n\n**`startKoin`**\n这是一个顶级函数，它调用 `GlobalContext.startKoin`，创建并初始化一个 `KoinApplication` 对象。\n\n**`modules(...)`**\n`KoinApplication` 的方法，它将传入的 `Module` 列表交给 `Koin` 实例的 `loadModels` 方法处理。\n\n**`module { ... }`**\nDSL函数，它创建一个 `Module` 对象，并执行其中的配置lambda。\n\n**`single/factory/scope`**\n`Module` 的扩展函数。它们的作用是：\n- 使用 `_createDefinition` 将 lambda 表达式包装成一个 `BeanDefinition`对象。\n- 使用 `_InstanceFactory` 将 `BeanDefinition` 包装成对应的 `InstanceFactory`。\n- 调用 `indexPrimaryType`，生成一个**唯一的Key**（格式：`类名:限定符:作用域`），并将 `Factory` 存入 `Module.mappings` 这个 `HashMap` 中。\n\n**最终存储**\n`Koin` 的 `InstanceRegistry` 会遍历所有 `Module`，将它们 `mappings` 中的全部 `Factory` 都合并到自己的 `_instances`（一个 `ConcurrentHashMap`）中。\n\n至此，所有依赖的定义都已注册到容器中，静待获取。\n\n## Koin的实例获取流程（Retrieval）\n\n```kotlin\n// 获取无参依赖（普通方式）\nval component = get<Component>()\n\n// 通过 scope 作用域限定进行获取\nval scope = koin.createScope(\"scope\", scopeQualifier)\nval component = scope.get<Component>()\n\n// 通过需要动态参数的获取\nval componentWithArgs = get<ComponentInt> { parametersOf(42) }\nval componentWithMultiArgs = get<ComponentIntFloat> { parametersOf(101, 3.14f) }\n```\n\n###  流程剖析\n\n**`Scope.get<T>`**\n\n这是 `Scope` 的一个扩展函数。它首先创建一个 `ResolutionContext`，封装了当前作用域、要解析的类型、限定符以及最重要的——**参数持有器 `ParametersHolder`**（由 `parametersOf` 函数创建）。\n\n **解析上下文（ResolutionContext）**\n \n 这个上下文对象包含了解析一个实例所需的所有信息。\n\n**核心解析器（CoreResolver）**\n`get` 操作会委托给 `Koin` 的 `CoreResolver`进行处理。源码里面对于查找顺序有非常清晰的层次体现：\n\n```kotlin\n  override fun <T> resolveFromContext(scope : Scope, instanceContext: ResolutionContext): T {\n        return resolveFromContextOrNull(scope,instanceContext) ?: throwNoDefinitionFound(instanceContext)\n    }\n\n    private fun <T> resolveFromContextOrNull(scope : Scope, instanceContext: ResolutionContext, lookupParent : Boolean = true): T? {\n        return resolveFromInjectedParameters(instanceContext)\n            ?: resolveFromRegistry(scope,instanceContext)\n            ?: resolveFromStackedParameters(scope,instanceContext)\n            ?: resolveFromScopeSource(scope,instanceContext)\n            ?: resolveFromScopeArchetype(scope,instanceContext)\n            ?: if (lookupParent) resolveFromParentScopes(scope,instanceContext) else null\n            ?: resolveInExtensions(scope,instanceContext)\n    }\n```\n\n **查找工厂**\n- `Resolver` 会调用 `InstanceRegistry.resolveDefinition`。\n- 该方法使用和注册时**相同的算法**生成Key（类名:限定符:作用域），然后从 `_instances` 中查找对应的 `InstanceFactory`。\n\n **创建实例**\n- 找到 `Factory` 后，调用其 `get(context: ResolutionContext)` 方法。\n- `Factory` 会调用自己的 `create` 方法。**关键一步来了**：在 `create` 方法中，会执行 `BeanDefinition.definition.invoke(context.scope, parameters)`。这其实就是执行了之前注册的 lambda：`{ (data: Int) -> ComponentInt(data) }`。\n\n- **参数传递**：这里的 `parameters` 就是在 `get` 时传入的 `ParametersHolder`。Lambda 的参数 `(data: Int)` 会从 `ParametersHolder` 中按顺序（或使用解构）取出值\n\n**返回实例**\n\n工厂将创建好的实例返回给调用者。\n\n对于 `SingleFactory`，它会将第一次创建出来的实例缓存起来，后续调用直接返回缓存实例。`FactoryFactory` 则每次都会执行 `create` 方法。\n\n## 其他技术\n\n###  @DslMarker 的作用\n在实现的过程中发现如下图所示：koin 的代码有颜色分层，能比较清晰地看到各个 block 之间的差异，自己写的代码全部是白色。\n{% qnimg koin_color_contrast.png %} \n\n\n代码开头定义了三个注解：`@KoinApplicationDslMarker`, `@KoinDslMarker`, `@OptionDslMarker`。这是Kotlin DSL的**安全卫士**。\n```kotlin\n@DslMarker\nannotation class KoinDslMarker\n\n@KoinDslMarker\nclass Module {\n    fun single(...) { ... } // 这个single在DSL里\n}\n\n@KoinDslMarker\nclass KoinApplication {\n    fun modules(...) { ... } // 这个modules在DSL里\n}\n\nfun test() {\n    startKoin {\n        modules(...) // 正确：在 KoinApplication 的 lambda 里\n        single { ... } // 编译错误！@DslMarker 阻止了隐式地使用外部 Receiver (Module)\n    }\n}\n```\n\n`@DslMarker` 实际的作用是防止在嵌套的DSL Lambda中，意外地调用到外层 Receiver 的方法，从而让DSL书写更加清晰和安全。代码颜色是由 IDE 提供的效果。在代码中加上几个注解之后，效果如图所示：\n\n{% qnimg koin_color_annotation.png %} \n跟 koin 的颜色不太一致，不过能明显看到代码有分层，应该是由于 koin 对 annotation 也有处理，这里没有再深入研究。\n\n### 2. 优雅的参数传递与解构\n这个逻辑复刻了Koin的动态参数特性。\n\n- **`ParametersHolder`**：一个轻量的参数容器，内部用一个 `List<Any?>` 存储参数。\n- **`parametersOf`**：辅助函数，优雅地创建 `ParametersHolder`。\n- **解构声明（Destructuring Declaration）**：`ParametersHolder` 重写了 `component1()` 到 `component5()` 操作符。这使得在定义lambda时，可以直接用 `(a: A, b: B)` 的形式来接收参数，而不是手动调用 `parameters.get<X>(0)`。\n\n```kotlin\n// 注册端：看起来就像普通函数\nsingle { (id: Int, name: String) -> User(id, name) }\n\n// 获取端：传递参数非常直观\nval user = get<User> { parametersOf(123, \"Julius\") }\n```\n这种设计极大地提升了API的简洁性和可读性。\n\n\n## 总结\n\n通过这个手写的迷你Koin，可以深刻地理解到，一个现代DI容器的核心无非是解决两个问题：\n\n1.  **如何注册（Declaration）**：通过DSL将依赖的创建方式（Lambda）以键值对的形式保存到一个全局的注册表中。\n2.  **如何获取（Retrieval）**：根据请求的类型、限定符和作用域生成Key，从注册表中找到对应的创建工厂，并调用它来生成实例。支持通过参数容器实现动态传参。\n\n除此之外，诸如 `@DslMarker` 保证DSL安全、**解构**实现参数优雅传递，都是构建一个健壮、易用框架的关键技术。\n\n虽然这个实现省略了Koin的许多高级功能（如完整的Scope生命周期管理、属性注入、Android特定支持等），但它已经囊括了最核心、最精妙的设计思想，再理解其他的模块也会简单很多。\n\n实现的所有源码位于：[JProject/source/koin](https://github.com/VomPom/JProject/tree/master/app/src/main/java/wang/julis/jproject/example/source/koin)","categories":[{"name":"技术文章","api":"api/categories/technology.json"}],"tags":[{"name":"koin","api":"api/tags/koin.json"}]},"api":"api/posts/2025/08/25/Koin-源码理解相关.json"}