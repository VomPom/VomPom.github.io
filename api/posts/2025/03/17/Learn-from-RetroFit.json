{"data":{"title":"RetroFit2 源码学习相关","slug":"Learn-from-RetroFit","description":"","date":"2025-03-17T12:28:00.000Z","updated":"2025-05-20T11:46:57.000Z","language":"zh-CN","comments":true,"url":"2025/03/17/Learn-from-RetroFit/","cover":null,"images":[],"content":"<p>研究 <a href=\"https://github.com/square/retrofit\">retrofit</a> 目标：理解动态代理、注解、反射、学习它所用到的设计模式，达到自己能手写它的核心实现。</p>\n<p>最近终于有点精力能够去研究研究源码了， 真的是写的一个非常好的的开源库，以前刚接触安卓的时候扒拉过相关的源码，但是随着工作了几年之后，经验的积累，让我对源码里面的东西能够体会更深刻，自己也尝试去手写里面的核心实现，看完源码对整体的架构理解了之后，以为自己能很顺利的写下来，实则不然。<br>知识还是需要知行合一，这篇文章主要记录 <a href=\"https://github.com/square/retrofit\">retrofit</a>  的一些知识点。</p>\n<h3 id=\"retrofit-的设计模式\"><a href=\"#retrofit-的设计模式\" class=\"headerlink\" title=\"retrofit 的设计模式\"></a>retrofit 的设计模式</h3><p>retrofit 里面中使用了多种设计模式，以实现其灵活、可扩展和高性能的特性：</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">设计模式</th>\n<th style=\"text-align:left\">应用场景</th>\n<th style=\"text-align:left\">作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\"><strong>建造者模式</strong></td>\n<td style=\"text-align:left\"><code>Retrofit.Builder</code></td>\n<td style=\"text-align:left\">灵活配置 Retrofit 实例</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>工厂模式</strong></td>\n<td style=\"text-align:left\"><code>Converter.Factory</code>、<code>CallAdapter.Factory</code></td>\n<td style=\"text-align:left\">创建 Converter 和 CallAdapter 实例</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>动态代理模式</strong></td>\n<td style=\"text-align:left\">接口方法转换为 HTTP 请求</td>\n<td style=\"text-align:left\">运行时生成接口代理对象</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>适配器模式</strong></td>\n<td style=\"text-align:left\"><code>CallAdapter</code></td>\n<td style=\"text-align:left\">将 <code>Call</code> 适配为其他类型</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>装饰器模式</strong></td>\n<td style=\"text-align:left\"><code>OkHttp</code> 拦截器</td>\n<td style=\"text-align:left\">增强 HTTP 请求和响应的功能</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>观察者模式</strong></td>\n<td style=\"text-align:left\">与 <code>RxJava</code> 或 <code>LiveData</code> 结合</td>\n<td style=\"text-align:left\">实现异步数据流的订阅和通知</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>策略模式</strong></td>\n<td style=\"text-align:left\"><code>Converter</code> 和 <code>CallAdapter</code> 选择</td>\n<td style=\"text-align:left\">动态选择数据转换或调用适配策略</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>单例模式</strong></td>\n<td style=\"text-align:left\"><code>Retrofit</code> 实例共享</td>\n<td style=\"text-align:left\">确保全局只有一个 Retrofit 实例</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>模板方法模式</strong></td>\n<td style=\"text-align:left\"><code>Call</code> 的实现</td>\n<td style=\"text-align:left\">定义 HTTP 请求的执行流程</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p><strong>retrofit 的动态代理模式</strong></p>\n<p>retrofit 用了诸多的设计模式，其中最经典的莫过于动态代理模式了，在了解 retrofit 之前，我一直以为这样的网络请求形式是最直观的，参考以前写的<a href=\"https://julis.wang/2019/05/13/%E5%9F%BA%E4%BA%8EVolley%E6%A1%86%E6%9E%B6%E7%9A%84%E8%BF%94%E5%9B%9E%E6%95%B0%E6%8D%AE%E7%9A%84%E8%8C%83%E5%9E%8B%E5%A4%84%E7%90%86/\">基于Volley框架的返回数据的范型处理</a></p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"code\"><pre><span class=\"line\">Request.<span class=\"keyword\">get</span>(</span><br><span class=\"line\">    url = url,</span><br><span class=\"line\">    params = param,</span><br><span class=\"line\">    listener = <span class=\"keyword\">object</span> : OnRequestListener&lt;Data&gt; &#123;</span><br><span class=\"line\">        <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onSuccess</span><span class=\"params\">(commonData: <span class=\"type\">CommonData</span>?, <span class=\"keyword\">data</span>: <span class=\"type\">Data</span>?)</span></span> &#123;&#125;</span><br><span class=\"line\">        <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onFailure</span><span class=\"params\">(errorCode: <span class=\"type\">Int</span>, errorMessage: <span class=\"type\">String</span>?)</span></span> &#123;&#125;</span><br><span class=\"line\">    &#125;)</span><br></pre></td></tr></table></figure>\n<p>以为这样很直观，逻辑也很清晰，实则 代码冗余，回调嵌套，如果有多个连续的请求，代码会变得难以维护，而 retrofit 搭配上协程能这样实现：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> <span class=\"keyword\">data</span> = apiService.getXXX(params)</span><br></pre></td></tr></table></figure>\n<p>简单到不能再简单，<code>动态代理</code>功不可没，上面的 apiService 是一个接口，由：<code>retrofit.create(ApiInterface::class.java)</code> 生成其实例，动态代理其核心实现：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> &lt;T&gt; T <span class=\"title function_\">create</span><span class=\"params\">(<span class=\"keyword\">final</span> Class&lt;T&gt; service)</span> &#123;</span><br><span class=\"line\">    validateServiceInterface(service);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (T)</span><br><span class=\"line\">        Proxy.newProxyInstance(</span><br><span class=\"line\">            service.getClassLoader(),</span><br><span class=\"line\">            <span class=\"keyword\">new</span> <span class=\"title class_\">Class</span>&lt;?&gt;[] &#123;service&#125;,</span><br><span class=\"line\">            <span class=\"keyword\">new</span> <span class=\"title class_\">InvocationHandler</span>() &#123;</span><br><span class=\"line\">              <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"type\">Platform</span> <span class=\"variable\">platform</span> <span class=\"operator\">=</span> Platform.get();</span><br><span class=\"line\">              <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Object[] emptyArgs = <span class=\"keyword\">new</span> <span class=\"title class_\">Object</span>[<span class=\"number\">0</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">              <span class=\"meta\">@Override</span></span><br><span class=\"line\">              <span class=\"keyword\">public</span> <span class=\"meta\">@Nullable</span> Object <span class=\"title function_\">invoke</span><span class=\"params\">(Object proxy, Method method, <span class=\"meta\">@Nullable</span> Object[] args)</span> <span class=\"keyword\">throws</span> Throwable &#123;</span><br><span class=\"line\">                <span class=\"comment\">// ....</span></span><br><span class=\"line\">                <span class=\"keyword\">return</span> platform.isDefaultMethod(method)</span><br><span class=\"line\">                    ? platform.invokeDefaultMethod(method, service, proxy, args)</span><br><span class=\"line\">                    : loadServiceMethod(method).invoke(args);</span><br><span class=\"line\">              &#125;</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<p>由<code>loadServiceMethod(method).invoke(args)</code> 负责将接口方法（通过 Java 反射获取的 <code>Method</code> 对象）解析并转换为一个可执行的 HTTP 请求。</p>\n<p><code>Proxy.newProxyInstance</code> 方法，参数：</p>\n<ul>\n<li><p>ClassLoader loader 用于加载代理类的类加载器。</p>\n</li>\n<li><p>Class&lt;?&gt;[] interfaces 代理类需要实现的接口数组，代理对象将实现这些接口，并拦截对这些接口方法的调用。只能代理实现了接口的类，不能代理没有接口的类。</p>\n</li>\n<li><p>InvocationHandler h<br>调用处理器，负责处理代理对象上的方法调用。每次调用代理对象的方法时，都会调用 <code>InvocationHandler</code> 的 <code>invoke</code> 方法。对于 Retrofit 的接口我们并没有去“实现”它的方法，所有的逻辑都由<code>` retrofit.create()</code>方法里面返回的 <code>InvocationHandler</code>实现的 <code>invoke</code>方法实现的。</p>\n</li>\n</ul>\n<h3 id=\"核心实现逻辑\"><a href=\"#核心实现逻辑\" class=\"headerlink\" title=\"核心实现逻辑\"></a>核心实现逻辑</h3><h4 id=\"协程的支持\"><a href=\"#协程的支持\" class=\"headerlink\" title=\"协程的支持\"></a><strong>协程的支持</strong></h4><p>Retrofit 支持多种异步编程模型，包括回调、RxJava 和协程等，这里主要记录一下对协程的支持。普通方法和异步逻辑的分叉在：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (!isKotlinSuspendFunction) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> new CallAdapted&lt;&gt;(requestFactory, callFactory, responseConverter, callAdapter);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (continuationWantsResponse) &#123;</span><br><span class=\"line\">      <span class=\"comment\">//noinspection unchecked Kotlin compiler guarantees ReturnT to be Object.</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> (HttpServiceMethod&lt;ResponseT, ReturnT&gt;)</span><br><span class=\"line\">          new SuspendForResponse&lt;&gt;(</span><br><span class=\"line\">              requestFactory,</span><br><span class=\"line\">              callFactory,</span><br><span class=\"line\">              responseConverter,</span><br><span class=\"line\">              (CallAdapter&lt;ResponseT, Call&lt;ResponseT&gt;&gt;) callAdapter);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">//noinspection unchecked Kotlin compiler guarantees ReturnT to be Object.</span></span><br><span class=\"line\">\t\t\t<span class=\"comment\">//...</span></span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>上面代码关键变量<code>isKotlinSuspendFunction</code> ，用于判断是否为协程方法（suspend修饰），判断逻辑很简单，只需要判定方法最后一个参数是否为<code>Continuation.class</code> 即可。这里的分叉逻辑都继承自<code>HttpServiceMethod&lt;T&gt;</code>实现 <code>ReturnT adapt(Call&lt;ResponseT&gt; call, Object[] args)</code>这个抽象方法，这也是 retrofit 使用 <strong>适配器模式</strong>的地方，把不同的调用方式进行统一。对于协程方式的调用有实现：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">protected</span> Object adapt(Call&lt;ResponseT&gt; call, Object[] args) &#123;</span><br><span class=\"line\">      call = callAdapter.adapt(call);</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">//noinspection unchecked Checked by reflection inside RequestFactory.</span></span><br><span class=\"line\">      Continuation&lt;Response&lt;ResponseT&gt;&gt; continuation =</span><br><span class=\"line\">          (Continuation&lt;Response&lt;ResponseT&gt;&gt;) args[args.length - <span class=\"number\">1</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">// See SuspendForBody for explanation about this try/catch.</span></span><br><span class=\"line\">      <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> KotlinExtensions.awaitResponse(call, continuation);</span><br><span class=\"line\">      &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>.suspendAndThrow(e, continuation);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">suspend</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"type\">&lt;T&gt;</span> Call<span class=\"type\">&lt;T&gt;</span>.<span class=\"title\">awaitResponse</span><span class=\"params\">()</span></span>: Response&lt;T&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> suspendCancellableCoroutine &#123; continuation -&gt;</span><br><span class=\"line\">    continuation.invokeOnCancellation &#123;</span><br><span class=\"line\">      cancel()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    enqueue(<span class=\"keyword\">object</span> : Callback&lt;T&gt; &#123;</span><br><span class=\"line\">      <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onResponse</span><span class=\"params\">(call: <span class=\"type\">Call</span>&lt;<span class=\"type\">T</span>&gt;, response: <span class=\"type\">Response</span>&lt;<span class=\"type\">T</span>&gt;)</span></span> &#123;</span><br><span class=\"line\">        continuation.resume(response)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onFailure</span><span class=\"params\">(call: <span class=\"type\">Call</span>&lt;<span class=\"type\">T</span>&gt;, t: <span class=\"type\">Throwable</span>)</span></span> &#123;</span><br><span class=\"line\">        continuation.resumeWithException(t)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里就一切都明朗了，实现了 <code>Call</code>的扩展方法，这里的 <code>Call</code>并不是 <code>okhttp3.Call</code>，它只是 retrofit  <code>okhttp3.Call</code>为方便框架整体逻辑的处理而定义的，比如 retrofit 的 <code>Call</code> 是泛型化的，可以直接返回解析后的对象，<code>enqueue</code>同理。</p>\n<p><code>suspendCancellableCoroutine</code>方法是实现协程方法的关键，它可以将基于回调的异步操作封装成一个挂起函数，怎么理解呢？对 扩展方法<code>awaitResponse</code>反编译可以看到方法定义是这样的：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Object <span class=\"title function_\">await</span><span class=\"params\">(<span class=\"meta\">@NotNull</span> Call $<span class=\"built_in\">this</span>$await, <span class=\"meta\">@NotNull</span> Continuation $completion)</span> </span><br></pre></td></tr></table></figure>\n<p>其实这里跟定义一个 <code>listener</code>去监听方法的回调有点像，这个方法改写成 <code>listener</code>的实现话大概就是这样：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"type\">&lt;T&gt;</span> Call<span class=\"type\">&lt;T&gt;</span>.<span class=\"title\">awaitResponse</span><span class=\"params\">(listener:<span class=\"type\">Listener</span>&lt;<span class=\"type\">T</span>&gt;)</span></span>: Response&lt;T&gt; &#123;</span><br><span class=\"line\">        enqueue(<span class=\"keyword\">object</span> : Callback&lt;T&gt; &#123;</span><br><span class=\"line\">            <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onResponse</span><span class=\"params\">(call: <span class=\"type\">Call</span>&lt;<span class=\"type\">T</span>&gt;, response: <span class=\"type\">Response</span>&lt;<span class=\"type\">T</span>&gt;)</span></span> &#123;</span><br><span class=\"line\">                Listener.resume(response)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onFailure</span><span class=\"params\">(call: <span class=\"type\">Call</span>&lt;<span class=\"type\">T</span>&gt;, t: <span class=\"type\">Throwable</span>)</span></span> &#123;</span><br><span class=\"line\">                Listener.resumeWithException(t)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>可看到改造实现需要传递一个 <code>listener</code>，哪这个 <code>listener</code>是什么？前面其有如何判断一个方法是否为协程的方法的逻辑：判定方法最后一个参数是否为<code>Continuation.class</code> 即可。这里的  <code>listener</code> 其实可以等价于 一个 <code>Continuation</code>实例，kotlin 的协程库帮我们实现了对应的封装，对于使用我们不会直观地感受<code>Continuation</code>的存在，实际它贯穿整个协程。关于协程这里不再赘述，可以查看 <a href=\"https://juejin.cn/post/7142743424670629895?searchId=202503230943390124BC33C1668EC4B62B\">《带着问题分析Kotlin协程原理》</a>了解。</p>\n<h3 id=\"返回数据格式的解析\"><a href=\"#返回数据格式的解析\" class=\"headerlink\" title=\"返回数据格式的解析\"></a><strong>返回数据格式的解析</strong></h3><p>对于<strong>Converter</strong>,在协程和普通方法调用分叉逻辑的前面点：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"code\"><pre><span class=\"line\">Converter&lt;ResponseBody, ResponseT&gt; responseConverter = createResponseConverter(retrofit, method, responseType);</span><br></pre></td></tr></table></figure>\n<p><code>createResponseConverter</code>之后一路走到</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> &lt;T&gt; Converter&lt;ResponseBody, T&gt; nextResponseBodyConverter(</span><br><span class=\"line\">    <span class=\"meta\">@Nullable</span> Converter.Factory skipPast, Type type, Annotation[] annotations) &#123;</span><br><span class=\"line\">  Objects.requireNonNull(type, <span class=\"string\">&quot;type == null&quot;</span>);</span><br><span class=\"line\">  Objects.requireNonNull(annotations, <span class=\"string\">&quot;annotations == null&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  int start = converterFactories.indexOf(skipPast) + <span class=\"number\">1</span>;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (int i = start, count = converterFactories.size(); i &lt; count; i++) &#123;</span><br><span class=\"line\">    Converter&lt;ResponseBody, ?&gt; converter =</span><br><span class=\"line\">        converterFactories.<span class=\"keyword\">get</span>(i).responseBodyConverter(type, annotations, <span class=\"keyword\">this</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (converter != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">      <span class=\"comment\">//noinspection unchecked</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> (Converter&lt;ResponseBody, T&gt;) converter;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>converterFactories</code> 的值就是在 retrofit 初始化的时候进行使用  <code>public Builder addConverterFactory(Converter.Factory factory)</code>添加的值。可以看到是按添加到<code>List&lt;Converter.Factory&gt; converterFactories</code>里面的顺序进行选择的，默认<code>GsonConverterFactory</code>实现了利用 <code>Gson</code>进行数据转化 ，如果我们自己实现<code>Converter.Factory</code>的接口的话，那么可以根据一定的规则判断是否要返回我们自定义的 <code>Converter</code>，如果不需要使用就返回 null，会自动匹配下一个能使用的 <code>Converter</code>。注意这里并不会因为前一个  <code>Converter</code> 解析失败而自动尝试使用下一个<code>Converter</code>（当然，你可以在自定义的<code>Converter</code>里面做类似这样的尝试策略）。</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><ul>\n<li><p>这篇文章深入剖析了 <strong>Retrofit</strong> 框架的核心设计模式、动态代理机制、协程支持以及数据解析逻辑，通过源码分析和手写实现，帮助读者更好地理解 Retrofit 的工作原理，并强调了理论与实践结合的重要性。</p>\n</li>\n<li><p>为加深对 retrofit 的理解，可以尝试手写核心实现，自己尝试的的代码在 <a href=\"https://github.com/VomPom/JProject/tree/master/app/src/main/java/wang/julis/jproject/example/source/retrofit2/learn/vmfit\">vmfit</a> </p>\n</li>\n<li><p>附一张 retrofit 的全流程图，来源：<a href=\"https://cloud.tencent.com/developer/article/1683334\">https://cloud.tencent.com/developer/article/1683334</a></p>\n</li>\n</ul>\n<img src=\"https://cdn.julis.wang/blog/img/ru5ssbhumq.jpeg\">","raw":"title: RetroFit2 源码学习相关\nauthor: 落叶挽歌\ntags:\n  - Android\ncategories:\n  - 技术文章\ndate: 2025-03-17 20:28:00\n---\n\n\n\n研究 [retrofit](https://github.com/square/retrofit) 目标：理解动态代理、注解、反射、学习它所用到的设计模式，达到自己能手写它的核心实现。\n\n最近终于有点精力能够去研究研究源码了， 真的是写的一个非常好的的开源库，以前刚接触安卓的时候扒拉过相关的源码，但是随着工作了几年之后，经验的积累，让我对源码里面的东西能够体会更深刻，自己也尝试去手写里面的核心实现，看完源码对整体的架构理解了之后，以为自己能很顺利的写下来，实则不然。\n知识还是需要知行合一，这篇文章主要记录 [retrofit](https://github.com/square/retrofit)  的一些知识点。\n\n\n\n### retrofit 的设计模式\n\nretrofit 里面中使用了多种设计模式，以实现其灵活、可扩展和高性能的特性：\n\n| 设计模式         | 应用场景                                   | 作用                               |\n| :--------------- | :----------------------------------------- | :--------------------------------- |\n| **建造者模式**   | `Retrofit.Builder`                         | 灵活配置 Retrofit 实例             |\n| **工厂模式**     | `Converter.Factory`、`CallAdapter.Factory` | 创建 Converter 和 CallAdapter 实例 |\n| **动态代理模式** | 接口方法转换为 HTTP 请求                   | 运行时生成接口代理对象             |\n| **适配器模式**   | `CallAdapter`                              | 将 `Call` 适配为其他类型           |\n| **装饰器模式**   | `OkHttp` 拦截器                            | 增强 HTTP 请求和响应的功能         |\n| **观察者模式**   | 与 `RxJava` 或 `LiveData` 结合             | 实现异步数据流的订阅和通知         |\n| **策略模式**     | `Converter` 和 `CallAdapter` 选择          | 动态选择数据转换或调用适配策略     |\n| **单例模式**     | `Retrofit` 实例共享                        | 确保全局只有一个 Retrofit 实例     |\n| **模板方法模式** | `Call` 的实现                              | 定义 HTTP 请求的执行流程           |\n\n**retrofit 的动态代理模式**\n\nretrofit 用了诸多的设计模式，其中最经典的莫过于动态代理模式了，在了解 retrofit 之前，我一直以为这样的网络请求形式是最直观的，参考以前写的[基于Volley框架的返回数据的范型处理](https://julis.wang/2019/05/13/%E5%9F%BA%E4%BA%8EVolley%E6%A1%86%E6%9E%B6%E7%9A%84%E8%BF%94%E5%9B%9E%E6%95%B0%E6%8D%AE%E7%9A%84%E8%8C%83%E5%9E%8B%E5%A4%84%E7%90%86/)\n\n```kotlin\nRequest.get(\n    url = url,\n    params = param,\n    listener = object : OnRequestListener<Data> {\n        override fun onSuccess(commonData: CommonData?, data: Data?) {}\n        override fun onFailure(errorCode: Int, errorMessage: String?) {}\n    })\n```\n\n以为这样很直观，逻辑也很清晰，实则 代码冗余，回调嵌套，如果有多个连续的请求，代码会变得难以维护，而 retrofit 搭配上协程能这样实现：\n\n```kotlin\nval data = apiService.getXXX(params)\n```\n\n简单到不能再简单，`动态代理`功不可没，上面的 apiService 是一个接口，由：` retrofit.create(ApiInterface::class.java)` 生成其实例，动态代理其核心实现：\n\n```java\npublic <T> T create(final Class<T> service) {\n    validateServiceInterface(service);\n    return (T)\n        Proxy.newProxyInstance(\n            service.getClassLoader(),\n            new Class<?>[] {service},\n            new InvocationHandler() {\n              private final Platform platform = Platform.get();\n              private final Object[] emptyArgs = new Object[0];\n\n              @Override\n              public @Nullable Object invoke(Object proxy, Method method, @Nullable Object[] args) throws Throwable {\n                // ....\n                return platform.isDefaultMethod(method)\n                    ? platform.invokeDefaultMethod(method, service, proxy, args)\n                    : loadServiceMethod(method).invoke(args);\n              }\n            });\n  }\n```\n\n由`loadServiceMethod(method).invoke(args)` 负责将接口方法（通过 Java 反射获取的 `Method` 对象）解析并转换为一个可执行的 HTTP 请求。\n\n`Proxy.newProxyInstance` 方法，参数：\n\n- ClassLoader loader 用于加载代理类的类加载器。\n\n- Class<?>[] interfaces 代理类需要实现的接口数组，代理对象将实现这些接口，并拦截对这些接口方法的调用。只能代理实现了接口的类，不能代理没有接口的类。\n\n- InvocationHandler h\n调用处理器，负责处理代理对象上的方法调用。每次调用代理对象的方法时，都会调用 `InvocationHandler` 的 `invoke` 方法。对于 Retrofit 的接口我们并没有去“实现”它的方法，所有的逻辑都由`` retrofit.create()`方法里面返回的 `InvocationHandler`实现的 `invoke`方法实现的。\n\n\n\n### 核心实现逻辑\n\n#### **协程的支持**\n\nRetrofit 支持多种异步编程模型，包括回调、RxJava 和协程等，这里主要记录一下对协程的支持。普通方法和异步逻辑的分叉在：\n\n```kotlin\nif (!isKotlinSuspendFunction) {\n      return new CallAdapted<>(requestFactory, callFactory, responseConverter, callAdapter);\n    } else if (continuationWantsResponse) {\n      //noinspection unchecked Kotlin compiler guarantees ReturnT to be Object.\n      return (HttpServiceMethod<ResponseT, ReturnT>)\n          new SuspendForResponse<>(\n              requestFactory,\n              callFactory,\n              responseConverter,\n              (CallAdapter<ResponseT, Call<ResponseT>>) callAdapter);\n    } else {\n      //noinspection unchecked Kotlin compiler guarantees ReturnT to be Object.\n\t\t\t//...\n    }\n```\n\n上面代码关键变量`isKotlinSuspendFunction` ，用于判断是否为协程方法（suspend修饰），判断逻辑很简单，只需要判定方法最后一个参数是否为` Continuation.class` 即可。这里的分叉逻辑都继承自`HttpServiceMethod<T>`实现 `ReturnT adapt(Call<ResponseT> call, Object[] args)`这个抽象方法，这也是 retrofit 使用 **适配器模式**的地方，把不同的调用方式进行统一。对于协程方式的调用有实现：\n\n```kotlin\nprotected Object adapt(Call<ResponseT> call, Object[] args) {\n      call = callAdapter.adapt(call);\n\n      //noinspection unchecked Checked by reflection inside RequestFactory.\n      Continuation<Response<ResponseT>> continuation =\n          (Continuation<Response<ResponseT>>) args[args.length - 1];\n\n      // See SuspendForBody for explanation about this try/catch.\n      try {\n        return KotlinExtensions.awaitResponse(call, continuation);\n      } catch (Exception e) {\n        return.suspendAndThrow(e, continuation);\n      }\n    }\n```\n\n```kotlin\nsuspend fun <T> Call<T>.awaitResponse(): Response<T> {\n  return suspendCancellableCoroutine { continuation ->\n    continuation.invokeOnCancellation {\n      cancel()\n    }\n    enqueue(object : Callback<T> {\n      override fun onResponse(call: Call<T>, response: Response<T>) {\n        continuation.resume(response)\n      }\n\n      override fun onFailure(call: Call<T>, t: Throwable) {\n        continuation.resumeWithException(t)\n      }\n    })\n  }\n}\n```\n\n这里就一切都明朗了，实现了 `Call`的扩展方法，这里的 `Call`并不是 `okhttp3.Call`，它只是 retrofit  `okhttp3.Call`为方便框架整体逻辑的处理而定义的，比如 retrofit 的 `Call` 是泛型化的，可以直接返回解析后的对象，`enqueue`同理。\n\n`suspendCancellableCoroutine`方法是实现协程方法的关键，它可以将基于回调的异步操作封装成一个挂起函数，怎么理解呢？对 扩展方法`awaitResponse`反编译可以看到方法定义是这样的：\n\n```java\n public static final Object await(@NotNull Call $this$await, @NotNull Continuation $completion) \n```\n\n其实这里跟定义一个 `listener`去监听方法的回调有点像，这个方法改写成 `listener`的实现话大概就是这样：\n\n```kotlin\nfun <T> Call<T>.awaitResponse(listener:Listener<T>): Response<T> {\n        enqueue(object : Callback<T> {\n            override fun onResponse(call: Call<T>, response: Response<T>) {\n                Listener.resume(response)\n            }\n\n            override fun onFailure(call: Call<T>, t: Throwable) {\n                Listener.resumeWithException(t)\n            }\n        })\n    }\n}\n```\n\n可看到改造实现需要传递一个 `listener`，哪这个 `listener`是什么？前面其有如何判断一个方法是否为协程的方法的逻辑：判定方法最后一个参数是否为` Continuation.class` 即可。这里的  `listener` 其实可以等价于 一个 `Continuation`实例，kotlin 的协程库帮我们实现了对应的封装，对于使用我们不会直观地感受`Continuation`的存在，实际它贯穿整个协程。关于协程这里不再赘述，可以查看 [《带着问题分析Kotlin协程原理》](https://juejin.cn/post/7142743424670629895?searchId=202503230943390124BC33C1668EC4B62B)了解。\n\n\n\n### **返回数据格式的解析**\n\n对于**Converter**,在协程和普通方法调用分叉逻辑的前面点：\n\n```kotlin\nConverter<ResponseBody, ResponseT> responseConverter = createResponseConverter(retrofit, method, responseType);\n```\n\n`createResponseConverter`之后一路走到\n\n```kotlin\n  public <T> Converter<ResponseBody, T> nextResponseBodyConverter(\n      @Nullable Converter.Factory skipPast, Type type, Annotation[] annotations) {\n    Objects.requireNonNull(type, \"type == null\");\n    Objects.requireNonNull(annotations, \"annotations == null\");\n\n    int start = converterFactories.indexOf(skipPast) + 1;\n    for (int i = start, count = converterFactories.size(); i < count; i++) {\n      Converter<ResponseBody, ?> converter =\n          converterFactories.get(i).responseBodyConverter(type, annotations, this);\n      if (converter != null) {\n        //noinspection unchecked\n        return (Converter<ResponseBody, T>) converter;\n      }\n    }\n  }\n```\n\n`converterFactories` 的值就是在 retrofit 初始化的时候进行使用  `public Builder addConverterFactory(Converter.Factory factory)`添加的值。可以看到是按添加到`List<Converter.Factory> converterFactories`里面的顺序进行选择的，默认`GsonConverterFactory`实现了利用 `Gson`进行数据转化 ，如果我们自己实现`Converter.Factory`的接口的话，那么可以根据一定的规则判断是否要返回我们自定义的 `Converter`，如果不需要使用就返回 null，会自动匹配下一个能使用的 `Converter`。注意这里并不会因为前一个  `Converter` 解析失败而自动尝试使用下一个`Converter`（当然，你可以在自定义的`Converter`里面做类似这样的尝试策略）。\n\n\n\n### 总结\n\n- 这篇文章深入剖析了 **Retrofit** 框架的核心设计模式、动态代理机制、协程支持以及数据解析逻辑，通过源码分析和手写实现，帮助读者更好地理解 Retrofit 的工作原理，并强调了理论与实践结合的重要性。\n\n- 为加深对 retrofit 的理解，可以尝试手写核心实现，自己尝试的的代码在 [vmfit](https://github.com/VomPom/JProject/tree/master/app/src/main/java/wang/julis/jproject/example/source/retrofit2/learn/vmfit) \n\n- 附一张 retrofit 的全流程图，来源：https://cloud.tencent.com/developer/article/1683334\n\n{% qnimg ru5ssbhumq.jpeg %}","categories":[{"name":"技术文章","api":"api/categories/technology.json"}],"tags":[{"name":"Android","api":"api/tags/Android.json"}]},"api":"api/posts/2025/03/17/Learn-from-RetroFit.json"}