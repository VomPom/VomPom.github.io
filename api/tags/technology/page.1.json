{"data":{"index":1,"total":1,"posts":[{"title":"RecyclerView自定义LayoutManager从0到1实践","slug":"自定义LayoutManager从0到1实践","date":"2023-10-31T11:19:00.000Z","updated":"2025-05-20T11:46:57.000Z","comments":true,"url":"2023/10/31/自定义LayoutManager从0到1实践/","excerpt":"<p>此前大部分涉及到 RecyclerView 页面的 LayoutManager基本上用系统提供的 LinearLayoutManager 、GridLayoutManager 就能解决，但在一些特殊场景上还是需要我们自定义  LayoutManager。之前基本上没有自己写过，在网上看各种源码各种文章，刚开始花了好多时间去理解整体流程，因为它们都给我一种非常非常复杂的感觉，包括相关的博客文章也是。经过一段时间摸索，也慢慢能理解为什么要那么复杂了，这的确不是特别容易入门。所以对整体的流程进行了一个拆解，尽量原子化一点，对自己学习的一个总结，也希望能帮助到一部分人能对  LayoutManager 入门。</p>\n<p>本文最终实现一个简单的 LinearLayoutManager（只支持 VERTICAL）方向，适合对 LayoutManager 整体流程的学习与理解，整体代码分为多个文件，每个文件都是对前一段代码的补充，方便理解，整体项目源码已提交 Github: <a href=\"https://github.com/VomPom/LayoutManagerGradually\">LayoutManagerGradually</a>，代码里面写了很多很多注释，如果不想浪费时间，可以直接看代码运行，跳过这篇文章，把每一个 LayoutManager 都跑一下体验结合代码看看。</p>\n<h2 id=\"自定义-LayoutManager-的必要元素\"><a href=\"#自定义-LayoutManager-的必要元素\" class=\"headerlink\" title=\"自定义 LayoutManager 的必要元素\"></a>自定义 LayoutManager 的必要元素</h2><ul>\n<li><p>继承 <code>RecyclerView.LayoutManager</code> 并实现 <code>generateDefaultLayoutParams()</code>方法</p>\n</li>\n<li><p>重写<code>onLayoutChildren</code> 第一次数据填充的时候数据添加</p>\n</li>\n<li><p>重写 <code>canScrollHorizontally()</code> 和<code>canScrollVertically()</code>方法设定支持滑动的方向</p>\n</li>\n<li><p>重写 <code>scrollHorizontallyBy()</code>和<code>scrollVerticallyBy()</code>方法，在滑动的时候对屏幕以外的 View 进行回收，以及填充即将滑动进入屏幕范围内的 View 进行填充</p>\n</li>\n<li><p>重写 <code>scrollToPosition()</code>和<code>smoothScrollToPosition()</code>方法支持</p>\n</li>\n</ul>\n<p>其中<code>onLayoutChildren</code> 和 <code>scrollHorizontallyBy/scrollVerticallyBy</code> 是最核心且最复杂的方法，这里稍微拎出来讲一下</p>\n<h3 id=\"onLayoutChildren\"><a href=\"#onLayoutChildren\" class=\"headerlink\" title=\"onLayoutChildren\"></a>onLayoutChildren</h3><p>这个方法类似于自定义 ViewGroup 的 onLayout() 方法，RecyclerView 的 LayoutManager.onLayoutChildren 在以下几个时机会被触发：</p>\n<ul>\n<li>当 <code>RecyclerView</code> 首次附加到窗口时</li>\n<li>当<code>Adapter</code>  的数据集发生变化</li>\n<li>当 <code>RecyclerView</code> 被 执行 <code>RequetLayout</code>的时候</li>\n<li>当 <code>LayoutManager</code> 发生变化时</li>\n</ul>\n<h3 id=\"scrollHorizontallyBy-scrollVerticallyBy\"><a href=\"#scrollHorizontallyBy-scrollVerticallyBy\" class=\"headerlink\" title=\"scrollHorizontallyBy/scrollVerticallyBy\"></a>scrollHorizontallyBy/scrollVerticallyBy</h3><p>方法的主要作用包括：</p>\n<ol>\n<li><p>更新 ItemView 的位置：根据传入的垂直滚动距离（dy 参数），更新子视图在屏幕上的位置。通常调用 <code>offsetChildrenVertical</code> 方法。</p>\n</li>\n<li><p>回收不可见的 ItemView：在滚动过程中，一些 ItemView 可能会离开屏幕，变得不可见。<code>scrollVerticallyBy</code> 方法需要负责回收这些子视图并将它们放入回收池，以便稍后复用。</p>\n</li>\n<li><p>添加新的 ItemView：在滚动过程中，新的 ItemView 可能需要显示在屏幕上。<code>scrollVerticallyBy</code> 方法需要从回收池中获取可复用的视图并将它们添加到屏幕上。这通常涉及到调用 <code>RecyclerView.Recycler</code> 的 <code>getViewForPosition</code> 方法。</p>\n</li>\n<li><p>返回实际滚动距离：由于 ItemView 的数量有限，滚动可能会受到限制。例如，当滚动到列表顶部或底部时，滚动可能会停止。在这种情况下，实际滚动的距离可能会小于传入的 <code>dy</code> 参数。<code>scrollVerticallyBy</code> 方法需要返回实际滚动的距离，以便 <code>RecyclerView</code> 可以正确地更新滚动条和触发滚动事件。</p>\n</li>\n</ol>\n<p>概念就简单讲这么多， talk is cheap show me the code，直接看代码理解会比较深刻</p>\n<h2 id=\"逐步实现\"><a href=\"#逐步实现\" class=\"headerlink\" title=\"逐步实现\"></a>逐步实现</h2><p>要实现一个可用的 LayoutManger 通常我们需要实现以下流程</p>\n<ul>\n<li>数据填充并且只需要填充屏幕范围内的 ItemView</li>\n<li>回收掉屏幕以外的 ItemView</li>\n<li>屏幕外 ItemView 再回到屏幕后，需要重新填充</li>\n<li>对滑动边界边界进行处理</li>\n<li>对 scrollToPosition 和 smoothScrollToPosition进行支持</li>\n</ul>\n<p>我们不用一上来就实现最终的效果，而是一步一步来，看看 LayoutManger 是怎么渐渐地变化，最终能跑起来的。</p>\n<h3 id=\"0-最简单的-LayoutManager\"><a href=\"#0-最简单的-LayoutManager\" class=\"headerlink\" title=\"0 最简单的 LayoutManager\"></a>0 最简单的 LayoutManager</h3><p>代码查看：<a href=\"https://github.com/VomPom/LayoutManagerGradually/tree/main/layoutmanager/src/main/java/com/julis/layoutmanager/series/MostSimpleLayoutManager.kt\">MostSimpleLayoutManager</a>，我们关注 <code>onLayoutChildren</code> 方法:</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onLayoutChildren</span><span class=\"params\">(recycler: <span class=\"type\">RecyclerView</span>.<span class=\"type\">Recycler</span>, state: <span class=\"type\">RecyclerView</span>.<span class=\"type\">State</span>?)</span></span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 垂直方向的偏移量</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> offsetTop = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"comment\">// 实际业务中最好不要这样一次性加载所有的数据，这里只是最简单地演示一下整体是如何工作的</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (itemIndex <span class=\"keyword\">in</span> <span class=\"number\">0</span> until itemCount) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 从适配器获取与给定位置关联的视图</span></span><br><span class=\"line\">        <span class=\"keyword\">val</span> itemView = recycler.getViewForPosition(itemIndex)</span><br><span class=\"line\">        <span class=\"comment\">// 将视图添加到 RecyclerView 中</span></span><br><span class=\"line\">        addView(itemView)</span><br><span class=\"line\">        <span class=\"comment\">// 测量并布局视图</span></span><br><span class=\"line\">        measureChildWithMargins(itemView, <span class=\"number\">0</span>, <span class=\"number\">0</span>)</span><br><span class=\"line\">        <span class=\"comment\">// 拿到宽高（包括ItemDecoration）</span></span><br><span class=\"line\">        <span class=\"keyword\">val</span> width = getDecoratedMeasuredWidth(itemView)</span><br><span class=\"line\">        <span class=\"keyword\">val</span> height = getDecoratedMeasuredHeight(itemView)</span><br><span class=\"line\">        <span class=\"comment\">// 对要添加的子 View 进行布局</span></span><br><span class=\"line\">        layoutDecorated(itemView, <span class=\"number\">0</span>, offsetTop, width, offsetTop + height)</span><br><span class=\"line\">        offsetTop += height</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面的代码主要演示了，如何利用<code>addView</code> <code>layoutDecorated</code>等方法，将 ItemView 添加到 RecyclerView 上。代码可见是 将所有的 ItemView（即使它在屏幕上不可见）一次性全部加载到了 RecyclerView上， 这里一般不这么做，只是这里这里只是最简单地演示一下整体是如何工作的。</p>\n<p>运行在手机上能看到这样的效果：Item数据已经被全部添加到界面上了，并且各个方向的滑动都支持。</p>\n<img src=\"https://cdn.julis.wang/blog/img/layoutmanager_gradually_0.gif?imageView2/2/w/300\">\n<h3 id=\"1-更合理的数据添加方式\"><a href=\"#1-更合理的数据添加方式\" class=\"headerlink\" title=\"1 更合理的数据添加方式\"></a>1 更合理的数据添加方式</h3><p>代码查看：<a href=\"https://github.com/VomPom/LayoutManagerGradually/tree/main/layoutmanager/src/main/java/com/julis/layoutmanager/series/LinearLayoutManager1\">LinearLayoutManager1.kt</a></p>\n<p>对最开始的代码进行优化，只在屏幕范围内的区域进行数据的添加，这样就不需要一次性将所有数据就添加上去，如果 Adapter 的 ItemCount 足够巨大，for all addView 的话，很容易就 OOM。</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onLayoutChildren</span><span class=\"params\">(recycler: <span class=\"type\">RecyclerView</span>.<span class=\"type\">Recycler</span>, state: <span class=\"type\">RecyclerView</span>.<span class=\"type\">State</span>)</span></span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 垂直方向上的的空间大小</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> remainSpace = height - paddingTop</span><br><span class=\"line\">    <span class=\"comment\">//垂直方向的偏移量</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> offsetTop = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> currentPosition = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (remainSpace &gt; <span class=\"number\">0</span> &amp;&amp; currentPosition &lt; state.itemCount) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 从适配器获取与给定位置关联的视图</span></span><br><span class=\"line\">        <span class=\"keyword\">val</span> itemView = recycler.getViewForPosition(currentPosition)</span><br><span class=\"line\">        <span class=\"comment\">// 将视图添加到 RecyclerView 中</span></span><br><span class=\"line\">        addView(itemView)</span><br><span class=\"line\">        <span class=\"comment\">// 测量并布局视图</span></span><br><span class=\"line\">        measureChildWithMargins(itemView, <span class=\"number\">0</span>, <span class=\"number\">0</span>)</span><br><span class=\"line\">        <span class=\"comment\">// 拿到宽高（包括ItemDecoration）</span></span><br><span class=\"line\">        <span class=\"keyword\">val</span> itemWidth = getDecoratedMeasuredWidth(itemView)</span><br><span class=\"line\">        <span class=\"keyword\">val</span> itemHeight = getDecoratedMeasuredHeight(itemView)</span><br><span class=\"line\">        <span class=\"comment\">// 对要添加的子 View 进行布局</span></span><br><span class=\"line\">        layoutDecorated(itemView, <span class=\"number\">0</span>, offsetTop, itemWidth, offsetTop + itemHeight)</span><br><span class=\"line\">        offsetTop += itemHeight</span><br><span class=\"line\">        currentPosition++</span><br><span class=\"line\">        <span class=\"comment\">// 可用空间减少</span></span><br><span class=\"line\">        remainSpace -= itemHeight</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-对屏幕外的View回收\"><a href=\"#2-对屏幕外的View回收\" class=\"headerlink\" title=\"2 对屏幕外的View回收\"></a>2 对屏幕外的View回收</h3><p>代码查看：<a href=\"https://github.com/VomPom/LayoutManagerGradually/tree/main/layoutmanager/src/main/java/com/julis/layoutmanager/series/LinearLayoutManager2.kt\">LinearLayoutManager2</a></p>\n<p>RecylerView 没有 recycler 怎么行呢？当 RecylerView 的 ItemView 滑出屏幕后我们需要对齐进行回收，实现的话需要在 <code>scrollVerticallyBy</code>中，比较复杂的逻辑就是怎么去判断：ItemView 在屏幕以外，最后利用：<code>removeAndRecycleView</code>方法进行回收</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">scrollVerticallyBy</span><span class=\"params\">(dy: <span class=\"type\">Int</span>, recycler: <span class=\"type\">RecyclerView</span>.<span class=\"type\">Recycler</span>, state: <span class=\"type\">RecyclerView</span>.<span class=\"type\">State</span>?)</span></span>: <span class=\"built_in\">Int</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 在这里处理上下的滚动逻辑，dy 表示滚动的距离</span></span><br><span class=\"line\">      <span class=\"comment\">// 平移所有子视图</span></span><br><span class=\"line\">      offsetChildrenVertical(-dy)</span><br><span class=\"line\">      <span class=\"comment\">// 如果实际滚动距离与 dy 相同，返回 dy；如果未滚动，返回 0</span></span><br><span class=\"line\">      recycleInvisibleView(dy, recycler)</span><br><span class=\"line\">      <span class=\"keyword\">return</span> dy</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 回收掉在界面上看不到的 ItemView</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> dy</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> recycler</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">recycleInvisibleView</span><span class=\"params\">(dy: <span class=\"type\">Int</span>, recycler: <span class=\"type\">RecyclerView</span>.<span class=\"type\">Recycler</span>)</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">val</span> totalSpace = orientationHelper.totalSpace</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 将要回收View的集合</span></span><br><span class=\"line\">    <span class=\"keyword\">val</span> recycleViews = hashSetOf&lt;View&gt;()</span><br><span class=\"line\">    <span class=\"comment\">// 从下往上滑</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (dy &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (i <span class=\"keyword\">in</span> <span class=\"number\">0</span> until childCount) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">val</span> child = getChildAt(i)!!</span><br><span class=\"line\">            <span class=\"comment\">// 从下往上滑从最上面的 item 开始计算</span></span><br><span class=\"line\">            <span class=\"keyword\">val</span> top = getDecoratedTop(child)</span><br><span class=\"line\">            <span class=\"comment\">// 判断最顶部的 item 是否已经完全不可见，如何可见，那说明底下的 item 也是可见</span></span><br><span class=\"line\">            <span class=\"keyword\">val</span> height = top - getDecoratedBottom(child)</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (height - top &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">break</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            recycleViews.add(child)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (dy &lt; <span class=\"number\">0</span>) &#123;   <span class=\"comment\">// 从上往下滑</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (i <span class=\"keyword\">in</span> childCount - <span class=\"number\">1</span> downTo <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">val</span> child = getChildAt(i)!!</span><br><span class=\"line\">            <span class=\"comment\">// 从上往下滑从最底部的 item 开始计算</span></span><br><span class=\"line\">            <span class=\"keyword\">val</span> bottom = getDecoratedBottom(child)</span><br><span class=\"line\">            <span class=\"comment\">// 判断最底部的 item 是否已经完全不可见，如何可见，那说明上面的 item 也是可见</span></span><br><span class=\"line\">            <span class=\"keyword\">val</span> height = bottom - getDecoratedTop(child)</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (bottom - totalSpace &lt; height) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">break</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            recycleViews.add(child)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 真正把 View 移除掉的逻辑</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (view <span class=\"keyword\">in</span> recycleViews) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// [removeAndRecycleView]</span></span><br><span class=\"line\">        <span class=\"comment\">// 用于从视图层次结构中删除某个视图，并将其资源回收，以便在需要时重新利用</span></span><br><span class=\"line\">        removeAndRecycleView(view, recycler)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    recycleViews.clear()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>运行在手机上能看到这样的效果：滑出屏幕外的ItemView 被回收掉了</p>\n<img src=\"https://cdn.julis.wang/blog/img/layoutmanager_gradually_2.gif?imageView2/2/w/300\">\n<h3 id=\"3-向上滑动的时View的填充\"><a href=\"#3-向上滑动的时View的填充\" class=\"headerlink\" title=\"3 向上滑动的时View的填充\"></a>3 向上滑动的时View的填充</h3><p>代码查看：<a href=\"https://github.com/VomPom/LayoutManagerGradually/tree/main/layoutmanager/src/main/java/com/julis/layoutmanager/series/LinearLayoutManager3.kt\">LinearLayoutManager3</a></p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">scrollVerticallyBy</span><span class=\"params\">(dy: <span class=\"type\">Int</span>, recycler: <span class=\"type\">RecyclerView</span>.<span class=\"type\">Recycler</span>, state: <span class=\"type\">RecyclerView</span>.<span class=\"type\">State</span>?)</span></span>: <span class=\"built_in\">Int</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 填充 view</span></span><br><span class=\"line\">    fillView(dy, recycler)</span><br><span class=\"line\">    <span class=\"comment\">// 移动 view</span></span><br><span class=\"line\">    offsetChildrenVertical(-dy)</span><br><span class=\"line\">    <span class=\"comment\">// 回收 View</span></span><br><span class=\"line\">    recycleInvisibleView(dy, recycler)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> dy</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 填充重新进入屏幕内的 ItemView</span></span><br><span class=\"line\"><span class=\"comment\"> *     getChildCount():childCount-&gt; 当前屏幕内RecyclerView展示的 ItemView 数量</span></span><br><span class=\"line\"><span class=\"comment\"> *     getItemCount():itemCount-&gt; 最大的 ItemView 数量，也就是 Adapter 传递的数据的数量</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">fillView</span><span class=\"params\">(dy: <span class=\"type\">Int</span>, recycler: <span class=\"type\">RecyclerView</span>.<span class=\"type\">Recycler</span>)</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">val</span> verticalSpace = orientationVerticalHelper.totalSpace</span><br><span class=\"line\">    <span class=\"keyword\">var</span> remainSpace = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> nextFillPosition = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"comment\">//垂直方向的偏移量</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> offsetTop = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> offsetLeft = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"comment\">// 从下往上滑，那么需要向底部添加数据</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (dy &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">val</span> anchorView = getChildAt(childCount - <span class=\"number\">1</span>) ?: <span class=\"keyword\">return</span></span><br><span class=\"line\">        <span class=\"keyword\">val</span> anchorPosition = getPosition(anchorView)</span><br><span class=\"line\">        <span class=\"keyword\">val</span> anchorBottom = getDecoratedBottom(anchorView)</span><br><span class=\"line\">        <span class=\"keyword\">val</span> anchorLeft = getDecoratedLeft(anchorView)</span><br><span class=\"line\">        remainSpace = verticalSpace - anchorBottom</span><br><span class=\"line\">        <span class=\"comment\">// 垂直可用的数据为&lt;0，意外着这时候屏幕底部的位置刚好在最底部的 ItemView 上，还需要向上滑动一点点...我们才能添加 View</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (remainSpace &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        nextFillPosition = anchorPosition + <span class=\"number\">1</span></span><br><span class=\"line\">        offsetTop = anchorBottom</span><br><span class=\"line\">        offsetLeft = anchorLeft</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (nextFillPosition &gt;= itemCount) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (dy &lt; <span class=\"number\">0</span>) &#123;  <span class=\"comment\">// 从上往下滑，那么需要向顶部添加数据</span></span><br><span class=\"line\">        <span class=\"comment\">//no-op 暂时不实现从上往下滑的底部数据填充</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (remainSpace &gt; <span class=\"number\">0</span> &amp;&amp; nextFillPosition &lt; itemCount) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 从适配器获取与给定位置关联的视图</span></span><br><span class=\"line\">        <span class=\"keyword\">val</span> itemView = recycler.getViewForPosition(nextFillPosition)</span><br><span class=\"line\">        <span class=\"comment\">// 将视图添加到 RecyclerView 中</span></span><br><span class=\"line\">        addView(itemView)</span><br><span class=\"line\">        <span class=\"comment\">// 测量并布局视图</span></span><br><span class=\"line\">        measureChildWithMargins(itemView, <span class=\"number\">0</span>, <span class=\"number\">0</span>)</span><br><span class=\"line\">        <span class=\"comment\">// 拿到宽高（包括ItemDecoration）</span></span><br><span class=\"line\">        <span class=\"keyword\">val</span> itemWidth = getDecoratedMeasuredWidth(itemView)</span><br><span class=\"line\">        <span class=\"keyword\">val</span> itemHeight = getDecoratedMeasuredHeight(itemView)</span><br><span class=\"line\">        <span class=\"comment\">// 对要添加的子 View 进行布局，相比onLayoutChildren 里面的实现添加了：offsetLeft（因为我们没有禁止掉 左右的滑动）</span></span><br><span class=\"line\">        <span class=\"comment\">// 试着把 offsetLeft 改成0，也就是最原始的样子，然后左右上下滑滑，你会有意外收获</span></span><br><span class=\"line\">        layoutDecorated(itemView, offsetLeft, offsetTop, itemWidth + offsetLeft, offsetTop + itemHeight)</span><br><span class=\"line\">        offsetTop += itemHeight</span><br><span class=\"line\">        nextFillPosition++</span><br><span class=\"line\">        <span class=\"comment\">// 可用空间减少</span></span><br><span class=\"line\">        remainSpace -= itemHeight</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>运行在手机上能看到这样的效果：向上滑动的时候，底部陆续有元素填充，但向下滑动的时候没有填充数据</p>\n<img src=\"https://cdn.julis.wang/blog/img/layoutmanager_gradually_3.gif?imageView2/2/w/300\">\n<h3 id=\"4-两个方向的View填充\"><a href=\"#4-两个方向的View填充\" class=\"headerlink\" title=\"4 两个方向的View填充\"></a>4 两个方向的View填充</h3><p>代码查看：<a href=\"https://github.com/VomPom/LayoutManagerGradually/tree/main/layoutmanager/src/main/java/com/julis/layoutmanager/series/LinearLayoutManager4.kt\">LinearLayoutManager4</a></p>\n<p>补齐从上往下滑之后添加的逻辑</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">fillView</span><span class=\"params\">(dy: <span class=\"type\">Int</span>, recycler: <span class=\"type\">RecyclerView</span>.<span class=\"type\">Recycler</span>)</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">val</span> verticalSpace = orientationVerticalHelper.totalSpace</span><br><span class=\"line\">    <span class=\"keyword\">var</span> remainSpace = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> nextFillPosition = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"comment\">//垂直方向的偏移量</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> offsetTop = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> offsetLeft = <span class=\"number\">0</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 从下往上滑，那么需要向底部添加数据</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (dy &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        ……</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (dy &lt; <span class=\"number\">0</span>) &#123;  <span class=\"comment\">// 从上往下滑，那么需要向顶部添加数据</span></span><br><span class=\"line\">        <span class=\"keyword\">val</span> anchorView = getChildAt(<span class=\"number\">0</span>) ?: <span class=\"keyword\">return</span></span><br><span class=\"line\">        <span class=\"keyword\">val</span> anchorPosition = getPosition(anchorView)</span><br><span class=\"line\">        <span class=\"keyword\">val</span> anchorTop = getDecoratedTop(anchorView)</span><br><span class=\"line\">        offsetLeft = getDecoratedLeft(anchorView)</span><br><span class=\"line\">        remainSpace = anchorTop</span><br><span class=\"line\">        <span class=\"comment\">// 垂直可用的数据为&lt;0，意外着这时候屏幕顶部的位置刚好在最底部的 ItemView 上，还需要向下滑动一点点...我们才能添加 View</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (anchorTop &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        nextFillPosition = anchorPosition - <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (nextFillPosition &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">val</span> itemHeight = getDecoratedMeasuredHeight(anchorView)</span><br><span class=\"line\">        <span class=\"comment\">// 新的布局的itemView 的顶部位置应该以 anchorTop - itemHeight 开始</span></span><br><span class=\"line\">        offsetTop = anchorTop - itemHeight</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (remainSpace &gt; <span class=\"number\">0</span> &amp;&amp;</span><br><span class=\"line\">        ((nextFillPosition &lt; itemCount) &amp;&amp; (nextFillPosition &gt;= <span class=\"number\">0</span>))</span><br><span class=\"line\">    ) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 从适配器获取与给定位置关联的视图</span></span><br><span class=\"line\">        <span class=\"keyword\">val</span> itemView = recycler.getViewForPosition(nextFillPosition)</span><br><span class=\"line\">        <span class=\"comment\">// 将视图添加到 RecyclerView 中k，从顶部添加的话，需要加到最前的位置</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (dy &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            addView(itemView)</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            addView(itemView, <span class=\"number\">0</span>)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        ……</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (dy &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            offsetTop += itemHeight</span><br><span class=\"line\">            nextFillPosition++</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            offsetTop -= itemHeight</span><br><span class=\"line\">            nextFillPosition--</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 可用空间减少</span></span><br><span class=\"line\">        remainSpace -= itemHeight</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>运行在手机上能看到这样的效果：向上或者滑动的时候，底部陆续都有元素填充</p>\n<img src=\"https://cdn.julis.wang/blog/img/layoutmanager_gradually_4.gif?imageView2/2/w/300\">\n<h3 id=\"5-对顶部和底部滑动边界处理\"><a href=\"#5-对顶部和底部滑动边界处理\" class=\"headerlink\" title=\"5 对顶部和底部滑动边界处理\"></a>5 对顶部和底部滑动边界处理</h3><p>代码查看：<a href=\"https://github.com/VomPom/LayoutManagerGradually/tree/main/layoutmanager/src/main/java/com/julis/layoutmanager/series/LinearLayoutManager5.kt\">LinearLayoutManager5</a></p>\n<p>对于前面的实现会发现会：不停地下滑或者上滑会留出来巨大的空白。这里对填充 View 的逻辑进行改造，需要进行边界检测。</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">scrollVerticallyBy</span><span class=\"params\">(dy: <span class=\"type\">Int</span>, recycler: <span class=\"type\">RecyclerView</span>.<span class=\"type\">Recycler</span>, state: <span class=\"type\">RecyclerView</span>.<span class=\"type\">State</span>?)</span></span>: <span class=\"built_in\">Int</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 填充 view</span></span><br><span class=\"line\">    <span class=\"keyword\">val</span> adjustedDy = fillView(dy, recycler)</span><br><span class=\"line\">    <span class=\"comment\">// 移动 view</span></span><br><span class=\"line\">    offsetChildrenVertical(-adjustedDy)</span><br><span class=\"line\">    <span class=\"comment\">// 回收 View</span></span><br><span class=\"line\">    recycleInvisibleView(adjustedDy, recycler)</span><br><span class=\"line\">    <span class=\"comment\">// 由于需要对边界进行限制，所以需要对原始的 dy 进行修正，这里不再直接返回 dy</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> adjustedDy</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>这里的整体注释我写在了代码里面，可以看图稍微理解一下，以向上滑动为例：假设这一次滑动的距离非常非常大(想象成10000像素)，如果直接滑动的话，我们有50个元素，每个元素高度100像素，最大高度也只有50x100=5000，那么滑动后一定会留下大量空区域。需要对当前传入的这 10000 像素做调整：只给到可滑动的最大距离，如果不能滑动了就返回0。</p>\n<img src=\"https://cdn.julis.wang/blog/img/5_scroll_limit.png\">\n<p>运行在手机上能看到这样的效果：向上或者滑动的时候，达到最大的位置时候是不能再滑动的。</p>\n<img src=\"https://cdn.julis.wang/blog/img/layoutmanager_gradually_5.gif?imageView2/2/w/300\">\n<h3 id=\"6-实现-scrollToPosition\"><a href=\"#6-实现-scrollToPosition\" class=\"headerlink\" title=\"6 实现 scrollToPosition\"></a>6 实现 scrollToPosition</h3><p>代码查看：<a href=\"https://github.com/VomPom/LayoutManagerGradually/tree/main/layoutmanager/src/main/java/com/julis/layoutmanager/series/LinearLayoutManager6.kt\">LinearLayoutManager6</a></p>\n<p>到这里这个 LinearLayoutManager 看着已经能正常运行了，但一般还需要支持<code>scrollToPosition</code> 和 <code>smoothScrollToPositio</code></p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">var</span> mPendingScrollPosition = RecyclerView.NO_POSITION</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">scrollToPosition</span><span class=\"params\">(position: <span class=\"type\">Int</span>)</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>.scrollToPosition(position)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (position &lt; <span class=\"number\">0</span> || position &gt;= itemCount) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    mPendingScrollPosition = position</span><br><span class=\"line\">    requestLayout()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onLayoutChildren</span><span class=\"params\">(recycler: <span class=\"type\">RecyclerView</span>.<span class=\"type\">Recycler</span>, state: <span class=\"type\">RecyclerView</span>.<span class=\"type\">State</span>)</span></span> &#123;</span><br><span class=\"line\">    ……</span><br><span class=\"line\">    <span class=\"keyword\">var</span> currentPosition = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mPendingScrollPosition != RecyclerView.NO_POSITION) &#123;</span><br><span class=\"line\">        currentPosition = mPendingScrollPosition</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (remainSpace &gt; <span class=\"number\">0</span> &amp;&amp; currentPosition &lt; state.itemCount) &#123;</span><br><span class=\"line\">      …… <span class=\"comment\">// 填充View 的逻辑</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>scrollToPosition</code> 的实现比较简单，如上代码所示：在 <code>scrollToPosition</code>  的时候记录一次目标position，再 requestLayout 一波，还记得之前有提到过：<code>onLayoutChildren</code> 会在 <code>requestLayout</code> 的时候调用一次，于是再将<code>onLayoutChildren</code>逻辑改写，不再从第0个元素开始，而是从目标位置进行布局。</p>\n<p>运行在手机上能看到这样的效果：点击 scrollTo30 将会滑动到 第30个位置。</p>\n<img src=\"https://cdn.julis.wang/blog/img/layoutmanager_gradually_6.gif?imageView2/2/w/300\">\n<h3 id=\"7-实现-smoothScrollToPosition\"><a href=\"#7-实现-smoothScrollToPosition\" class=\"headerlink\" title=\"7 实现 smoothScrollToPosition\"></a>7 实现 smoothScrollToPosition</h3><p>代码查看：<a href=\"https://github.com/VomPom/LayoutManagerGradually/tree/main/layoutmanager/src/main/java/com/julis/layoutmanager/series/LinearLayoutManager7.kt\">LinearLayoutManager7</a>  </p>\n<p>要实现自定义的 smoothScrollToPosition 动画效果，这一块如果要完全自己实现的话比较复杂，可以直接使用系统提供的 LinearSmoothScroller改造,也可以继承 RecyclerView.SmoothScroller 自定义，也可以完全不使用 SmoothScroller， 照着 SmoothScroller 的实现使用类似 ValueAnimator 自定义动画，添加动画 UpdateListener，在 onAnimationUpdate 的时候动态计算布局从而实现滑动动画,这里拿 LinearSmoothScroller 举例:</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">smoothScrollToPosition</span><span class=\"params\">(</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">    recyclerView: <span class=\"type\">RecyclerView</span>,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">    state: <span class=\"type\">RecyclerView</span>.<span class=\"type\">State</span>,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">    position: <span class=\"type\">Int</span></span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">)</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (position &gt;= itemCount || position &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">val</span> scroller: LinearSmoothScroller = <span class=\"keyword\">object</span> : LinearSmoothScroller(recyclerView.context) &#123;</span><br><span class=\"line\">        <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">         * 这个方法用于计算滚动到目标位置所需的滚动向量。滚动向量是一个二维向量，包含水平和垂直方向上的滚动距离</span></span><br><span class=\"line\"><span class=\"comment\">         *</span></span><br><span class=\"line\"><span class=\"comment\">         * <span class=\"doctag\">@param</span> targetPosition 滑动的目标位置</span></span><br><span class=\"line\"><span class=\"comment\">         * <span class=\"doctag\">@return</span>  返回一个 PointF 对象，表示滚动向量。</span></span><br><span class=\"line\"><span class=\"comment\">         *              PointF.x 表示水平方向上的滚动距离，</span></span><br><span class=\"line\"><span class=\"comment\">         *              PointF.y 表示垂直方向上的滚动距离</span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\">        <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">computeScrollVectorForPosition</span><span class=\"params\">(targetPosition: <span class=\"type\">Int</span>)</span></span>: PointF &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 查找到屏幕里显示的第 1 个元素与</span></span><br><span class=\"line\">            <span class=\"keyword\">val</span> firstChildPos = getPosition(getChildAt(<span class=\"number\">0</span>)!!)</span><br><span class=\"line\">            <span class=\"keyword\">val</span> direction = <span class=\"keyword\">if</span> (targetPosition &lt; firstChildPos) -<span class=\"number\">1</span> <span class=\"keyword\">else</span> <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"comment\">// x 左右滑动，由于我们只实现了垂直的滑动，所以 x方向为0即可</span></span><br><span class=\"line\">            <span class=\"comment\">// 整数代表正向移动，负数代表反向移动，这里的数值大小不重要，源码里面最终都会 normalize 归一化处理</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> PointF(<span class=\"number\">0f</span>, direction.toFloat())</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">         * 计算每像素速度</span></span><br><span class=\"line\"><span class=\"comment\">         *</span></span><br><span class=\"line\"><span class=\"comment\">         * <span class=\"doctag\">@param</span> displayMetrics</span></span><br><span class=\"line\"><span class=\"comment\">         * <span class=\"doctag\">@return</span> 返回每一像素的耗时，单位ms，假设返回值是1.0 代表着：1ms 内会滑动 1像素，1s会滑动1000像素</span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\">        <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">calculateSpeedPerPixel</span><span class=\"params\">(displayMetrics: <span class=\"type\">DisplayMetrics</span>?)</span></span>: <span class=\"built_in\">Float</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">super</span>.calculateSpeedPerPixel(displayMetrics)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">         * 滑动速度的插值（实现滑动速度随着滑动时间的变化）</span></span><br><span class=\"line\"><span class=\"comment\">         *</span></span><br><span class=\"line\"><span class=\"comment\">         * <span class=\"doctag\">@param</span> dx</span></span><br><span class=\"line\"><span class=\"comment\">         * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\">        <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">calculateTimeForDeceleration</span><span class=\"params\">(dx: <span class=\"type\">Int</span>)</span></span>: <span class=\"built_in\">Int</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">super</span>.calculateTimeForDeceleration(dx)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 很多方法可以使用，不再一一列举</span></span><br><span class=\"line\">        <span class=\"comment\">// ...</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    scroller.targetPosition = position</span><br><span class=\"line\">    <span class=\"comment\">// 执行默认动画的逻辑</span></span><br><span class=\"line\">    startSmoothScroll(scroller)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>运行在手机上能看到这样的效果：点击 smoothScrollTo30 将会有个动画效果滑动到第30个位置。</p>\n<img src=\"https://cdn.julis.wang/blog/img/layoutmanager_gradually_7.gif?imageView2/2/w/300\">\n<p>以上基本上一个自定义 LayoutManager 的雏形就已经完成了，虽然只实现了一个方向的滑动，但是其原理都是一样的，剩下的就是各种细节的打磨了，可以加各种自己想要的效果，比如：指定位置 放大一定的系数，或者更炫酷的滑动动画…</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>本文主要整理了自定义 LayoutManager 的必要元素，以及其核心方法 scrollHorizontallyBy/scrollVerticallyBy、onLayoutChildren 的作用与调用时机，接下对实现一个简单的 LinearLayoutManger 进行逻辑拆解，从最简单的不滑动回收和填充以及不含滑动边界检测，到最终一个具备基本功能的 LayoutManger</p>\n<p>源码：<a href=\"https://github.com/VomPom/LayoutManagerGradually\">https://github.com/VomPom/LayoutManagerGradually</a></p>\n<p>参考：</p>\n<p><a href=\"https://juejin.cn/post/6870770285247725581?searchId=202310181005138A6D82B1DEE9C47A9797#heading-23\">《看完这篇文章你还不会自定义LayoutManager，我吃X！》</a></p>\n<p><a href=\"https://github.com/MycroftWong/FlowLayoutManager/blob/master/LayoutManager%E5%88%86%E6%9E%90%E4%B8%8E%E5%AE%9E%E8%B7%B5.md\">《/LayoutManager分析与实践》</a></p>\n<p><a href=\"https://wiresareobsolete.com/2014/09/building-a-recyclerview-layoutmanager-part-1/\">Building a RecyclerView LayoutManager – Part 1</a></p>\n","cover":null,"images":["https://cdn.julis.wang/blog/img/layoutmanager_gradually_0.gif?imageView2/2/w/300","https://cdn.julis.wang/blog/img/layoutmanager_gradually_2.gif?imageView2/2/w/300","https://cdn.julis.wang/blog/img/layoutmanager_gradually_3.gif?imageView2/2/w/300","https://cdn.julis.wang/blog/img/layoutmanager_gradually_4.gif?imageView2/2/w/300","https://cdn.julis.wang/blog/img/5_scroll_limit.png","https://cdn.julis.wang/blog/img/layoutmanager_gradually_5.gif?imageView2/2/w/300","https://cdn.julis.wang/blog/img/layoutmanager_gradually_6.gif?imageView2/2/w/300","https://cdn.julis.wang/blog/img/layoutmanager_gradually_7.gif?imageView2/2/w/300"],"content":"<p>此前大部分涉及到 RecyclerView 页面的 LayoutManager基本上用系统提供的 LinearLayoutManager 、GridLayoutManager 就能解决，但在一些特殊场景上还是需要我们自定义  LayoutManager。之前基本上没有自己写过，在网上看各种源码各种文章，刚开始花了好多时间去理解整体流程，因为它们都给我一种非常非常复杂的感觉，包括相关的博客文章也是。经过一段时间摸索，也慢慢能理解为什么要那么复杂了，这的确不是特别容易入门。所以对整体的流程进行了一个拆解，尽量原子化一点，对自己学习的一个总结，也希望能帮助到一部分人能对  LayoutManager 入门。</p>\n<p>本文最终实现一个简单的 LinearLayoutManager（只支持 VERTICAL）方向，适合对 LayoutManager 整体流程的学习与理解，整体代码分为多个文件，每个文件都是对前一段代码的补充，方便理解，整体项目源码已提交 Github: <a href=\"https://github.com/VomPom/LayoutManagerGradually\">LayoutManagerGradually</a>，代码里面写了很多很多注释，如果不想浪费时间，可以直接看代码运行，跳过这篇文章，把每一个 LayoutManager 都跑一下体验结合代码看看。</p>\n<h2 id=\"自定义-LayoutManager-的必要元素\"><a href=\"#自定义-LayoutManager-的必要元素\" class=\"headerlink\" title=\"自定义 LayoutManager 的必要元素\"></a>自定义 LayoutManager 的必要元素</h2><ul>\n<li><p>继承 <code>RecyclerView.LayoutManager</code> 并实现 <code>generateDefaultLayoutParams()</code>方法</p>\n</li>\n<li><p>重写<code>onLayoutChildren</code> 第一次数据填充的时候数据添加</p>\n</li>\n<li><p>重写 <code>canScrollHorizontally()</code> 和<code>canScrollVertically()</code>方法设定支持滑动的方向</p>\n</li>\n<li><p>重写 <code>scrollHorizontallyBy()</code>和<code>scrollVerticallyBy()</code>方法，在滑动的时候对屏幕以外的 View 进行回收，以及填充即将滑动进入屏幕范围内的 View 进行填充</p>\n</li>\n<li><p>重写 <code>scrollToPosition()</code>和<code>smoothScrollToPosition()</code>方法支持</p>\n</li>\n</ul>\n<p>其中<code>onLayoutChildren</code> 和 <code>scrollHorizontallyBy/scrollVerticallyBy</code> 是最核心且最复杂的方法，这里稍微拎出来讲一下</p>\n<h3 id=\"onLayoutChildren\"><a href=\"#onLayoutChildren\" class=\"headerlink\" title=\"onLayoutChildren\"></a>onLayoutChildren</h3><p>这个方法类似于自定义 ViewGroup 的 onLayout() 方法，RecyclerView 的 LayoutManager.onLayoutChildren 在以下几个时机会被触发：</p>\n<ul>\n<li>当 <code>RecyclerView</code> 首次附加到窗口时</li>\n<li>当<code>Adapter</code>  的数据集发生变化</li>\n<li>当 <code>RecyclerView</code> 被 执行 <code>RequetLayout</code>的时候</li>\n<li>当 <code>LayoutManager</code> 发生变化时</li>\n</ul>\n<h3 id=\"scrollHorizontallyBy-scrollVerticallyBy\"><a href=\"#scrollHorizontallyBy-scrollVerticallyBy\" class=\"headerlink\" title=\"scrollHorizontallyBy/scrollVerticallyBy\"></a>scrollHorizontallyBy/scrollVerticallyBy</h3><p>方法的主要作用包括：</p>\n<ol>\n<li><p>更新 ItemView 的位置：根据传入的垂直滚动距离（dy 参数），更新子视图在屏幕上的位置。通常调用 <code>offsetChildrenVertical</code> 方法。</p>\n</li>\n<li><p>回收不可见的 ItemView：在滚动过程中，一些 ItemView 可能会离开屏幕，变得不可见。<code>scrollVerticallyBy</code> 方法需要负责回收这些子视图并将它们放入回收池，以便稍后复用。</p>\n</li>\n<li><p>添加新的 ItemView：在滚动过程中，新的 ItemView 可能需要显示在屏幕上。<code>scrollVerticallyBy</code> 方法需要从回收池中获取可复用的视图并将它们添加到屏幕上。这通常涉及到调用 <code>RecyclerView.Recycler</code> 的 <code>getViewForPosition</code> 方法。</p>\n</li>\n<li><p>返回实际滚动距离：由于 ItemView 的数量有限，滚动可能会受到限制。例如，当滚动到列表顶部或底部时，滚动可能会停止。在这种情况下，实际滚动的距离可能会小于传入的 <code>dy</code> 参数。<code>scrollVerticallyBy</code> 方法需要返回实际滚动的距离，以便 <code>RecyclerView</code> 可以正确地更新滚动条和触发滚动事件。</p>\n</li>\n</ol>\n<p>概念就简单讲这么多， talk is cheap show me the code，直接看代码理解会比较深刻</p>\n<h2 id=\"逐步实现\"><a href=\"#逐步实现\" class=\"headerlink\" title=\"逐步实现\"></a>逐步实现</h2><p>要实现一个可用的 LayoutManger 通常我们需要实现以下流程</p>\n<ul>\n<li>数据填充并且只需要填充屏幕范围内的 ItemView</li>\n<li>回收掉屏幕以外的 ItemView</li>\n<li>屏幕外 ItemView 再回到屏幕后，需要重新填充</li>\n<li>对滑动边界边界进行处理</li>\n<li>对 scrollToPosition 和 smoothScrollToPosition进行支持</li>\n</ul>\n<p>我们不用一上来就实现最终的效果，而是一步一步来，看看 LayoutManger 是怎么渐渐地变化，最终能跑起来的。</p>\n<h3 id=\"0-最简单的-LayoutManager\"><a href=\"#0-最简单的-LayoutManager\" class=\"headerlink\" title=\"0 最简单的 LayoutManager\"></a>0 最简单的 LayoutManager</h3><p>代码查看：<a href=\"https://github.com/VomPom/LayoutManagerGradually/tree/main/layoutmanager/src/main/java/com/julis/layoutmanager/series/MostSimpleLayoutManager.kt\">MostSimpleLayoutManager</a>，我们关注 <code>onLayoutChildren</code> 方法:</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onLayoutChildren</span><span class=\"params\">(recycler: <span class=\"type\">RecyclerView</span>.<span class=\"type\">Recycler</span>, state: <span class=\"type\">RecyclerView</span>.<span class=\"type\">State</span>?)</span></span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 垂直方向的偏移量</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> offsetTop = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"comment\">// 实际业务中最好不要这样一次性加载所有的数据，这里只是最简单地演示一下整体是如何工作的</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (itemIndex <span class=\"keyword\">in</span> <span class=\"number\">0</span> until itemCount) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 从适配器获取与给定位置关联的视图</span></span><br><span class=\"line\">        <span class=\"keyword\">val</span> itemView = recycler.getViewForPosition(itemIndex)</span><br><span class=\"line\">        <span class=\"comment\">// 将视图添加到 RecyclerView 中</span></span><br><span class=\"line\">        addView(itemView)</span><br><span class=\"line\">        <span class=\"comment\">// 测量并布局视图</span></span><br><span class=\"line\">        measureChildWithMargins(itemView, <span class=\"number\">0</span>, <span class=\"number\">0</span>)</span><br><span class=\"line\">        <span class=\"comment\">// 拿到宽高（包括ItemDecoration）</span></span><br><span class=\"line\">        <span class=\"keyword\">val</span> width = getDecoratedMeasuredWidth(itemView)</span><br><span class=\"line\">        <span class=\"keyword\">val</span> height = getDecoratedMeasuredHeight(itemView)</span><br><span class=\"line\">        <span class=\"comment\">// 对要添加的子 View 进行布局</span></span><br><span class=\"line\">        layoutDecorated(itemView, <span class=\"number\">0</span>, offsetTop, width, offsetTop + height)</span><br><span class=\"line\">        offsetTop += height</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面的代码主要演示了，如何利用<code>addView</code> <code>layoutDecorated</code>等方法，将 ItemView 添加到 RecyclerView 上。代码可见是 将所有的 ItemView（即使它在屏幕上不可见）一次性全部加载到了 RecyclerView上， 这里一般不这么做，只是这里这里只是最简单地演示一下整体是如何工作的。</p>\n<p>运行在手机上能看到这样的效果：Item数据已经被全部添加到界面上了，并且各个方向的滑动都支持。</p>\n<img src=\"https://cdn.julis.wang/blog/img/layoutmanager_gradually_0.gif?imageView2/2/w/300\">\n<h3 id=\"1-更合理的数据添加方式\"><a href=\"#1-更合理的数据添加方式\" class=\"headerlink\" title=\"1 更合理的数据添加方式\"></a>1 更合理的数据添加方式</h3><p>代码查看：<a href=\"https://github.com/VomPom/LayoutManagerGradually/tree/main/layoutmanager/src/main/java/com/julis/layoutmanager/series/LinearLayoutManager1\">LinearLayoutManager1.kt</a></p>\n<p>对最开始的代码进行优化，只在屏幕范围内的区域进行数据的添加，这样就不需要一次性将所有数据就添加上去，如果 Adapter 的 ItemCount 足够巨大，for all addView 的话，很容易就 OOM。</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onLayoutChildren</span><span class=\"params\">(recycler: <span class=\"type\">RecyclerView</span>.<span class=\"type\">Recycler</span>, state: <span class=\"type\">RecyclerView</span>.<span class=\"type\">State</span>)</span></span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 垂直方向上的的空间大小</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> remainSpace = height - paddingTop</span><br><span class=\"line\">    <span class=\"comment\">//垂直方向的偏移量</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> offsetTop = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> currentPosition = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (remainSpace &gt; <span class=\"number\">0</span> &amp;&amp; currentPosition &lt; state.itemCount) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 从适配器获取与给定位置关联的视图</span></span><br><span class=\"line\">        <span class=\"keyword\">val</span> itemView = recycler.getViewForPosition(currentPosition)</span><br><span class=\"line\">        <span class=\"comment\">// 将视图添加到 RecyclerView 中</span></span><br><span class=\"line\">        addView(itemView)</span><br><span class=\"line\">        <span class=\"comment\">// 测量并布局视图</span></span><br><span class=\"line\">        measureChildWithMargins(itemView, <span class=\"number\">0</span>, <span class=\"number\">0</span>)</span><br><span class=\"line\">        <span class=\"comment\">// 拿到宽高（包括ItemDecoration）</span></span><br><span class=\"line\">        <span class=\"keyword\">val</span> itemWidth = getDecoratedMeasuredWidth(itemView)</span><br><span class=\"line\">        <span class=\"keyword\">val</span> itemHeight = getDecoratedMeasuredHeight(itemView)</span><br><span class=\"line\">        <span class=\"comment\">// 对要添加的子 View 进行布局</span></span><br><span class=\"line\">        layoutDecorated(itemView, <span class=\"number\">0</span>, offsetTop, itemWidth, offsetTop + itemHeight)</span><br><span class=\"line\">        offsetTop += itemHeight</span><br><span class=\"line\">        currentPosition++</span><br><span class=\"line\">        <span class=\"comment\">// 可用空间减少</span></span><br><span class=\"line\">        remainSpace -= itemHeight</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-对屏幕外的View回收\"><a href=\"#2-对屏幕外的View回收\" class=\"headerlink\" title=\"2 对屏幕外的View回收\"></a>2 对屏幕外的View回收</h3><p>代码查看：<a href=\"https://github.com/VomPom/LayoutManagerGradually/tree/main/layoutmanager/src/main/java/com/julis/layoutmanager/series/LinearLayoutManager2.kt\">LinearLayoutManager2</a></p>\n<p>RecylerView 没有 recycler 怎么行呢？当 RecylerView 的 ItemView 滑出屏幕后我们需要对齐进行回收，实现的话需要在 <code>scrollVerticallyBy</code>中，比较复杂的逻辑就是怎么去判断：ItemView 在屏幕以外，最后利用：<code>removeAndRecycleView</code>方法进行回收</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">scrollVerticallyBy</span><span class=\"params\">(dy: <span class=\"type\">Int</span>, recycler: <span class=\"type\">RecyclerView</span>.<span class=\"type\">Recycler</span>, state: <span class=\"type\">RecyclerView</span>.<span class=\"type\">State</span>?)</span></span>: <span class=\"built_in\">Int</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 在这里处理上下的滚动逻辑，dy 表示滚动的距离</span></span><br><span class=\"line\">      <span class=\"comment\">// 平移所有子视图</span></span><br><span class=\"line\">      offsetChildrenVertical(-dy)</span><br><span class=\"line\">      <span class=\"comment\">// 如果实际滚动距离与 dy 相同，返回 dy；如果未滚动，返回 0</span></span><br><span class=\"line\">      recycleInvisibleView(dy, recycler)</span><br><span class=\"line\">      <span class=\"keyword\">return</span> dy</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 回收掉在界面上看不到的 ItemView</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> dy</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> recycler</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">recycleInvisibleView</span><span class=\"params\">(dy: <span class=\"type\">Int</span>, recycler: <span class=\"type\">RecyclerView</span>.<span class=\"type\">Recycler</span>)</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">val</span> totalSpace = orientationHelper.totalSpace</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 将要回收View的集合</span></span><br><span class=\"line\">    <span class=\"keyword\">val</span> recycleViews = hashSetOf&lt;View&gt;()</span><br><span class=\"line\">    <span class=\"comment\">// 从下往上滑</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (dy &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (i <span class=\"keyword\">in</span> <span class=\"number\">0</span> until childCount) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">val</span> child = getChildAt(i)!!</span><br><span class=\"line\">            <span class=\"comment\">// 从下往上滑从最上面的 item 开始计算</span></span><br><span class=\"line\">            <span class=\"keyword\">val</span> top = getDecoratedTop(child)</span><br><span class=\"line\">            <span class=\"comment\">// 判断最顶部的 item 是否已经完全不可见，如何可见，那说明底下的 item 也是可见</span></span><br><span class=\"line\">            <span class=\"keyword\">val</span> height = top - getDecoratedBottom(child)</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (height - top &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">break</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            recycleViews.add(child)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (dy &lt; <span class=\"number\">0</span>) &#123;   <span class=\"comment\">// 从上往下滑</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (i <span class=\"keyword\">in</span> childCount - <span class=\"number\">1</span> downTo <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">val</span> child = getChildAt(i)!!</span><br><span class=\"line\">            <span class=\"comment\">// 从上往下滑从最底部的 item 开始计算</span></span><br><span class=\"line\">            <span class=\"keyword\">val</span> bottom = getDecoratedBottom(child)</span><br><span class=\"line\">            <span class=\"comment\">// 判断最底部的 item 是否已经完全不可见，如何可见，那说明上面的 item 也是可见</span></span><br><span class=\"line\">            <span class=\"keyword\">val</span> height = bottom - getDecoratedTop(child)</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (bottom - totalSpace &lt; height) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">break</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            recycleViews.add(child)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 真正把 View 移除掉的逻辑</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (view <span class=\"keyword\">in</span> recycleViews) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// [removeAndRecycleView]</span></span><br><span class=\"line\">        <span class=\"comment\">// 用于从视图层次结构中删除某个视图，并将其资源回收，以便在需要时重新利用</span></span><br><span class=\"line\">        removeAndRecycleView(view, recycler)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    recycleViews.clear()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>运行在手机上能看到这样的效果：滑出屏幕外的ItemView 被回收掉了</p>\n<img src=\"https://cdn.julis.wang/blog/img/layoutmanager_gradually_2.gif?imageView2/2/w/300\">\n<h3 id=\"3-向上滑动的时View的填充\"><a href=\"#3-向上滑动的时View的填充\" class=\"headerlink\" title=\"3 向上滑动的时View的填充\"></a>3 向上滑动的时View的填充</h3><p>代码查看：<a href=\"https://github.com/VomPom/LayoutManagerGradually/tree/main/layoutmanager/src/main/java/com/julis/layoutmanager/series/LinearLayoutManager3.kt\">LinearLayoutManager3</a></p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">scrollVerticallyBy</span><span class=\"params\">(dy: <span class=\"type\">Int</span>, recycler: <span class=\"type\">RecyclerView</span>.<span class=\"type\">Recycler</span>, state: <span class=\"type\">RecyclerView</span>.<span class=\"type\">State</span>?)</span></span>: <span class=\"built_in\">Int</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 填充 view</span></span><br><span class=\"line\">    fillView(dy, recycler)</span><br><span class=\"line\">    <span class=\"comment\">// 移动 view</span></span><br><span class=\"line\">    offsetChildrenVertical(-dy)</span><br><span class=\"line\">    <span class=\"comment\">// 回收 View</span></span><br><span class=\"line\">    recycleInvisibleView(dy, recycler)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> dy</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 填充重新进入屏幕内的 ItemView</span></span><br><span class=\"line\"><span class=\"comment\"> *     getChildCount():childCount-&gt; 当前屏幕内RecyclerView展示的 ItemView 数量</span></span><br><span class=\"line\"><span class=\"comment\"> *     getItemCount():itemCount-&gt; 最大的 ItemView 数量，也就是 Adapter 传递的数据的数量</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">fillView</span><span class=\"params\">(dy: <span class=\"type\">Int</span>, recycler: <span class=\"type\">RecyclerView</span>.<span class=\"type\">Recycler</span>)</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">val</span> verticalSpace = orientationVerticalHelper.totalSpace</span><br><span class=\"line\">    <span class=\"keyword\">var</span> remainSpace = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> nextFillPosition = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"comment\">//垂直方向的偏移量</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> offsetTop = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> offsetLeft = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"comment\">// 从下往上滑，那么需要向底部添加数据</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (dy &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">val</span> anchorView = getChildAt(childCount - <span class=\"number\">1</span>) ?: <span class=\"keyword\">return</span></span><br><span class=\"line\">        <span class=\"keyword\">val</span> anchorPosition = getPosition(anchorView)</span><br><span class=\"line\">        <span class=\"keyword\">val</span> anchorBottom = getDecoratedBottom(anchorView)</span><br><span class=\"line\">        <span class=\"keyword\">val</span> anchorLeft = getDecoratedLeft(anchorView)</span><br><span class=\"line\">        remainSpace = verticalSpace - anchorBottom</span><br><span class=\"line\">        <span class=\"comment\">// 垂直可用的数据为&lt;0，意外着这时候屏幕底部的位置刚好在最底部的 ItemView 上，还需要向上滑动一点点...我们才能添加 View</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (remainSpace &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        nextFillPosition = anchorPosition + <span class=\"number\">1</span></span><br><span class=\"line\">        offsetTop = anchorBottom</span><br><span class=\"line\">        offsetLeft = anchorLeft</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (nextFillPosition &gt;= itemCount) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (dy &lt; <span class=\"number\">0</span>) &#123;  <span class=\"comment\">// 从上往下滑，那么需要向顶部添加数据</span></span><br><span class=\"line\">        <span class=\"comment\">//no-op 暂时不实现从上往下滑的底部数据填充</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (remainSpace &gt; <span class=\"number\">0</span> &amp;&amp; nextFillPosition &lt; itemCount) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 从适配器获取与给定位置关联的视图</span></span><br><span class=\"line\">        <span class=\"keyword\">val</span> itemView = recycler.getViewForPosition(nextFillPosition)</span><br><span class=\"line\">        <span class=\"comment\">// 将视图添加到 RecyclerView 中</span></span><br><span class=\"line\">        addView(itemView)</span><br><span class=\"line\">        <span class=\"comment\">// 测量并布局视图</span></span><br><span class=\"line\">        measureChildWithMargins(itemView, <span class=\"number\">0</span>, <span class=\"number\">0</span>)</span><br><span class=\"line\">        <span class=\"comment\">// 拿到宽高（包括ItemDecoration）</span></span><br><span class=\"line\">        <span class=\"keyword\">val</span> itemWidth = getDecoratedMeasuredWidth(itemView)</span><br><span class=\"line\">        <span class=\"keyword\">val</span> itemHeight = getDecoratedMeasuredHeight(itemView)</span><br><span class=\"line\">        <span class=\"comment\">// 对要添加的子 View 进行布局，相比onLayoutChildren 里面的实现添加了：offsetLeft（因为我们没有禁止掉 左右的滑动）</span></span><br><span class=\"line\">        <span class=\"comment\">// 试着把 offsetLeft 改成0，也就是最原始的样子，然后左右上下滑滑，你会有意外收获</span></span><br><span class=\"line\">        layoutDecorated(itemView, offsetLeft, offsetTop, itemWidth + offsetLeft, offsetTop + itemHeight)</span><br><span class=\"line\">        offsetTop += itemHeight</span><br><span class=\"line\">        nextFillPosition++</span><br><span class=\"line\">        <span class=\"comment\">// 可用空间减少</span></span><br><span class=\"line\">        remainSpace -= itemHeight</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>运行在手机上能看到这样的效果：向上滑动的时候，底部陆续有元素填充，但向下滑动的时候没有填充数据</p>\n<img src=\"https://cdn.julis.wang/blog/img/layoutmanager_gradually_3.gif?imageView2/2/w/300\">\n<h3 id=\"4-两个方向的View填充\"><a href=\"#4-两个方向的View填充\" class=\"headerlink\" title=\"4 两个方向的View填充\"></a>4 两个方向的View填充</h3><p>代码查看：<a href=\"https://github.com/VomPom/LayoutManagerGradually/tree/main/layoutmanager/src/main/java/com/julis/layoutmanager/series/LinearLayoutManager4.kt\">LinearLayoutManager4</a></p>\n<p>补齐从上往下滑之后添加的逻辑</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">fillView</span><span class=\"params\">(dy: <span class=\"type\">Int</span>, recycler: <span class=\"type\">RecyclerView</span>.<span class=\"type\">Recycler</span>)</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">val</span> verticalSpace = orientationVerticalHelper.totalSpace</span><br><span class=\"line\">    <span class=\"keyword\">var</span> remainSpace = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> nextFillPosition = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"comment\">//垂直方向的偏移量</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> offsetTop = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> offsetLeft = <span class=\"number\">0</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 从下往上滑，那么需要向底部添加数据</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (dy &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        ……</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (dy &lt; <span class=\"number\">0</span>) &#123;  <span class=\"comment\">// 从上往下滑，那么需要向顶部添加数据</span></span><br><span class=\"line\">        <span class=\"keyword\">val</span> anchorView = getChildAt(<span class=\"number\">0</span>) ?: <span class=\"keyword\">return</span></span><br><span class=\"line\">        <span class=\"keyword\">val</span> anchorPosition = getPosition(anchorView)</span><br><span class=\"line\">        <span class=\"keyword\">val</span> anchorTop = getDecoratedTop(anchorView)</span><br><span class=\"line\">        offsetLeft = getDecoratedLeft(anchorView)</span><br><span class=\"line\">        remainSpace = anchorTop</span><br><span class=\"line\">        <span class=\"comment\">// 垂直可用的数据为&lt;0，意外着这时候屏幕顶部的位置刚好在最底部的 ItemView 上，还需要向下滑动一点点...我们才能添加 View</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (anchorTop &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        nextFillPosition = anchorPosition - <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (nextFillPosition &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">val</span> itemHeight = getDecoratedMeasuredHeight(anchorView)</span><br><span class=\"line\">        <span class=\"comment\">// 新的布局的itemView 的顶部位置应该以 anchorTop - itemHeight 开始</span></span><br><span class=\"line\">        offsetTop = anchorTop - itemHeight</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (remainSpace &gt; <span class=\"number\">0</span> &amp;&amp;</span><br><span class=\"line\">        ((nextFillPosition &lt; itemCount) &amp;&amp; (nextFillPosition &gt;= <span class=\"number\">0</span>))</span><br><span class=\"line\">    ) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 从适配器获取与给定位置关联的视图</span></span><br><span class=\"line\">        <span class=\"keyword\">val</span> itemView = recycler.getViewForPosition(nextFillPosition)</span><br><span class=\"line\">        <span class=\"comment\">// 将视图添加到 RecyclerView 中k，从顶部添加的话，需要加到最前的位置</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (dy &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            addView(itemView)</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            addView(itemView, <span class=\"number\">0</span>)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        ……</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (dy &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            offsetTop += itemHeight</span><br><span class=\"line\">            nextFillPosition++</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            offsetTop -= itemHeight</span><br><span class=\"line\">            nextFillPosition--</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 可用空间减少</span></span><br><span class=\"line\">        remainSpace -= itemHeight</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>运行在手机上能看到这样的效果：向上或者滑动的时候，底部陆续都有元素填充</p>\n<img src=\"https://cdn.julis.wang/blog/img/layoutmanager_gradually_4.gif?imageView2/2/w/300\">\n<h3 id=\"5-对顶部和底部滑动边界处理\"><a href=\"#5-对顶部和底部滑动边界处理\" class=\"headerlink\" title=\"5 对顶部和底部滑动边界处理\"></a>5 对顶部和底部滑动边界处理</h3><p>代码查看：<a href=\"https://github.com/VomPom/LayoutManagerGradually/tree/main/layoutmanager/src/main/java/com/julis/layoutmanager/series/LinearLayoutManager5.kt\">LinearLayoutManager5</a></p>\n<p>对于前面的实现会发现会：不停地下滑或者上滑会留出来巨大的空白。这里对填充 View 的逻辑进行改造，需要进行边界检测。</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">scrollVerticallyBy</span><span class=\"params\">(dy: <span class=\"type\">Int</span>, recycler: <span class=\"type\">RecyclerView</span>.<span class=\"type\">Recycler</span>, state: <span class=\"type\">RecyclerView</span>.<span class=\"type\">State</span>?)</span></span>: <span class=\"built_in\">Int</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 填充 view</span></span><br><span class=\"line\">    <span class=\"keyword\">val</span> adjustedDy = fillView(dy, recycler)</span><br><span class=\"line\">    <span class=\"comment\">// 移动 view</span></span><br><span class=\"line\">    offsetChildrenVertical(-adjustedDy)</span><br><span class=\"line\">    <span class=\"comment\">// 回收 View</span></span><br><span class=\"line\">    recycleInvisibleView(adjustedDy, recycler)</span><br><span class=\"line\">    <span class=\"comment\">// 由于需要对边界进行限制，所以需要对原始的 dy 进行修正，这里不再直接返回 dy</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> adjustedDy</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>这里的整体注释我写在了代码里面，可以看图稍微理解一下，以向上滑动为例：假设这一次滑动的距离非常非常大(想象成10000像素)，如果直接滑动的话，我们有50个元素，每个元素高度100像素，最大高度也只有50x100=5000，那么滑动后一定会留下大量空区域。需要对当前传入的这 10000 像素做调整：只给到可滑动的最大距离，如果不能滑动了就返回0。</p>\n<img src=\"https://cdn.julis.wang/blog/img/5_scroll_limit.png\">\n<p>运行在手机上能看到这样的效果：向上或者滑动的时候，达到最大的位置时候是不能再滑动的。</p>\n<img src=\"https://cdn.julis.wang/blog/img/layoutmanager_gradually_5.gif?imageView2/2/w/300\">\n<h3 id=\"6-实现-scrollToPosition\"><a href=\"#6-实现-scrollToPosition\" class=\"headerlink\" title=\"6 实现 scrollToPosition\"></a>6 实现 scrollToPosition</h3><p>代码查看：<a href=\"https://github.com/VomPom/LayoutManagerGradually/tree/main/layoutmanager/src/main/java/com/julis/layoutmanager/series/LinearLayoutManager6.kt\">LinearLayoutManager6</a></p>\n<p>到这里这个 LinearLayoutManager 看着已经能正常运行了，但一般还需要支持<code>scrollToPosition</code> 和 <code>smoothScrollToPositio</code></p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">var</span> mPendingScrollPosition = RecyclerView.NO_POSITION</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">scrollToPosition</span><span class=\"params\">(position: <span class=\"type\">Int</span>)</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>.scrollToPosition(position)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (position &lt; <span class=\"number\">0</span> || position &gt;= itemCount) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    mPendingScrollPosition = position</span><br><span class=\"line\">    requestLayout()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onLayoutChildren</span><span class=\"params\">(recycler: <span class=\"type\">RecyclerView</span>.<span class=\"type\">Recycler</span>, state: <span class=\"type\">RecyclerView</span>.<span class=\"type\">State</span>)</span></span> &#123;</span><br><span class=\"line\">    ……</span><br><span class=\"line\">    <span class=\"keyword\">var</span> currentPosition = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mPendingScrollPosition != RecyclerView.NO_POSITION) &#123;</span><br><span class=\"line\">        currentPosition = mPendingScrollPosition</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (remainSpace &gt; <span class=\"number\">0</span> &amp;&amp; currentPosition &lt; state.itemCount) &#123;</span><br><span class=\"line\">      …… <span class=\"comment\">// 填充View 的逻辑</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>scrollToPosition</code> 的实现比较简单，如上代码所示：在 <code>scrollToPosition</code>  的时候记录一次目标position，再 requestLayout 一波，还记得之前有提到过：<code>onLayoutChildren</code> 会在 <code>requestLayout</code> 的时候调用一次，于是再将<code>onLayoutChildren</code>逻辑改写，不再从第0个元素开始，而是从目标位置进行布局。</p>\n<p>运行在手机上能看到这样的效果：点击 scrollTo30 将会滑动到 第30个位置。</p>\n<img src=\"https://cdn.julis.wang/blog/img/layoutmanager_gradually_6.gif?imageView2/2/w/300\">\n<h3 id=\"7-实现-smoothScrollToPosition\"><a href=\"#7-实现-smoothScrollToPosition\" class=\"headerlink\" title=\"7 实现 smoothScrollToPosition\"></a>7 实现 smoothScrollToPosition</h3><p>代码查看：<a href=\"https://github.com/VomPom/LayoutManagerGradually/tree/main/layoutmanager/src/main/java/com/julis/layoutmanager/series/LinearLayoutManager7.kt\">LinearLayoutManager7</a>  </p>\n<p>要实现自定义的 smoothScrollToPosition 动画效果，这一块如果要完全自己实现的话比较复杂，可以直接使用系统提供的 LinearSmoothScroller改造,也可以继承 RecyclerView.SmoothScroller 自定义，也可以完全不使用 SmoothScroller， 照着 SmoothScroller 的实现使用类似 ValueAnimator 自定义动画，添加动画 UpdateListener，在 onAnimationUpdate 的时候动态计算布局从而实现滑动动画,这里拿 LinearSmoothScroller 举例:</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">smoothScrollToPosition</span><span class=\"params\">(</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">    recyclerView: <span class=\"type\">RecyclerView</span>,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">    state: <span class=\"type\">RecyclerView</span>.<span class=\"type\">State</span>,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">    position: <span class=\"type\">Int</span></span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">)</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (position &gt;= itemCount || position &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">val</span> scroller: LinearSmoothScroller = <span class=\"keyword\">object</span> : LinearSmoothScroller(recyclerView.context) &#123;</span><br><span class=\"line\">        <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">         * 这个方法用于计算滚动到目标位置所需的滚动向量。滚动向量是一个二维向量，包含水平和垂直方向上的滚动距离</span></span><br><span class=\"line\"><span class=\"comment\">         *</span></span><br><span class=\"line\"><span class=\"comment\">         * <span class=\"doctag\">@param</span> targetPosition 滑动的目标位置</span></span><br><span class=\"line\"><span class=\"comment\">         * <span class=\"doctag\">@return</span>  返回一个 PointF 对象，表示滚动向量。</span></span><br><span class=\"line\"><span class=\"comment\">         *              PointF.x 表示水平方向上的滚动距离，</span></span><br><span class=\"line\"><span class=\"comment\">         *              PointF.y 表示垂直方向上的滚动距离</span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\">        <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">computeScrollVectorForPosition</span><span class=\"params\">(targetPosition: <span class=\"type\">Int</span>)</span></span>: PointF &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 查找到屏幕里显示的第 1 个元素与</span></span><br><span class=\"line\">            <span class=\"keyword\">val</span> firstChildPos = getPosition(getChildAt(<span class=\"number\">0</span>)!!)</span><br><span class=\"line\">            <span class=\"keyword\">val</span> direction = <span class=\"keyword\">if</span> (targetPosition &lt; firstChildPos) -<span class=\"number\">1</span> <span class=\"keyword\">else</span> <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"comment\">// x 左右滑动，由于我们只实现了垂直的滑动，所以 x方向为0即可</span></span><br><span class=\"line\">            <span class=\"comment\">// 整数代表正向移动，负数代表反向移动，这里的数值大小不重要，源码里面最终都会 normalize 归一化处理</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> PointF(<span class=\"number\">0f</span>, direction.toFloat())</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">         * 计算每像素速度</span></span><br><span class=\"line\"><span class=\"comment\">         *</span></span><br><span class=\"line\"><span class=\"comment\">         * <span class=\"doctag\">@param</span> displayMetrics</span></span><br><span class=\"line\"><span class=\"comment\">         * <span class=\"doctag\">@return</span> 返回每一像素的耗时，单位ms，假设返回值是1.0 代表着：1ms 内会滑动 1像素，1s会滑动1000像素</span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\">        <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">calculateSpeedPerPixel</span><span class=\"params\">(displayMetrics: <span class=\"type\">DisplayMetrics</span>?)</span></span>: <span class=\"built_in\">Float</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">super</span>.calculateSpeedPerPixel(displayMetrics)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">         * 滑动速度的插值（实现滑动速度随着滑动时间的变化）</span></span><br><span class=\"line\"><span class=\"comment\">         *</span></span><br><span class=\"line\"><span class=\"comment\">         * <span class=\"doctag\">@param</span> dx</span></span><br><span class=\"line\"><span class=\"comment\">         * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\">        <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">calculateTimeForDeceleration</span><span class=\"params\">(dx: <span class=\"type\">Int</span>)</span></span>: <span class=\"built_in\">Int</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">super</span>.calculateTimeForDeceleration(dx)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 很多方法可以使用，不再一一列举</span></span><br><span class=\"line\">        <span class=\"comment\">// ...</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    scroller.targetPosition = position</span><br><span class=\"line\">    <span class=\"comment\">// 执行默认动画的逻辑</span></span><br><span class=\"line\">    startSmoothScroll(scroller)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>运行在手机上能看到这样的效果：点击 smoothScrollTo30 将会有个动画效果滑动到第30个位置。</p>\n<img src=\"https://cdn.julis.wang/blog/img/layoutmanager_gradually_7.gif?imageView2/2/w/300\">\n<p>以上基本上一个自定义 LayoutManager 的雏形就已经完成了，虽然只实现了一个方向的滑动，但是其原理都是一样的，剩下的就是各种细节的打磨了，可以加各种自己想要的效果，比如：指定位置 放大一定的系数，或者更炫酷的滑动动画…</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>本文主要整理了自定义 LayoutManager 的必要元素，以及其核心方法 scrollHorizontallyBy/scrollVerticallyBy、onLayoutChildren 的作用与调用时机，接下对实现一个简单的 LinearLayoutManger 进行逻辑拆解，从最简单的不滑动回收和填充以及不含滑动边界检测，到最终一个具备基本功能的 LayoutManger</p>\n<p>源码：<a href=\"https://github.com/VomPom/LayoutManagerGradually\">https://github.com/VomPom/LayoutManagerGradually</a></p>\n<p>参考：</p>\n<p><a href=\"https://juejin.cn/post/6870770285247725581?searchId=202310181005138A6D82B1DEE9C47A9797#heading-23\">《看完这篇文章你还不会自定义LayoutManager，我吃X！》</a></p>\n<p><a href=\"https://github.com/MycroftWong/FlowLayoutManager/blob/master/LayoutManager%E5%88%86%E6%9E%90%E4%B8%8E%E5%AE%9E%E8%B7%B5.md\">《/LayoutManager分析与实践》</a></p>\n<p><a href=\"https://wiresareobsolete.com/2014/09/building-a-recyclerview-layoutmanager-part-1/\">Building a RecyclerView LayoutManager – Part 1</a></p>\n","categories":[],"tags":[{"name":"技术文章","slug":"technology","api":"api/tags/technology.json"}],"api":"api/posts/2023/10/31/自定义LayoutManager从0到1实践.json"},{"title":"记一次Android依赖库版本不兼容的问题处理过程","slug":"记一次Android依赖-wire-低版本与高版本不兼容的处理过程","date":"2022-03-31T02:47:00.000Z","updated":"2025-05-20T11:46:57.000Z","comments":true,"url":"2022/03/31/记一次Android依赖-wire-低版本与高版本不兼容的处理过程/","excerpt":"<p>此前我们项目组开发了相关 SDK 并集成到 App 工程中进行测试，发现业务App中的 <a href=\"https://github.com/square/wire\">wire</a> (一个与 protobuf 相关的库)，版本为1.5.1，而 SDK 中所依赖的版本为3.7.0，两者之间相互不兼容。如果要让业务升级到高版本的库的话，初步排查低版本中使用的某个类而高版本中已废除，单纯的就这一个类涉及100多个文件，工程量太大了，SDK中亦然。所以不能通过简单地更改版本号来解决版本冲突问题，最后经过一系列的尝试，终于解决了该问题。</p>\n<h2 id=\"分析和处理\"><a href=\"#分析和处理\" class=\"headerlink\" title=\"分析和处理\"></a>分析和处理</h2><p>最初集成 SDK 到 App 运行时发现报错：<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">java.lang.NoClassDefFoundError: Failed resolution of: Lcom/squareup/wire/ProtoEnum;</span><br></pre></td></tr></table></figure><br>检查代码发现 <code>ProtoEnum</code>位于wire 1.5.1中，打印依赖树发现App中的库被SDK所依赖的库给覆盖掉了，自动升级到新的版本，但新的版本又不存在该类。</p>\n<blockquote>\n<p><code>|    |    |    \\--- com.squareup.wire:wire-runtime:1.5.1 -&gt; 3.7.0</code></p>\n</blockquote>\n<p>以为只是简单的版本冲突的问题，尝试解冲突，我们知道处理Android版本冲突主要使用 <code>exclude``transitive</code> <code>force</code> gralde 处理依赖的关键字解决依赖冲突，但我无论使用什么操作整个项目中所打出来的Apk只存在一个版本：要么1.5.1要么3.7.0，对比两个库：<br><img src=\"https://cdn.julis.wang/blog/img/acb66f45a28a458fb4d00ae03cecafc1.png\"><br>发现高版本相比于低版本多了太多的类，以及一部分类进行了改名，至此我们可以得出一个结论：<strong>wire库高版本(3.7.1)与低版本(1.5.1)完全不兼容。</strong> 现在摆在我面前有两条路可以走：</p>\n<p>一、手动升级App中的低版本</p>\n<p>二、手动降级SDK中的高版本</p>\n<p>对于第一种，发现到App中大量文件使用 Wire 中的 <code>Message</code> 类，虽然两个版本都有<code>Message</code>类，但是两者“今非昔比”，涉及到太多的方法改动，而 <code>Message</code> 类在App有100+文件使用，如果一个个改过去，可能XXXXXXXX了。</p>\n<p>两个库之间有这么大的差异，甚至1.X版本不支持kotlin，而SDK中大量代码都是使用的 Kotlin，那么第二种降低SDK的高版本也自然变得不太现实。</p>\n<p>向大佬们请教，有被指点到：<strong>是否可以通过 ffat-aar+混淆的方式将 wire库跟SDK合并打包到一起？</strong></p>\n<p>！！大佬毕竟大佬，我的脑子瞬间有一种叮咚的感觉，其实这种方式也就是将SDK变向的重命名，将两个不同的版本库进行“共存”，现在要做的就是：<strong>将 SDK 中的高版本的库包名给改掉，以达到两个不同版本库之间的兼容。</strong></p>\n<p>说干就干，打好了库之后运行发现：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">java.lang.RuntimeException: Duplicate class a.a.a.a found in modules</span><br><span class=\"line\">etified-target-SDK-0.0.1.11-SNAPSHOT-runtime.jar</span><br><span class=\"line\">and ctlogin-0.4.23.04_lol_47-runtime.jar</span><br><span class=\"line\">(clogin-sso.clogin:0.4.23.04_lol_47)</span><br></pre></td></tr></table></figure>\n<img src=\"https://cdn.julis.wang/blog/img/41a8f2543baa48c5bf6b5a363cde6a9b.png\">\n<p>我当时内心就是这个表情,心想：难道<code>wtlogin</code> 大佬们也是想采用这种方式来避免一些库的兼容问题？这问题不大，因为混淆默认从a-z进行命名，只要给混淆再配一些参数就能避免掉这个问题，于是加上以下参数<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">-obfuscationdictionary obfucationdictionary.txt</span><br><span class=\"line\">-classobfuscationdictionary obfucationdictionary.txt</span><br><span class=\"line\">-packageobfuscationdictionary obfucationdictionary.txt</span><br></pre></td></tr></table></figure><br>当再次运行的时候，发现又报错了：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">java.lang.NoClassDefFoundError: Failed resolution of: Lcom/squareup/wire/ProtoAdapter;</span><br></pre></td></tr></table></figure>\n<p>？？？<code>ProtoAdapter</code> 是属于3.7.0高版本的类，不是已经被混淆了么？为什么还会报这个错？<br><img src=\"https://cdn.julis.wang/blog/img/32adc8ebefda4dfea050974c533fb4de.png\"><br>难道是使用混淆的方式是不行的？于是继续搜寻解决方案，了解到使用 <a href=\"https://github.com/shevek/jarjar\">jarjar.jar</a>可以对包重新命名打包，尝试了一下运行，依然报错<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">java.lang.NoClassDefFoundError: Failed resolution of: Lcom/squareup/wire/ProtoAdapter;</span><br></pre></td></tr></table></figure></p>\n<p>到底哪里还有 使用 <code>com/squareup/wire/ProtoAdapter</code>呢？使用<code>jd-gui</code>对重新打好的 jar 包的内容进行搜索.<br><img src=\"https://cdn.julis.wang/blog/img/14e36a6fa7da4feda26779f83b4e9b63.png\"><br>果然有搜到相应的内容，这是一个字符串，第一反应就是反射。我瞬间明白了，这是一串字符串并且是写死的，回到App中来，如下图所示：<code>wire</code>库的作用是将 .proto 文件生成咱们通常所说的 Model 类，下图的    <code>AudioEffect</code>就是通过 .proto 文件中定义好的属性生成的。<br><img src=\"https://cdn.julis.wang/blog/img/1512ded69e1248ac9e19ef5a4b995c63.png\"><br>那该怎么办呢？就一个依赖库版本冲突的问题，常规的方法就这些呀，难道真的要肝一波了么？<br><img src=\"https://cdn.julis.wang/blog/img/a5011fe0e772443f8e00fbbdd0b7f09f.png\"><br>到这里我们大概知道是怎么回事了，我们的目标很简单，就是改一个包名，但是包又在  <code>wire-gradle-plugin</code> 插件中，所以改wire的运行库当然是不行的……</p>\n<p>那还有一个终极办法：<strong>改源码</strong>。</p>\n<p>说干就干，直接拉 <a href=\"https://github.com/square/wire\">wire</a> 源码</p>\n<img src=\"https://cdn.julis.wang/blog/img/2dab42479a29453391b68a979008ae31.png\">\n<p>，主要关注以下几个目录：<br><code>wire-gradle-plugin</code>: wire-gradle 插件的主要源码<br><code>wire-compiler</code>: wire编译.proto相关的操作<br><code>wire-runtime</code>: wire运行时所需要的类<br>接下来要做的就是 <strong>右键+rename</strong>,重新编译打包，也……就1000多处改动</p>\n<img src=\"https://cdn.julis.wang/blog/img/daac3e4f19db4e5c9b8d1354ab65b7b7.png\">\n<p>打完包之后发现整个插件生成出来类的包还是包含<code>&quot;com.squareup.wire.ProtoAdapter&quot;</code>，我的目标是生成：<code>&quot;com.squareup.xxxx_.ProtoAdapter&quot;</code>，跟wire-plguin-gradle的源码，发现有这么一处：</p>\n<img src=\"https://cdn.julis.wang/blog/img/fed8bf2812474044b6344ec7d0acf290.png\">\n<p>它回在运行中重新从仓库中拉取<code>com.squareup.wire:wire-runtime:3.7.0</code>，于是需要对整个<code>wire-runtime</code>也重新打包，最终生成了一系列jar包如下所示：然后将其作为 plugin </p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"code\"><pre><span class=\"line\">classpath files(<span class=\"string\">&#x27;wire-profiles-3.7.0.jar&#x27;</span>)</span><br><span class=\"line\">classpath files(<span class=\"string\">&#x27;wire-compiler-3.7.0.jar&#x27;</span>)</span><br><span class=\"line\">classpath files(<span class=\"string\">&#x27;wire-kotlin-generator-3.7.0.jar&#x27;</span>)</span><br><span class=\"line\">classpath files(<span class=\"string\">&#x27;wire-gradle-plugin-3.7.0.jar&#x27;</span>)</span><br><span class=\"line\">classpath files(<span class=\"string\">&#x27;wire-schema-jvm-3.7.0.jar&#x27;</span>)</span><br></pre></td></tr></table></figure>\n<p>然后再将运行时所需要的类跟随SDK一起打包</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"code\"><pre><span class=\"line\">implementation files(<span class=\"string\">&#x27;src/libs/wire-runtime-jvm-3.7.0.jar&#x27;</span>)</span><br></pre></td></tr></table></figure>\n<p>重新编译打包，run、install 成功运行！</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>1、整个一系列操作，让我又学到了很多平时没有接触过的东西，比如：jarjar.jar，这个库对一些比较小的库存，或者说轻量级的库重新命名会比较快速的解决。本文中所述的 wire 库实在是太复杂，只能从源码层面进行操作了。还有就是在看 wire工程源码的时候又发现了一个<strong>shadowJar</strong>(利用gradle shadowjar构建包含依赖的JAR包)，之前一直用 ffat-aar打入的依赖，不知道这个插件怎么样，后面学习学习试试。</p>\n<p>2、在改整个源码之前，其实内心是比较抗拒的，因为一般改源码这种操作都是比较危险，或者更耗时，有可能就算改完了，也不一定能正常运行，一度想放弃，但实在是不想去改业务中那100+的文件，既然一条路走到黑，还是走下去吧，让我明白一定要坚持下去，不要放弃。</p>\n","cover":null,"images":["https://cdn.julis.wang/blog/img/acb66f45a28a458fb4d00ae03cecafc1.png","https://cdn.julis.wang/blog/img/41a8f2543baa48c5bf6b5a363cde6a9b.png","https://cdn.julis.wang/blog/img/32adc8ebefda4dfea050974c533fb4de.png","https://cdn.julis.wang/blog/img/14e36a6fa7da4feda26779f83b4e9b63.png","https://cdn.julis.wang/blog/img/2dab42479a29453391b68a979008ae31.png","https://cdn.julis.wang/blog/img/daac3e4f19db4e5c9b8d1354ab65b7b7.png","https://cdn.julis.wang/blog/img/fed8bf2812474044b6344ec7d0acf290.png"],"content":"<p>此前我们项目组开发了相关 SDK 并集成到 App 工程中进行测试，发现业务App中的 <a href=\"https://github.com/square/wire\">wire</a> (一个与 protobuf 相关的库)，版本为1.5.1，而 SDK 中所依赖的版本为3.7.0，两者之间相互不兼容。如果要让业务升级到高版本的库的话，初步排查低版本中使用的某个类而高版本中已废除，单纯的就这一个类涉及100多个文件，工程量太大了，SDK中亦然。所以不能通过简单地更改版本号来解决版本冲突问题，最后经过一系列的尝试，终于解决了该问题。</p>\n<h2 id=\"分析和处理\"><a href=\"#分析和处理\" class=\"headerlink\" title=\"分析和处理\"></a>分析和处理</h2><p>最初集成 SDK 到 App 运行时发现报错：<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">java.lang.NoClassDefFoundError: Failed resolution of: Lcom/squareup/wire/ProtoEnum;</span><br></pre></td></tr></table></figure><br>检查代码发现 <code>ProtoEnum</code>位于wire 1.5.1中，打印依赖树发现App中的库被SDK所依赖的库给覆盖掉了，自动升级到新的版本，但新的版本又不存在该类。</p>\n<blockquote>\n<p><code>|    |    |    \\--- com.squareup.wire:wire-runtime:1.5.1 -&gt; 3.7.0</code></p>\n</blockquote>\n<p>以为只是简单的版本冲突的问题，尝试解冲突，我们知道处理Android版本冲突主要使用 <code>exclude``transitive</code> <code>force</code> gralde 处理依赖的关键字解决依赖冲突，但我无论使用什么操作整个项目中所打出来的Apk只存在一个版本：要么1.5.1要么3.7.0，对比两个库：<br><img src=\"https://cdn.julis.wang/blog/img/acb66f45a28a458fb4d00ae03cecafc1.png\"><br>发现高版本相比于低版本多了太多的类，以及一部分类进行了改名，至此我们可以得出一个结论：<strong>wire库高版本(3.7.1)与低版本(1.5.1)完全不兼容。</strong> 现在摆在我面前有两条路可以走：</p>\n<p>一、手动升级App中的低版本</p>\n<p>二、手动降级SDK中的高版本</p>\n<p>对于第一种，发现到App中大量文件使用 Wire 中的 <code>Message</code> 类，虽然两个版本都有<code>Message</code>类，但是两者“今非昔比”，涉及到太多的方法改动，而 <code>Message</code> 类在App有100+文件使用，如果一个个改过去，可能XXXXXXXX了。</p>\n<p>两个库之间有这么大的差异，甚至1.X版本不支持kotlin，而SDK中大量代码都是使用的 Kotlin，那么第二种降低SDK的高版本也自然变得不太现实。</p>\n<p>向大佬们请教，有被指点到：<strong>是否可以通过 ffat-aar+混淆的方式将 wire库跟SDK合并打包到一起？</strong></p>\n<p>！！大佬毕竟大佬，我的脑子瞬间有一种叮咚的感觉，其实这种方式也就是将SDK变向的重命名，将两个不同的版本库进行“共存”，现在要做的就是：<strong>将 SDK 中的高版本的库包名给改掉，以达到两个不同版本库之间的兼容。</strong></p>\n<p>说干就干，打好了库之后运行发现：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">java.lang.RuntimeException: Duplicate class a.a.a.a found in modules</span><br><span class=\"line\">etified-target-SDK-0.0.1.11-SNAPSHOT-runtime.jar</span><br><span class=\"line\">and ctlogin-0.4.23.04_lol_47-runtime.jar</span><br><span class=\"line\">(clogin-sso.clogin:0.4.23.04_lol_47)</span><br></pre></td></tr></table></figure>\n<img src=\"https://cdn.julis.wang/blog/img/41a8f2543baa48c5bf6b5a363cde6a9b.png\">\n<p>我当时内心就是这个表情,心想：难道<code>wtlogin</code> 大佬们也是想采用这种方式来避免一些库的兼容问题？这问题不大，因为混淆默认从a-z进行命名，只要给混淆再配一些参数就能避免掉这个问题，于是加上以下参数<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">-obfuscationdictionary obfucationdictionary.txt</span><br><span class=\"line\">-classobfuscationdictionary obfucationdictionary.txt</span><br><span class=\"line\">-packageobfuscationdictionary obfucationdictionary.txt</span><br></pre></td></tr></table></figure><br>当再次运行的时候，发现又报错了：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">java.lang.NoClassDefFoundError: Failed resolution of: Lcom/squareup/wire/ProtoAdapter;</span><br></pre></td></tr></table></figure>\n<p>？？？<code>ProtoAdapter</code> 是属于3.7.0高版本的类，不是已经被混淆了么？为什么还会报这个错？<br><img src=\"https://cdn.julis.wang/blog/img/32adc8ebefda4dfea050974c533fb4de.png\"><br>难道是使用混淆的方式是不行的？于是继续搜寻解决方案，了解到使用 <a href=\"https://github.com/shevek/jarjar\">jarjar.jar</a>可以对包重新命名打包，尝试了一下运行，依然报错<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">java.lang.NoClassDefFoundError: Failed resolution of: Lcom/squareup/wire/ProtoAdapter;</span><br></pre></td></tr></table></figure></p>\n<p>到底哪里还有 使用 <code>com/squareup/wire/ProtoAdapter</code>呢？使用<code>jd-gui</code>对重新打好的 jar 包的内容进行搜索.<br><img src=\"https://cdn.julis.wang/blog/img/14e36a6fa7da4feda26779f83b4e9b63.png\"><br>果然有搜到相应的内容，这是一个字符串，第一反应就是反射。我瞬间明白了，这是一串字符串并且是写死的，回到App中来，如下图所示：<code>wire</code>库的作用是将 .proto 文件生成咱们通常所说的 Model 类，下图的    <code>AudioEffect</code>就是通过 .proto 文件中定义好的属性生成的。<br><img src=\"https://cdn.julis.wang/blog/img/1512ded69e1248ac9e19ef5a4b995c63.png\"><br>那该怎么办呢？就一个依赖库版本冲突的问题，常规的方法就这些呀，难道真的要肝一波了么？<br><img src=\"https://cdn.julis.wang/blog/img/a5011fe0e772443f8e00fbbdd0b7f09f.png\"><br>到这里我们大概知道是怎么回事了，我们的目标很简单，就是改一个包名，但是包又在  <code>wire-gradle-plugin</code> 插件中，所以改wire的运行库当然是不行的……</p>\n<p>那还有一个终极办法：<strong>改源码</strong>。</p>\n<p>说干就干，直接拉 <a href=\"https://github.com/square/wire\">wire</a> 源码</p>\n<img src=\"https://cdn.julis.wang/blog/img/2dab42479a29453391b68a979008ae31.png\">\n<p>，主要关注以下几个目录：<br><code>wire-gradle-plugin</code>: wire-gradle 插件的主要源码<br><code>wire-compiler</code>: wire编译.proto相关的操作<br><code>wire-runtime</code>: wire运行时所需要的类<br>接下来要做的就是 <strong>右键+rename</strong>,重新编译打包，也……就1000多处改动</p>\n<img src=\"https://cdn.julis.wang/blog/img/daac3e4f19db4e5c9b8d1354ab65b7b7.png\">\n<p>打完包之后发现整个插件生成出来类的包还是包含<code>&quot;com.squareup.wire.ProtoAdapter&quot;</code>，我的目标是生成：<code>&quot;com.squareup.xxxx_.ProtoAdapter&quot;</code>，跟wire-plguin-gradle的源码，发现有这么一处：</p>\n<img src=\"https://cdn.julis.wang/blog/img/fed8bf2812474044b6344ec7d0acf290.png\">\n<p>它回在运行中重新从仓库中拉取<code>com.squareup.wire:wire-runtime:3.7.0</code>，于是需要对整个<code>wire-runtime</code>也重新打包，最终生成了一系列jar包如下所示：然后将其作为 plugin </p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"code\"><pre><span class=\"line\">classpath files(<span class=\"string\">&#x27;wire-profiles-3.7.0.jar&#x27;</span>)</span><br><span class=\"line\">classpath files(<span class=\"string\">&#x27;wire-compiler-3.7.0.jar&#x27;</span>)</span><br><span class=\"line\">classpath files(<span class=\"string\">&#x27;wire-kotlin-generator-3.7.0.jar&#x27;</span>)</span><br><span class=\"line\">classpath files(<span class=\"string\">&#x27;wire-gradle-plugin-3.7.0.jar&#x27;</span>)</span><br><span class=\"line\">classpath files(<span class=\"string\">&#x27;wire-schema-jvm-3.7.0.jar&#x27;</span>)</span><br></pre></td></tr></table></figure>\n<p>然后再将运行时所需要的类跟随SDK一起打包</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"code\"><pre><span class=\"line\">implementation files(<span class=\"string\">&#x27;src/libs/wire-runtime-jvm-3.7.0.jar&#x27;</span>)</span><br></pre></td></tr></table></figure>\n<p>重新编译打包，run、install 成功运行！</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>1、整个一系列操作，让我又学到了很多平时没有接触过的东西，比如：jarjar.jar，这个库对一些比较小的库存，或者说轻量级的库重新命名会比较快速的解决。本文中所述的 wire 库实在是太复杂，只能从源码层面进行操作了。还有就是在看 wire工程源码的时候又发现了一个<strong>shadowJar</strong>(利用gradle shadowjar构建包含依赖的JAR包)，之前一直用 ffat-aar打入的依赖，不知道这个插件怎么样，后面学习学习试试。</p>\n<p>2、在改整个源码之前，其实内心是比较抗拒的，因为一般改源码这种操作都是比较危险，或者更耗时，有可能就算改完了，也不一定能正常运行，一度想放弃，但实在是不想去改业务中那100+的文件，既然一条路走到黑，还是走下去吧，让我明白一定要坚持下去，不要放弃。</p>\n","categories":[],"tags":[{"name":"技术文章","slug":"technology","api":"api/tags/technology.json"}],"api":"api/posts/2022/03/31/记一次Android依赖-wire-低版本与高版本不兼容的处理过程.json"},{"title":"哈夫曼树与编码","slug":"数据结构-哈夫曼Huffman树","date":"2020-03-24T01:38:00.000Z","updated":"2025-05-20T11:46:57.000Z","comments":true,"url":"2020/03/24/数据结构-哈夫曼Huffman树/","excerpt":"<p><strong>哈夫曼树定义：</strong></p>\n<blockquote>\n<p>给定N个权值作为N个叶子结点，构造一棵二叉树，若该树的带权路径长度达到最小，称这样的二叉树为最优二叉树，也称为哈夫曼树(Huffman<br>Tree)。哈夫曼树是带权路径长度最短的树，权值较大的结点离根较近。</p>\n</blockquote>\n<p>例：在数据通信中，需要将传送的文字转换成二进制的字符串，用0，1码的不同排列来表示字符。例如，需传送的报文为“AFTER DATA EAR ARE ART AREA”，这里用到的字符集为“A，E，R，T，F，D”，各字母出现的次数为{8，4，5，3，1，1}。现要求为这些字母设计编码。要区别6个字母，最简单的二进制编码方式是等长编码，固定采用3位二进制，可分别用000、001、010、011、100、101对“A，E，R，T，F，D”进行编码发送，当对方接收报文时再按照三位一分进行译码。显然编码的长度取决报文中不同字符的个数。</p>\n<h2 id=\"哈夫曼树创建方法\"><a href=\"#哈夫曼树创建方法\" class=\"headerlink\" title=\"哈夫曼树创建方法\"></a>哈夫曼树创建方法</h2><p>摘自：<a href=\"https://blog.csdn.net/FX677588/article/details/70767446\">《详细图解哈夫曼Huffman编码树》</a></p>\n<h3 id=\"2-1-初始队列\"><a href=\"#2-1-初始队列\" class=\"headerlink\" title=\"2.1 初始队列\"></a>2.1 初始队列</h3><p>　　我们按出现频率高低将其放入一个优先级队列中，从左到右依次为频率逐渐增加。<br>　<br><img src=\"https://cdn.julis.wang/blog/img/20200319094704131.png\"><br>　　下面我们需要将这个队列转换成哈夫曼二叉树，哈夫曼二叉树是一颗带权重的二叉树，权重是由队列中每个字符出现的次数所决定的。并且哈夫曼二叉树始终保证权重越大的字符出现在越高的地方。</p>\n<h3 id=\"2-2-第一步合并\"><a href=\"#2-2-第一步合并\" class=\"headerlink\" title=\"2.2 第一步合并\"></a>2.2 第一步合并</h3><p>　　首先我们从左到右进行合并，依次构建二叉树。第一步取前两个字符u和r来构造初始二叉树，第一个字符作为左节点，第二个元素作为右节点，然后两个元素相加作为新空元素，并且两者权重相加作为新元素的权重。<br>　　<br><img src=\"https://cdn.julis.wang/blog/img/20200319094810712.png\"></p>\n<p>　　同理，新元素可以和字符i再合并，如下：</p>\n<img src=\"https://cdn.julis.wang/blog/img/20200319094824181.png\">\n<h3 id=\"2-3-重新调整队列\"><a href=\"#2-3-重新调整队列\" class=\"headerlink\" title=\"2.3 重新调整队列\"></a>2.3 重新调整队列</h3><p>　　上图新元素权重相加后结果是变大了，需要对权重进行重新排序。<br>　　<br><img src=\"https://cdn.julis.wang/blog/img/20200319094841561.png\"><br>　　然后再依次从左到右合并，每合并一次则进行一次队列重新排序调整。如下：<br><img src=\"https://cdn.julis.wang/blog/img/2020031909485354.png\"><br>　　经过多步操作之后，得到以下的哈夫曼二叉树结构，也就是一个带有权重的二叉树：</p>\n<img src=\"https://cdn.julis.wang/blog/img/20200319094902609.png\">\n<h3 id=\"2-4-哈夫曼编码\"><a href=\"#2-4-哈夫曼编码\" class=\"headerlink\" title=\"2.4 哈夫曼编码\"></a>2.4 哈夫曼编码</h3><p>　　有了上面带权重的二叉树之后，我们就可以进行编码了。我们把二叉树分支中左边的支路编码为0，右边分支表示为1，如下图：\n　</p>\n<img src=\"https://cdn.julis.wang/blog/img/20200319094918382.png\">\n<p>　　这样依次遍历这颗二叉树就可以获取得到所有字符的编码了。例如：‘ ’的编码为10，‘l’的编码为00，‘u’的编码为11100等等。经过这个编码设置之后我们可以发现，出现频率越高的字符越会在上层，这样它的编码越短；出现频率越低的字符越会在下层，编码越短。经过这样的设计，最终整个文本存储空间才会最大化的缩减。<br>　　最终我们可以得到下面这张编码表：</p>\n<img src=\"https://cdn.julis.wang/blog/img/20200319094927897.png\">\n<h3 id=\"2-5-字符串编码\"><a href=\"#2-5-字符串编码\" class=\"headerlink\" title=\"2.5 字符串编码\"></a>2.5 字符串编码</h3><p>　　有了上面的编码表之后，”we will we will r u”这句重新进行编码就可以得到很大的压缩，编码表示为：01 110 10 01 1111 00 00 10 01 110 10 01 1111 00 00 10 11101 10 11100。这样最终我们只需50位内存，比原ASCII码表示节约了2/3空间，效果还是很理想的。当然现实中不是简单这样表示的，还需要考虑很多问题。</p>\n<h2 id=\"三、哈夫曼编码的压缩与解压\"><a href=\"#三、哈夫曼编码的压缩与解压\" class=\"headerlink\" title=\"三、哈夫曼编码的压缩与解压\"></a>三、哈夫曼编码的压缩与解压</h2><p>1、使用IO流逐字节读取文档。用一个数组（0~255,下标表示ASCII码）来保存不同字符出现的次数<br>2、建一个节点类，保存节点对象的信息。将数组每一位表示的字符和出现频次存入创建的节点，把所有节点存入一个链表。<br>3、根据节点存储的频次值，对链表进行从小到大排序<br>4、从链表中取出并删除最小的两个节点，创建一个他们的父节点，父节点不存字符，值为那两个节点的和，把那两个节点分别作为其左子节点和右子节点，最后把这个父节点存入链表。再次排序，取出并删除最小的两个节点，生成父节点，再存入…以此类推，最终生成一棵哈夫曼树。<br>5、对哈夫曼树进行遍历，使得叶子结点获得相应编码，同时把字符和它对应的哈夫曼编码存入HashMap</p>\n<h2 id=\"四、疑问\"><a href=\"#四、疑问\" class=\"headerlink\" title=\"四、疑问\"></a>四、疑问</h2><h3 id=\"4-1对于字符频率相等的情况\"><a href=\"#4-1对于字符频率相等的情况\" class=\"headerlink\" title=\"4.1对于字符频率相等的情况\"></a>4.1对于字符频率相等的情况</h3><p>我们在构建哈夫曼树的时候在想，如果我们的字符出现的频率相等的情况，那哈夫曼树岂不是很糟？<br>我们假设原来字符串长度为N，那么对于普通的ASCII编码得到的长度为8N，如果利用哈夫曼编码，对于每一个字符，最大的长度不会超过8层树因为ASCII编码总共只有2^8个字符，也就是说最极端的情况：一个文件中所有字符串中出现256个字符且重复次数是一样的，但这仍然对原来的文本有进行过压缩（毕竟出现次数相等的话，构造的哈夫曼树在8层之前还是有数据的，那些数据的位数&lt;8）最终的编码数一定是会&lt;8N</p>\n<h3 id=\"4-2解码冲突问题\"><a href=\"#4-2解码冲突问题\" class=\"headerlink\" title=\"4.2解码冲突问题\"></a>4.2解码冲突问题</h3><p>我们在解压遍历哈夫曼的时候，最终的编码不会冲突么？举例：上面我们得到得最终的编码是<br>01 110 10 01 1111 00 00 10 01 110 10 01 1111 00 00 10 11101 10 11100但是在实际的压缩中我们不会有分隔符最终的情况将会是：<br>0111010 0111110000100111010011111000010111011011100<br>于是我们怎么知道：前面的01是一个编码，为什那么0111就是一个编码呢？也就是说01是0111的前缀 。其实我们从这张图就能看出来：对于上述的字符串一定不会存在一个叫0111的编码，因为“w”字母代表的01已经没有子节点。其实中也可以看出一些区域是空着的比如：11、111、111、1110 没有数据，其实这都是满足了哈夫曼树的 <strong>左起字串不冲突原则</strong></p>\n<img src=\"https://cdn.julis.wang/blog/img/20200319094918382.png\">\n","cover":null,"images":["https://cdn.julis.wang/blog/img/20200319094704131.png","https://cdn.julis.wang/blog/img/20200319094810712.png","https://cdn.julis.wang/blog/img/20200319094824181.png","https://cdn.julis.wang/blog/img/20200319094841561.png","https://cdn.julis.wang/blog/img/20200319094902609.png","https://cdn.julis.wang/blog/img/20200319094918382.png","https://cdn.julis.wang/blog/img/20200319094927897.png"],"content":"<p><strong>哈夫曼树定义：</strong></p>\n<blockquote>\n<p>给定N个权值作为N个叶子结点，构造一棵二叉树，若该树的带权路径长度达到最小，称这样的二叉树为最优二叉树，也称为哈夫曼树(Huffman<br>Tree)。哈夫曼树是带权路径长度最短的树，权值较大的结点离根较近。</p>\n</blockquote>\n<p>例：在数据通信中，需要将传送的文字转换成二进制的字符串，用0，1码的不同排列来表示字符。例如，需传送的报文为“AFTER DATA EAR ARE ART AREA”，这里用到的字符集为“A，E，R，T，F，D”，各字母出现的次数为{8，4，5，3，1，1}。现要求为这些字母设计编码。要区别6个字母，最简单的二进制编码方式是等长编码，固定采用3位二进制，可分别用000、001、010、011、100、101对“A，E，R，T，F，D”进行编码发送，当对方接收报文时再按照三位一分进行译码。显然编码的长度取决报文中不同字符的个数。</p>\n<h2 id=\"哈夫曼树创建方法\"><a href=\"#哈夫曼树创建方法\" class=\"headerlink\" title=\"哈夫曼树创建方法\"></a>哈夫曼树创建方法</h2><p>摘自：<a href=\"https://blog.csdn.net/FX677588/article/details/70767446\">《详细图解哈夫曼Huffman编码树》</a></p>\n<h3 id=\"2-1-初始队列\"><a href=\"#2-1-初始队列\" class=\"headerlink\" title=\"2.1 初始队列\"></a>2.1 初始队列</h3><p>　　我们按出现频率高低将其放入一个优先级队列中，从左到右依次为频率逐渐增加。<br>　<br><img src=\"https://cdn.julis.wang/blog/img/20200319094704131.png\"><br>　　下面我们需要将这个队列转换成哈夫曼二叉树，哈夫曼二叉树是一颗带权重的二叉树，权重是由队列中每个字符出现的次数所决定的。并且哈夫曼二叉树始终保证权重越大的字符出现在越高的地方。</p>\n<h3 id=\"2-2-第一步合并\"><a href=\"#2-2-第一步合并\" class=\"headerlink\" title=\"2.2 第一步合并\"></a>2.2 第一步合并</h3><p>　　首先我们从左到右进行合并，依次构建二叉树。第一步取前两个字符u和r来构造初始二叉树，第一个字符作为左节点，第二个元素作为右节点，然后两个元素相加作为新空元素，并且两者权重相加作为新元素的权重。<br>　　<br><img src=\"https://cdn.julis.wang/blog/img/20200319094810712.png\"></p>\n<p>　　同理，新元素可以和字符i再合并，如下：</p>\n<img src=\"https://cdn.julis.wang/blog/img/20200319094824181.png\">\n<h3 id=\"2-3-重新调整队列\"><a href=\"#2-3-重新调整队列\" class=\"headerlink\" title=\"2.3 重新调整队列\"></a>2.3 重新调整队列</h3><p>　　上图新元素权重相加后结果是变大了，需要对权重进行重新排序。<br>　　<br><img src=\"https://cdn.julis.wang/blog/img/20200319094841561.png\"><br>　　然后再依次从左到右合并，每合并一次则进行一次队列重新排序调整。如下：<br><img src=\"https://cdn.julis.wang/blog/img/2020031909485354.png\"><br>　　经过多步操作之后，得到以下的哈夫曼二叉树结构，也就是一个带有权重的二叉树：</p>\n<img src=\"https://cdn.julis.wang/blog/img/20200319094902609.png\">\n<h3 id=\"2-4-哈夫曼编码\"><a href=\"#2-4-哈夫曼编码\" class=\"headerlink\" title=\"2.4 哈夫曼编码\"></a>2.4 哈夫曼编码</h3><p>　　有了上面带权重的二叉树之后，我们就可以进行编码了。我们把二叉树分支中左边的支路编码为0，右边分支表示为1，如下图：\n　</p>\n<img src=\"https://cdn.julis.wang/blog/img/20200319094918382.png\">\n<p>　　这样依次遍历这颗二叉树就可以获取得到所有字符的编码了。例如：‘ ’的编码为10，‘l’的编码为00，‘u’的编码为11100等等。经过这个编码设置之后我们可以发现，出现频率越高的字符越会在上层，这样它的编码越短；出现频率越低的字符越会在下层，编码越短。经过这样的设计，最终整个文本存储空间才会最大化的缩减。<br>　　最终我们可以得到下面这张编码表：</p>\n<img src=\"https://cdn.julis.wang/blog/img/20200319094927897.png\">\n<h3 id=\"2-5-字符串编码\"><a href=\"#2-5-字符串编码\" class=\"headerlink\" title=\"2.5 字符串编码\"></a>2.5 字符串编码</h3><p>　　有了上面的编码表之后，”we will we will r u”这句重新进行编码就可以得到很大的压缩，编码表示为：01 110 10 01 1111 00 00 10 01 110 10 01 1111 00 00 10 11101 10 11100。这样最终我们只需50位内存，比原ASCII码表示节约了2/3空间，效果还是很理想的。当然现实中不是简单这样表示的，还需要考虑很多问题。</p>\n<h2 id=\"三、哈夫曼编码的压缩与解压\"><a href=\"#三、哈夫曼编码的压缩与解压\" class=\"headerlink\" title=\"三、哈夫曼编码的压缩与解压\"></a>三、哈夫曼编码的压缩与解压</h2><p>1、使用IO流逐字节读取文档。用一个数组（0~255,下标表示ASCII码）来保存不同字符出现的次数<br>2、建一个节点类，保存节点对象的信息。将数组每一位表示的字符和出现频次存入创建的节点，把所有节点存入一个链表。<br>3、根据节点存储的频次值，对链表进行从小到大排序<br>4、从链表中取出并删除最小的两个节点，创建一个他们的父节点，父节点不存字符，值为那两个节点的和，把那两个节点分别作为其左子节点和右子节点，最后把这个父节点存入链表。再次排序，取出并删除最小的两个节点，生成父节点，再存入…以此类推，最终生成一棵哈夫曼树。<br>5、对哈夫曼树进行遍历，使得叶子结点获得相应编码，同时把字符和它对应的哈夫曼编码存入HashMap</p>\n<h2 id=\"四、疑问\"><a href=\"#四、疑问\" class=\"headerlink\" title=\"四、疑问\"></a>四、疑问</h2><h3 id=\"4-1对于字符频率相等的情况\"><a href=\"#4-1对于字符频率相等的情况\" class=\"headerlink\" title=\"4.1对于字符频率相等的情况\"></a>4.1对于字符频率相等的情况</h3><p>我们在构建哈夫曼树的时候在想，如果我们的字符出现的频率相等的情况，那哈夫曼树岂不是很糟？<br>我们假设原来字符串长度为N，那么对于普通的ASCII编码得到的长度为8N，如果利用哈夫曼编码，对于每一个字符，最大的长度不会超过8层树因为ASCII编码总共只有2^8个字符，也就是说最极端的情况：一个文件中所有字符串中出现256个字符且重复次数是一样的，但这仍然对原来的文本有进行过压缩（毕竟出现次数相等的话，构造的哈夫曼树在8层之前还是有数据的，那些数据的位数&lt;8）最终的编码数一定是会&lt;8N</p>\n<h3 id=\"4-2解码冲突问题\"><a href=\"#4-2解码冲突问题\" class=\"headerlink\" title=\"4.2解码冲突问题\"></a>4.2解码冲突问题</h3><p>我们在解压遍历哈夫曼的时候，最终的编码不会冲突么？举例：上面我们得到得最终的编码是<br>01 110 10 01 1111 00 00 10 01 110 10 01 1111 00 00 10 11101 10 11100但是在实际的压缩中我们不会有分隔符最终的情况将会是：<br>0111010 0111110000100111010011111000010111011011100<br>于是我们怎么知道：前面的01是一个编码，为什那么0111就是一个编码呢？也就是说01是0111的前缀 。其实我们从这张图就能看出来：对于上述的字符串一定不会存在一个叫0111的编码，因为“w”字母代表的01已经没有子节点。其实中也可以看出一些区域是空着的比如：11、111、111、1110 没有数据，其实这都是满足了哈夫曼树的 <strong>左起字串不冲突原则</strong></p>\n<img src=\"https://cdn.julis.wang/blog/img/20200319094918382.png\">\n","categories":[{"name":"算法研究","slug":"算法研究","api":"api/categories/算法研究.json"}],"tags":[{"name":"技术文章","slug":"technology","api":"api/tags/technology.json"}],"api":"api/posts/2020/03/24/数据结构-哈夫曼Huffman树.json"}],"info":{"type":"tag","name":"技术文章","slug":"technology"}},"api":"api/tags/technology/page.1.json"}