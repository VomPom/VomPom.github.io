{"data":{"index":1,"total":1,"posts":[{"title":"Android屏幕刷新机制","slug":"Android屏幕刷新机制","date":"2025-02-24T02:49:00.000Z","updated":"2025-05-20T11:46:57.000Z","comments":true,"url":"2025/02/24/Android屏幕刷新机制/","excerpt":"<p>最近在研究 Android 屏幕显示与渲染相关的内容，平时经常看到这些类 <code>ViewRootImpl</code>、<code>Choreographer</code>、<code>Surface</code> 、 <code>SurfaceFlinger</code>等，知道它们都用于屏幕渲染相关，但对它们细节了解较少，相关的文章也比较多，不需要自己完全重新再编写一份，于是对相关内容进行一个总结,<br>主要来源：<a href=\"https://juejin.cn/post/6863756420380196877\">《Android屏幕刷新机制—VSyncChoreographer 全面理解》</a>，这篇博客是我认为是目前看到过最好的一篇，文章由浅入深比较好理解。不过文章里面图片链接资源已经失效，为以后复习相关知识点，在此将其整理删除冗余内容，并对图片资源进行更新。</p>\n<h2 id=\"一、背景和疑问\"><a href=\"#一、背景和疑问\" class=\"headerlink\" title=\"一、背景和疑问\"></a><strong>一、背景和疑问</strong></h2><p>在Android中，当我们谈到 <strong>布局优化</strong>、<strong>卡顿优化</strong> 时，通常都知道 需要减少布局层级、减少主线程耗时操作，这样可以减少<strong>丢帧</strong>。如果丢帧比较严重，那么界面可能会有明显的卡顿感。我们知道 通常手机刷新是每秒60次，即每隔16.6ms刷新一次。 问题来了：</p>\n<ol>\n<li><strong>丢帧</strong>(掉帧) ，是说 这一帧延迟显示 还是丢弃不再显示 ？</li>\n<li>布局层级较多&#x2F;主线程耗时 是如何造成 丢帧的呢？</li>\n<li>16.6ms刷新一次 是啥意思？是每16.6ms都走一次 measure&#x2F;layout&#x2F;draw ？</li>\n<li>measure&#x2F;layout&#x2F;draw 走完，界面就立刻刷新了吗?</li>\n<li>如果界面没动静止了，还会刷新吗？</li>\n<li>可能你知道<strong>VSYNC</strong>，这个具体指啥？在屏幕刷新中如何工作的？</li>\n<li>可能你还听过屏幕刷新使用 <strong>双缓存</strong>、<strong>三缓存</strong>，这又是啥意思呢？</li>\n<li>可能你还听过神秘的<strong>Choreographer</strong>，这又是干啥的？</li>\n</ol>\n<h2 id=\"二、显示系统基础知识\"><a href=\"#二、显示系统基础知识\" class=\"headerlink\" title=\"二、显示系统基础知识\"></a><strong>二、显示系统基础知识</strong></h2><p>在一个典型的显示系统中，一般包括CPU、GPU、Display三个部分， CPU负责计算帧数据，把计算好的数据交给GPU，GPU会对图形数据进行渲染，渲染好后放到buffer(图像缓冲区)里存起来，然后Display（屏幕或显示器）负责把buffer里的数据呈现到屏幕上。如下图：</p>\n<img src=\"https://cdn.julis.wang/blog/img/0nq54q5jtq.jpeg\">\n\n<p>单缓存，从缓存映射到屏幕。</p>\n<h3 id=\"2-1-基础概念\"><a href=\"#2-1-基础概念\" class=\"headerlink\" title=\"2.1 基础概念\"></a><strong>2.1 基础概念</strong></h3><ul>\n<li><strong>屏幕刷新频率</strong> 一秒内屏幕刷新的次数（一秒内显示了多少帧的图像），单位 Hz（赫兹），如常见的 60 Hz。<strong>刷新频率取决于硬件的固定参数</strong>（不会变的）。</li>\n<li><strong>逐行扫描</strong> 显示器并不是一次性将画面显示到屏幕上，而是从左到右边，从上到下逐行扫描，顺序显示整屏的一个个像素点，不过这一过程快到人眼无法察觉到变化。以 60 Hz 刷新率的屏幕为例，这一过程即 1000 &#x2F; 60 ≈ 16ms。</li>\n<li><strong>帧率</strong> （Frame Rate） 表示 <strong>GPU 在一秒内绘制操作的帧数</strong>，单位 fps。例如在电影界采用 24 帧的速度足够使画面运行的非常流畅。而 Android 系统则采用更加流程的 60 fps，即每秒钟GPU最多绘制 60 帧画面。帧率是动态变化的，例如当画面静止时，GPU 是没有绘制操作的，屏幕刷新的还是buffer中的数据，即GPU最后操作的帧数据。</li>\n<li><strong>画面撕裂</strong>（tearing） 一个屏幕内的数据来自2个不同的帧，画面会出现撕裂感，如下图</li>\n</ul>\n<img src=\"https://cdn.julis.wang/blog/img/xxm0lvzypa.jpeg\">\n\n<p>明显看出画面错位的位置，这就是画面撕裂。</p>\n<h3 id=\"2-2-双缓存\"><a href=\"#2-2-双缓存\" class=\"headerlink\" title=\"2.2 双缓存\"></a><strong>2.2 双缓存</strong></h3><h5 id=\"2-2-1-画面撕裂-原因\"><a href=\"#2-2-1-画面撕裂-原因\" class=\"headerlink\" title=\"2.2.1  画面撕裂 原因\"></a><strong>2.2.1  画面撕裂 原因</strong></h5><p>屏幕刷新频是固定的，比如每16.6ms从buffer取数据显示完一帧，理想情况下帧率和刷新频率保持一致，即每绘制完成一帧，显示器显示一帧。但是CPU&#x2F;GPU写数据是不可控的，所以会出现buffer里有些数据根本没显示出来就被重写了，即buffer里的数据可能是来自不同的帧的， 当屏幕刷新时，此时它并不知道buffer的状态，因此从buffer抓取的帧并不是完整的一帧画面，即出现画面撕裂。</p>\n<p>简单说就是Display在显示的过程中，buffer内数据被CPU&#x2F;GPU修改，导致画面撕裂。</p>\n<h5 id=\"2-2-2-双缓存\"><a href=\"#2-2-2-双缓存\" class=\"headerlink\" title=\"2.2.2  双缓存\"></a><strong>2.2.2  双缓存</strong></h5><p>那咋解决画面撕裂呢？答案是使用 双缓存。</p>\n<p>由于图像绘制和屏幕读取 使用的是同个buffer，所以屏幕刷新时可能读取到的是不完整的一帧画面。</p>\n<p><strong>双缓存</strong>，让绘制和显示器拥有各自的buffer：GPU 始终将完成的一帧图像数据写入到 <strong>Back Buffer</strong>，而显示器使用 <strong>Frame Buffer</strong>，当屏幕刷新时，Frame Buffer 并不会发生变化，当Back buffer准备就绪后，它们才进行交换。如下图：</p>\n<img src=\"https://cdn.julis.wang/blog/img/q2vukxpyvq.jpeg\">\n\n<p>双缓存，CPU&#x2F;GPU写数据到Back Buffer，显示器从Frame Buffer取数据</p>\n<h5 id=\"2-2-3-VSync\"><a href=\"#2-2-3-VSync\" class=\"headerlink\" title=\"2.2.3  VSync\"></a><strong>2.2.3  VSync</strong></h5><p>问题又来了：什么时候进行两个buffer的交换呢？</p>\n<p>假如是 Back buffer准备完成一帧数据以后就进行，那么如果此时屏幕还没有完整显示上一帧内容的话，肯定是会出问题的。看来只能是等到屏幕处理完一帧数据后，才可以执行这一操作了。</p>\n<p>当扫描完一个屏幕后，设备需要重新回到第一行以进入下一次的循环，此时有一段时间空隙，称为VerticalBlanking Interval(VBI)。那，这个时间点就是我们进行缓冲区交换的最佳时间。因为此时屏幕没有在刷新，也就避免了交换过程中出现 screen tearing的状况。</p>\n<p><strong>VSync</strong>(垂直同步)是VerticalSynchronization的简写，它利用VBI时期出现的vertical sync pulse（垂直同步脉冲）来保证双缓冲在最佳时间点才进行交换。另外，交换是指各自的内存地址，可以认为该操作是瞬间完成。</p>\n<p>所以说V-sync这个概念并不是Google首创的，它在早年的PC机领域就已经出现了。</p>\n<h2 id=\"三、Android屏幕刷新机制\"><a href=\"#三、Android屏幕刷新机制\" class=\"headerlink\" title=\"三、Android屏幕刷新机制\"></a><strong>三、Android屏幕刷新机制</strong></h2><h3 id=\"3-1-Android4-1之前的问题\"><a href=\"#3-1-Android4-1之前的问题\" class=\"headerlink\" title=\"3.1 Android4.1之前的问题\"></a><strong>3.1 Android4.1之前的问题</strong></h3><p>具体到Android中，在Android4.1之前，屏幕刷新也遵循 上面介绍的 双缓存+VSync 机制。如下图：</p>\n<img src=\"https://cdn.julis.wang/blog/img/1ax0mz0nu1.jpeg\">\n\n<p>双缓存会在VSync脉冲时交换，但CPU&#x2F;GPU绘制是随机的</p>\n<p>以时间的顺序来看下将会发生的过程：</p>\n<ol>\n<li>Display显示第0帧数据，此时CPU和<a href=\"https://cloud.tencent.com/solution/render?from_column=20065&from=20065\">GPU渲染</a>第1帧画面，且在Display显示下一帧前完成</li>\n<li>因为渲染及时，Display在第0帧显示完成后，也就是第1个VSync后，缓存进行交换，然后正常显示第1帧</li>\n<li>接着第2帧开始处理，是直到第2个VSync快来前才开始处理的。</li>\n<li>第2个VSync来时，由于第2帧数据还没有准备就绪，缓存没有交换，显示的还是第1帧。这种情况被Android开发组命名为“Jank”，即发生了<strong>丢帧</strong>。</li>\n<li>当第2帧数据准备完成后，它并不会马上被显示，而是要等待下一个VSync 进行缓存交换再显示。</li>\n</ol>\n<p>所以总的来说，就是屏幕平白无故地多显示了一次第1帧。</p>\n<p>原因是 第2帧的CPU&#x2F;GPU计算 没能在VSync信号到来前完成 。</p>\n<p>我们知道，<strong>双缓存的交换 是在Vsyn到来时进行，交换后屏幕会取Frame buffer内的新数据，而实际 此时的Back buffer 就可以供GPU准备下一帧数据了。如果 Vsyn到来时  CPU&#x2F;GPU就开始操作的话，是有完整的16.6ms的，这样应该会基本避免jank的出现了</strong>（除非CPU&#x2F;GPU计算超过了16.6ms）。  那如何让 CPU&#x2F;GPU计算在 Vsyn到来时进行呢？</p>\n<h3 id=\"3-2-drawing-with-VSync\"><a href=\"#3-2-drawing-with-VSync\" class=\"headerlink\" title=\"3.2 drawing with VSync\"></a><strong>3.2 drawing with VSync</strong></h3><p>为了优化显示性能，Google在Android 4.1系统中对Android Display系统进行了重构，实现了Project Butter（黄油工程）：系统在收到VSync pulse后，将马上开始下一帧的渲染。即<strong>一旦收到VSync通知（16ms触发一次），CPU和GPU 才立刻开始计算然后把数据写入buffer</strong>。如下图：</p>\n<img src=\"https://cdn.julis.wang/blog/img/uuqflxwo53.jpeg\">\n\n<p>VSync脉冲到来：双缓存交换，且开始CPU&#x2F;GPU绘制 CPU&#x2F;GPU根据VSYNC信号同步处理数据，可以让CPU&#x2F;GPU有完整的16ms时间来处理数据，减少了jank。</p>\n<p>一句话总结，<strong>VSync同步使得CPU&#x2F;GPU充分利用了16.6ms时间，减少jank。</strong></p>\n<p>问题又来了，如果界面比较复杂，CPU&#x2F;GPU的处理时间较长 超过了16.6ms呢？如下图：</p>\n<img src=\"https://cdn.julis.wang/blog/img/po2jd1h7u8.jpeg\">\n\n<p>虽然CPU&#x2F;GPU开始在VSync，但超过16.6ms</p>\n<ol>\n<li>在第二个时间段内，但却因 GPU 还在处理 B 帧，缓存没能交换，导致 A 帧被重复显示。</li>\n<li>而B完成后，又因为缺乏VSync pulse信号，它只能等待下一个signal的来临。于是在这一过程中，有一大段时间是被浪费的。</li>\n<li>当下一个VSync出现时，CPU&#x2F;GPU马上执行操作（A帧），且缓存交换，相应的显示屏对应的就是B。这时看起来就是正常的。只不过由于执行时间仍然超过16ms，导致下一次应该执行的缓冲区交换又被推迟了——如此循环反复，便出现了越来越多的“Jank”。</li>\n</ol>\n<p><strong>为什么 CPU 不能在第二个 16ms 处理绘制工作呢？</strong></p>\n<p>原因是只有两个 buffer，Back buffer正在被GPU用来处理B帧的数据， Frame buffer的内容用于Display的显示，这样两个buffer都被占用，CPU 则无法准备下一帧的数据。那么，如果再提供一个buffer，CPU、GPU 和显示设备都能使用各自的buffer工作，互不影响。</p>\n<h3 id=\"3-3-三缓存\"><a href=\"#3-3-三缓存\" class=\"headerlink\" title=\"3.3 三缓存\"></a><strong>3.3 三缓存</strong></h3><p><strong>三缓存</strong>就是在双缓冲机制基础上增加了一个 Graphic Buffer 缓冲区，这样可以最大限度的利用空闲时间，带来的坏处是多使用的一个 Graphic Buffer 所占用的内存。</p>\n<img src=\"https://cdn.julis.wang/blog/img/ldq7oda57p.jpeg\">\n\n<p>三缓存</p>\n<ol>\n<li>第一个Jank，是不可避免的。但是在第二个 16ms 时间段，CPU&#x2F;GPU 使用 <strong>第三个 Buffer</strong> 完成C帧的计算，虽然还是会多显示一次 A 帧，但后续显示就比较顺畅了，有效避免 Jank 的进一步加剧。</li>\n<li>注意在第3段中，A帧的计算已完成，但是在第4个vsync来的时候才显示，如果是双缓冲，那在第三个vynsc就可以显示了。</li>\n</ol>\n<p><strong>三缓冲有效利用了等待vysnc的时间，减少了jank，但是带来了延迟。</strong> 所以，是不是 Buffer 越多越好呢？这个是否定的，Buffer 正常还是两个，当出现 Jank 后三个足以。</p>\n<p>以上就是Android屏幕刷新的原理了。</p>\n<h2 id=\"四、Choreographer\"><a href=\"#四、Choreographer\" class=\"headerlink\" title=\"四、Choreographer\"></a><strong>四、Choreographer</strong></h2><h3 id=\"4-1-概述\"><a href=\"#4-1-概述\" class=\"headerlink\" title=\"4.1 概述\"></a><strong>4.1 概述</strong></h3><p>上面讲到，Google在Android 4.1系统中对Android Display系统进行了优化：在收到VSync pulse后，将马上开始下一帧的渲染。即<strong>一旦收到VSync通知，CPU和GPU就立刻开始计算然后把数据写入buffer</strong>。本节就来讲 “drawing with VSync” 的实现——<strong>Choreographer</strong>。</p>\n<ul>\n<li>Choreographer，意为 舞蹈编导、编舞者。在这里就是指 对CPU&#x2F;GPU绘制的指导—— 收到VSync信号 才开始绘制，保证绘制拥有完整的16.6ms，避免绘制的随机性。</li>\n<li>Choreographer，是一个Java类，包路径android.view.Choreographer。类注释是“协调动画、输入和绘图的计时”。</li>\n<li>通常 应用层不会直接使用Choreographer，而是使用更高级的API，例如动画和View绘制相关的ValueAnimator.start()、View.invalidate()等。</li>\n<li>业界一般通过Choreographer来监控应用的帧率。</li>\n</ul>\n<h3 id=\"4-2-源码分析\"><a href=\"#4-2-源码分析\" class=\"headerlink\" title=\"4.2 源码分析\"></a><strong>4.2 源码分析</strong></h3><p>学习 Choreographer 可以帮助理解 每帧运行的原理，也可加深对 Handler机制、View绘制流程的理解，这样再去做UI优化、卡顿优化，思路会更清晰。</p>\n<p>好了，下面开始源码分析了~</p>\n<h5 id=\"4-2-1-入口-和-实例创建\"><a href=\"#4-2-1-入口-和-实例创建\" class=\"headerlink\" title=\"4.2.1 入口 和 实例创建\"></a><strong>4.2.1 入口 和 实例创建</strong></h5><p>在<a href=\"https://juejin.cn/post/7076274407416528909\">《Window和WindowManager》</a>、<a href=\"https://blog.csdn.net/allen_xu_2012_new/article/details/131167564\">《Activity的启动过程详解》</a>中介绍过，Activity启动 走完onResume方法后，会进行<strong>window的添加</strong>。window添加过程会 调用ViewRootImpl的setView()方法，setView()方法会调用requestLayout()方法来请求绘制布局，requestLayout()方法内部又会走到scheduleTraversals()方法，最后会走到performTraversals()方法，接着到了我们熟知的测量、布局、绘制三大流程了。</p>\n<p>另外，查看源码发现，当我们使用 ValueAnimator.start()、View.invalidate()时，最后也是走到ViewRootImpl的scheduleTraversals()方法。（View.invalidate()内部会循环获取ViewParent直到ViewRootImpl的invalidateChildInParent()方法，然后走到scheduleTraversals()，可自行查看源码 ）</p>\n<p>即 <strong>所有UI的变化都是走到ViewRootImpl的scheduleTraversals()方法。</strong></p>\n<p>那么问题又来了，scheduleTraversals() 到 performTraversals() 中间 经历了什么呢？是立刻执行吗？答案很显然是否定的，根据我们上面的介绍，在VSync信号到来时才会执行绘制，即performTraversals()方法。下面来瞅瞅这是如何实现的：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//ViewRootImpl.java</span></span><br><span class=\"line\"><span class=\"keyword\">void</span> <span class=\"title function_\">scheduleTraversals</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!mTraversalScheduled) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//此字段保证同时间多次更改只会刷新一次，例如TextView连续两次setText(),也只会走一次绘制流程</span></span><br><span class=\"line\">        mTraversalScheduled = <span class=\"literal\">true</span>;</span><br><span class=\"line\">        <span class=\"comment\">//添加同步屏障，屏蔽同步消息，保证VSync到来立即执行绘制</span></span><br><span class=\"line\">        mTraversalBarrier = mHandler.getLooper().getQueue().postSyncBarrier();</span><br><span class=\"line\">        <span class=\"comment\">//mTraversalRunnable是TraversalRunnable实例，最终走到run()，也即doTraversal();</span></span><br><span class=\"line\">        mChoreographer.postCallback(</span><br><span class=\"line\">                Choreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, <span class=\"literal\">null</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!mUnbufferedInputDispatch) &#123;</span><br><span class=\"line\">            scheduleConsumeBatchedInput();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        notifyRendererOfFramePending();</span><br><span class=\"line\">        pokeDrawLockIfNeeded();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">final</span> <span class=\"keyword\">class</span> <span class=\"title class_\">TraversalRunnable</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Runnable</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        doTraversal();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">final</span> <span class=\"type\">TraversalRunnable</span> <span class=\"variable\">mTraversalRunnable</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">TraversalRunnable</span>();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">void</span> <span class=\"title function_\">doTraversal</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mTraversalScheduled) &#123;</span><br><span class=\"line\">        mTraversalScheduled = <span class=\"literal\">false</span>;</span><br><span class=\"line\">        <span class=\"comment\">//移除同步屏障</span></span><br><span class=\"line\">        mHandler.getLooper().getQueue().removeSyncBarrier(mTraversalBarrier);</span><br><span class=\"line\">        ...</span><br><span class=\"line\">        <span class=\"comment\">//开始三大绘制流程</span></span><br><span class=\"line\">        performTraversals();</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>主要有以下逻辑：</p>\n<ol>\n<li>首先使用mTraversalScheduled字段保证同时间多次更改只会刷新一次，例如TextView连续两次setText()，也只会走一次绘制流程。</li>\n<li>然后把当前线程的<a href=\"https://cloud.tencent.com/product/message-queue-catalog?from_column=20065&from=20065\">消息队列</a>Queue添加了<strong>同步屏障</strong>，这样就屏蔽了正常的同步消息，保证VSync到来后立即执行绘制，而不是要等前面的同步消息。后面会具体分析同步屏障和异步消息的代码逻辑。</li>\n<li>调用了mChoreographer.postCallback()方法，发送一个会在下一帧执行的回调，即<strong>在下一个VSync到来时会执行TraversalRunnable–&gt;doTraversal()—&gt;performTraversals()–&gt;绘制流程</strong>。</li>\n</ol>\n<p>接下来，就是分析的重点——Choreographer。我们先看它的实例mChoreographer，是在ViewRootImpl的构造方法内使用Choreographer.getInstance()创建：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">Choreographer mChoreographer;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//ViewRootImpl实例是在添加window时创建</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"title function_\">ViewRootImpl</span><span class=\"params\">(Context context, Display display)</span> &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    mChoreographer = Choreographer.getInstance();</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们先来看看Choreographer.getInstance()：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Choreographer <span class=\"title function_\">getInstance</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> sThreadInstance.get();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> ThreadLocal&lt;Choreographer&gt; sThreadInstance =</span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">ThreadLocal</span>&lt;Choreographer&gt;() &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">protected</span> Choreographer <span class=\"title function_\">initialValue</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">Looper</span> <span class=\"variable\">looper</span> <span class=\"operator\">=</span> Looper.myLooper();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (looper == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//当前线程要有looper，Choreographer实例需要传入</span></span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">IllegalStateException</span>(<span class=\"string\">&quot;The current thread must have a looper!&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"type\">Choreographer</span> <span class=\"variable\">choreographer</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Choreographer</span>(looper, VSYNC_SOURCE_APP);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (looper == Looper.getMainLooper()) &#123;</span><br><span class=\"line\">            mMainInstance = choreographer;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> choreographer;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>看到这里 如你对Handler机制中looper比较熟悉的话，应该知道 Choreographer和Looper一样 是线程单例的。且当前线程要有looper，Choreographer实例需要传入。接着看看Choreographer构造方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"title function_\">Choreographer</span><span class=\"params\">(Looper looper, <span class=\"type\">int</span> vsyncSource)</span> &#123;</span><br><span class=\"line\">    mLooper = looper;</span><br><span class=\"line\">    <span class=\"comment\">//使用当前线程looper创建 mHandler</span></span><br><span class=\"line\">    mHandler = <span class=\"keyword\">new</span> <span class=\"title class_\">FrameHandler</span>(looper);</span><br><span class=\"line\">    <span class=\"comment\">//USE_VSYNC 4.1以上默认是true，表示 具备接受VSync的能力，这个接受能力就是FrameDisplayEventReceiver</span></span><br><span class=\"line\">    mDisplayEventReceiver = USE_VSYNC</span><br><span class=\"line\">            ? <span class=\"keyword\">new</span> <span class=\"title class_\">FrameDisplayEventReceiver</span>(looper, vsyncSource)</span><br><span class=\"line\">            : <span class=\"literal\">null</span>;</span><br><span class=\"line\">    mLastFrameTimeNanos = Long.MIN_VALUE;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 计算一帧的时间，Android手机屏幕是60Hz的刷新频率，就是16ms</span></span><br><span class=\"line\">    mFrameIntervalNanos = (<span class=\"type\">long</span>)(<span class=\"number\">1000000000</span> / getRefreshRate());</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 创建一个链表类型CallbackQueue的数组，大小为5，</span></span><br><span class=\"line\">    <span class=\"comment\">//也就是数组中有五个链表，每个链表存相同类型的任务：输入、动画、遍历绘制等任务（CALLBACK_INPUT、CALLBACK_ANIMATION、CALLBACK_TRAVERSAL）</span></span><br><span class=\"line\">    mCallbackQueues = <span class=\"keyword\">new</span> <span class=\"title class_\">CallbackQueue</span>[CALLBACK_LAST + <span class=\"number\">1</span>];</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt;= CALLBACK_LAST; i++) &#123;</span><br><span class=\"line\">        mCallbackQueues[i] = <span class=\"keyword\">new</span> <span class=\"title class_\">CallbackQueue</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// b/68769804: For low FPS experiments.</span></span><br><span class=\"line\">    setFPSDivisor(SystemProperties.getInt(ThreadedRenderer.DEBUG_FPS_DIVISOR, <span class=\"number\">1</span>));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>代码中都有注释，创建了一个mHandler、VSync事件接收器mDisplayEventReceiver、任务链表数组mCallbackQueues。FrameHandler、FrameDisplayEventReceiver、CallbackQueue后面会一一说明。</p>\n<h5 id=\"4-2-2-安排任务—postCallback\"><a href=\"#4-2-2-安排任务—postCallback\" class=\"headerlink\" title=\"4.2.2 安排任务—postCallback\"></a><strong>4.2.2 安排任务—postCallback</strong></h5><p>回头看mChoreographer.postCallback(Choreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, null)方法，注意到第一个参数是CALLBACK_TRAVERSAL，表示回调任务的类型，共有以下5种类型：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//输入事件，首先执行</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">CALLBACK_INPUT</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"comment\">//动画，第二执行</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">CALLBACK_ANIMATION</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"comment\">//插入更新的动画，第三执行</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">CALLBACK_INSETS_ANIMATION</span> <span class=\"operator\">=</span> <span class=\"number\">2</span>;</span><br><span class=\"line\"><span class=\"comment\">//绘制，第四执行</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">CALLBACK_TRAVERSAL</span> <span class=\"operator\">=</span> <span class=\"number\">3</span>;</span><br><span class=\"line\"><span class=\"comment\">//提交，最后执行，</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">CALLBACK_COMMIT</span> <span class=\"operator\">=</span> <span class=\"number\">4</span>;</span><br></pre></td></tr></table></figure>\n\n<p>五种类型任务对应存入对应的CallbackQueue中，每当收到 VSYNC 信号时，Choreographer 将首先处理 INPUT 类型的任务，然后是 ANIMATION 类型，最后才是 TRAVERSAL 类型。</p>\n<p>postCallback()内部调用postCallbackDelayed()，接着又调用postCallbackDelayedInternal()，来瞅瞅：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">postCallbackDelayedInternal</span><span class=\"params\">(<span class=\"type\">int</span> callbackType,</span></span><br><span class=\"line\"><span class=\"params\">        Object action, Object token, <span class=\"type\">long</span> delayMillis)</span> &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (mLock) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 当前时间</span></span><br><span class=\"line\">        <span class=\"keyword\">final</span> <span class=\"type\">long</span> <span class=\"variable\">now</span> <span class=\"operator\">=</span> SystemClock.uptimeMillis();</span><br><span class=\"line\">        <span class=\"comment\">// 加上延迟时间</span></span><br><span class=\"line\">        <span class=\"keyword\">final</span> <span class=\"type\">long</span> <span class=\"variable\">dueTime</span> <span class=\"operator\">=</span> now + delayMillis;</span><br><span class=\"line\">        <span class=\"comment\">//取对应类型的CallbackQueue添加任务</span></span><br><span class=\"line\">        mCallbackQueues[callbackType].addCallbackLocked(dueTime, action, token);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (dueTime &lt;= now) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//立即执行</span></span><br><span class=\"line\">            scheduleFrameLocked(now);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">//延迟运行，最终也会走到scheduleFrameLocked()</span></span><br><span class=\"line\">            <span class=\"type\">Message</span> <span class=\"variable\">msg</span> <span class=\"operator\">=</span> mHandler.obtainMessage(MSG_DO_SCHEDULE_CALLBACK, action);</span><br><span class=\"line\">            msg.arg1 = callbackType;</span><br><span class=\"line\">            msg.setAsynchronous(<span class=\"literal\">true</span>);</span><br><span class=\"line\">            mHandler.sendMessageAtTime(msg, dueTime);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>首先取对应类型的CallbackQueue添加任务，action就是mTraversalRunnable，token是null。<strong>CallbackQueue的addCallbackLocked()就是把 dueTime、action、token组装成CallbackRecord后 存入CallbackQueue的下一个节点</strong>，具体代码比较简单，不再跟进。</p>\n<p>然后注意到如果没有延迟会执行scheduleFrameLocked()方法，有延迟就会使用 mHandler发送MSG_DO_SCHEDULE_CALLBACK消息，并且注意到 <strong>使用msg.setAsynchronous(true)把消息设置成异步</strong>，这是因为前面设置了同步屏障，只有异步消息才会执行。我们看下mHandler的对这个消息的处理：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">class</span> <span class=\"title class_\">FrameHandler</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">Handler</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">FrameHandler</span><span class=\"params\">(Looper looper)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">super</span>(looper);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">handleMessage</span><span class=\"params\">(Message msg)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">switch</span> (msg.what) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> MSG_DO_FRAME:</span><br><span class=\"line\">                <span class=\"comment\">// 执行doFrame,即绘制过程</span></span><br><span class=\"line\">                doFrame(System.nanoTime(), <span class=\"number\">0</span>);</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> MSG_DO_SCHEDULE_VSYNC:</span><br><span class=\"line\">                <span class=\"comment\">//申请VSYNC信号，例如当前需要绘制任务时</span></span><br><span class=\"line\">                doScheduleVsync();</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> MSG_DO_SCHEDULE_CALLBACK:</span><br><span class=\"line\">                <span class=\"comment\">//需要延迟的任务，最终还是执行上述两个事件</span></span><br><span class=\"line\">                doScheduleCallback(msg.arg1);</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>直接使用doScheduleCallback方法，看看：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> <span class=\"title function_\">doScheduleCallback</span><span class=\"params\">(<span class=\"type\">int</span> callbackType)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (mLock) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!mFrameScheduled) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">final</span> <span class=\"type\">long</span> <span class=\"variable\">now</span> <span class=\"operator\">=</span> SystemClock.uptimeMillis();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (mCallbackQueues[callbackType].hasDueCallbacksLocked(now)) &#123;</span><br><span class=\"line\">                scheduleFrameLocked(now);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>发现也是走到这里，即延迟运行最终也会走到scheduleFrameLocked()，跟进看看：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">scheduleFrameLocked</span><span class=\"params\">(<span class=\"type\">long</span> now)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!mFrameScheduled) &#123;</span><br><span class=\"line\">        mFrameScheduled = <span class=\"literal\">true</span>;</span><br><span class=\"line\">        <span class=\"comment\">//开启了VSYNC</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (USE_VSYNC) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (DEBUG_FRAMES) &#123;</span><br><span class=\"line\">                Log.d(TAG, <span class=\"string\">&quot;Scheduling next frame on vsync.&quot;</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">//当前执行的线程，是否是mLooper所在线程</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (isRunningOnLooperThreadLocked()) &#123;</span><br><span class=\"line\">                <span class=\"comment\">//申请 VSYNC 信号</span></span><br><span class=\"line\">                scheduleVsyncLocked();</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 若不在，就用mHandler发送消息到原线程，最后还是调用scheduleVsyncLocked方法</span></span><br><span class=\"line\">                <span class=\"type\">Message</span> <span class=\"variable\">msg</span> <span class=\"operator\">=</span> mHandler.obtainMessage(MSG_DO_SCHEDULE_VSYNC);</span><br><span class=\"line\">                msg.setAsynchronous(<span class=\"literal\">true</span>);<span class=\"comment\">//异步</span></span><br><span class=\"line\">                mHandler.sendMessageAtFrontOfQueue(msg);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 如果未开启VSYNC则直接doFrame方法（4.1后默认开启）</span></span><br><span class=\"line\">            <span class=\"keyword\">final</span> <span class=\"type\">long</span> <span class=\"variable\">nextFrameTime</span> <span class=\"operator\">=</span> Math.max(</span><br><span class=\"line\">                    mLastFrameTimeNanos / TimeUtils.NANOS_PER_MS + sFrameDelay, now);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (DEBUG_FRAMES) &#123;</span><br><span class=\"line\">                Log.d(TAG, <span class=\"string\">&quot;Scheduling next frame in &quot;</span> + (nextFrameTime - now) + <span class=\"string\">&quot; ms.&quot;</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"type\">Message</span> <span class=\"variable\">msg</span> <span class=\"operator\">=</span> mHandler.obtainMessage(MSG_DO_FRAME);</span><br><span class=\"line\">            msg.setAsynchronous(<span class=\"literal\">true</span>);<span class=\"comment\">//异步</span></span><br><span class=\"line\">            mHandler.sendMessageAtTime(msg, nextFrameTime);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>如果系统未开启 VSYNC 机制，此时直接发送 MSG_DO_FRAME 消息到 FrameHandler。注意查看上面贴出的 FrameHandler 代码，此时直接执行 doFrame 方法。</li>\n<li>Android 4.1 之后系统默认开启 VSYNC，在 Choreographer 的构造方法会创建一个 FrameDisplayEventReceiver，scheduleVsyncLocked 方法将会通过它申请 VSYNC 信号。</li>\n<li>isRunningOnLooperThreadLocked 方法，其内部根据 Looper 判断是否在原线程，否则发送消息到 FrameHandler。最终还是会调用 scheduleVsyncLocked 方法申请 VSYNC 信号。</li>\n</ol>\n<p>到这里，<strong>FrameHandler的作用很明显里了：发送异步消息（因为前面设置了同步屏障）。有延迟的任务发延迟消息、不在原线程的发到原线程、没开启VSYNC的直接走 doFrame 方法取执行绘制。</strong></p>\n<h5 id=\"4-2-3-申请和接受VSync\"><a href=\"#4-2-3-申请和接受VSync\" class=\"headerlink\" title=\"4.2.3 申请和接受VSync\"></a><strong>4.2.3 申请和接受VSync</strong></h5><p>好了， 接着就看 scheduleVsyncLocked 方法是如何申请 VSYNC 信号的。猜测肯定申请 VSYNC 信号后，信号到来时也是走doFrame() 方法，doFrame()后面再看。先跟进scheduleVsyncLocked():</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">scheduleVsyncLocked</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    mDisplayEventReceiver.scheduleVsync();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>很简单，调用mDisplayEventReceiver的scheduleVsync()方法，mDisplayEventReceiver是Choreographer构造方法中创建，是FrameDisplayEventReceiver 的实例。FrameDisplayEventReceiver是 DisplayEventReceiver 的子类，DisplayEventReceiver 是一个 abstract class：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"title function_\">DisplayEventReceiver</span><span class=\"params\">(Looper looper, <span class=\"type\">int</span> vsyncSource)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (looper == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">IllegalArgumentException</span>(<span class=\"string\">&quot;looper must not be null&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    mMessageQueue = looper.getQueue();</span><br><span class=\"line\">    <span class=\"comment\">// 注册VSYNC信号监听者</span></span><br><span class=\"line\">    mReceiverPtr = nativeInit(<span class=\"keyword\">new</span> <span class=\"title class_\">WeakReference</span>&lt;DisplayEventReceiver&gt;(<span class=\"built_in\">this</span>), mMessageQueue,</span><br><span class=\"line\">            vsyncSource);</span><br><span class=\"line\"></span><br><span class=\"line\">    mCloseGuard.open(<span class=\"string\">&quot;dispose&quot;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在 DisplayEventReceiver 的构造方法会通过 JNI 创建一个 IDisplayEventConnection 的 VSYNC 的监听者。</p>\n<p>FrameDisplayEventReceiver的scheduleVsync()就是在 DisplayEventReceiver中：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">scheduleVsync</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mReceiverPtr == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        Log.w(TAG, <span class=\"string\">&quot;Attempted to schedule a vertical sync pulse but the display event &quot;</span></span><br><span class=\"line\">                + <span class=\"string\">&quot;receiver has already been disposed.&quot;</span>);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 申请VSYNC中断信号，会回调onVsync方法</span></span><br><span class=\"line\">        nativeScheduleVsync(mReceiverPtr);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>那么scheduleVsync()就是使用native方法nativeScheduleVsync()去申请VSYNC信号。这个native方法就看不了了，只需要知道<strong>VSYNC信号的接受回调是onVsync()</strong>，我们直接看onVsync()：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 接收到VSync脉冲时 回调</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> timestampNanos VSync脉冲的时间戳</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> physicalDisplayId Stable display ID that uniquely describes a (display, port) pair.</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> frame 帧号码，自增</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"meta\">@UnsupportedAppUsage</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">onVsync</span><span class=\"params\">(<span class=\"type\">long</span> timestampNanos, <span class=\"type\">long</span> physicalDisplayId, <span class=\"type\">int</span> frame)</span> &#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>具体实现是在FrameDisplayEventReceiver中：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">class</span> <span class=\"title class_\">FrameDisplayEventReceiver</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">DisplayEventReceiver</span></span><br><span class=\"line\">        <span class=\"keyword\">implements</span> <span class=\"title class_\">Runnable</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">boolean</span> mHavePendingVsync;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">long</span> mTimestampNanos;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">int</span> mFrame;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">FrameDisplayEventReceiver</span><span class=\"params\">(Looper looper, <span class=\"type\">int</span> vsyncSource)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">super</span>(looper, vsyncSource);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">onVsync</span><span class=\"params\">(<span class=\"type\">long</span> timestampNanos, <span class=\"type\">long</span> physicalDisplayId, <span class=\"type\">int</span> frame)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// Post the vsync event to the Handler.</span></span><br><span class=\"line\">        <span class=\"comment\">// The idea is to prevent incoming vsync events from completely starving</span></span><br><span class=\"line\">        <span class=\"comment\">// the message queue.  If there are no messages in the queue with timestamps</span></span><br><span class=\"line\">        <span class=\"comment\">// earlier than the frame time, then the vsync event will be processed immediately.</span></span><br><span class=\"line\">        <span class=\"comment\">// Otherwise, messages that predate the vsync event will be handled first.</span></span><br><span class=\"line\">        <span class=\"type\">long</span> <span class=\"variable\">now</span> <span class=\"operator\">=</span> System.nanoTime();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (timestampNanos &gt; now) &#123;</span><br><span class=\"line\">            Log.w(TAG, <span class=\"string\">&quot;Frame time is &quot;</span> + ((timestampNanos - now) * <span class=\"number\">0.000001f</span>)</span><br><span class=\"line\">                    + <span class=\"string\">&quot; ms in the future!  Check that graphics HAL is generating vsync &quot;</span></span><br><span class=\"line\">                    + <span class=\"string\">&quot;timestamps using the correct timebase.&quot;</span>);</span><br><span class=\"line\">            timestampNanos = now;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mHavePendingVsync) &#123;</span><br><span class=\"line\">            Log.w(TAG, <span class=\"string\">&quot;Already have a pending vsync event.  There should only be &quot;</span></span><br><span class=\"line\">                    + <span class=\"string\">&quot;one at a time.&quot;</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            mHavePendingVsync = <span class=\"literal\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        mTimestampNanos = timestampNanos;</span><br><span class=\"line\">        mFrame = frame;</span><br><span class=\"line\">        <span class=\"comment\">//将本身作为runnable传入msg， 发消息后 会走run()，即doFrame()，也是异步消息</span></span><br><span class=\"line\">        <span class=\"type\">Message</span> <span class=\"variable\">msg</span> <span class=\"operator\">=</span> Message.obtain(mHandler, <span class=\"built_in\">this</span>);</span><br><span class=\"line\">        msg.setAsynchronous(<span class=\"literal\">true</span>);</span><br><span class=\"line\">        mHandler.sendMessageAtTime(msg, timestampNanos / TimeUtils.NANOS_PER_MS);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        mHavePendingVsync = <span class=\"literal\">false</span>;</span><br><span class=\"line\">        doFrame(mTimestampNanos, mFrame);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>onVsync()中，将接收器本身作为runnable传入异步消息msg，并使用mHandler发送msg，最终执行的就是doFrame()方法了。</p>\n<p>注意一点是，<strong>onVsync()方法中只是使用mHandler发送消息到MessageQueue中，不一定是立刻执行，如何MessageQueue中前面有较为耗时的操作，那么就要等完成，才会执行本次的doFrame()</strong>。</p>\n<h5 id=\"4-2-4-doFrame\"><a href=\"#4-2-4-doFrame\" class=\"headerlink\" title=\"4.2.4 doFrame\"></a><strong>4.2.4 doFrame</strong></h5><p>和上面猜测一样，申请VSync信号接收到后确实是走 doFrame()方法，那么就来看看Choreographer的doFrame()：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> <span class=\"title function_\">doFrame</span><span class=\"params\">(<span class=\"type\">long</span> frameTimeNanos, <span class=\"type\">int</span> frame)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"type\">long</span> startNanos;</span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (mLock) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!mFrameScheduled) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span>; <span class=\"comment\">// no work to do</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        ...</span><br><span class=\"line\">        <span class=\"comment\">// 预期执行时间</span></span><br><span class=\"line\">        <span class=\"type\">long</span> <span class=\"variable\">intendedFrameTimeNanos</span> <span class=\"operator\">=</span> frameTimeNanos;</span><br><span class=\"line\">        startNanos = System.nanoTime();</span><br><span class=\"line\">        <span class=\"comment\">// 超时时间是否超过一帧的时间（这是因为MessageQueue虽然添加了同步屏障，但是还是有正在执行的同步任务，导致doFrame延迟执行了）</span></span><br><span class=\"line\">        <span class=\"keyword\">final</span> <span class=\"type\">long</span> <span class=\"variable\">jitterNanos</span> <span class=\"operator\">=</span> startNanos - frameTimeNanos;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (jitterNanos &gt;= mFrameIntervalNanos) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 计算掉帧数</span></span><br><span class=\"line\">            <span class=\"keyword\">final</span> <span class=\"type\">long</span> <span class=\"variable\">skippedFrames</span> <span class=\"operator\">=</span> jitterNanos / mFrameIntervalNanos;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (skippedFrames &gt;= SKIPPED_FRAME_WARNING_LIMIT) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 掉帧超过30帧打印Log提示</span></span><br><span class=\"line\">                Log.i(TAG, <span class=\"string\">&quot;Skipped &quot;</span> + skippedFrames + <span class=\"string\">&quot; frames!  &quot;</span></span><br><span class=\"line\">                        + <span class=\"string\">&quot;The application may be doing too much work on its main thread.&quot;</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">final</span> <span class=\"type\">long</span> <span class=\"variable\">lastFrameOffset</span> <span class=\"operator\">=</span> jitterNanos % mFrameIntervalNanos;</span><br><span class=\"line\">            ...</span><br><span class=\"line\">            frameTimeNanos = startNanos - lastFrameOffset;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        ...</span><br><span class=\"line\"></span><br><span class=\"line\">        mFrameInfo.setVsync(intendedFrameTimeNanos, frameTimeNanos);</span><br><span class=\"line\">        <span class=\"comment\">// Frame标志位恢复</span></span><br><span class=\"line\">        mFrameScheduled = <span class=\"literal\">false</span>;</span><br><span class=\"line\">        <span class=\"comment\">// 记录最后一帧时间</span></span><br><span class=\"line\">        mLastFrameTimeNanos = frameTimeNanos;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 按类型顺序 执行任务</span></span><br><span class=\"line\">        Trace.traceBegin(Trace.TRACE_TAG_VIEW, <span class=\"string\">&quot;Choreographer#doFrame&quot;</span>);</span><br><span class=\"line\">        AnimationUtils.lockAnimationClock(frameTimeNanos / TimeUtils.NANOS_PER_MS);</span><br><span class=\"line\"></span><br><span class=\"line\">        mFrameInfo.markInputHandlingStart();</span><br><span class=\"line\">        doCallbacks(Choreographer.CALLBACK_INPUT, frameTimeNanos);</span><br><span class=\"line\"></span><br><span class=\"line\">        mFrameInfo.markAnimationsStart();</span><br><span class=\"line\">        doCallbacks(Choreographer.CALLBACK_ANIMATION, frameTimeNanos);</span><br><span class=\"line\">        doCallbacks(Choreographer.CALLBACK_INSETS_ANIMATION, frameTimeNanos);</span><br><span class=\"line\"></span><br><span class=\"line\">        mFrameInfo.markPerformTraversalsStart();</span><br><span class=\"line\">        doCallbacks(Choreographer.CALLBACK_TRAVERSAL, frameTimeNanos);</span><br><span class=\"line\"></span><br><span class=\"line\">        doCallbacks(Choreographer.CALLBACK_COMMIT, frameTimeNanos);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        AnimationUtils.unlockAnimationClock();</span><br><span class=\"line\">        Trace.traceEnd(Trace.TRACE_TAG_VIEW);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面都有注释了很好理解，接着看任务的具体执行doCallbacks 方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> <span class=\"title function_\">doCallbacks</span><span class=\"params\">(<span class=\"type\">int</span> callbackType, <span class=\"type\">long</span> frameTimeNanos)</span> &#123;</span><br><span class=\"line\">    CallbackRecord callbacks;</span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (mLock) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">final</span> <span class=\"type\">long</span> <span class=\"variable\">now</span> <span class=\"operator\">=</span> System.nanoTime();</span><br><span class=\"line\">        <span class=\"comment\">// 根据指定的类型CallbackkQueue中查找到达执行时间的CallbackRecord</span></span><br><span class=\"line\">        callbacks = mCallbackQueues[callbackType].extractDueCallbacksLocked(now / TimeUtils.NANOS_PER_MS);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (callbacks == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        mCallbacksRunning = <span class=\"literal\">true</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//提交任务类型</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (callbackType == Choreographer.CALLBACK_COMMIT) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">final</span> <span class=\"type\">long</span> <span class=\"variable\">jitterNanos</span> <span class=\"operator\">=</span> now - frameTimeNanos;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (jitterNanos &gt;= <span class=\"number\">2</span> * mFrameIntervalNanos) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">final</span> <span class=\"type\">long</span> <span class=\"variable\">lastFrameOffset</span> <span class=\"operator\">=</span> jitterNanos % mFrameIntervalNanos</span><br><span class=\"line\">                        + mFrameIntervalNanos;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (DEBUG_JANK) &#123;</span><br><span class=\"line\">                    Log.d(TAG, <span class=\"string\">&quot;Commit callback delayed by &quot;</span> + (jitterNanos * <span class=\"number\">0.000001f</span>)</span><br><span class=\"line\">                            + <span class=\"string\">&quot; ms which is more than twice the frame interval of &quot;</span></span><br><span class=\"line\">                            + (mFrameIntervalNanos * <span class=\"number\">0.000001f</span>) + <span class=\"string\">&quot; ms!  &quot;</span></span><br><span class=\"line\">                            + <span class=\"string\">&quot;Setting frame time to &quot;</span> + (lastFrameOffset * <span class=\"number\">0.000001f</span>)</span><br><span class=\"line\">                            + <span class=\"string\">&quot; ms in the past.&quot;</span>);</span><br><span class=\"line\">                    mDebugPrintNextFrameTimeDelta = <span class=\"literal\">true</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                frameTimeNanos = now - lastFrameOffset;</span><br><span class=\"line\">                mLastFrameTimeNanos = frameTimeNanos;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 迭代执行队列所有任务</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">CallbackRecord</span> <span class=\"variable\">c</span> <span class=\"operator\">=</span> callbacks; c != <span class=\"literal\">null</span>; c = c.next) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 回调CallbackRecord的run，其内部回调Callback的run</span></span><br><span class=\"line\">            c.run(frameTimeNanos);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span> (mLock) &#123;</span><br><span class=\"line\">            mCallbacksRunning = <span class=\"literal\">false</span>;</span><br><span class=\"line\">            <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">final</span> <span class=\"type\">CallbackRecord</span> <span class=\"variable\">next</span> <span class=\"operator\">=</span> callbacks.next;</span><br><span class=\"line\">                <span class=\"comment\">//回收CallbackRecord</span></span><br><span class=\"line\">                recycleCallbackLocked(callbacks);</span><br><span class=\"line\">                callbacks = next;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">while</span> (callbacks != <span class=\"literal\">null</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>主要内容就是取对应任务类型的队列，遍历队列执行所有任务，执行任务是 CallbackRecord的 run 方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">class</span> <span class=\"title class_\">CallbackRecord</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> CallbackRecord next;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">long</span> dueTime;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> Object action; <span class=\"comment\">// Runnable or FrameCallback</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Object token;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@UnsupportedAppUsage</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">(<span class=\"type\">long</span> frameTimeNanos)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (token == FRAME_CALLBACK_TOKEN) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 通过postFrameCallback 或 postFrameCallbackDelayed，会执行这里</span></span><br><span class=\"line\">            ((FrameCallback)action).doFrame(frameTimeNanos);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">//取出Runnable执行run()</span></span><br><span class=\"line\">            ((Runnable)action).run();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>前面看到mChoreographer.postCallback传的token是null，所以取出action，就是Runnable，执行run()，这里的action就是 ViewRootImpl 发起的绘制任务mTraversalRunnable了，那么<strong>这样整个逻辑就闭环了</strong>。</p>\n<p>那么 啥时候 token &#x3D;&#x3D; FRAME_CALLBACK_TOKEN 呢？答案是Choreographer的postFrameCallback()方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">postFrameCallback</span><span class=\"params\">(FrameCallback callback)</span> &#123;</span><br><span class=\"line\">    postFrameCallbackDelayed(callback, <span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">postFrameCallbackDelayed</span><span class=\"params\">(FrameCallback callback, <span class=\"type\">long</span> delayMillis)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (callback == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">IllegalArgumentException</span>(<span class=\"string\">&quot;callback must not be null&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//也是走到是postCallbackDelayedInternal，并且注意是CALLBACK_ANIMATION类型，</span></span><br><span class=\"line\">    <span class=\"comment\">//token是FRAME_CALLBACK_TOKEN，action就是FrameCallback</span></span><br><span class=\"line\">    postCallbackDelayedInternal(CALLBACK_ANIMATION,</span><br><span class=\"line\">            callback, FRAME_CALLBACK_TOKEN, delayMillis);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">FrameCallback</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">doFrame</span><span class=\"params\">(<span class=\"type\">long</span> frameTimeNanos)</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可以看到postFrameCallback()传入的是FrameCallback实例，接口FrameCallback只有一个doFrame()方法。并且也是走到postCallbackDelayedInternal，FrameCallback实例作为action传入，token则是FRAME_CALLBACK_TOKEN，并且任务是CALLBACK_ANIMATION类型。</p>\n<p><strong>Choreographer的postFrameCallback()通常用来计算丢帧情况</strong>，使用方式如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">      <span class=\"comment\">//Application.java</span></span><br><span class=\"line\">       <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">onCreate</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">           <span class=\"built_in\">super</span>.onCreate();</span><br><span class=\"line\">           <span class=\"comment\">//在Application中使用postFrameCallback</span></span><br><span class=\"line\">           Choreographer.getInstance().postFrameCallback(<span class=\"keyword\">new</span> <span class=\"title class_\">FPSFrameCallback</span>(System.nanoTime()));</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">FPSFrameCallback</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Choreographer</span>.FrameCallback &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">String</span> <span class=\"variable\">TAG</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;FPS_TEST&quot;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">long</span> <span class=\"variable\">mLastFrameTimeNanos</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">long</span> mFrameIntervalNanos;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">FPSFrameCallback</span><span class=\"params\">(<span class=\"type\">long</span> lastFrameTimeNanos)</span> &#123;</span><br><span class=\"line\">        mLastFrameTimeNanos = lastFrameTimeNanos;</span><br><span class=\"line\">        mFrameIntervalNanos = (<span class=\"type\">long</span>)(<span class=\"number\">1000000000</span> / <span class=\"number\">60.0</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">doFrame</span><span class=\"params\">(<span class=\"type\">long</span> frameTimeNanos)</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//初始化时间</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mLastFrameTimeNanos == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            mLastFrameTimeNanos = frameTimeNanos;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> <span class=\"type\">long</span> <span class=\"variable\">jitterNanos</span> <span class=\"operator\">=</span> frameTimeNanos - mLastFrameTimeNanos;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (jitterNanos &gt;= mFrameIntervalNanos) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">final</span> <span class=\"type\">long</span> <span class=\"variable\">skippedFrames</span> <span class=\"operator\">=</span> jitterNanos / mFrameIntervalNanos;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(skippedFrames&gt;<span class=\"number\">30</span>)&#123;</span><br><span class=\"line\">                <span class=\"comment\">//丢帧30以上打印日志</span></span><br><span class=\"line\">                Log.i(TAG, <span class=\"string\">&quot;Skipped &quot;</span> + skippedFrames + <span class=\"string\">&quot; frames!  &quot;</span></span><br><span class=\"line\">                        + <span class=\"string\">&quot;The application may be doing too much work on its main thread.&quot;</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        mLastFrameTimeNanos=frameTimeNanos;</span><br><span class=\"line\">        <span class=\"comment\">//注册下一帧回调</span></span><br><span class=\"line\">        Choreographer.getInstance().postFrameCallback(<span class=\"built_in\">this</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"4-2-5-小结\"><a href=\"#4-2-5-小结\" class=\"headerlink\" title=\"4.2.5 小结\"></a><strong>4.2.5 小结</strong></h5><p>使用Choreographer的postCallback()、postFrameCallback() 作用理解：发送任务 存队列中，监听VSync信号，当前VSync到来时 会使用mHandler发送异步message，这个message的Runnable就是队列中的所有任务。</p>\n<p>好了，Choreographer整个代码逻辑都讲完了，引用《Android 之 Choreographer 详细分析》的流程图：</p>\n<p>原文流程图为：<a href=\"https://i-blog.csdnimg.cn/blog_migrate/5ff22e98afde4ff780f8a291d1081619.png\">Android 之 Choreographer</a>，但并不是很形象，引用另一张流程图：</p>\n<img src=\"https://cdn.julis.wang/blog/img/aab4273a0af898dcc9bb0fdcc0447b5a.png\">\n<h2 id=\"六、疑问解答\"><a href=\"#六、疑问解答\" class=\"headerlink\" title=\"六、疑问解答\"></a><strong>六、疑问解答</strong></h2><ol>\n<li><strong>丢帧</strong>(掉帧) ，是说 这一帧延迟显示 还是丢弃不再显示 ？ 答：延迟显示，因为缓存交换的时机只能等下一个VSync了。</li>\n<li>布局层级较多&#x2F;主线程耗时 是如何造成 丢帧的呢？ 答：布局层级较多&#x2F;主线程耗时 会影响CPU&#x2F;GPU的执行时间，大于16.6ms时只能等下一个VSync了。</li>\n<li>16.6ms刷新一次 是啥意思？是每16.6ms都走一次 measure&#x2F;layout&#x2F;draw ？ 答：屏幕的固定刷新频率是60Hz，即16.6ms。不是每16.6ms都走一次 measure&#x2F;layout&#x2F;draw，而是有绘制任务才会走，并且绘制时间间隔是取决于布局复杂度及主线程耗时。</li>\n<li>measure&#x2F;layout&#x2F;draw 走完，界面就立刻刷新了吗? 答：不是。measure&#x2F;layout&#x2F;draw 走完后 会在VSync到来时进行缓存交换和刷新。</li>\n<li>如果界面没动静止了，还会刷新吗？ 答：屏幕会固定没16.6ms刷新，但CPU&#x2F;GPU不走绘制流程。见下面的SysTrace图。</li>\n<li>可能你知道<strong>VSYNC</strong>，这个具体指啥？在屏幕刷新中如何工作的？ 答：当扫描完一个屏幕后，设备需要重新回到第一行以进入下一次的循环，此时会出现的vertical sync pulse（垂直同步脉冲）来保证双缓冲在最佳时间点才进行交换。并且Android4.1后 CPU&#x2F;GPU的绘制是在VSYNC到来时开始。</li>\n<li>可能你还听过屏幕刷新使用 <strong>双缓存</strong>、<strong>三缓存</strong>，这又是啥意思呢？ 答：双缓存是Back buffer、Frame buffer，用于解决画面撕裂。三缓存增加一个Back buffer，用于减少Jank。</li>\n<li>可能你还听过神秘的<strong>Choreographer</strong>，这又是干啥的？ 答：用于实现——“CPU&#x2F;GPU的绘制是在VSYNC到来时开始”。</li>\n</ol>\n","cover":null,"images":["https://cdn.julis.wang/blog/img/0nq54q5jtq.jpeg","https://cdn.julis.wang/blog/img/xxm0lvzypa.jpeg","https://cdn.julis.wang/blog/img/q2vukxpyvq.jpeg","https://cdn.julis.wang/blog/img/1ax0mz0nu1.jpeg","https://cdn.julis.wang/blog/img/uuqflxwo53.jpeg","https://cdn.julis.wang/blog/img/po2jd1h7u8.jpeg","https://cdn.julis.wang/blog/img/ldq7oda57p.jpeg","https://cdn.julis.wang/blog/img/aab4273a0af898dcc9bb0fdcc0447b5a.png"],"content":"<p>最近在研究 Android 屏幕显示与渲染相关的内容，平时经常看到这些类 <code>ViewRootImpl</code>、<code>Choreographer</code>、<code>Surface</code> 、 <code>SurfaceFlinger</code>等，知道它们都用于屏幕渲染相关，但对它们细节了解较少，相关的文章也比较多，不需要自己完全重新再编写一份，于是对相关内容进行一个总结,<br>主要来源：<a href=\"https://juejin.cn/post/6863756420380196877\">《Android屏幕刷新机制—VSyncChoreographer 全面理解》</a>，这篇博客是我认为是目前看到过最好的一篇，文章由浅入深比较好理解。不过文章里面图片链接资源已经失效，为以后复习相关知识点，在此将其整理删除冗余内容，并对图片资源进行更新。</p>\n<h2 id=\"一、背景和疑问\"><a href=\"#一、背景和疑问\" class=\"headerlink\" title=\"一、背景和疑问\"></a><strong>一、背景和疑问</strong></h2><p>在Android中，当我们谈到 <strong>布局优化</strong>、<strong>卡顿优化</strong> 时，通常都知道 需要减少布局层级、减少主线程耗时操作，这样可以减少<strong>丢帧</strong>。如果丢帧比较严重，那么界面可能会有明显的卡顿感。我们知道 通常手机刷新是每秒60次，即每隔16.6ms刷新一次。 问题来了：</p>\n<ol>\n<li><strong>丢帧</strong>(掉帧) ，是说 这一帧延迟显示 还是丢弃不再显示 ？</li>\n<li>布局层级较多&#x2F;主线程耗时 是如何造成 丢帧的呢？</li>\n<li>16.6ms刷新一次 是啥意思？是每16.6ms都走一次 measure&#x2F;layout&#x2F;draw ？</li>\n<li>measure&#x2F;layout&#x2F;draw 走完，界面就立刻刷新了吗?</li>\n<li>如果界面没动静止了，还会刷新吗？</li>\n<li>可能你知道<strong>VSYNC</strong>，这个具体指啥？在屏幕刷新中如何工作的？</li>\n<li>可能你还听过屏幕刷新使用 <strong>双缓存</strong>、<strong>三缓存</strong>，这又是啥意思呢？</li>\n<li>可能你还听过神秘的<strong>Choreographer</strong>，这又是干啥的？</li>\n</ol>\n<h2 id=\"二、显示系统基础知识\"><a href=\"#二、显示系统基础知识\" class=\"headerlink\" title=\"二、显示系统基础知识\"></a><strong>二、显示系统基础知识</strong></h2><p>在一个典型的显示系统中，一般包括CPU、GPU、Display三个部分， CPU负责计算帧数据，把计算好的数据交给GPU，GPU会对图形数据进行渲染，渲染好后放到buffer(图像缓冲区)里存起来，然后Display（屏幕或显示器）负责把buffer里的数据呈现到屏幕上。如下图：</p>\n<img src=\"https://cdn.julis.wang/blog/img/0nq54q5jtq.jpeg\">\n\n<p>单缓存，从缓存映射到屏幕。</p>\n<h3 id=\"2-1-基础概念\"><a href=\"#2-1-基础概念\" class=\"headerlink\" title=\"2.1 基础概念\"></a><strong>2.1 基础概念</strong></h3><ul>\n<li><strong>屏幕刷新频率</strong> 一秒内屏幕刷新的次数（一秒内显示了多少帧的图像），单位 Hz（赫兹），如常见的 60 Hz。<strong>刷新频率取决于硬件的固定参数</strong>（不会变的）。</li>\n<li><strong>逐行扫描</strong> 显示器并不是一次性将画面显示到屏幕上，而是从左到右边，从上到下逐行扫描，顺序显示整屏的一个个像素点，不过这一过程快到人眼无法察觉到变化。以 60 Hz 刷新率的屏幕为例，这一过程即 1000 &#x2F; 60 ≈ 16ms。</li>\n<li><strong>帧率</strong> （Frame Rate） 表示 <strong>GPU 在一秒内绘制操作的帧数</strong>，单位 fps。例如在电影界采用 24 帧的速度足够使画面运行的非常流畅。而 Android 系统则采用更加流程的 60 fps，即每秒钟GPU最多绘制 60 帧画面。帧率是动态变化的，例如当画面静止时，GPU 是没有绘制操作的，屏幕刷新的还是buffer中的数据，即GPU最后操作的帧数据。</li>\n<li><strong>画面撕裂</strong>（tearing） 一个屏幕内的数据来自2个不同的帧，画面会出现撕裂感，如下图</li>\n</ul>\n<img src=\"https://cdn.julis.wang/blog/img/xxm0lvzypa.jpeg\">\n\n<p>明显看出画面错位的位置，这就是画面撕裂。</p>\n<h3 id=\"2-2-双缓存\"><a href=\"#2-2-双缓存\" class=\"headerlink\" title=\"2.2 双缓存\"></a><strong>2.2 双缓存</strong></h3><h5 id=\"2-2-1-画面撕裂-原因\"><a href=\"#2-2-1-画面撕裂-原因\" class=\"headerlink\" title=\"2.2.1  画面撕裂 原因\"></a><strong>2.2.1  画面撕裂 原因</strong></h5><p>屏幕刷新频是固定的，比如每16.6ms从buffer取数据显示完一帧，理想情况下帧率和刷新频率保持一致，即每绘制完成一帧，显示器显示一帧。但是CPU&#x2F;GPU写数据是不可控的，所以会出现buffer里有些数据根本没显示出来就被重写了，即buffer里的数据可能是来自不同的帧的， 当屏幕刷新时，此时它并不知道buffer的状态，因此从buffer抓取的帧并不是完整的一帧画面，即出现画面撕裂。</p>\n<p>简单说就是Display在显示的过程中，buffer内数据被CPU&#x2F;GPU修改，导致画面撕裂。</p>\n<h5 id=\"2-2-2-双缓存\"><a href=\"#2-2-2-双缓存\" class=\"headerlink\" title=\"2.2.2  双缓存\"></a><strong>2.2.2  双缓存</strong></h5><p>那咋解决画面撕裂呢？答案是使用 双缓存。</p>\n<p>由于图像绘制和屏幕读取 使用的是同个buffer，所以屏幕刷新时可能读取到的是不完整的一帧画面。</p>\n<p><strong>双缓存</strong>，让绘制和显示器拥有各自的buffer：GPU 始终将完成的一帧图像数据写入到 <strong>Back Buffer</strong>，而显示器使用 <strong>Frame Buffer</strong>，当屏幕刷新时，Frame Buffer 并不会发生变化，当Back buffer准备就绪后，它们才进行交换。如下图：</p>\n<img src=\"https://cdn.julis.wang/blog/img/q2vukxpyvq.jpeg\">\n\n<p>双缓存，CPU&#x2F;GPU写数据到Back Buffer，显示器从Frame Buffer取数据</p>\n<h5 id=\"2-2-3-VSync\"><a href=\"#2-2-3-VSync\" class=\"headerlink\" title=\"2.2.3  VSync\"></a><strong>2.2.3  VSync</strong></h5><p>问题又来了：什么时候进行两个buffer的交换呢？</p>\n<p>假如是 Back buffer准备完成一帧数据以后就进行，那么如果此时屏幕还没有完整显示上一帧内容的话，肯定是会出问题的。看来只能是等到屏幕处理完一帧数据后，才可以执行这一操作了。</p>\n<p>当扫描完一个屏幕后，设备需要重新回到第一行以进入下一次的循环，此时有一段时间空隙，称为VerticalBlanking Interval(VBI)。那，这个时间点就是我们进行缓冲区交换的最佳时间。因为此时屏幕没有在刷新，也就避免了交换过程中出现 screen tearing的状况。</p>\n<p><strong>VSync</strong>(垂直同步)是VerticalSynchronization的简写，它利用VBI时期出现的vertical sync pulse（垂直同步脉冲）来保证双缓冲在最佳时间点才进行交换。另外，交换是指各自的内存地址，可以认为该操作是瞬间完成。</p>\n<p>所以说V-sync这个概念并不是Google首创的，它在早年的PC机领域就已经出现了。</p>\n<h2 id=\"三、Android屏幕刷新机制\"><a href=\"#三、Android屏幕刷新机制\" class=\"headerlink\" title=\"三、Android屏幕刷新机制\"></a><strong>三、Android屏幕刷新机制</strong></h2><h3 id=\"3-1-Android4-1之前的问题\"><a href=\"#3-1-Android4-1之前的问题\" class=\"headerlink\" title=\"3.1 Android4.1之前的问题\"></a><strong>3.1 Android4.1之前的问题</strong></h3><p>具体到Android中，在Android4.1之前，屏幕刷新也遵循 上面介绍的 双缓存+VSync 机制。如下图：</p>\n<img src=\"https://cdn.julis.wang/blog/img/1ax0mz0nu1.jpeg\">\n\n<p>双缓存会在VSync脉冲时交换，但CPU&#x2F;GPU绘制是随机的</p>\n<p>以时间的顺序来看下将会发生的过程：</p>\n<ol>\n<li>Display显示第0帧数据，此时CPU和<a href=\"https://cloud.tencent.com/solution/render?from_column=20065&from=20065\">GPU渲染</a>第1帧画面，且在Display显示下一帧前完成</li>\n<li>因为渲染及时，Display在第0帧显示完成后，也就是第1个VSync后，缓存进行交换，然后正常显示第1帧</li>\n<li>接着第2帧开始处理，是直到第2个VSync快来前才开始处理的。</li>\n<li>第2个VSync来时，由于第2帧数据还没有准备就绪，缓存没有交换，显示的还是第1帧。这种情况被Android开发组命名为“Jank”，即发生了<strong>丢帧</strong>。</li>\n<li>当第2帧数据准备完成后，它并不会马上被显示，而是要等待下一个VSync 进行缓存交换再显示。</li>\n</ol>\n<p>所以总的来说，就是屏幕平白无故地多显示了一次第1帧。</p>\n<p>原因是 第2帧的CPU&#x2F;GPU计算 没能在VSync信号到来前完成 。</p>\n<p>我们知道，<strong>双缓存的交换 是在Vsyn到来时进行，交换后屏幕会取Frame buffer内的新数据，而实际 此时的Back buffer 就可以供GPU准备下一帧数据了。如果 Vsyn到来时  CPU&#x2F;GPU就开始操作的话，是有完整的16.6ms的，这样应该会基本避免jank的出现了</strong>（除非CPU&#x2F;GPU计算超过了16.6ms）。  那如何让 CPU&#x2F;GPU计算在 Vsyn到来时进行呢？</p>\n<h3 id=\"3-2-drawing-with-VSync\"><a href=\"#3-2-drawing-with-VSync\" class=\"headerlink\" title=\"3.2 drawing with VSync\"></a><strong>3.2 drawing with VSync</strong></h3><p>为了优化显示性能，Google在Android 4.1系统中对Android Display系统进行了重构，实现了Project Butter（黄油工程）：系统在收到VSync pulse后，将马上开始下一帧的渲染。即<strong>一旦收到VSync通知（16ms触发一次），CPU和GPU 才立刻开始计算然后把数据写入buffer</strong>。如下图：</p>\n<img src=\"https://cdn.julis.wang/blog/img/uuqflxwo53.jpeg\">\n\n<p>VSync脉冲到来：双缓存交换，且开始CPU&#x2F;GPU绘制 CPU&#x2F;GPU根据VSYNC信号同步处理数据，可以让CPU&#x2F;GPU有完整的16ms时间来处理数据，减少了jank。</p>\n<p>一句话总结，<strong>VSync同步使得CPU&#x2F;GPU充分利用了16.6ms时间，减少jank。</strong></p>\n<p>问题又来了，如果界面比较复杂，CPU&#x2F;GPU的处理时间较长 超过了16.6ms呢？如下图：</p>\n<img src=\"https://cdn.julis.wang/blog/img/po2jd1h7u8.jpeg\">\n\n<p>虽然CPU&#x2F;GPU开始在VSync，但超过16.6ms</p>\n<ol>\n<li>在第二个时间段内，但却因 GPU 还在处理 B 帧，缓存没能交换，导致 A 帧被重复显示。</li>\n<li>而B完成后，又因为缺乏VSync pulse信号，它只能等待下一个signal的来临。于是在这一过程中，有一大段时间是被浪费的。</li>\n<li>当下一个VSync出现时，CPU&#x2F;GPU马上执行操作（A帧），且缓存交换，相应的显示屏对应的就是B。这时看起来就是正常的。只不过由于执行时间仍然超过16ms，导致下一次应该执行的缓冲区交换又被推迟了——如此循环反复，便出现了越来越多的“Jank”。</li>\n</ol>\n<p><strong>为什么 CPU 不能在第二个 16ms 处理绘制工作呢？</strong></p>\n<p>原因是只有两个 buffer，Back buffer正在被GPU用来处理B帧的数据， Frame buffer的内容用于Display的显示，这样两个buffer都被占用，CPU 则无法准备下一帧的数据。那么，如果再提供一个buffer，CPU、GPU 和显示设备都能使用各自的buffer工作，互不影响。</p>\n<h3 id=\"3-3-三缓存\"><a href=\"#3-3-三缓存\" class=\"headerlink\" title=\"3.3 三缓存\"></a><strong>3.3 三缓存</strong></h3><p><strong>三缓存</strong>就是在双缓冲机制基础上增加了一个 Graphic Buffer 缓冲区，这样可以最大限度的利用空闲时间，带来的坏处是多使用的一个 Graphic Buffer 所占用的内存。</p>\n<img src=\"https://cdn.julis.wang/blog/img/ldq7oda57p.jpeg\">\n\n<p>三缓存</p>\n<ol>\n<li>第一个Jank，是不可避免的。但是在第二个 16ms 时间段，CPU&#x2F;GPU 使用 <strong>第三个 Buffer</strong> 完成C帧的计算，虽然还是会多显示一次 A 帧，但后续显示就比较顺畅了，有效避免 Jank 的进一步加剧。</li>\n<li>注意在第3段中，A帧的计算已完成，但是在第4个vsync来的时候才显示，如果是双缓冲，那在第三个vynsc就可以显示了。</li>\n</ol>\n<p><strong>三缓冲有效利用了等待vysnc的时间，减少了jank，但是带来了延迟。</strong> 所以，是不是 Buffer 越多越好呢？这个是否定的，Buffer 正常还是两个，当出现 Jank 后三个足以。</p>\n<p>以上就是Android屏幕刷新的原理了。</p>\n<h2 id=\"四、Choreographer\"><a href=\"#四、Choreographer\" class=\"headerlink\" title=\"四、Choreographer\"></a><strong>四、Choreographer</strong></h2><h3 id=\"4-1-概述\"><a href=\"#4-1-概述\" class=\"headerlink\" title=\"4.1 概述\"></a><strong>4.1 概述</strong></h3><p>上面讲到，Google在Android 4.1系统中对Android Display系统进行了优化：在收到VSync pulse后，将马上开始下一帧的渲染。即<strong>一旦收到VSync通知，CPU和GPU就立刻开始计算然后把数据写入buffer</strong>。本节就来讲 “drawing with VSync” 的实现——<strong>Choreographer</strong>。</p>\n<ul>\n<li>Choreographer，意为 舞蹈编导、编舞者。在这里就是指 对CPU&#x2F;GPU绘制的指导—— 收到VSync信号 才开始绘制，保证绘制拥有完整的16.6ms，避免绘制的随机性。</li>\n<li>Choreographer，是一个Java类，包路径android.view.Choreographer。类注释是“协调动画、输入和绘图的计时”。</li>\n<li>通常 应用层不会直接使用Choreographer，而是使用更高级的API，例如动画和View绘制相关的ValueAnimator.start()、View.invalidate()等。</li>\n<li>业界一般通过Choreographer来监控应用的帧率。</li>\n</ul>\n<h3 id=\"4-2-源码分析\"><a href=\"#4-2-源码分析\" class=\"headerlink\" title=\"4.2 源码分析\"></a><strong>4.2 源码分析</strong></h3><p>学习 Choreographer 可以帮助理解 每帧运行的原理，也可加深对 Handler机制、View绘制流程的理解，这样再去做UI优化、卡顿优化，思路会更清晰。</p>\n<p>好了，下面开始源码分析了~</p>\n<h5 id=\"4-2-1-入口-和-实例创建\"><a href=\"#4-2-1-入口-和-实例创建\" class=\"headerlink\" title=\"4.2.1 入口 和 实例创建\"></a><strong>4.2.1 入口 和 实例创建</strong></h5><p>在<a href=\"https://juejin.cn/post/7076274407416528909\">《Window和WindowManager》</a>、<a href=\"https://blog.csdn.net/allen_xu_2012_new/article/details/131167564\">《Activity的启动过程详解》</a>中介绍过，Activity启动 走完onResume方法后，会进行<strong>window的添加</strong>。window添加过程会 调用ViewRootImpl的setView()方法，setView()方法会调用requestLayout()方法来请求绘制布局，requestLayout()方法内部又会走到scheduleTraversals()方法，最后会走到performTraversals()方法，接着到了我们熟知的测量、布局、绘制三大流程了。</p>\n<p>另外，查看源码发现，当我们使用 ValueAnimator.start()、View.invalidate()时，最后也是走到ViewRootImpl的scheduleTraversals()方法。（View.invalidate()内部会循环获取ViewParent直到ViewRootImpl的invalidateChildInParent()方法，然后走到scheduleTraversals()，可自行查看源码 ）</p>\n<p>即 <strong>所有UI的变化都是走到ViewRootImpl的scheduleTraversals()方法。</strong></p>\n<p>那么问题又来了，scheduleTraversals() 到 performTraversals() 中间 经历了什么呢？是立刻执行吗？答案很显然是否定的，根据我们上面的介绍，在VSync信号到来时才会执行绘制，即performTraversals()方法。下面来瞅瞅这是如何实现的：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//ViewRootImpl.java</span></span><br><span class=\"line\"><span class=\"keyword\">void</span> <span class=\"title function_\">scheduleTraversals</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!mTraversalScheduled) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//此字段保证同时间多次更改只会刷新一次，例如TextView连续两次setText(),也只会走一次绘制流程</span></span><br><span class=\"line\">        mTraversalScheduled = <span class=\"literal\">true</span>;</span><br><span class=\"line\">        <span class=\"comment\">//添加同步屏障，屏蔽同步消息，保证VSync到来立即执行绘制</span></span><br><span class=\"line\">        mTraversalBarrier = mHandler.getLooper().getQueue().postSyncBarrier();</span><br><span class=\"line\">        <span class=\"comment\">//mTraversalRunnable是TraversalRunnable实例，最终走到run()，也即doTraversal();</span></span><br><span class=\"line\">        mChoreographer.postCallback(</span><br><span class=\"line\">                Choreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, <span class=\"literal\">null</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!mUnbufferedInputDispatch) &#123;</span><br><span class=\"line\">            scheduleConsumeBatchedInput();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        notifyRendererOfFramePending();</span><br><span class=\"line\">        pokeDrawLockIfNeeded();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">final</span> <span class=\"keyword\">class</span> <span class=\"title class_\">TraversalRunnable</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Runnable</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        doTraversal();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">final</span> <span class=\"type\">TraversalRunnable</span> <span class=\"variable\">mTraversalRunnable</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">TraversalRunnable</span>();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">void</span> <span class=\"title function_\">doTraversal</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mTraversalScheduled) &#123;</span><br><span class=\"line\">        mTraversalScheduled = <span class=\"literal\">false</span>;</span><br><span class=\"line\">        <span class=\"comment\">//移除同步屏障</span></span><br><span class=\"line\">        mHandler.getLooper().getQueue().removeSyncBarrier(mTraversalBarrier);</span><br><span class=\"line\">        ...</span><br><span class=\"line\">        <span class=\"comment\">//开始三大绘制流程</span></span><br><span class=\"line\">        performTraversals();</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>主要有以下逻辑：</p>\n<ol>\n<li>首先使用mTraversalScheduled字段保证同时间多次更改只会刷新一次，例如TextView连续两次setText()，也只会走一次绘制流程。</li>\n<li>然后把当前线程的<a href=\"https://cloud.tencent.com/product/message-queue-catalog?from_column=20065&from=20065\">消息队列</a>Queue添加了<strong>同步屏障</strong>，这样就屏蔽了正常的同步消息，保证VSync到来后立即执行绘制，而不是要等前面的同步消息。后面会具体分析同步屏障和异步消息的代码逻辑。</li>\n<li>调用了mChoreographer.postCallback()方法，发送一个会在下一帧执行的回调，即<strong>在下一个VSync到来时会执行TraversalRunnable–&gt;doTraversal()—&gt;performTraversals()–&gt;绘制流程</strong>。</li>\n</ol>\n<p>接下来，就是分析的重点——Choreographer。我们先看它的实例mChoreographer，是在ViewRootImpl的构造方法内使用Choreographer.getInstance()创建：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">Choreographer mChoreographer;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//ViewRootImpl实例是在添加window时创建</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"title function_\">ViewRootImpl</span><span class=\"params\">(Context context, Display display)</span> &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    mChoreographer = Choreographer.getInstance();</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们先来看看Choreographer.getInstance()：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Choreographer <span class=\"title function_\">getInstance</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> sThreadInstance.get();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> ThreadLocal&lt;Choreographer&gt; sThreadInstance =</span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">ThreadLocal</span>&lt;Choreographer&gt;() &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">protected</span> Choreographer <span class=\"title function_\">initialValue</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">Looper</span> <span class=\"variable\">looper</span> <span class=\"operator\">=</span> Looper.myLooper();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (looper == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//当前线程要有looper，Choreographer实例需要传入</span></span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">IllegalStateException</span>(<span class=\"string\">&quot;The current thread must have a looper!&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"type\">Choreographer</span> <span class=\"variable\">choreographer</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Choreographer</span>(looper, VSYNC_SOURCE_APP);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (looper == Looper.getMainLooper()) &#123;</span><br><span class=\"line\">            mMainInstance = choreographer;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> choreographer;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>看到这里 如你对Handler机制中looper比较熟悉的话，应该知道 Choreographer和Looper一样 是线程单例的。且当前线程要有looper，Choreographer实例需要传入。接着看看Choreographer构造方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"title function_\">Choreographer</span><span class=\"params\">(Looper looper, <span class=\"type\">int</span> vsyncSource)</span> &#123;</span><br><span class=\"line\">    mLooper = looper;</span><br><span class=\"line\">    <span class=\"comment\">//使用当前线程looper创建 mHandler</span></span><br><span class=\"line\">    mHandler = <span class=\"keyword\">new</span> <span class=\"title class_\">FrameHandler</span>(looper);</span><br><span class=\"line\">    <span class=\"comment\">//USE_VSYNC 4.1以上默认是true，表示 具备接受VSync的能力，这个接受能力就是FrameDisplayEventReceiver</span></span><br><span class=\"line\">    mDisplayEventReceiver = USE_VSYNC</span><br><span class=\"line\">            ? <span class=\"keyword\">new</span> <span class=\"title class_\">FrameDisplayEventReceiver</span>(looper, vsyncSource)</span><br><span class=\"line\">            : <span class=\"literal\">null</span>;</span><br><span class=\"line\">    mLastFrameTimeNanos = Long.MIN_VALUE;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 计算一帧的时间，Android手机屏幕是60Hz的刷新频率，就是16ms</span></span><br><span class=\"line\">    mFrameIntervalNanos = (<span class=\"type\">long</span>)(<span class=\"number\">1000000000</span> / getRefreshRate());</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 创建一个链表类型CallbackQueue的数组，大小为5，</span></span><br><span class=\"line\">    <span class=\"comment\">//也就是数组中有五个链表，每个链表存相同类型的任务：输入、动画、遍历绘制等任务（CALLBACK_INPUT、CALLBACK_ANIMATION、CALLBACK_TRAVERSAL）</span></span><br><span class=\"line\">    mCallbackQueues = <span class=\"keyword\">new</span> <span class=\"title class_\">CallbackQueue</span>[CALLBACK_LAST + <span class=\"number\">1</span>];</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt;= CALLBACK_LAST; i++) &#123;</span><br><span class=\"line\">        mCallbackQueues[i] = <span class=\"keyword\">new</span> <span class=\"title class_\">CallbackQueue</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// b/68769804: For low FPS experiments.</span></span><br><span class=\"line\">    setFPSDivisor(SystemProperties.getInt(ThreadedRenderer.DEBUG_FPS_DIVISOR, <span class=\"number\">1</span>));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>代码中都有注释，创建了一个mHandler、VSync事件接收器mDisplayEventReceiver、任务链表数组mCallbackQueues。FrameHandler、FrameDisplayEventReceiver、CallbackQueue后面会一一说明。</p>\n<h5 id=\"4-2-2-安排任务—postCallback\"><a href=\"#4-2-2-安排任务—postCallback\" class=\"headerlink\" title=\"4.2.2 安排任务—postCallback\"></a><strong>4.2.2 安排任务—postCallback</strong></h5><p>回头看mChoreographer.postCallback(Choreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, null)方法，注意到第一个参数是CALLBACK_TRAVERSAL，表示回调任务的类型，共有以下5种类型：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//输入事件，首先执行</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">CALLBACK_INPUT</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"comment\">//动画，第二执行</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">CALLBACK_ANIMATION</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"comment\">//插入更新的动画，第三执行</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">CALLBACK_INSETS_ANIMATION</span> <span class=\"operator\">=</span> <span class=\"number\">2</span>;</span><br><span class=\"line\"><span class=\"comment\">//绘制，第四执行</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">CALLBACK_TRAVERSAL</span> <span class=\"operator\">=</span> <span class=\"number\">3</span>;</span><br><span class=\"line\"><span class=\"comment\">//提交，最后执行，</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">CALLBACK_COMMIT</span> <span class=\"operator\">=</span> <span class=\"number\">4</span>;</span><br></pre></td></tr></table></figure>\n\n<p>五种类型任务对应存入对应的CallbackQueue中，每当收到 VSYNC 信号时，Choreographer 将首先处理 INPUT 类型的任务，然后是 ANIMATION 类型，最后才是 TRAVERSAL 类型。</p>\n<p>postCallback()内部调用postCallbackDelayed()，接着又调用postCallbackDelayedInternal()，来瞅瞅：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">postCallbackDelayedInternal</span><span class=\"params\">(<span class=\"type\">int</span> callbackType,</span></span><br><span class=\"line\"><span class=\"params\">        Object action, Object token, <span class=\"type\">long</span> delayMillis)</span> &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (mLock) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 当前时间</span></span><br><span class=\"line\">        <span class=\"keyword\">final</span> <span class=\"type\">long</span> <span class=\"variable\">now</span> <span class=\"operator\">=</span> SystemClock.uptimeMillis();</span><br><span class=\"line\">        <span class=\"comment\">// 加上延迟时间</span></span><br><span class=\"line\">        <span class=\"keyword\">final</span> <span class=\"type\">long</span> <span class=\"variable\">dueTime</span> <span class=\"operator\">=</span> now + delayMillis;</span><br><span class=\"line\">        <span class=\"comment\">//取对应类型的CallbackQueue添加任务</span></span><br><span class=\"line\">        mCallbackQueues[callbackType].addCallbackLocked(dueTime, action, token);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (dueTime &lt;= now) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//立即执行</span></span><br><span class=\"line\">            scheduleFrameLocked(now);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">//延迟运行，最终也会走到scheduleFrameLocked()</span></span><br><span class=\"line\">            <span class=\"type\">Message</span> <span class=\"variable\">msg</span> <span class=\"operator\">=</span> mHandler.obtainMessage(MSG_DO_SCHEDULE_CALLBACK, action);</span><br><span class=\"line\">            msg.arg1 = callbackType;</span><br><span class=\"line\">            msg.setAsynchronous(<span class=\"literal\">true</span>);</span><br><span class=\"line\">            mHandler.sendMessageAtTime(msg, dueTime);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>首先取对应类型的CallbackQueue添加任务，action就是mTraversalRunnable，token是null。<strong>CallbackQueue的addCallbackLocked()就是把 dueTime、action、token组装成CallbackRecord后 存入CallbackQueue的下一个节点</strong>，具体代码比较简单，不再跟进。</p>\n<p>然后注意到如果没有延迟会执行scheduleFrameLocked()方法，有延迟就会使用 mHandler发送MSG_DO_SCHEDULE_CALLBACK消息，并且注意到 <strong>使用msg.setAsynchronous(true)把消息设置成异步</strong>，这是因为前面设置了同步屏障，只有异步消息才会执行。我们看下mHandler的对这个消息的处理：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">class</span> <span class=\"title class_\">FrameHandler</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">Handler</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">FrameHandler</span><span class=\"params\">(Looper looper)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">super</span>(looper);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">handleMessage</span><span class=\"params\">(Message msg)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">switch</span> (msg.what) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> MSG_DO_FRAME:</span><br><span class=\"line\">                <span class=\"comment\">// 执行doFrame,即绘制过程</span></span><br><span class=\"line\">                doFrame(System.nanoTime(), <span class=\"number\">0</span>);</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> MSG_DO_SCHEDULE_VSYNC:</span><br><span class=\"line\">                <span class=\"comment\">//申请VSYNC信号，例如当前需要绘制任务时</span></span><br><span class=\"line\">                doScheduleVsync();</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> MSG_DO_SCHEDULE_CALLBACK:</span><br><span class=\"line\">                <span class=\"comment\">//需要延迟的任务，最终还是执行上述两个事件</span></span><br><span class=\"line\">                doScheduleCallback(msg.arg1);</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>直接使用doScheduleCallback方法，看看：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> <span class=\"title function_\">doScheduleCallback</span><span class=\"params\">(<span class=\"type\">int</span> callbackType)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (mLock) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!mFrameScheduled) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">final</span> <span class=\"type\">long</span> <span class=\"variable\">now</span> <span class=\"operator\">=</span> SystemClock.uptimeMillis();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (mCallbackQueues[callbackType].hasDueCallbacksLocked(now)) &#123;</span><br><span class=\"line\">                scheduleFrameLocked(now);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>发现也是走到这里，即延迟运行最终也会走到scheduleFrameLocked()，跟进看看：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">scheduleFrameLocked</span><span class=\"params\">(<span class=\"type\">long</span> now)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!mFrameScheduled) &#123;</span><br><span class=\"line\">        mFrameScheduled = <span class=\"literal\">true</span>;</span><br><span class=\"line\">        <span class=\"comment\">//开启了VSYNC</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (USE_VSYNC) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (DEBUG_FRAMES) &#123;</span><br><span class=\"line\">                Log.d(TAG, <span class=\"string\">&quot;Scheduling next frame on vsync.&quot;</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">//当前执行的线程，是否是mLooper所在线程</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (isRunningOnLooperThreadLocked()) &#123;</span><br><span class=\"line\">                <span class=\"comment\">//申请 VSYNC 信号</span></span><br><span class=\"line\">                scheduleVsyncLocked();</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 若不在，就用mHandler发送消息到原线程，最后还是调用scheduleVsyncLocked方法</span></span><br><span class=\"line\">                <span class=\"type\">Message</span> <span class=\"variable\">msg</span> <span class=\"operator\">=</span> mHandler.obtainMessage(MSG_DO_SCHEDULE_VSYNC);</span><br><span class=\"line\">                msg.setAsynchronous(<span class=\"literal\">true</span>);<span class=\"comment\">//异步</span></span><br><span class=\"line\">                mHandler.sendMessageAtFrontOfQueue(msg);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 如果未开启VSYNC则直接doFrame方法（4.1后默认开启）</span></span><br><span class=\"line\">            <span class=\"keyword\">final</span> <span class=\"type\">long</span> <span class=\"variable\">nextFrameTime</span> <span class=\"operator\">=</span> Math.max(</span><br><span class=\"line\">                    mLastFrameTimeNanos / TimeUtils.NANOS_PER_MS + sFrameDelay, now);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (DEBUG_FRAMES) &#123;</span><br><span class=\"line\">                Log.d(TAG, <span class=\"string\">&quot;Scheduling next frame in &quot;</span> + (nextFrameTime - now) + <span class=\"string\">&quot; ms.&quot;</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"type\">Message</span> <span class=\"variable\">msg</span> <span class=\"operator\">=</span> mHandler.obtainMessage(MSG_DO_FRAME);</span><br><span class=\"line\">            msg.setAsynchronous(<span class=\"literal\">true</span>);<span class=\"comment\">//异步</span></span><br><span class=\"line\">            mHandler.sendMessageAtTime(msg, nextFrameTime);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>如果系统未开启 VSYNC 机制，此时直接发送 MSG_DO_FRAME 消息到 FrameHandler。注意查看上面贴出的 FrameHandler 代码，此时直接执行 doFrame 方法。</li>\n<li>Android 4.1 之后系统默认开启 VSYNC，在 Choreographer 的构造方法会创建一个 FrameDisplayEventReceiver，scheduleVsyncLocked 方法将会通过它申请 VSYNC 信号。</li>\n<li>isRunningOnLooperThreadLocked 方法，其内部根据 Looper 判断是否在原线程，否则发送消息到 FrameHandler。最终还是会调用 scheduleVsyncLocked 方法申请 VSYNC 信号。</li>\n</ol>\n<p>到这里，<strong>FrameHandler的作用很明显里了：发送异步消息（因为前面设置了同步屏障）。有延迟的任务发延迟消息、不在原线程的发到原线程、没开启VSYNC的直接走 doFrame 方法取执行绘制。</strong></p>\n<h5 id=\"4-2-3-申请和接受VSync\"><a href=\"#4-2-3-申请和接受VSync\" class=\"headerlink\" title=\"4.2.3 申请和接受VSync\"></a><strong>4.2.3 申请和接受VSync</strong></h5><p>好了， 接着就看 scheduleVsyncLocked 方法是如何申请 VSYNC 信号的。猜测肯定申请 VSYNC 信号后，信号到来时也是走doFrame() 方法，doFrame()后面再看。先跟进scheduleVsyncLocked():</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">scheduleVsyncLocked</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    mDisplayEventReceiver.scheduleVsync();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>很简单，调用mDisplayEventReceiver的scheduleVsync()方法，mDisplayEventReceiver是Choreographer构造方法中创建，是FrameDisplayEventReceiver 的实例。FrameDisplayEventReceiver是 DisplayEventReceiver 的子类，DisplayEventReceiver 是一个 abstract class：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"title function_\">DisplayEventReceiver</span><span class=\"params\">(Looper looper, <span class=\"type\">int</span> vsyncSource)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (looper == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">IllegalArgumentException</span>(<span class=\"string\">&quot;looper must not be null&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    mMessageQueue = looper.getQueue();</span><br><span class=\"line\">    <span class=\"comment\">// 注册VSYNC信号监听者</span></span><br><span class=\"line\">    mReceiverPtr = nativeInit(<span class=\"keyword\">new</span> <span class=\"title class_\">WeakReference</span>&lt;DisplayEventReceiver&gt;(<span class=\"built_in\">this</span>), mMessageQueue,</span><br><span class=\"line\">            vsyncSource);</span><br><span class=\"line\"></span><br><span class=\"line\">    mCloseGuard.open(<span class=\"string\">&quot;dispose&quot;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在 DisplayEventReceiver 的构造方法会通过 JNI 创建一个 IDisplayEventConnection 的 VSYNC 的监听者。</p>\n<p>FrameDisplayEventReceiver的scheduleVsync()就是在 DisplayEventReceiver中：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">scheduleVsync</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mReceiverPtr == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        Log.w(TAG, <span class=\"string\">&quot;Attempted to schedule a vertical sync pulse but the display event &quot;</span></span><br><span class=\"line\">                + <span class=\"string\">&quot;receiver has already been disposed.&quot;</span>);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 申请VSYNC中断信号，会回调onVsync方法</span></span><br><span class=\"line\">        nativeScheduleVsync(mReceiverPtr);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>那么scheduleVsync()就是使用native方法nativeScheduleVsync()去申请VSYNC信号。这个native方法就看不了了，只需要知道<strong>VSYNC信号的接受回调是onVsync()</strong>，我们直接看onVsync()：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 接收到VSync脉冲时 回调</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> timestampNanos VSync脉冲的时间戳</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> physicalDisplayId Stable display ID that uniquely describes a (display, port) pair.</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> frame 帧号码，自增</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"meta\">@UnsupportedAppUsage</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">onVsync</span><span class=\"params\">(<span class=\"type\">long</span> timestampNanos, <span class=\"type\">long</span> physicalDisplayId, <span class=\"type\">int</span> frame)</span> &#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>具体实现是在FrameDisplayEventReceiver中：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">class</span> <span class=\"title class_\">FrameDisplayEventReceiver</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">DisplayEventReceiver</span></span><br><span class=\"line\">        <span class=\"keyword\">implements</span> <span class=\"title class_\">Runnable</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">boolean</span> mHavePendingVsync;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">long</span> mTimestampNanos;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">int</span> mFrame;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">FrameDisplayEventReceiver</span><span class=\"params\">(Looper looper, <span class=\"type\">int</span> vsyncSource)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">super</span>(looper, vsyncSource);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">onVsync</span><span class=\"params\">(<span class=\"type\">long</span> timestampNanos, <span class=\"type\">long</span> physicalDisplayId, <span class=\"type\">int</span> frame)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// Post the vsync event to the Handler.</span></span><br><span class=\"line\">        <span class=\"comment\">// The idea is to prevent incoming vsync events from completely starving</span></span><br><span class=\"line\">        <span class=\"comment\">// the message queue.  If there are no messages in the queue with timestamps</span></span><br><span class=\"line\">        <span class=\"comment\">// earlier than the frame time, then the vsync event will be processed immediately.</span></span><br><span class=\"line\">        <span class=\"comment\">// Otherwise, messages that predate the vsync event will be handled first.</span></span><br><span class=\"line\">        <span class=\"type\">long</span> <span class=\"variable\">now</span> <span class=\"operator\">=</span> System.nanoTime();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (timestampNanos &gt; now) &#123;</span><br><span class=\"line\">            Log.w(TAG, <span class=\"string\">&quot;Frame time is &quot;</span> + ((timestampNanos - now) * <span class=\"number\">0.000001f</span>)</span><br><span class=\"line\">                    + <span class=\"string\">&quot; ms in the future!  Check that graphics HAL is generating vsync &quot;</span></span><br><span class=\"line\">                    + <span class=\"string\">&quot;timestamps using the correct timebase.&quot;</span>);</span><br><span class=\"line\">            timestampNanos = now;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mHavePendingVsync) &#123;</span><br><span class=\"line\">            Log.w(TAG, <span class=\"string\">&quot;Already have a pending vsync event.  There should only be &quot;</span></span><br><span class=\"line\">                    + <span class=\"string\">&quot;one at a time.&quot;</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            mHavePendingVsync = <span class=\"literal\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        mTimestampNanos = timestampNanos;</span><br><span class=\"line\">        mFrame = frame;</span><br><span class=\"line\">        <span class=\"comment\">//将本身作为runnable传入msg， 发消息后 会走run()，即doFrame()，也是异步消息</span></span><br><span class=\"line\">        <span class=\"type\">Message</span> <span class=\"variable\">msg</span> <span class=\"operator\">=</span> Message.obtain(mHandler, <span class=\"built_in\">this</span>);</span><br><span class=\"line\">        msg.setAsynchronous(<span class=\"literal\">true</span>);</span><br><span class=\"line\">        mHandler.sendMessageAtTime(msg, timestampNanos / TimeUtils.NANOS_PER_MS);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        mHavePendingVsync = <span class=\"literal\">false</span>;</span><br><span class=\"line\">        doFrame(mTimestampNanos, mFrame);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>onVsync()中，将接收器本身作为runnable传入异步消息msg，并使用mHandler发送msg，最终执行的就是doFrame()方法了。</p>\n<p>注意一点是，<strong>onVsync()方法中只是使用mHandler发送消息到MessageQueue中，不一定是立刻执行，如何MessageQueue中前面有较为耗时的操作，那么就要等完成，才会执行本次的doFrame()</strong>。</p>\n<h5 id=\"4-2-4-doFrame\"><a href=\"#4-2-4-doFrame\" class=\"headerlink\" title=\"4.2.4 doFrame\"></a><strong>4.2.4 doFrame</strong></h5><p>和上面猜测一样，申请VSync信号接收到后确实是走 doFrame()方法，那么就来看看Choreographer的doFrame()：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> <span class=\"title function_\">doFrame</span><span class=\"params\">(<span class=\"type\">long</span> frameTimeNanos, <span class=\"type\">int</span> frame)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"type\">long</span> startNanos;</span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (mLock) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!mFrameScheduled) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span>; <span class=\"comment\">// no work to do</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        ...</span><br><span class=\"line\">        <span class=\"comment\">// 预期执行时间</span></span><br><span class=\"line\">        <span class=\"type\">long</span> <span class=\"variable\">intendedFrameTimeNanos</span> <span class=\"operator\">=</span> frameTimeNanos;</span><br><span class=\"line\">        startNanos = System.nanoTime();</span><br><span class=\"line\">        <span class=\"comment\">// 超时时间是否超过一帧的时间（这是因为MessageQueue虽然添加了同步屏障，但是还是有正在执行的同步任务，导致doFrame延迟执行了）</span></span><br><span class=\"line\">        <span class=\"keyword\">final</span> <span class=\"type\">long</span> <span class=\"variable\">jitterNanos</span> <span class=\"operator\">=</span> startNanos - frameTimeNanos;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (jitterNanos &gt;= mFrameIntervalNanos) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 计算掉帧数</span></span><br><span class=\"line\">            <span class=\"keyword\">final</span> <span class=\"type\">long</span> <span class=\"variable\">skippedFrames</span> <span class=\"operator\">=</span> jitterNanos / mFrameIntervalNanos;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (skippedFrames &gt;= SKIPPED_FRAME_WARNING_LIMIT) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 掉帧超过30帧打印Log提示</span></span><br><span class=\"line\">                Log.i(TAG, <span class=\"string\">&quot;Skipped &quot;</span> + skippedFrames + <span class=\"string\">&quot; frames!  &quot;</span></span><br><span class=\"line\">                        + <span class=\"string\">&quot;The application may be doing too much work on its main thread.&quot;</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">final</span> <span class=\"type\">long</span> <span class=\"variable\">lastFrameOffset</span> <span class=\"operator\">=</span> jitterNanos % mFrameIntervalNanos;</span><br><span class=\"line\">            ...</span><br><span class=\"line\">            frameTimeNanos = startNanos - lastFrameOffset;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        ...</span><br><span class=\"line\"></span><br><span class=\"line\">        mFrameInfo.setVsync(intendedFrameTimeNanos, frameTimeNanos);</span><br><span class=\"line\">        <span class=\"comment\">// Frame标志位恢复</span></span><br><span class=\"line\">        mFrameScheduled = <span class=\"literal\">false</span>;</span><br><span class=\"line\">        <span class=\"comment\">// 记录最后一帧时间</span></span><br><span class=\"line\">        mLastFrameTimeNanos = frameTimeNanos;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 按类型顺序 执行任务</span></span><br><span class=\"line\">        Trace.traceBegin(Trace.TRACE_TAG_VIEW, <span class=\"string\">&quot;Choreographer#doFrame&quot;</span>);</span><br><span class=\"line\">        AnimationUtils.lockAnimationClock(frameTimeNanos / TimeUtils.NANOS_PER_MS);</span><br><span class=\"line\"></span><br><span class=\"line\">        mFrameInfo.markInputHandlingStart();</span><br><span class=\"line\">        doCallbacks(Choreographer.CALLBACK_INPUT, frameTimeNanos);</span><br><span class=\"line\"></span><br><span class=\"line\">        mFrameInfo.markAnimationsStart();</span><br><span class=\"line\">        doCallbacks(Choreographer.CALLBACK_ANIMATION, frameTimeNanos);</span><br><span class=\"line\">        doCallbacks(Choreographer.CALLBACK_INSETS_ANIMATION, frameTimeNanos);</span><br><span class=\"line\"></span><br><span class=\"line\">        mFrameInfo.markPerformTraversalsStart();</span><br><span class=\"line\">        doCallbacks(Choreographer.CALLBACK_TRAVERSAL, frameTimeNanos);</span><br><span class=\"line\"></span><br><span class=\"line\">        doCallbacks(Choreographer.CALLBACK_COMMIT, frameTimeNanos);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        AnimationUtils.unlockAnimationClock();</span><br><span class=\"line\">        Trace.traceEnd(Trace.TRACE_TAG_VIEW);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面都有注释了很好理解，接着看任务的具体执行doCallbacks 方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> <span class=\"title function_\">doCallbacks</span><span class=\"params\">(<span class=\"type\">int</span> callbackType, <span class=\"type\">long</span> frameTimeNanos)</span> &#123;</span><br><span class=\"line\">    CallbackRecord callbacks;</span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (mLock) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">final</span> <span class=\"type\">long</span> <span class=\"variable\">now</span> <span class=\"operator\">=</span> System.nanoTime();</span><br><span class=\"line\">        <span class=\"comment\">// 根据指定的类型CallbackkQueue中查找到达执行时间的CallbackRecord</span></span><br><span class=\"line\">        callbacks = mCallbackQueues[callbackType].extractDueCallbacksLocked(now / TimeUtils.NANOS_PER_MS);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (callbacks == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        mCallbacksRunning = <span class=\"literal\">true</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//提交任务类型</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (callbackType == Choreographer.CALLBACK_COMMIT) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">final</span> <span class=\"type\">long</span> <span class=\"variable\">jitterNanos</span> <span class=\"operator\">=</span> now - frameTimeNanos;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (jitterNanos &gt;= <span class=\"number\">2</span> * mFrameIntervalNanos) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">final</span> <span class=\"type\">long</span> <span class=\"variable\">lastFrameOffset</span> <span class=\"operator\">=</span> jitterNanos % mFrameIntervalNanos</span><br><span class=\"line\">                        + mFrameIntervalNanos;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (DEBUG_JANK) &#123;</span><br><span class=\"line\">                    Log.d(TAG, <span class=\"string\">&quot;Commit callback delayed by &quot;</span> + (jitterNanos * <span class=\"number\">0.000001f</span>)</span><br><span class=\"line\">                            + <span class=\"string\">&quot; ms which is more than twice the frame interval of &quot;</span></span><br><span class=\"line\">                            + (mFrameIntervalNanos * <span class=\"number\">0.000001f</span>) + <span class=\"string\">&quot; ms!  &quot;</span></span><br><span class=\"line\">                            + <span class=\"string\">&quot;Setting frame time to &quot;</span> + (lastFrameOffset * <span class=\"number\">0.000001f</span>)</span><br><span class=\"line\">                            + <span class=\"string\">&quot; ms in the past.&quot;</span>);</span><br><span class=\"line\">                    mDebugPrintNextFrameTimeDelta = <span class=\"literal\">true</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                frameTimeNanos = now - lastFrameOffset;</span><br><span class=\"line\">                mLastFrameTimeNanos = frameTimeNanos;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 迭代执行队列所有任务</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">CallbackRecord</span> <span class=\"variable\">c</span> <span class=\"operator\">=</span> callbacks; c != <span class=\"literal\">null</span>; c = c.next) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 回调CallbackRecord的run，其内部回调Callback的run</span></span><br><span class=\"line\">            c.run(frameTimeNanos);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span> (mLock) &#123;</span><br><span class=\"line\">            mCallbacksRunning = <span class=\"literal\">false</span>;</span><br><span class=\"line\">            <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">final</span> <span class=\"type\">CallbackRecord</span> <span class=\"variable\">next</span> <span class=\"operator\">=</span> callbacks.next;</span><br><span class=\"line\">                <span class=\"comment\">//回收CallbackRecord</span></span><br><span class=\"line\">                recycleCallbackLocked(callbacks);</span><br><span class=\"line\">                callbacks = next;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">while</span> (callbacks != <span class=\"literal\">null</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>主要内容就是取对应任务类型的队列，遍历队列执行所有任务，执行任务是 CallbackRecord的 run 方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">class</span> <span class=\"title class_\">CallbackRecord</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> CallbackRecord next;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">long</span> dueTime;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> Object action; <span class=\"comment\">// Runnable or FrameCallback</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Object token;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@UnsupportedAppUsage</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">(<span class=\"type\">long</span> frameTimeNanos)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (token == FRAME_CALLBACK_TOKEN) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 通过postFrameCallback 或 postFrameCallbackDelayed，会执行这里</span></span><br><span class=\"line\">            ((FrameCallback)action).doFrame(frameTimeNanos);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">//取出Runnable执行run()</span></span><br><span class=\"line\">            ((Runnable)action).run();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>前面看到mChoreographer.postCallback传的token是null，所以取出action，就是Runnable，执行run()，这里的action就是 ViewRootImpl 发起的绘制任务mTraversalRunnable了，那么<strong>这样整个逻辑就闭环了</strong>。</p>\n<p>那么 啥时候 token &#x3D;&#x3D; FRAME_CALLBACK_TOKEN 呢？答案是Choreographer的postFrameCallback()方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">postFrameCallback</span><span class=\"params\">(FrameCallback callback)</span> &#123;</span><br><span class=\"line\">    postFrameCallbackDelayed(callback, <span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">postFrameCallbackDelayed</span><span class=\"params\">(FrameCallback callback, <span class=\"type\">long</span> delayMillis)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (callback == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">IllegalArgumentException</span>(<span class=\"string\">&quot;callback must not be null&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//也是走到是postCallbackDelayedInternal，并且注意是CALLBACK_ANIMATION类型，</span></span><br><span class=\"line\">    <span class=\"comment\">//token是FRAME_CALLBACK_TOKEN，action就是FrameCallback</span></span><br><span class=\"line\">    postCallbackDelayedInternal(CALLBACK_ANIMATION,</span><br><span class=\"line\">            callback, FRAME_CALLBACK_TOKEN, delayMillis);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">FrameCallback</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">doFrame</span><span class=\"params\">(<span class=\"type\">long</span> frameTimeNanos)</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可以看到postFrameCallback()传入的是FrameCallback实例，接口FrameCallback只有一个doFrame()方法。并且也是走到postCallbackDelayedInternal，FrameCallback实例作为action传入，token则是FRAME_CALLBACK_TOKEN，并且任务是CALLBACK_ANIMATION类型。</p>\n<p><strong>Choreographer的postFrameCallback()通常用来计算丢帧情况</strong>，使用方式如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">      <span class=\"comment\">//Application.java</span></span><br><span class=\"line\">       <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">onCreate</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">           <span class=\"built_in\">super</span>.onCreate();</span><br><span class=\"line\">           <span class=\"comment\">//在Application中使用postFrameCallback</span></span><br><span class=\"line\">           Choreographer.getInstance().postFrameCallback(<span class=\"keyword\">new</span> <span class=\"title class_\">FPSFrameCallback</span>(System.nanoTime()));</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">FPSFrameCallback</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Choreographer</span>.FrameCallback &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">String</span> <span class=\"variable\">TAG</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;FPS_TEST&quot;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">long</span> <span class=\"variable\">mLastFrameTimeNanos</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">long</span> mFrameIntervalNanos;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">FPSFrameCallback</span><span class=\"params\">(<span class=\"type\">long</span> lastFrameTimeNanos)</span> &#123;</span><br><span class=\"line\">        mLastFrameTimeNanos = lastFrameTimeNanos;</span><br><span class=\"line\">        mFrameIntervalNanos = (<span class=\"type\">long</span>)(<span class=\"number\">1000000000</span> / <span class=\"number\">60.0</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">doFrame</span><span class=\"params\">(<span class=\"type\">long</span> frameTimeNanos)</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//初始化时间</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mLastFrameTimeNanos == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            mLastFrameTimeNanos = frameTimeNanos;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> <span class=\"type\">long</span> <span class=\"variable\">jitterNanos</span> <span class=\"operator\">=</span> frameTimeNanos - mLastFrameTimeNanos;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (jitterNanos &gt;= mFrameIntervalNanos) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">final</span> <span class=\"type\">long</span> <span class=\"variable\">skippedFrames</span> <span class=\"operator\">=</span> jitterNanos / mFrameIntervalNanos;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(skippedFrames&gt;<span class=\"number\">30</span>)&#123;</span><br><span class=\"line\">                <span class=\"comment\">//丢帧30以上打印日志</span></span><br><span class=\"line\">                Log.i(TAG, <span class=\"string\">&quot;Skipped &quot;</span> + skippedFrames + <span class=\"string\">&quot; frames!  &quot;</span></span><br><span class=\"line\">                        + <span class=\"string\">&quot;The application may be doing too much work on its main thread.&quot;</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        mLastFrameTimeNanos=frameTimeNanos;</span><br><span class=\"line\">        <span class=\"comment\">//注册下一帧回调</span></span><br><span class=\"line\">        Choreographer.getInstance().postFrameCallback(<span class=\"built_in\">this</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"4-2-5-小结\"><a href=\"#4-2-5-小结\" class=\"headerlink\" title=\"4.2.5 小结\"></a><strong>4.2.5 小结</strong></h5><p>使用Choreographer的postCallback()、postFrameCallback() 作用理解：发送任务 存队列中，监听VSync信号，当前VSync到来时 会使用mHandler发送异步message，这个message的Runnable就是队列中的所有任务。</p>\n<p>好了，Choreographer整个代码逻辑都讲完了，引用《Android 之 Choreographer 详细分析》的流程图：</p>\n<p>原文流程图为：<a href=\"https://i-blog.csdnimg.cn/blog_migrate/5ff22e98afde4ff780f8a291d1081619.png\">Android 之 Choreographer</a>，但并不是很形象，引用另一张流程图：</p>\n<img src=\"https://cdn.julis.wang/blog/img/aab4273a0af898dcc9bb0fdcc0447b5a.png\">\n<h2 id=\"六、疑问解答\"><a href=\"#六、疑问解答\" class=\"headerlink\" title=\"六、疑问解答\"></a><strong>六、疑问解答</strong></h2><ol>\n<li><strong>丢帧</strong>(掉帧) ，是说 这一帧延迟显示 还是丢弃不再显示 ？ 答：延迟显示，因为缓存交换的时机只能等下一个VSync了。</li>\n<li>布局层级较多&#x2F;主线程耗时 是如何造成 丢帧的呢？ 答：布局层级较多&#x2F;主线程耗时 会影响CPU&#x2F;GPU的执行时间，大于16.6ms时只能等下一个VSync了。</li>\n<li>16.6ms刷新一次 是啥意思？是每16.6ms都走一次 measure&#x2F;layout&#x2F;draw ？ 答：屏幕的固定刷新频率是60Hz，即16.6ms。不是每16.6ms都走一次 measure&#x2F;layout&#x2F;draw，而是有绘制任务才会走，并且绘制时间间隔是取决于布局复杂度及主线程耗时。</li>\n<li>measure&#x2F;layout&#x2F;draw 走完，界面就立刻刷新了吗? 答：不是。measure&#x2F;layout&#x2F;draw 走完后 会在VSync到来时进行缓存交换和刷新。</li>\n<li>如果界面没动静止了，还会刷新吗？ 答：屏幕会固定没16.6ms刷新，但CPU&#x2F;GPU不走绘制流程。见下面的SysTrace图。</li>\n<li>可能你知道<strong>VSYNC</strong>，这个具体指啥？在屏幕刷新中如何工作的？ 答：当扫描完一个屏幕后，设备需要重新回到第一行以进入下一次的循环，此时会出现的vertical sync pulse（垂直同步脉冲）来保证双缓冲在最佳时间点才进行交换。并且Android4.1后 CPU&#x2F;GPU的绘制是在VSYNC到来时开始。</li>\n<li>可能你还听过屏幕刷新使用 <strong>双缓存</strong>、<strong>三缓存</strong>，这又是啥意思呢？ 答：双缓存是Back buffer、Frame buffer，用于解决画面撕裂。三缓存增加一个Back buffer，用于减少Jank。</li>\n<li>可能你还听过神秘的<strong>Choreographer</strong>，这又是干啥的？ 答：用于实现——“CPU&#x2F;GPU的绘制是在VSYNC到来时开始”。</li>\n</ol>\n","categories":[{"name":"技术文章","slug":"technology","api":"api/categories/technology.json"}],"tags":[{"name":"安卓","slug":"Android","api":"api/tags/Android.json"}],"api":"api/posts/2025/02/24/Android屏幕刷新机制.json"},{"title":"从Android返回键退出和直接杀死进程退出说起","slug":"从Android返回键退出和直接杀死进程退出说起","date":"2020-09-09T01:31:00.000Z","updated":"2025-05-20T11:46:57.000Z","comments":true,"url":"2020/09/09/从Android返回键退出和直接杀死进程退出说起/","excerpt":"<p>最近开发的时候，使用了一个单例模式，当我返回键退出App，再重新启动，发现App的确是从首页启动，但还没有执行为单例类设置数值的位置。可是！断点调试的时候发现这时候已经有了一个数据，并且是上一次运行留下的数据，当时觉得很神奇，明明根Activity已经执行了OnDestroy()，而且再启动的确是从首页过来的，讲道理应该是“everything will be new”，但是单例里面的数据仍然存在，这可是为什么呢？</p>\n<p>Google搜了一下，噢！恍然大悟，看到这一块的知识很久没有用就忘掉了，或者说对运行机制相关还不太熟悉吧，所以在此重新整理总结一份。</p>\n<h4 id=\"返回键退出和直接杀死进程退出的区别？\"><a href=\"#返回键退出和直接杀死进程退出的区别？\" class=\"headerlink\" title=\"返回键退出和直接杀死进程退出的区别？\"></a>返回键退出和直接杀死进程退出的区别？</h4><p><strong>直接杀死退出</strong>：所有的内存都会被回收，重新启动应用程序时，会重新调用Application的<code>OnCreate()</code>方法，会调用onSaveInstanceState方法。</p>\n<p><strong>返回键退出程序</strong>：退出程序后，一些加载过的静态变量并没有被回收，重新启动也不需要调用Application的OnCreate()方法。</p>\n<p>于是我们就知道，静态变量并没有被回收，而我们的单例模式实例就是静态变量，没有被回收，于是我们就知道为什么单例模式数据还存在了，于是在响应的位置对其数据进行释放。可是 why？这两者的差异究竟是什么导致的？我们要知其然，也要知其所以然。</p>\n<h4 id=\"关于直接杀死进程\"><a href=\"#关于直接杀死进程\" class=\"headerlink\" title=\"关于直接杀死进程\"></a>关于直接杀死进程</h4><p>这里我们应该很好去理解，Android中的每一个App都是运行在自己VM实例之中(沙盒)。每一个VM实例在linux中又是一个单独的进程，通过任务管理杀掉一个进程，那么对应进程里面的数据全部被回收掉。</p>\n<h4 id=\"关于返回键退出\"><a href=\"#关于返回键退出\" class=\"headerlink\" title=\"关于返回键退出\"></a>关于返回键退出</h4><p>通过对源码的追溯，如果不对onBackPressed()做特殊的处理，无论是AppCompatActivity还是android.app.Activity，发现都会通过执行onBackPressed(),最后到Activity的finish()方法，也就是说当App退出到根的时候，最终只是执行的是当前App根Activity的finish()方法，整个App“依然在运行”，只是看不到界面了，那么也就是说，如果在App中运行的Service之类的后台任务并没结束，仍然在运行。</p>\n<p>那为什么单例模里面的静态变量没有回收呢？如果问你的话，你怎么答？emmmmm……因为……它没有被销毁嘛，所以它还在。当然不能这么回答了，需要用理论依据来解释。</p>\n<h4 id=\"关于方法区与静态变量\"><a href=\"#关于方法区与静态变量\" class=\"headerlink\" title=\"关于方法区与静态变量\"></a>关于方法区与静态变量</h4><p>我们知道静态变量存在与JVM的方法区中，静态变量在类被加载的时候分配内存，Java虚拟机规范中说过可以不要求虚拟机在方法区实现垃圾收集，如下图所示：</p>\n<img src=\"https://cdn.julis.wang/blog/img/20200908231258604.png\">\n<p>那么我们是不是可以理解为方法区中不会进行垃圾回收？查到来自《深入理解Java虚拟机》中的解释：</p>\n<blockquote>\n<p>很多人以为方法区（或者HotSopt 虚拟机中的永久代）是没有垃圾收集的，Java虚拟机规范中确实说过可以不要求虚拟机在方法区实现垃圾收集，而且性价比一般较低，在对的新生代生一般能回收70%~95%的空间，而永久代远低于此。</p>\n<p>永久代的垃圾手机主要回收两部分内容：<strong>废弃常量</strong>和<strong>无用的类</strong>。 回收废弃常量与回收Java堆中的对象非常相似。以常量池中字面量的回收为例，若字符串“abc”已经进入常量池中，但当前系统没有任何String对象引用常量池中的“abc”常量，也没有其他地方引用该字面量，若发生内存回收，且必要的话，该“abc”就会被系统清理出常量池。常量池中其他的类（接口）、方法、字段的符号引用与此类似。</p>\n<p>无用的类需要满足3个条件：</p>\n<p>（1）该类所有的实例都已经被回收，即Java堆中不存在该类的任何实例；<br>（2）加载该类的ClassLoader已经被回收；<br>（3）该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</p>\n</blockquote>\n<p>那么对于我们的静态变量来说，如果不是我们手动处理的话设置实例为null的话，或其他操作的话，那么就不会满足上面的条件。那么静态变量会在什么时候被销毁呢？答案很简单了就：**静态变量在类被卸载的时候销毁，类在什么时候被卸载？在进程结束的时候。**那么这也自然能解释我最开始遇到的情况了，返回键返回结束App后进程并没有结束，当下一次再启动App的时候，进程并没有销毁而，因是同一个进程，所以单例中的数据依然存在。</p>\n","cover":null,"images":["https://cdn.julis.wang/blog/img/20200908231258604.png"],"content":"<p>最近开发的时候，使用了一个单例模式，当我返回键退出App，再重新启动，发现App的确是从首页启动，但还没有执行为单例类设置数值的位置。可是！断点调试的时候发现这时候已经有了一个数据，并且是上一次运行留下的数据，当时觉得很神奇，明明根Activity已经执行了OnDestroy()，而且再启动的确是从首页过来的，讲道理应该是“everything will be new”，但是单例里面的数据仍然存在，这可是为什么呢？</p>\n<p>Google搜了一下，噢！恍然大悟，看到这一块的知识很久没有用就忘掉了，或者说对运行机制相关还不太熟悉吧，所以在此重新整理总结一份。</p>\n<h4 id=\"返回键退出和直接杀死进程退出的区别？\"><a href=\"#返回键退出和直接杀死进程退出的区别？\" class=\"headerlink\" title=\"返回键退出和直接杀死进程退出的区别？\"></a>返回键退出和直接杀死进程退出的区别？</h4><p><strong>直接杀死退出</strong>：所有的内存都会被回收，重新启动应用程序时，会重新调用Application的<code>OnCreate()</code>方法，会调用onSaveInstanceState方法。</p>\n<p><strong>返回键退出程序</strong>：退出程序后，一些加载过的静态变量并没有被回收，重新启动也不需要调用Application的OnCreate()方法。</p>\n<p>于是我们就知道，静态变量并没有被回收，而我们的单例模式实例就是静态变量，没有被回收，于是我们就知道为什么单例模式数据还存在了，于是在响应的位置对其数据进行释放。可是 why？这两者的差异究竟是什么导致的？我们要知其然，也要知其所以然。</p>\n<h4 id=\"关于直接杀死进程\"><a href=\"#关于直接杀死进程\" class=\"headerlink\" title=\"关于直接杀死进程\"></a>关于直接杀死进程</h4><p>这里我们应该很好去理解，Android中的每一个App都是运行在自己VM实例之中(沙盒)。每一个VM实例在linux中又是一个单独的进程，通过任务管理杀掉一个进程，那么对应进程里面的数据全部被回收掉。</p>\n<h4 id=\"关于返回键退出\"><a href=\"#关于返回键退出\" class=\"headerlink\" title=\"关于返回键退出\"></a>关于返回键退出</h4><p>通过对源码的追溯，如果不对onBackPressed()做特殊的处理，无论是AppCompatActivity还是android.app.Activity，发现都会通过执行onBackPressed(),最后到Activity的finish()方法，也就是说当App退出到根的时候，最终只是执行的是当前App根Activity的finish()方法，整个App“依然在运行”，只是看不到界面了，那么也就是说，如果在App中运行的Service之类的后台任务并没结束，仍然在运行。</p>\n<p>那为什么单例模里面的静态变量没有回收呢？如果问你的话，你怎么答？emmmmm……因为……它没有被销毁嘛，所以它还在。当然不能这么回答了，需要用理论依据来解释。</p>\n<h4 id=\"关于方法区与静态变量\"><a href=\"#关于方法区与静态变量\" class=\"headerlink\" title=\"关于方法区与静态变量\"></a>关于方法区与静态变量</h4><p>我们知道静态变量存在与JVM的方法区中，静态变量在类被加载的时候分配内存，Java虚拟机规范中说过可以不要求虚拟机在方法区实现垃圾收集，如下图所示：</p>\n<img src=\"https://cdn.julis.wang/blog/img/20200908231258604.png\">\n<p>那么我们是不是可以理解为方法区中不会进行垃圾回收？查到来自《深入理解Java虚拟机》中的解释：</p>\n<blockquote>\n<p>很多人以为方法区（或者HotSopt 虚拟机中的永久代）是没有垃圾收集的，Java虚拟机规范中确实说过可以不要求虚拟机在方法区实现垃圾收集，而且性价比一般较低，在对的新生代生一般能回收70%~95%的空间，而永久代远低于此。</p>\n<p>永久代的垃圾手机主要回收两部分内容：<strong>废弃常量</strong>和<strong>无用的类</strong>。 回收废弃常量与回收Java堆中的对象非常相似。以常量池中字面量的回收为例，若字符串“abc”已经进入常量池中，但当前系统没有任何String对象引用常量池中的“abc”常量，也没有其他地方引用该字面量，若发生内存回收，且必要的话，该“abc”就会被系统清理出常量池。常量池中其他的类（接口）、方法、字段的符号引用与此类似。</p>\n<p>无用的类需要满足3个条件：</p>\n<p>（1）该类所有的实例都已经被回收，即Java堆中不存在该类的任何实例；<br>（2）加载该类的ClassLoader已经被回收；<br>（3）该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</p>\n</blockquote>\n<p>那么对于我们的静态变量来说，如果不是我们手动处理的话设置实例为null的话，或其他操作的话，那么就不会满足上面的条件。那么静态变量会在什么时候被销毁呢？答案很简单了就：**静态变量在类被卸载的时候销毁，类在什么时候被卸载？在进程结束的时候。**那么这也自然能解释我最开始遇到的情况了，返回键返回结束App后进程并没有结束，当下一次再启动App的时候，进程并没有销毁而，因是同一个进程，所以单例中的数据依然存在。</p>\n","categories":[{"name":"技术文章","slug":"technology","api":"api/categories/technology.json"}],"tags":[{"name":"安卓","slug":"Android","api":"api/tags/Android.json"}],"api":"api/posts/2020/09/09/从Android返回键退出和直接杀死进程退出说起.json"},{"title":"Android监听截屏事件之媒体读取的探索","slug":"Android监听截屏事件之媒体读取的探索","date":"2019-07-02T09:58:00.000Z","updated":"2025-05-20T11:46:57.000Z","comments":true,"url":"2019/07/02/Android监听截屏事件之媒体读取的探索/","excerpt":"<p>最近做了一个需求：监听用户截屏，然后生成相关海报。<br>参考了<a href=\"https://blog.csdn.net/xietansheng/article/details/52692163\" title=\"Android 截屏事件监听\">Android 截屏事件监听</a>的文章，大致思路是：</p>\n<p>1、利用ContentObserver用来监听指定Uri的所有资源变化,当媒体库中有相关图片新增的时候，则发送相关的通知。</p>\n<p>2、得到回调的Uri后，借助ContentResolver在媒体数据库中查询最后一条数据</p>\n<p>3、对数据做一些过滤。比如短时间重复截屏的情况以及其他App也插入了媒体文件等情况做处理。</p>\n<p>不过有一些适配性的问题：</p>\n<p>1、截屏后读取文件数据库后获取到件的绝对路径后，利用“screenshot”等关键字判断是否是截屏图片，并不能适配所有手机截屏的命名规则，以及其他应用同时间产生带有“screenshot”等关键词的文件也会有问题。</p>\n<p>2、在某些型号手机中(现遇到Vivo)从数据库中读取的文件并不是获取到的最新的截屏文件，而且其他目录的文件，这里就有些难以理解了，所以今天取探究一下媒体数据库的读取。</p>\n<p>其中ContentObserver如下代码所示：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">   * 媒体内容观察者(观察媒体数据库的改变)</span></span><br><span class=\"line\"><span class=\"comment\">   */</span></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">class</span> <span class=\"title class_\">MediaContentObserver</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">ContentObserver</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">private</span> Uri mContentUri;</span><br><span class=\"line\">      <span class=\"keyword\">public</span> <span class=\"title function_\">MediaContentObserver</span><span class=\"params\">(Uri contentUri, Handler handler)</span> &#123;</span><br><span class=\"line\">          <span class=\"built_in\">super</span>(handler);</span><br><span class=\"line\">          mContentUri = contentUri;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      [<span class=\"meta\">@Override</span>](https:<span class=\"comment\">//my.oschina.net/u/1162528)</span></span><br><span class=\"line\">      <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">onChange</span><span class=\"params\">(<span class=\"type\">boolean</span> selfChange)</span> &#123;</span><br><span class=\"line\">          <span class=\"built_in\">super</span>.onChange(selfChange);</span><br><span class=\"line\">          handleMediaContentChange(mContentUri);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<p>其中获取最后一次更新的媒体文件时的代码(为便于查看 删除了判空处理代码)：<br> <figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">\t<span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">    * 处理媒体数据库的内容改变</span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">   <span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">handleMediaContentChange</span><span class=\"params\">(Uri contentUri)</span> &#123;</span><br><span class=\"line\">       <span class=\"type\">Cursor</span> <span class=\"variable\">cursor</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">       <span class=\"comment\">/** 读取媒体数据库时需要读取的列 */</span></span><br><span class=\"line\">       <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String[] MEDIA_PROJECTIONS =  &#123;</span><br><span class=\"line\">           MediaStore.Images.ImageColumns.DATA,</span><br><span class=\"line\">           MediaStore.Images.ImageColumns.DATE_TAKEN &#125;;</span><br><span class=\"line\">       <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">           <span class=\"comment\">// 数据改变时查询数据库中最后加入的一条数据</span></span><br><span class=\"line\">           cursor = mContext.getContentResolver().query(</span><br><span class=\"line\">                   contentUri,</span><br><span class=\"line\">                    MEDIA_PROJECTIONS,</span><br><span class=\"line\">                   <span class=\"literal\">null</span>,</span><br><span class=\"line\">                   <span class=\"literal\">null</span>,</span><br><span class=\"line\">                   MediaStore.Images.ImageColumns.DATE_ADDED + <span class=\"string\">&quot; desc limit 1&quot;</span></span><br><span class=\"line\">           );</span><br><span class=\"line\">           <span class=\"comment\">// 获取各列的索引</span></span><br><span class=\"line\">           <span class=\"type\">int</span> <span class=\"variable\">dataIndex</span> <span class=\"operator\">=</span> cursor.getColumnIndex(MediaStore.Images.ImageColumns.DATA);</span><br><span class=\"line\">           <span class=\"type\">int</span> <span class=\"variable\">dateTakenIndex</span> <span class=\"operator\">=</span> cursor.getColumnIndex(MediaStore.Images.ImageColumns.DATE_TAKEN);</span><br><span class=\"line\"></span><br><span class=\"line\">           <span class=\"comment\">// 获取行数据</span></span><br><span class=\"line\">           <span class=\"type\">String</span> <span class=\"variable\">data</span> <span class=\"operator\">=</span> cursor.getString(dataIndex);</span><br><span class=\"line\">           <span class=\"type\">long</span> <span class=\"variable\">dateTaken</span> <span class=\"operator\">=</span> cursor.getLong(dateTakenIndex);</span><br><span class=\"line\"></span><br><span class=\"line\">           <span class=\"comment\">// 处理获取到的第一行数据</span></span><br><span class=\"line\">           handleMediaRowData(data, dateTaken);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>这次的目的主要探究的是从数据库获取相关信息的过程</p>\n<p><strong>1、Android 的多媒体如何存储？</strong></p>\n<p>Android的多媒体文件主要存储在 &#x2F;data&#x2F;data&#x2F;com.android.providers.media&#x2F;databases 目录下，该目录下有连个db文件：</p>\n<p>内部存储数据库文件：internal.db</p>\n<p>存储卡数据库：external-XXXX.db</p>\n<p>媒体文件的操作主要是围绕着这两个数据库来进行，这两个数据库的结构是一样的。</p>\n<p>这两个数据库包含这些表：<br>album_art 、audio 、search 、album_info 、audio_genres、 searchhelpertitle、albums、 audio_genres_map、 thumbnails、<br>android_metadata、 audio_meta、 video、artist_info 、audio_playlists 、videothumbnails、artists 、audio_playlists_map、<br>artists_albums_map 、images</p>\n<p><strong>2、表的结构</strong><br>对于Images表：主要存储images信息。表结构如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">CREATE TABLE <span class=\"title function_\">images</span> <span class=\"params\">(</span></span><br><span class=\"line\"><span class=\"params\">   _id INTEGER PRIMARY KEY, </span></span><br><span class=\"line\"><span class=\"params\">   _data TEXT,</span></span><br><span class=\"line\"><span class=\"params\">   _size INTEGER,</span></span><br><span class=\"line\"><span class=\"params\">   _display_name TEXT,</span></span><br><span class=\"line\"><span class=\"params\">   mime_type TEXT,</span></span><br><span class=\"line\"><span class=\"params\">   title TEXT, </span></span><br><span class=\"line\"><span class=\"params\">   date_added INTEGER, </span></span><br><span class=\"line\"><span class=\"params\">   date_modified INTEGER,</span></span><br><span class=\"line\"><span class=\"params\">   description TEXT,</span></span><br><span class=\"line\"><span class=\"params\">   picasa_id TEXT,</span></span><br><span class=\"line\"><span class=\"params\">   isprivate INTEGER,</span></span><br><span class=\"line\"><span class=\"params\">   latitude DOUBLE, </span></span><br><span class=\"line\"><span class=\"params\">   longitude DOUBLE, </span></span><br><span class=\"line\"><span class=\"params\">   datetaken INTEGER, </span></span><br><span class=\"line\"><span class=\"params\">   orientation INTEGER, </span></span><br><span class=\"line\"><span class=\"params\">   mini_thumb_magic INTEGER, </span></span><br><span class=\"line\"><span class=\"params\">   bucket_id TEXT, </span></span><br><span class=\"line\"><span class=\"params\">   bucket_display_name TEXT )</span>;</span><br></pre></td></tr></table></figure>\n\n<p>各字段所表示意思，如图所示：</p>\n<img src=\"https://cdn.julis.wang/blog/img/2eb1be5d3ece2831fa9ca6d00678bf520a7.jpg\">\n\n<p><em>图片来自：<a href=\"https://blog.csdn.net/love_xsq/article/details/50387747\" title=\"Android MediaProvider数据库模式说明\">Android MediaProvider数据库模式说明</a></em></p>\n<p>所以在截屏监听数据的时候所读取的数据库返回值，分别为：</p>\n<p>_data  :图片据对路径</p>\n<p>datetaken：取子EXIF照片拍摄事件，空的话为文件修改时间</p>\n<pre><code>  private static final String[] MEDIA_PROJECTIONS =  &#123;\n        MediaStore.Images.ImageColumns.DATA,\n        MediaStore.Images.ImageColumns.DATE_TAKEN &#125;;\n</code></pre>\n<p>在查询过程中构造的数据库代码为：</p>\n<pre><code>public final Cursor query (Uri uri, \n\tString[] projection,\n\tString selection, \n\tString[] selectionArgs, \n\tString sortOrder)\n</code></pre>\n<p>&#96;<br>其中对应的构造参数官方解释为：</p>\n<blockquote>\n<p>uri\tThe URI, using the content:&#x2F;&#x2F; scheme, for the content to retrieve.</p>\n</blockquote>\n<blockquote>\n<p>projection\tA list of which columns to return. Passing null will return all columns, which is inefficient.  </p>\n</blockquote>\n<blockquote>\n<p>selection\tA filter declaring which rows to return, formatted as an SQL WHERE clause (excluding the WHERE itself). Passing null will return all rows for the given URI.</p>\n</blockquote>\n<blockquote>\n<p>selectionArgs\tYou may include ?s in selection, which will be replaced by the values from selectionArgs, in the order that they appear in the selection. The values will be bound as Strings.</p>\n</blockquote>\n<blockquote>\n<p>sortOrder\tHow to order the rows, formatted as an SQL ORDER BY clause (excluding the ORDER BY itself). Passing null will use the default sort order, which may be unordered.</p>\n</blockquote>\n<hr>\n<p>所以参数依次为：<br>所要查找的目标、所要的返回值、条件限制(类似sql中where)、匹配项、排序规则</p>\n<p>所以这里的查询就显而易见了：获取最新图片数据库下data和datatoken列的数据</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">cursor = mContext.getContentResolver().query(</span><br><span class=\"line\">                 contentUri,</span><br><span class=\"line\">                 MEDIA_PROJECTIONS,</span><br><span class=\"line\">                 <span class=\"literal\">null</span>,</span><br><span class=\"line\">                 <span class=\"literal\">null</span>,</span><br><span class=\"line\">                 MediaStore.Images.ImageColumns.DATE_ADDED + <span class=\"string\">&quot; desc limit 1&quot;</span></span><br><span class=\"line\">         );</span><br></pre></td></tr></table></figure>\n<p>然而…并不能解释vivo手机为什么查找出来不是最新截图的图片的问题</p>\n","cover":null,"images":["https://cdn.julis.wang/blog/img/2eb1be5d3ece2831fa9ca6d00678bf520a7.jpg"],"content":"<p>最近做了一个需求：监听用户截屏，然后生成相关海报。<br>参考了<a href=\"https://blog.csdn.net/xietansheng/article/details/52692163\" title=\"Android 截屏事件监听\">Android 截屏事件监听</a>的文章，大致思路是：</p>\n<p>1、利用ContentObserver用来监听指定Uri的所有资源变化,当媒体库中有相关图片新增的时候，则发送相关的通知。</p>\n<p>2、得到回调的Uri后，借助ContentResolver在媒体数据库中查询最后一条数据</p>\n<p>3、对数据做一些过滤。比如短时间重复截屏的情况以及其他App也插入了媒体文件等情况做处理。</p>\n<p>不过有一些适配性的问题：</p>\n<p>1、截屏后读取文件数据库后获取到件的绝对路径后，利用“screenshot”等关键字判断是否是截屏图片，并不能适配所有手机截屏的命名规则，以及其他应用同时间产生带有“screenshot”等关键词的文件也会有问题。</p>\n<p>2、在某些型号手机中(现遇到Vivo)从数据库中读取的文件并不是获取到的最新的截屏文件，而且其他目录的文件，这里就有些难以理解了，所以今天取探究一下媒体数据库的读取。</p>\n<p>其中ContentObserver如下代码所示：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">   * 媒体内容观察者(观察媒体数据库的改变)</span></span><br><span class=\"line\"><span class=\"comment\">   */</span></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">class</span> <span class=\"title class_\">MediaContentObserver</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">ContentObserver</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">private</span> Uri mContentUri;</span><br><span class=\"line\">      <span class=\"keyword\">public</span> <span class=\"title function_\">MediaContentObserver</span><span class=\"params\">(Uri contentUri, Handler handler)</span> &#123;</span><br><span class=\"line\">          <span class=\"built_in\">super</span>(handler);</span><br><span class=\"line\">          mContentUri = contentUri;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      [<span class=\"meta\">@Override</span>](https:<span class=\"comment\">//my.oschina.net/u/1162528)</span></span><br><span class=\"line\">      <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">onChange</span><span class=\"params\">(<span class=\"type\">boolean</span> selfChange)</span> &#123;</span><br><span class=\"line\">          <span class=\"built_in\">super</span>.onChange(selfChange);</span><br><span class=\"line\">          handleMediaContentChange(mContentUri);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<p>其中获取最后一次更新的媒体文件时的代码(为便于查看 删除了判空处理代码)：<br> <figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">\t<span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">    * 处理媒体数据库的内容改变</span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">   <span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">handleMediaContentChange</span><span class=\"params\">(Uri contentUri)</span> &#123;</span><br><span class=\"line\">       <span class=\"type\">Cursor</span> <span class=\"variable\">cursor</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">       <span class=\"comment\">/** 读取媒体数据库时需要读取的列 */</span></span><br><span class=\"line\">       <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String[] MEDIA_PROJECTIONS =  &#123;</span><br><span class=\"line\">           MediaStore.Images.ImageColumns.DATA,</span><br><span class=\"line\">           MediaStore.Images.ImageColumns.DATE_TAKEN &#125;;</span><br><span class=\"line\">       <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">           <span class=\"comment\">// 数据改变时查询数据库中最后加入的一条数据</span></span><br><span class=\"line\">           cursor = mContext.getContentResolver().query(</span><br><span class=\"line\">                   contentUri,</span><br><span class=\"line\">                    MEDIA_PROJECTIONS,</span><br><span class=\"line\">                   <span class=\"literal\">null</span>,</span><br><span class=\"line\">                   <span class=\"literal\">null</span>,</span><br><span class=\"line\">                   MediaStore.Images.ImageColumns.DATE_ADDED + <span class=\"string\">&quot; desc limit 1&quot;</span></span><br><span class=\"line\">           );</span><br><span class=\"line\">           <span class=\"comment\">// 获取各列的索引</span></span><br><span class=\"line\">           <span class=\"type\">int</span> <span class=\"variable\">dataIndex</span> <span class=\"operator\">=</span> cursor.getColumnIndex(MediaStore.Images.ImageColumns.DATA);</span><br><span class=\"line\">           <span class=\"type\">int</span> <span class=\"variable\">dateTakenIndex</span> <span class=\"operator\">=</span> cursor.getColumnIndex(MediaStore.Images.ImageColumns.DATE_TAKEN);</span><br><span class=\"line\"></span><br><span class=\"line\">           <span class=\"comment\">// 获取行数据</span></span><br><span class=\"line\">           <span class=\"type\">String</span> <span class=\"variable\">data</span> <span class=\"operator\">=</span> cursor.getString(dataIndex);</span><br><span class=\"line\">           <span class=\"type\">long</span> <span class=\"variable\">dateTaken</span> <span class=\"operator\">=</span> cursor.getLong(dateTakenIndex);</span><br><span class=\"line\"></span><br><span class=\"line\">           <span class=\"comment\">// 处理获取到的第一行数据</span></span><br><span class=\"line\">           handleMediaRowData(data, dateTaken);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>这次的目的主要探究的是从数据库获取相关信息的过程</p>\n<p><strong>1、Android 的多媒体如何存储？</strong></p>\n<p>Android的多媒体文件主要存储在 &#x2F;data&#x2F;data&#x2F;com.android.providers.media&#x2F;databases 目录下，该目录下有连个db文件：</p>\n<p>内部存储数据库文件：internal.db</p>\n<p>存储卡数据库：external-XXXX.db</p>\n<p>媒体文件的操作主要是围绕着这两个数据库来进行，这两个数据库的结构是一样的。</p>\n<p>这两个数据库包含这些表：<br>album_art 、audio 、search 、album_info 、audio_genres、 searchhelpertitle、albums、 audio_genres_map、 thumbnails、<br>android_metadata、 audio_meta、 video、artist_info 、audio_playlists 、videothumbnails、artists 、audio_playlists_map、<br>artists_albums_map 、images</p>\n<p><strong>2、表的结构</strong><br>对于Images表：主要存储images信息。表结构如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">CREATE TABLE <span class=\"title function_\">images</span> <span class=\"params\">(</span></span><br><span class=\"line\"><span class=\"params\">   _id INTEGER PRIMARY KEY, </span></span><br><span class=\"line\"><span class=\"params\">   _data TEXT,</span></span><br><span class=\"line\"><span class=\"params\">   _size INTEGER,</span></span><br><span class=\"line\"><span class=\"params\">   _display_name TEXT,</span></span><br><span class=\"line\"><span class=\"params\">   mime_type TEXT,</span></span><br><span class=\"line\"><span class=\"params\">   title TEXT, </span></span><br><span class=\"line\"><span class=\"params\">   date_added INTEGER, </span></span><br><span class=\"line\"><span class=\"params\">   date_modified INTEGER,</span></span><br><span class=\"line\"><span class=\"params\">   description TEXT,</span></span><br><span class=\"line\"><span class=\"params\">   picasa_id TEXT,</span></span><br><span class=\"line\"><span class=\"params\">   isprivate INTEGER,</span></span><br><span class=\"line\"><span class=\"params\">   latitude DOUBLE, </span></span><br><span class=\"line\"><span class=\"params\">   longitude DOUBLE, </span></span><br><span class=\"line\"><span class=\"params\">   datetaken INTEGER, </span></span><br><span class=\"line\"><span class=\"params\">   orientation INTEGER, </span></span><br><span class=\"line\"><span class=\"params\">   mini_thumb_magic INTEGER, </span></span><br><span class=\"line\"><span class=\"params\">   bucket_id TEXT, </span></span><br><span class=\"line\"><span class=\"params\">   bucket_display_name TEXT )</span>;</span><br></pre></td></tr></table></figure>\n\n<p>各字段所表示意思，如图所示：</p>\n<img src=\"https://cdn.julis.wang/blog/img/2eb1be5d3ece2831fa9ca6d00678bf520a7.jpg\">\n\n<p><em>图片来自：<a href=\"https://blog.csdn.net/love_xsq/article/details/50387747\" title=\"Android MediaProvider数据库模式说明\">Android MediaProvider数据库模式说明</a></em></p>\n<p>所以在截屏监听数据的时候所读取的数据库返回值，分别为：</p>\n<p>_data  :图片据对路径</p>\n<p>datetaken：取子EXIF照片拍摄事件，空的话为文件修改时间</p>\n<pre><code>  private static final String[] MEDIA_PROJECTIONS =  &#123;\n        MediaStore.Images.ImageColumns.DATA,\n        MediaStore.Images.ImageColumns.DATE_TAKEN &#125;;\n</code></pre>\n<p>在查询过程中构造的数据库代码为：</p>\n<pre><code>public final Cursor query (Uri uri, \n\tString[] projection,\n\tString selection, \n\tString[] selectionArgs, \n\tString sortOrder)\n</code></pre>\n<p>&#96;<br>其中对应的构造参数官方解释为：</p>\n<blockquote>\n<p>uri\tThe URI, using the content:&#x2F;&#x2F; scheme, for the content to retrieve.</p>\n</blockquote>\n<blockquote>\n<p>projection\tA list of which columns to return. Passing null will return all columns, which is inefficient.  </p>\n</blockquote>\n<blockquote>\n<p>selection\tA filter declaring which rows to return, formatted as an SQL WHERE clause (excluding the WHERE itself). Passing null will return all rows for the given URI.</p>\n</blockquote>\n<blockquote>\n<p>selectionArgs\tYou may include ?s in selection, which will be replaced by the values from selectionArgs, in the order that they appear in the selection. The values will be bound as Strings.</p>\n</blockquote>\n<blockquote>\n<p>sortOrder\tHow to order the rows, formatted as an SQL ORDER BY clause (excluding the ORDER BY itself). Passing null will use the default sort order, which may be unordered.</p>\n</blockquote>\n<hr>\n<p>所以参数依次为：<br>所要查找的目标、所要的返回值、条件限制(类似sql中where)、匹配项、排序规则</p>\n<p>所以这里的查询就显而易见了：获取最新图片数据库下data和datatoken列的数据</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">cursor = mContext.getContentResolver().query(</span><br><span class=\"line\">                 contentUri,</span><br><span class=\"line\">                 MEDIA_PROJECTIONS,</span><br><span class=\"line\">                 <span class=\"literal\">null</span>,</span><br><span class=\"line\">                 <span class=\"literal\">null</span>,</span><br><span class=\"line\">                 MediaStore.Images.ImageColumns.DATE_ADDED + <span class=\"string\">&quot; desc limit 1&quot;</span></span><br><span class=\"line\">         );</span><br></pre></td></tr></table></figure>\n<p>然而…并不能解释vivo手机为什么查找出来不是最新截图的图片的问题</p>\n","categories":[{"name":"技术文章","slug":"technology","api":"api/categories/technology.json"}],"tags":[{"name":"安卓","slug":"Android","api":"api/tags/Android.json"}],"api":"api/posts/2019/07/02/Android监听截屏事件之媒体读取的探索.json"},{"title":"Android在子线程中创建Handler为什么会抛出异常？","slug":"Android在子线程中创建Handler为什么会抛出异常？","date":"2019-06-24T09:27:00.000Z","updated":"2025-05-20T11:46:57.000Z","comments":true,"url":"2019/06/24/Android在子线程中创建Handler为什么会抛出异常？/","excerpt":"<p>复习一下消息机制，如下代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>() &#123;</span><br><span class=\"line\">           <span class=\"type\">Handler</span> <span class=\"variable\">handler</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">           [<span class=\"meta\">@Override</span>](https:<span class=\"comment\">//my.oschina.net/u/1162528)</span></span><br><span class=\"line\">           <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">               handler = <span class=\"keyword\">new</span> <span class=\"title class_\">Handler</span>();</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">       &#125;.start();</span><br></pre></td></tr></table></figure>\n<p>如果执行会抛出异常：</p>\n<blockquote>\n<p>Can’t create handler inside thread Thread.currentThread() that has not called Looper.prepare()</p>\n</blockquote>\n<p>这是为什么呢？</p>\n<p>我们进入Handler的构造方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"> <span class=\"keyword\">public</span> <span class=\"title function_\">Handler</span><span class=\"params\">(Callback callback, <span class=\"type\">boolean</span> async)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (FIND_POTENTIAL_LEAKS) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> Class&lt;? <span class=\"keyword\">extends</span> <span class=\"title class_\">Handler</span>&gt; klass = getClass();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((klass.isAnonymousClass() || klass.isMemberClass() || klass.isLocalClass()) &amp;&amp;</span><br><span class=\"line\">                (klass.getModifiers() &amp; Modifier.STATIC) == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            Log.w(TAG, <span class=\"string\">&quot;The following Handler class should be static or leaks might occur: &quot;</span> +</span><br><span class=\"line\">                klass.getCanonicalName());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    mLooper = Looper.myLooper();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mLooper == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">RuntimeException</span>(</span><br><span class=\"line\">            <span class=\"string\">&quot;Can&#x27;t create handler inside thread &quot;</span> + Thread.currentThread()</span><br><span class=\"line\">                    + <span class=\"string\">&quot; that has not called Looper.prepare()&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    mQueue = mLooper.mQueue;</span><br><span class=\"line\">    mCallback = callback;</span><br><span class=\"line\">    mAsynchronous = async;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>从上面的代码我们很清新的可以知道mLooper  为null,那么就会抛出这样的异常，那么mLooper 为什么会为空呢？这是因为在线程中的Looper还未被创建，所以在Looper.myLooper()中sThreadLocal.get()就会返回null。</p>\n<p>我们知道 Handler的作用是处理消息，将消息传递给MessageQueue，而MessageQueue存在于Looper中，如果没有Looper那么就没有MessageQueue，所以创建Handler时，Looper不能够为空。</p>\n<p>所以以上代码可以进行一个修改：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">test</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>() &#123;</span><br><span class=\"line\">        <span class=\"type\">Handler</span> <span class=\"variable\">handler</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">        [<span class=\"meta\">@Override</span>](https:<span class=\"comment\">//my.oschina.net/u/1162528)</span></span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">            Looper.prepare();</span><br><span class=\"line\">            handler = <span class=\"keyword\">new</span> <span class=\"title class_\">Handler</span>();</span><br><span class=\"line\">            Looper.loop();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;.start();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>其中     Looper.prepare();为当前线程创建Looper并绑定在ThreadLocal中<br>    Looper.loop();执行消息循环，这样子 Handler就能够正常工作了。\n\t\n\t</p>\n","cover":null,"images":[],"content":"<p>复习一下消息机制，如下代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>() &#123;</span><br><span class=\"line\">           <span class=\"type\">Handler</span> <span class=\"variable\">handler</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">           [<span class=\"meta\">@Override</span>](https:<span class=\"comment\">//my.oschina.net/u/1162528)</span></span><br><span class=\"line\">           <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">               handler = <span class=\"keyword\">new</span> <span class=\"title class_\">Handler</span>();</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">       &#125;.start();</span><br></pre></td></tr></table></figure>\n<p>如果执行会抛出异常：</p>\n<blockquote>\n<p>Can’t create handler inside thread Thread.currentThread() that has not called Looper.prepare()</p>\n</blockquote>\n<p>这是为什么呢？</p>\n<p>我们进入Handler的构造方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"> <span class=\"keyword\">public</span> <span class=\"title function_\">Handler</span><span class=\"params\">(Callback callback, <span class=\"type\">boolean</span> async)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (FIND_POTENTIAL_LEAKS) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> Class&lt;? <span class=\"keyword\">extends</span> <span class=\"title class_\">Handler</span>&gt; klass = getClass();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((klass.isAnonymousClass() || klass.isMemberClass() || klass.isLocalClass()) &amp;&amp;</span><br><span class=\"line\">                (klass.getModifiers() &amp; Modifier.STATIC) == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            Log.w(TAG, <span class=\"string\">&quot;The following Handler class should be static or leaks might occur: &quot;</span> +</span><br><span class=\"line\">                klass.getCanonicalName());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    mLooper = Looper.myLooper();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mLooper == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">RuntimeException</span>(</span><br><span class=\"line\">            <span class=\"string\">&quot;Can&#x27;t create handler inside thread &quot;</span> + Thread.currentThread()</span><br><span class=\"line\">                    + <span class=\"string\">&quot; that has not called Looper.prepare()&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    mQueue = mLooper.mQueue;</span><br><span class=\"line\">    mCallback = callback;</span><br><span class=\"line\">    mAsynchronous = async;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>从上面的代码我们很清新的可以知道mLooper  为null,那么就会抛出这样的异常，那么mLooper 为什么会为空呢？这是因为在线程中的Looper还未被创建，所以在Looper.myLooper()中sThreadLocal.get()就会返回null。</p>\n<p>我们知道 Handler的作用是处理消息，将消息传递给MessageQueue，而MessageQueue存在于Looper中，如果没有Looper那么就没有MessageQueue，所以创建Handler时，Looper不能够为空。</p>\n<p>所以以上代码可以进行一个修改：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">test</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>() &#123;</span><br><span class=\"line\">        <span class=\"type\">Handler</span> <span class=\"variable\">handler</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">        [<span class=\"meta\">@Override</span>](https:<span class=\"comment\">//my.oschina.net/u/1162528)</span></span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">            Looper.prepare();</span><br><span class=\"line\">            handler = <span class=\"keyword\">new</span> <span class=\"title class_\">Handler</span>();</span><br><span class=\"line\">            Looper.loop();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;.start();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>其中     Looper.prepare();为当前线程创建Looper并绑定在ThreadLocal中<br>    Looper.loop();执行消息循环，这样子 Handler就能够正常工作了。\n\t\n\t</p>\n","categories":[{"name":"技术文章","slug":"technology","api":"api/categories/technology.json"}],"tags":[{"name":"安卓","slug":"Android","api":"api/tags/Android.json"}],"api":"api/posts/2019/06/24/Android在子线程中创建Handler为什么会抛出异常？.json"},{"title":"基于Volley框架的返回数据的范型处理","slug":"基于Volley框架的返回数据的范型处理","date":"2019-05-13T06:56:00.000Z","updated":"2025-05-20T11:46:57.000Z","comments":true,"url":"2019/05/13/基于Volley框架的返回数据的范型处理/","excerpt":"<p>在平时最普通的Volley的网络请求中，我们StringRequest是这样请求网络数据的：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">StringRequest</span> <span class=\"variable\">stringRequest</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">StringRequest</span>(<span class=\"string\">&quot;http://www.baidu.com&quot;</span>,</span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">Response</span>.Listener&lt;String&gt;() &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">onResponse</span><span class=\"params\">(String response)</span> &#123;</span><br><span class=\"line\">                Log.d(<span class=\"string\">&quot;TAG&quot;</span>, response);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;, <span class=\"keyword\">new</span> <span class=\"title class_\">Response</span>.ErrorListener() &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">onErrorResponse</span><span class=\"params\">(VolleyError error)</span> &#123;</span><br><span class=\"line\">        Log.e(<span class=\"string\">&quot;TAG&quot;</span>, error.getMessage(), error);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>注意在onResponse的时候是拿到的string类型，拿到string后对其再进行相关的解析，我们是否是可以对其直接封装然后拿到具体想要类型的model数据结构呢？所以对其网络请求架构进行一次封装，到达如下效果：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">GetGoodDetailByGidRequest</span> <span class=\"variable\">getGoodDetailByGidRequest</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">GetGoodDetailByGidRequest</span>(mCouponId,</span><br><span class=\"line\">              <span class=\"keyword\">new</span> <span class=\"title class_\">RequestListener</span>&lt;List&lt;CouponModel&gt;&gt;() &#123;</span><br><span class=\"line\">                  <span class=\"meta\">@Override</span></span><br><span class=\"line\">                  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">onSuccess</span><span class=\"params\">(List&lt;CouponModel&gt; result)</span> &#123;</span><br><span class=\"line\">                  &#125;</span><br><span class=\"line\">                  <span class=\"meta\">@Override</span></span><br><span class=\"line\">                  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">onError</span><span class=\"params\">(Exception e)</span> &#123;</span><br><span class=\"line\">                      e.printStackTrace();</span><br><span class=\"line\">                      stopLoadingDialog();</span><br><span class=\"line\">                  &#125;</span><br><span class=\"line\">              &#125;);</span><br></pre></td></tr></table></figure>\n<p>这里我们在构造Request的时候指定了返回数据的类型，这样的话就方便了我们在写业务的时候直接使用解析好的数据结构，具体如何做到的呢？</p>\n<p><strong>一、让每个Request基于一个带有范型请求类</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">class</span> <span class=\"title class_\">BaseApiRequest</span>&lt;T&gt;  </span><br></pre></td></tr></table></figure>\n<p>这里的T就是目标请求期望的model类<br>在具体实现的时候继承基类，并指定返回类型，下面是一个例子：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">GetGoodDetailByGidRequest</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">BaseApiRequest</span>&lt;List&lt;CouponModel&gt;&gt; &#123;</span><br><span class=\"line\">   \t<span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">String</span> <span class=\"variable\">url</span> <span class=\"operator\">=</span> CURL.GoodDetailURL;</span><br><span class=\"line\">   \t<span class=\"keyword\">public</span> <span class=\"title function_\">GetGoodDetailByGidRequest</span><span class=\"params\">(String goodId, RequestListener&lt;List&lt;CouponModel&gt;&gt; requestListener)</span> &#123;</span><br><span class=\"line\">       \t\t<span class=\"built_in\">super</span>(requestListener);</span><br><span class=\"line\">       \t\t<span class=\"built_in\">this</span>.mUrlParams.put(<span class=\"string\">&quot;id&quot;</span>, goodId);</span><br><span class=\"line\">   \t&#125;</span><br><span class=\"line\">   \t<span class=\"meta\">@Override</span></span><br><span class=\"line\">   \t<span class=\"keyword\">public</span> String <span class=\"title function_\">getBaseUrl</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">       \t\t<span class=\"keyword\">return</span> url;</span><br><span class=\"line\">  \t\t &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>二、在基类中构造网络请求</strong>\t</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">protected</span> StringRequest <span class=\"title function_\">getStringRequest</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">     <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">StringRequest</span>(requestMethod, getRequestUrl(),</span><br><span class=\"line\">             response -&gt; parseJson(response),</span><br><span class=\"line\">             error -&gt; requestListener.onError(error)) &#123;</span><br><span class=\"line\">         <span class=\"meta\">@Override</span></span><br><span class=\"line\">         <span class=\"keyword\">protected</span> Map&lt;String, String&gt; <span class=\"title function_\">getParams</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">             <span class=\"keyword\">return</span> mEntityParams;</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">     &#125;;</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n<p>在此处实现可以看到Request在基类中进行，然后分别处理返回结果</p>\n<p><strong>三、对返回结果进行解析</strong>\t</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">parseJson</span><span class=\"params\">(String response)</span> &#123;</span><br><span class=\"line\">      <span class=\"type\">int</span> <span class=\"variable\">responseCode</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">      <span class=\"type\">int</span> <span class=\"variable\">errorCode</span> <span class=\"operator\">=</span> <span class=\"number\">400</span>;</span><br><span class=\"line\">      <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">          <span class=\"type\">JSONObject</span> <span class=\"variable\">jsonObject</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">JSONObject</span>(response);</span><br><span class=\"line\"></span><br><span class=\"line\">          <span class=\"type\">String</span> <span class=\"variable\">resultString</span> <span class=\"operator\">=</span> jsonObject.getString(<span class=\"string\">&quot;data&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">          <span class=\"keyword\">if</span> (jsonObject.has(<span class=\"string\">&quot;code&quot;</span>)) &#123;</span><br><span class=\"line\">              responseCode = jsonObject.getInt(<span class=\"string\">&quot;code&quot;</span>);</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">          <span class=\"keyword\">if</span> (jsonObject.has(<span class=\"string\">&quot;error&quot;</span>)) &#123;</span><br><span class=\"line\">              errorCode = jsonObject.getInt(<span class=\"string\">&quot;error&quot;</span>);</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">          <span class=\"keyword\">if</span> (responseCode == <span class=\"number\">200</span> || errorCode == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">              <span class=\"keyword\">if</span> (!TextUtils.isEmpty(response)) &#123;</span><br><span class=\"line\">                  <span class=\"type\">Type</span> <span class=\"variable\">type</span> <span class=\"operator\">=</span> getTType(requestListener.getClass());</span><br><span class=\"line\">                  <span class=\"comment\">//泛型是实体或者List等类型</span></span><br><span class=\"line\">                  <span class=\"type\">T</span> <span class=\"variable\">t</span> <span class=\"operator\">=</span> JsonUtils.fromJson(resultString, type);</span><br><span class=\"line\">                  requestListener.onSuccess(t);</span><br><span class=\"line\">                  <span class=\"keyword\">return</span>;</span><br><span class=\"line\">              &#125;</span><br><span class=\"line\">              ToastUtils.showToast(<span class=\"string\">&quot;Data is empty!&quot;</span>);</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">          ToastUtils.showToast(<span class=\"string\">&quot;Response code is error.&quot;</span>);</span><br><span class=\"line\">          requestListener.onError(<span class=\"keyword\">new</span> <span class=\"title class_\">ParseError</span>());</span><br><span class=\"line\">      &#125; <span class=\"keyword\">catch</span> (JSONException e) &#123;</span><br><span class=\"line\">          ToastUtils.showToast(e.toString());</span><br><span class=\"line\">          e.printStackTrace();</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<p>这里是最关键的一步，由于和后端约定好相关返回字段，那么只需要解析字段中目标model的数据，其中比较重要的是这段代码</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">\t<span class=\"type\">Type</span> <span class=\"variable\">type</span> <span class=\"operator\">=</span> getTType(requestListener.getClass());</span><br><span class=\"line\">    <span class=\"comment\">//泛型是实体或者List等类型</span></span><br><span class=\"line\">     <span class=\"type\">T</span> <span class=\"variable\">t</span> <span class=\"operator\">=</span> JsonUtils.fromJson(resultString, type);</span><br><span class=\"line\">     requestListener.onSuccess(t);</span><br><span class=\"line\">```\t </span><br><span class=\"line\">通过封装好的 JsonUtils将String转化为对应的model类型，我们知道json转实体对象的时候，需要指明其类type，那这里的type是如何获取到的呢？</span><br><span class=\"line\"></span><br><span class=\"line\">其中getTType ()的具体实现为：</span><br><span class=\"line\"> ```java</span><br><span class=\"line\">     <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Type <span class=\"title function_\">getTType</span><span class=\"params\">(Class&lt;?&gt; clazz)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//以Type的形式返回本类直接实现的接口.</span></span><br><span class=\"line\">        Type[] types = clazz.getGenericInterfaces();</span><br><span class=\"line\">        clazz.getInterfaces();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (types.length &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//返回表示此类型实际类型参数的 Type 对象的数组</span></span><br><span class=\"line\">            Type[] interfacesTypes = ((ParameterizedType) types[<span class=\"number\">0</span>]).getActualTypeArguments();</span><br><span class=\"line\">            <span class=\"keyword\">return</span> interfacesTypes[<span class=\"number\">0</span>];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>通过次方法能够获取到请求实现中所指明的请求类型，其中getGenericInterfaces等相关原理可以阅读：<a href=\"https://my.oschina.net/617669559/blog/3012228\">https://my.oschina.net/617669559/blog/3012228</a></p>\n<p>所以对于\t</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">GetGoodDetailByGidRequest</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">BaseApiRequest</span>&lt;List&lt;CouponModel&gt;&gt;</span><br></pre></td></tr></table></figure>\n<p>那么获取到的就是List<CouponModel>类型</p>\n<p><strong>四、通过Listener回调相关解析结果</strong>\t</p>\n<p>拿到解析好的result并回调给构造Request方法中的listener使用</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">T</span> <span class=\"variable\">t</span> <span class=\"operator\">=</span> JsonUtils.fromJson(resultString, type);</span><br><span class=\"line\">requestListener.onSuccess(t);</span><br></pre></td></tr></table></figure>\n<p>这样对整个网络请求后的返回数据直接进行解析方便多了。</p>\n<p><strong>总结：</strong></p>\n<p>1、本文最主要是对基本Request类进行改造，以达到不需要每次重复写解析返回的String数据</p>\n<p>2、在获取目标的类的类型的时候，主要是去获取基类中的“T”类型</p>\n<p>3、设计不仅适用用Volley同样适用于其他类似的网络请求框架</p>\n","cover":null,"images":[],"content":"<p>在平时最普通的Volley的网络请求中，我们StringRequest是这样请求网络数据的：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">StringRequest</span> <span class=\"variable\">stringRequest</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">StringRequest</span>(<span class=\"string\">&quot;http://www.baidu.com&quot;</span>,</span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">Response</span>.Listener&lt;String&gt;() &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">onResponse</span><span class=\"params\">(String response)</span> &#123;</span><br><span class=\"line\">                Log.d(<span class=\"string\">&quot;TAG&quot;</span>, response);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;, <span class=\"keyword\">new</span> <span class=\"title class_\">Response</span>.ErrorListener() &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">onErrorResponse</span><span class=\"params\">(VolleyError error)</span> &#123;</span><br><span class=\"line\">        Log.e(<span class=\"string\">&quot;TAG&quot;</span>, error.getMessage(), error);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>注意在onResponse的时候是拿到的string类型，拿到string后对其再进行相关的解析，我们是否是可以对其直接封装然后拿到具体想要类型的model数据结构呢？所以对其网络请求架构进行一次封装，到达如下效果：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">GetGoodDetailByGidRequest</span> <span class=\"variable\">getGoodDetailByGidRequest</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">GetGoodDetailByGidRequest</span>(mCouponId,</span><br><span class=\"line\">              <span class=\"keyword\">new</span> <span class=\"title class_\">RequestListener</span>&lt;List&lt;CouponModel&gt;&gt;() &#123;</span><br><span class=\"line\">                  <span class=\"meta\">@Override</span></span><br><span class=\"line\">                  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">onSuccess</span><span class=\"params\">(List&lt;CouponModel&gt; result)</span> &#123;</span><br><span class=\"line\">                  &#125;</span><br><span class=\"line\">                  <span class=\"meta\">@Override</span></span><br><span class=\"line\">                  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">onError</span><span class=\"params\">(Exception e)</span> &#123;</span><br><span class=\"line\">                      e.printStackTrace();</span><br><span class=\"line\">                      stopLoadingDialog();</span><br><span class=\"line\">                  &#125;</span><br><span class=\"line\">              &#125;);</span><br></pre></td></tr></table></figure>\n<p>这里我们在构造Request的时候指定了返回数据的类型，这样的话就方便了我们在写业务的时候直接使用解析好的数据结构，具体如何做到的呢？</p>\n<p><strong>一、让每个Request基于一个带有范型请求类</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">class</span> <span class=\"title class_\">BaseApiRequest</span>&lt;T&gt;  </span><br></pre></td></tr></table></figure>\n<p>这里的T就是目标请求期望的model类<br>在具体实现的时候继承基类，并指定返回类型，下面是一个例子：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">GetGoodDetailByGidRequest</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">BaseApiRequest</span>&lt;List&lt;CouponModel&gt;&gt; &#123;</span><br><span class=\"line\">   \t<span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">String</span> <span class=\"variable\">url</span> <span class=\"operator\">=</span> CURL.GoodDetailURL;</span><br><span class=\"line\">   \t<span class=\"keyword\">public</span> <span class=\"title function_\">GetGoodDetailByGidRequest</span><span class=\"params\">(String goodId, RequestListener&lt;List&lt;CouponModel&gt;&gt; requestListener)</span> &#123;</span><br><span class=\"line\">       \t\t<span class=\"built_in\">super</span>(requestListener);</span><br><span class=\"line\">       \t\t<span class=\"built_in\">this</span>.mUrlParams.put(<span class=\"string\">&quot;id&quot;</span>, goodId);</span><br><span class=\"line\">   \t&#125;</span><br><span class=\"line\">   \t<span class=\"meta\">@Override</span></span><br><span class=\"line\">   \t<span class=\"keyword\">public</span> String <span class=\"title function_\">getBaseUrl</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">       \t\t<span class=\"keyword\">return</span> url;</span><br><span class=\"line\">  \t\t &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>二、在基类中构造网络请求</strong>\t</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">protected</span> StringRequest <span class=\"title function_\">getStringRequest</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">     <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">StringRequest</span>(requestMethod, getRequestUrl(),</span><br><span class=\"line\">             response -&gt; parseJson(response),</span><br><span class=\"line\">             error -&gt; requestListener.onError(error)) &#123;</span><br><span class=\"line\">         <span class=\"meta\">@Override</span></span><br><span class=\"line\">         <span class=\"keyword\">protected</span> Map&lt;String, String&gt; <span class=\"title function_\">getParams</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">             <span class=\"keyword\">return</span> mEntityParams;</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">     &#125;;</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n<p>在此处实现可以看到Request在基类中进行，然后分别处理返回结果</p>\n<p><strong>三、对返回结果进行解析</strong>\t</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">parseJson</span><span class=\"params\">(String response)</span> &#123;</span><br><span class=\"line\">      <span class=\"type\">int</span> <span class=\"variable\">responseCode</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">      <span class=\"type\">int</span> <span class=\"variable\">errorCode</span> <span class=\"operator\">=</span> <span class=\"number\">400</span>;</span><br><span class=\"line\">      <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">          <span class=\"type\">JSONObject</span> <span class=\"variable\">jsonObject</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">JSONObject</span>(response);</span><br><span class=\"line\"></span><br><span class=\"line\">          <span class=\"type\">String</span> <span class=\"variable\">resultString</span> <span class=\"operator\">=</span> jsonObject.getString(<span class=\"string\">&quot;data&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">          <span class=\"keyword\">if</span> (jsonObject.has(<span class=\"string\">&quot;code&quot;</span>)) &#123;</span><br><span class=\"line\">              responseCode = jsonObject.getInt(<span class=\"string\">&quot;code&quot;</span>);</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">          <span class=\"keyword\">if</span> (jsonObject.has(<span class=\"string\">&quot;error&quot;</span>)) &#123;</span><br><span class=\"line\">              errorCode = jsonObject.getInt(<span class=\"string\">&quot;error&quot;</span>);</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">          <span class=\"keyword\">if</span> (responseCode == <span class=\"number\">200</span> || errorCode == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">              <span class=\"keyword\">if</span> (!TextUtils.isEmpty(response)) &#123;</span><br><span class=\"line\">                  <span class=\"type\">Type</span> <span class=\"variable\">type</span> <span class=\"operator\">=</span> getTType(requestListener.getClass());</span><br><span class=\"line\">                  <span class=\"comment\">//泛型是实体或者List等类型</span></span><br><span class=\"line\">                  <span class=\"type\">T</span> <span class=\"variable\">t</span> <span class=\"operator\">=</span> JsonUtils.fromJson(resultString, type);</span><br><span class=\"line\">                  requestListener.onSuccess(t);</span><br><span class=\"line\">                  <span class=\"keyword\">return</span>;</span><br><span class=\"line\">              &#125;</span><br><span class=\"line\">              ToastUtils.showToast(<span class=\"string\">&quot;Data is empty!&quot;</span>);</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">          ToastUtils.showToast(<span class=\"string\">&quot;Response code is error.&quot;</span>);</span><br><span class=\"line\">          requestListener.onError(<span class=\"keyword\">new</span> <span class=\"title class_\">ParseError</span>());</span><br><span class=\"line\">      &#125; <span class=\"keyword\">catch</span> (JSONException e) &#123;</span><br><span class=\"line\">          ToastUtils.showToast(e.toString());</span><br><span class=\"line\">          e.printStackTrace();</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<p>这里是最关键的一步，由于和后端约定好相关返回字段，那么只需要解析字段中目标model的数据，其中比较重要的是这段代码</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">\t<span class=\"type\">Type</span> <span class=\"variable\">type</span> <span class=\"operator\">=</span> getTType(requestListener.getClass());</span><br><span class=\"line\">    <span class=\"comment\">//泛型是实体或者List等类型</span></span><br><span class=\"line\">     <span class=\"type\">T</span> <span class=\"variable\">t</span> <span class=\"operator\">=</span> JsonUtils.fromJson(resultString, type);</span><br><span class=\"line\">     requestListener.onSuccess(t);</span><br><span class=\"line\">```\t </span><br><span class=\"line\">通过封装好的 JsonUtils将String转化为对应的model类型，我们知道json转实体对象的时候，需要指明其类type，那这里的type是如何获取到的呢？</span><br><span class=\"line\"></span><br><span class=\"line\">其中getTType ()的具体实现为：</span><br><span class=\"line\"> ```java</span><br><span class=\"line\">     <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Type <span class=\"title function_\">getTType</span><span class=\"params\">(Class&lt;?&gt; clazz)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//以Type的形式返回本类直接实现的接口.</span></span><br><span class=\"line\">        Type[] types = clazz.getGenericInterfaces();</span><br><span class=\"line\">        clazz.getInterfaces();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (types.length &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//返回表示此类型实际类型参数的 Type 对象的数组</span></span><br><span class=\"line\">            Type[] interfacesTypes = ((ParameterizedType) types[<span class=\"number\">0</span>]).getActualTypeArguments();</span><br><span class=\"line\">            <span class=\"keyword\">return</span> interfacesTypes[<span class=\"number\">0</span>];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>通过次方法能够获取到请求实现中所指明的请求类型，其中getGenericInterfaces等相关原理可以阅读：<a href=\"https://my.oschina.net/617669559/blog/3012228\">https://my.oschina.net/617669559/blog/3012228</a></p>\n<p>所以对于\t</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">GetGoodDetailByGidRequest</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">BaseApiRequest</span>&lt;List&lt;CouponModel&gt;&gt;</span><br></pre></td></tr></table></figure>\n<p>那么获取到的就是List<CouponModel>类型</p>\n<p><strong>四、通过Listener回调相关解析结果</strong>\t</p>\n<p>拿到解析好的result并回调给构造Request方法中的listener使用</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">T</span> <span class=\"variable\">t</span> <span class=\"operator\">=</span> JsonUtils.fromJson(resultString, type);</span><br><span class=\"line\">requestListener.onSuccess(t);</span><br></pre></td></tr></table></figure>\n<p>这样对整个网络请求后的返回数据直接进行解析方便多了。</p>\n<p><strong>总结：</strong></p>\n<p>1、本文最主要是对基本Request类进行改造，以达到不需要每次重复写解析返回的String数据</p>\n<p>2、在获取目标的类的类型的时候，主要是去获取基类中的“T”类型</p>\n<p>3、设计不仅适用用Volley同样适用于其他类似的网络请求框架</p>\n","categories":[{"name":"技术文章","slug":"technology","api":"api/categories/technology.json"}],"tags":[{"name":"安卓","slug":"Android","api":"api/tags/Android.json"}],"api":"api/posts/2019/05/13/基于Volley框架的返回数据的范型处理.json"},{"title":" Android中Handler使用导致的内存泄漏","slug":"Android中Handler使用导致的内存泄漏","date":"2019-03-18T01:37:00.000Z","updated":"2025-05-20T11:46:57.000Z","comments":true,"url":"2019/03/18/Android中Handler使用导致的内存泄漏/","excerpt":"<p><strong>1.什么是内存泄漏</strong></p>\n<p>用动态存储分配函数动态开辟的空间，在使用完毕后未被得到释放，结果一直占据该用内存单元，直到程序结束，即所谓的内存泄漏。</p>\n<p><strong>2.是内存泄漏与内存溢出的区别</strong></p>\n<p>内存溢出 Out of Memory，是指程序在申请内存时，没有足够的内存空间供其使用，出现out of memory；比如申请了一个integer,但给它存了long才能存下的数，那就是内存溢出。</p>\n<p>内存泄露 Memory Leak，是指程序在申请内存后，无法释放已申请的内存空间，一次内存泄露危害可以忽略，但内存泄露堆积后果很严重，无论多少内存,迟早会被占光。</p>\n<p>用一个很形象的例子来说明：一个仓库，被无用的物资所占据，而得不到管理员的清理，这里的无用货物占用仓库空间的行为被叫做”内存泄漏“，而某一天仓库由于所存储的物品太多，而无法继续存放物资，这个时候就被叫做“内存溢出”。</p>\n<p><strong>3.内存泄漏导致的问题</strong></p>\n<p>相关内存无法被系统给回收，随着程序运行可以用的内存会越来越少，机子越来越卡，直到内存溢出。（这也是为什么手机电脑很卡之后重启一下后会好很多，主要是相关未被系统回收的内存被回收）</p>\n<p><strong>4、安卓中的内存泄漏</strong></p>\n<p>典型的可能产生内存泄漏的代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">MemoryLeakActivity</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">MyActivity</span> &#123;</span><br><span class=\"line\">   <span class=\"comment\">//可能会导致内存泄漏的代码</span></span><br><span class=\"line\">   <span class=\"keyword\">private</span> <span class=\"type\">Handler</span> <span class=\"variable\">handler</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Handler</span>() &#123;</span><br><span class=\"line\">       [<span class=\"meta\">@Override</span>](https:<span class=\"comment\">//my.oschina.net/u/1162528)</span></span><br><span class=\"line\">       <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">handleMessage</span><span class=\"params\">(Message msg)</span> &#123;</span><br><span class=\"line\">           <span class=\"built_in\">super</span>.handleMessage(msg);</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">   &#125;;&#125;</span><br></pre></td></tr></table></figure>\n<p>产生内存泄漏可能的原因：Handler的工作机制中Handler与Looper以及MessageQueue一起工作的，App启动之后，系统会默认创建一个为主线程服务的Looper对象，负责处理主线程中所有的Message对象，它的生命周期则为整个应用的生命周期。在主线程使用Handler都会默认绑定到这个Looper上面，主线程创建Handler对象，会立即关联Looper对象的MessageQueue，这时发送MessageQueue重的Message会持有Handler的引用， 这样在Looper处理Message时候才会回调到Handler的handleMessage方法。因此，如果Message没有被处理完成，那么Handler对象就不会被垃圾回收。</p>\n<img src=\"https://cdn.julis.wang/blog/img/6e154da75042608bc2e6e970e2452f7a857.jpg\">\n<p>上面的代码，将Handler的实例声明为MemoryLeakActivity类的内部类，在Java中：<strong>非静态内部匿名类会持有外部类的一个隐式引用，这样就可能导致外部类无法被垃圾回收。</strong></p>\n<p>最终由于MessageQueue中的Message 没有处理完成，就会持有Handler对象的引用，而非静态的Handler对象会持有外部类Activity的引用，这个activity无法被回收，从而导致内存泄漏。</p>\n<p><strong>5、解决方案</strong></p>\n<p>1、将Handler声明为静态内部类，这样就不会持有对外部类的引用。</p>\n<p>2、创建一个Looper与一般Java对象一样的生命周期</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> InnerHandler <span class=\"keyword\">extends</span> <span class=\"title class_\">Handler</span>&#123;       </span><br><span class=\"line\"> \t\t<span class=\"comment\">// 声明一个静态Handler类，并持有外部类引用</span></span><br><span class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">final</span> WeakReference&lt;MemoryLeakActivity&gt; mActivity;</span><br><span class=\"line\">       \t<span class=\"keyword\">public</span> <span class=\"title function_\">InnerHandler</span><span class=\"params\">(MemoryLeakActivity activity)</span>&#123;</span><br><span class=\"line\">          \t\t <span class=\"built_in\">this</span>.mActivity = <span class=\"keyword\">new</span> <span class=\"title class_\">WeakReference</span>&lt;MemoryLeakActivity&gt;(activity);</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>","cover":null,"images":["https://cdn.julis.wang/blog/img/6e154da75042608bc2e6e970e2452f7a857.jpg"],"content":"<p><strong>1.什么是内存泄漏</strong></p>\n<p>用动态存储分配函数动态开辟的空间，在使用完毕后未被得到释放，结果一直占据该用内存单元，直到程序结束，即所谓的内存泄漏。</p>\n<p><strong>2.是内存泄漏与内存溢出的区别</strong></p>\n<p>内存溢出 Out of Memory，是指程序在申请内存时，没有足够的内存空间供其使用，出现out of memory；比如申请了一个integer,但给它存了long才能存下的数，那就是内存溢出。</p>\n<p>内存泄露 Memory Leak，是指程序在申请内存后，无法释放已申请的内存空间，一次内存泄露危害可以忽略，但内存泄露堆积后果很严重，无论多少内存,迟早会被占光。</p>\n<p>用一个很形象的例子来说明：一个仓库，被无用的物资所占据，而得不到管理员的清理，这里的无用货物占用仓库空间的行为被叫做”内存泄漏“，而某一天仓库由于所存储的物品太多，而无法继续存放物资，这个时候就被叫做“内存溢出”。</p>\n<p><strong>3.内存泄漏导致的问题</strong></p>\n<p>相关内存无法被系统给回收，随着程序运行可以用的内存会越来越少，机子越来越卡，直到内存溢出。（这也是为什么手机电脑很卡之后重启一下后会好很多，主要是相关未被系统回收的内存被回收）</p>\n<p><strong>4、安卓中的内存泄漏</strong></p>\n<p>典型的可能产生内存泄漏的代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">MemoryLeakActivity</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">MyActivity</span> &#123;</span><br><span class=\"line\">   <span class=\"comment\">//可能会导致内存泄漏的代码</span></span><br><span class=\"line\">   <span class=\"keyword\">private</span> <span class=\"type\">Handler</span> <span class=\"variable\">handler</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Handler</span>() &#123;</span><br><span class=\"line\">       [<span class=\"meta\">@Override</span>](https:<span class=\"comment\">//my.oschina.net/u/1162528)</span></span><br><span class=\"line\">       <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">handleMessage</span><span class=\"params\">(Message msg)</span> &#123;</span><br><span class=\"line\">           <span class=\"built_in\">super</span>.handleMessage(msg);</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">   &#125;;&#125;</span><br></pre></td></tr></table></figure>\n<p>产生内存泄漏可能的原因：Handler的工作机制中Handler与Looper以及MessageQueue一起工作的，App启动之后，系统会默认创建一个为主线程服务的Looper对象，负责处理主线程中所有的Message对象，它的生命周期则为整个应用的生命周期。在主线程使用Handler都会默认绑定到这个Looper上面，主线程创建Handler对象，会立即关联Looper对象的MessageQueue，这时发送MessageQueue重的Message会持有Handler的引用， 这样在Looper处理Message时候才会回调到Handler的handleMessage方法。因此，如果Message没有被处理完成，那么Handler对象就不会被垃圾回收。</p>\n<img src=\"https://cdn.julis.wang/blog/img/6e154da75042608bc2e6e970e2452f7a857.jpg\">\n<p>上面的代码，将Handler的实例声明为MemoryLeakActivity类的内部类，在Java中：<strong>非静态内部匿名类会持有外部类的一个隐式引用，这样就可能导致外部类无法被垃圾回收。</strong></p>\n<p>最终由于MessageQueue中的Message 没有处理完成，就会持有Handler对象的引用，而非静态的Handler对象会持有外部类Activity的引用，这个activity无法被回收，从而导致内存泄漏。</p>\n<p><strong>5、解决方案</strong></p>\n<p>1、将Handler声明为静态内部类，这样就不会持有对外部类的引用。</p>\n<p>2、创建一个Looper与一般Java对象一样的生命周期</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> InnerHandler <span class=\"keyword\">extends</span> <span class=\"title class_\">Handler</span>&#123;       </span><br><span class=\"line\"> \t\t<span class=\"comment\">// 声明一个静态Handler类，并持有外部类引用</span></span><br><span class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">final</span> WeakReference&lt;MemoryLeakActivity&gt; mActivity;</span><br><span class=\"line\">       \t<span class=\"keyword\">public</span> <span class=\"title function_\">InnerHandler</span><span class=\"params\">(MemoryLeakActivity activity)</span>&#123;</span><br><span class=\"line\">          \t\t <span class=\"built_in\">this</span>.mActivity = <span class=\"keyword\">new</span> <span class=\"title class_\">WeakReference</span>&lt;MemoryLeakActivity&gt;(activity);</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>","categories":[{"name":"技术文章","slug":"technology","api":"api/categories/technology.json"}],"tags":[{"name":"安卓","slug":"Android","api":"api/tags/Android.json"}],"api":"api/posts/2019/03/18/Android中Handler使用导致的内存泄漏.json"}],"info":{"type":"tag","name":"安卓","slug":"Android"}},"api":"api/tags/Android/page.1.json"}