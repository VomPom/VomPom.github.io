{"data":{"index":1,"total":1,"posts":[{"title":"基于AndroidVideoCache的预加载","slug":"基于AndroidVideoCache的预加载","date":"2020-07-06T11:09:00.000Z","updated":"2025-05-20T11:46:57.000Z","comments":true,"url":"2020/07/06/基于AndroidVideoCache的预加载/","excerpt":"<p>最近有做需求关于视频缓存，了解到相关的开源库<a href=\"https://www.jianshu.com/p/dfc18278b053\">AndroidVideoCache</a>，\b一款市面上相对比较流行的视频缓存框架，而我想利用该框架进行视频缓存的处理，并且希望能够支持预加载。然而该框架作者在18年就已经停止了维护，所以留下了无限的编程空间给其他程序员，对于视频预加载，只搜到一篇<a href=\"https://www.jianshu.com/p/dfc18278b053\">《AndroidVideoCache源码详解以及改造系列-源码篇》</a>，然而点进该作者的博客列表，说好的预加载呢？？？后面也没有了下文，搜遍全网好像没有做AndroidVideoCache的预加载相关的事情，那么这样子的话……自己干吧。</p>\n<p>首先需要明白AndroidVideoCache的实现原理，推荐查看<a href=\"https://www.jianshu.com/p/4745de02dcdc\">《AndroidVideoCache-视频边播放边缓存的代理策略》</a>这里不再赘述。</p>\n<p>其实预加载的思路很简单，在进行一个播放视频后，再返回接下来需要预加载的视频url，启用后台线程去请求下载数据，不过中间涉及的细节逻辑比较多。</p>\n<h2 id=\"一、实现方案\"><a href=\"#一、实现方案\" class=\"headerlink\" title=\"一、实现方案\"></a>一、实现方案</h2><p>主要逻辑为：</p>\n<p>1、后台开启一个线程去请求并预加载一部分的数据</p>\n<p>2、可能需要预加载的数据大于&gt;1，利用队列先进入的先进行加载，加上前面的条件 使用HandlerThread再适合不过了。</p>\n<p>我们首先定义好需要去处理的任务情况：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">preload</span><span class=\"params\">( String method，Call call)</span> &#123;</span><br><span class=\"line\">       <span class=\"keyword\">switch</span> (method) &#123;</span><br><span class=\"line\">           <span class=\"keyword\">case</span> <span class=\"string\">&quot;addPreloadURL&quot;</span>:</span><br><span class=\"line\">               addPreloadURL(call); <span class=\"comment\">//添加url到预加载队列</span></span><br><span class=\"line\">               <span class=\"keyword\">break</span>;</span><br><span class=\"line\">           <span class=\"keyword\">case</span> <span class=\"string\">&quot;cancelPreloadURLIfNeeded&quot;</span>:</span><br><span class=\"line\">               cancelPreloadURLIfNeeded(call); <span class=\"comment\">//取消对应的url预加载（因为可能是立马需要播放这个视频，那么就不需要预加载了）</span></span><br><span class=\"line\">               <span class=\"keyword\">break</span>;</span><br><span class=\"line\">           <span class=\"keyword\">case</span> <span class=\"string\">&quot;cancelAnyPreloads&quot;</span>: </span><br><span class=\"line\">               cancelAnyPreLoads();<span class=\"comment\">//取消所有的预加载，主要是方便管理任务</span></span><br><span class=\"line\">               <span class=\"keyword\">break</span>;</span><br><span class=\"line\">           <span class=\"keyword\">default</span>:</span><br><span class=\"line\">           </span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n\n<p>那么对于每次的预加载逻辑基本上是这样的方法执行顺序：</p>\n<p> cancelPreloadURLIfNeeded()-&gt;addPreloadURL();   &#x2F;&#x2F;取消对应url加载的任务，因为有可能该url不需要再进行预加载了（参考抖音，当用户瞬间下滑几个视频，那么很多视频就需要跳过了不需要再进行预加载）</p>\n<p> cancelAnyPreLoads()-&gt;addPreloadURL();   &#x2F;&#x2F;取消对应url加载的任务（这时候需要立马播放最新的视频，那么就应该让出网速给该视频），之后再添加新一轮的预加载url。</p>\n<p>接下来具体的处理逻辑VideoPreLoader类，我直接放上所有的代码逻辑吧,为方便观察删除了一部分不太重要的逻辑，其实总体流程也比较简单。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">VideoPreLoader</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> Handler handler;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> HandlerThread handlerThread;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> List&lt;String&gt; cancelList = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"title function_\">VideoPreLoader</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    handlerThread = <span class=\"keyword\">new</span> <span class=\"title class_\">HandlerThread</span>(<span class=\"string\">&quot;VideoPreLoaderThread&quot;</span>);</span><br><span class=\"line\">    handlerThread.start();</span><br><span class=\"line\">    handler = <span class=\"keyword\">new</span> <span class=\"title class_\">Handler</span>(handlerThread.getLooper()) &#123;</span><br><span class=\"line\">      <span class=\"meta\">@Override</span></span><br><span class=\"line\">      <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">handleMessage</span><span class=\"params\">(Message msg)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">super</span>.handleMessage(msg);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">void</span> <span class=\"title function_\">addPreloadURL</span><span class=\"params\">(<span class=\"keyword\">final</span> VideoPreLoadModel data)</span> &#123;</span><br><span class=\"line\">    handler.post(<span class=\"keyword\">new</span> <span class=\"title class_\">Runnable</span>() &#123;</span><br><span class=\"line\">      <span class=\"meta\">@Override</span></span><br><span class=\"line\">      <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        realPreload(data);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">void</span> <span class=\"title function_\">cancelPreloadURLIfNeeded</span><span class=\"params\">(String url)</span> &#123;</span><br><span class=\"line\">    cancelList.add(url);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">void</span> <span class=\"title function_\">cancelAnyPreLoads</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    handler.removeCallbacksAndMessages(<span class=\"literal\">null</span>);</span><br><span class=\"line\">    cancelList.clear();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">realPreload</span><span class=\"params\">(VideoPreLoadModel data)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (data == <span class=\"literal\">null</span> || isCancel(data.originalUrl)) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"type\">HttpURLConnection</span> <span class=\"variable\">conn</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">      <span class=\"type\">URL</span> <span class=\"variable\">myURL</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">URL</span>(data.proxyUrl);</span><br><span class=\"line\">      conn = (HttpURLConnection) myURL.openConnection();</span><br><span class=\"line\">      conn.connect();</span><br><span class=\"line\">      <span class=\"type\">InputStream</span> <span class=\"variable\">is</span> <span class=\"operator\">=</span> conn.getInputStream();</span><br><span class=\"line\">      <span class=\"type\">byte</span>[] buf = <span class=\"keyword\">new</span> <span class=\"title class_\">byte</span>[<span class=\"number\">1024</span>];</span><br><span class=\"line\">      <span class=\"type\">int</span> <span class=\"variable\">downLoadedSize</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">      <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">numRead</span> <span class=\"operator\">=</span> is.read(buf);</span><br><span class=\"line\">        downLoadedSize += numRead;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (downLoadedSize &gt;= data.preLoadBytes || numRead == -<span class=\"number\">1</span>) &#123; <span class=\"comment\">//Reached  preload range or end of Input stream.</span></span><br><span class=\"line\">          <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125; <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>);</span><br><span class=\"line\">      is.close();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ....</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"type\">boolean</span> <span class=\"title function_\">isCancel</span><span class=\"params\">(String url)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (TextUtils.isEmpty(url)) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (String cancelUrl : cancelList) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (cancelUrl.equals(url)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>对于这段代码中其实有“两个”队列，一个是HandlerThread中的队列，熟悉消息机制的同学应该都能明白，内部是一个looper在不断地循环获取消息，当一个消息处理完毕之后才会处理下一个消息。我还定义了一个就是取消队列，因为HandlerThread中的任务我们不太好控制取消具体的任务，所以设置了一个取消队列，当之后的消息再需要执行的时候会首先判断是否是在取消队列里面，这样子就能做到对预加载队列逻辑的控制。</p>\n<h2 id=\"二、关于一些细节问题\"><a href=\"#二、关于一些细节问题\" class=\"headerlink\" title=\"二、关于一些细节问题\"></a>二、关于一些细节问题</h2><p>这样子我们在播放一个视频的时候，只需要传给我们接下来将会播放的视频的URL，我们就能对其预加载并缓存下来，但是会存在其他条件：</p>\n<h5 id=\"预加载的长度？\"><a href=\"#预加载的长度？\" class=\"headerlink\" title=\"预加载的长度？\"></a>预加载的长度？</h5><p>对于视频加载长度，我们很容易想到在视频url请求加入Range在header上面，比如</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">conn.addRequestProperty(<span class=\"string\">&quot;Range&quot;</span>, <span class=\"string\">&quot;0-102400&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n<p>我们只获取前102400 bytes，不用将整个视频全部进行预加载，我有进行这样的尝试，但是实际发现是有坑的。我做了很多尝试，发现不论怎么请求，拿到的 responseCode 虽然是206，但是 还是把数据给全部下载完了，这就有点不科学了！！</p>\n<p>最终去源码中才发现：源码有对range做正则匹配</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">Pattern</span> <span class=\"variable\">RANGE_HEADER_PATTERN</span> <span class=\"operator\">=</span> Pattern.compile(<span class=\"string\">&quot;[R,r]ange:[ ]?bytes=(\\\\d*)-&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"type\">long</span> <span class=\"title function_\">findRangeOffset</span><span class=\"params\">(String request)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">Matcher</span> <span class=\"variable\">matcher</span> <span class=\"operator\">=</span> RANGE_HEADER_PATTERN.matcher(request);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (matcher.find()) &#123;</span><br><span class=\"line\">            <span class=\"type\">String</span> <span class=\"variable\">rangeValue</span> <span class=\"operator\">=</span> matcher.group(<span class=\"number\">1</span>);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> Long.parseLong(rangeValue);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>看清楚了 <strong><em>“[R,r]ange:[ ]?bytes&#x3D;(\\d</em>)-“</strong>* 它只去匹配了前面的的，也就是说 我传入了 0-102400 它最终只当作是：Range：0- 来处理，导致addRequestProperty设置的range实现。坑！不过能理解作者为什么这么做，后面总结会讲到。没有办法只有使用最原始的方法进行判断了：在每次获取inputStream的时候进行判断是否达到预加载的大小，虽然有一定的性能开销，但是不去改源码的话也没有 办法了。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">      <span class=\"type\">int</span> <span class=\"variable\">numRead</span> <span class=\"operator\">=</span> is.read(buf);</span><br><span class=\"line\">      downLoadedSize += numRead;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (downLoadedSize &gt;= data.preLoadBytes || numRead == -<span class=\"number\">1</span>) &#123; <span class=\"comment\">//Reached  preload range or end of Input stream.</span></span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>);</span><br><span class=\"line\">    is.close();</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"三、总结\"><a href=\"#三、总结\" class=\"headerlink\" title=\"三、总结\"></a>三、总结</h2><p>本文主要讲了基于AndroidVideoCache的预加载具体实现原理，以及其中遇到的坑</p>\n<p>1、预加载主要通过HandlerThread去实现后台网络的访问以及缓存的处理逻辑</p>\n<p>2、加入取消队列去控制对应需要取消的任务</p>\n<p>3、对于预加载的size只能通过读取的时候进行判断，没有办法使用range去判断。其实很容易理解作者为什么正则要这样写，因为它只是一个视频缓存框架，主要是用来做“边播边存”，所以每次去进行请求的时候应该都是在原有的缓存之上去进行缓存数据处理，而缓存最终需要处理完的就是 content-size，不需要再去管Range中的结束范围了。</p>\n","cover":null,"images":[],"content":"<p>最近有做需求关于视频缓存，了解到相关的开源库<a href=\"https://www.jianshu.com/p/dfc18278b053\">AndroidVideoCache</a>，\b一款市面上相对比较流行的视频缓存框架，而我想利用该框架进行视频缓存的处理，并且希望能够支持预加载。然而该框架作者在18年就已经停止了维护，所以留下了无限的编程空间给其他程序员，对于视频预加载，只搜到一篇<a href=\"https://www.jianshu.com/p/dfc18278b053\">《AndroidVideoCache源码详解以及改造系列-源码篇》</a>，然而点进该作者的博客列表，说好的预加载呢？？？后面也没有了下文，搜遍全网好像没有做AndroidVideoCache的预加载相关的事情，那么这样子的话……自己干吧。</p>\n<p>首先需要明白AndroidVideoCache的实现原理，推荐查看<a href=\"https://www.jianshu.com/p/4745de02dcdc\">《AndroidVideoCache-视频边播放边缓存的代理策略》</a>这里不再赘述。</p>\n<p>其实预加载的思路很简单，在进行一个播放视频后，再返回接下来需要预加载的视频url，启用后台线程去请求下载数据，不过中间涉及的细节逻辑比较多。</p>\n<h2 id=\"一、实现方案\"><a href=\"#一、实现方案\" class=\"headerlink\" title=\"一、实现方案\"></a>一、实现方案</h2><p>主要逻辑为：</p>\n<p>1、后台开启一个线程去请求并预加载一部分的数据</p>\n<p>2、可能需要预加载的数据大于&gt;1，利用队列先进入的先进行加载，加上前面的条件 使用HandlerThread再适合不过了。</p>\n<p>我们首先定义好需要去处理的任务情况：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">preload</span><span class=\"params\">( String method，Call call)</span> &#123;</span><br><span class=\"line\">       <span class=\"keyword\">switch</span> (method) &#123;</span><br><span class=\"line\">           <span class=\"keyword\">case</span> <span class=\"string\">&quot;addPreloadURL&quot;</span>:</span><br><span class=\"line\">               addPreloadURL(call); <span class=\"comment\">//添加url到预加载队列</span></span><br><span class=\"line\">               <span class=\"keyword\">break</span>;</span><br><span class=\"line\">           <span class=\"keyword\">case</span> <span class=\"string\">&quot;cancelPreloadURLIfNeeded&quot;</span>:</span><br><span class=\"line\">               cancelPreloadURLIfNeeded(call); <span class=\"comment\">//取消对应的url预加载（因为可能是立马需要播放这个视频，那么就不需要预加载了）</span></span><br><span class=\"line\">               <span class=\"keyword\">break</span>;</span><br><span class=\"line\">           <span class=\"keyword\">case</span> <span class=\"string\">&quot;cancelAnyPreloads&quot;</span>: </span><br><span class=\"line\">               cancelAnyPreLoads();<span class=\"comment\">//取消所有的预加载，主要是方便管理任务</span></span><br><span class=\"line\">               <span class=\"keyword\">break</span>;</span><br><span class=\"line\">           <span class=\"keyword\">default</span>:</span><br><span class=\"line\">           </span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n\n<p>那么对于每次的预加载逻辑基本上是这样的方法执行顺序：</p>\n<p> cancelPreloadURLIfNeeded()-&gt;addPreloadURL();   &#x2F;&#x2F;取消对应url加载的任务，因为有可能该url不需要再进行预加载了（参考抖音，当用户瞬间下滑几个视频，那么很多视频就需要跳过了不需要再进行预加载）</p>\n<p> cancelAnyPreLoads()-&gt;addPreloadURL();   &#x2F;&#x2F;取消对应url加载的任务（这时候需要立马播放最新的视频，那么就应该让出网速给该视频），之后再添加新一轮的预加载url。</p>\n<p>接下来具体的处理逻辑VideoPreLoader类，我直接放上所有的代码逻辑吧,为方便观察删除了一部分不太重要的逻辑，其实总体流程也比较简单。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">VideoPreLoader</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> Handler handler;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> HandlerThread handlerThread;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> List&lt;String&gt; cancelList = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"title function_\">VideoPreLoader</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    handlerThread = <span class=\"keyword\">new</span> <span class=\"title class_\">HandlerThread</span>(<span class=\"string\">&quot;VideoPreLoaderThread&quot;</span>);</span><br><span class=\"line\">    handlerThread.start();</span><br><span class=\"line\">    handler = <span class=\"keyword\">new</span> <span class=\"title class_\">Handler</span>(handlerThread.getLooper()) &#123;</span><br><span class=\"line\">      <span class=\"meta\">@Override</span></span><br><span class=\"line\">      <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">handleMessage</span><span class=\"params\">(Message msg)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">super</span>.handleMessage(msg);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">void</span> <span class=\"title function_\">addPreloadURL</span><span class=\"params\">(<span class=\"keyword\">final</span> VideoPreLoadModel data)</span> &#123;</span><br><span class=\"line\">    handler.post(<span class=\"keyword\">new</span> <span class=\"title class_\">Runnable</span>() &#123;</span><br><span class=\"line\">      <span class=\"meta\">@Override</span></span><br><span class=\"line\">      <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        realPreload(data);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">void</span> <span class=\"title function_\">cancelPreloadURLIfNeeded</span><span class=\"params\">(String url)</span> &#123;</span><br><span class=\"line\">    cancelList.add(url);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">void</span> <span class=\"title function_\">cancelAnyPreLoads</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    handler.removeCallbacksAndMessages(<span class=\"literal\">null</span>);</span><br><span class=\"line\">    cancelList.clear();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">realPreload</span><span class=\"params\">(VideoPreLoadModel data)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (data == <span class=\"literal\">null</span> || isCancel(data.originalUrl)) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"type\">HttpURLConnection</span> <span class=\"variable\">conn</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">      <span class=\"type\">URL</span> <span class=\"variable\">myURL</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">URL</span>(data.proxyUrl);</span><br><span class=\"line\">      conn = (HttpURLConnection) myURL.openConnection();</span><br><span class=\"line\">      conn.connect();</span><br><span class=\"line\">      <span class=\"type\">InputStream</span> <span class=\"variable\">is</span> <span class=\"operator\">=</span> conn.getInputStream();</span><br><span class=\"line\">      <span class=\"type\">byte</span>[] buf = <span class=\"keyword\">new</span> <span class=\"title class_\">byte</span>[<span class=\"number\">1024</span>];</span><br><span class=\"line\">      <span class=\"type\">int</span> <span class=\"variable\">downLoadedSize</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">      <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">numRead</span> <span class=\"operator\">=</span> is.read(buf);</span><br><span class=\"line\">        downLoadedSize += numRead;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (downLoadedSize &gt;= data.preLoadBytes || numRead == -<span class=\"number\">1</span>) &#123; <span class=\"comment\">//Reached  preload range or end of Input stream.</span></span><br><span class=\"line\">          <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125; <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>);</span><br><span class=\"line\">      is.close();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ....</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"type\">boolean</span> <span class=\"title function_\">isCancel</span><span class=\"params\">(String url)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (TextUtils.isEmpty(url)) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (String cancelUrl : cancelList) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (cancelUrl.equals(url)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>对于这段代码中其实有“两个”队列，一个是HandlerThread中的队列，熟悉消息机制的同学应该都能明白，内部是一个looper在不断地循环获取消息，当一个消息处理完毕之后才会处理下一个消息。我还定义了一个就是取消队列，因为HandlerThread中的任务我们不太好控制取消具体的任务，所以设置了一个取消队列，当之后的消息再需要执行的时候会首先判断是否是在取消队列里面，这样子就能做到对预加载队列逻辑的控制。</p>\n<h2 id=\"二、关于一些细节问题\"><a href=\"#二、关于一些细节问题\" class=\"headerlink\" title=\"二、关于一些细节问题\"></a>二、关于一些细节问题</h2><p>这样子我们在播放一个视频的时候，只需要传给我们接下来将会播放的视频的URL，我们就能对其预加载并缓存下来，但是会存在其他条件：</p>\n<h5 id=\"预加载的长度？\"><a href=\"#预加载的长度？\" class=\"headerlink\" title=\"预加载的长度？\"></a>预加载的长度？</h5><p>对于视频加载长度，我们很容易想到在视频url请求加入Range在header上面，比如</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">conn.addRequestProperty(<span class=\"string\">&quot;Range&quot;</span>, <span class=\"string\">&quot;0-102400&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n<p>我们只获取前102400 bytes，不用将整个视频全部进行预加载，我有进行这样的尝试，但是实际发现是有坑的。我做了很多尝试，发现不论怎么请求，拿到的 responseCode 虽然是206，但是 还是把数据给全部下载完了，这就有点不科学了！！</p>\n<p>最终去源码中才发现：源码有对range做正则匹配</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">Pattern</span> <span class=\"variable\">RANGE_HEADER_PATTERN</span> <span class=\"operator\">=</span> Pattern.compile(<span class=\"string\">&quot;[R,r]ange:[ ]?bytes=(\\\\d*)-&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"type\">long</span> <span class=\"title function_\">findRangeOffset</span><span class=\"params\">(String request)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">Matcher</span> <span class=\"variable\">matcher</span> <span class=\"operator\">=</span> RANGE_HEADER_PATTERN.matcher(request);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (matcher.find()) &#123;</span><br><span class=\"line\">            <span class=\"type\">String</span> <span class=\"variable\">rangeValue</span> <span class=\"operator\">=</span> matcher.group(<span class=\"number\">1</span>);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> Long.parseLong(rangeValue);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>看清楚了 <strong><em>“[R,r]ange:[ ]?bytes&#x3D;(\\d</em>)-“</strong>* 它只去匹配了前面的的，也就是说 我传入了 0-102400 它最终只当作是：Range：0- 来处理，导致addRequestProperty设置的range实现。坑！不过能理解作者为什么这么做，后面总结会讲到。没有办法只有使用最原始的方法进行判断了：在每次获取inputStream的时候进行判断是否达到预加载的大小，虽然有一定的性能开销，但是不去改源码的话也没有 办法了。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">      <span class=\"type\">int</span> <span class=\"variable\">numRead</span> <span class=\"operator\">=</span> is.read(buf);</span><br><span class=\"line\">      downLoadedSize += numRead;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (downLoadedSize &gt;= data.preLoadBytes || numRead == -<span class=\"number\">1</span>) &#123; <span class=\"comment\">//Reached  preload range or end of Input stream.</span></span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>);</span><br><span class=\"line\">    is.close();</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"三、总结\"><a href=\"#三、总结\" class=\"headerlink\" title=\"三、总结\"></a>三、总结</h2><p>本文主要讲了基于AndroidVideoCache的预加载具体实现原理，以及其中遇到的坑</p>\n<p>1、预加载主要通过HandlerThread去实现后台网络的访问以及缓存的处理逻辑</p>\n<p>2、加入取消队列去控制对应需要取消的任务</p>\n<p>3、对于预加载的size只能通过读取的时候进行判断，没有办法使用range去判断。其实很容易理解作者为什么正则要这样写，因为它只是一个视频缓存框架，主要是用来做“边播边存”，所以每次去进行请求的时候应该都是在原有的缓存之上去进行缓存数据处理，而缓存最终需要处理完的就是 content-size，不需要再去管Range中的结束范围了。</p>\n","categories":[{"name":"技术文章","slug":"technology","api":"api/categories/technology.json"}],"tags":[{"name":"视频","slug":"视频","api":"api/tags/视频.json"}],"api":"api/posts/2020/07/06/基于AndroidVideoCache的预加载.json"}],"info":{"type":"tag","name":"视频","slug":"视频"}},"api":"api/tags/视频/page.1.json"}