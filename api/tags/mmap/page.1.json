{"data":{"index":1,"total":1,"posts":[{"title":"KV-存储之mmkv","slug":"KV-存储之mmkv","date":"2025-03-30T03:38:00.000Z","updated":"2025-05-20T11:46:57.000Z","comments":true,"url":"2025/03/30/KV-存储之mmkv/","excerpt":"<p>在平时的业务中，需要用到轻量级存储业务中的数据（例如设置数据存储），绝大多数时候 Anroid 管法提供的 <a href=\"https://developer.android.com/reference/android/content/SharedPreferences\">SharedPreferences</a>  组件就能实现，但针对一些需要高效的场景它就不那么使用了，不适合存储大量数据、多线程操作的不安全性、数据明文不安全性，以及不支持多进程之间的调用等各种问题。<br><a href=\"https://github.com/Tencent/MMKV\">MMKV</a>的诞生就是为了解决以上的问题，本文主要对 MMKV 源码的学习知识点进行一些总结。</p>\n<h2 id=\"核心设计与原理\"><a href=\"#核心设计与原理\" class=\"headerlink\" title=\"核心设计与原理\"></a>核心设计与原理</h2><p>在官方的开源工程中可以看到如下的一些介绍</p>\n<blockquote>\n<p>MMKV 是基于 mmap 内存映射的 key-value 组件，底层序列化&#x2F;反序列化使用 protobuf 实现，性能高，稳定性强。从 2015 年中至今在微信上使用，其性能和稳定性经过了时间的验证。</p>\n</blockquote>\n<h3 id=\"传统I-O与-mmap\"><a href=\"#传统I-O与-mmap\" class=\"headerlink\" title=\"传统I&#x2F;O与 mmap\"></a>传统I&#x2F;O与 mmap</h3><p>mmap 这个是 mmkv 实现的核心，没有 mmap 那么就没有 mmkv。对于 <code>SharedPreferences</code>的实现来说，每次的数据更新都将操作本地文件，而本地文件的写入是通过传统的I&#x2F;O实现。要理解两者的实现差异，需要先理解 Linux <strong>用户空间与内核空间</strong>设计。</p>\n<h4 id=\"用户空间与内核空间\"><a href=\"#用户空间与内核空间\" class=\"headerlink\" title=\"用户空间与内核空间\"></a><strong>用户空间与内核空间</strong></h4><p>Linux的进程是相互独立的，一个进程是不能直接操作或者访问别一个进程空间的。每个进程空间还分为用户空间和内核（Kernel）空间，相当于把Kernel和上层的应用程序抽像的隔离开。</p>\n<p><strong>用户空间</strong>和<strong>内核空间</strong>，用户空间是用户程序代码运行的地方，内核空间是内核代码运行的地方。为了安全，它们是隔离的，即使用户的程序崩溃了，内核也不受影响。</p>\n<p>这里有两个隔离，一个进程间是相互隔离的，二是进程内有用户空间和内核空间的隔离。</p>\n<p>进程间，用户空间的数据不可共享，所以用户空间 &#x3D; 不可共享空间<br>进程间，内核空间的数据可共享，所以内核空间 &#x3D; 可共享空间，所以Linux系统的内存通常是MemFree+Cache<br>所有进程共用1个内核空间。</p>\n<h4 id=\"传统I-O读写流程\"><a href=\"#传统I-O读写流程\" class=\"headerlink\" title=\"传统I&#x2F;O读写流程\"></a><strong>传统I&#x2F;O读写流程</strong></h4><p>常规文件读写操作（调用read&#x2F;fread等函数）过程如下：</p>\n<ul>\n<li><p>进程发起读写文件请求。</p>\n</li>\n<li><p>内核通过查找进程文件符表，定位到内核已打开文件集上的文件信息，从而找到此文件的<code>inode</code>。</p>\n</li>\n<li><p><code>inode</code> 在 <code>address_space</code> 上查找要请求的文件页是否已经缓存在页缓存中。如果存在，则直接返回这片文件页的内容。</p>\n</li>\n<li><p>如果不存在，则通过 <code>inode</code> 定位到文件磁盘地址，将数据从磁盘复制到页缓存。之后再次发起读页面过程，进而将页缓存中的数据发给用户进程。</p>\n<blockquote>\n<p><strong>什么是 inode</strong> ?</p>\n<p>全称为 index node，既<strong>存储文件元信息的区域</strong>，中文译名“索引节点”。<br>包含：文件权限、文件拥有者的UID、文件的大小等等。</p>\n</blockquote>\n</li>\n</ul>\n<img src=\"https://cdn.julis.wang/blog/img/ee519ba873acf3f80fd4ccec86ed72e7.png\">\n\n\n<p>总结来说，常规文件操作为了提高读写效率和保护磁盘，使用了页缓存机制。这样造成读文件时需要先将文件页从磁盘拷贝到页缓存中，由于页缓存处在内核空间，不能被用户进程直接寻址访问，所以还需要将页缓存中的数据页再次拷贝到用户空间中。这样，通过了两次数据拷贝过程，才能完成<strong>进程</strong>对<strong>文件</strong>内容的访问。</p>\n<h4 id=\"mmap基本概念和原理\"><a href=\"#mmap基本概念和原理\" class=\"headerlink\" title=\"mmap基本概念和原理\"></a><strong>mmap基本概念和原理</strong></h4><p>内存映射（mmap），就是<strong>将文件的磁盘扇区映射到进程的虚拟内存空间</strong>的过程，即将一个文件映射到进程的虚拟空间，实现文件磁盘地址和进程虚拟空间中一段虚拟地址的一一对应关系。实现这样的映射关系后，进程就可以采用指针的方式读写操作这一段内存，而系统会自动回写脏页面到对应的文件磁盘上，即完成了对文件的操作而不必再调用read,write等系统调用函数。</p>\n<img src=\"https://cdn.julis.wang/blog/img/mmap_1.png\">\n\n<p>由上图可知，进程的虚拟地址空间，由多个虚拟内存区域构成。每个虚拟内存区域都是进程在虚拟地址空间中的一个同质区间，即具有同样特性的连续地址范围。上图中所示的text数据段（代码段）、初始数据段、BSS数据段、堆、栈和内存映射，都是一个独立的虚拟内存区域。内存映射的地址空间处在堆栈之间的空余部分。</p>\n<p>linux内核使用 <code>vm_area_struc</code>t 结构来表示一个独立的虚拟内存区域，由于每个不同质的虚拟内存区域功能和内部机制都不同，因此一个进程使用多个 <code>vm_area_struct</code> 结构来分别表示不同类型的虚拟内存区域。各个 <code>vm_area_struct</code> 结构使用链表或者树形结构链接，方便进程快速访问，如下图所示：</p>\n<img src=\"https://cdn.julis.wang/blog/img/mmap_2_1.png\">\n\n<p><code>vm_area_struct</code> 结构中包含区域起始和终止地址以及其他相关信息。这样，进程对某一虚拟内存区域的任何操作需要用要的信息，都可以从 <code>vm_area_struct</code> 中获得。mmap函数就是要创建一个新的 <code>vm_area_struct</code> 结构，并将其与文件的物理磁盘地址相连。</p>\n<p>mmap内存映射的实现过程，总的来说可以分为三个阶段：</p>\n<p><strong>阶段一：进程启动映射过程，并在虚拟地址空间中为映射创建虚拟映射区域</strong></p>\n<ul>\n<li>进程在用户空间调用mmap库函数</li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> *<span class=\"title\">mmap</span><span class=\"params\">(<span class=\"type\">void</span> *addr, <span class=\"type\">size_t</span> length, <span class=\"type\">int</span> prot, <span class=\"type\">int</span> flags, <span class=\"type\">int</span> fd, <span class=\"type\">off_t</span> offset)</span></span>;</span><br></pre></td></tr></table></figure>\n\n<p><code>addr</code>：指定映射的虚拟内存地址，可以设置为 NULL，让内核自动选择合适的虚拟内存地址</p>\n<p><code>length</code>：映射的长度。</p>\n<p><code>prot</code>：映射内存的保护模式，可选值如下：  </p>\n<p><code>flags</code>：指定映射的类型</p>\n<p><code>fd</code>：进行映射的文件句柄。</p>\n<p><code>offset</code>：文件偏移量（从文件的何处开始映射）</p>\n<ul>\n<li><p>在当前进程的虚拟地址空间中，寻找一段空闲的满足要求的连续的虚拟地址</p>\n</li>\n<li><p>为此虚拟区分配一个 <code>vm_area_struct</code> 结构，接着对这个结构的各个域进行了初始化</p>\n</li>\n<li><p>将新创建的虚拟区结构 <code>vm_area_struct</code> 对象插入到进程的虚拟地址区域链表&#x2F;树中</p>\n</li>\n</ul>\n<p><strong>阶段二：调用内核空间的mmap函数（不同于用户空间函数），实现文件物理地址和进程虚拟地址的一一映射关系</strong></p>\n<ul>\n<li><p>为映射分配了新的虚拟地址区域后，通过待映射的文件指针，在文件描述符表中找到对应的文件描述符，通过文件描述符，链接到内核“已打开文件集”中该文件的文件结构体（struct file），每个文件结构体维护着和这个已打开文件相关各项信息。</p>\n</li>\n<li><p>为映射分配了新的虚拟地址区域后，通过待映射的文件指针，在文件描述符表中找到对应的文件描述符，通过文件描述符，链接到内核“已打开文件集”中该文件的文件结构体（struct file），每个文件结构体维护着和这个已打开文件相关各项信息。</p>\n</li>\n<li><p>通过该文件的文件结构体，链接到 <code>file_operations</code> 模块，调用内核mmap函数，其原型为：</p>\n</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">int mmap(struct file *filp, struct vm_area_struct *vma) //不同于用户空间mmap库函数</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>内核mmap函数通过虚拟文件系统inode模块定位到文件磁盘物理地址。</p>\n</li>\n<li><p>通过 <code>remap_pfn_range</code> 函数建立页表，即实现了文件地址和虚拟地址区域的映射关系。此时，这片虚拟地址并没有任何数据关联到物理内存(主存)中。</p>\n</li>\n</ul>\n<blockquote>\n<p>主存</p>\n<p>主存储器（Main memory），简称主存。是计算机硬件的一个重要部件，其作用是存放指令和数据，并能由中央处理器（CPU）直接随机存取</p>\n</blockquote>\n<p><strong>阶段三：进程发起对这片映射地址空间的访问，引发缺页异常，实现文件内容到主存（物理内存）的拷贝</strong></p>\n<blockquote>\n<p>前两个阶段仅在于创建虚拟区间并完成地址映射，但是并没有将任何文件数据的拷贝至主存。真正的文件读取是当进程发起读或写操作时</p>\n</blockquote>\n<ul>\n<li><p>进程的读或写操作访问虚拟地址空间这一段映射地址，通过查询页表，发现这一段地址并不在物理页上。因为目前只建立了地址映射，真正的硬盘数据还没有拷贝到内存中，因此引发缺页异常。</p>\n</li>\n<li><p>缺页异常进行一系列判断，确定无非法操作后，内核发起请求调页过程。</p>\n</li>\n<li><p>调页过程先在交换缓存空间（swap cache）中寻找需要访问的内存页，如果没有则调用nopage函数把所缺的页从磁盘装入到主存中。</p>\n</li>\n<li><p>之后进程即可对这片主存进行读或者写的操作，如果写操作改变了其内容，一定时间后系统会自动回写脏页面到对应磁盘地址，也即完成了写入到文件的过程。</p>\n</li>\n</ul>\n<blockquote>\n<p>修改过的脏页面并不会立即更新回文件中，而是有一段时间的延迟，可以调用<code>msync()</code>来强制同步, 这样所写的内容就能立即保存到文件里了</p>\n</blockquote>\n<p>常规文件操作需要从磁盘到内核空间页缓存再到用户空间主存的两次数据拷贝。而mmap文件映射，只需要从磁盘到用户空间主存的一次数据拷贝过程。mmap的关键点是实现了用户空间和内核空间的数据直接交互而省去了空间不同数据不通的繁琐过程，因此 mmap 效率更高。</p>\n<p>以上是 mmap 的基本概念和原理，搞明白了这些才能看明白整个 mmkv 里面的逻辑处理</p>\n<h3 id=\"mmkv-一次-put-的流程\"><a href=\"#mmkv-一次-put-的流程\" class=\"headerlink\" title=\"mmkv 一次 put 的流程\"></a>mmkv 一次 put 的流程</h3><p>mmkv初始化比较简单，主要涉及到一些配置的初始化，文件夹创建等，其中最重要的逻辑 mmap 调用被封装到一个 <code>MemoryFile</code>到对象里面 </p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">MemoryFile::mmap</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">auto</span> oldPtr = m_ptr;</span><br><span class=\"line\">    <span class=\"keyword\">auto</span> mode = m_readOnly ? PROT_READ : (PROT_READ | PROT_WRITE);</span><br><span class=\"line\">    m_ptr = (<span class=\"type\">char</span> *) ::<span class=\"built_in\">mmap</span>(m_ptr, m_size, mode, MAP_SHARED, m_diskFile.m_fd, <span class=\"number\">0</span>);</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>主要记录一下一次 put 任务的流程，以 <code>mmkv.putInt(&quot;int&quot;, 1)</code>为例，进过 JNI 的调用到了</p>\n<p><strong>native-birdge.cpp</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">MMKV_JNI jboolean <span class=\"title\">encodeInt</span><span class=\"params\">(JNIEnv *env, jobject obj, jlong handle, jstring oKey, jint value)</span> </span>&#123;</span><br><span class=\"line\">    MMKV *kv = <span class=\"built_in\">reinterpret_cast</span>&lt;MMKV *&gt;(handle);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (kv &amp;&amp; oKey) &#123;</span><br><span class=\"line\">        string key = <span class=\"built_in\">jstring2string</span>(env, oKey);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (jboolean) kv-&gt;<span class=\"built_in\">set</span>((<span class=\"type\">int32_t</span>) value, key);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (jboolean) <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>进入了<strong>MMVK.cpp</strong>的 </p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">MMKV::set</span><span class=\"params\">(<span class=\"type\">int32_t</span> value, MMKVKey_t key, <span class=\"type\">uint32_t</span> expireDuration)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">isKeyEmpty</span>(key)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"type\">size_t</span> size = <span class=\"built_in\">mmkv_unlikely</span>(m_enableKeyExpire) ? Fixed32Size + <span class=\"built_in\">pbInt32Size</span>(value) : <span class=\"built_in\">pbInt32Size</span>(value);</span><br><span class=\"line\">    <span class=\"function\">MMBuffer <span class=\"title\">data</span><span class=\"params\">(size)</span></span>;</span><br><span class=\"line\">    <span class=\"function\">CodedOutputData <span class=\"title\">output</span><span class=\"params\">(data.getPtr(), size)</span></span>;</span><br><span class=\"line\">    output.<span class=\"built_in\">writeInt32</span>(value);</span><br><span class=\"line\">    <span class=\"comment\">// ... 省略一些校验逻辑</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">setDataForKey</span>(std::<span class=\"built_in\">move</span>(data), key);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这一步主要是准备一下数据，并使用 <code>MMBuffer</code> <code>CodedOutputData</code>将写入的数据进行一次包装（不仅仅是 key-value，还有数据size等等），实际调用在<code>setDataForKey</code></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">MMKV::setDataForKey</span><span class=\"params\">(MMBuffer &amp;&amp;data, MMKVKey_t key, <span class=\"type\">bool</span> isDataHolder)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">checkLoadData</span>(); <span class=\"comment\">// 状态同步相关的逻辑</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (m_crypter) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// ... 省略加密的处理逻辑</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">auto</span> itr = m_dic-&gt;<span class=\"built_in\">find</span>(key);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (itr != m_dic-&gt;<span class=\"built_in\">end</span>()) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// compare data before appending to file</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (<span class=\"built_in\">isCompareBeforeSetEnabled</span>()) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">auto</span> basePtr = (<span class=\"type\">uint8_t</span> *) (m_file-&gt;<span class=\"built_in\">getMemory</span>()) + Fixed32Size;</span><br><span class=\"line\">                MMBuffer oldValueData = itr-&gt;second.<span class=\"built_in\">toMMBuffer</span>(basePtr);</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (isDataHolder) &#123;</span><br><span class=\"line\">                    <span class=\"function\">CodedInputData <span class=\"title\">inputData</span><span class=\"params\">(oldValueData.getPtr(), oldValueData.length())</span></span>;</span><br><span class=\"line\">                    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                        <span class=\"comment\">// read extra holder header bytes and to real MMBuffer</span></span><br><span class=\"line\">                        oldValueData = CodedInputData::<span class=\"built_in\">readRealData</span>(oldValueData);</span><br><span class=\"line\">                        <span class=\"keyword\">if</span> (oldValueData == data) &#123;</span><br><span class=\"line\">                            <span class=\"comment\">// MMKVInfo(&quot;[key] %s, set the same data&quot;, key.c_str());</span></span><br><span class=\"line\">                            <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125; <span class=\"built_in\">catch</span> (std::exception &amp;exception) &#123;</span><br><span class=\"line\">                        <span class=\"built_in\">MMKVWarning</span>(<span class=\"string\">&quot;compareBeforeSet exception: %s&quot;</span>, exception.<span class=\"built_in\">what</span>());</span><br><span class=\"line\">                    &#125; <span class=\"built_in\">catch</span> (...) &#123;</span><br><span class=\"line\">                        <span class=\"built_in\">MMKVWarning</span>(<span class=\"string\">&quot;compareBeforeSet fail&quot;</span>);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                     ...</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"type\">bool</span> onlyOneKey = !<span class=\"built_in\">isMultiProcess</span>() &amp;&amp; m_dic-&gt;<span class=\"built_in\">size</span>() == <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (<span class=\"built_in\">mmkv_likely</span>(!m_enableKeyExpire)) &#123;</span><br><span class=\"line\">                ...</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                KVHolderRet_t ret;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (onlyOneKey) &#123;</span><br><span class=\"line\">                    ret = <span class=\"built_in\">overrideDataWithKey</span>(data, key, isDataHolder);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    ret = <span class=\"built_in\">appendDataWithKey</span>(data, key, isDataHolder);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (!ret.first) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                itr = m_dic-&gt;<span class=\"built_in\">find</span>(key);</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (itr != m_dic-&gt;<span class=\"built_in\">end</span>()) &#123;</span><br><span class=\"line\">                    itr-&gt;second = std::<span class=\"built_in\">move</span>(ret.second);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// in case filterExpiredKeys() is triggered</span></span><br><span class=\"line\">                    m_dic-&gt;<span class=\"built_in\">emplace</span>(key, std::<span class=\"built_in\">move</span>(ret.second));</span><br><span class=\"line\">                    <span class=\"built_in\">mmkv_retain_key</span>(key);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">           ...</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    m_hasFullWriteback = <span class=\"literal\">false</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里面的代码逻辑很长，做了很多 if-else 的逻辑，最终走向两个大分支：</p>\n<p>key 是新增的走 <code>appendDataWithKey</code></p>\n<p>key 将会覆盖原来的将会走 <code>overrideDataWithKey</code></p>\n<p>有这两个分支，主要是因为 mmkv 存储采用的  <a href=\"https://protobuf.com.cn/\">protobuf 协议</a>，另外有一个很重要的方法也在这里执行了：<code>checkLoadData();</code>  安卓里面的多进程实现，将需要这里的一些逻辑，在 mmkv多进程原理篇进行讲解。</p>\n<p><code>appendDataWithKey</code> 转换为 <code>MMBuffer</code>并继续向下执行</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">KVHolderRet_t <span class=\"title\">MMKV::appendDataWithKey</span><span class=\"params\">(<span class=\"type\">const</span> MMBuffer &amp;data, MMKVKey_t key, <span class=\"type\">bool</span> isDataHolder)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">auto</span> keyData = <span class=\"built_in\">MMBuffer</span>((<span class=\"type\">void</span> *) key.<span class=\"built_in\">data</span>(), key.<span class=\"built_in\">size</span>(), MMBufferNoCopy);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">doAppendDataWithKey</span>(data, keyData, isDataHolder, <span class=\"built_in\">static_cast</span>&lt;<span class=\"type\">uint32_t</span>&gt;(keyData.<span class=\"built_in\">length</span>()));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>doAppendDataWithKey</code> 里面的代码也很长，不过也就只做一件事：将k-v值写入到文件里面做准备，真正的写入逻辑在 <code>m_output-&gt;writeData(keyData);</code>，这里先后调用了两次 <code>writeData</code>,是先写入key再写入了 value。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">KVHolderRet_t</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">MMKV::doAppendDataWithKey</span><span class=\"params\">(<span class=\"type\">const</span> MMBuffer &amp;data, <span class=\"type\">const</span> MMBuffer &amp;keyData, <span class=\"type\">bool</span> isDataHolder, <span class=\"type\">uint32_t</span> originKeyLength)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">auto</span> isKeyEncoded = (originKeyLength &lt; keyData.<span class=\"built_in\">length</span>());</span><br><span class=\"line\">    <span class=\"keyword\">auto</span> keyLength = <span class=\"built_in\">static_cast</span>&lt;<span class=\"type\">uint32_t</span>&gt;(keyData.<span class=\"built_in\">length</span>());</span><br><span class=\"line\">    <span class=\"keyword\">auto</span> valueLength = <span class=\"built_in\">static_cast</span>&lt;<span class=\"type\">uint32_t</span>&gt;(data.<span class=\"built_in\">length</span>());</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (isDataHolder) &#123;</span><br><span class=\"line\">        valueLength += <span class=\"built_in\">pbRawVarint32Size</span>(valueLength);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// size needed to encode the key</span></span><br><span class=\"line\">    <span class=\"type\">size_t</span> size = isKeyEncoded ? keyLength : (keyLength + <span class=\"built_in\">pbRawVarint32Size</span>(keyLength));</span><br><span class=\"line\">    <span class=\"comment\">// size needed to encode the value</span></span><br><span class=\"line\">    size += valueLength + <span class=\"built_in\">pbRawVarint32Size</span>(valueLength);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">SCOPED_LOCK</span>(m_exclusiveProcessLock);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">bool</span> hasEnoughSize = <span class=\"built_in\">ensureMemorySize</span>(size);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!hasEnoughSize || !<span class=\"built_in\">isFileValid</span>()) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">make_pair</span>(<span class=\"literal\">false</span>, <span class=\"built_in\">KeyValueHolder</span>());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">\t\t...</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (isKeyEncoded) &#123;</span><br><span class=\"line\">            m_output-&gt;<span class=\"built_in\">writeRawData</span>(keyData);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            m_output-&gt;<span class=\"built_in\">writeData</span>(keyData);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (isDataHolder) &#123;</span><br><span class=\"line\">            m_output-&gt;<span class=\"built_in\">writeRawVarint32</span>((<span class=\"type\">int32_t</span>) valueLength);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        m_output-&gt;<span class=\"built_in\">writeData</span>(data); <span class=\"comment\">// note: write size of data</span></span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">    ...</span><br><span class=\"line\">    m_actualSize += size;</span><br><span class=\"line\">    <span class=\"built_in\">updateCRCDigest</span>(ptr, size);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">make_pair</span>(<span class=\"literal\">true</span>, <span class=\"built_in\">KeyValueHolder</span>(originKeyLength, valueLength, offset));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>writeData</code> 进行了两步先写入数据的 <strong>长度信息</strong>，再写入真实的数据，这里还是因为  <a href=\"https://protobuf.com.cn/\">protobuf 协议</a>设计相关</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">CodedOutputData::writeData</span><span class=\"params\">(<span class=\"type\">const</span> MMBuffer &amp;value)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>-&gt;<span class=\"built_in\">writeRawVarint32</span>((<span class=\"type\">int32_t</span>) value.<span class=\"built_in\">length</span>());</span><br><span class=\"line\">    <span class=\"keyword\">this</span>-&gt;<span class=\"built_in\">writeRawData</span>(value);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>最终走到了<code>writeRawData</code> 关键代码</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">CodedOutputData::writeRawData</span><span class=\"params\">(<span class=\"type\">const</span> MMBuffer &amp;data)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"type\">size_t</span> numberOfBytes = data.<span class=\"built_in\">length</span>();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (m_position + numberOfBytes &gt; m_size) &#123;</span><br><span class=\"line\">       ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">memcpy</span>(m_ptr + m_position, data.<span class=\"built_in\">getPtr</span>(), numberOfBytes);</span><br><span class=\"line\">    m_position += numberOfBytes;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>核心逻辑使用 <code>memcpy</code> 将数据直接通过 memcpy 直接在内存层面进行拷贝，而这里的 <code>m_ptr</code>就是最开始通过<code>mmap</code>创建出来的指针！！到这里一次写入基本上就结束了。</p>\n<h3 id=\"mmkv-一次-get-的流程\"><a href=\"#mmkv-一次-get-的流程\" class=\"headerlink\" title=\"mmkv 一次 get 的流程\"></a>mmkv 一次 get 的流程</h3><p>依然先通过 JNI走到</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">MMKV_JNI jint <span class=\"title\">decodeInt</span><span class=\"params\">(JNIEnv *env, jobject obj, jlong handle, jstring oKey, jint defaultValue)</span> </span>&#123;</span><br><span class=\"line\">    MMKV *kv = <span class=\"built_in\">reinterpret_cast</span>&lt;MMKV *&gt;(handle);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (kv &amp;&amp; oKey) &#123;</span><br><span class=\"line\">        string key = <span class=\"built_in\">jstring2string</span>(env, oKey);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (jint) kv-&gt;<span class=\"built_in\">getInt32</span>(key, defaultValue);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> defaultValue;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>再到 mmkv getInt32</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int32_t</span> <span class=\"title\">MMKV::getInt32</span><span class=\"params\">(MMKVKey_t key, <span class=\"type\">int32_t</span> defaultValue, <span class=\"type\">bool</span> *hasValue)</span> </span>&#123;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">    <span class=\"built_in\">SCOPED_LOCK</span>(m_lock);</span><br><span class=\"line\">    <span class=\"built_in\">SCOPED_LOCK</span>(m_sharedProcessLock);</span><br><span class=\"line\">    <span class=\"keyword\">auto</span> data = <span class=\"built_in\">getDataForKey</span>(key);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (data.<span class=\"built_in\">length</span>() &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"function\">CodedInputData <span class=\"title\">input</span><span class=\"params\">(data.getPtr(), data.length())</span></span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (hasValue != <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">                *hasValue = <span class=\"literal\">true</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> input.<span class=\"built_in\">readInt32</span>();</span><br><span class=\"line\">        &#125; </span><br><span class=\"line\">        ...</span><br><span class=\"line\">    <span class=\"keyword\">return</span> defaultValue;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>getRawDataForKey</code>方法，主要有两个分支，一种是加密逻辑，另一种是非加密逻辑，但他们流程都差不多从一个  map 里面根据 key 获取一个对象（这个对象暂时并不是 get 最终的返回值），那这个 map 是从哪里来的呢？</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">MMBuffer <span class=\"title\">MMKV::getRawDataForKey</span><span class=\"params\">(MMKVKey_t key)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">checkLoadData</span>();</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">ifndef</span> MMKV_DISABLE_CRYPT</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (m_crypter) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">auto</span> itr = m_dicCrypt-&gt;<span class=\"built_in\">find</span>(key);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (itr != m_dicCrypt-&gt;<span class=\"built_in\">end</span>()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">auto</span> basePtr = (<span class=\"type\">uint8_t</span> *) (m_file-&gt;<span class=\"built_in\">getMemory</span>()) + Fixed32Size;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> itr-&gt;second.<span class=\"built_in\">toMMBuffer</span>(basePtr, m_crypter);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span></span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">auto</span> itr = m_dic-&gt;<span class=\"built_in\">find</span>(key);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (itr != m_dic-&gt;<span class=\"built_in\">end</span>()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">auto</span> basePtr = (<span class=\"type\">uint8_t</span> *) (m_file-&gt;<span class=\"built_in\">getMemory</span>()) + Fixed32Size;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> itr-&gt;second.<span class=\"built_in\">toMMBuffer</span>(basePtr);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    MMBuffer nan;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> nan;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>从源码里面溯源<code>m_dicCrypt</code>和 <code>m_dic</code> 是在 MMKV 初始化的时候生成的，主要逻辑在 <code>MMKV_IO .cpp</code>里面的 <code>loadFromFile</code>方法内：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">MMKV::loadFromFile</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">loadMetaInfoAndCheck</span>();</span><br><span class=\"line\">\t\t...</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!m_file-&gt;<span class=\"built_in\">isFileValid</span>()) &#123;</span><br><span class=\"line\">        m_file-&gt;<span class=\"built_in\">reloadFromFile</span>(m_expectedCapacity);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!m_file-&gt;<span class=\"built_in\">isFileValid</span>()) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">MMKVError</span>(<span class=\"string\">&quot;file [%s] not valid&quot;</span>, m_path.<span class=\"built_in\">c_str</span>());</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">bool</span> loadFromFile = <span class=\"literal\">false</span>, needFullWriteback = <span class=\"literal\">false</span>;</span><br><span class=\"line\">        <span class=\"built_in\">checkDataValid</span>(loadFromFile, needFullWriteback);</span><br><span class=\"line\">        ...</span><br><span class=\"line\">        <span class=\"keyword\">auto</span> ptr = (<span class=\"type\">uint8_t</span> *) m_file-&gt;<span class=\"built_in\">getMemory</span>();</span><br><span class=\"line\">        <span class=\"comment\">// loading</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (loadFromFile &amp;&amp; m_actualSize &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\t\t\t...</span><br><span class=\"line\">            <span class=\"function\">MMBuffer <span class=\"title\">inputBuffer</span><span class=\"params\">(ptr + Fixed32Size, m_actualSize, MMBufferNoCopy)</span></span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (m_crypter) &#123;</span><br><span class=\"line\">                <span class=\"built_in\">clearDictionary</span>(m_dicCrypt);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"built_in\">clearDictionary</span>(m_dic);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (needFullWriteback) &#123;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">ifndef</span> MMKV_DISABLE_CRYPT</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (m_crypter) &#123;</span><br><span class=\"line\">                    MiniPBCoder::<span class=\"built_in\">greedyDecodeMap</span>(*m_dicCrypt, inputBuffer, m_crypter);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span></span></span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    MiniPBCoder::<span class=\"built_in\">greedyDecodeMap</span>(*m_dic, inputBuffer);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">ifndef</span> MMKV_DISABLE_CRYPT</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (m_crypter) &#123;</span><br><span class=\"line\">                    MiniPBCoder::<span class=\"built_in\">decodeMap</span>(*m_dicCrypt, inputBuffer, m_crypter);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span></span></span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    MiniPBCoder::<span class=\"built_in\">decodeMap</span>(*m_dic, inputBuffer);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            m_output = <span class=\"keyword\">new</span> <span class=\"built_in\">CodedOutputData</span>(ptr + Fixed32Size, m_file-&gt;<span class=\"built_in\">getFileSize</span>() - Fixed32Size);</span><br><span class=\"line\">            m_output-&gt;<span class=\"built_in\">seek</span>(m_actualSize);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (needFullWriteback) &#123;</span><br><span class=\"line\">                <span class=\"built_in\">fullWriteback</span>();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// file not valid or empty, discard everything</span></span><br><span class=\"line\">            <span class=\"built_in\">SCOPED_LOCK</span>(m_exclusiveProcessLock);</span><br><span class=\"line\"></span><br><span class=\"line\">            m_output = <span class=\"keyword\">new</span> <span class=\"built_in\">CodedOutputData</span>(ptr + Fixed32Size, m_file-&gt;<span class=\"built_in\">getFileSize</span>() - Fixed32Size);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (m_actualSize &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                <span class=\"built_in\">writeActualSize</span>(<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"literal\">nullptr</span>, IncreaseSequence);</span><br><span class=\"line\">                <span class=\"built_in\">sync</span>(MMKV_SYNC);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"built_in\">writeActualSize</span>(<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"literal\">nullptr</span>, KeepSequence);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">\t\t\t\t...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    m_needLoadFromFile = <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>总统来说就是在初始化的时候就会将基于<code>protobuf</code>协议的本地文件里面的数据加载到内存，并将其放在一个 map 内，方便后续使用。</p>\n<p>回到 <code>int32_t MMKV::getInt32()</code>通过 <code>getDataForKey(key)</code>获取到一个<code>MMBuffer</code>对象，并通过 <strong>CodedInputData</strong>进行反序列化操作，读取 <strong>Varint32</strong> 的 <strong>valueSize</strong> 值，随后不断循环通过 <strong>CodedInputData</strong>  读取到<strong>value</strong> 值。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int32_t</span> <span class=\"title\">MMKV::getInt32</span><span class=\"params\">(MMKVKey_t key, <span class=\"type\">int32_t</span> defaultValue, <span class=\"type\">bool</span> *hasValue)</span> </span>&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"keyword\">auto</span> data = <span class=\"built_in\">getDataForKey</span>(key);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (data.<span class=\"built_in\">length</span>() &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"function\">CodedInputData <span class=\"title\">input</span><span class=\"params\">(data.getPtr(), data.length())</span></span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (hasValue != <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">                *hasValue = <span class=\"literal\">true</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> input.<span class=\"built_in\">readInt32</span>();</span><br><span class=\"line\">        &#125; </span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  \t...</span><br><span class=\"line\">    <span class=\"keyword\">return</span> defaultValue;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"mmkv-与-SharedPreferences\"><a href=\"#mmkv-与-SharedPreferences\" class=\"headerlink\" title=\"mmkv 与 SharedPreferences\"></a>mmkv 与 SharedPreferences</h2><p>以下是 <strong>MMKV</strong> 与 <strong>SharedPreferences</strong> 的优劣势对比总结，结合性能、安全性、功能支持等核心维度进行分析：</p>\n<h3 id=\"性能对比\"><a href=\"#性能对比\" class=\"headerlink\" title=\"性能对比\"></a><strong>性能对比</strong></h3><table>\n<thead>\n<tr>\n<th align=\"left\"><strong>维度</strong></th>\n<th align=\"left\"><strong>SharedPreferences</strong></th>\n<th align=\"left\"><strong>MMKV</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><strong>读写速度</strong></td>\n<td align=\"left\">慢（同步 I&#x2F;O，多次数据拷贝）</td>\n<td align=\"left\">快（<code>mmap</code> 零拷贝，内存直接操作）</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>线程安全</strong></td>\n<td align=\"left\">需自行加锁（<code>apply()</code> 异步写入仍有风险）</td>\n<td align=\"left\">内置多线程锁（文件锁 + 内存锁）</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>大数据量支持</strong></td>\n<td align=\"left\">性能急剧下降（全量 XML 解析&#x2F;序列化）</td>\n<td align=\"left\">高效（增量更新，Protobuf 编码）</td>\n</tr>\n</tbody></table>\n<h3 id=\"安全性与稳定性\"><a href=\"#安全性与稳定性\" class=\"headerlink\" title=\"安全性与稳定性\"></a><strong>安全性与稳定性</strong></h3><table>\n<thead>\n<tr>\n<th align=\"left\"><strong>维度</strong></th>\n<th align=\"left\"><strong>SharedPreferences</strong></th>\n<th align=\"left\"><strong>MMKV</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><strong>数据加密</strong></td>\n<td align=\"left\">无（明文存储）</td>\n<td align=\"left\">支持 AES-128&#x2F;AES-256 加密</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>崩溃恢复</strong></td>\n<td align=\"left\">可能因异常导致 XML 损坏</td>\n<td align=\"left\">通过 CRC 校验 + 备份文件保障完整性</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>系统版本适配</strong></td>\n<td align=\"left\">部分版本有 ANR 问题（如 <code>apply()</code>）</td>\n<td align=\"left\">无系统级兼容性问题</td>\n</tr>\n</tbody></table>\n<h3 id=\"功能支持\"><a href=\"#功能支持\" class=\"headerlink\" title=\"功能支持\"></a><strong>功能支持</strong></h3><table>\n<thead>\n<tr>\n<th align=\"left\"><strong>维度</strong></th>\n<th align=\"left\"><strong>SharedPreferences</strong></th>\n<th align=\"left\"><strong>MMKV</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><strong>多进程</strong></td>\n<td align=\"left\">不支持（跨进程数据不同步）</td>\n<td align=\"left\">支持（通过文件锁 + <code>mmap</code> 共享内存）</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>数据类型</strong></td>\n<td align=\"left\">仅支持基本类型（int&#x2F;String 等）</td>\n<td align=\"left\">支持基本类型、二进制数据（MMBuffer）</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>加密存储</strong></td>\n<td align=\"left\">明文存储（XML）</td>\n<td align=\"left\">支持 AES 加密（可选）</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>增量更新</strong></td>\n<td align=\"left\">全量写入（即使只改一个键值）</td>\n<td align=\"left\">仅追加新数据，定期整理</td>\n</tr>\n</tbody></table>\n<p>从上面的对比看看，mmkv 在很多层面都是领先 SharedPreferences 的，那么 mmkv 是否有缺陷呢？答案是有的。</p>\n<blockquote>\n<p>任何的操作系统、任何的软件，在往磁盘写数据的过程中如果发生了意外——例如程序崩溃，或者断电关机——磁盘里的文件就会以这种写了一半的、不完整的形式被保留。写了一半的数据怎么用啊？没法用，这就是文件的损坏。这种问题是不可能避免的，MMKV 虽然由于底层机制的原因，在程序崩溃的时候不会影响数据往磁盘的写入，但断电关机之类的操作系统级别的崩溃，MMKV 就没办法了，文件照样会损坏。对于这种文件损坏，SharedPreferences 和 DataStore 的应对方式是在每次写入新数据之前都对现有文件做一次自动备份，这样在发生了意外出现了文件损坏之后，它们就会把备份的数据恢复过来；而 MMKV，没有这种自动的备份和恢复，那么当文件发生了损坏，数据就丢了，之前保存的各种信息只能被重置。也就是说，MMKV 是唯一会丢数据的方案。</p>\n</blockquote>\n<p>在 mmkv 里面有 <a href=\"https://info.support.huawei.com/info-finder/encyclopedia/zh/CRC.html\">CRC</a> 校验，如果不通过的话，将会废弃掉之前所有的数据。在 mmkv 里面也有人反馈：<a href=\"https://github.com/Tencent/MMKV/issues/729\">https://github.com/Tencent/MMKV/issues/729</a> 在写入的过程中因为一些特殊情况写入失败，会导致本地的文件损坏且不可recovery。</p>\n<p>那有什么办法避免这个问题呢？有大佬开源另一个 KV 框架 <a href=\"https://github.com/BillyWei01/FastKV\">FastKV</a>对这个问题进行了处理，采用通过double-write等方法确保数据的完整性，原理是数据依次写入A&#x2F;B两个文件，如果写入A过程中崩溃，B仍是完整的，如果A完整写入了，则B写入时崩溃也不要紧。这种实现方式理论上是不错的，不太清楚 mmkv 为什么没有采取这样的逻辑。不过这个库并没有经过大量业务进行验证，只能作为一个学习的方案先看看。</p>\n<p>另外谷歌已经开发了新的KV存储框架<a href=\"https://cloud.google.com/datastore/docs/concepts/overview?hl=zh-cn\">DataStore</a>，<code>SharedPreferences</code>也将渐渐地退出历史的舞台了。不过 DataStore 的性能目前仍然没有 mmkv 的好。关于这三者的比较可以查看： <a href=\"https://juejin.cn/post/7112268981163016229\">《Android 的键值对存储有没有最优解？》</a></p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>这篇文章深入剖析了 <strong>MMKV</strong>（腾讯开源的高性能键值存储组件）的核心设计与实现原理，重点对比了传统 I&#x2F;O 与 <code>mmap</code> 内存映射的差异，并详细分析了 MMKV 的读写流程以及和 SharedPreferences 的各方面对比。</p>\n<p><strong>参考</strong></p>\n<p><a href=\"https://juejin.cn/post/7112268981163016229\">《Android 的键值对存储有没有最优解？》</a></p>\n<p><a href=\"https://yangjie2.github.io/2021/11/14/mmap%E5%8E%9F%E7%90%86%E4%B8%8E%E5%BA%94%E7%94%A8/\">《mmap原理与应用》</a></p>\n<p><a href=\"https://blog.csdn.net/zhanglh046/article/details/115603788\">《文件内存映射和传统I&#x2F;O机制》</a></p>\n<p><a href=\"https://blog.csdn.net/luo_boke/article/details/109311432\">Android 内存映射mmap浅谈</a></p>\n","cover":null,"images":["https://cdn.julis.wang/blog/img/ee519ba873acf3f80fd4ccec86ed72e7.png","https://cdn.julis.wang/blog/img/mmap_1.png","https://cdn.julis.wang/blog/img/mmap_2_1.png"],"content":"<p>在平时的业务中，需要用到轻量级存储业务中的数据（例如设置数据存储），绝大多数时候 Anroid 管法提供的 <a href=\"https://developer.android.com/reference/android/content/SharedPreferences\">SharedPreferences</a>  组件就能实现，但针对一些需要高效的场景它就不那么使用了，不适合存储大量数据、多线程操作的不安全性、数据明文不安全性，以及不支持多进程之间的调用等各种问题。<br><a href=\"https://github.com/Tencent/MMKV\">MMKV</a>的诞生就是为了解决以上的问题，本文主要对 MMKV 源码的学习知识点进行一些总结。</p>\n<h2 id=\"核心设计与原理\"><a href=\"#核心设计与原理\" class=\"headerlink\" title=\"核心设计与原理\"></a>核心设计与原理</h2><p>在官方的开源工程中可以看到如下的一些介绍</p>\n<blockquote>\n<p>MMKV 是基于 mmap 内存映射的 key-value 组件，底层序列化&#x2F;反序列化使用 protobuf 实现，性能高，稳定性强。从 2015 年中至今在微信上使用，其性能和稳定性经过了时间的验证。</p>\n</blockquote>\n<h3 id=\"传统I-O与-mmap\"><a href=\"#传统I-O与-mmap\" class=\"headerlink\" title=\"传统I&#x2F;O与 mmap\"></a>传统I&#x2F;O与 mmap</h3><p>mmap 这个是 mmkv 实现的核心，没有 mmap 那么就没有 mmkv。对于 <code>SharedPreferences</code>的实现来说，每次的数据更新都将操作本地文件，而本地文件的写入是通过传统的I&#x2F;O实现。要理解两者的实现差异，需要先理解 Linux <strong>用户空间与内核空间</strong>设计。</p>\n<h4 id=\"用户空间与内核空间\"><a href=\"#用户空间与内核空间\" class=\"headerlink\" title=\"用户空间与内核空间\"></a><strong>用户空间与内核空间</strong></h4><p>Linux的进程是相互独立的，一个进程是不能直接操作或者访问别一个进程空间的。每个进程空间还分为用户空间和内核（Kernel）空间，相当于把Kernel和上层的应用程序抽像的隔离开。</p>\n<p><strong>用户空间</strong>和<strong>内核空间</strong>，用户空间是用户程序代码运行的地方，内核空间是内核代码运行的地方。为了安全，它们是隔离的，即使用户的程序崩溃了，内核也不受影响。</p>\n<p>这里有两个隔离，一个进程间是相互隔离的，二是进程内有用户空间和内核空间的隔离。</p>\n<p>进程间，用户空间的数据不可共享，所以用户空间 &#x3D; 不可共享空间<br>进程间，内核空间的数据可共享，所以内核空间 &#x3D; 可共享空间，所以Linux系统的内存通常是MemFree+Cache<br>所有进程共用1个内核空间。</p>\n<h4 id=\"传统I-O读写流程\"><a href=\"#传统I-O读写流程\" class=\"headerlink\" title=\"传统I&#x2F;O读写流程\"></a><strong>传统I&#x2F;O读写流程</strong></h4><p>常规文件读写操作（调用read&#x2F;fread等函数）过程如下：</p>\n<ul>\n<li><p>进程发起读写文件请求。</p>\n</li>\n<li><p>内核通过查找进程文件符表，定位到内核已打开文件集上的文件信息，从而找到此文件的<code>inode</code>。</p>\n</li>\n<li><p><code>inode</code> 在 <code>address_space</code> 上查找要请求的文件页是否已经缓存在页缓存中。如果存在，则直接返回这片文件页的内容。</p>\n</li>\n<li><p>如果不存在，则通过 <code>inode</code> 定位到文件磁盘地址，将数据从磁盘复制到页缓存。之后再次发起读页面过程，进而将页缓存中的数据发给用户进程。</p>\n<blockquote>\n<p><strong>什么是 inode</strong> ?</p>\n<p>全称为 index node，既<strong>存储文件元信息的区域</strong>，中文译名“索引节点”。<br>包含：文件权限、文件拥有者的UID、文件的大小等等。</p>\n</blockquote>\n</li>\n</ul>\n<img src=\"https://cdn.julis.wang/blog/img/ee519ba873acf3f80fd4ccec86ed72e7.png\">\n\n\n<p>总结来说，常规文件操作为了提高读写效率和保护磁盘，使用了页缓存机制。这样造成读文件时需要先将文件页从磁盘拷贝到页缓存中，由于页缓存处在内核空间，不能被用户进程直接寻址访问，所以还需要将页缓存中的数据页再次拷贝到用户空间中。这样，通过了两次数据拷贝过程，才能完成<strong>进程</strong>对<strong>文件</strong>内容的访问。</p>\n<h4 id=\"mmap基本概念和原理\"><a href=\"#mmap基本概念和原理\" class=\"headerlink\" title=\"mmap基本概念和原理\"></a><strong>mmap基本概念和原理</strong></h4><p>内存映射（mmap），就是<strong>将文件的磁盘扇区映射到进程的虚拟内存空间</strong>的过程，即将一个文件映射到进程的虚拟空间，实现文件磁盘地址和进程虚拟空间中一段虚拟地址的一一对应关系。实现这样的映射关系后，进程就可以采用指针的方式读写操作这一段内存，而系统会自动回写脏页面到对应的文件磁盘上，即完成了对文件的操作而不必再调用read,write等系统调用函数。</p>\n<img src=\"https://cdn.julis.wang/blog/img/mmap_1.png\">\n\n<p>由上图可知，进程的虚拟地址空间，由多个虚拟内存区域构成。每个虚拟内存区域都是进程在虚拟地址空间中的一个同质区间，即具有同样特性的连续地址范围。上图中所示的text数据段（代码段）、初始数据段、BSS数据段、堆、栈和内存映射，都是一个独立的虚拟内存区域。内存映射的地址空间处在堆栈之间的空余部分。</p>\n<p>linux内核使用 <code>vm_area_struc</code>t 结构来表示一个独立的虚拟内存区域，由于每个不同质的虚拟内存区域功能和内部机制都不同，因此一个进程使用多个 <code>vm_area_struct</code> 结构来分别表示不同类型的虚拟内存区域。各个 <code>vm_area_struct</code> 结构使用链表或者树形结构链接，方便进程快速访问，如下图所示：</p>\n<img src=\"https://cdn.julis.wang/blog/img/mmap_2_1.png\">\n\n<p><code>vm_area_struct</code> 结构中包含区域起始和终止地址以及其他相关信息。这样，进程对某一虚拟内存区域的任何操作需要用要的信息，都可以从 <code>vm_area_struct</code> 中获得。mmap函数就是要创建一个新的 <code>vm_area_struct</code> 结构，并将其与文件的物理磁盘地址相连。</p>\n<p>mmap内存映射的实现过程，总的来说可以分为三个阶段：</p>\n<p><strong>阶段一：进程启动映射过程，并在虚拟地址空间中为映射创建虚拟映射区域</strong></p>\n<ul>\n<li>进程在用户空间调用mmap库函数</li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> *<span class=\"title\">mmap</span><span class=\"params\">(<span class=\"type\">void</span> *addr, <span class=\"type\">size_t</span> length, <span class=\"type\">int</span> prot, <span class=\"type\">int</span> flags, <span class=\"type\">int</span> fd, <span class=\"type\">off_t</span> offset)</span></span>;</span><br></pre></td></tr></table></figure>\n\n<p><code>addr</code>：指定映射的虚拟内存地址，可以设置为 NULL，让内核自动选择合适的虚拟内存地址</p>\n<p><code>length</code>：映射的长度。</p>\n<p><code>prot</code>：映射内存的保护模式，可选值如下：  </p>\n<p><code>flags</code>：指定映射的类型</p>\n<p><code>fd</code>：进行映射的文件句柄。</p>\n<p><code>offset</code>：文件偏移量（从文件的何处开始映射）</p>\n<ul>\n<li><p>在当前进程的虚拟地址空间中，寻找一段空闲的满足要求的连续的虚拟地址</p>\n</li>\n<li><p>为此虚拟区分配一个 <code>vm_area_struct</code> 结构，接着对这个结构的各个域进行了初始化</p>\n</li>\n<li><p>将新创建的虚拟区结构 <code>vm_area_struct</code> 对象插入到进程的虚拟地址区域链表&#x2F;树中</p>\n</li>\n</ul>\n<p><strong>阶段二：调用内核空间的mmap函数（不同于用户空间函数），实现文件物理地址和进程虚拟地址的一一映射关系</strong></p>\n<ul>\n<li><p>为映射分配了新的虚拟地址区域后，通过待映射的文件指针，在文件描述符表中找到对应的文件描述符，通过文件描述符，链接到内核“已打开文件集”中该文件的文件结构体（struct file），每个文件结构体维护着和这个已打开文件相关各项信息。</p>\n</li>\n<li><p>为映射分配了新的虚拟地址区域后，通过待映射的文件指针，在文件描述符表中找到对应的文件描述符，通过文件描述符，链接到内核“已打开文件集”中该文件的文件结构体（struct file），每个文件结构体维护着和这个已打开文件相关各项信息。</p>\n</li>\n<li><p>通过该文件的文件结构体，链接到 <code>file_operations</code> 模块，调用内核mmap函数，其原型为：</p>\n</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">int mmap(struct file *filp, struct vm_area_struct *vma) //不同于用户空间mmap库函数</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>内核mmap函数通过虚拟文件系统inode模块定位到文件磁盘物理地址。</p>\n</li>\n<li><p>通过 <code>remap_pfn_range</code> 函数建立页表，即实现了文件地址和虚拟地址区域的映射关系。此时，这片虚拟地址并没有任何数据关联到物理内存(主存)中。</p>\n</li>\n</ul>\n<blockquote>\n<p>主存</p>\n<p>主存储器（Main memory），简称主存。是计算机硬件的一个重要部件，其作用是存放指令和数据，并能由中央处理器（CPU）直接随机存取</p>\n</blockquote>\n<p><strong>阶段三：进程发起对这片映射地址空间的访问，引发缺页异常，实现文件内容到主存（物理内存）的拷贝</strong></p>\n<blockquote>\n<p>前两个阶段仅在于创建虚拟区间并完成地址映射，但是并没有将任何文件数据的拷贝至主存。真正的文件读取是当进程发起读或写操作时</p>\n</blockquote>\n<ul>\n<li><p>进程的读或写操作访问虚拟地址空间这一段映射地址，通过查询页表，发现这一段地址并不在物理页上。因为目前只建立了地址映射，真正的硬盘数据还没有拷贝到内存中，因此引发缺页异常。</p>\n</li>\n<li><p>缺页异常进行一系列判断，确定无非法操作后，内核发起请求调页过程。</p>\n</li>\n<li><p>调页过程先在交换缓存空间（swap cache）中寻找需要访问的内存页，如果没有则调用nopage函数把所缺的页从磁盘装入到主存中。</p>\n</li>\n<li><p>之后进程即可对这片主存进行读或者写的操作，如果写操作改变了其内容，一定时间后系统会自动回写脏页面到对应磁盘地址，也即完成了写入到文件的过程。</p>\n</li>\n</ul>\n<blockquote>\n<p>修改过的脏页面并不会立即更新回文件中，而是有一段时间的延迟，可以调用<code>msync()</code>来强制同步, 这样所写的内容就能立即保存到文件里了</p>\n</blockquote>\n<p>常规文件操作需要从磁盘到内核空间页缓存再到用户空间主存的两次数据拷贝。而mmap文件映射，只需要从磁盘到用户空间主存的一次数据拷贝过程。mmap的关键点是实现了用户空间和内核空间的数据直接交互而省去了空间不同数据不通的繁琐过程，因此 mmap 效率更高。</p>\n<p>以上是 mmap 的基本概念和原理，搞明白了这些才能看明白整个 mmkv 里面的逻辑处理</p>\n<h3 id=\"mmkv-一次-put-的流程\"><a href=\"#mmkv-一次-put-的流程\" class=\"headerlink\" title=\"mmkv 一次 put 的流程\"></a>mmkv 一次 put 的流程</h3><p>mmkv初始化比较简单，主要涉及到一些配置的初始化，文件夹创建等，其中最重要的逻辑 mmap 调用被封装到一个 <code>MemoryFile</code>到对象里面 </p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">MemoryFile::mmap</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">auto</span> oldPtr = m_ptr;</span><br><span class=\"line\">    <span class=\"keyword\">auto</span> mode = m_readOnly ? PROT_READ : (PROT_READ | PROT_WRITE);</span><br><span class=\"line\">    m_ptr = (<span class=\"type\">char</span> *) ::<span class=\"built_in\">mmap</span>(m_ptr, m_size, mode, MAP_SHARED, m_diskFile.m_fd, <span class=\"number\">0</span>);</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>主要记录一下一次 put 任务的流程，以 <code>mmkv.putInt(&quot;int&quot;, 1)</code>为例，进过 JNI 的调用到了</p>\n<p><strong>native-birdge.cpp</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">MMKV_JNI jboolean <span class=\"title\">encodeInt</span><span class=\"params\">(JNIEnv *env, jobject obj, jlong handle, jstring oKey, jint value)</span> </span>&#123;</span><br><span class=\"line\">    MMKV *kv = <span class=\"built_in\">reinterpret_cast</span>&lt;MMKV *&gt;(handle);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (kv &amp;&amp; oKey) &#123;</span><br><span class=\"line\">        string key = <span class=\"built_in\">jstring2string</span>(env, oKey);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (jboolean) kv-&gt;<span class=\"built_in\">set</span>((<span class=\"type\">int32_t</span>) value, key);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (jboolean) <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>进入了<strong>MMVK.cpp</strong>的 </p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">MMKV::set</span><span class=\"params\">(<span class=\"type\">int32_t</span> value, MMKVKey_t key, <span class=\"type\">uint32_t</span> expireDuration)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">isKeyEmpty</span>(key)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"type\">size_t</span> size = <span class=\"built_in\">mmkv_unlikely</span>(m_enableKeyExpire) ? Fixed32Size + <span class=\"built_in\">pbInt32Size</span>(value) : <span class=\"built_in\">pbInt32Size</span>(value);</span><br><span class=\"line\">    <span class=\"function\">MMBuffer <span class=\"title\">data</span><span class=\"params\">(size)</span></span>;</span><br><span class=\"line\">    <span class=\"function\">CodedOutputData <span class=\"title\">output</span><span class=\"params\">(data.getPtr(), size)</span></span>;</span><br><span class=\"line\">    output.<span class=\"built_in\">writeInt32</span>(value);</span><br><span class=\"line\">    <span class=\"comment\">// ... 省略一些校验逻辑</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">setDataForKey</span>(std::<span class=\"built_in\">move</span>(data), key);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这一步主要是准备一下数据，并使用 <code>MMBuffer</code> <code>CodedOutputData</code>将写入的数据进行一次包装（不仅仅是 key-value，还有数据size等等），实际调用在<code>setDataForKey</code></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">MMKV::setDataForKey</span><span class=\"params\">(MMBuffer &amp;&amp;data, MMKVKey_t key, <span class=\"type\">bool</span> isDataHolder)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">checkLoadData</span>(); <span class=\"comment\">// 状态同步相关的逻辑</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (m_crypter) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// ... 省略加密的处理逻辑</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">auto</span> itr = m_dic-&gt;<span class=\"built_in\">find</span>(key);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (itr != m_dic-&gt;<span class=\"built_in\">end</span>()) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// compare data before appending to file</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (<span class=\"built_in\">isCompareBeforeSetEnabled</span>()) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">auto</span> basePtr = (<span class=\"type\">uint8_t</span> *) (m_file-&gt;<span class=\"built_in\">getMemory</span>()) + Fixed32Size;</span><br><span class=\"line\">                MMBuffer oldValueData = itr-&gt;second.<span class=\"built_in\">toMMBuffer</span>(basePtr);</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (isDataHolder) &#123;</span><br><span class=\"line\">                    <span class=\"function\">CodedInputData <span class=\"title\">inputData</span><span class=\"params\">(oldValueData.getPtr(), oldValueData.length())</span></span>;</span><br><span class=\"line\">                    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                        <span class=\"comment\">// read extra holder header bytes and to real MMBuffer</span></span><br><span class=\"line\">                        oldValueData = CodedInputData::<span class=\"built_in\">readRealData</span>(oldValueData);</span><br><span class=\"line\">                        <span class=\"keyword\">if</span> (oldValueData == data) &#123;</span><br><span class=\"line\">                            <span class=\"comment\">// MMKVInfo(&quot;[key] %s, set the same data&quot;, key.c_str());</span></span><br><span class=\"line\">                            <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125; <span class=\"built_in\">catch</span> (std::exception &amp;exception) &#123;</span><br><span class=\"line\">                        <span class=\"built_in\">MMKVWarning</span>(<span class=\"string\">&quot;compareBeforeSet exception: %s&quot;</span>, exception.<span class=\"built_in\">what</span>());</span><br><span class=\"line\">                    &#125; <span class=\"built_in\">catch</span> (...) &#123;</span><br><span class=\"line\">                        <span class=\"built_in\">MMKVWarning</span>(<span class=\"string\">&quot;compareBeforeSet fail&quot;</span>);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                     ...</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"type\">bool</span> onlyOneKey = !<span class=\"built_in\">isMultiProcess</span>() &amp;&amp; m_dic-&gt;<span class=\"built_in\">size</span>() == <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (<span class=\"built_in\">mmkv_likely</span>(!m_enableKeyExpire)) &#123;</span><br><span class=\"line\">                ...</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                KVHolderRet_t ret;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (onlyOneKey) &#123;</span><br><span class=\"line\">                    ret = <span class=\"built_in\">overrideDataWithKey</span>(data, key, isDataHolder);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    ret = <span class=\"built_in\">appendDataWithKey</span>(data, key, isDataHolder);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (!ret.first) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                itr = m_dic-&gt;<span class=\"built_in\">find</span>(key);</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (itr != m_dic-&gt;<span class=\"built_in\">end</span>()) &#123;</span><br><span class=\"line\">                    itr-&gt;second = std::<span class=\"built_in\">move</span>(ret.second);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// in case filterExpiredKeys() is triggered</span></span><br><span class=\"line\">                    m_dic-&gt;<span class=\"built_in\">emplace</span>(key, std::<span class=\"built_in\">move</span>(ret.second));</span><br><span class=\"line\">                    <span class=\"built_in\">mmkv_retain_key</span>(key);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">           ...</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    m_hasFullWriteback = <span class=\"literal\">false</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里面的代码逻辑很长，做了很多 if-else 的逻辑，最终走向两个大分支：</p>\n<p>key 是新增的走 <code>appendDataWithKey</code></p>\n<p>key 将会覆盖原来的将会走 <code>overrideDataWithKey</code></p>\n<p>有这两个分支，主要是因为 mmkv 存储采用的  <a href=\"https://protobuf.com.cn/\">protobuf 协议</a>，另外有一个很重要的方法也在这里执行了：<code>checkLoadData();</code>  安卓里面的多进程实现，将需要这里的一些逻辑，在 mmkv多进程原理篇进行讲解。</p>\n<p><code>appendDataWithKey</code> 转换为 <code>MMBuffer</code>并继续向下执行</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">KVHolderRet_t <span class=\"title\">MMKV::appendDataWithKey</span><span class=\"params\">(<span class=\"type\">const</span> MMBuffer &amp;data, MMKVKey_t key, <span class=\"type\">bool</span> isDataHolder)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">auto</span> keyData = <span class=\"built_in\">MMBuffer</span>((<span class=\"type\">void</span> *) key.<span class=\"built_in\">data</span>(), key.<span class=\"built_in\">size</span>(), MMBufferNoCopy);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">doAppendDataWithKey</span>(data, keyData, isDataHolder, <span class=\"built_in\">static_cast</span>&lt;<span class=\"type\">uint32_t</span>&gt;(keyData.<span class=\"built_in\">length</span>()));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>doAppendDataWithKey</code> 里面的代码也很长，不过也就只做一件事：将k-v值写入到文件里面做准备，真正的写入逻辑在 <code>m_output-&gt;writeData(keyData);</code>，这里先后调用了两次 <code>writeData</code>,是先写入key再写入了 value。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">KVHolderRet_t</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">MMKV::doAppendDataWithKey</span><span class=\"params\">(<span class=\"type\">const</span> MMBuffer &amp;data, <span class=\"type\">const</span> MMBuffer &amp;keyData, <span class=\"type\">bool</span> isDataHolder, <span class=\"type\">uint32_t</span> originKeyLength)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">auto</span> isKeyEncoded = (originKeyLength &lt; keyData.<span class=\"built_in\">length</span>());</span><br><span class=\"line\">    <span class=\"keyword\">auto</span> keyLength = <span class=\"built_in\">static_cast</span>&lt;<span class=\"type\">uint32_t</span>&gt;(keyData.<span class=\"built_in\">length</span>());</span><br><span class=\"line\">    <span class=\"keyword\">auto</span> valueLength = <span class=\"built_in\">static_cast</span>&lt;<span class=\"type\">uint32_t</span>&gt;(data.<span class=\"built_in\">length</span>());</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (isDataHolder) &#123;</span><br><span class=\"line\">        valueLength += <span class=\"built_in\">pbRawVarint32Size</span>(valueLength);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// size needed to encode the key</span></span><br><span class=\"line\">    <span class=\"type\">size_t</span> size = isKeyEncoded ? keyLength : (keyLength + <span class=\"built_in\">pbRawVarint32Size</span>(keyLength));</span><br><span class=\"line\">    <span class=\"comment\">// size needed to encode the value</span></span><br><span class=\"line\">    size += valueLength + <span class=\"built_in\">pbRawVarint32Size</span>(valueLength);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">SCOPED_LOCK</span>(m_exclusiveProcessLock);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">bool</span> hasEnoughSize = <span class=\"built_in\">ensureMemorySize</span>(size);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!hasEnoughSize || !<span class=\"built_in\">isFileValid</span>()) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">make_pair</span>(<span class=\"literal\">false</span>, <span class=\"built_in\">KeyValueHolder</span>());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">\t\t...</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (isKeyEncoded) &#123;</span><br><span class=\"line\">            m_output-&gt;<span class=\"built_in\">writeRawData</span>(keyData);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            m_output-&gt;<span class=\"built_in\">writeData</span>(keyData);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (isDataHolder) &#123;</span><br><span class=\"line\">            m_output-&gt;<span class=\"built_in\">writeRawVarint32</span>((<span class=\"type\">int32_t</span>) valueLength);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        m_output-&gt;<span class=\"built_in\">writeData</span>(data); <span class=\"comment\">// note: write size of data</span></span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">    ...</span><br><span class=\"line\">    m_actualSize += size;</span><br><span class=\"line\">    <span class=\"built_in\">updateCRCDigest</span>(ptr, size);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">make_pair</span>(<span class=\"literal\">true</span>, <span class=\"built_in\">KeyValueHolder</span>(originKeyLength, valueLength, offset));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>writeData</code> 进行了两步先写入数据的 <strong>长度信息</strong>，再写入真实的数据，这里还是因为  <a href=\"https://protobuf.com.cn/\">protobuf 协议</a>设计相关</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">CodedOutputData::writeData</span><span class=\"params\">(<span class=\"type\">const</span> MMBuffer &amp;value)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>-&gt;<span class=\"built_in\">writeRawVarint32</span>((<span class=\"type\">int32_t</span>) value.<span class=\"built_in\">length</span>());</span><br><span class=\"line\">    <span class=\"keyword\">this</span>-&gt;<span class=\"built_in\">writeRawData</span>(value);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>最终走到了<code>writeRawData</code> 关键代码</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">CodedOutputData::writeRawData</span><span class=\"params\">(<span class=\"type\">const</span> MMBuffer &amp;data)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"type\">size_t</span> numberOfBytes = data.<span class=\"built_in\">length</span>();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (m_position + numberOfBytes &gt; m_size) &#123;</span><br><span class=\"line\">       ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">memcpy</span>(m_ptr + m_position, data.<span class=\"built_in\">getPtr</span>(), numberOfBytes);</span><br><span class=\"line\">    m_position += numberOfBytes;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>核心逻辑使用 <code>memcpy</code> 将数据直接通过 memcpy 直接在内存层面进行拷贝，而这里的 <code>m_ptr</code>就是最开始通过<code>mmap</code>创建出来的指针！！到这里一次写入基本上就结束了。</p>\n<h3 id=\"mmkv-一次-get-的流程\"><a href=\"#mmkv-一次-get-的流程\" class=\"headerlink\" title=\"mmkv 一次 get 的流程\"></a>mmkv 一次 get 的流程</h3><p>依然先通过 JNI走到</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">MMKV_JNI jint <span class=\"title\">decodeInt</span><span class=\"params\">(JNIEnv *env, jobject obj, jlong handle, jstring oKey, jint defaultValue)</span> </span>&#123;</span><br><span class=\"line\">    MMKV *kv = <span class=\"built_in\">reinterpret_cast</span>&lt;MMKV *&gt;(handle);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (kv &amp;&amp; oKey) &#123;</span><br><span class=\"line\">        string key = <span class=\"built_in\">jstring2string</span>(env, oKey);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (jint) kv-&gt;<span class=\"built_in\">getInt32</span>(key, defaultValue);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> defaultValue;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>再到 mmkv getInt32</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int32_t</span> <span class=\"title\">MMKV::getInt32</span><span class=\"params\">(MMKVKey_t key, <span class=\"type\">int32_t</span> defaultValue, <span class=\"type\">bool</span> *hasValue)</span> </span>&#123;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">    <span class=\"built_in\">SCOPED_LOCK</span>(m_lock);</span><br><span class=\"line\">    <span class=\"built_in\">SCOPED_LOCK</span>(m_sharedProcessLock);</span><br><span class=\"line\">    <span class=\"keyword\">auto</span> data = <span class=\"built_in\">getDataForKey</span>(key);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (data.<span class=\"built_in\">length</span>() &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"function\">CodedInputData <span class=\"title\">input</span><span class=\"params\">(data.getPtr(), data.length())</span></span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (hasValue != <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">                *hasValue = <span class=\"literal\">true</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> input.<span class=\"built_in\">readInt32</span>();</span><br><span class=\"line\">        &#125; </span><br><span class=\"line\">        ...</span><br><span class=\"line\">    <span class=\"keyword\">return</span> defaultValue;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>getRawDataForKey</code>方法，主要有两个分支，一种是加密逻辑，另一种是非加密逻辑，但他们流程都差不多从一个  map 里面根据 key 获取一个对象（这个对象暂时并不是 get 最终的返回值），那这个 map 是从哪里来的呢？</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">MMBuffer <span class=\"title\">MMKV::getRawDataForKey</span><span class=\"params\">(MMKVKey_t key)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">checkLoadData</span>();</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">ifndef</span> MMKV_DISABLE_CRYPT</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (m_crypter) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">auto</span> itr = m_dicCrypt-&gt;<span class=\"built_in\">find</span>(key);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (itr != m_dicCrypt-&gt;<span class=\"built_in\">end</span>()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">auto</span> basePtr = (<span class=\"type\">uint8_t</span> *) (m_file-&gt;<span class=\"built_in\">getMemory</span>()) + Fixed32Size;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> itr-&gt;second.<span class=\"built_in\">toMMBuffer</span>(basePtr, m_crypter);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span></span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">auto</span> itr = m_dic-&gt;<span class=\"built_in\">find</span>(key);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (itr != m_dic-&gt;<span class=\"built_in\">end</span>()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">auto</span> basePtr = (<span class=\"type\">uint8_t</span> *) (m_file-&gt;<span class=\"built_in\">getMemory</span>()) + Fixed32Size;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> itr-&gt;second.<span class=\"built_in\">toMMBuffer</span>(basePtr);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    MMBuffer nan;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> nan;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>从源码里面溯源<code>m_dicCrypt</code>和 <code>m_dic</code> 是在 MMKV 初始化的时候生成的，主要逻辑在 <code>MMKV_IO .cpp</code>里面的 <code>loadFromFile</code>方法内：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">MMKV::loadFromFile</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">loadMetaInfoAndCheck</span>();</span><br><span class=\"line\">\t\t...</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!m_file-&gt;<span class=\"built_in\">isFileValid</span>()) &#123;</span><br><span class=\"line\">        m_file-&gt;<span class=\"built_in\">reloadFromFile</span>(m_expectedCapacity);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!m_file-&gt;<span class=\"built_in\">isFileValid</span>()) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">MMKVError</span>(<span class=\"string\">&quot;file [%s] not valid&quot;</span>, m_path.<span class=\"built_in\">c_str</span>());</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">bool</span> loadFromFile = <span class=\"literal\">false</span>, needFullWriteback = <span class=\"literal\">false</span>;</span><br><span class=\"line\">        <span class=\"built_in\">checkDataValid</span>(loadFromFile, needFullWriteback);</span><br><span class=\"line\">        ...</span><br><span class=\"line\">        <span class=\"keyword\">auto</span> ptr = (<span class=\"type\">uint8_t</span> *) m_file-&gt;<span class=\"built_in\">getMemory</span>();</span><br><span class=\"line\">        <span class=\"comment\">// loading</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (loadFromFile &amp;&amp; m_actualSize &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\t\t\t...</span><br><span class=\"line\">            <span class=\"function\">MMBuffer <span class=\"title\">inputBuffer</span><span class=\"params\">(ptr + Fixed32Size, m_actualSize, MMBufferNoCopy)</span></span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (m_crypter) &#123;</span><br><span class=\"line\">                <span class=\"built_in\">clearDictionary</span>(m_dicCrypt);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"built_in\">clearDictionary</span>(m_dic);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (needFullWriteback) &#123;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">ifndef</span> MMKV_DISABLE_CRYPT</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (m_crypter) &#123;</span><br><span class=\"line\">                    MiniPBCoder::<span class=\"built_in\">greedyDecodeMap</span>(*m_dicCrypt, inputBuffer, m_crypter);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span></span></span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    MiniPBCoder::<span class=\"built_in\">greedyDecodeMap</span>(*m_dic, inputBuffer);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">ifndef</span> MMKV_DISABLE_CRYPT</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (m_crypter) &#123;</span><br><span class=\"line\">                    MiniPBCoder::<span class=\"built_in\">decodeMap</span>(*m_dicCrypt, inputBuffer, m_crypter);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span></span></span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    MiniPBCoder::<span class=\"built_in\">decodeMap</span>(*m_dic, inputBuffer);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            m_output = <span class=\"keyword\">new</span> <span class=\"built_in\">CodedOutputData</span>(ptr + Fixed32Size, m_file-&gt;<span class=\"built_in\">getFileSize</span>() - Fixed32Size);</span><br><span class=\"line\">            m_output-&gt;<span class=\"built_in\">seek</span>(m_actualSize);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (needFullWriteback) &#123;</span><br><span class=\"line\">                <span class=\"built_in\">fullWriteback</span>();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// file not valid or empty, discard everything</span></span><br><span class=\"line\">            <span class=\"built_in\">SCOPED_LOCK</span>(m_exclusiveProcessLock);</span><br><span class=\"line\"></span><br><span class=\"line\">            m_output = <span class=\"keyword\">new</span> <span class=\"built_in\">CodedOutputData</span>(ptr + Fixed32Size, m_file-&gt;<span class=\"built_in\">getFileSize</span>() - Fixed32Size);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (m_actualSize &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                <span class=\"built_in\">writeActualSize</span>(<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"literal\">nullptr</span>, IncreaseSequence);</span><br><span class=\"line\">                <span class=\"built_in\">sync</span>(MMKV_SYNC);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"built_in\">writeActualSize</span>(<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"literal\">nullptr</span>, KeepSequence);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">\t\t\t\t...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    m_needLoadFromFile = <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>总统来说就是在初始化的时候就会将基于<code>protobuf</code>协议的本地文件里面的数据加载到内存，并将其放在一个 map 内，方便后续使用。</p>\n<p>回到 <code>int32_t MMKV::getInt32()</code>通过 <code>getDataForKey(key)</code>获取到一个<code>MMBuffer</code>对象，并通过 <strong>CodedInputData</strong>进行反序列化操作，读取 <strong>Varint32</strong> 的 <strong>valueSize</strong> 值，随后不断循环通过 <strong>CodedInputData</strong>  读取到<strong>value</strong> 值。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int32_t</span> <span class=\"title\">MMKV::getInt32</span><span class=\"params\">(MMKVKey_t key, <span class=\"type\">int32_t</span> defaultValue, <span class=\"type\">bool</span> *hasValue)</span> </span>&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"keyword\">auto</span> data = <span class=\"built_in\">getDataForKey</span>(key);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (data.<span class=\"built_in\">length</span>() &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"function\">CodedInputData <span class=\"title\">input</span><span class=\"params\">(data.getPtr(), data.length())</span></span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (hasValue != <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">                *hasValue = <span class=\"literal\">true</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> input.<span class=\"built_in\">readInt32</span>();</span><br><span class=\"line\">        &#125; </span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  \t...</span><br><span class=\"line\">    <span class=\"keyword\">return</span> defaultValue;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"mmkv-与-SharedPreferences\"><a href=\"#mmkv-与-SharedPreferences\" class=\"headerlink\" title=\"mmkv 与 SharedPreferences\"></a>mmkv 与 SharedPreferences</h2><p>以下是 <strong>MMKV</strong> 与 <strong>SharedPreferences</strong> 的优劣势对比总结，结合性能、安全性、功能支持等核心维度进行分析：</p>\n<h3 id=\"性能对比\"><a href=\"#性能对比\" class=\"headerlink\" title=\"性能对比\"></a><strong>性能对比</strong></h3><table>\n<thead>\n<tr>\n<th align=\"left\"><strong>维度</strong></th>\n<th align=\"left\"><strong>SharedPreferences</strong></th>\n<th align=\"left\"><strong>MMKV</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><strong>读写速度</strong></td>\n<td align=\"left\">慢（同步 I&#x2F;O，多次数据拷贝）</td>\n<td align=\"left\">快（<code>mmap</code> 零拷贝，内存直接操作）</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>线程安全</strong></td>\n<td align=\"left\">需自行加锁（<code>apply()</code> 异步写入仍有风险）</td>\n<td align=\"left\">内置多线程锁（文件锁 + 内存锁）</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>大数据量支持</strong></td>\n<td align=\"left\">性能急剧下降（全量 XML 解析&#x2F;序列化）</td>\n<td align=\"left\">高效（增量更新，Protobuf 编码）</td>\n</tr>\n</tbody></table>\n<h3 id=\"安全性与稳定性\"><a href=\"#安全性与稳定性\" class=\"headerlink\" title=\"安全性与稳定性\"></a><strong>安全性与稳定性</strong></h3><table>\n<thead>\n<tr>\n<th align=\"left\"><strong>维度</strong></th>\n<th align=\"left\"><strong>SharedPreferences</strong></th>\n<th align=\"left\"><strong>MMKV</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><strong>数据加密</strong></td>\n<td align=\"left\">无（明文存储）</td>\n<td align=\"left\">支持 AES-128&#x2F;AES-256 加密</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>崩溃恢复</strong></td>\n<td align=\"left\">可能因异常导致 XML 损坏</td>\n<td align=\"left\">通过 CRC 校验 + 备份文件保障完整性</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>系统版本适配</strong></td>\n<td align=\"left\">部分版本有 ANR 问题（如 <code>apply()</code>）</td>\n<td align=\"left\">无系统级兼容性问题</td>\n</tr>\n</tbody></table>\n<h3 id=\"功能支持\"><a href=\"#功能支持\" class=\"headerlink\" title=\"功能支持\"></a><strong>功能支持</strong></h3><table>\n<thead>\n<tr>\n<th align=\"left\"><strong>维度</strong></th>\n<th align=\"left\"><strong>SharedPreferences</strong></th>\n<th align=\"left\"><strong>MMKV</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><strong>多进程</strong></td>\n<td align=\"left\">不支持（跨进程数据不同步）</td>\n<td align=\"left\">支持（通过文件锁 + <code>mmap</code> 共享内存）</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>数据类型</strong></td>\n<td align=\"left\">仅支持基本类型（int&#x2F;String 等）</td>\n<td align=\"left\">支持基本类型、二进制数据（MMBuffer）</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>加密存储</strong></td>\n<td align=\"left\">明文存储（XML）</td>\n<td align=\"left\">支持 AES 加密（可选）</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>增量更新</strong></td>\n<td align=\"left\">全量写入（即使只改一个键值）</td>\n<td align=\"left\">仅追加新数据，定期整理</td>\n</tr>\n</tbody></table>\n<p>从上面的对比看看，mmkv 在很多层面都是领先 SharedPreferences 的，那么 mmkv 是否有缺陷呢？答案是有的。</p>\n<blockquote>\n<p>任何的操作系统、任何的软件，在往磁盘写数据的过程中如果发生了意外——例如程序崩溃，或者断电关机——磁盘里的文件就会以这种写了一半的、不完整的形式被保留。写了一半的数据怎么用啊？没法用，这就是文件的损坏。这种问题是不可能避免的，MMKV 虽然由于底层机制的原因，在程序崩溃的时候不会影响数据往磁盘的写入，但断电关机之类的操作系统级别的崩溃，MMKV 就没办法了，文件照样会损坏。对于这种文件损坏，SharedPreferences 和 DataStore 的应对方式是在每次写入新数据之前都对现有文件做一次自动备份，这样在发生了意外出现了文件损坏之后，它们就会把备份的数据恢复过来；而 MMKV，没有这种自动的备份和恢复，那么当文件发生了损坏，数据就丢了，之前保存的各种信息只能被重置。也就是说，MMKV 是唯一会丢数据的方案。</p>\n</blockquote>\n<p>在 mmkv 里面有 <a href=\"https://info.support.huawei.com/info-finder/encyclopedia/zh/CRC.html\">CRC</a> 校验，如果不通过的话，将会废弃掉之前所有的数据。在 mmkv 里面也有人反馈：<a href=\"https://github.com/Tencent/MMKV/issues/729\">https://github.com/Tencent/MMKV/issues/729</a> 在写入的过程中因为一些特殊情况写入失败，会导致本地的文件损坏且不可recovery。</p>\n<p>那有什么办法避免这个问题呢？有大佬开源另一个 KV 框架 <a href=\"https://github.com/BillyWei01/FastKV\">FastKV</a>对这个问题进行了处理，采用通过double-write等方法确保数据的完整性，原理是数据依次写入A&#x2F;B两个文件，如果写入A过程中崩溃，B仍是完整的，如果A完整写入了，则B写入时崩溃也不要紧。这种实现方式理论上是不错的，不太清楚 mmkv 为什么没有采取这样的逻辑。不过这个库并没有经过大量业务进行验证，只能作为一个学习的方案先看看。</p>\n<p>另外谷歌已经开发了新的KV存储框架<a href=\"https://cloud.google.com/datastore/docs/concepts/overview?hl=zh-cn\">DataStore</a>，<code>SharedPreferences</code>也将渐渐地退出历史的舞台了。不过 DataStore 的性能目前仍然没有 mmkv 的好。关于这三者的比较可以查看： <a href=\"https://juejin.cn/post/7112268981163016229\">《Android 的键值对存储有没有最优解？》</a></p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>这篇文章深入剖析了 <strong>MMKV</strong>（腾讯开源的高性能键值存储组件）的核心设计与实现原理，重点对比了传统 I&#x2F;O 与 <code>mmap</code> 内存映射的差异，并详细分析了 MMKV 的读写流程以及和 SharedPreferences 的各方面对比。</p>\n<p><strong>参考</strong></p>\n<p><a href=\"https://juejin.cn/post/7112268981163016229\">《Android 的键值对存储有没有最优解？》</a></p>\n<p><a href=\"https://yangjie2.github.io/2021/11/14/mmap%E5%8E%9F%E7%90%86%E4%B8%8E%E5%BA%94%E7%94%A8/\">《mmap原理与应用》</a></p>\n<p><a href=\"https://blog.csdn.net/zhanglh046/article/details/115603788\">《文件内存映射和传统I&#x2F;O机制》</a></p>\n<p><a href=\"https://blog.csdn.net/luo_boke/article/details/109311432\">Android 内存映射mmap浅谈</a></p>\n","categories":[],"tags":[{"name":"mmap","slug":"mmap","api":"api/tags/mmap.json"}],"api":"api/posts/2025/03/30/KV-存储之mmkv.json"}],"info":{"type":"tag","name":"mmap","slug":"mmap"}},"api":"api/tags/mmap/page.1.json"}