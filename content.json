{"meta":{"title":"落叶挽歌","subtitle":"juliswang's 博客","description":"落叶挽歌","author":"落叶挽歌","url":"http://vompom.github.com","root":"/"},"pages":[{"title":"关于我","date":"2020-06-23T02:20:28.000Z","updated":"2025-12-13T16:21:31.532Z","comments":true,"path":"about/index.html","permalink":"http://vompom.github.com/about/index.html","excerpt":"","text":"你好，我是 juliswang，来自四川，现居上海，是一名互联网软件开发者。很有幸你能访问到我的博客，希望你能在这里对我有更多的了解。 主要方向 Android移动应用/SDK开发 音视频领域开发 游戏引擎与移动客户端相关开发 开发技能 平台Android/Unity/Flutter/Windows/Mac 语言Java/Kotlin/JavaScript/C++/C#/C 技术KMP/FFmpeg/Node.js/OpenGL/Shader/ 开发经历 Android/Flutter/PC App开发 视频剪辑/特效 SDK 录屏 SDK 云渲染 SDK Flutter 混合栈 SDK Unity/UE 插件 安卓逆向 感悟记得自己初中的时候，那时候家里还没有电脑，那时候记得还是 wap2.0 的时代，那时候手机还搭载着是MTK操作系统。似乎还记得那个经典神奇的一串指令：*#220807#。当我输入了这一串指令之后，关于编程的兴趣从此开始了。慢慢地接触到了 UBB代码，想想那时候真的是有意思，拿着个手机然后就能做一些简单的网页，对于喜欢折腾的我，实在是太喜欢这种感觉了。我还把我做的网页分享给同学，虽然没有什么特殊的东西，但是成就感满满，也对我后面的兴趣打下了基础。 高中我买了很多书看(java c vb 等等方面的书籍)，但是很多都没有看完，都是粗略的了解。因为编程的兴趣爱好，高中认识了很多对编程有兴趣的同学，现分布于祖国的大江南北，虽然离得很远，但是感情一直都很好，大家每年过年都会聚一聚。 高中曾看到一本关于“黑客攻防”方面的书，那时候认识到了黑客界的大牛–凯文.米特尼克。 一个15岁能破解进入美国五角大楼安放系统的人，而自己15岁呢？后来慢慢开始了解他，他曾出版过一本书叫 《反欺骗的艺术》， 试着去读了读，小白的我被里面的内容虎得一愣一愣的。 学到关于一些社会工程学相关的内容，于是……自己就下手尝试了。拿了个看起来比较单纯的小姑娘的qq号做测试，果不其然！尝试次数没有到10次就登陆上她的qq了（2012qq的安全防范并没有现在这么严格），然后我利用她的身份去“欺骗”了她很多同学，得到来很多的qq密码……最后走的时候还把她的分组改了，改成大概是“XXX到此一游”的语句，这次“黑”可能算得上一次比较成功的，虽然没有用什么很高端的技术，但是完全激发了我对代码程序相关的兴趣。 高中的时候关于编程的兴趣，大概是我努力考大学的动力，每周最开心的事不是放假，也不是这次考试前进了多少名次，而是周二周三的时候报刊亭订阅的《电脑报》到了。 有时候我会开开心心地从教室里跑到报刊亭，去拿最新一期的《电脑报》，偶尔被告知它还没有到但时候，心里很失望…… 终于经过了高考，整个暑假也是对大学充满惊喜，曾在“红客联盟”发过一篇自己的感受的帖子 （ 一个喜欢电脑孩子的心声！()……可能由于网站改版，其文章已经不见了，还好内容有存下下来，被放在博客里面《红盟：一个喜欢电脑孩子的心声！求围观》。 等过了漫长的暑假，进入了大学，我想我要这里启程腾飞，可是现实却一点一点给了我打击。那时，“互联网+”的口号在全国兴起，到处都是“大众创业，万众创新”的旗帜，大学也不例外。然而对于创业和技术，我想我并没有把控好两者的平衡，我一直没有忘记我的初衷：对于技术的热爱。在学校里面，大家都是做一些“创业”相关的东西， 学院领导觉得我很有干劲，觉得我是一个比较适合做创业的人，但他们不知道我最想做的是技术，慢慢地被氛围带着有点偏了。后来，我成为了学院某工作室的负责人， 随之而来压力也逐渐大了起来。到后来，我逐渐成为老师心中很能干的学生，同学心中的“大佬”、“大神” 以前写过《 一篇程序员学习之路—小白成长记(网站网页篇)》， 算是对自己以前学过关于网站网页一块的总结，都是很基础的知识，但不知道为什么总觉得很厉害很厉害，各种团队想叫我加入他们。我不太想做关于创业的事，每天我最开心的不是和各种各样的团队或者人员交流或者，而是沉浸在代码的世界里。 大学四年自己经历了很多很多的事，现在看看那时候真的经历了很多，每一件事后面自己都付出了心血，同样也收获了成长，大学有遗憾而无悔。 我很崇拜一个叫翁天信的大佬，他的博客 www.dandyweng.com 做得非常棒， 博客已经有90万+(截止19年5月)的访问量，非常的牛逼。可是我们再去了解一下这个人：他是一个HomesShooler，他没有去过学校上课。他说：“在自学的这些年里，我自己学，做自己。追寻自己的所想所爱，并试着将各种兴趣爱好串连在一起。” 我很喜欢他这种生活方式，也很向往很追求这样的生活：编程、摄影、旅游。那张地图上布满红点代表了他去过的地方， 他的足迹遍布全国乃至世界各地；他的编程水平，他的博客也是很好的体现；他的摄影水平，博客上也都有。 他跟我是同龄人，看看他在做什么，而我又在做什么？相比之下，有觉得自己这一年的生活是不是很无聊，很无趣。 所以受他的影响，也希望我的生活变得更有趣一点。我自己不仅仅在编程上我有兴趣，我也有其他方面的爱好： 我喜欢写字，当完成一幅作品后，那种优美是多么的令人陶醉。我也喜欢阅读，通过阅读能让自己多加思考，去探寻人生的答案。我也喜欢足球，那一声声“雄起”中迸发的激情与集体的共鸣，是多么的令人热血沸腾。我也喜欢旅行，希望去遍历全国各地乃至世界各地，感受不同的文化。 点击这里查看我的旅行足迹我也喜欢其他的，我也还有很多很多想要去做的事……最后：很高兴认识你，我是 juliswang，请多多关照 --2018.12 杭州"},{"title":"旅行足迹","date":"2019-12-31T16:00:00.000Z","updated":"2025-12-13T16:22:25.909Z","comments":true,"path":"about/travel.html","permalink":"http://vompom.github.com/about/travel.html","excerpt":"","text":"setTimeout(function() { var chart = echarts.init(document.getElementById('chinaMap')); // 中国城市坐标数据库（包含您提到的所有城市） var cityCoordinates = { '北京': [116.46, 39.92], '上海': [121.48, 31.22], '成都': [104.06, 30.67], '重庆': [106.55, 29.57], '大连': [121.62, 38.92], '烟台': [121.39, 37.52], '威海': [122.12, 37.52], '青岛': [120.38, 36.07], '连云港': [119.16, 34.59], '淮安': [119.15, 33.50], '南通': [120.86, 32.01], '常州': [119.95, 31.79], '无锡': [120.29, 31.59], '嘉兴': [120.76, 30.77], '湖州': [120.09, 30.89], '杭州': [120.19, 30.26], '绍兴': [120.58, 30.01], '宁波': [121.56, 29.86], '黄山': [118.34, 29.71], '丽水': [119.92, 28.45], '温州': [120.65, 28.01], '衢州': [118.87, 28.93], '福州': [119.30, 26.08], '广州': [113.23, 23.16], '佛山': [113.11, 23.05], '香港': [114.17, 22.28], '澳门': [113.55, 22.19], '深圳': [114.07, 22.62], '南昌': [115.89, 28.68], '武汉': [114.31, 30.52], '荆州': [112.24, 30.33], '天津': [117.20, 39.13], '济南': [117.00, 36.65], '太原': [112.53, 37.87], '晋中': [112.75, 37.69], '临汾': [111.52, 36.08], '运城': [111.00, 35.03], '西安': [108.95, 34.27], '绵阳': [104.73, 31.48], '德阳': [104.38, 31.13], '雅安': [103.00, 29.98] }; // 您去过的城市列表 var visitedCities = [ '北京', '上海', '成都', '重庆', '大连', '烟台', '威海', '青岛', '连云港', '淮安', '南通', '常州', '无锡', '嘉兴', '湖州', '杭州', '绍兴', '宁波', '黄山', '丽水', '温州', '衢州', '福州', '广州', '佛山', '香港', '澳门', '深圳', '南昌', '武汉', '荆州', '天津', '济南', '太原', '晋中', '临汾', '运城', '西安', '绵阳', '德阳', '雅安' ]; // 生成echarts数据格式 var chartData = visitedCities.map(function(city) { return { name: city, value: cityCoordinates[city] }; }); var option = { title: { text: '我的中国城市旅行足迹', subtext: '已到访' + visitedCities.length + '个城市', left: 'center', textStyle: { fontSize: 18, fontWeight: 'bold' } }, tooltip: { trigger: 'item', formatter: function(params) { if (params.componentType === 'series') { return params.name + '' + '经度: ' + params.value[0].toFixed(2) + '' + '纬度: ' + params.value[1].toFixed(2); } return params.name; } }, geo: { map: 'china', roam: true, zoom: 1.2, label: { emphasis: { show: false } }, itemStyle: { normal: { areaColor: '#f5f5f5', borderColor: '#ddd', borderWidth: 1 }, emphasis: { areaColor: '#d0e6ff' } } }, series: [ { name: '去过的城市', type: 'scatter', coordinateSystem: 'geo', data: chartData, symbolSize: function(val) { // 主要城市显示稍大 var majorCities = ['北京', '上海', '广州', '深圳', '香港']; return majorCities.includes(val.name) ? 14 : 10; }, itemStyle: { normal: { color: '#ff6b6b', shadowBlur: 8, shadowColor: 'rgba(255, 107, 107, 0.5)' }, emphasis: { color: '#ff3838', shadowBlur: 12, shadowColor: 'rgba(255, 56, 56, 0.8)' } }, label: { normal: { show: true, formatter: '{b}', position: 'right', color: '#333', fontSize: 10 }, emphasis: { show: true, fontSize: 12, fontWeight: 'bold' } } }, { name: '热门城市', type: 'effectScatter', coordinateSystem: 'geo', data: chartData.filter(function(item) { var majorCities = ['北京', '上海', '广州', '深圳', '香港', '成都', '重庆', '杭州', '武汉', '西安']; return majorCities.includes(item.name); }), symbolSize: 12, showEffectOn: 'render', rippleEffect: { brushType: 'stroke', scale: 4, period: 3 }, hoverAnimation: true, itemStyle: { normal: { color: '#e74c3c', shadowBlur: 10, shadowColor: '#e74c3c' } }, zlevel: 1 } ], visualMap: { show: false, min: 0, max: 100, left: 'left', top: 'bottom', inRange: { color: ['#e0f7fa', '#0097a7'] } } }; chart.setOption(option); chart._api.getZr().on('mousewheel', function(e) { e.stop(); }); chart._api.getZr().on('mousedown', function(e) { e.stop(); }); chart._api.getZr().on('mousemove', function(e) { // 只允许tooltip，不允许其他交互 if (e.event.target === chart._dom) { // 允许tooltip正常工作 } }); // 窗口大小变化时重绘 window.onresize = function() { chart.resize(); }; // 添加点击事件 chart.on('click', function(params) { if (params.componentType === 'series') { console.log('点击了城市:', params.name, '坐标:', params.value); } }); // 窗口大小变化时重绘 window.onresize = function() { chart.resize(); }; }, 500); /* 添加一些额外的样式 */ #chinaMap { margin: 20px 0; border-radius: 8px; box-shadow: 0 4px 12px rgba(0,0,0,0.1); background-color: white; } setTimeout(function() { var chart = echarts.init(document.getElementById('worldMap')); // 去过的国家列表 var visitedCountries = ['英国', '日本', '新加坡', '越南']; // 国家信息（首都坐标、颜色、国旗等） var countryInfo = { '英国': { capital: '伦敦', coordinates: [-0.13, 51.51], // 伦敦坐标 color: '#4ECDC4', visitedCities: ['伦敦', '利物浦', '曼彻斯特'], flag: '🇬🇧', continent: '欧洲' }, '日本': { capital: '东京', coordinates: [139.69, 35.69], // 东京坐标 color: '#45B7D1', visitedCities: ['大阪', '神户', '奈良'], flag: '🇯🇵', continent: '亚洲' }, '新加坡': { capital: '新加坡', coordinates: [103.85, 1.29], // 新加坡坐标 color: '#96CEB4', visitedCities: ['新加坡'], flag: '🇸🇬', continent: '亚洲' }, '越南': { capital: '河内', coordinates: [105.85, 21.03], // 河内坐标 color: '#FF8A65', visitedCities: ['河内', '胡志明', '岘港'], flag: '🇻🇳', continent: '亚洲' } }; // 生成echarts数据格式 var chartData = visitedCountries.map(function(country) { var info = countryInfo[country]; return { name: country, value: info.coordinates, capital: info.capital, color: info.color, flag: info.flag, visitedCities: info.visitedCities, continent: info.continent }; }); var option = { title: { text: '我去过的国家', subtext: '已到访4个国家，跨越2个大洲', left: 'center', textStyle: { fontSize: 18, fontWeight: 'bold', color: '#2c3e50' } }, tooltip: { trigger: 'item', backgroundColor: 'rgba(255,255,255,0.95)', borderColor: '#ddd', borderWidth: 1, padding: [10, 15], textStyle: { color: '#333', fontSize: 12 }, formatter: function(params) { if (params.componentType === 'series') { var info = params.data; var citiesHtml = info.visitedCities.map(function(city, index) { return '• ' + city + ''; }).join(''); return '' + info.flag + ' ' + info.name + '' + '首都：' + info.capital + '' + '大洲：' + info.continent + '' + '到访城市：' + '' + citiesHtml + ''; } return params.name; } }, geo: { map: 'world', roam: false, // 禁用缩放和平移 zoom: 1.8, // 稍微放大一些，更好地显示越南 center: [90, 20], // 调整中心点，更好地显示亚洲地区 label: { normal: { show: false }, emphasis: { show: false } }, itemStyle: { normal: { areaColor: '#f0f2f5', borderColor: '#d9d9d9', borderWidth: 0.5 }, emphasis: { areaColor: '#e6f7ff' } }, // 高亮显示去过的国家 regions: visitedCountries.map(function(country) { var info = countryInfo[country]; return { name: getCountryEnglishName(country), itemStyle: { areaColor: info.color + '20', // 20%透明度 borderColor: info.color, borderWidth: 2 } }; }) }, series: [ { name: '去过的国家', type: 'scatter', coordinateSystem: 'geo', data: chartData, symbolSize: 24, symbol: 'pin', symbolRotate: 0, itemStyle: { normal: { color: function(params) { return params.data.color; }, borderWidth: 3, borderColor: '#fff', shadowBlur: 10, shadowColor: 'rgba(0, 0, 0, 0.3)' }, emphasis: { borderWidth: 4, borderColor: '#fff', shadowBlur: 15, shadowColor: 'rgba(0, 0, 0, 0.5)' } }, label: { normal: { show: true, position: 'top', distance: 15, formatter: function(params) { var info = params.data; // 为越南调整标签位置 if (info.name === '越南') { return '{flag|' + info.flag + '}{name|' + info.name + '}'; } return '{flag|' + info.flag + '}{name|' + info.name + '}'; }, rich: { flag: { fontSize: 16, padding: [0, 5, 0, 0] }, name: { backgroundColor: 'rgba(255,255,255,0.9)', padding: [4, 8], borderRadius: 4, borderWidth: 1, borderColor: '#ddd', fontSize: 12, fontWeight: 'bold', color: '#333' } } }, emphasis: { show: true, fontSize: 14 } } }, { name: '国家特效', type: 'effectScatter', coordinateSystem: 'geo', data: chartData, symbolSize: 12, showEffectOn: 'render', rippleEffect: { brushType: 'stroke', scale: 4, period: 3 }, hoverAnimation: true, itemStyle: { normal: { color: function(params) { return params.data.color; }, shadowBlur: 15, shadowColor: function(params) { return params.data.color; } } }, zlevel: 1 } ], graphic: [ // 添加大洲标注 { type: 'text', left: '25%', top: '40%', style: { text: '欧 洲', fill: '#4ECDC4', fontSize: 16, fontWeight: 'bold', shadowColor: '#fff', shadowBlur: 5 } }, { type: 'text', left: '65%', top: '45%', style: { text: '亚 洲', fill: '#45B7D1', fontSize: 16, fontWeight: 'bold', shadowColor: '#fff', shadowBlur: 5 } } ] }; chart.setOption(option); // 禁用所有鼠标交互 chart.getZr().on('mousewheel', function(e) { e.stop(); }); chart.getZr().on('mousedown', function(e) { e.stop(); }); // 窗口大小变化时重绘 window.onresize = function() { chart.resize(); }; // 辅助函数：获取国家英文名（用于地图区域匹配） function getCountryEnglishName(chineseName) { var nameMap = { '英国': 'United Kingdom', '日本': 'Japan', '新加坡': 'Singapore', '越南': 'Vietnam' }; return nameMap[chineseName] || chineseName; } }, 500); #worldMap { margin: 20px 0; border-radius: 8px; box-shadow: 0 4px 12px rgba(0,0,0,0.1); background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%); cursor: default !important; } /* 自定义提示框样式 */ .echarts-tooltip { box-shadow: 0 6px 16px rgba(0,0,0,0.15) !important; border-radius: 6px !important; } /* 禁用所有交互 */ .echarts-map { pointer-events: none !important; } /* 但允许tooltip工作 */ .echarts-map .geo { pointer-events: auto !important; }"},{"title":"留言板","date":"2020-06-23T10:57:02.000Z","updated":"2025-05-20T11:46:57.000Z","comments":true,"path":"message/index.html","permalink":"http://vompom.github.com/message/index.html","excerpt":"","text":"说点什么？"},{"title":"project","date":"2024-03-04T11:55:31.000Z","updated":"2025-05-20T11:46:57.000Z","comments":true,"path":"project/index.html","permalink":"http://vompom.github.com/project/index.html","excerpt":"","text":"test"}],"posts":[{"title":"如何构建一个好用的SDK","slug":"如何构建一个好用的SDK","date":"2026-02-04T12:53:23.000Z","updated":"2026-02-09T11:48:13.026Z","comments":true,"path":"2026/02/04/如何构建一个好用的SDK/","permalink":"http://vompom.github.com/2026/02/04/%E5%A6%82%E4%BD%95%E6%9E%84%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%A5%BD%E7%94%A8%E7%9A%84SDK/","excerpt":"","text":"如何去设计一个好用的SDK，自己做了很久的SDK，实际上并没有过多去思考过这个问题。最近对起总结一下，在回答这个问题之前，我们可以自己思考一下：对于接入者，怎样才算是一个好的SDK？对我自己而言，如果我要去接入一个SDK的话，可能会去考虑分别针对几个阶段： 接入前： 有清晰的文档能告诉我这个SDK 的环境要求，比如 minSdkVersion compileSdkVersion 这些硬性配置，明确列出所有直接 / 间接依赖的第三方库及版本，以及包大小、申请权限等。 接入中：接入需要足够简单，在 dependencies 中一行搞定；如果有初始化操作也尽量简洁，一行搞定；对应 SDK 调用 ，提供一个单例类或者某个接口，在这个类/接口里面能够看到最核心的 Api；使用的接口对各种异常处理有足够多的错误提示信息；针对输出日志能够有配置开关等。 接入后： SDK 由于功能需要更新，需提供详尽的 CHANGELOG，接入者只用更新版本号； 上面是站在接入者的角度去考虑的，作为SDK的开发者则应该遵循以下的规则。 先前原则核心原则：以接入方体验为中心 在开发一个SDK的时候，把接入者当作“小白”，不寄希望于他能点进SDK内部，去了解内部的实现；把接入者视作“懒人”，他不想做太多事，他赖得看你代码里面的各种注释，只想看一份接入文档就搞定所有事情。 最小化原则：只暴露必要的内容 对外仅暴露核心入口类 + 必要数据类 + 统一结果类，内部工具类、中间逻辑、私有方法全部标记为private（Java）/internal（Kotlin），杜绝接入方依赖内部逻辑。 稳定性原则：避免崩溃，容错兜底 不要将你的SDK视为一个可以随时更新的应用程序，而应将其看作一旦上线就无法实时更新的后端服务。避免崩溃是第一前提，但不可能万无一失，会由于设备兼容性问题，没法在上线将所有情况全考虑到，那么需要SDK能够有兜底操作，比如某个开关能够关闭掉该功能，或者针对特定机型Android系统等进行屏蔽（需服务端配合）。 开发阶段详细的文档接入需要清晰、详细的文档，了解如何充分发挥 SDK 的能力。一份全面的文档需要包含： SDK开发环境要求 SDK安装和配置的详细流程 核心 Api 使用的代码示例 有一个可进行索引的目录 安装和初始化使用Maven Publish Plugin将 SDK 发布到 Maven 仓库，配置groupId/artifactId/version，确保接入方仅需一行implementation即可引入； 避免在 AndroidManifest.xml 中配置冗余内容，如需一些动态配置，提供Gradle 插件自动注入这些能力，无需接入方手动修改。 初始化的时候一行搞定，比如：XxxSdk.Builder().appKey(&quot;your_app_key&quot;).debugMode(true).build() 极简 API 设计设计良好的 API 确保接入者能够轻松集成并使用你的 SDK 功能，避免不必要的复杂性。用 Kochava SDK 工程总监 Nathan Darst 的话说： The developer wants to solve a problem, and the API should facilitate solving this problem quickly and intuitively with as few lines of code as possible. A good API prioritizes and focuses on the most common use cases; it is not muddied up with unnecessary, ambiguous, redundant, or rarely used functionality likely to confuse the user. 开发者的核心诉求是解决实际问题，而 API 的设计初衷，应是助力开发者用最少的代码、最直观的方式，快速解决问题。一个优质的 API，会优先聚焦并打磨最常用的核心使用场景；不会掺杂无关、模糊、冗余或极少用到的功能 —— 这类功能只会让使用者产生困惑。 更多的代码准则应参考谷歌官方：Android API 准则 轻量级 SDK尽量减少外部依赖，尤其是核心功能方面。如果非得用第三方库（Gson、okhttp等），就把它们隔离出来，或者更好的是，让接入者选择排除或替换这些工具，或者参考koin，采用模块化架构允许仅集成所需的组件。 错误处理、调试、测试当出现错误时，清晰且可作的响应帮助接入者快速识别并修复问题，减少挫败感，节省集成和故障排除的时间。尽可能将详细的错误返回或者在日志里面输出出来，不要只展示“未知错误”、”-1”、“errros”这些表达不明确的错误。 除了明确的错误信息提示外，还需要提供一些详细详细日志，且可配置。以视频渲染SDK为例，由于有多个线程参与，还有 GPU 参与，断点调试几乎不太可能，如果在每一帧都打印日志的话，又会得到大量冗余的信息，所以这里就需要日志输出可配置化。 为了更好地测试你的库，建议使用 依赖注入，这里以一份网络请求做对比-&gt;使用依赖注入和不使用依赖注入的两种实现对比 依赖注入通过解耦被测试类与具体依赖，实现依赖的灵活替换与精准模拟，让单元测试更可控、快速且用例间相互独立。 前后的兼容性当 SDK 更新破坏现有 API 实现时，接入者会面临不必要的返工，通过保持向后兼容性，使接入者能够无缝采用新的 SDK 版本，同时不影响他们的工作流程。实现这一目标的一种广泛采用的策略是语义版本控制（SemVer）， 它采用三部分版本控制方案，清晰传达变更的范围和影响： 以 4.3.2 为例，4 是主版本号，其变更代表 SDK 出现了向后不兼容的破坏性修改，需适配调整才能使用；3 是次版本号，其变更为新增兼容式功能 / 特性，无需改动原有代码即可升级；2 是补丁版本号，其变更仅为兼容式 bug 修复，是最无风险的小版本升级。 其他这里主要是一些琐碎点，或者能提供一些在SDK 开发过程中的帮助 多利用语言特性目前我遇到的利用 kotlin 特性最好的开源库是 koin，使用了大量的高阶函数 &amp; Lambda 表达式，比如：高阶函数 / Lambda实现简洁的 DSL 模块定义（module { … }），委托属性实现by inject() 延迟获取依赖，协程支持协程作用域、挂起函数创建依赖等 演示代码片段：koin使用到 kotlin 的一些特性 善于使用脚本脚本可以帮助开发者实现很多重复工作，包括不限于：Android SDK 一键编译打包（AAR/JAR）、多版本编译（测试不同 Kotlin/AGP 版本）、自动更新 SDK 版本号、生成版本日志（结合 Git 提交记录）、测试自动化等，这里面有很多可以使用 Gradle脚本，有的也可使用 Shell 脚本。 其他持续补充…… 总结本人结合个人Android SDK开发经验，好用的SDK需围绕接入方体验、稳定性设计：接入前有清晰文档，接入中极简便捷，接入后无缝升级。开发者需遵循接入方体验为中心、最小化暴露、稳定性兜底三大原则，开发中做好文档、安装初始化、API设计等核心工作，善用Kotlin特性与自动化脚本。本文为个人经验总结，因SDK开发场景多样，不适用于所有情况，仅供学习参考。 参考Building great SDKs SDK Development; The Good, The Bad, The Ugly SDK design best practices Mobile SDK Development Guidelines Android SDK开发艺术探索（一）开篇与设计 Building Better SDKs","categories":[{"name":"思考总结","slug":"thinking","permalink":"http://vompom.github.com/categories/thinking/"}],"tags":[{"name":"SDK","slug":"SDK","permalink":"http://vompom.github.com/tags/SDK/"}],"author":"落叶挽歌"},{"title":"JPEG压缩之DCT离散余弦变换","slug":"JPEG压缩之DCT离散余弦变换","date":"2025-11-04T14:25:17.000Z","updated":"2025-11-08T03:17:35.317Z","comments":true,"path":"2025/11/04/JPEG压缩之DCT离散余弦变换/","permalink":"http://vompom.github.com/2025/11/04/JPEG%E5%8E%8B%E7%BC%A9%E4%B9%8BDCT%E7%A6%BB%E6%95%A3%E4%BD%99%E5%BC%A6%E5%8F%98%E6%8D%A2/","excerpt":"","text":"在digital_video_introduction的一节中讲解 视频编解码器是如何工作的？提到了 DCT，此前没有太关注，最近有对相关的原理进行学习了解，本文对 DCT 离散余弦变换相关的内容进行整理总结。JPEG 使用的是 二维 DCT，因为它处理的是图像（二维信号）,理解二维 DCT 的基础是一维 DCT。 一维离散余弦变换一维 DCT 将一个长度为 N 的信号序列（例如一行像素值）从空间域转换到频域。最常用的是 DCT-II 类型，这也是 JPEG 标准所使用的。 正变换： 从空间域到频域 F(u) = C(u) \\sum_{x=0}^{N-1} f(x) \\cdot \\cos\\left[\\frac{\\pi u (2x + 1)}{2N}\\right]其中： f(x) 是输入信号在位置 x 的值（例如，像素亮度）。 F(u) 是变换后得到的第 u 个频率分量（DCT 系数）。 N 是信号的长度（在 JPEG 中，通常是 8）。 u 是频率索引，u = 0, 1, \\dots, N-1。 x 是空间位置索引，x = 0, 1, \\dots, N-1。 C(u) 是一个归一化系数，定义为： C(u) = \\begin{cases} \\sqrt{\\frac{1}{N}} & \\text{if } u = 0 \\\\ \\sqrt{\\frac{2}{N}} & \\text{if } u > 0 \\end{cases}关键点： 当 u = 0 时，F(0) 被称为 直流系数。它实际上是整个信号块的平均值。 当 u > 0 时，F(u) 被称为 交流系数。它们代表了信号中不同频率的振荡模式。u 越大，代表的频率越高。 二维离散余弦变换JPEG 将图像分割成 8x8 的小块，然后对每个块独立进行二维 DCT。二维 DCT 可以看作先对每一行进行一维 DCT，然后再对每一列进行一维 DCT（顺序可互换）。 正变换： 从空间域到频域 F(u, v) = C(u) C(v) \\sum_{x=0}^{N-1} \\sum_{y=0}^{N-1} f(x, y) \\cdot \\cos\\left[\\frac{\\pi u (2x + 1)}{2N}\\right] \\cdot \\cos\\left[\\frac{\\pi v (2y + 1)}{2N}\\right]其中： f(x, y) 是 8x8 图像块中在位置 (x, y) 的像素值。在计算前，通常会先将像素值减去 128（即 -128 到 127 的范围），使其围绕零对称。 F(u, v) 是变换后得到的在频率 (u, v) 上的 DCT 系数。 N = 8（对于标准的 JPEG）。 u, v 是频率索引，u, v = 0, 1, \\dots, 7。 x, y 是空间位置索引，x, y = 0, 1, \\dots, 7。 C(u) 和 C(v) 的定义与一维情况相同： C(u) = \\begin{cases} \\sqrt{\\frac{1}{8}} & \\text{if } u = 0 \\\\ \\sqrt{\\frac{2}{8}} & \\text{if } u > 0 \\end{cases} 同理于 C(v)。 关键点： F(0, 0) 是 直流系数，代表整个 8x8 块的平均亮度。 所有其他的 F(u, v) 都是 交流系数。 系数 F(u, v) 的 u 和 v 值越大，代表在水平和垂直方向上的频率越高。 在变换后的 8x8 系数矩阵中，左上角是低频系数，右下角是高频系数。图像的大部分能量（信息）都集中在低频区域，这是 JPEG 能够实现高压缩比的关键。 逆离散余弦变换为了从频域数据重建图像，需要使用逆 DCT。 逆变换： 从频域回到空间域 f(x, y) = \\sum_{u=0}^{N-1} \\sum_{v=0}^{N-1} C(u) C(v) F(u, v) \\cdot \\cos\\left[\\frac{\\pi u (2x + 1)}{2N}\\right] \\cdot \\cos\\left[\\frac{\\pi v (2y + 1)}{2N}\\right]公式中的各项含义与正变换完全相同。 简单理解DCT的本质与核心直觉 DCT可以看作离散傅里叶变换（DFT）的一种特殊形式，主要处理实数信号，并且有很好的能量集中特性。 它的核心思想是：任何一个8x8的像素块，都可以看作是64种不同频率的标准余弦波（即“基础图案”）按照特定权重（也就是DCT系数）叠加而成的。在这些基础图案中： 低频成分（对应于系数矩阵左上角，u和v值较小的部分）代表了图像块的大致轮廓和平滑变化的背景。 高频成分（对应于系数矩阵右下角，u和v值较大的部分）代表了图像块的细节、锐利边缘和纹理。 图像的大部分视觉能量（信息） 通常都集中在低频区域。这意味著，我们往往只需要少数几个大的低频系数，就能大致描述出图像块的主要样貌。 用二进制分解来类比DCT的能量集中 171=2^7+2^5+2^3+2^1+2^0如果我们将所有的0系数也补上 171=2^7+0*2^6+2^5+0*2^4+2^3+0*2^2+2^1+2^0那么对应的系数数组为：[1,0,1,0,1,0,1,1] 如果我们简单将数组低索引称之为”低频”，高索引为”高频”,将数据压缩只包含”低频”系数[1,0,0,0,0,0,0,0]=&gt;2^7=128 大概丢了25%的信息[1,0,1,0,0,0,0,0]=&gt;2^7+2^5=160 大概丢了6%的信息[1,0,1,0,1,0,0,0]=&gt;2^7+2^5=160 大概丢了1%的信息…… 可以看到“高频”信号对整个数据的影响比较小，这与DCT的思想不谋而合：我们保留对整体影响大的主要成分（低频系数），而舍弃或粗略表示那些影响细微的成分（高频系数），从而实现压缩。 总结 JPEG 压缩的流程 颜色空间转换：将图像从 RGB 转换到 YCbCr。 分块：将每个分量（Y, Cb, Cr）图像分割成 8x8 的块。 前向 DCT：对每个 8x8 块应用上述的二维 DCT 公式，得到频率系数。 量化：将 DCT 系数除以一个对应的量化步长（来自量化表），并四舍五入到整数。这一步是有损的，是信息丢失的主要来源。高频系数通常会被量化为 0。 熵编码：对量化后的系数进行 Zigzag 扫描、差分脉冲编码调制和霍夫曼编码，生成最终的 .jpg 文件。 当解码时，过程是反过来的：熵解码 -&gt; 反量化 -&gt; 逆 DCT -&gt; 合并块 -&gt; 转换回 RGB。 参考 《影像算法解析——JPEG 压缩算法》 《白话文理解DCT离散余弦变换》 《离散余弦变换》 视频 The Unreasonable Effectiveness of JPEG: A Signal Processing Approach中文翻译版本《离散余弦变换可视化讲解》","categories":[{"name":"算法研究","slug":"算法研究","permalink":"http://vompom.github.com/categories/%E7%AE%97%E6%B3%95%E7%A0%94%E7%A9%B6/"}],"tags":[{"name":"数学","slug":"数学","permalink":"http://vompom.github.com/tags/%E6%95%B0%E5%AD%A6/"}],"author":"落叶挽歌"},{"title":"H264码流结构理解整理","slug":"H264码流结构理解整理","date":"2025-09-15T13:31:00.000Z","updated":"2025-12-16T13:30:14.834Z","comments":true,"path":"2025/09/15/H264码流结构理解整理/","permalink":"http://vompom.github.com/2025/09/15/H264%E7%A0%81%E6%B5%81%E7%BB%93%E6%9E%84%E7%90%86%E8%A7%A3%E6%95%B4%E7%90%86/","excerpt":"","text":"本文将带你深入H.264文件的内部，从宏观到微观，逐一剖析其各个组成部分的作用、相互关系以及一些精妙的设计哲学。在了解H264之前需要有以下的一些基础知识： 宏观结构：从文件到帧一个H.264原始码流（.h264或.264文件）并不是一个简单的“视频文件”，它不包含音频、字幕等元信息。它是一个纯粹的、编码后的视频数据比特流。这个流的结构可以看作一个分层模型，如下图所示，理解这个结构是理解H.264的关键： 网络抽象层单元 (NAL Unit)H.264设计的一个核心思想是网络友好性。为了实现这一目标，整个码流被分割成一个个独立的包，称为 NAL Unit（网络抽象层单元）。每个NAL Unit都是一个自包含的数据包，包含一个头部和负载数据。这种设计使得H.流非常适合在容易产生包丢失和延迟的网络（如RTP/UDP）中传输，因为一个NAL Unit的丢失通常不会导致整个视频无法解码。 关键概念：帧 (Frame) 与片 (Slice)在视频编码中，一帧（Frame） 通常对应一张静态图片。H.264对一帧图像进行编码后，其数据可能会被装进一个或多个NAL Unit中。 为什么是一或多个？这是因为一帧数据可以被分割成多个片（Slice）。每个Slice都是一个独立的编码单元，包含了一帧图像中的一部分宏块（Macroblock）。将一帧分割成多个Slice主要有两个好处： 错误恢复：在网络传输中，如果一个Slice丢失了，解码器仍然可以利用错误隐藏技术来近似恢复图像，而不是丢失整帧。 并行处理：多个Slice可以并行编码或解码，提高效率。 微观结构：NAL Unit的内部世界现在，让我们打开一个NAL Unit，看看它里面到底有什么。 NAL Unit Header（头部）每个NAL Unit都以一个1字节（可扩展为2字节）的头部开始。这个头部虽然小，但信息量巨大： 禁止位（F）：通常为0，如果为1表示该单元出错。 重要性指示位（NRI）：表示这个NAL Unit的重要性。值越大，解码器越需要优先保护它（如SPS/PPS的NRI值最高）。 类型（Type）：这是最关键的部分！它定义了该单元负载数据的类型。主要分为两大类： VCL（视频编码层）单元：真正携带编码视频数据的单元（如Slice）。 Non-VCL（非视频编码层）单元：携带元数据和控制信息的单元，是解码的“说明书”。 NAL Unit Payload（负载）负载部分的数据内容完全由头部中的类型（Type） 决定。 关键的Non-VCL单元（元数据）这些单元不包含图像像素数据，但没有它们，VCL单元根本无法被解码。它们通常在视频流开始时发送一次，但如果解码器中途加入，也需要重新获取。 SPS（序列参数集 - Type 7） 作用：包含了适用于整个视频序列的全局参数。它是解码器的“总纲”。 包含信息：视频的档次、级别、分辨率（pic_width_in_mbs_minus1等）、帧率、色深、比特深度等。没有SPS，解码器连图像该解码成多大都不知道。 PPS（图像参数集 - Type 8） 作用：包含了适用于一幅或多幅图像的解码参数。它更像是“章节细则”。 包含信息：熵编码模式（CAVLC或CABAC）、量化参数等。PPS可以改变，从而在序列中实现不同的编码配置。 IDR（即时解码刷新 - 属于VCL，但特殊） 作用：一个特殊的Slice（通常是I-Slice），它告诉解码器：“从这里开始，可以独立解码，不再需要参考之前的帧了。” 意义：IDR帧是随机访问和 seeking 的关键点。当你拖动视频进度条时，播放器总是在寻找最近的IDR帧开始解码，因为它能清空之前的参考帧缓冲区，保证解码正确。 VCL单元（核心数据）这些单元携带了实际的压缩视频数据，即Slice。 Slice Header（切片头） 每个Slice都有自己的头，其中包含了当前Slice解码所需的信息： 引用哪个PPS（从而间接引用SPS）。 帧类型（I, P, B）。 量化参数。 根据帧类型，包含运动向量预测所需的信息。 Slice Data（切片数据） 这是压缩数据的核心，由一系列宏块（Macroblock） 组成。 宏块通常是16x16像素的编码单元，它包含了： 预测信息：对于I帧，是帧内预测模式；对于P/B帧，是运动向量（描述当前块是从参考帧的哪个位置移动过来的）。 残差数据：经过预测后，当前块与预测块之间的差值。这部分数据会经过变换（DCT）、量化、熵编码（CAVLC/CABAC），从而获得极高的压缩率。 特殊设计点3.1 参数集（SPS/PPS）机制这是H.264一个非常巧妙的设计。它将很少改变但至关重要的信息（SPS/PPS）与频繁变化的数据（Slice）分离开。 优点一：鲁棒性：即使丢失了一些Slice，只要SPS/PPS还在，解码器就能继续工作。 优点二：效率：无需在每一个Slice中都重复这些头部信息，大大节省了码流。 优点三：灵活性：一个码流中可以存在多个PPS，并在不同场景下切换使用。 3.2 I, P, B帧与GOP（图像组） I帧（Intra）：自包含帧，仅使用本帧内的信息进行编码，不参考其他帧。它是压缩率最低但最关键的帧，是P帧和B帧的锚点。 P帧（Predicted）：参考前面的I帧或P帧进行运动补偿预测编码，压缩率高于I帧。 B帧（Bi-directional）：可以同时参考前面和后面的帧，获得最高的压缩率，但会带来编码延迟。 一个GOP就是从上一个IDR帧到下一个IDR帧之前的所有帧序列。GOP长度越长，B/P帧越多，压缩率越高，但随机访问的间隔也越长。 3.3 熵编码：CAVLC 与 CABAC这是压缩过程中的最后一步，将数据转换为二进制码流。 CAVLC（上下文自适应变长编码）：相对简单，压缩效率一般，用于Baseline等档次。 CABAC（上下文自适应二进制算术编码）：非常复杂，但压缩效率比CAVLC高出10%-20%，是Main和High档次效率高的主要原因之一。 总结H.264的结构是一个分层、模块化的杰作： 整体：码流由一个个NAL Unit组成，适合网络传输。 局部：NAL Unit分为VCL（携带Slice数据）和Non-VCL（携带SPS/PPS等元数据）。 核心：Slice数据由宏块组成，宏块包含了预测信息和残差数据，通过预测和变换编码实现压缩。 精妙设计：参数集分离、IDR帧、Slice划分和CABAC等特性共同造就了H.264在效率、鲁棒性和灵活性上的完美平衡。 理解H.264的结构，不仅能帮助我们更好地处理视频数据（如封装、传输、解码问题定位），更能让我们体会到工程师们在标准制定中的智慧和远见。尽管如今H.265/HEVC、AV1等更先进的编码器已经出现，但H.264的基本设计思想和结构仍然深刻地影响着它们。","categories":[],"tags":[{"name":"音视频","slug":"音视频","permalink":"http://vompom.github.com/tags/%E9%9F%B3%E8%A7%86%E9%A2%91/"}],"author":"落叶挽歌"},{"title":"手写一个精简版Koin：深入理解依赖注入核心原理","slug":"Koin-源码理解相关","date":"2025-08-25T13:08:00.000Z","updated":"2025-08-25T13:44:34.603Z","comments":true,"path":"2025/08/25/Koin-源码理解相关/","permalink":"http://vompom.github.com/2025/08/25/Koin-%E6%BA%90%E7%A0%81%E7%90%86%E8%A7%A3%E7%9B%B8%E5%85%B3/","excerpt":"","text":"在现代 Android 应用开发中，依赖注入（Dependency Injection, DI）已成为构建松耦合、可测试代码的重要技术。Koin 作为一个轻量级的Kotlin依赖注入框架，因其简洁的DSL和易用性深受开发者喜爱。最近对其源码进行学习了解，通过手写一个极度精简的 Koin 核心代码，来透彻理解Koin的注册、解析和参数传递机制。 本文代码基于 Koin 源码思想实现，仅用于学习核心原理，并非 Koin官 方代码。 核心概念与项目结构下图是基于 koin 4.1 解析的 主要类UML图，可以比较清晰地看看各个类之间的关系power by mermaidchart 主要类： KoinApplication: Koin启动的入口，负责初始化容器和加载模块。 Koin: 核心容器，持有实例注册表 InstanceRegistry 和作用域注册表 ScopeRegistry。 Module: 定义依赖的地方，存放了所有的 bean 定义 BeanDefinition 与 InstanceFactory。 BeanDefinition: 对一个依赖项的定义，包括其类型、限定符、所属作用域以及创建它的 lambda 表达式。 InstanceFactory: 负责根据 BeanDefinition 创建实例的核心工厂，分为 SingleFactory (单例)、FactoryFactory (工厂模式) 和 ScopeFactory (作用域内单例)。 Scope: 作用域，用于管理特定生命周期内的实例。 ParametersHolder: 参数容器，用于在获取实例时动态传递参数。 手写 koin 代码介绍基于对源码的理解和参考，实现了 koin 的基本功能，整体分成三部分：简单 single 数据存取、包含 scope 能力、动态参数能力，分成三个文件夹，顺序123是基于前面带代码累加的。 简单 single 数据存取代码实现在：KoinWithoutScope.kt 这是一份最简单的代码，大概200行不到，基本上包含了 koin 的核心思想：启动时注册组件定义。解析时，先查作用域缓存，命中则直接返回。未命中则递归解析其依赖项，调用工厂函数创建实例，最后返回实例。 从这也能看出来 koin 的缺点：Koin 启动时 (startKoin) 需要将所有模块的定义 (BeanDefinition) 注册到容器中。实例数量过多会显著增加启动注册过程的耗时，影响应用启动速度。由于每个实例都会对应一个 BeanDefinition 以及 Factory ，内存占用会相应地上升。 整个流程简单来讲就是生成一个 map，通过 key 获取对于的数据。 Scope 能力代码实现在：KoinWithScope.kt 这一份是在之前的能力上进行添加，此前将所有的数据都注册到 “root” 这个容器内，全局通用，但为了将不同作用域分开，需要引入 scope 的概念。 简单理解就是在通过 key 获取的 map 里面的数据的时候，这个 key 是有一定的规则的，核心逻辑在这里： inline fun indexKey(clazz: KClass&lt;*&gt;, typeQualifier: String?, scopeQualifier: String): String &#123; return buildString &#123; append(clazz.java.name) append(&#x27;:&#x27;) append(typeQualifier ?: &quot;&quot;) append(&#x27;:&#x27;) append(scopeQualifier) &#125;&#125; 不同的 scope 实际上也就是获取的 key 值的不同。 动态参数能力代码实现在：KoinWithParameter.kt 最后在 scope 的基础上实现了一个比较重要的能力-动态参数能力，通过这个能力可以让有实例能够在运行的时候根据参数动态创建。这个能力也是像在安卓 Activity/Fragment 里面 viewmodel() 实现依赖注入的必要实现。 简单理解就是在 get() 的时候将参数传入到获取实例的调用链中，在运行时执行注册的 Lambda 函数invoke时候将作为参数传递到构造方法中去。这里单独拎出来实现是因为这个参数传递影响到整个流程的逻辑，为了上上面的两个能力逻辑更简单清晰，单独在这一部分实现。 Koin 的注册流程（Declaration）注册是DI容器工作的第一步。通过 startKoin 和 module DSL来声明依赖。 启动 Koin 与模块加载整个启动加载流程将 kotlin 的语法糖用到了极致，也就使得整个代码看起来是如此的简洁。 val myApp = startKoin &#123; modules(appModule)&#125;// 定义一个模块val appModule = module &#123; // 注册一个单例，其构造需要一個 Int 参数 single &#123; (data: Int) -&gt; ComponentInt(data) &#125; // 注册一个工厂（每次获取都是新实例），其构造需要 Int 和 Float 参数 factory &#123; (data1: Int, data2: Float) -&gt; ComponentIntFloat(data1, data2) &#125;&#125; 流程剖析： startKoin这是一个顶级函数，它调用 GlobalContext.startKoin，创建并初始化一个 KoinApplication 对象。 modules(...)KoinApplication 的方法，它将传入的 Module 列表交给 Koin 实例的 loadModels 方法处理。 module &#123; ... &#125;DSL函数，它创建一个 Module 对象，并执行其中的配置lambda。 single/factory/scopeModule 的扩展函数。它们的作用是： 使用 _createDefinition 将 lambda 表达式包装成一个 BeanDefinition对象。 使用 _InstanceFactory 将 BeanDefinition 包装成对应的 InstanceFactory。 调用 indexPrimaryType，生成一个唯一的Key（格式：类名:限定符:作用域），并将 Factory 存入 Module.mappings 这个 HashMap 中。 最终存储Koin 的 InstanceRegistry 会遍历所有 Module，将它们 mappings 中的全部 Factory 都合并到自己的 _instances（一个 ConcurrentHashMap）中。 至此，所有依赖的定义都已注册到容器中，静待获取。 Koin的实例获取流程（Retrieval）// 获取无参依赖（普通方式）val component = get&lt;Component&gt;()// 通过 scope 作用域限定进行获取val scope = koin.createScope(&quot;scope&quot;, scopeQualifier)val component = scope.get&lt;Component&gt;()// 通过需要动态参数的获取val componentWithArgs = get&lt;ComponentInt&gt; &#123; parametersOf(42) &#125;val componentWithMultiArgs = get&lt;ComponentIntFloat&gt; &#123; parametersOf(101, 3.14f) &#125; 流程剖析Scope.get&lt;T&gt; 这是 Scope 的一个扩展函数。它首先创建一个 ResolutionContext，封装了当前作用域、要解析的类型、限定符以及最重要的——参数持有器 ParametersHolder（由 parametersOf 函数创建）。 解析上下文（ResolutionContext） 这个上下文对象包含了解析一个实例所需的所有信息。 核心解析器（CoreResolver）get 操作会委托给 Koin 的 CoreResolver进行处理。源码里面对于查找顺序有非常清晰的层次体现： override fun &lt;T&gt; resolveFromContext(scope : Scope, instanceContext: ResolutionContext): T &#123; return resolveFromContextOrNull(scope,instanceContext) ?: throwNoDefinitionFound(instanceContext) &#125; private fun &lt;T&gt; resolveFromContextOrNull(scope : Scope, instanceContext: ResolutionContext, lookupParent : Boolean = true): T? &#123; return resolveFromInjectedParameters(instanceContext) ?: resolveFromRegistry(scope,instanceContext) ?: resolveFromStackedParameters(scope,instanceContext) ?: resolveFromScopeSource(scope,instanceContext) ?: resolveFromScopeArchetype(scope,instanceContext) ?: if (lookupParent) resolveFromParentScopes(scope,instanceContext) else null ?: resolveInExtensions(scope,instanceContext) &#125; 查找工厂 Resolver 会调用 InstanceRegistry.resolveDefinition。 该方法使用和注册时相同的算法生成Key（类名:限定符:作用域），然后从 _instances 中查找对应的 InstanceFactory。 创建实例 找到 Factory 后，调用其 get(context: ResolutionContext) 方法。 Factory 会调用自己的 create 方法。关键一步来了：在 create 方法中，会执行 BeanDefinition.definition.invoke(context.scope, parameters)。这其实就是执行了之前注册的 lambda：&#123; (data: Int) -&gt; ComponentInt(data) &#125;。 参数传递：这里的 parameters 就是在 get 时传入的 ParametersHolder。Lambda 的参数 (data: Int) 会从 ParametersHolder 中按顺序（或使用解构）取出值 返回实例 工厂将创建好的实例返回给调用者。 对于 SingleFactory，它会将第一次创建出来的实例缓存起来，后续调用直接返回缓存实例。FactoryFactory 则每次都会执行 create 方法。 其他技术@DslMarker 的作用在实现的过程中发现如下图所示：koin 的代码有颜色分层，能比较清晰地看到各个 block 之间的差异，自己写的代码全部是白色。 代码开头定义了三个注解：@KoinApplicationDslMarker, @KoinDslMarker, @OptionDslMarker。这是Kotlin DSL的安全卫士。@DslMarkerannotation class KoinDslMarker@KoinDslMarkerclass Module &#123; fun single(...) &#123; ... &#125; // 这个single在DSL里&#125;@KoinDslMarkerclass KoinApplication &#123; fun modules(...) &#123; ... &#125; // 这个modules在DSL里&#125;fun test() &#123; startKoin &#123; modules(...) // 正确：在 KoinApplication 的 lambda 里 single &#123; ... &#125; // 编译错误！@DslMarker 阻止了隐式地使用外部 Receiver (Module) &#125;&#125; @DslMarker 实际的作用是防止在嵌套的DSL Lambda中，意外地调用到外层 Receiver 的方法，从而让DSL书写更加清晰和安全。代码颜色是由 IDE 提供的效果。在代码中加上几个注解之后，效果如图所示： 跟 koin 的颜色不太一致，不过能明显看到代码有分层，应该是由于 koin 对 annotation 也有处理，这里没有再深入研究。 2. 优雅的参数传递与解构这个逻辑复刻了Koin的动态参数特性。 ParametersHolder：一个轻量的参数容器，内部用一个 List&lt;Any?&gt; 存储参数。 parametersOf：辅助函数，优雅地创建 ParametersHolder。 解构声明（Destructuring Declaration）：ParametersHolder 重写了 component1() 到 component5() 操作符。这使得在定义lambda时，可以直接用 (a: A, b: B) 的形式来接收参数，而不是手动调用 parameters.get&lt;X&gt;(0)。 // 注册端：看起来就像普通函数single &#123; (id: Int, name: String) -&gt; User(id, name) &#125;// 获取端：传递参数非常直观val user = get&lt;User&gt; &#123; parametersOf(123, &quot;Julius&quot;) &#125; 这种设计极大地提升了API的简洁性和可读性。 总结通过这个手写的迷你Koin，可以深刻地理解到，一个现代DI容器的核心无非是解决两个问题： 如何注册（Declaration）：通过DSL将依赖的创建方式（Lambda）以键值对的形式保存到一个全局的注册表中。 如何获取（Retrieval）：根据请求的类型、限定符和作用域生成Key，从注册表中找到对应的创建工厂，并调用它来生成实例。支持通过参数容器实现动态传参。 除此之外，诸如 @DslMarker 保证DSL安全、解构实现参数优雅传递，都是构建一个健壮、易用框架的关键技术。 虽然这个实现省略了Koin的许多高级功能（如完整的Scope生命周期管理、属性注入、Android特定支持等），但它已经囊括了最核心、最精妙的设计思想，再理解其他的模块也会简单很多。 实现的所有源码位于：JProject/source/koin","categories":[{"name":"技术文章","slug":"technology","permalink":"http://vompom.github.com/categories/technology/"}],"tags":[{"name":"koin","slug":"koin","permalink":"http://vompom.github.com/tags/koin/"}],"author":"落叶挽歌"},{"title":"[Compose Multiplatform]跨平台博客应用实践","slug":"Compose-Multiplatform-跨平台博客应用实践","date":"2025-07-28T12:28:00.000Z","updated":"2026-02-09T10:48:52.288Z","comments":true,"path":"2025/07/28/Compose-Multiplatform-跨平台博客应用实践/","permalink":"http://vompom.github.com/2025/07/28/Compose-Multiplatform-%E8%B7%A8%E5%B9%B3%E5%8F%B0%E5%8D%9A%E5%AE%A2%E5%BA%94%E7%94%A8%E5%AE%9E%E8%B7%B5/","excerpt":"","text":"用 CMP 构建跨平台博客应用：一次 Kotlin 的全栈实践在追求高效开发的时代，跨平台技术已成为移动应用开发的主流选择，此前基于鸿蒙的开发平台开发 blog_harmony，将自己博客文章进行展示。本文将介绍基于 CMP(Compose Multiplatform) 构建的开源博客应用 blog_kmp，展示如何用 Kotlin 实现跨平台的应用开发。 Compose MultiplatformCompose Multiplatform 是 JetBrains 推出的声明式 UI 框架，基于 Jetpack Compose 扩展而来： 核心优势：用同一套 Kotlin 代码构建 Android、iOS、Desktop 和 Web 应用 开发效率：实时预览、热重载加速开发迭代 原生性能：通过 Skia 渲染引擎实现接近原生体验 共享逻辑：业务逻辑、网络请求、状态管理可 100% 复用 项目架构与技术栈blog_kmp 采用分层架构设计，核心模块包括： shared/├── src/commonMain/kotlin/ # 共享业务逻辑│ ├── data/ # 数据层│ ├── domain/ # 领域模型│ └── presentation/ # UI状态管理├── src/androidMain/ # Android 平台代码└── src/iosMain/ # iOS 平台适配├── composeApp│ ├── build.gradle.kts│ └── src│ ├── androidMain # Android 平台代码│ ├── commonMain # 共享业务逻辑│ ├── App.kt # 界面展示入口│ ├── data # 数据层│ │ ├── api # 网络请求│ │ ├── di # koin 依赖注入│ │ ├── model # model 数据│ │ └── repository # 数据缓存管理│ ││ ├── navigation # 页面间导航管理│ ├── platform # 通过对各个平台抽象的接口 │ └── ui # 通用 UI 逻辑││ ├── desktopMain # Desktop 平台适配│ └── iosMain # iOS 平台适配 功能预览Android 深色模式 iOS Desktop 主要技术栈 Ktor 客户端 - 网络请求 val httpClient = HttpClient &#123; install(ContentNegotiation) &#123; json(Json &#123; ignoreUnknownKeys = true &#125;) &#125;&#125;suspend fun loadPosts(): List&lt;Post&gt; = httpClient.get(&quot;https://cdn.julis/api/posts&quot;).body() DataStore - 跨平台数据库 val dataKey = stringPreferencesKey(key)val result = dataStore.data .catch &#123; exception -&gt; // dataStore.data throws an IOException when an error is encountered when reading data if (exception is IOException) &#123; emit(emptyPreferences()) &#125; else &#123; throw exception &#125; &#125; .map &#123; preferences -&gt; val data: String? = preferences[dataKey] if (data == null) &#123; null &#125; else &#123; if (isJson) Json.decodeFromString&lt;T&gt;(data) else (data as T) &#125; &#125; Koin - 依赖注入 val sharedModule = module &#123; single&lt;PostRepository&gt; &#123; PostRepositoryImpl(get()) &#125; viewModel &#123; PostViewModel(get()) &#125;&#125; Kotlinx.Serialization - JSON 解析 @Serializabledata class Post( val id: String, val title: String, val content: String) compose-webview-multiplatform - WebView 浏览器使用的第三方开发compose-webview-multiplatform基于 java-cef开发，不过这个library 在 desktop 平台表现不是太好，待完善。 val state = rememberWebViewState(postUrl) WebView(state = state,modifier = Modifier.fillMaxSize()) 平台特定实现UI 层面三端能够使用同一份代码，但为了体验，可能需要针对不同的设计，在桌面端可以设计更好地体验UI。这里避免不了 if-else 的UI逻辑，以及一些依赖各种系统的 api 需要单独实现，比如：深色模式监听、资源存储路径、系统信息、状态栏颜色等。 Android 端Android 特定的功能结合使用起来非常的简单，毕竟都是有血缘关系的。可以使用 AndroidView 直接渲染原生的 UI 页面。 AndroidView( modifier = Modifier.fillMaxSize(), factory = &#123; context -&gt; MyView(context) &#125; &#125;, update = &#123; view -&gt;&#125; ) iOS 端iOS端主要需要 XCode 进行配合，还需要关注开发者账号相关的信息等，其他与 Android 端实现没有太大的差异。 桌面端利用 Compose Desktop 的窗口管理，可以实现窗口多开。fun main() = application &#123; Window(onCloseRequest = ::exitApplication) &#123; DesktopAppTheme &#123; AppContent() &#125; &#125;&#125; 🚀 性能优化实践 分页加载：实现懒加载防止长列表卡顿 LazyColumn &#123; itemsIndexed(posts) &#123; _, post -&gt; PostItem(post) &#125; item &#123; if (loading) LoadingIndicator() &#125;&#125; 本地缓存：DataStore 离线存储 + Ktor 缓存策略 HttpClient &#123; install(HttpCache) // 启用 HTTP 缓存&#125; 图像处理：搭配 Coil 实现高效图片加载 AsyncImage( modifier = Modifier.size(80.dp) .shadow( elevation = 5.dp, shape = CircleShape, spotColor = Color.Black ) .clip(CircleShape) .clickable &#123; &#125;, model = AppConfig.AVATAR, contentDescription = AppConfig.AVATAR,) 开发经验总结 UI界面使用 Compose 进行界面布局开发，声明性编程范式相比于传统的 xml 布局开发，高效很多，使用也很方便。使用了这种方式，传统的 UI 开发方式再也回不去了。 状态管理使用 mutableStateOf 实现响应式更新，或者使用 derivedStateOf 实现派生状态的处理。 var pagIndex by remember &#123; mutableStateOf(0) &#125;var errorState by remember &#123; mutableStateOf&lt;String?&gt;(null) &#125; val themeState by mineViewModel.appTheme.collectAsState()val uiChecked by remember(themeState) &#123; derivedStateOf &#123; themeState == ThemeConstants.DARK &#125; &#125; 导航 实现 Compose Navigator 统一路由管理val gotoDebug: () -&gt; Unit = &#123; navController.navigate(Routes.Debug())&#125;val goToPostDetail: (Post) -&gt; Unit = &#123; it -&gt; navController.navigate(Routes.PostDetail(title = it.title, it.url))&#125; Kotlin Flow简化异步编程，让网络请求的代码看起来更直观fun loadAllPost(): Flow&lt;List&lt;PostV2&gt;&gt; = load(&quot;allPosts&quot;) &#123; postApi.getAllPost()?.data ?: emptyList()&#125;suspend fun getAllPost(): SearchResponse? = request&lt;SearchResponse&gt;(getUrl(&quot;api/search.json&quot;))private suspend inline fun &lt;reified T&gt; request(url: String): T? &#123; return try &#123; client.get(url).body() &#125; catch (e: Exception) &#123; if (e is CancellationException) throw e e.printStackTrace() null &#125;&#125; 总结经过一番各种折腾，将很多在工作上无法使用的能力（Koin、Flow、DataStore……）都体验使用了一下，在业余的时间完成了基于博客文章构建的 App 在三个平台上的开发，实际上最初我也想搭建 WebJs 的平台的，后面删除掉了，因为涉及到 web 平台开发的各种库相比客户端少很多，兼容起来也比较费劲。KMP/CMP 这块技术确实是能很大地节省开发人力，多端使用同一份UI逻辑代码，部分逻辑也可以用 kotlin 统一进行封装，后续维护也会方便很多。但这里有个缺点就是涉及到的库所需要的 kotlin/Java 版本要求比较高，除非开发一些独立的 App，否则公司里的项目想基于这些技术去实现不太大可能。以及如果所需要的能力比较依赖与原生，比如音视频领域就有一定的局限性，总体来讲更适合偏交互业务的开发。 项目源码: https://github.com/VomPom/blog_kmp","categories":[{"name":"技术文章","slug":"technology","permalink":"http://vompom.github.com/categories/technology/"}],"tags":[{"name":"KMP","slug":"KMP","permalink":"http://vompom.github.com/tags/KMP/"}],"author":"落叶挽歌"},{"title":"[鸿蒙]写了个基于Hexo博客的鸿蒙App","slug":"鸿蒙-写了个基于Hexo博客的鸿蒙App","date":"2025-05-16T12:10:00.000Z","updated":"2026-02-09T10:49:11.605Z","comments":true,"path":"2025/05/16/鸿蒙-写了个基于Hexo博客的鸿蒙App/","permalink":"http://vompom.github.com/2025/05/16/%E9%B8%BF%E8%92%99-%E5%86%99%E4%BA%86%E4%B8%AA%E5%9F%BA%E4%BA%8EHexo%E5%8D%9A%E5%AE%A2%E7%9A%84%E9%B8%BF%E8%92%99App/","excerpt":"","text":"最近部门也在跟进鸿蒙平台的业务开发，自己主要是做 Android 开发，主要使用 Kotlin/Java 语言。，需要对新的开发平台和开发模式进行学习，在业余时间开了个项目练手，做了个基于 Hexo 博客内容开发的App。鸿蒙主要使用ArkTS语言和ArkUI框架进行开发，有使用 Jetpack Compose 和 JavaScript/TypeScript 的开发经验的话，上手会比较的轻松。本文主要介绍做的App功能以及对鸿蒙开发的一个总结。 App 简介后台数据来自 Hexo 生成的博客文章，利用 hexo-generator-wxapi 生成 api .json 文件，再利用 七牛云 提供对图片和 .json 文件 CDN。 实现的功能 博客列表分页加载 文章详情加载 文章按分类/标签展示 文章内容统计 深色/浅色模式切换 数据本地缓存 功能预览 依赖项Hexo Hexo 快速、简洁且高效的博客框架 hexo-generator-wxapi 用于将 Hexo 博客内容生成 api 风格的.json文件 七牛云 提供对图片和.json文件 CDN加速 HarmonyOS ArkTS ArkTS在TypeScript（简称TS）生态基础上做了进一步扩展，保持了TS的基本风格，同时通过规范定义强化开发期静态检查和分析，提升代码健壮性，并实现更好的程序执行稳定性和性能。 ArkUI ArkUI（方舟UI框架）为应用的UI开发提供了完整的基础设施，包括简洁的UI语法、丰富的UI功能（组件、布局、动画以及交互事件），以及实时界面预览工具等，可以支持开发者进行可视化界面开发。 ohos_pull_to_refresh 列表加载/刷新控件(没有’No more’的状态) MMKV 是基于 mmap 内存映射的 key-value 组件 鸿蒙开发总结ArkTs 语言ArkTS 是 TypeScript 的超集，TypeScript 又是 JavaScript 的超集，所以对于基本数据类型使用的是 TypeScript 语法。他们三者的关系如下图所示： 相关的差异可以参考社区话题讨论 ArkTS与Typescript的区别？ 这里主要记录一下自己使用过程中踩过的坑： 基本语言类型Number 和 number 是两个不同的类型，Number 是 JavaScript 中的一个全局对象，可以使用 new Number() 来创建一个 Number 对象。同理对于 String 和 string，Boolean 和 boolean 也是一样的，大写开头的是包装对象类型，小写的是原始类型，这点Java/kotlin也有类似的包装对象比较好理解，但 Object 居然也有大小写之区分相比难理解点，写代码的时候好几次忽略了这个事，Object 是所有对象的基类，object 表示非原始类型（即不是 number、string、boolean、symbol、null 或 undefined 的所有类型）。可以是任何对象、数组、函数、类实例等。let obj: object;obj = &#123; a: 1 &#125;; // ✅ 正确：普通对象obj = [1, 2, 3]; // ✅ 正确：数组obj = () =&gt; &#123;&#125;; // ✅ 正确：函数obj = new Date(); // ✅ 正确：类实例obj = 42; // ❌ 错误：原始类型 numberobj = &quot;hello&quot;; // ❌ 错误：原始类型 string 特性 ArkTS JavaScript 允许的值 仅非原始类型（对象、数组等） 任意类型（包括原始值） 原始值处理 禁止使用原始值 自动装箱（如 42 → Number） 使用场景 明确限制为非原始类型时 极少使用（通常用 unknown 或具体类型替代） Map 等集合类当作普通 JavaScript 对象来操作let map = new Map&lt;string, object&gt;();map[&quot;key&quot;] = value; // ❌ 错误用法！console.log(map.get(&quot;biz&quot;)); // ❌ 输出 undefined 最开始挺奇怪的 map 明明设置了值，但是对应的 map size 为0，遍历 map 也没有数据。后来才发现是这种方式 不会 触发 Map 的内部机制，而是绕过了 Map 的方法，直接操作对象的属性，赋值后，键值对 不会 被存入 Map 的真实存储中，而是作为对象的普通属性存在。正确的用法是： let map = new Map&lt;string, object&gt;();map.set[&quot;key&quot;] = value; // ✅ 正确用法！console.log(map.get(&quot;biz&quot;)); // ✅ 输出 value struct 的困扰在 js 里面是没有 struct 这个关键词的，从刚接触到现在它唯一的作用就是：和 @Component绑定声明一个UI控件。例如： @Componentexport struct ToolBar&#123;&#125; @Component 和 struct 两则缺一不可，既然必须有 @Component来标注这是一个UI控件，为什么不能下面这样呢？能省掉一个关键字。@Componentexport class ToolBar &#123;&#125;同样困扰的人还有很多，这里有一份讨论定义组件时的stuct关键字是什么？官方也有一份聊胜于无的介绍 struct和class的区别是什么? struct只在自定义组件中使用，@Component装饰的struct就是自定义组件，自定义组件和class是两个概念，自定义组件没有类型，也不能等同于class。如果开发者需要使用组件作为参数在组件之间传递，可以使用自定义占位节点。 我猜测这样是为了省掉对@Component装饰器编译的工作量，如果使用 class 声明，那么声明的UI控件就有“面向对象”的能力，实际上只希望它是一个UI控件声明，不需要它有其他的能力。难道不能对 @Component 装饰过的对象收回“面向对象”的能力么？当然能啊，估计要做很多编译检查的事儿。另外，从开发理解的层面上来讲，它确实也已经不是”对象”了，它只是一个干巴巴的一个UI结构，所以干脆就搞了一个新的关键词 struct。 ArkUI 框架整体框架使用的方式和 Jetpack Compose 类似，都是声明式UI框架。compose 里面使用 @Composable来标记某个方法这个方法便成了UI控件，控件里面的状态管理使用 remember+ mutableState来控制。而 ArkUI 通过 @State、@Link、@Prop 等装饰器来控制。了解了这些个装饰器的用法，基本上就能理解 ArkUI 的开发流程了。 构建 UI 的 @Component @Builder@Component 和 @Builder 组合起来实现的差不多就是 Compose 里面使用 @Composable 装饰某个方法的作用，用于构建 UI 或可复用的逻辑单元。@Component用于创建一个自定义组件，组件可以包含独立的 UI 结构、状态管理和生命周期。 @Builder定义可复用的 UI 片段，用于创建一个UI 构建函数，封装一段可复用的 UI 代码块。不是独立组件，而是嵌入到其他组件或布局中执行，主要作用是复用和逻辑隔离，例如：关于页面，里面的文本是差不多的样式，只是内容不一样，那么只需要保留一个 text 属性出来接收参数。或者某块UI比较复杂，可以抽离一部分UI成为一个独立的UI逻辑模块。 构建 UI 的状态控制装饰器@State比较常用的装饰器，和 Compose 里面 remember+mutableStateOf 的作用差不多，对应的值改变之后，对相关的使用到该属性UI的地方进行刷新。 @Prop@Prop 装饰的变量和父组件建立单向的同步关系，@Prop变量允许在本地修改，但修改后的变化不会同步回父组件。 也就是在某个 @Component 的组件内有一个 @State 装饰的属性，传递到子 @Component 组件 @Prop 修饰的属性。子控件对这个属性修改之后，父控件不会对这个改变感知，父控件UI不会改变。 @Link子组件中被@Link装饰的变量与其父组件中对应的数据源建立双向数据绑定。跟 @Prop 的作用类似，不过是双向的，子控件对这个属性修改之后，父控件会感知这个变化，父控件UI会随着这个属性改变而改变。 @BuilderParam主要用于动态注入 UI 构建逻辑（即 @Builder 函数），实现父组件向子组件传递可定制的 UI 片段，也就是向子控件传递 UI 参数。 基本上比较常用到的就这些，还有很多例如：@LocalBuilder @StorageLink @Styles等，都是为了解决开发过过程中遇到的问题，但是只要掌握了 ArkUI UI组件的声明周期和状态管理的基本原理理解其他装饰器还是比较简单的。 总结总体开发体验下来，鸿蒙开发学习成本并不是特别高，比较快能上手，但设计的 api 更像一个缝合怪，且使用上不太收敛。很多库还需要再建设，例如音视频开发对应的支持库还不是特别成熟。不过，作为一个从头搞的生态来说能实现成这样已经很不错了，就像此前武磊登陆西甲，以及目前被看好的青年新星王钰栋，都是”自己的孩子”，需要迈出第一步。现在，很多公司也在适配鸿蒙了，期待未来能从 Android 跟 iOS 的生态中争夺出一片大市场。 项目源码：https://github.com/VomPom/blog_harmony","categories":[{"name":"技术文章","slug":"technology","permalink":"http://vompom.github.com/categories/technology/"}],"tags":[{"name":"鸿蒙","slug":"鸿蒙","permalink":"http://vompom.github.com/tags/%E9%B8%BF%E8%92%99/"}],"author":"落叶挽歌"},{"title":"KV-存储之mmkv","slug":"KV-存储之mmkv","date":"2025-03-30T03:38:00.000Z","updated":"2025-05-20T11:46:57.000Z","comments":true,"path":"2025/03/30/KV-存储之mmkv/","permalink":"http://vompom.github.com/2025/03/30/KV-%E5%AD%98%E5%82%A8%E4%B9%8Bmmkv/","excerpt":"","text":"在平时的业务中，需要用到轻量级存储业务中的数据（例如设置数据存储），绝大多数时候 Anroid 管法提供的 SharedPreferences 组件就能实现，但针对一些需要高效的场景它就不那么使用了，不适合存储大量数据、多线程操作的不安全性、数据明文不安全性，以及不支持多进程之间的调用等各种问题。MMKV的诞生就是为了解决以上的问题，本文主要对 MMKV 源码的学习知识点进行一些总结。 核心设计与原理在官方的开源工程中可以看到如下的一些介绍 MMKV 是基于 mmap 内存映射的 key-value 组件，底层序列化/反序列化使用 protobuf 实现，性能高，稳定性强。从 2015 年中至今在微信上使用，其性能和稳定性经过了时间的验证。 传统I/O与 mmapmmap 这个是 mmkv 实现的核心，没有 mmap 那么就没有 mmkv。对于 SharedPreferences的实现来说，每次的数据更新都将操作本地文件，而本地文件的写入是通过传统的I/O实现。要理解两者的实现差异，需要先理解 Linux 用户空间与内核空间设计。 用户空间与内核空间Linux的进程是相互独立的，一个进程是不能直接操作或者访问别一个进程空间的。每个进程空间还分为用户空间和内核（Kernel）空间，相当于把Kernel和上层的应用程序抽像的隔离开。 用户空间和内核空间，用户空间是用户程序代码运行的地方，内核空间是内核代码运行的地方。为了安全，它们是隔离的，即使用户的程序崩溃了，内核也不受影响。 这里有两个隔离，一个进程间是相互隔离的，二是进程内有用户空间和内核空间的隔离。 进程间，用户空间的数据不可共享，所以用户空间 = 不可共享空间进程间，内核空间的数据可共享，所以内核空间 = 可共享空间，所以Linux系统的内存通常是MemFree+Cache所有进程共用1个内核空间。 传统I/O读写流程常规文件读写操作（调用read/fread等函数）过程如下： 进程发起读写文件请求。 内核通过查找进程文件符表，定位到内核已打开文件集上的文件信息，从而找到此文件的inode。 inode 在 address_space 上查找要请求的文件页是否已经缓存在页缓存中。如果存在，则直接返回这片文件页的内容。 如果不存在，则通过 inode 定位到文件磁盘地址，将数据从磁盘复制到页缓存。之后再次发起读页面过程，进而将页缓存中的数据发给用户进程。 什么是 inode ? 全称为 index node，既存储文件元信息的区域，中文译名“索引节点”。包含：文件权限、文件拥有者的UID、文件的大小等等。 总结来说，常规文件操作为了提高读写效率和保护磁盘，使用了页缓存机制。这样造成读文件时需要先将文件页从磁盘拷贝到页缓存中，由于页缓存处在内核空间，不能被用户进程直接寻址访问，所以还需要将页缓存中的数据页再次拷贝到用户空间中。这样，通过了两次数据拷贝过程，才能完成进程对文件内容的访问。 mmap基本概念和原理内存映射（mmap），就是将文件的磁盘扇区映射到进程的虚拟内存空间的过程，即将一个文件映射到进程的虚拟空间，实现文件磁盘地址和进程虚拟空间中一段虚拟地址的一一对应关系。实现这样的映射关系后，进程就可以采用指针的方式读写操作这一段内存，而系统会自动回写脏页面到对应的文件磁盘上，即完成了对文件的操作而不必再调用read,write等系统调用函数。 由上图可知，进程的虚拟地址空间，由多个虚拟内存区域构成。每个虚拟内存区域都是进程在虚拟地址空间中的一个同质区间，即具有同样特性的连续地址范围。上图中所示的text数据段（代码段）、初始数据段、BSS数据段、堆、栈和内存映射，都是一个独立的虚拟内存区域。内存映射的地址空间处在堆栈之间的空余部分。 linux内核使用 vm_area_struct 结构来表示一个独立的虚拟内存区域，由于每个不同质的虚拟内存区域功能和内部机制都不同，因此一个进程使用多个 vm_area_struct 结构来分别表示不同类型的虚拟内存区域。各个 vm_area_struct 结构使用链表或者树形结构链接，方便进程快速访问，如下图所示： vm_area_struct 结构中包含区域起始和终止地址以及其他相关信息。这样，进程对某一虚拟内存区域的任何操作需要用要的信息，都可以从 vm_area_struct 中获得。mmap函数就是要创建一个新的 vm_area_struct 结构，并将其与文件的物理磁盘地址相连。 mmap内存映射的实现过程，总的来说可以分为三个阶段： 阶段一：进程启动映射过程，并在虚拟地址空间中为映射创建虚拟映射区域 进程在用户空间调用mmap库函数 void *mmap(void *addr, size_t length, int prot, int flags, int fd, off_t offset); addr：指定映射的虚拟内存地址，可以设置为 NULL，让内核自动选择合适的虚拟内存地址 length：映射的长度。 prot：映射内存的保护模式，可选值如下： flags：指定映射的类型 fd：进行映射的文件句柄。 offset：文件偏移量（从文件的何处开始映射） 在当前进程的虚拟地址空间中，寻找一段空闲的满足要求的连续的虚拟地址 为此虚拟区分配一个 vm_area_struct 结构，接着对这个结构的各个域进行了初始化 将新创建的虚拟区结构 vm_area_struct 对象插入到进程的虚拟地址区域链表/树中 阶段二：调用内核空间的mmap函数（不同于用户空间函数），实现文件物理地址和进程虚拟地址的一一映射关系 为映射分配了新的虚拟地址区域后，通过待映射的文件指针，在文件描述符表中找到对应的文件描述符，通过文件描述符，链接到内核“已打开文件集”中该文件的文件结构体（struct file），每个文件结构体维护着和这个已打开文件相关各项信息。 为映射分配了新的虚拟地址区域后，通过待映射的文件指针，在文件描述符表中找到对应的文件描述符，通过文件描述符，链接到内核“已打开文件集”中该文件的文件结构体（struct file），每个文件结构体维护着和这个已打开文件相关各项信息。 通过该文件的文件结构体，链接到 file_operations 模块，调用内核mmap函数，其原型为： int mmap(struct file *filp, struct vm_area_struct *vma) //不同于用户空间mmap库函数 内核mmap函数通过虚拟文件系统inode模块定位到文件磁盘物理地址。 通过 remap_pfn_range 函数建立页表，即实现了文件地址和虚拟地址区域的映射关系。此时，这片虚拟地址并没有任何数据关联到物理内存(主存)中。 主存 主存储器（Main memory），简称主存。是计算机硬件的一个重要部件，其作用是存放指令和数据，并能由中央处理器（CPU）直接随机存取 阶段三：进程发起对这片映射地址空间的访问，引发缺页异常，实现文件内容到主存（物理内存）的拷贝 前两个阶段仅在于创建虚拟区间并完成地址映射，但是并没有将任何文件数据的拷贝至主存。真正的文件读取是当进程发起读或写操作时 进程的读或写操作访问虚拟地址空间这一段映射地址，通过查询页表，发现这一段地址并不在物理页上。因为目前只建立了地址映射，真正的硬盘数据还没有拷贝到内存中，因此引发缺页异常。 缺页异常进行一系列判断，确定无非法操作后，内核发起请求调页过程。 调页过程先在交换缓存空间（swap cache）中寻找需要访问的内存页，如果没有则调用nopage函数把所缺的页从磁盘装入到主存中。 之后进程即可对这片主存进行读或者写的操作，如果写操作改变了其内容，一定时间后系统会自动回写脏页面到对应磁盘地址，也即完成了写入到文件的过程。 修改过的脏页面并不会立即更新回文件中，而是有一段时间的延迟，可以调用msync()来强制同步, 这样所写的内容就能立即保存到文件里了 常规文件操作需要从磁盘到内核空间页缓存再到用户空间主存的两次数据拷贝。而mmap文件映射，只需要从磁盘到用户空间主存的一次数据拷贝过程。mmap的关键点是实现了用户空间和内核空间的数据直接交互而省去了空间不同数据不通的繁琐过程，因此 mmap 效率更高。 以上是 mmap 的基本概念和原理，搞明白了这些才能看明白整个 mmkv 里面的逻辑处理 mmkv 一次 put 的流程mmkv初始化比较简单，主要涉及到一些配置的初始化，文件夹创建等，其中最重要的逻辑 mmap 调用被封装到一个 MemoryFile到对象里面 bool MemoryFile::mmap() &#123; auto oldPtr = m_ptr; auto mode = m_readOnly ? PROT_READ : (PROT_READ | PROT_WRITE); m_ptr = (char *) ::mmap(m_ptr, m_size, mode, MAP_SHARED, m_diskFile.m_fd, 0); ... return true;&#125; 主要记录一下一次 put 任务的流程，以 mmkv.putInt(&quot;int&quot;, 1)为例，进过 JNI 的调用到了 native-birdge.cpp MMKV_JNI jboolean encodeInt(JNIEnv *env, jobject obj, jlong handle, jstring oKey, jint value) &#123; MMKV *kv = reinterpret_cast&lt;MMKV *&gt;(handle); if (kv &amp;&amp; oKey) &#123; string key = jstring2string(env, oKey); return (jboolean) kv-&gt;set((int32_t) value, key); &#125; return (jboolean) false;&#125; 进入了MMVK.cpp的 bool MMKV::set(int32_t value, MMKVKey_t key, uint32_t expireDuration) &#123; if (isKeyEmpty(key)) &#123; return false; &#125; size_t size = mmkv_unlikely(m_enableKeyExpire) ? Fixed32Size + pbInt32Size(value) : pbInt32Size(value); MMBuffer data(size); CodedOutputData output(data.getPtr(), size); output.writeInt32(value); // ... 省略一些校验逻辑 return setDataForKey(std::move(data), key);&#125; 这一步主要是准备一下数据，并使用 MMBuffer CodedOutputData将写入的数据进行一次包装（不仅仅是 key-value，还有数据size等等），实际调用在setDataForKey bool MMKV::setDataForKey(MMBuffer &amp;&amp;data, MMKVKey_t key, bool isDataHolder) &#123; checkLoadData(); // 状态同步相关的逻辑 if (m_crypter) &#123; // ... 省略加密的处理逻辑 &#125; else &#123; auto itr = m_dic-&gt;find(key); if (itr != m_dic-&gt;end()) &#123; // compare data before appending to file if (isCompareBeforeSetEnabled()) &#123; auto basePtr = (uint8_t *) (m_file-&gt;getMemory()) + Fixed32Size; MMBuffer oldValueData = itr-&gt;second.toMMBuffer(basePtr); if (isDataHolder) &#123; CodedInputData inputData(oldValueData.getPtr(), oldValueData.length()); try &#123; // read extra holder header bytes and to real MMBuffer oldValueData = CodedInputData::readRealData(oldValueData); if (oldValueData == data) &#123; // MMKVInfo(&quot;[key] %s, set the same data&quot;, key.c_str()); return true; &#125; &#125; catch (std::exception &amp;exception) &#123; MMKVWarning(&quot;compareBeforeSet exception: %s&quot;, exception.what()); &#125; catch (...) &#123; MMKVWarning(&quot;compareBeforeSet fail&quot;); &#125; &#125; else &#123; ... &#125; &#125; bool onlyOneKey = !isMultiProcess() &amp;&amp; m_dic-&gt;size() == 1; if (mmkv_likely(!m_enableKeyExpire)) &#123; ... &#125; else &#123; KVHolderRet_t ret; if (onlyOneKey) &#123; ret = overrideDataWithKey(data, key, isDataHolder); &#125; else &#123; ret = appendDataWithKey(data, key, isDataHolder); &#125; if (!ret.first) &#123; return false; &#125; itr = m_dic-&gt;find(key); if (itr != m_dic-&gt;end()) &#123; itr-&gt;second = std::move(ret.second); &#125; else &#123; // in case filterExpiredKeys() is triggered m_dic-&gt;emplace(key, std::move(ret.second)); mmkv_retain_key(key); &#125; &#125; &#125; else &#123; ... &#125; &#125; m_hasFullWriteback = false; return true;&#125; 这里面的代码逻辑很长，做了很多 if-else 的逻辑，最终走向两个大分支： key 是新增的走 appendDataWithKey key 将会覆盖原来的将会走 overrideDataWithKey 有这两个分支，主要是因为 mmkv 存储采用的 protobuf 协议，另外有一个很重要的方法也在这里执行了：checkLoadData(); 安卓里面的多进程实现，将需要这里的一些逻辑，在 mmkv多进程原理篇进行讲解。 appendDataWithKey 转换为 MMBuffer并继续向下执行 KVHolderRet_t MMKV::appendDataWithKey(const MMBuffer &amp;data, MMKVKey_t key, bool isDataHolder) &#123; auto keyData = MMBuffer((void *) key.data(), key.size(), MMBufferNoCopy); return doAppendDataWithKey(data, keyData, isDataHolder, static_cast&lt;uint32_t&gt;(keyData.length()));&#125; doAppendDataWithKey 里面的代码也很长，不过也就只做一件事：将k-v值写入到文件里面做准备，真正的写入逻辑在 m_output-&gt;writeData(keyData);，这里先后调用了两次 writeData,是先写入key再写入了 value。 KVHolderRet_tMMKV::doAppendDataWithKey(const MMBuffer &amp;data, const MMBuffer &amp;keyData, bool isDataHolder, uint32_t originKeyLength) &#123; auto isKeyEncoded = (originKeyLength &lt; keyData.length()); auto keyLength = static_cast&lt;uint32_t&gt;(keyData.length()); auto valueLength = static_cast&lt;uint32_t&gt;(data.length()); if (isDataHolder) &#123; valueLength += pbRawVarint32Size(valueLength); &#125; // size needed to encode the key size_t size = isKeyEncoded ? keyLength : (keyLength + pbRawVarint32Size(keyLength)); // size needed to encode the value size += valueLength + pbRawVarint32Size(valueLength); SCOPED_LOCK(m_exclusiveProcessLock); bool hasEnoughSize = ensureMemorySize(size); if (!hasEnoughSize || !isFileValid()) &#123; return make_pair(false, KeyValueHolder()); &#125; ... try &#123; if (isKeyEncoded) &#123; m_output-&gt;writeRawData(keyData); &#125; else &#123; m_output-&gt;writeData(keyData); &#125; if (isDataHolder) &#123; m_output-&gt;writeRawVarint32((int32_t) valueLength); &#125; m_output-&gt;writeData(data); // note: write size of data &#125; ... m_actualSize += size; updateCRCDigest(ptr, size); return make_pair(true, KeyValueHolder(originKeyLength, valueLength, offset));&#125; writeData 进行了两步先写入数据的 长度信息，再写入真实的数据，这里还是因为 protobuf 协议设计相关 void CodedOutputData::writeData(const MMBuffer &amp;value) &#123; this-&gt;writeRawVarint32((int32_t) value.length()); this-&gt;writeRawData(value);&#125; 最终走到了writeRawData 关键代码 void CodedOutputData::writeRawData(const MMBuffer &amp;data) &#123; size_t numberOfBytes = data.length(); if (m_position + numberOfBytes &gt; m_size) &#123; ... &#125; memcpy(m_ptr + m_position, data.getPtr(), numberOfBytes); m_position += numberOfBytes;&#125; 核心逻辑使用 memcpy 将数据直接通过 memcpy 直接在内存层面进行拷贝，而这里的 m_ptr就是最开始通过mmap创建出来的指针！！到这里一次写入基本上就结束了。 mmkv 一次 get 的流程依然先通过 JNI走到 MMKV_JNI jint decodeInt(JNIEnv *env, jobject obj, jlong handle, jstring oKey, jint defaultValue) &#123; MMKV *kv = reinterpret_cast&lt;MMKV *&gt;(handle); if (kv &amp;&amp; oKey) &#123; string key = jstring2string(env, oKey); return (jint) kv-&gt;getInt32(key, defaultValue); &#125; return defaultValue;&#125; 再到 mmkv getInt32 int32_t MMKV::getInt32(MMKVKey_t key, int32_t defaultValue, bool *hasValue) &#123; ... SCOPED_LOCK(m_lock); SCOPED_LOCK(m_sharedProcessLock); auto data = getDataForKey(key); if (data.length() &gt; 0) &#123; try &#123; CodedInputData input(data.getPtr(), data.length()); if (hasValue != nullptr) &#123; *hasValue = true; &#125; return input.readInt32(); &#125; ... return defaultValue;&#125; getRawDataForKey方法，主要有两个分支，一种是加密逻辑，另一种是非加密逻辑，但他们流程都差不多从一个 map 里面根据 key 获取一个对象（这个对象暂时并不是 get 最终的返回值），那这个 map 是从哪里来的呢？ MMBuffer MMKV::getRawDataForKey(MMKVKey_t key) &#123; checkLoadData();#ifndef MMKV_DISABLE_CRYPT if (m_crypter) &#123; auto itr = m_dicCrypt-&gt;find(key); if (itr != m_dicCrypt-&gt;end()) &#123; auto basePtr = (uint8_t *) (m_file-&gt;getMemory()) + Fixed32Size; return itr-&gt;second.toMMBuffer(basePtr, m_crypter); &#125; &#125; else#endif &#123; auto itr = m_dic-&gt;find(key); if (itr != m_dic-&gt;end()) &#123; auto basePtr = (uint8_t *) (m_file-&gt;getMemory()) + Fixed32Size; return itr-&gt;second.toMMBuffer(basePtr); &#125; &#125; MMBuffer nan; return nan;&#125; 从源码里面溯源m_dicCrypt和 m_dic 是在 MMKV 初始化的时候生成的，主要逻辑在 MMKV_IO .cpp里面的 loadFromFile方法内： void MMKV::loadFromFile() &#123; loadMetaInfoAndCheck(); ... if (!m_file-&gt;isFileValid()) &#123; m_file-&gt;reloadFromFile(m_expectedCapacity); &#125; if (!m_file-&gt;isFileValid()) &#123; MMKVError(&quot;file [%s] not valid&quot;, m_path.c_str()); &#125; else &#123; bool loadFromFile = false, needFullWriteback = false; checkDataValid(loadFromFile, needFullWriteback); ... auto ptr = (uint8_t *) m_file-&gt;getMemory(); // loading if (loadFromFile &amp;&amp; m_actualSize &gt; 0) &#123; ... MMBuffer inputBuffer(ptr + Fixed32Size, m_actualSize, MMBufferNoCopy); if (m_crypter) &#123; clearDictionary(m_dicCrypt); &#125; else &#123; clearDictionary(m_dic); &#125; if (needFullWriteback) &#123;#ifndef MMKV_DISABLE_CRYPT if (m_crypter) &#123; MiniPBCoder::greedyDecodeMap(*m_dicCrypt, inputBuffer, m_crypter); &#125; else#endif &#123; MiniPBCoder::greedyDecodeMap(*m_dic, inputBuffer); &#125; &#125; else &#123;#ifndef MMKV_DISABLE_CRYPT if (m_crypter) &#123; MiniPBCoder::decodeMap(*m_dicCrypt, inputBuffer, m_crypter); &#125; else#endif &#123; MiniPBCoder::decodeMap(*m_dic, inputBuffer); &#125; &#125; m_output = new CodedOutputData(ptr + Fixed32Size, m_file-&gt;getFileSize() - Fixed32Size); m_output-&gt;seek(m_actualSize); if (needFullWriteback) &#123; fullWriteback(); &#125; &#125; else &#123; // file not valid or empty, discard everything SCOPED_LOCK(m_exclusiveProcessLock); m_output = new CodedOutputData(ptr + Fixed32Size, m_file-&gt;getFileSize() - Fixed32Size); if (m_actualSize &gt; 0) &#123; writeActualSize(0, 0, nullptr, IncreaseSequence); sync(MMKV_SYNC); &#125; else &#123; writeActualSize(0, 0, nullptr, KeepSequence); &#125; &#125; ... &#125; m_needLoadFromFile = false;&#125; 总统来说就是在初始化的时候就会将基于protobuf协议的本地文件里面的数据加载到内存，并将其放在一个 map 内，方便后续使用。 回到 int32_t MMKV::getInt32()通过 getDataForKey(key)获取到一个MMBuffer对象，并通过 CodedInputData进行反序列化操作，读取 Varint32 的 valueSize 值，随后不断循环通过 CodedInputData 读取到value 值。 int32_t MMKV::getInt32(MMKVKey_t key, int32_t defaultValue, bool *hasValue) &#123; ... auto data = getDataForKey(key); if (data.length() &gt; 0) &#123; try &#123; CodedInputData input(data.getPtr(), data.length()); if (hasValue != nullptr) &#123; *hasValue = true; &#125; return input.readInt32(); &#125; ... &#125; ... return defaultValue;&#125; mmkv 与 SharedPreferences以下是 MMKV 与 SharedPreferences 的优劣势对比总结，结合性能、安全性、功能支持等核心维度进行分析： 性能对比 维度 SharedPreferences MMKV 读写速度 慢（同步 I/O，多次数据拷贝） 快（mmap 零拷贝，内存直接操作） 线程安全 需自行加锁（apply() 异步写入仍有风险） 内置多线程锁（文件锁 + 内存锁） 大数据量支持 性能急剧下降（全量 XML 解析/序列化） 高效（增量更新，Protobuf 编码） 安全性与稳定性 维度 SharedPreferences MMKV 数据加密 无（明文存储） 支持 AES-128/AES-256 加密 崩溃恢复 可能因异常导致 XML 损坏 通过 CRC 校验 + 备份文件保障完整性 系统版本适配 部分版本有 ANR 问题（如 apply()） 无系统级兼容性问题 功能支持 维度 SharedPreferences MMKV 多进程 不支持（跨进程数据不同步） 支持（通过文件锁 + mmap 共享内存） 数据类型 仅支持基本类型（int/String 等） 支持基本类型、二进制数据（MMBuffer） 加密存储 明文存储（XML） 支持 AES 加密（可选） 增量更新 全量写入（即使只改一个键值） 仅追加新数据，定期整理 从上面的对比看看，mmkv 在很多层面都是领先 SharedPreferences 的，那么 mmkv 是否有缺陷呢？答案是有的。 任何的操作系统、任何的软件，在往磁盘写数据的过程中如果发生了意外——例如程序崩溃，或者断电关机——磁盘里的文件就会以这种写了一半的、不完整的形式被保留。写了一半的数据怎么用啊？没法用，这就是文件的损坏。这种问题是不可能避免的，MMKV 虽然由于底层机制的原因，在程序崩溃的时候不会影响数据往磁盘的写入，但断电关机之类的操作系统级别的崩溃，MMKV 就没办法了，文件照样会损坏。对于这种文件损坏，SharedPreferences 和 DataStore 的应对方式是在每次写入新数据之前都对现有文件做一次自动备份，这样在发生了意外出现了文件损坏之后，它们就会把备份的数据恢复过来；而 MMKV，没有这种自动的备份和恢复，那么当文件发生了损坏，数据就丢了，之前保存的各种信息只能被重置。也就是说，MMKV 是唯一会丢数据的方案。 在 mmkv 里面有 CRC 校验，如果不通过的话，将会废弃掉之前所有的数据。在 mmkv 里面也有人反馈：https://github.com/Tencent/MMKV/issues/729 在写入的过程中因为一些特殊情况写入失败，会导致本地的文件损坏且不可recovery。 那有什么办法避免这个问题呢？有大佬开源另一个 KV 框架 FastKV对这个问题进行了处理，采用通过double-write等方法确保数据的完整性，原理是数据依次写入A/B两个文件，如果写入A过程中崩溃，B仍是完整的，如果A完整写入了，则B写入时崩溃也不要紧。这种实现方式理论上是不错的，不太清楚 mmkv 为什么没有采取这样的逻辑。不过这个库并没有经过大量业务进行验证，只能作为一个学习的方案先看看。 另外谷歌已经开发了新的KV存储框架DataStore，SharedPreferences也将渐渐地退出历史的舞台了。不过 DataStore 的性能目前仍然没有 mmkv 的好。关于这三者的比较可以查看： 《Android 的键值对存储有没有最优解？》 总结这篇文章深入剖析了 MMKV（腾讯开源的高性能键值存储组件）的核心设计与实现原理，重点对比了传统 I/O 与 mmap 内存映射的差异，并详细分析了 MMKV 的读写流程以及和 SharedPreferences 的各方面对比。 参考 《Android 的键值对存储有没有最优解？》 《mmap原理与应用》 《文件内存映射和传统I/O机制》 Android 内存映射mmap浅谈","categories":[],"tags":[{"name":"mmap","slug":"mmap","permalink":"http://vompom.github.com/tags/mmap/"}],"author":"落叶挽歌"},{"title":"RetroFit2 源码学习相关","slug":"Learn-from-RetroFit","date":"2025-03-17T12:28:00.000Z","updated":"2025-05-20T11:46:57.000Z","comments":true,"path":"2025/03/17/Learn-from-RetroFit/","permalink":"http://vompom.github.com/2025/03/17/Learn-from-RetroFit/","excerpt":"","text":"研究 retrofit 目标：理解动态代理、注解、反射、学习它所用到的设计模式，达到自己能手写它的核心实现。 最近终于有点精力能够去研究研究源码了， 真的是写的一个非常好的的开源库，以前刚接触安卓的时候扒拉过相关的源码，但是随着工作了几年之后，经验的积累，让我对源码里面的东西能够体会更深刻，自己也尝试去手写里面的核心实现，看完源码对整体的架构理解了之后，以为自己能很顺利的写下来，实则不然。知识还是需要知行合一，这篇文章主要记录 retrofit 的一些知识点。 retrofit 的设计模式retrofit 里面中使用了多种设计模式，以实现其灵活、可扩展和高性能的特性： 设计模式 应用场景 作用 建造者模式 Retrofit.Builder 灵活配置 Retrofit 实例 工厂模式 Converter.Factory、CallAdapter.Factory 创建 Converter 和 CallAdapter 实例 动态代理模式 接口方法转换为 HTTP 请求 运行时生成接口代理对象 适配器模式 CallAdapter 将 Call 适配为其他类型 装饰器模式 OkHttp 拦截器 增强 HTTP 请求和响应的功能 观察者模式 与 RxJava 或 LiveData 结合 实现异步数据流的订阅和通知 策略模式 Converter 和 CallAdapter 选择 动态选择数据转换或调用适配策略 单例模式 Retrofit 实例共享 确保全局只有一个 Retrofit 实例 模板方法模式 Call 的实现 定义 HTTP 请求的执行流程 retrofit 的动态代理模式 retrofit 用了诸多的设计模式，其中最经典的莫过于动态代理模式了，在了解 retrofit 之前，我一直以为这样的网络请求形式是最直观的，参考以前写的基于Volley框架的返回数据的范型处理 Request.get( url = url, params = param, listener = object : OnRequestListener&lt;Data&gt; &#123; override fun onSuccess(commonData: CommonData?, data: Data?) &#123;&#125; override fun onFailure(errorCode: Int, errorMessage: String?) &#123;&#125; &#125;) 以为这样很直观，逻辑也很清晰，实则 代码冗余，回调嵌套，如果有多个连续的请求，代码会变得难以维护，而 retrofit 搭配上协程能这样实现： val data = apiService.getXXX(params) 简单到不能再简单，动态代理功不可没，上面的 apiService 是一个接口，由：retrofit.create(ApiInterface::class.java) 生成其实例，动态代理其核心实现： public &lt;T&gt; T create(final Class&lt;T&gt; service) &#123; validateServiceInterface(service); return (T) Proxy.newProxyInstance( service.getClassLoader(), new Class&lt;?&gt;[] &#123;service&#125;, new InvocationHandler() &#123; private final Platform platform = Platform.get(); private final Object[] emptyArgs = new Object[0]; @Override public @Nullable Object invoke(Object proxy, Method method, @Nullable Object[] args) throws Throwable &#123; // .... return platform.isDefaultMethod(method) ? platform.invokeDefaultMethod(method, service, proxy, args) : loadServiceMethod(method).invoke(args); &#125; &#125;); &#125; 由loadServiceMethod(method).invoke(args) 负责将接口方法（通过 Java 反射获取的 Method 对象）解析并转换为一个可执行的 HTTP 请求。 Proxy.newProxyInstance 方法，参数： ClassLoader loader 用于加载代理类的类加载器。 Class&lt;?&gt;[] interfaces 代理类需要实现的接口数组，代理对象将实现这些接口，并拦截对这些接口方法的调用。只能代理实现了接口的类，不能代理没有接口的类。 InvocationHandler h调用处理器，负责处理代理对象上的方法调用。每次调用代理对象的方法时，都会调用 InvocationHandler 的 invoke 方法。对于 Retrofit 的接口我们并没有去“实现”它的方法，所有的逻辑都由` retrofit.create()方法里面返回的 InvocationHandler实现的 invoke方法实现的。 核心实现逻辑协程的支持Retrofit 支持多种异步编程模型，包括回调、RxJava 和协程等，这里主要记录一下对协程的支持。普通方法和异步逻辑的分叉在： if (!isKotlinSuspendFunction) &#123; return new CallAdapted&lt;&gt;(requestFactory, callFactory, responseConverter, callAdapter); &#125; else if (continuationWantsResponse) &#123; //noinspection unchecked Kotlin compiler guarantees ReturnT to be Object. return (HttpServiceMethod&lt;ResponseT, ReturnT&gt;) new SuspendForResponse&lt;&gt;( requestFactory, callFactory, responseConverter, (CallAdapter&lt;ResponseT, Call&lt;ResponseT&gt;&gt;) callAdapter); &#125; else &#123; //noinspection unchecked Kotlin compiler guarantees ReturnT to be Object. //... &#125; 上面代码关键变量isKotlinSuspendFunction ，用于判断是否为协程方法（suspend修饰），判断逻辑很简单，只需要判定方法最后一个参数是否为Continuation.class 即可。这里的分叉逻辑都继承自HttpServiceMethod&lt;T&gt;实现 ReturnT adapt(Call&lt;ResponseT&gt; call, Object[] args)这个抽象方法，这也是 retrofit 使用 适配器模式的地方，把不同的调用方式进行统一。对于协程方式的调用有实现： protected Object adapt(Call&lt;ResponseT&gt; call, Object[] args) &#123; call = callAdapter.adapt(call); //noinspection unchecked Checked by reflection inside RequestFactory. Continuation&lt;Response&lt;ResponseT&gt;&gt; continuation = (Continuation&lt;Response&lt;ResponseT&gt;&gt;) args[args.length - 1]; // See SuspendForBody for explanation about this try/catch. try &#123; return KotlinExtensions.awaitResponse(call, continuation); &#125; catch (Exception e) &#123; return.suspendAndThrow(e, continuation); &#125; &#125; suspend fun &lt;T&gt; Call&lt;T&gt;.awaitResponse(): Response&lt;T&gt; &#123; return suspendCancellableCoroutine &#123; continuation -&gt; continuation.invokeOnCancellation &#123; cancel() &#125; enqueue(object : Callback&lt;T&gt; &#123; override fun onResponse(call: Call&lt;T&gt;, response: Response&lt;T&gt;) &#123; continuation.resume(response) &#125; override fun onFailure(call: Call&lt;T&gt;, t: Throwable) &#123; continuation.resumeWithException(t) &#125; &#125;) &#125;&#125; 这里就一切都明朗了，实现了 Call的扩展方法，这里的 Call并不是 okhttp3.Call，它只是 retrofit okhttp3.Call为方便框架整体逻辑的处理而定义的，比如 retrofit 的 Call 是泛型化的，可以直接返回解析后的对象，enqueue同理。 suspendCancellableCoroutine方法是实现协程方法的关键，它可以将基于回调的异步操作封装成一个挂起函数，怎么理解呢？对 扩展方法awaitResponse反编译可以看到方法定义是这样的： public static final Object await(@NotNull Call $this$await, @NotNull Continuation $completion) 其实这里跟定义一个 listener去监听方法的回调有点像，这个方法改写成 listener的实现话大概就是这样： fun &lt;T&gt; Call&lt;T&gt;.awaitResponse(listener:Listener&lt;T&gt;): Response&lt;T&gt; &#123; enqueue(object : Callback&lt;T&gt; &#123; override fun onResponse(call: Call&lt;T&gt;, response: Response&lt;T&gt;) &#123; Listener.resume(response) &#125; override fun onFailure(call: Call&lt;T&gt;, t: Throwable) &#123; Listener.resumeWithException(t) &#125; &#125;) &#125;&#125; 可看到改造实现需要传递一个 listener，哪这个 listener是什么？前面其有如何判断一个方法是否为协程的方法的逻辑：判定方法最后一个参数是否为Continuation.class 即可。这里的 listener 其实可以等价于 一个 Continuation实例，kotlin 的协程库帮我们实现了对应的封装，对于使用我们不会直观地感受Continuation的存在，实际它贯穿整个协程。关于协程这里不再赘述，可以查看 《带着问题分析Kotlin协程原理》了解。 返回数据格式的解析对于Converter,在协程和普通方法调用分叉逻辑的前面点： Converter&lt;ResponseBody, ResponseT&gt; responseConverter = createResponseConverter(retrofit, method, responseType); createResponseConverter之后一路走到 public &lt;T&gt; Converter&lt;ResponseBody, T&gt; nextResponseBodyConverter( @Nullable Converter.Factory skipPast, Type type, Annotation[] annotations) &#123; Objects.requireNonNull(type, &quot;type == null&quot;); Objects.requireNonNull(annotations, &quot;annotations == null&quot;); int start = converterFactories.indexOf(skipPast) + 1; for (int i = start, count = converterFactories.size(); i &lt; count; i++) &#123; Converter&lt;ResponseBody, ?&gt; converter = converterFactories.get(i).responseBodyConverter(type, annotations, this); if (converter != null) &#123; //noinspection unchecked return (Converter&lt;ResponseBody, T&gt;) converter; &#125; &#125;&#125; converterFactories 的值就是在 retrofit 初始化的时候进行使用 public Builder addConverterFactory(Converter.Factory factory)添加的值。可以看到是按添加到List&lt;Converter.Factory&gt; converterFactories里面的顺序进行选择的，默认GsonConverterFactory实现了利用 Gson进行数据转化 ，如果我们自己实现Converter.Factory的接口的话，那么可以根据一定的规则判断是否要返回我们自定义的 Converter，如果不需要使用就返回 null，会自动匹配下一个能使用的 Converter。注意这里并不会因为前一个 Converter 解析失败而自动尝试使用下一个Converter（当然，你可以在自定义的Converter里面做类似这样的尝试策略）。 总结 这篇文章深入剖析了 Retrofit 框架的核心设计模式、动态代理机制、协程支持以及数据解析逻辑，通过源码分析和手写实现，帮助读者更好地理解 Retrofit 的工作原理，并强调了理论与实践结合的重要性。 为加深对 retrofit 的理解，可以尝试手写核心实现，自己尝试的的代码在 vmfit 附一张 retrofit 的全流程图，来源：https://cloud.tencent.com/developer/article/1683334","categories":[{"name":"技术文章","slug":"technology","permalink":"http://vompom.github.com/categories/technology/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://vompom.github.com/tags/Android/"}],"author":"落叶挽歌"},{"title":"Android屏幕刷新机制","slug":"Android屏幕刷新机制","date":"2025-02-24T02:49:00.000Z","updated":"2025-05-20T11:46:57.000Z","comments":true,"path":"2025/02/24/Android屏幕刷新机制/","permalink":"http://vompom.github.com/2025/02/24/Android%E5%B1%8F%E5%B9%95%E5%88%B7%E6%96%B0%E6%9C%BA%E5%88%B6/","excerpt":"","text":"最近在研究 Android 屏幕显示与渲染相关的内容，平时经常看到这些类 ViewRootImpl、Choreographer、Surface 、 SurfaceFlinger等，知道它们都用于屏幕渲染相关，但对它们细节了解较少，相关的文章也比较多，不需要自己完全重新再编写一份，于是对相关内容进行一个总结,主要来源：《Android屏幕刷新机制—VSyncChoreographer 全面理解》，这篇博客是我认为是目前看到过最好的一篇，文章由浅入深比较好理解。不过文章里面图片链接资源已经失效，为以后复习相关知识点，在此将其整理删除冗余内容，并对图片资源进行更新。 一、背景和疑问在Android中，当我们谈到 布局优化、卡顿优化 时，通常都知道 需要减少布局层级、减少主线程耗时操作，这样可以减少丢帧。如果丢帧比较严重，那么界面可能会有明显的卡顿感。我们知道 通常手机刷新是每秒60次，即每隔16.6ms刷新一次。 问题来了： 丢帧(掉帧) ，是说 这一帧延迟显示 还是丢弃不再显示 ？ 布局层级较多/主线程耗时 是如何造成 丢帧的呢？ 16.6ms刷新一次 是啥意思？是每16.6ms都走一次 measure/layout/draw ？ measure/layout/draw 走完，界面就立刻刷新了吗? 如果界面没动静止了，还会刷新吗？ 可能你知道VSYNC，这个具体指啥？在屏幕刷新中如何工作的？ 可能你还听过屏幕刷新使用 双缓存、三缓存，这又是啥意思呢？ 可能你还听过神秘的Choreographer，这又是干啥的？ 二、显示系统基础知识在一个典型的显示系统中，一般包括CPU、GPU、Display三个部分， CPU负责计算帧数据，把计算好的数据交给GPU，GPU会对图形数据进行渲染，渲染好后放到buffer(图像缓冲区)里存起来，然后Display（屏幕或显示器）负责把buffer里的数据呈现到屏幕上。如下图： 单缓存，从缓存映射到屏幕。 2.1 基础概念 屏幕刷新频率 一秒内屏幕刷新的次数（一秒内显示了多少帧的图像），单位 Hz（赫兹），如常见的 60 Hz。刷新频率取决于硬件的固定参数（不会变的）。 逐行扫描 显示器并不是一次性将画面显示到屏幕上，而是从左到右边，从上到下逐行扫描，顺序显示整屏的一个个像素点，不过这一过程快到人眼无法察觉到变化。以 60 Hz 刷新率的屏幕为例，这一过程即 1000 / 60 ≈ 16ms。 帧率 （Frame Rate） 表示 GPU 在一秒内绘制操作的帧数，单位 fps。例如在电影界采用 24 帧的速度足够使画面运行的非常流畅。而 Android 系统则采用更加流程的 60 fps，即每秒钟GPU最多绘制 60 帧画面。帧率是动态变化的，例如当画面静止时，GPU 是没有绘制操作的，屏幕刷新的还是buffer中的数据，即GPU最后操作的帧数据。 画面撕裂（tearing） 一个屏幕内的数据来自2个不同的帧，画面会出现撕裂感，如下图 明显看出画面错位的位置，这就是画面撕裂。 2.2 双缓存2.2.1 画面撕裂 原因屏幕刷新频是固定的，比如每16.6ms从buffer取数据显示完一帧，理想情况下帧率和刷新频率保持一致，即每绘制完成一帧，显示器显示一帧。但是CPU/GPU写数据是不可控的，所以会出现buffer里有些数据根本没显示出来就被重写了，即buffer里的数据可能是来自不同的帧的， 当屏幕刷新时，此时它并不知道buffer的状态，因此从buffer抓取的帧并不是完整的一帧画面，即出现画面撕裂。 简单说就是Display在显示的过程中，buffer内数据被CPU/GPU修改，导致画面撕裂。 2.2.2 双缓存那咋解决画面撕裂呢？答案是使用 双缓存。 由于图像绘制和屏幕读取 使用的是同个buffer，所以屏幕刷新时可能读取到的是不完整的一帧画面。 双缓存，让绘制和显示器拥有各自的buffer：GPU 始终将完成的一帧图像数据写入到 Back Buffer，而显示器使用 Frame Buffer，当屏幕刷新时，Frame Buffer 并不会发生变化，当Back buffer准备就绪后，它们才进行交换。如下图： 双缓存，CPU/GPU写数据到Back Buffer，显示器从Frame Buffer取数据 2.2.3 VSync问题又来了：什么时候进行两个buffer的交换呢？ 假如是 Back buffer准备完成一帧数据以后就进行，那么如果此时屏幕还没有完整显示上一帧内容的话，肯定是会出问题的。看来只能是等到屏幕处理完一帧数据后，才可以执行这一操作了。 当扫描完一个屏幕后，设备需要重新回到第一行以进入下一次的循环，此时有一段时间空隙，称为VerticalBlanking Interval(VBI)。那，这个时间点就是我们进行缓冲区交换的最佳时间。因为此时屏幕没有在刷新，也就避免了交换过程中出现 screen tearing的状况。 VSync(垂直同步)是VerticalSynchronization的简写，它利用VBI时期出现的vertical sync pulse（垂直同步脉冲）来保证双缓冲在最佳时间点才进行交换。另外，交换是指各自的内存地址，可以认为该操作是瞬间完成。 所以说V-sync这个概念并不是Google首创的，它在早年的PC机领域就已经出现了。 三、Android屏幕刷新机制3.1 Android4.1之前的问题具体到Android中，在Android4.1之前，屏幕刷新也遵循 上面介绍的 双缓存+VSync 机制。如下图： 双缓存会在VSync脉冲时交换，但CPU/GPU绘制是随机的 以时间的顺序来看下将会发生的过程： Display显示第0帧数据，此时CPU和GPU渲染第1帧画面，且在Display显示下一帧前完成 因为渲染及时，Display在第0帧显示完成后，也就是第1个VSync后，缓存进行交换，然后正常显示第1帧 接着第2帧开始处理，是直到第2个VSync快来前才开始处理的。 第2个VSync来时，由于第2帧数据还没有准备就绪，缓存没有交换，显示的还是第1帧。这种情况被Android开发组命名为“Jank”，即发生了丢帧。 当第2帧数据准备完成后，它并不会马上被显示，而是要等待下一个VSync 进行缓存交换再显示。 所以总的来说，就是屏幕平白无故地多显示了一次第1帧。 原因是 第2帧的CPU/GPU计算 没能在VSync信号到来前完成 。 我们知道，双缓存的交换 是在Vsyn到来时进行，交换后屏幕会取Frame buffer内的新数据，而实际 此时的Back buffer 就可以供GPU准备下一帧数据了。如果 Vsyn到来时 CPU/GPU就开始操作的话，是有完整的16.6ms的，这样应该会基本避免jank的出现了（除非CPU/GPU计算超过了16.6ms）。 那如何让 CPU/GPU计算在 Vsyn到来时进行呢？ 3.2 drawing with VSync为了优化显示性能，Google在Android 4.1系统中对Android Display系统进行了重构，实现了Project Butter（黄油工程）：系统在收到VSync pulse后，将马上开始下一帧的渲染。即一旦收到VSync通知（16ms触发一次），CPU和GPU 才立刻开始计算然后把数据写入buffer。如下图： VSync脉冲到来：双缓存交换，且开始CPU/GPU绘制 CPU/GPU根据VSYNC信号同步处理数据，可以让CPU/GPU有完整的16ms时间来处理数据，减少了jank。 一句话总结，VSync同步使得CPU/GPU充分利用了16.6ms时间，减少jank。 问题又来了，如果界面比较复杂，CPU/GPU的处理时间较长 超过了16.6ms呢？如下图： 虽然CPU/GPU开始在VSync，但超过16.6ms 在第二个时间段内，但却因 GPU 还在处理 B 帧，缓存没能交换，导致 A 帧被重复显示。 而B完成后，又因为缺乏VSync pulse信号，它只能等待下一个signal的来临。于是在这一过程中，有一大段时间是被浪费的。 当下一个VSync出现时，CPU/GPU马上执行操作（A帧），且缓存交换，相应的显示屏对应的就是B。这时看起来就是正常的。只不过由于执行时间仍然超过16ms，导致下一次应该执行的缓冲区交换又被推迟了——如此循环反复，便出现了越来越多的“Jank”。 为什么 CPU 不能在第二个 16ms 处理绘制工作呢？ 原因是只有两个 buffer，Back buffer正在被GPU用来处理B帧的数据， Frame buffer的内容用于Display的显示，这样两个buffer都被占用，CPU 则无法准备下一帧的数据。那么，如果再提供一个buffer，CPU、GPU 和显示设备都能使用各自的buffer工作，互不影响。 3.3 三缓存三缓存就是在双缓冲机制基础上增加了一个 Graphic Buffer 缓冲区，这样可以最大限度的利用空闲时间，带来的坏处是多使用的一个 Graphic Buffer 所占用的内存。 三缓存 第一个Jank，是不可避免的。但是在第二个 16ms 时间段，CPU/GPU 使用 第三个 Buffer 完成C帧的计算，虽然还是会多显示一次 A 帧，但后续显示就比较顺畅了，有效避免 Jank 的进一步加剧。 注意在第3段中，A帧的计算已完成，但是在第4个vsync来的时候才显示，如果是双缓冲，那在第三个vynsc就可以显示了。 三缓冲有效利用了等待vysnc的时间，减少了jank，但是带来了延迟。 所以，是不是 Buffer 越多越好呢？这个是否定的，Buffer 正常还是两个，当出现 Jank 后三个足以。 以上就是Android屏幕刷新的原理了。 四、Choreographer4.1 概述上面讲到，Google在Android 4.1系统中对Android Display系统进行了优化：在收到VSync pulse后，将马上开始下一帧的渲染。即一旦收到VSync通知，CPU和GPU就立刻开始计算然后把数据写入buffer。本节就来讲 “drawing with VSync” 的实现——Choreographer。 Choreographer，意为 舞蹈编导、编舞者。在这里就是指 对CPU/GPU绘制的指导—— 收到VSync信号 才开始绘制，保证绘制拥有完整的16.6ms，避免绘制的随机性。 Choreographer，是一个Java类，包路径android.view.Choreographer。类注释是“协调动画、输入和绘图的计时”。 通常 应用层不会直接使用Choreographer，而是使用更高级的API，例如动画和View绘制相关的ValueAnimator.start()、View.invalidate()等。 业界一般通过Choreographer来监控应用的帧率。 4.2 源码分析学习 Choreographer 可以帮助理解 每帧运行的原理，也可加深对 Handler机制、View绘制流程的理解，这样再去做UI优化、卡顿优化，思路会更清晰。 好了，下面开始源码分析了~ 4.2.1 入口 和 实例创建在《Window和WindowManager》、《Activity的启动过程详解》中介绍过，Activity启动 走完onResume方法后，会进行window的添加。window添加过程会 调用ViewRootImpl的setView()方法，setView()方法会调用requestLayout()方法来请求绘制布局，requestLayout()方法内部又会走到scheduleTraversals()方法，最后会走到performTraversals()方法，接着到了我们熟知的测量、布局、绘制三大流程了。 另外，查看源码发现，当我们使用 ValueAnimator.start()、View.invalidate()时，最后也是走到ViewRootImpl的scheduleTraversals()方法。（View.invalidate()内部会循环获取ViewParent直到ViewRootImpl的invalidateChildInParent()方法，然后走到scheduleTraversals()，可自行查看源码 ） 即 所有UI的变化都是走到ViewRootImpl的scheduleTraversals()方法。 那么问题又来了，scheduleTraversals() 到 performTraversals() 中间 经历了什么呢？是立刻执行吗？答案很显然是否定的，根据我们上面的介绍，在VSync信号到来时才会执行绘制，即performTraversals()方法。下面来瞅瞅这是如何实现的： //ViewRootImpl.javavoid scheduleTraversals() &#123; if (!mTraversalScheduled) &#123; //此字段保证同时间多次更改只会刷新一次，例如TextView连续两次setText(),也只会走一次绘制流程 mTraversalScheduled = true; //添加同步屏障，屏蔽同步消息，保证VSync到来立即执行绘制 mTraversalBarrier = mHandler.getLooper().getQueue().postSyncBarrier(); //mTraversalRunnable是TraversalRunnable实例，最终走到run()，也即doTraversal(); mChoreographer.postCallback( Choreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, null); if (!mUnbufferedInputDispatch) &#123; scheduleConsumeBatchedInput(); &#125; notifyRendererOfFramePending(); pokeDrawLockIfNeeded(); &#125;&#125;final class TraversalRunnable implements Runnable &#123; @Override public void run() &#123; doTraversal(); &#125;&#125;final TraversalRunnable mTraversalRunnable = new TraversalRunnable();void doTraversal() &#123; if (mTraversalScheduled) &#123; mTraversalScheduled = false; //移除同步屏障 mHandler.getLooper().getQueue().removeSyncBarrier(mTraversalBarrier); ... //开始三大绘制流程 performTraversals(); ... &#125;&#125; 主要有以下逻辑： 首先使用mTraversalScheduled字段保证同时间多次更改只会刷新一次，例如TextView连续两次setText()，也只会走一次绘制流程。 然后把当前线程的消息队列Queue添加了同步屏障，这样就屏蔽了正常的同步消息，保证VSync到来后立即执行绘制，而不是要等前面的同步消息。后面会具体分析同步屏障和异步消息的代码逻辑。 调用了mChoreographer.postCallback()方法，发送一个会在下一帧执行的回调，即在下一个VSync到来时会执行TraversalRunnable—&gt;doTraversal()—-&gt;performTraversals()—&gt;绘制流程。 接下来，就是分析的重点——Choreographer。我们先看它的实例mChoreographer，是在ViewRootImpl的构造方法内使用Choreographer.getInstance()创建： Choreographer mChoreographer;//ViewRootImpl实例是在添加window时创建public ViewRootImpl(Context context, Display display) &#123; ... mChoreographer = Choreographer.getInstance(); ...&#125; 我们先来看看Choreographer.getInstance()： public static Choreographer getInstance() &#123; return sThreadInstance.get();&#125;private static final ThreadLocal&lt;Choreographer&gt; sThreadInstance = new ThreadLocal&lt;Choreographer&gt;() &#123; @Override protected Choreographer initialValue() &#123; Looper looper = Looper.myLooper(); if (looper == null) &#123; //当前线程要有looper，Choreographer实例需要传入 throw new IllegalStateException(&quot;The current thread must have a looper!&quot;); &#125; Choreographer choreographer = new Choreographer(looper, VSYNC_SOURCE_APP); if (looper == Looper.getMainLooper()) &#123; mMainInstance = choreographer; &#125; return choreographer; &#125;&#125;; 看到这里 如你对Handler机制中looper比较熟悉的话，应该知道 Choreographer和Looper一样 是线程单例的。且当前线程要有looper，Choreographer实例需要传入。接着看看Choreographer构造方法： private Choreographer(Looper looper, int vsyncSource) &#123; mLooper = looper; //使用当前线程looper创建 mHandler mHandler = new FrameHandler(looper); //USE_VSYNC 4.1以上默认是true，表示 具备接受VSync的能力，这个接受能力就是FrameDisplayEventReceiver mDisplayEventReceiver = USE_VSYNC ? new FrameDisplayEventReceiver(looper, vsyncSource) : null; mLastFrameTimeNanos = Long.MIN_VALUE; // 计算一帧的时间，Android手机屏幕是60Hz的刷新频率，就是16ms mFrameIntervalNanos = (long)(1000000000 / getRefreshRate()); // 创建一个链表类型CallbackQueue的数组，大小为5， //也就是数组中有五个链表，每个链表存相同类型的任务：输入、动画、遍历绘制等任务（CALLBACK_INPUT、CALLBACK_ANIMATION、CALLBACK_TRAVERSAL） mCallbackQueues = new CallbackQueue[CALLBACK_LAST + 1]; for (int i = 0; i &lt;= CALLBACK_LAST; i++) &#123; mCallbackQueues[i] = new CallbackQueue(); &#125; // b/68769804: For low FPS experiments. setFPSDivisor(SystemProperties.getInt(ThreadedRenderer.DEBUG_FPS_DIVISOR, 1));&#125; 代码中都有注释，创建了一个mHandler、VSync事件接收器mDisplayEventReceiver、任务链表数组mCallbackQueues。FrameHandler、FrameDisplayEventReceiver、CallbackQueue后面会一一说明。 4.2.2 安排任务—postCallback回头看mChoreographer.postCallback(Choreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, null)方法，注意到第一个参数是CALLBACK_TRAVERSAL，表示回调任务的类型，共有以下5种类型： //输入事件，首先执行public static final int CALLBACK_INPUT = 0;//动画，第二执行public static final int CALLBACK_ANIMATION = 1;//插入更新的动画，第三执行public static final int CALLBACK_INSETS_ANIMATION = 2;//绘制，第四执行public static final int CALLBACK_TRAVERSAL = 3;//提交，最后执行，public static final int CALLBACK_COMMIT = 4; 五种类型任务对应存入对应的CallbackQueue中，每当收到 VSYNC 信号时，Choreographer 将首先处理 INPUT 类型的任务，然后是 ANIMATION 类型，最后才是 TRAVERSAL 类型。 postCallback()内部调用postCallbackDelayed()，接着又调用postCallbackDelayedInternal()，来瞅瞅： private void postCallbackDelayedInternal(int callbackType, Object action, Object token, long delayMillis) &#123; ... synchronized (mLock) &#123; // 当前时间 final long now = SystemClock.uptimeMillis(); // 加上延迟时间 final long dueTime = now + delayMillis; //取对应类型的CallbackQueue添加任务 mCallbackQueues[callbackType].addCallbackLocked(dueTime, action, token); if (dueTime &lt;= now) &#123; //立即执行 scheduleFrameLocked(now); &#125; else &#123; //延迟运行，最终也会走到scheduleFrameLocked() Message msg = mHandler.obtainMessage(MSG_DO_SCHEDULE_CALLBACK, action); msg.arg1 = callbackType; msg.setAsynchronous(true); mHandler.sendMessageAtTime(msg, dueTime); &#125; &#125;&#125; 首先取对应类型的CallbackQueue添加任务，action就是mTraversalRunnable，token是null。CallbackQueue的addCallbackLocked()就是把 dueTime、action、token组装成CallbackRecord后 存入CallbackQueue的下一个节点，具体代码比较简单，不再跟进。 然后注意到如果没有延迟会执行scheduleFrameLocked()方法，有延迟就会使用 mHandler发送MSG_DO_SCHEDULE_CALLBACK消息，并且注意到 使用msg.setAsynchronous(true)把消息设置成异步，这是因为前面设置了同步屏障，只有异步消息才会执行。我们看下mHandler的对这个消息的处理： private final class FrameHandler extends Handler &#123; public FrameHandler(Looper looper) &#123; super(looper); &#125; @Override public void handleMessage(Message msg) &#123; switch (msg.what) &#123; case MSG_DO_FRAME: // 执行doFrame,即绘制过程 doFrame(System.nanoTime(), 0); break; case MSG_DO_SCHEDULE_VSYNC: //申请VSYNC信号，例如当前需要绘制任务时 doScheduleVsync(); break; case MSG_DO_SCHEDULE_CALLBACK: //需要延迟的任务，最终还是执行上述两个事件 doScheduleCallback(msg.arg1); break; &#125; &#125;&#125; 直接使用doScheduleCallback方法，看看： void doScheduleCallback(int callbackType) &#123; synchronized (mLock) &#123; if (!mFrameScheduled) &#123; final long now = SystemClock.uptimeMillis(); if (mCallbackQueues[callbackType].hasDueCallbacksLocked(now)) &#123; scheduleFrameLocked(now); &#125; &#125; &#125;&#125; 发现也是走到这里，即延迟运行最终也会走到scheduleFrameLocked()，跟进看看： private void scheduleFrameLocked(long now) &#123; if (!mFrameScheduled) &#123; mFrameScheduled = true; //开启了VSYNC if (USE_VSYNC) &#123; if (DEBUG_FRAMES) &#123; Log.d(TAG, &quot;Scheduling next frame on vsync.&quot;); &#125; //当前执行的线程，是否是mLooper所在线程 if (isRunningOnLooperThreadLocked()) &#123; //申请 VSYNC 信号 scheduleVsyncLocked(); &#125; else &#123; // 若不在，就用mHandler发送消息到原线程，最后还是调用scheduleVsyncLocked方法 Message msg = mHandler.obtainMessage(MSG_DO_SCHEDULE_VSYNC); msg.setAsynchronous(true);//异步 mHandler.sendMessageAtFrontOfQueue(msg); &#125; &#125; else &#123; // 如果未开启VSYNC则直接doFrame方法（4.1后默认开启） final long nextFrameTime = Math.max( mLastFrameTimeNanos / TimeUtils.NANOS_PER_MS + sFrameDelay, now); if (DEBUG_FRAMES) &#123; Log.d(TAG, &quot;Scheduling next frame in &quot; + (nextFrameTime - now) + &quot; ms.&quot;); &#125; Message msg = mHandler.obtainMessage(MSG_DO_FRAME); msg.setAsynchronous(true);//异步 mHandler.sendMessageAtTime(msg, nextFrameTime); &#125; &#125;&#125; 如果系统未开启 VSYNC 机制，此时直接发送 MSG_DO_FRAME 消息到 FrameHandler。注意查看上面贴出的 FrameHandler 代码，此时直接执行 doFrame 方法。 Android 4.1 之后系统默认开启 VSYNC，在 Choreographer 的构造方法会创建一个 FrameDisplayEventReceiver，scheduleVsyncLocked 方法将会通过它申请 VSYNC 信号。 isRunningOnLooperThreadLocked 方法，其内部根据 Looper 判断是否在原线程，否则发送消息到 FrameHandler。最终还是会调用 scheduleVsyncLocked 方法申请 VSYNC 信号。 到这里，FrameHandler的作用很明显里了：发送异步消息（因为前面设置了同步屏障）。有延迟的任务发延迟消息、不在原线程的发到原线程、没开启VSYNC的直接走 doFrame 方法取执行绘制。 4.2.3 申请和接受VSync好了， 接着就看 scheduleVsyncLocked 方法是如何申请 VSYNC 信号的。猜测肯定申请 VSYNC 信号后，信号到来时也是走doFrame() 方法，doFrame()后面再看。先跟进scheduleVsyncLocked(): private void scheduleVsyncLocked() &#123; mDisplayEventReceiver.scheduleVsync();&#125; 很简单，调用mDisplayEventReceiver的scheduleVsync()方法，mDisplayEventReceiver是Choreographer构造方法中创建，是FrameDisplayEventReceiver 的实例。FrameDisplayEventReceiver是 DisplayEventReceiver 的子类，DisplayEventReceiver 是一个 abstract class： public DisplayEventReceiver(Looper looper, int vsyncSource) &#123; if (looper == null) &#123; throw new IllegalArgumentException(&quot;looper must not be null&quot;); &#125; mMessageQueue = looper.getQueue(); // 注册VSYNC信号监听者 mReceiverPtr = nativeInit(new WeakReference&lt;DisplayEventReceiver&gt;(this), mMessageQueue, vsyncSource); mCloseGuard.open(&quot;dispose&quot;);&#125; 在 DisplayEventReceiver 的构造方法会通过 JNI 创建一个 IDisplayEventConnection 的 VSYNC 的监听者。 FrameDisplayEventReceiver的scheduleVsync()就是在 DisplayEventReceiver中： public void scheduleVsync() &#123; if (mReceiverPtr == 0) &#123; Log.w(TAG, &quot;Attempted to schedule a vertical sync pulse but the display event &quot; + &quot;receiver has already been disposed.&quot;); &#125; else &#123; // 申请VSYNC中断信号，会回调onVsync方法 nativeScheduleVsync(mReceiverPtr); &#125;&#125; 那么scheduleVsync()就是使用native方法nativeScheduleVsync()去申请VSYNC信号。这个native方法就看不了了，只需要知道VSYNC信号的接受回调是onVsync()，我们直接看onVsync()： /** * 接收到VSync脉冲时 回调 * @param timestampNanos VSync脉冲的时间戳 * @param physicalDisplayId Stable display ID that uniquely describes a (display, port) pair. * @param frame 帧号码，自增 */@UnsupportedAppUsagepublic void onVsync(long timestampNanos, long physicalDisplayId, int frame) &#123;&#125; 具体实现是在FrameDisplayEventReceiver中： private final class FrameDisplayEventReceiver extends DisplayEventReceiver implements Runnable &#123; private boolean mHavePendingVsync; private long mTimestampNanos; private int mFrame; public FrameDisplayEventReceiver(Looper looper, int vsyncSource) &#123; super(looper, vsyncSource); &#125; @Override public void onVsync(long timestampNanos, long physicalDisplayId, int frame) &#123; // Post the vsync event to the Handler. // The idea is to prevent incoming vsync events from completely starving // the message queue. If there are no messages in the queue with timestamps // earlier than the frame time, then the vsync event will be processed immediately. // Otherwise, messages that predate the vsync event will be handled first. long now = System.nanoTime(); if (timestampNanos &gt; now) &#123; Log.w(TAG, &quot;Frame time is &quot; + ((timestampNanos - now) * 0.000001f) + &quot; ms in the future! Check that graphics HAL is generating vsync &quot; + &quot;timestamps using the correct timebase.&quot;); timestampNanos = now; &#125; if (mHavePendingVsync) &#123; Log.w(TAG, &quot;Already have a pending vsync event. There should only be &quot; + &quot;one at a time.&quot;); &#125; else &#123; mHavePendingVsync = true; &#125; mTimestampNanos = timestampNanos; mFrame = frame; //将本身作为runnable传入msg， 发消息后 会走run()，即doFrame()，也是异步消息 Message msg = Message.obtain(mHandler, this); msg.setAsynchronous(true); mHandler.sendMessageAtTime(msg, timestampNanos / TimeUtils.NANOS_PER_MS); &#125; @Override public void run() &#123; mHavePendingVsync = false; doFrame(mTimestampNanos, mFrame); &#125;&#125; onVsync()中，将接收器本身作为runnable传入异步消息msg，并使用mHandler发送msg，最终执行的就是doFrame()方法了。 注意一点是，onVsync()方法中只是使用mHandler发送消息到MessageQueue中，不一定是立刻执行，如何MessageQueue中前面有较为耗时的操作，那么就要等完成，才会执行本次的doFrame()。 4.2.4 doFrame和上面猜测一样，申请VSync信号接收到后确实是走 doFrame()方法，那么就来看看Choreographer的doFrame()： void doFrame(long frameTimeNanos, int frame) &#123; final long startNanos; synchronized (mLock) &#123; if (!mFrameScheduled) &#123; return; // no work to do &#125; ... // 预期执行时间 long intendedFrameTimeNanos = frameTimeNanos; startNanos = System.nanoTime(); // 超时时间是否超过一帧的时间（这是因为MessageQueue虽然添加了同步屏障，但是还是有正在执行的同步任务，导致doFrame延迟执行了） final long jitterNanos = startNanos - frameTimeNanos; if (jitterNanos &gt;= mFrameIntervalNanos) &#123; // 计算掉帧数 final long skippedFrames = jitterNanos / mFrameIntervalNanos; if (skippedFrames &gt;= SKIPPED_FRAME_WARNING_LIMIT) &#123; // 掉帧超过30帧打印Log提示 Log.i(TAG, &quot;Skipped &quot; + skippedFrames + &quot; frames! &quot; + &quot;The application may be doing too much work on its main thread.&quot;); &#125; final long lastFrameOffset = jitterNanos % mFrameIntervalNanos; ... frameTimeNanos = startNanos - lastFrameOffset; &#125; ... mFrameInfo.setVsync(intendedFrameTimeNanos, frameTimeNanos); // Frame标志位恢复 mFrameScheduled = false; // 记录最后一帧时间 mLastFrameTimeNanos = frameTimeNanos; &#125; try &#123; // 按类型顺序 执行任务 Trace.traceBegin(Trace.TRACE_TAG_VIEW, &quot;Choreographer#doFrame&quot;); AnimationUtils.lockAnimationClock(frameTimeNanos / TimeUtils.NANOS_PER_MS); mFrameInfo.markInputHandlingStart(); doCallbacks(Choreographer.CALLBACK_INPUT, frameTimeNanos); mFrameInfo.markAnimationsStart(); doCallbacks(Choreographer.CALLBACK_ANIMATION, frameTimeNanos); doCallbacks(Choreographer.CALLBACK_INSETS_ANIMATION, frameTimeNanos); mFrameInfo.markPerformTraversalsStart(); doCallbacks(Choreographer.CALLBACK_TRAVERSAL, frameTimeNanos); doCallbacks(Choreographer.CALLBACK_COMMIT, frameTimeNanos); &#125; finally &#123; AnimationUtils.unlockAnimationClock(); Trace.traceEnd(Trace.TRACE_TAG_VIEW); &#125;&#125; 上面都有注释了很好理解，接着看任务的具体执行doCallbacks 方法： void doCallbacks(int callbackType, long frameTimeNanos) &#123; CallbackRecord callbacks; synchronized (mLock) &#123; final long now = System.nanoTime(); // 根据指定的类型CallbackkQueue中查找到达执行时间的CallbackRecord callbacks = mCallbackQueues[callbackType].extractDueCallbacksLocked(now / TimeUtils.NANOS_PER_MS); if (callbacks == null) &#123; return; &#125; mCallbacksRunning = true; //提交任务类型 if (callbackType == Choreographer.CALLBACK_COMMIT) &#123; final long jitterNanos = now - frameTimeNanos; if (jitterNanos &gt;= 2 * mFrameIntervalNanos) &#123; final long lastFrameOffset = jitterNanos % mFrameIntervalNanos + mFrameIntervalNanos; if (DEBUG_JANK) &#123; Log.d(TAG, &quot;Commit callback delayed by &quot; + (jitterNanos * 0.000001f) + &quot; ms which is more than twice the frame interval of &quot; + (mFrameIntervalNanos * 0.000001f) + &quot; ms! &quot; + &quot;Setting frame time to &quot; + (lastFrameOffset * 0.000001f) + &quot; ms in the past.&quot;); mDebugPrintNextFrameTimeDelta = true; &#125; frameTimeNanos = now - lastFrameOffset; mLastFrameTimeNanos = frameTimeNanos; &#125; &#125; &#125; try &#123; // 迭代执行队列所有任务 for (CallbackRecord c = callbacks; c != null; c = c.next) &#123; // 回调CallbackRecord的run，其内部回调Callback的run c.run(frameTimeNanos); &#125; &#125; finally &#123; synchronized (mLock) &#123; mCallbacksRunning = false; do &#123; final CallbackRecord next = callbacks.next; //回收CallbackRecord recycleCallbackLocked(callbacks); callbacks = next; &#125; while (callbacks != null); &#125; &#125;&#125; 主要内容就是取对应任务类型的队列，遍历队列执行所有任务，执行任务是 CallbackRecord的 run 方法： private static final class CallbackRecord &#123; public CallbackRecord next; public long dueTime; public Object action; // Runnable or FrameCallback public Object token; @UnsupportedAppUsage public void run(long frameTimeNanos) &#123; if (token == FRAME_CALLBACK_TOKEN) &#123; // 通过postFrameCallback 或 postFrameCallbackDelayed，会执行这里 ((FrameCallback)action).doFrame(frameTimeNanos); &#125; else &#123; //取出Runnable执行run() ((Runnable)action).run(); &#125; &#125;&#125; 前面看到mChoreographer.postCallback传的token是null，所以取出action，就是Runnable，执行run()，这里的action就是 ViewRootImpl 发起的绘制任务mTraversalRunnable了，那么这样整个逻辑就闭环了。 那么 啥时候 token == FRAME_CALLBACK_TOKEN 呢？答案是Choreographer的postFrameCallback()方法： public void postFrameCallback(FrameCallback callback) &#123; postFrameCallbackDelayed(callback, 0);&#125;public void postFrameCallbackDelayed(FrameCallback callback, long delayMillis) &#123; if (callback == null) &#123; throw new IllegalArgumentException(&quot;callback must not be null&quot;); &#125; //也是走到是postCallbackDelayedInternal，并且注意是CALLBACK_ANIMATION类型， //token是FRAME_CALLBACK_TOKEN，action就是FrameCallback postCallbackDelayedInternal(CALLBACK_ANIMATION, callback, FRAME_CALLBACK_TOKEN, delayMillis);&#125;public interface FrameCallback &#123; public void doFrame(long frameTimeNanos);&#125; 可以看到postFrameCallback()传入的是FrameCallback实例，接口FrameCallback只有一个doFrame()方法。并且也是走到postCallbackDelayedInternal，FrameCallback实例作为action传入，token则是FRAME_CALLBACK_TOKEN，并且任务是CALLBACK_ANIMATION类型。 Choreographer的postFrameCallback()通常用来计算丢帧情况，使用方式如下： //Application.java public void onCreate() &#123; super.onCreate(); //在Application中使用postFrameCallback Choreographer.getInstance().postFrameCallback(new FPSFrameCallback(System.nanoTime())); &#125; public class FPSFrameCallback implements Choreographer.FrameCallback &#123; private static final String TAG = &quot;FPS_TEST&quot;; private long mLastFrameTimeNanos = 0; private long mFrameIntervalNanos; public FPSFrameCallback(long lastFrameTimeNanos) &#123; mLastFrameTimeNanos = lastFrameTimeNanos; mFrameIntervalNanos = (long)(1000000000 / 60.0); &#125; @Override public void doFrame(long frameTimeNanos) &#123; //初始化时间 if (mLastFrameTimeNanos == 0) &#123; mLastFrameTimeNanos = frameTimeNanos; &#125; final long jitterNanos = frameTimeNanos - mLastFrameTimeNanos; if (jitterNanos &gt;= mFrameIntervalNanos) &#123; final long skippedFrames = jitterNanos / mFrameIntervalNanos; if(skippedFrames&gt;30)&#123; //丢帧30以上打印日志 Log.i(TAG, &quot;Skipped &quot; + skippedFrames + &quot; frames! &quot; + &quot;The application may be doing too much work on its main thread.&quot;); &#125; &#125; mLastFrameTimeNanos=frameTimeNanos; //注册下一帧回调 Choreographer.getInstance().postFrameCallback(this); &#125;&#125; 4.2.5 小结使用Choreographer的postCallback()、postFrameCallback() 作用理解：发送任务 存队列中，监听VSync信号，当前VSync到来时 会使用mHandler发送异步message，这个message的Runnable就是队列中的所有任务。 好了，Choreographer整个代码逻辑都讲完了，引用《Android 之 Choreographer 详细分析》的流程图： 原文流程图为：Android 之 Choreographer，但并不是很形象，引用另一张流程图： 六、疑问解答 丢帧(掉帧) ，是说 这一帧延迟显示 还是丢弃不再显示 ？ 答：延迟显示，因为缓存交换的时机只能等下一个VSync了。 布局层级较多/主线程耗时 是如何造成 丢帧的呢？ 答：布局层级较多/主线程耗时 会影响CPU/GPU的执行时间，大于16.6ms时只能等下一个VSync了。 16.6ms刷新一次 是啥意思？是每16.6ms都走一次 measure/layout/draw ？ 答：屏幕的固定刷新频率是60Hz，即16.6ms。不是每16.6ms都走一次 measure/layout/draw，而是有绘制任务才会走，并且绘制时间间隔是取决于布局复杂度及主线程耗时。 measure/layout/draw 走完，界面就立刻刷新了吗? 答：不是。measure/layout/draw 走完后 会在VSync到来时进行缓存交换和刷新。 如果界面没动静止了，还会刷新吗？ 答：屏幕会固定没16.6ms刷新，但CPU/GPU不走绘制流程。见下面的SysTrace图。 可能你知道VSYNC，这个具体指啥？在屏幕刷新中如何工作的？ 答：当扫描完一个屏幕后，设备需要重新回到第一行以进入下一次的循环，此时会出现的vertical sync pulse（垂直同步脉冲）来保证双缓冲在最佳时间点才进行交换。并且Android4.1后 CPU/GPU的绘制是在VSYNC到来时开始。 可能你还听过屏幕刷新使用 双缓存、三缓存，这又是啥意思呢？ 答：双缓存是Back buffer、Frame buffer，用于解决画面撕裂。三缓存增加一个Back buffer，用于减少Jank。 可能你还听过神秘的Choreographer，这又是干啥的？ 答：用于实现——“CPU/GPU的绘制是在VSYNC到来时开始”。","categories":[{"name":"技术文章","slug":"technology","permalink":"http://vompom.github.com/categories/technology/"}],"tags":[{"name":"安卓","slug":"Android","permalink":"http://vompom.github.com/tags/Android/"}],"author":"落叶挽歌"},{"title":"关于 pthread_key_t 导致的 Android Crash 的探索","slug":"关于-pthread-key-t-导致的-Android-Crash-的探索","date":"2024-11-10T08:11:00.000Z","updated":"2025-05-20T11:46:57.000Z","comments":true,"path":"2024/11/10/关于-pthread-key-t-导致的-Android-Crash-的探索/","permalink":"http://vompom.github.com/2024/11/10/%E5%85%B3%E4%BA%8E-pthread-key-t-%E5%AF%BC%E8%87%B4%E7%9A%84-Android-Crash-%E7%9A%84%E6%8E%A2%E7%B4%A2/","excerpt":"","text":"此前我负责的 SDK 已集成多个司内业务，一切运行正常，最近在接入到一些游戏项目中的时候发现存在比较多关于 libc.so 的 crash，在游戏中某个场景会使用SDK 进行逻辑处理，在部分手机会在短时间就直接 Crash，且集中在性能比较好的手机中。经过一番折腾，最后被定位在了一个跟 SDK 没有什么关系的地方：pthread_key_t Crash 表现在 Crash 上报平台中收到诸多的 Crash 上报，调用的形式多种多样，异常名都是signal 6 (SIGABRT) 但崩溃调用栈最终都停留在 /apex/com.android.runtime/lib64/bionic/libc.so pc (abort+168) 以及中间都会经过：/apex/com.android.runtime/lib64/bionic/libc.so (pthread_once+136) 难以复现的问题由于我们的项目依赖于其他业务的SDK，最终的 SDK 打包合并在 Unity 的游戏中，我们不能直接使用游戏侧代码逻辑进行编译打包进行调试，这为问题的排查增大了一定的难度，只能在 Unity 的 demo 工程具体的表现为： 1、部分性能好的手机（如小米14 pro）才会出现 Crash，而且在对应的游戏中必现，有些游戏又不会复现 2、SDK里面同样的代码逻辑在测试 App 工程中完全不会复现 3、SDK里面同样的代码逻辑在 Unity 测试游戏 demo 中也完全不会复现 4、使用了业务方（游戏侧）的 Unity 的各种配置，依然没有复现 5、崩溃栈中有涉及到 thread 相关的关键词，怀疑是线程相关问题，但在原生层开辟N个线程也没有复现 6、其他各种尝试都没有复现：开辟大量内存、Unity 与 Android 调用方式调整…… 解决线索与方案一开始是怀疑业务方的环境与 SDK 运行环境有冲突，毕竟 SDK 已经在诸多业务中上线并正常运行了很久，不应该是 SDK 本身代码逻辑不对导致的才对。但没过多久，我们在另一个业务中也发现了这个问题，那说明并不是一个游戏环境导致。 解决问题直接看对应的崩溃栈，其崩溃栈都是使用相关的组件导致的 Crash，询问了相关的开发大佬之后并没有得到解决办法，原因是我们使用的版本相对较老，经历了比较久的迭代，逻辑改掉了很多。二是有可能这个问题在新版本中已经修复掉了。于是我们进行了一大波改造升级，经过一段时间后，再次集成到业务方，原以为这个问题就此解决了，调用了一下创编 SDK 之后依然 crash，此时心拔凉拔凉……但这时候比较能确定的是，这个 crash 跟依赖的SDK 没有直接关系，可能是由其他的环境问题什么。 问题线索 pthread_key在最开始的排查问题过程中一直在关注在环境的差异上面，经过一番折腾依然没有效果，方向错误了，于是再次回到 Crash 栈中来，在崩溃栈中都含有：pthread_once、emutls_get_address、cxa_get_globals、emutls_init相关的关键词，由于平时完全没有接触过这几个函数，对他们的了解比较少。但经过一番搜索之后，他们都有提到一个关键的术语：TLS (thread-local storage) 以及对几个函数调用的源码进行查看，发现这几个函数最终涉及到的都是 pthread 使用或者创建相关的 其中在 cs.android的 emutls.c 源码里有：static void emutls_init(void) &#123; if (pthread_key_create(&amp;emutls_pthread_key, emutls_key_destructor) != 0) abort();&#125; 这里基本上可以和崩溃栈对应上了，正是这里执行的 abort()，那么原因是否是由 pthread_key_create()引起的呢？继续对 pthread_key_create 研究，原来在 Bionic 中，能够被开发者所使用的 Pthread Key 数量，是 PTHREAD_KEYS_MAX 宏所定义的 128 个。 那我们遇到的问题是否也是同一个问题呢？得到答案最好的方式是验证，想办法做一个验证，用代码把系统能提供的 pthread_key 耗尽然后再使用我们创编SDK的功能，使用如下代码创建 PTHREAD_KEYS_MAX个 pthread_key_t，再直接使用创编 SDK，果不其然 Crash了，而且 crash 栈与上报的数据比较的一致（没有完全一致，毕竟一些场景还是会有点差异）。 以下的代码会耗尽目前程序中的 key，只创建 pthread_key，而不释放掉 void available_key() &#123; for (int i = 0; i &lt; PTHREAD_KEYS_MAX; i++) &#123; pthread_key_t key; int result = pthread_key_create(&amp;key, detachDestructor); if (result == JNI_OK) &#123; __android_log_print(ANDROID_LOG_ERROR, &quot;--julis&quot;, &quot;create thread key Success&quot;); &#125; else &#123; __android_log_print(ANDROID_LOG_ERROR, &quot;--julis&quot;, &quot;create thread key failed&quot;); &#125; &#125;&#125; 从打印的日志里面看，在 Unity demo App 里面大概创建到 60 多的时候就创建失败了，也就是说Unity 本身可能就使用了很多 key，留给应用层开发的就只有几十个 key 了。 虽然尝试是Crash了，但怎么能证明这个就是导致业务方 Crash 就是这个原因呢？以及怎么解释有的手机为什么会Crash，有的手机不会Crash呢？ 我们继续，从目前的推论来看，我们的创编SDK需要使用 pthread_key_t, 可能数量不够了，也就说创编SDK需要使用一定数量的key，那我们将刚才代码里面的i &lt; PTHREAD_KEYS_MAX; 进行调整，我们预留足够的 key 空间给创编SDK，i &lt; target_number; 于是在之前 crash 的手机和未 crash 的手机做了一次对比。 以下是对部手机的测试结果，记录日志前面的数字就是代码里面的 target_number 从对比结果看，两部手机他们可以供应用层使用的 key 的数量是不同的，之前会 crash 的手机它可以使用的 key 明显是少于之前未 crash 手机的数量的，这也就能解释为什么有的手机为什么会 crash，有的手机不会 crash 了。以及，可以推测出来创编SDK使用了5个key左右。 这里提一下在解决问题之初，我们发现 crash 的手机基本上都是市面上比较好的手机，且手机的 GPU 都集中于 Adreno 比较新的型号，一度误以为是相关底层 SDK 未进行兼容性适配导致。为什么性能更好的手机使用的 pthread_key_t 会更多？猜测可能是好的手机 Unity 运行相关的东西或者优化(这里的优化指的是游戏特效或者功能玩法)更多，所以消耗的资源就更多一点，当然这里只是个人猜测，具体原因还需要深入了解。 还剩下一个问题：业务方的 App 为什么会Crash？于是将上面的 available_key()方法进行一次包装，并将其打包集成进游戏侧测试，从日志里面看到留给我们创编SDK使用的 key 只有3个了！而我们的 SDK 需要5个左右，问题原因基本就是这个了，那如何解决呢？ 方案解决究其根本原因是 Android 系统的 pthread_key_t 的使用数量的限制，那么最直接的解决方式那就是降低对 pthread_key_t 的使用，但是由于我们依赖使用其他地方的 SDK，对其项目直接优化更改可能成本相对较高，直接修改源码解决的话一时半会儿无法解决。这里先对 pthread_key_t 数量限制相关的问题进行一些研究总结： 在 Android 官方源码 pthread.h#pthread_key_create() 里面有提到： There is a limit of PTHREAD_KEYS_MAX keys per process, but most callers should just use the C or C++ thread_local storage specifier anyway. When targeting new enough OS versions, the compiler will automatically use ELF TLS; when targeting old OS versions the emutls implementation will multiplex pthread keys behind the scenes, using one per library rather than one per thread-local variable. If you are implementing the runtime for a different language, you should consider similar implementation choices and avoid a direct one-to-one mapping from thread locals to pthread keys.Returns 0 on success and returns an error number on failure.int pthread_key_create(pthread_key_t* _Nonnull **key_ptr, void (* _Nullable **key_destructor)(void* _Nullable)); 可以看到官方建议使用 thread_local 去实现 TLS，以及在新的系统版本中会使用 ELF TLS 对 pthread_key_t 将不直接依赖，但条件相对比较高，参考官方更新：需要 miniSDK&gt;29 和NDK r26 ELF TLS (Available for API level &gt;= 29)Android supports ELF TLS starting at API level 29. Since NDK r26, clang will automatically enable ELF TLS for minSdkVersion 29 or higher. Otherwise, the existing emutls implementation (which uses pthread_key_create() behind the scenes) will continue to be used. This means that convenient C/C++ thread-local syntax is available at any API level; at worst it will perform similarly to “roll your own” thread locals using pthread_key_create() but at best you’ll get the performance benefit of ELF TLS, and the NDK will take care of the details. 最后我们的解决方式是依据上面 pthread_key_create 提到的 There is a limit of PTHREAD_KEYS_MAX keys per process….. 重点是：per process，每个进程有 PTHREAD_KEYS_MAX,这个PTHREAD_KEYS_MAX被定义在 limits.h 现在的 Android 基本上都是定义为128。那那我们将我们的SDK 使用的时候放在一个单独的进程不就ok了？事实是的，由于我们的SDK向业务只是提供一个 素材输入=&gt;视频输出的功能，中间过程是一个黑盒，那么这个场景使用多进程是完全OK的，使用多进程还有一个好处就是能与游戏进程相独立，尽量减少两者之间的依赖。但多进程也带来了一些门槛，但这相比与改渲染 SDK 底层的源码来说是相对简单很多的，最终经过一番折腾我们将创编SDK得渲染放在了一个单独的进程，后试验运行在之前 Crash 过的游戏业务上一切正常。 pthread_key 检测工具为了以后接入其他游戏前不再发生类似的Crash问题，在接入业务前做一些技术评估，pthread_key_t 可用数量可能也需要成为一个考量指标，可用数的不同，可能需要不同的技术方案，我专门写了一个小工具，可方便查询业务项目目前使用了多少 pthread_key_t，能帮助项目排查当前问题是否是由于 pthread_key_t 占满导致的相关问题。 不过我更想做一个能够检测项目里面有消耗过 pthread_key_t 的地方，将其 hook 住，打印出来对应的调用栈，这样就能方便业务排查。未来，随着 Android 业务的复杂化，这种问题可能会变成更多大型项目将会遇到。调研发现 Tencent 对外开源项目 Tencent/matrix 已经有针对 pthread_key 做了相关的hook，业务侧也可以直接使用 matrix 进行检测，但其项目相对比较庞大，以及使用的方式较复杂。于是将其精简到一个小工具内，整体大小只有1MB 不到。 源码地址：PthreadKeyDetect 总结本文主要记录了i创作SDK出现大佬了关于 libc.so 的 Crash，经过调查，问题被定位在 pthread_key_t 资源耗尽的问题上，并对其进行了相关研究，最后并解决了该问题的过程。 参考Android linker changes for NDK developers thread specific key leakage pthread_key_create用法导致的崩溃修复 Crash issue caused by pthread_key_create failed: 11 when integrating Flutter into our project #127079 Increase PTHREAD_KEYS_MAX","categories":[{"name":"技术文章","slug":"technology","permalink":"http://vompom.github.com/categories/technology/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://vompom.github.com/tags/Android/"}],"author":"落叶挽歌"},{"title":"[译]软件开发人员的常青技能","slug":"软件开发人员的常青技能","date":"2024-07-08T23:27:19.000Z","updated":"2026-02-09T10:49:55.671Z","comments":true,"path":"2024/07/09/软件开发人员的常青技能/","permalink":"http://vompom.github.com/2024/07/09/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E4%BA%BA%E5%91%98%E7%9A%84%E5%B8%B8%E9%9D%92%E6%8A%80%E8%83%BD/","excerpt":"","text":"最近在 Github 看到这一篇将程序员一直需要使用的非技术核心能力进行了总结，深受里面内容的启发，语言、框架都是会过时的，但有些技能无论是什么语言或者框架都是通用的，如果要在这个行业持续深根，那么这些非技术能力是必备的且实用的。本文在原文上进行翻译，并对文中提到部分专业术语进行了解释，以及对指向外部链接的文档内容作了一些简单的概述，希望能帮助到查看此文档的人。 原文地址：evergreen-skills-developers 中英双文地址：[译]evergreen-skills-developers 原文翻译：这个仓库包括了一份“常青技能”清单，这份清单应该可以作为对技术精湛的软件工程师/开发者客观评价。 这份工作的是为了在招聘软件开发者/工程师时，提供一个替代的技术面试的方案。文档关注的是软开发最佳实践、跨框架原则和通用的技能；而不是我们在行业中经常看到的语言层面，或者特定技术框架的内容。 编程语言不断进化，公司也不断改变他们的技术栈，框架很快就会过时，有经验的工程师使用搜索引擎能在几分钟就能解决语法相关的问题。因此，在面试候选人时关注这些方面是否有意义呢？ 另一方面，技术框架以外的原理和非技术的技能是在谷歌上查不到的，这些技能是“常青”的，并且对工程师的表现有巨大的影响。这些更能反映出软件开发者/工程师为团队带来的真正价值。 这个仓库是基于以下文章的一个衍生作品：”是什么造就了一位伟大的软件工程师“。 这是一个正在进行中的工作。重要的知识可能缺失，现有的条目可能可以改进，更好的分组策略也可能被发现。因此，任何贡献（即PR或问题）都是受欢迎的。请随时按照贡献指南提出修改建议。 目录 非技术技能 核心技能 交流 团队 创新和自我管理技能 开发流程 问题解决能力 心态 技能能力 通用技术能力 编程准则 数据结构 代码整洁 源码管理 技术合作 DevOps实践 通用技术知识 语言理论知识 优化 并发 特定领域技术知识 前端开发 后端开发 架构 基础建设 安全 非技术技能以下非技术能力可能是开发者最重要的能力。尽管一个人可能具备很强的技术能力，但在公司中没有良好的沟通、团队合作态度、开发流程、解决问题的能力和学习的心态的话，一切会变得非常糟糕。 核心技能（又称“软技能”）交流 遵循邮件使用的最佳策略(例： some e-mail etiquette rules) 遵循沟通的最佳策略 (e.g. use threads to organize discussions and other best-practices from Slack) 两份链接指向的 slack 的一则使用文档和一份 slack 使用技巧文档 最小化干扰 链接指向的文章是一篇关于程序员在工作中，因被其他事项而中断程序开发的影响，一般人，在工作过程中断打扰后大约需要23分钟才能恢复到之前的状态，而程序员需要更久，文中强调了工作中断对程序员工作效率和心情的影响，并讨论了有计划和非计划性中断的不同影响。 保持礼貌 团队 练习同理心 保持谦逊和低调 做一个积极倾听的人 做一个好的导师 知识分享 得有见地 创新和自我管理技能开发流程 了解《敏捷开发原则》 适应迭代和增量开发 自组织的能力 指的是个体或系统能够自发地、无需外部强制指挥，根据内部规则和相互作用来组织自身结构和行为的能力。这种能力在多个层面都有体现，包括个人自我管理、团队协作以及更广泛的社会和生态系统 避免产生错误的预估（比如：工时预估） 关注优先级和业务价值 问题解决能力 使用科学方法(Scientific Method) 科学方法是一种有系统地寻求知识的程序，涉及了以下三个步骤：问题的认知与表述、实验数据的收集、假说的构成与测试。 检索能力 横向思维 横向思维，指使用间接的、具有创造力的、不是一望而知的推理方式来解决问题 抽象化能力 创造力 五问法 五问法关键所在就是，鼓励解决问题的人要努力避开主观或自负的假设和逻辑陷阱，从结果着手，沿着因果关系链条，顺藤摸瓜，穿越不同的抽象层面，直至找出原有问题的根本原因。简而言之，就是鼓励解决问题的人要有“打破砂锅问到底”的精神。 风险管理 心态 不要害怕变化 敢于失败 终生学习 批判性思维 （保持理性，质疑决定，“让事实说话”） 技能能力通用技术能力有一些技术知识是永恒的，对任何软件工程师都有关，尽管他们将要从事的具体领域各不相同。为了深入了解他们的资历并了解他们的工程实践有多扎实，你可以和他们就编程原理、数据结构、清晰的代码、源代码管理、技术协作或者DevOps实践等主题进行交谈。如果这些基础扎实，他们可能能够毫无问题地学习你们特定领域的东西。 编程准则 基本流程结构和逻辑代数 面向对象编程 SOLID, GRASP)面向对象设计 SOLID（单一功能、开闭原则、里氏替换、接口隔离以及依赖反转） S 单一功能原则 认为“对象应该仅具有一种单一功能”的概念。 O 开闭原则 认为“软件应该是对于扩展开放的，但是对于修改封闭的”的概念。 L 里氏替换原则 认为“程序中的对象应该是可以在不改变程序正确性的前提下被它的子类所替换的”的概念。参考契约式设计。 I 接口隔离原则 认为“多个特定客户端接口要好于一个宽泛用途的接口”的概念。 D 依赖反转原则 认为一个方法应该遵从“依赖于抽象而不是一个实例”的概念。 依赖注入是该原则的一种实现方式。 GRASP中提到的模式和原则包括有控制器（controller）、创建者（creator）、中介（indirection）、信息专家（information expert）、低耦合性（low coupling）、高内聚性（high cohesion）、多态（polymorphism）、保护变化（protected variations）和纯虚构（pure Fabrication）[2] 函数式编程（纯函数、不变性、递归……） 声明式与命令式编程 声明式和命令式编程范例只不过是描述在不同抽象层次上编码的流行词。声明式编程关注的是“做什么，而不是如何做”，而命令式编程则关注的是“如何做，而不是做什么”。声明式编程是在比命令式编程更高的抽象层次上进行编程。两者都有其适用的地方，例如在网页开发中使用框架时需要声明式编程，而在设计算法和其他底层需求时则需要命令式编程。 数据结构 基本数据结构（基本类型、数组、矩阵、对象…） 缓存和 memoization memoization 没有一个很好的词能翻译，大概意思就是通过存储函数调用的结果，并在再次使用相同输入调用函数时直接返回已存储的结果，从而加速计算逻辑。斐波那契数列就是一个使用 memoization 的例子 Hash codes、 tokens、编码（比如 Base64） 栈与堆内存 链接指向一则在 stackoverflow 提出堆栈相关的诸多疑问，最高数回答解释了堆栈两种内存分配方式的基本概念、操作方式和性能差异，其中栈内存分配方式由于其后进先出的特性和近距离的存取模式，使得其在内存分配和回收上更加高效；而堆内存分配方式由于其动态和灵活的特性，对内存的管理相对复杂，但能够满足更多的内存需求 代码整洁 懂得命名对代码的可读性的重要性 避免过长的方法和类，确保职责被划分到各个方法或者类中 遵循约定来管理项目结构 将复杂的布尔条件提取到命名良好的函数中 尽量编写尽可能自解释的代码（即通过阅读代码就能容易理解代码的功能） 良好的命名和轻量的文档而不是行内注释 代码注释通常可能会误导人，因为它们经常被用作一种捷径，用来解释一段混乱的代码块的功能，而不是投入时间去重构它以提高其可读性。 链接的文章主张编写清晰、自解释和可维护的代码，而不是过度依赖注释，同时也承认在某些特殊情况下，注释是有其必要性和价值的。 将文档编写为代码，理想情况下与代码一起，以便于维护（例如，在仓库中的“docs”文件夹中的 markdown 文件） 使用文档来描述“为什么”和“怎么做”（例如，目标、用例、组件、高级架构概述等） 在面向对象编程中，组合优于继承 Follow 语义化 了解TDD及其实践（例如，“红色，绿色，重构”） TDD(测试驱动开发)是戴两顶帽子思考的开发方式：先戴上实现功能的帽子，在测试的辅助下，快速实现其功能；再戴上测试驱动开发的帽子，在测试的保护下，通过去除冗余的代码，提高代码品质。测试驱动着整个开发过程：首先，驱动代码的设计和功能的实现；其后，驱动代码的再设计和重构。 红色：首先编写一个针对新功能的测试用例，此时由于功能尚未实现，测试用例将无法通过（失败，显示红色） 绿色：接下来编写功能代码，使得测试用例能够通过（成功，显示绿色）。在这个阶段，重点是让测试通过，而不是编写完美的代码。 重构：在测试用例通过后，对功能代码进行优化和重构，提高代码质量，同时确保测试用例仍然能够通过。 源码管理能力 CVS（控制版本系统）/ SCM（源代码管理）基础知识：分支、标签、集中式与分散式等 SCM与仓库管理/托管的区别（即Git与GitHub之间的区别） 理解版本化的重要性 Commit 最佳实践 微提交 /原子提交，良好的描述等 常规提交 功能分支（短期） 基于主干的开发 依赖管理（包管理器的重要性，依赖地狱的风险等） 技术合作 代码 review 最佳实践 一句话来说就是：在执行代码审查时关注相关部分。目的是学习，而不是指责。 结对编程 这篇文章主要讨论了结对编程（Pair Programming）的相关主题，包括其风格、时间管理、轮换策略、日常规划、物理环境设置、远程配对等方面。还探讨了结对编程的好处和挑战，以及如何说服管理者和同事采用这种方法。此外，文章还涉及了一些与配对编程相关的细节和常见问题 DevOps 实践 自动化构建 构件仓库和镜像注册表 编写自动化测试 单元、集成和端到端（e2e）测试之间的区别 测试金字塔 持续集成 持续交付与持续部署 功能 Flag 和功能开关 通用技术知识语言理论知识 正则表达式（regex） 编译型与解释型语言 动态与静态 &amp; 弱类型与强类型语言类型 优化 懒加载 性能分析) 并发 竞态条件 死锁 互斥 特定领域技术知识在某些情况下，您可能希望工程师已经了解某些特定领域，例如前端、后端、架构、基础设施或安全方面。在这些情况下，还有一些跨框架的概念和原则，可用于推动针对每个领域的特定技术知识的内容。 前端开发 API通信（不同的架构标准，数据如何传输…） DOM（定义，理解，虚拟DOM…） 浏览器事件 响应式设计（目的，优点，渐进增强…） 客户端渲染（CSR）与服务器端渲染（SSR） 分页 状态管理（相关问题，无状态方法…） MVC 和相关的衍生品 WebSockets 网络通信协议 后端开发 API设计（不同的架构标准，数据如何传输…） 消息代理 关系型数据库（它们是如何工作的，基本概念…） 非关系型数据库 数据库设计 ORM（对象关系映射） 批处理进程 / 定时任务 会话处理 错误处理、审查、日志记录 架构 API 标准协议：REST / SOAP 安全性（例如拦截机器人，控制账户接管攻击等） 针对第三方服务故障的弹性橱窗（例如断路器） 外部可配置化 万物皆代码（即配置即代码，基础设施即代码，文档即代码…） 单体应用与微服务 领域驱动设计（DDD） 六边形架构 服务 Mesh 相关的互联网协议及其用法（如 HTTP, HTTPS, TCP, UDP, LDAP, SSH, SMTP…） 数据建模 基础设施 虚拟机与容器 进程与线程 控制器-代理/主副本模式 C/S模式 IAAS, PAAS, SASS Web服务器 反向代理 负载均衡 冗余 延迟 监控 可监控性 安全 身份和访问管理（IAM） 认证（JWT, SSO） 授权（RBAC, ABAC） 公钥密码系统（例如RSA） 加密协议（TLS, SSL） 最小权限原则 DoS / DDoS SQL 注入 中间人攻击 XSS（跨站脚本攻击） 和 CSRF（跨站请求伪造）","categories":[{"name":"思考总结","slug":"thinking","permalink":"http://vompom.github.com/categories/thinking/"}],"tags":[],"author":"落叶挽歌"},{"title":"UTF-8字符编码相关","slug":"关于Windows中文字符乱码","date":"2024-04-11T06:23:00.000Z","updated":"2025-05-20T11:46:57.000Z","comments":true,"path":"2024/04/11/关于Windows中文字符乱码/","permalink":"http://vompom.github.com/2024/04/11/%E5%85%B3%E4%BA%8EWindows%E4%B8%AD%E6%96%87%E5%AD%97%E7%AC%A6%E4%B9%B1%E7%A0%81/","excerpt":"","text":"最近在 Windows 上开发一些逻辑的时候遇到一些关于中文的坑，中文路径会乱码，是由于 Window 系统默认的编码格式是 GBK，而传入的参数编码格式是 UTF-8，导致整个程序出错。后续使用了`MultiByteToWideChar 和WideCharToMultiByte 方法对编码进行一次改变，从而避免了这个问题的产生。但不了解相关原因，经过一番学习，对相关的概念进行一些简单的总结，并对一些 api 的实现源码进行分析。 ASCII 码 ASCII ( American Standard Code for Information Interchange) 256个符号，从 00000000 到 11111111 ANSIANSI（American National Standards Institute，美国国家标准协会）编码：ANSI 编码是一种基于 8 位的字符编码。它包含了 128 个美国英语字符和其他 128 个特殊字符，共 256 个字符。ANSI 编码主要用于表示英语字符，但它的局限性在于无法表示其他语言的字符。为了解决这个问题，各国家和地区分别制定了自己的 ANSI 编码标准，但这又引入了新的问题，即不同编码之间的互不兼容。 ​ 美国和西欧：Windows-1252​ 中文（简体）：GB2312 或 GBK​ 中文（繁体）：Big5​ 日文：Shift-JIS​ 韩文：EUC-KR Unicode为了解决字符编码之间的兼容性问题，Unicode 标准应运而生。Unicode 是一种包含世界上大多数字符的编码方案，它为每个字符分配一个唯一的数字（称为码点），无论在任何平台、程序或语言中，都可以表示这些字符。Unicode 有多种实现方式，如 UTF-8、UTF-16 和 UTF-32。UTF-8 是最常用的 Unicode 实现方式，它是一种变长编码，可以使用 1 到 4 个字节来表示一个字符，这使得它在存储和传输方面更加高效 “FE FF” 是 Unicode 字符串的字节顺序标记（Byte Order Mark，简称 BOM），用于表示字符串的字节顺序 Unicode Little-Endian，”FF FE” Unicode Big-Endian，”FE FF” UTF-8UTF-8 是 Unicode 的实现方式之一 ，是一种变长编码，它使用 1 到 4 个字节（8 位）来表示一个字符 单字节 所有的ASCII 字符二字节 带有附加符号的拉丁文、希腊文、西里尔字母、亚美尼亚语、希伯来文、阿拉伯文、叙利亚文及它拿字母则需要二个字节编码 三字节 基本等同于GBK，含21000多个汉字 四字节 中日韩超大字符集里面的汉字，有5万多个 UTF-8编码对照表 Unicode 符号范围 (十六进制) UTF-8编码方式（二进制） 0000 0000 ~ 0000 007F 0xxxxxxx 0000 0080 ~ 0000 07FF 110xxxxx 10xxxxxx 0000 0800 ~ 0000 FFFF 1110xxxx 10xxxxxx 10xxxxxx 0001 0000 ~ 0010 FFFF 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx 源码阅读：Java String toUtf8 Java 的 String 默认用 UTF-16 存储数据，String 类的方法.getBytes(StandardCharsets.UTF_8) 将指定的字符集将字符串编码为 byte 序列，并将结果存储到一个新的 byte 数组中。 其主要逻辑在:CharsetUtils.java#toUtf8Bytes public static native byte[] toUtf8Bytes(String s, int offset, int length); 对应的最终实现：java_nio_charset_Charsets.cpp#Charsets_toUtf8Bytes static jbyteArray Charsets_toUtf8Bytes(JNIEnv* env, jclass, jcharArray javaChars, jint offset, jint length) &#123; // ....此处省略 一些检查逻辑 const int end = offset + length; for (int i = offset; i &lt; end; ++i) &#123; jint ch = chars[i]; if (ch &lt; 0x80) &#123; // 单字节直接放进去 if (!out.append(ch)) &#123; return NULL; &#125; &#125; else if (ch &lt; 0x800) &#123; // 双字节 if (!out.append((ch &gt;&gt; 6) | 0xc0) || !out.append((ch &amp; 0x3f) | 0x80)) &#123; return NULL; &#125; &#125; else if (U16_IS_SURROGATE(ch)) &#123; // ....此处省略 UTF-16 代理字符串相关的逻辑 ch = U16_GET_SUPPLEMENTARY(high, low); // 四字节 jbyte b1 = (ch &gt;&gt; 18) | 0xf0; jbyte b2 = ((ch &gt;&gt; 12) &amp; 0x3f) | 0x80; jbyte b3 = ((ch &gt;&gt; 6) &amp; 0x3f) | 0x80; jbyte b4 = (ch &amp; 0x3f) | 0x80; if (!out.append(b1) || !out.append(b2) || !out.append(b3) || !out.append(b4)) &#123; return NULL; &#125; &#125; else &#123; // 三字节. jbyte b1 = (ch &gt;&gt; 12) | 0xe0; jbyte b2 = ((ch &gt;&gt; 6) &amp; 0x3f) | 0x80; jbyte b3 = (ch &amp; 0x3f) | 0x80; if (!out.append(b1) || !out.append(b2) || !out.append(b3)) &#123; return NULL; &#125; &#125; &#125; return out.toByteArray();&#125; 整体的逻辑非常的好理解：判断输入值的区间，并分成单双三四字节的处理逻辑，其中有处理 UTF-16 代理字符串相关的逻辑此处忽略，可以了解代理项和增补字符。对应单字节符号处理，直接将原始值返回即可，其他的字节就一个一个地获取，这里分析一下对于双字节的逻辑处理。获取第一个字节的逻辑为：(ch &gt;&gt; 6) | 0xc0第二个字节逻辑为 (ch &amp; 0x3f) | 0x80 (ch &gt;&gt; 6) | 0xc0 第一个字节的前两位是 11（十六进制中的 0xc0），后面的 5 位是 Unicode 码点的高 5 位 (ch &amp; 0x3f) | 0x80 第二个字节的前两位是 10（十六进制中的 0x80），后面的 6 位是 Unicode 码点的低 6 位 举例，希腊符号 ε(epsilon) 在 UTF-8 编码里面是用双字节表示， Unicode 为 0x03B5 对应二进制数据：0000001110110101，计算流程如下所示： # ε 0x03B5 to UTF-8 # 第一个字节 (ch &gt;&gt; 6) | 0xc00000001110110101 &gt;&gt; 6 0000001110 | 0xc0 (11000000) 11000000 || 11001110 0xCE# 第二个字节 (ch &amp; 0x3f) | 0x800000001110110101 &amp; 0x3f (111111) 111111 110101 | 0x80 (10000000) 10000000 || 10110101 0xB5 从而计算出 ε 对应的 UTF-8 Encoding为0xCE 0xB5 “锟斤拷”和“烫”“锟斤拷”通常发生在UTF-8 到 GBK 编码的转换中，在 UTF-8 编码中，”0xEF 0xBF 0xBD” 是一个特殊的字符，表示 REPLACEMENT CHARACTER（替换字符），当解码器在解码字节序列时遇到无法识别的字节或无效的编码时，通常会用 REPLACEMENT CHARACTER（U+FFFD）替换这些无效的字节 ，”0xEF 0xBF 0xBD” 在 GBK 里面则编码成 “锟斤拷”。 “烫” 则是由于在 Windows 操作系统中，开发者在使用调试器调试程序时，会发现未初始化的内存通常会被填充为0xCC，而”0xCC” 在 GBK 里面则编码成“烫”。 总结本文主要讨论了字符编码的一些基本概念和原理，包括 ASCII、ANSI、Unicode 和 UTF-8 编码，文章分析了 Java String 类的.getBytes(StandardCharsets.UTF_8)方法的实现源码，解释了将 Unicode 字符串转换为 UTF-8 编码字节序列的过程，最后介绍了一下 “锟斤拷”和”烫”为什么会被展示。","categories":[],"tags":[{"name":"UTF-8","slug":"UTF-8","permalink":"http://vompom.github.com/tags/UTF-8/"}],"author":"落叶挽歌"},{"title":"实现一个自定义 FFmpeg Filter","slug":"实现一个自定义FFmpeg-Filter","date":"2024-03-07T02:58:00.000Z","updated":"2025-12-22T03:35:09.445Z","comments":true,"path":"2024/03/07/实现一个自定义FFmpeg-Filter/","permalink":"http://vompom.github.com/2024/03/07/%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E8%87%AA%E5%AE%9A%E4%B9%89FFmpeg-Filter/","excerpt":"","text":"此前在做 ffmpeg+某个第三库作为 filter 的集成，第三库是做AE特效相关的，与 ffmpeg 结合能让视频渲染效果大大提升。整体流程将第三方库作为 ffmpeg 的一个filter 形式进行结合，其中就涉及到 ffmpeg 的 filter 开发，本文即 对ffmpeg 的滤镜开发流程作一个总结。本文以实现一个视频垂直翻转的 filter 为例，ffmpeg 源码基于FFmpeg6.1 实现自定义 Filter 流程 编写 filter.c 文件 一般视频滤镜以 vf_ 为前缀，视频滤镜以 af_ 为前缀，放在libavfilter目录下，参考其他 filter 代码逻辑，模块化配置相关参数，本文例以 vf_flip.c 实现视频的上下翻转 在 libavfilter/allfilters.c 注册 例如：extern const AVFilter ff_vf_flip; ff_vf_flip就是在 vf_flip.c的 filter 注册名称 修改 libavfilter/Makefile 添加编译配置： 例如：OBJS-$(CONFIG_FLIP_FILTER) += vf_flip.o 编译打包 编写 filter.c 文件AVFilter主体typedef struct AVFilter &#123; const char *name; const char *description; const AVFilterPad *inputs; const AVFilterPad *outputs; const AVClass *priv_class; int flags; int (*preinit)(AVFilterContext *ctx); int (*init)(AVFilterContext *ctx); int (*init_dict)(AVFilterContext *ctx, AVDictionary **options); void (*uninit)(AVFilterContext *ctx); int (*query_formats)(AVFilterContext *); int priv_size; int flags_internal; struct AVFilter *next; int (*process_command)(AVFilterContext *, const char *cmd, const char *arg, char *res, int res_len, int flags); int (*init_opaque)(AVFilterContext *ctx, void *opaque); int (*activate)(AVFilterContext *ctx);&#125; AVFilter; 具体里面的属性作用可以参考：[ffmpeg] 定制滤波器，可以根据需求实现里面的相关函数，接下来以一个最简单的 Filter 和一个较复杂一点的 Filter 举例。 最简单的 AVFiltertypedef struct &#123; const AVClass *class;&#125; NoopContext;static int filter_frame(AVFilterLink *link, AVFrame *frame) &#123; av_log(NULL, AV_LOG_INFO, &quot;filter frame pts:%lld\\n&quot;, frame-&gt;pts); NoopContext *noopContext = link-&gt;dst-&gt;priv; return ff_filter_frame(link-&gt;dst-&gt;outputs[0], frame);&#125;static const AVFilterPad noop_inputs[] = &#123; &#123; .name = &quot;default&quot;, .type = AVMEDIA_TYPE_VIDEO, .filter_frame = filter_frame, &#125;&#125;;static const AVFilterPad noop_outputs[] = &#123; &#123; .name = &quot;default&quot;, .type = AVMEDIA_TYPE_VIDEO, &#125;&#125;;const AVFilter ff_vf_noop = &#123; .name = &quot;noop&quot;, .description = NULL_IF_CONFIG_SMALL(&quot;Pass the input video unchanged.&quot;), .priv_size = sizeof(NoopContext), FILTER_INPUTS(noop_inputs), FILTER_OUTPUTS(noop_outputs),&#125;; 命令行运行： ffmpeg -i test.mp4 -vf &quot;noop&quot; noop.mp4 正常输出文件（对原片没有做任何更改）,这个 filter 的作用是将输入的视频帧不做任何处理地传递给下一个过滤器，在处理每帧的时候会打印处理的 PTS，麻雀虽小五脏俱全，它包含了一个 AVFilter 基础的结构： NoopContext 这是一个简单的结构体，包含一个指向 AVClass 的指针。在这个例子中，实际上没有使用到 NoopContext 结构体的任何成员，因为这个过滤器没有需要存储的私有数据。 filter_frame 这个函数的作用是处理输入的视频帧。在这个例子中，它只是打印帧的 PTS（Presentation Time Stamp，显示时间戳）并将帧传递给下一个过滤器，不对帧做任何修改。 noop_inputs 和 noop_outputs 这两个数组定义了过滤器的输入和输出 Pad。在这个例子中，输入 Pad 类型为 AVMEDIA_TYPE_VIDEO，并关联了 filter_frame 函数。输出 Pad 也是 AVMEDIA_TYPE_VIDEO 类型，但没有关联任何函数，因为输出直接由 filter_frame 函数处理。 ff_vf_noop 这是一个 AVFilter 结构体实例，包含了过滤器的名称、描述、私有数据大小以及输入和输出 Pad。在这个例子中，过滤器的名称为 “noop”，描述为 “Pass the input video unchanged.”，这也就是在执行：ffmpeg -filters 看到的 Filter描述内容。 接下来看一个稍微复杂的一个 AVFilter，实现一个视频的上下翻转 复杂一点的 AVFiltertypedef struct FlipContext &#123; const AVClass *class; int duration;&#125; FlipContext;#define OFFSET(x) offsetof(FlipContext, x)static const AVOption flip_options[] = &#123; &#123;&quot;duration&quot;, &quot;set flip duration&quot;, OFFSET(duration), AV_OPT_TYPE_INT, &#123;.i64 = 0&#125;, 0, INT_MAX, .flags = AV_OPT_FLAG_FILTERING_PARAM&#125;, &#123;NULL&#125;&#125;;static av_cold int flip_init(AVFilterContext *ctx) &#123; FlipContext *context = ctx-&gt;priv; av_log(NULL, AV_LOG_ERROR, &quot;Input duration: %d.\\n&quot;, context-&gt;duration); return 0;&#125;static av_cold void flip_uninit(AVFilterContext *ctx) &#123; FlipContext *context = ctx-&gt;priv; // no-op 本例无需释放滤镜实例分配的内存、关闭文件、资源等&#125;// 对输入的 AVFrame 进行翻转static AVFrame *flip_frame(AVFilterContext *ctx, AVFrame *in_frame) &#123; AVFilterLink *inlink = ctx-&gt;inputs[0]; FlipContext *s = ctx-&gt;priv; int64_t pts = in_frame-&gt;pts; // 将时间戳（pts）转化以秒为单位的时间戳 float time_s = TS2T(pts, inlink-&gt;time_base); if (time_s &gt; s-&gt;duration) &#123; // 超过对应的时间则直接输出in_frame return in_frame; &#125; // 创建输出帧并分配内存 AVFrame *out_frame = av_frame_alloc(); if (!out_frame) &#123; av_frame_free(&amp;in_frame); return out_frame; &#125; // 设置输出帧的属性 out_frame-&gt;format = in_frame-&gt;format; out_frame-&gt;width = in_frame-&gt;width; out_frame-&gt;height = in_frame-&gt;height; out_frame-&gt;pts = in_frame-&gt;pts; // 分配输出帧的数据缓冲区 int ret = av_frame_get_buffer(out_frame, 32); if (ret &lt; 0) &#123; av_frame_free(&amp;in_frame); av_frame_free(&amp;out_frame); return out_frame; &#125; // 这个示例仅适用于 YUV 格式的视频。对于其他格式（如 RGB） // 翻转输入帧的数据到输出帧 // 翻转了 Y 分量，然后翻转了 U 和 V 分量 // uint8_t *src_y = in_frame-&gt;data[0]; uint8_t *src_u = in_frame-&gt;data[1]; uint8_t *src_v = in_frame-&gt;data[2]; uint8_t *dst_y = out_frame-&gt;data[0] + (in_frame-&gt;height - 1) * out_frame-&gt;linesize[0]; uint8_t *dst_u = out_frame-&gt;data[1] + (in_frame-&gt;height / 2 - 1) * out_frame-&gt;linesize[1]; uint8_t *dst_v = out_frame-&gt;data[2] + (in_frame-&gt;height / 2 - 1) * out_frame-&gt;linesize[2]; for (int i = 0; i &lt; in_frame-&gt;height; i++) &#123; memcpy(dst_y, src_y, in_frame-&gt;width); src_y += in_frame-&gt;linesize[0]; dst_y -= out_frame-&gt;linesize[0]; if (i &lt; in_frame-&gt;height / 2) &#123; memcpy(dst_u, src_u, in_frame-&gt;width / 2); memcpy(dst_v, src_v, in_frame-&gt;width / 2); src_u += in_frame-&gt;linesize[1]; src_v += in_frame-&gt;linesize[2]; dst_u -= out_frame-&gt;linesize[1]; dst_v -= out_frame-&gt;linesize[2]; &#125; &#125; return out_frame;&#125;static int activate(AVFilterContext *ctx) &#123; AVFilterLink *inlink = ctx-&gt;inputs[0]; AVFilterLink *outlink = ctx-&gt;outputs[0]; AVFrame *in_frame = NULL; AVFrame *out_frame = NULL; int ret = 0; // 获取输入帧 ret = ff_inlink_consume_frame(inlink, &amp;in_frame); if (ret &lt; 0) &#123; return ret; &#125; // 如果有输入帧，进行翻转处理 if (in_frame) &#123; // 对输出帧进行上下翻转处理 out_frame = flip_frame(ctx, in_frame); // 将处理后的帧放入输出缓冲区 ret = ff_filter_frame(outlink, out_frame); if (ret &lt; 0) &#123; av_frame_free(&amp;out_frame); return ret; &#125; &#125; // 如果没有输入帧，尝试请求一个新的输入帧 if (!in_frame) &#123; ff_inlink_request_frame(inlink); &#125; int status; int64_t pts; ret = ff_inlink_acknowledge_status(inlink, &amp;status, &amp;pts); if (ret &lt; 0) return ret; if (status == AVERROR_EOF) &#123; // 输入链接已经结束，设置输出链接的状态为 EOF ff_outlink_set_status(outlink, AVERROR_EOF, pts); return 0; &#125; return 0;&#125;AVFILTER_DEFINE_CLASS(flip);static const AVFilterPad flip_inputs[] = &#123; &#123; .name = &quot;default&quot;, .type = AVMEDIA_TYPE_VIDEO, &#125;&#125;;static const AVFilterPad flip_outputs[] = &#123; &#123; .name = &quot;default&quot;, .type = AVMEDIA_TYPE_VIDEO, &#125;&#125;;const AVFilter ff_vf_flip = &#123; .name = &quot;flip&quot;, .description = NULL_IF_CONFIG_SMALL(&quot;Flip the input video.&quot;), .priv_size = sizeof(FlipContext), .priv_class = &amp;flip_class, .activate = activate, .init = flip_init, .uninit = flip_uninit, FILTER_INPUTS(flip_inputs), FILTER_OUTPUTS(flip_outputs),&#125;; 命令行运行： ffmpeg -i test.mp4 -filter_complex &quot;[0:v]flip=duration=5[out];&quot; -map &quot;[out]&quot; flip.mp4 得到渲染好的视频，前5s是上下翻转的，后面的内容正常。 相比于最简单的 AVFilter 多了几个实现： AVOption flip_options 用于设置翻转持续时间的选项，外部命令配置可选输入duration=5，会自动对数据合法性进行校验。参数类型为 AV_OPT_TYPE_INT，默认值为 0，取值范围为 0 到 INT_MAX。.flags 设置为 AV_OPT_FLAG_FILTERING_PARAM，表示这是一个过滤参数。 .priv_class 配置的flip_class实际是通过 AVFILTER_DEFINE_CLASS(flip); 宏实现的一个声明：见：internal.h#AVFILTER_DEFINE_CLASS_EXT init&amp; uninit 滤镜在初始化或者释放资源的时候将会调用 activate 这个函数首先获取输入帧，然后调用 flip_frame 函数进行翻转操作，并将处理后的帧放入输出链接。如果没有输入帧，它会请求一个新的输入帧。最后，它会确认输入链接的状态，并根据需要设置输出链接的状态。 这个例子相比最简单的 filter 使用了 activate 函数 用于帧渲染，而不是使用 filter_frame去渲染，这两个方法有什么区别于联系呢？查看：filter_frame和activate方法和activate()函数) 也能通过 filter_frame实现，对代码部分逻辑更新更改： static const AVFilterPad flip_inputs[] = &#123; &#123; .name = &quot;default&quot;, .type = AVMEDIA_TYPE_VIDEO, .filter_frame = filter_frame, //添加filter_frame 实现 &#125;&#125;;const AVFilter ff_vf_flip = &#123; …… .priv_class = &amp;flip_class, // .activate = activate, .init = flip_init, ……&#125;;static int filter_frame(AVFilterLink *inlink, AVFrame *in) &#123; AVFilterContext *ctx = inlink-&gt;dst; FlipContext *s = ctx-&gt;priv; AVFilterLink *outlink = ctx-&gt;outputs[0]; int64_t pts = in-&gt;pts; // 将时间戳（pts）转化以秒为单位的时间戳 float time_s = TS2T(pts, inlink-&gt;time_base); if (time_s &gt; s-&gt;duration) &#123; // 超过对应的时间则直接输出in_frame return ff_filter_frame(outlink, in); &#125; else &#123; av_log(NULL, AV_LOG_ERROR, &quot;time_s s: %f.\\n&quot;, time_s); &#125; AVFrame *out = flip_frame(ctx, in); // 释放输入帧 av_frame_free(&amp;in); // 将输出帧传递给下一个滤镜 return ff_filter_frame(outlink, out);&#125; 命令行运行，得到的输出结果是一样的。 filter_frame()和activate()函数对于这点查了相关资料，看看源码相关的实现 参考：https://www.ffmpeg.org/doxygen/5.0/filter__design_8txt.html The purpose of these rules is to ensure that frames flow in the filter graph without getting stuck and accumulating somewhere. Simple filters that output one frame for each input frame should not have to worry about it. There are two design for filters:one using the filter_frame() and request_frame() callbacks and the other using the activate() callback. The design using filter_frame() and request_frame() is legacy, but it is suitable for filters that have a single input and process one frame at a time. New filters with several inputs, that treat several frames at a time or that require a special treatment at EOF should probably use the design using activate(). activate ———— This method is called when something must be done in a filter 大意，实现滤镜有两种实现方式： filter_frame() 可以被认为是历史遗留产物。在早期的 AVFilter 设计中，filter_frame() 和 request_frame() 是主要用于处理输入帧和请求输出帧的回调函数。这种设计适用于简单的过滤器，例如单输入且每次处理一个帧的过滤器。 activate() 随着 ffmpeg 和 AVFilter 的发展，处理需求变得越来越复杂，例如需要处理多个输入、一次处理多个帧或在文件结束（EOF）时进行特殊处理等。为了满足这些需求，引入了 activate() 函数，它提供了更灵活和强大的处理能力。因此，虽然 filter_frame() 在某些简单场景下仍然可以使用，但对于新的或复杂的过滤器，建议使用 activate() 函数。 如果两个方法都实现了，那他们谁会先执行呢？ 对应的源码处理逻辑： avfilter.c int ff_filter_activate(AVFilterContext *filter)&#123; int ret; …… ret = filter-&gt;filter-&gt;activate ? filter-&gt;filter-&gt;activate(filter) : ff_filter_activate_default(filter); …… return ret;&#125; 如果配置了activate() 函数则执行，否则执行 ff_filter_activate_default()-&gt;ff_filter_frame_to_filter()-&gt;ff_filter_frame_framed() 最终执行到配置的 filter_frame() 方法。 static int ff_filter_frame_framed(AVFilterLink *link, AVFrame *frame)&#123; int (*filter_frame)(AVFilterLink *, AVFrame *); AVFilterContext *dstctx = link-&gt;dst; AVFilterPad *dst = link-&gt;dstpad; int ret; if (!(filter_frame = dst-&gt;filter_frame)) filter_frame = default_filter_frame; …… ret = filter_frame(link, frame); // 最终调用到的地方 link-&gt;frame_count_out++; return ret;fail: ……&#125; 总结本文介绍了 FFmpeg 滤镜开发的整体流程，如何编写 filter.c 文件，并以一个最简单的 AVFilter 和一个较为复杂的 AVFilter 为例，解析了滤镜开发的具体步骤和代码实现，并介绍了 filter_frame() 和 activate() 函数的区别与联系。 在滤镜开发过程中，需要注意的是，filter_frame() 和 activate() 函数的使用取决于滤镜的复杂性。对于简单的滤镜，可以使用 filter_frame() 函数；而对于需要处理多个输入、一次处理多个帧或在文件结束（EOF）时进行特殊处理的复杂滤镜，建议使用 activate() 函数。 文中的源码可以查看：add most simplest AVFilter and a simple video flip filter. 参考：https://www.cnblogs.com/TaigaCon/p/10171464.html https://www.cnblogs.com/ranson7zop/p/7728639.html https://www.ffmpeg.org/doxygen/5.0/filter__design_8txt.html","categories":[{"name":"技术文章","slug":"technology","permalink":"http://vompom.github.com/categories/technology/"}],"tags":[{"name":"FFmpeg","slug":"FFmpeg","permalink":"http://vompom.github.com/tags/FFmpeg/"},{"name":"音视频","slug":"音视频","permalink":"http://vompom.github.com/tags/%E9%9F%B3%E8%A7%86%E9%A2%91/"}],"author":"落叶挽歌"},{"title":"RecyclerView自定义LayoutManager从0到1实践","slug":"自定义LayoutManager从0到1实践","date":"2023-10-31T11:19:00.000Z","updated":"2025-05-20T11:46:57.000Z","comments":true,"path":"2023/10/31/自定义LayoutManager从0到1实践/","permalink":"http://vompom.github.com/2023/10/31/%E8%87%AA%E5%AE%9A%E4%B9%89LayoutManager%E4%BB%8E0%E5%88%B01%E5%AE%9E%E8%B7%B5/","excerpt":"","text":"此前大部分涉及到 RecyclerView 页面的 LayoutManager基本上用系统提供的 LinearLayoutManager 、GridLayoutManager 就能解决，但在一些特殊场景上还是需要我们自定义 LayoutManager。之前基本上没有自己写过，在网上看各种源码各种文章，刚开始花了好多时间去理解整体流程，因为它们都给我一种非常非常复杂的感觉，包括相关的博客文章也是。经过一段时间摸索，也慢慢能理解为什么要那么复杂了，这的确不是特别容易入门。所以对整体的流程进行了一个拆解，尽量原子化一点，对自己学习的一个总结，也希望能帮助到一部分人能对 LayoutManager 入门。 本文最终实现一个简单的 LinearLayoutManager（只支持 VERTICAL）方向，适合对 LayoutManager 整体流程的学习与理解，整体代码分为多个文件，每个文件都是对前一段代码的补充，方便理解，整体项目源码已提交 Github: LayoutManagerGradually，代码里面写了很多很多注释，如果不想浪费时间，可以直接看代码运行，跳过这篇文章，把每一个 LayoutManager 都跑一下体验结合代码看看。 自定义 LayoutManager 的必要元素 继承 RecyclerView.LayoutManager 并实现 generateDefaultLayoutParams()方法 重写onLayoutChildren 第一次数据填充的时候数据添加 重写 canScrollHorizontally() 和canScrollVertically()方法设定支持滑动的方向 重写 scrollHorizontallyBy()和scrollVerticallyBy()方法，在滑动的时候对屏幕以外的 View 进行回收，以及填充即将滑动进入屏幕范围内的 View 进行填充 重写 scrollToPosition()和smoothScrollToPosition()方法支持 其中onLayoutChildren 和 scrollHorizontallyBy/scrollVerticallyBy 是最核心且最复杂的方法，这里稍微拎出来讲一下 onLayoutChildren这个方法类似于自定义 ViewGroup 的 onLayout() 方法，RecyclerView 的 LayoutManager.onLayoutChildren 在以下几个时机会被触发： 当 RecyclerView 首次附加到窗口时 当Adapter 的数据集发生变化 当 RecyclerView 被 执行 RequetLayout的时候 当 LayoutManager 发生变化时 scrollHorizontallyBy/scrollVerticallyBy方法的主要作用包括： 更新 ItemView 的位置：根据传入的垂直滚动距离（dy 参数），更新子视图在屏幕上的位置。通常调用 offsetChildrenVertical 方法。 回收不可见的 ItemView：在滚动过程中，一些 ItemView 可能会离开屏幕，变得不可见。scrollVerticallyBy 方法需要负责回收这些子视图并将它们放入回收池，以便稍后复用。 添加新的 ItemView：在滚动过程中，新的 ItemView 可能需要显示在屏幕上。scrollVerticallyBy 方法需要从回收池中获取可复用的视图并将它们添加到屏幕上。这通常涉及到调用 RecyclerView.Recycler 的 getViewForPosition 方法。 返回实际滚动距离：由于 ItemView 的数量有限，滚动可能会受到限制。例如，当滚动到列表顶部或底部时，滚动可能会停止。在这种情况下，实际滚动的距离可能会小于传入的 dy 参数。scrollVerticallyBy 方法需要返回实际滚动的距离，以便 RecyclerView 可以正确地更新滚动条和触发滚动事件。 概念就简单讲这么多， talk is cheap show me the code，直接看代码理解会比较深刻 逐步实现要实现一个可用的 LayoutManger 通常我们需要实现以下流程 数据填充并且只需要填充屏幕范围内的 ItemView 回收掉屏幕以外的 ItemView 屏幕外 ItemView 再回到屏幕后，需要重新填充 对滑动边界边界进行处理 对 scrollToPosition 和 smoothScrollToPosition进行支持 我们不用一上来就实现最终的效果，而是一步一步来，看看 LayoutManger 是怎么渐渐地变化，最终能跑起来的。 0 最简单的 LayoutManager代码查看：MostSimpleLayoutManager，我们关注 onLayoutChildren 方法: override fun onLayoutChildren(recycler: RecyclerView.Recycler, state: RecyclerView.State?) &#123; // 垂直方向的偏移量 var offsetTop = 0 // 实际业务中最好不要这样一次性加载所有的数据，这里只是最简单地演示一下整体是如何工作的 for (itemIndex in 0 until itemCount) &#123; // 从适配器获取与给定位置关联的视图 val itemView = recycler.getViewForPosition(itemIndex) // 将视图添加到 RecyclerView 中 addView(itemView) // 测量并布局视图 measureChildWithMargins(itemView, 0, 0) // 拿到宽高（包括ItemDecoration） val width = getDecoratedMeasuredWidth(itemView) val height = getDecoratedMeasuredHeight(itemView) // 对要添加的子 View 进行布局 layoutDecorated(itemView, 0, offsetTop, width, offsetTop + height) offsetTop += height &#125;&#125; 上面的代码主要演示了，如何利用addView layoutDecorated等方法，将 ItemView 添加到 RecyclerView 上。代码可见是 将所有的 ItemView（即使它在屏幕上不可见）一次性全部加载到了 RecyclerView上， 这里一般不这么做，只是这里这里只是最简单地演示一下整体是如何工作的。 运行在手机上能看到这样的效果：Item数据已经被全部添加到界面上了，并且各个方向的滑动都支持。 1 更合理的数据添加方式代码查看：LinearLayoutManager1.kt 对最开始的代码进行优化，只在屏幕范围内的区域进行数据的添加，这样就不需要一次性将所有数据就添加上去，如果 Adapter 的 ItemCount 足够巨大，for all addView 的话，很容易就 OOM。 override fun onLayoutChildren(recycler: RecyclerView.Recycler, state: RecyclerView.State) &#123; // 垂直方向上的的空间大小 var remainSpace = height - paddingTop //垂直方向的偏移量 var offsetTop = 0 var currentPosition = 0 while (remainSpace &gt; 0 &amp;&amp; currentPosition &lt; state.itemCount) &#123; // 从适配器获取与给定位置关联的视图 val itemView = recycler.getViewForPosition(currentPosition) // 将视图添加到 RecyclerView 中 addView(itemView) // 测量并布局视图 measureChildWithMargins(itemView, 0, 0) // 拿到宽高（包括ItemDecoration） val itemWidth = getDecoratedMeasuredWidth(itemView) val itemHeight = getDecoratedMeasuredHeight(itemView) // 对要添加的子 View 进行布局 layoutDecorated(itemView, 0, offsetTop, itemWidth, offsetTop + itemHeight) offsetTop += itemHeight currentPosition++ // 可用空间减少 remainSpace -= itemHeight &#125;&#125; 2 对屏幕外的View回收代码查看：LinearLayoutManager2 RecylerView 没有 recycler 怎么行呢？当 RecylerView 的 ItemView 滑出屏幕后我们需要对齐进行回收，实现的话需要在 scrollVerticallyBy中，比较复杂的逻辑就是怎么去判断：ItemView 在屏幕以外，最后利用：removeAndRecycleView方法进行回收 override fun scrollVerticallyBy(dy: Int, recycler: RecyclerView.Recycler, state: RecyclerView.State?): Int &#123; // 在这里处理上下的滚动逻辑，dy 表示滚动的距离 // 平移所有子视图 offsetChildrenVertical(-dy) // 如果实际滚动距离与 dy 相同，返回 dy；如果未滚动，返回 0 recycleInvisibleView(dy, recycler) return dy&#125;/** * 回收掉在界面上看不到的 ItemView * * @param dy * @param recycler */private fun recycleInvisibleView(dy: Int, recycler: RecyclerView.Recycler) &#123; val totalSpace = orientationHelper.totalSpace // 将要回收View的集合 val recycleViews = hashSetOf&lt;View&gt;() // 从下往上滑 if (dy &gt; 0) &#123; for (i in 0 until childCount) &#123; val child = getChildAt(i)!! // 从下往上滑从最上面的 item 开始计算 val top = getDecoratedTop(child) // 判断最顶部的 item 是否已经完全不可见，如何可见，那说明底下的 item 也是可见 val height = top - getDecoratedBottom(child) if (height - top &lt; 0) &#123; break &#125; recycleViews.add(child) &#125; &#125; else if (dy &lt; 0) &#123; // 从上往下滑 for (i in childCount - 1 downTo 0) &#123; val child = getChildAt(i)!! // 从上往下滑从最底部的 item 开始计算 val bottom = getDecoratedBottom(child) // 判断最底部的 item 是否已经完全不可见，如何可见，那说明上面的 item 也是可见 val height = bottom - getDecoratedTop(child) if (bottom - totalSpace &lt; height) &#123; break &#125; recycleViews.add(child) &#125; &#125; // 真正把 View 移除掉的逻辑 for (view in recycleViews) &#123; // [removeAndRecycleView] // 用于从视图层次结构中删除某个视图，并将其资源回收，以便在需要时重新利用 removeAndRecycleView(view, recycler) &#125; recycleViews.clear()&#125; 运行在手机上能看到这样的效果：滑出屏幕外的ItemView 被回收掉了 3 向上滑动的时View的填充代码查看：LinearLayoutManager3 override fun scrollVerticallyBy(dy: Int, recycler: RecyclerView.Recycler, state: RecyclerView.State?): Int &#123; // 填充 view fillView(dy, recycler) // 移动 view offsetChildrenVertical(-dy) // 回收 View recycleInvisibleView(dy, recycler) return dy&#125;/** * 填充重新进入屏幕内的 ItemView * getChildCount():childCount-&gt; 当前屏幕内RecyclerView展示的 ItemView 数量 * getItemCount():itemCount-&gt; 最大的 ItemView 数量，也就是 Adapter 传递的数据的数量 */private fun fillView(dy: Int, recycler: RecyclerView.Recycler) &#123; val verticalSpace = orientationVerticalHelper.totalSpace var remainSpace = 0 var nextFillPosition = 0 //垂直方向的偏移量 var offsetTop = 0 var offsetLeft = 0 // 从下往上滑，那么需要向底部添加数据 if (dy &gt; 0) &#123; val anchorView = getChildAt(childCount - 1) ?: return val anchorPosition = getPosition(anchorView) val anchorBottom = getDecoratedBottom(anchorView) val anchorLeft = getDecoratedLeft(anchorView) remainSpace = verticalSpace - anchorBottom // 垂直可用的数据为&lt;0，意外着这时候屏幕底部的位置刚好在最底部的 ItemView 上，还需要向上滑动一点点...我们才能添加 View if (remainSpace &lt; 0) &#123; return &#125; nextFillPosition = anchorPosition + 1 offsetTop = anchorBottom offsetLeft = anchorLeft if (nextFillPosition &gt;= itemCount) &#123; return &#125; &#125; else if (dy &lt; 0) &#123; // 从上往下滑，那么需要向顶部添加数据 //no-op 暂时不实现从上往下滑的底部数据填充 &#125; while (remainSpace &gt; 0 &amp;&amp; nextFillPosition &lt; itemCount) &#123; // 从适配器获取与给定位置关联的视图 val itemView = recycler.getViewForPosition(nextFillPosition) // 将视图添加到 RecyclerView 中 addView(itemView) // 测量并布局视图 measureChildWithMargins(itemView, 0, 0) // 拿到宽高（包括ItemDecoration） val itemWidth = getDecoratedMeasuredWidth(itemView) val itemHeight = getDecoratedMeasuredHeight(itemView) // 对要添加的子 View 进行布局，相比onLayoutChildren 里面的实现添加了：offsetLeft（因为我们没有禁止掉 左右的滑动） // 试着把 offsetLeft 改成0，也就是最原始的样子，然后左右上下滑滑，你会有意外收获 layoutDecorated(itemView, offsetLeft, offsetTop, itemWidth + offsetLeft, offsetTop + itemHeight) offsetTop += itemHeight nextFillPosition++ // 可用空间减少 remainSpace -= itemHeight &#125;&#125; 运行在手机上能看到这样的效果：向上滑动的时候，底部陆续有元素填充，但向下滑动的时候没有填充数据 4 两个方向的View填充代码查看：LinearLayoutManager4 补齐从上往下滑之后添加的逻辑 private fun fillView(dy: Int, recycler: RecyclerView.Recycler) &#123; val verticalSpace = orientationVerticalHelper.totalSpace var remainSpace = 0 var nextFillPosition = 0 //垂直方向的偏移量 var offsetTop = 0 var offsetLeft = 0 // 从下往上滑，那么需要向底部添加数据 if (dy &gt; 0) &#123; …… &#125; else if (dy &lt; 0) &#123; // 从上往下滑，那么需要向顶部添加数据 val anchorView = getChildAt(0) ?: return val anchorPosition = getPosition(anchorView) val anchorTop = getDecoratedTop(anchorView) offsetLeft = getDecoratedLeft(anchorView) remainSpace = anchorTop // 垂直可用的数据为&lt;0，意外着这时候屏幕顶部的位置刚好在最底部的 ItemView 上，还需要向下滑动一点点...我们才能添加 View if (anchorTop &lt; 0) &#123; return &#125; nextFillPosition = anchorPosition - 1 if (nextFillPosition &lt; 0) &#123; return &#125; val itemHeight = getDecoratedMeasuredHeight(anchorView) // 新的布局的itemView 的顶部位置应该以 anchorTop - itemHeight 开始 offsetTop = anchorTop - itemHeight &#125; while (remainSpace &gt; 0 &amp;&amp; ((nextFillPosition &lt; itemCount) &amp;&amp; (nextFillPosition &gt;= 0)) ) &#123; // 从适配器获取与给定位置关联的视图 val itemView = recycler.getViewForPosition(nextFillPosition) // 将视图添加到 RecyclerView 中k，从顶部添加的话，需要加到最前的位置 if (dy &gt; 0) &#123; addView(itemView) &#125; else &#123; addView(itemView, 0) &#125; …… if (dy &gt; 0) &#123; offsetTop += itemHeight nextFillPosition++ &#125; else &#123; offsetTop -= itemHeight nextFillPosition-- &#125; // 可用空间减少 remainSpace -= itemHeight &#125; 运行在手机上能看到这样的效果：向上或者滑动的时候，底部陆续都有元素填充 5 对顶部和底部滑动边界处理代码查看：LinearLayoutManager5 对于前面的实现会发现会：不停地下滑或者上滑会留出来巨大的空白。这里对填充 View 的逻辑进行改造，需要进行边界检测。 override fun scrollVerticallyBy(dy: Int, recycler: RecyclerView.Recycler, state: RecyclerView.State?): Int &#123; // 填充 view val adjustedDy = fillView(dy, recycler) // 移动 view offsetChildrenVertical(-adjustedDy) // 回收 View recycleInvisibleView(adjustedDy, recycler) // 由于需要对边界进行限制，所以需要对原始的 dy 进行修正，这里不再直接返回 dy return adjustedDy&#125; 这里的整体注释我写在了代码里面，可以看图稍微理解一下，以向上滑动为例：假设这一次滑动的距离非常非常大(想象成10000像素)，如果直接滑动的话，我们有50个元素，每个元素高度100像素，最大高度也只有50x100=5000，那么滑动后一定会留下大量空区域。需要对当前传入的这 10000 像素做调整：只给到可滑动的最大距离，如果不能滑动了就返回0。 运行在手机上能看到这样的效果：向上或者滑动的时候，达到最大的位置时候是不能再滑动的。 6 实现 scrollToPosition代码查看：LinearLayoutManager6 到这里这个 LinearLayoutManager 看着已经能正常运行了，但一般还需要支持scrollToPosition 和 smoothScrollToPositio private var mPendingScrollPosition = RecyclerView.NO_POSITIONoverride fun scrollToPosition(position: Int) &#123; super.scrollToPosition(position) if (position &lt; 0 || position &gt;= itemCount) &#123; return &#125; mPendingScrollPosition = position requestLayout()&#125;override fun onLayoutChildren(recycler: RecyclerView.Recycler, state: RecyclerView.State) &#123; …… var currentPosition = 0 if (mPendingScrollPosition != RecyclerView.NO_POSITION) &#123; currentPosition = mPendingScrollPosition &#125; while (remainSpace &gt; 0 &amp;&amp; currentPosition &lt; state.itemCount) &#123; …… // 填充View 的逻辑 &#125;&#125; scrollToPosition 的实现比较简单，如上代码所示：在 scrollToPosition 的时候记录一次目标position，再 requestLayout 一波，还记得之前有提到过：onLayoutChildren 会在 requestLayout 的时候调用一次，于是再将onLayoutChildren逻辑改写，不再从第0个元素开始，而是从目标位置进行布局。 运行在手机上能看到这样的效果：点击 scrollTo30 将会滑动到 第30个位置。 7 实现 smoothScrollToPosition代码查看：LinearLayoutManager7 要实现自定义的 smoothScrollToPosition 动画效果，这一块如果要完全自己实现的话比较复杂，可以直接使用系统提供的 LinearSmoothScroller改造,也可以继承 RecyclerView.SmoothScroller 自定义，也可以完全不使用 SmoothScroller， 照着 SmoothScroller 的实现使用类似 ValueAnimator 自定义动画，添加动画 UpdateListener，在 onAnimationUpdate 的时候动态计算布局从而实现滑动动画,这里拿 LinearSmoothScroller 举例: override fun smoothScrollToPosition( recyclerView: RecyclerView, state: RecyclerView.State, position: Int) &#123; if (position &gt;= itemCount || position &lt; 0) &#123; return &#125; val scroller: LinearSmoothScroller = object : LinearSmoothScroller(recyclerView.context) &#123; /** * 这个方法用于计算滚动到目标位置所需的滚动向量。滚动向量是一个二维向量，包含水平和垂直方向上的滚动距离 * * @param targetPosition 滑动的目标位置 * @return 返回一个 PointF 对象，表示滚动向量。 * PointF.x 表示水平方向上的滚动距离， * PointF.y 表示垂直方向上的滚动距离 */ override fun computeScrollVectorForPosition(targetPosition: Int): PointF &#123; // 查找到屏幕里显示的第 1 个元素与 val firstChildPos = getPosition(getChildAt(0)!!) val direction = if (targetPosition &lt; firstChildPos) -1 else 1 // x 左右滑动，由于我们只实现了垂直的滑动，所以 x方向为0即可 // 整数代表正向移动，负数代表反向移动，这里的数值大小不重要，源码里面最终都会 normalize 归一化处理 return PointF(0f, direction.toFloat()) &#125; /** * 计算每像素速度 * * @param displayMetrics * @return 返回每一像素的耗时，单位ms，假设返回值是1.0 代表着：1ms 内会滑动 1像素，1s会滑动1000像素 */ override fun calculateSpeedPerPixel(displayMetrics: DisplayMetrics?): Float &#123; return super.calculateSpeedPerPixel(displayMetrics) &#125; /** * 滑动速度的插值（实现滑动速度随着滑动时间的变化） * * @param dx * @return */ override fun calculateTimeForDeceleration(dx: Int): Int &#123; return super.calculateTimeForDeceleration(dx) &#125; // 很多方法可以使用，不再一一列举 // ... &#125; scroller.targetPosition = position // 执行默认动画的逻辑 startSmoothScroll(scroller)&#125; 运行在手机上能看到这样的效果：点击 smoothScrollTo30 将会有个动画效果滑动到第30个位置。 以上基本上一个自定义 LayoutManager 的雏形就已经完成了，虽然只实现了一个方向的滑动，但是其原理都是一样的，剩下的就是各种细节的打磨了，可以加各种自己想要的效果，比如：指定位置 放大一定的系数，或者更炫酷的滑动动画… 总结本文主要整理了自定义 LayoutManager 的必要元素，以及其核心方法 scrollHorizontallyBy/scrollVerticallyBy、onLayoutChildren 的作用与调用时机，接下对实现一个简单的 LinearLayoutManger 进行逻辑拆解，从最简单的不滑动回收和填充以及不含滑动边界检测，到最终一个具备基本功能的 LayoutManger 源码：https://github.com/VomPom/LayoutManagerGradually 参考： 《看完这篇文章你还不会自定义LayoutManager，我吃X！》 《/LayoutManager分析与实践》 Building a RecyclerView LayoutManager – Part 1","categories":[],"tags":[{"name":"技术文章","slug":"technology","permalink":"http://vompom.github.com/tags/technology/"}],"author":"落叶挽歌"},{"title":"Android 基于 J2V8 运行 JavasScript  实践","slug":"Android-J2V8-实践","date":"2023-09-30T13:11:00.000Z","updated":"2025-05-20T11:46:57.000Z","comments":true,"path":"2023/09/30/Android-J2V8-实践/","permalink":"http://vompom.github.com/2023/09/30/Android-J2V8-%E5%AE%9E%E8%B7%B5/","excerpt":"","text":"V8 引擎是由 Google 开源的 JavaScript 引擎，Chrome 就是基于 V8 开发，V8 是跨平台的，J2V8 基于 V8 进行开发，使得 js 代码能够在 Android 平台上脱离 WebView 运行。目前，也有很多关于 Android J2V8 的文章，不过讲解不是特别细（可能也是我太菜了，看完了之后，依然遇到很多问题），自己在调研的过程中遇到很多坑，所以这里记录一下，本文主要记录整个 J2V8 框架的使用方法，以及一些坑。 一、Webpack 打包通常业务逻辑的 js 文件是有多个的，我们需要借助一些打包工具将多个文件打包成一个 js 文件供 J2V8 使用，我们可以使用 Gulp、Webpack、Browserify，本文主要讲 Webpack 的使用。主要流程如下： 编写基础逻辑并通过 module.exports 对外部提供 编写 index.js 入口文件...module.exports = &#123; simpleFunc, complexFunc&#125;; 编写webpack.config打包配置module.exports = &#123; entry: &#x27;./src/example/index.js&#x27;, output: &#123; library: &#x27;libExample&#x27;, // j2v8 加载该lib path: path.resolve(__dirname, &#x27;dist&#x27;), filename: &#x27;example.js&#x27;, // 导出指定命名的 js 文件 &#125;, ...&#125;; 执行 webpack 打包命令./node_modules/.bin/webpack --config webpack.config.js 二、运行 JavaScript到这里我们已经有一份通过 Webpack 打包好的 js 文件了，要在 j2v8 中运行 JavaScript 文件，使用以下步骤： 1、创建一个 V8 实例V8 v8 = V8.createV8Runtime();2、读取 JavaScript 文件var scriptStr = String(Files.readAllBytes(Paths.get(&quot;example.js&quot;)))3、在 V8 实例中执行 JavaScript 代码v8.executeScript(scriptStr);这一步已经让整个 js 文件运行起来，但我们还不能调用我们的方法 4、读取指定模块 由于是通过 Webpack 打包，在 Webpack 的 output.library 配置，选项用于将打包后的代码作为一个库(library)暴露出去，以便其他应用程序或模块可以使用它。val rootLib =v8.getObject(libName); // 这里的 libName 就是 output.library 配置的名字如果是访问模块的导出对象中的子对象，那么继续：val subLib =rootLib.getObject(subLibName); // 这里的 subLibName 是 index 文件中 module.exports 里面的模块名 如果子对象还有子对象，继续.getObject 即可 5、运行指定方法 接下来就简单了，直接通过如下方法执行 js 中的指定方法public void executeVoidFunction(String name, V8Array parameters)public String executeStringFunction(String name, V8Array parameters) public double executeDoubleFunction(String name, V8Array parameters) public int executeIntegerFunction(String name, V8Array parameters)…… V8Object 提供了很多数据格式调用，不过都差不多，主要是在返回值那里帮你实现了数据的转化，如果不想用转化好的格式，希望自己来操作的话，使用public V8Object executeObjectFunction() 拿到返回值，自己去转化即可 6、释放资源 由于 V8 运行消耗较多的资源，执行结束的时候要将在过程中创建的所有的资源释放，避免导致内存泄漏。V8提供了close方法，如果只使用 v8.close() 进行释放，或者未关闭过程中有用到 v8 runtime 的变量都会报如下错误，正确的做法是将所有资源进行关闭。 java.lang.IllegalStateException: 3 Object(s) still exist in runtime 三、进阶通过以上的方式已经能执行很多逻辑了，但在实践过过程中发现：如何 js 的返回值是 Promise 的话不会等到最终的结果给我们，而是直接返回了一个 Promise 对象，以及看不到 console.log 打印的日志…… 诸如此类的问题需要解决，这里主要讲讲这两种方法的实现。 注册 Native 插件 J2V8 是一个基于 V8 引擎的 Java 库，它允许在 Java 中执行 JavaScript 代码。由于 J2V8 是在 Java 中运行的，它没有直接访问浏览器或控制台的能力，因此无法直接使用 console.log 函数来输出日志，总结 J2V8 不能实现以下功能： 浏览器 API：j2v8 是在 Java 中运行的，因此无法直接访问浏览器 API，如 DOM、BOM 等。这意味着 j2v8 无法直接操作网页内容、处理事件等 文件系统访问：j2v8 在 Java 中运行，无法直接访问文件系统。如果需要访问文件系统，需要使用 Java 提供的文件操作 API。 定时器：JavaScript 中有多种定时器函数，如 setTimeout、setInterval 等，可以在指定时间后执行代码。但 j2v8 无法实现这些定时器函数，因为它无法直接访问系统的计时器。 Web Worker：Web Worker 是 JavaScript 中的一个特殊对象，可以在后台线程中执行代码，以避免阻塞主线程。但 j2v8 无法实现 Web Worker，因为它无法直接访问操作系统的线程。 Node.js API：j2v8 主要是为了在 Java 中执行浏览器端的 JavaScript 代码而设计的，因此无法直接访问 Node.js API。如果需要在 Java 中执行 Node.js 代码，可以考虑使用 Nashorn 等其他工具。 这里是 console.log的一个简单实现： V8Object 是 J2V8 中的一个类，它代表了一个 JavaScript 对象，对于 console.log 我们可以将 console 看作一个对象，其有一个叫 log 的方法，要实现在 js 中打印日志到 Android Studio 控制台，如下即可： class ConsolePlugin &#123; fun log(message: Any) &#123; Log.d(&quot;ConsolePlugin&quot;, message.toString()) &#125; fun register(v8: V8) &#123; val v8Console = V8Object(v8) // 第一个 log 表示 在 Java 中该方法的名字，第二个 log 表示在 JavaScript 中调用的名字 v8Console.registerJavaMethod(this, &quot;log&quot;, &quot;log&quot;, arrayOf&lt;Class&lt;*&gt;&gt;(Any::class.java)) v8Console.setWeak() // 将含有叫&quot;log&quot;方法的一个对象加到运行环境中，该对象被命名为 &quot;console&quot; v8.add(&quot;console&quot;, v8Console) &#125;&#125;ConsolePlugin().register(v8) 具体代码可参考:J2V8_tutorial 执行返回值是 Promise 类型的方法之前将的方法调用都是返回数据为基础类型，由于在 Java/kotlin 中没有Promise类型的方法，所以对于 Promise 方法我们需要进行一些特殊处理，我们通过使用 CountDownLatch 可以来实现一个 “异步变同步” 的操作，我们需要考虑的是如何接受到 resolve rejcet的调用，js 中 Promise 的方法使用如下：PromiseMethod().then((result)=&gt;&#123; // success got result &#125;).catch((e)=&gt;&#123; // error... &#125;);在 J2V8中一样的实现 获取返回的 Promise 对象val promiseObj = v8.executeFunction(functionName, v8Array) as V8Object执行 Promise 对象的 then 和 catch 方法 jsPromise.apply &#123; val onResolveParameter = V8Array(v8).push(onResolve) val onRejectParameter = V8Array(v8).push(onReject) executeVoidFunction(&quot;then&quot;, onResolveParameter) executeVoidFunction(&quot;catch&quot;, onRejectParameter) .... &#125;其中 onResolveval onResolve = V8Function(jsRuntime) &#123; receiver, parameters -&gt; …… &#125;具体代码可参考:J2V8_tutorial 四、总结以上基本上能解决大部分 Android 调用 js的代码逻辑了，这里对整体执行的流程进行一个总结 1、通过 webpack 对多个 .js 文件打包2、初始化 V8 环境并加载 .js 文件3、注册 Java 方法，供 js 进行调用4、读取指定的模板5、执行目标 js 方法，并释放 v8 执行过程中产生的资源 踩过的一些坑1、java.lang.UnsupportedOperationException: StartNodeJS Not Supported. 这个库有一个 NodeJS.createNodeJS()方法，以为是完美结合 NodeJs 的，查了下不太支持 Android，不过也有人提出解决方法：https://stackoverflow.com/questions/42574824/how-to-use-nodejs-in-android-using-j2v8 2、java.lang.IllegalStateException: 3 Object(s) still exist in runtime 这是调用 `v8.close`` 总是会遇到的问题，一定需要确保使用了 v8 Runtime 过程变量有被释放掉，可能有时候不知道具体哪个变量没有被释放 3、setTimeout、setInterval 无效 这是我最开始遇到的问题，简单想着“既然能执行js代码，那 setTimeout、setInterval 这些方法都是 js 最普通的方法应该没问题吧”，如果有一些平时在 js 很常见的操作如果无法执行，最好 check 一下 J2V8 是否支持 4、Undefined 相关 虽然源码里面通过了一个 Undefined 的类，但是不能直接使用，如果方法返回的 Undefined，通过 V8Object 的 isUndefined() 去判断 引用[1]J2V8 https://eclipsesource.com/blogs/tutorials/getting-started-with-j2v8/ [2] Registering Java Callbacks with J2V8 https://eclipsesource.com/blogs/2015/06/06/registering-java-callbacks-with-j2v8/ [3] Simple JS in Node.js https://yenhuang.gitbooks.io/android-development-note/content/wrap-js-library/simple-js-with-nodejs.html","categories":[{"name":"技术文章","slug":"technology","permalink":"http://vompom.github.com/categories/technology/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://vompom.github.com/tags/JavaScript/"}],"author":"落叶挽歌"},{"title":"[转]《数字化视频技术概述》","slug":"转-《数字化视频技术概述》","date":"2023-09-15T12:11:00.000Z","updated":"2025-09-15T13:30:00.946Z","comments":true,"path":"2023/09/15/转-《数字化视频技术概述》/","permalink":"http://vompom.github.com/2023/09/15/%E8%BD%AC-%E3%80%8A%E6%95%B0%E5%AD%97%E5%8C%96%E8%A7%86%E9%A2%91%E6%8A%80%E6%9C%AF%E6%A6%82%E8%BF%B0%E3%80%8B/","excerpt":"","text":"自己从事在音视频领域的边缘，音视频领域存在太多的专业术语，一下子搞懂是不可能的，这个项目 digital_video_introduction 来自 github 的一个开源项目，目前接近有 16k 的 star 了，从最基础的图像概念开始，逐步深入到视频、编解码器、传输和流媒体，适合反复学习阅读。主要内容包括：图像基础： 介绍了图像是如何被计算机理解和存储的，包括像素、分辨率、色彩空间（如 RGB 和 YUV）以及色度采样（如 4:2:0）。视频： 将视频定义为一系列帧在时间上的连续，并引出了帧率（FPS）的概念。编解码器（Codec）： 详细介绍了视频压缩的原理，包括帧内预测、帧间预测（I、P、B 帧）、运动补偿、宏块、熵编码、量化和变换。文章特别提到了 FFmpeg，并提供了如何使用它进行视频编码和转码的实例。容器格式（Container）： 解释了容器格式（如 MP4、MKV）的作用，它们用于封装视频流、音频流和元数据。 原文链接: https://github.com/leandromoreira/digital_video_introduction","categories":[],"tags":[{"name":"音视频","slug":"音视频","permalink":"http://vompom.github.com/tags/%E9%9F%B3%E8%A7%86%E9%A2%91/"}],"author":"落叶挽歌"},{"title":"[转]OpenGL黑屏及渲染不出来的常见原因总结","slug":"转-OpenGL黑屏及渲染不出来的常见原因总结","date":"2023-01-15T04:18:00.000Z","updated":"2025-11-25T02:49:22.233Z","comments":true,"path":"2023/01/15/转-OpenGL黑屏及渲染不出来的常见原因总结/","permalink":"http://vompom.github.com/2023/01/15/%E8%BD%AC-OpenGL%E9%BB%91%E5%B1%8F%E5%8F%8A%E6%B8%B2%E6%9F%93%E4%B8%8D%E5%87%BA%E6%9D%A5%E7%9A%84%E5%B8%B8%E8%A7%81%E5%8E%9F%E5%9B%A0%E6%80%BB%E7%BB%93/","excerpt":"","text":"最近在做 Unitiy 与原生渲染相关的研究学习，对于OpenGL这块自己也是接触不多，有很多的坑需要自己去踩，做的过程中遇到最多的问题是：渲染黑屏 在掘金上搜到这篇文章《OpenGL黑屏及渲染不出来的常见原因总结》很不错，于是记录转载过来，方便日后学习以及问题排查。 原文链接：https://juejin.cn/post/6844903910742687751 原文做OpenGL开发的同学，想必一定碰到过黑屏的问题，特别是刚接触OpenGL的同学，可能会觉得黑屏问题让人相当头疼，因为OpenGL的查错没有一般编程时那么简单，我们通常是利用glGetError()这个API来获取错误码，但这个方法获取的错误是调用这个方法时，已经产生的错误，它有可能是很久之前产生的，这样查越来还是比较不方便的，而且，有些黑屏以及渲染不出来的情况下，glGetError()也不会报任何错。 在给大家总结常见的黑屏原因之前，我们先来铺垫一下基础知识，其实屏幕也是一块frame buffer，但它比较特殊，是0号frame buffer，我们如果自己申请frame buffer的话，得到的id是大于0的。那么frame buffer它就会有自己的颜色，如果不特意设置的话，它就是黑色的，因此如果我们渲染操作未正确执行，什么也没渲染出来，自然看到了底色的黑色。 我们也可以通过glClearColor()+glClear()来设置消除颜色及执行消除操作，来将一个frame buffer清成某种颜色。因此，如果你将frame buffer清成了别的颜色，但其它渲染操作未正确执行，你有可能也不是黑屏，而是你设置的消除颜色，这里也一并总结了，统成为黑屏，同时也包括其它一些不正确的情形。如果不是渲染到屏幕上，是渲染到一个离屏的frame buffer上，同样也会遇到各种黑掉或者渲染不出来的情况，有些原因会同时导致上屏和离屏都黑，有些只影响其中一种情况。 下面给大家总结一下： 调用线程的Context不正确 OpenGL的API在调用时需要有正确的上下文，在Android中称为EGL Context，IOS中是EAGL Context，其它平台有其它平台的叫法，但原理类似。一个线程需要跟EGL Context绑定才能正确使用OpenGL的API，否则调用不会有任何效果，具体可参考我的一篇文章：《OpenGL ES 高级进阶：EGL及GL线程》。 【转载注】这也是我碰到的第一个坑，因为从 Unity 调用到 Android 侧的时候，gl渲染线程和 Unity 线程不一致。我花了很大的精力去排查前面shader相关的渲染问题，一直没有注意这个问题，所以浪费了大量时间。我个人认为这个问题需要像使用一门新语言的时候要先确保它能打印出”Hello World”一样，是整个流程的前提。 GL Program不正确 OpenGL渲染需要通过GL Program，它就是一个程序，和我们的普通程序是一个道理，只不过它是运行在GPU上的，如果它不正确了，那自然就渲染不出正确的结果，常见的不正确原因为shader编译失败，通常是因为语法错误，可以用glGetShaderInfoLog()来在编译之后查看相关shader信息，以及在Link后用glGetProgramInfoLog()查看相关program信息，如果得到的信息为空，则说明没有错。 没有use program 渲染前需要通过glUseProgran设置本次渲染所用的program，如果未设置则无法执行到对应的shader，自然无法渲染出来。 未调用glDrawXXX() 要渲染出来东西，必须调用glDrawXXX()，一般很少出现没调的情况，一般都是低级失误，最好也排查一下。 对于底层是多buffer实现的surface，渲染后未进行swap buffer常见的是双buffer，此时有一个back buffer和一个front buffer，front buffer是正在显存的这个，back buffer是正在渲染的，如果draw call后没有swap buffer，那back buffer不会呈现出来，因此渲染不出来，这里是特定上屏，如果渲染不是要上屏，则无需考虑这个问题。 frame buffer的attachment不正确 在离屏渲染情况下，当我们要渲染到一个frame buffer上，这个frame buffer必须正确绑定了attachment，否则相当于frame buffer是个空壳，它没有任何可用于承载渲染结果的空间。 顶点attribute值设置错误 顶点关系到渲染到什么位置，如果设置错误导致渲染的位置在可视范围之外，那么就看不到了，这里的范围是什么呢？如果直接用NDC坐标渲染，那就是-1~1,如果是用世界坐标来渲染，那就要看具体设置的投影矩阵，详细原理可参考我的另一篇文章《OpenGL 3D渲染技术：坐标系及矩阵变换》。 attribute未启用我们通过想要设置一个attribute的值，需要获取这个attribute的location，并通过glVertexAttribPointer()给它设置值，但别忘了需要使用glGetAttribLocation()来启用这个location，不然设置了也没有用，默认是不启用的。 VAO/VBO未绑定或者绑定错误 如果是用VAO/VBO的方式渲染，在渲染前要绑定正确的VAO/VBO，否则等于没指定或者指定错了顶点，就渲染不出来了。 VAO/VBO方式渲染之后未重置，后面接着用非VAO/VBO方式渲染 在用VAO/VBO方式渲染之后如果未重置，那么顶点绑定的还是VAO/VBO指定的顶点，此时如果再用普通的glVertexAttribPointer()的方式指定顶点渲染，那用法上会冲突，因为VAO/VBO的方式要求glVertexAttribPointer()函数不指定顶点数据，而普通用法中glVertexAttribPointer()又要指定顶点数据，此时容易造成顶点混乱，渲染结果不正确。 View Port设置错误View Port即视口，可以理解成我们通过一个窗口去看见OpenGL世界坐标系里渲染的景物，就像我们通过窗口看到室外的景物一样，如果这个窗口没设置或者设置不正确，也会导致看不到东西，一般情况下，我们会将它设置为surface的大小，这样渲染出来的东西就刚好填满这个surface。 没有渲染到0号frame buffer 有时候渲染操作有很多步，想做完这些步骤后，再将做好的结果显示的屏幕上，这时就会用一些frame buffer来做离屏渲染，但在最后一步渲染到屏幕上时，需要将frame buffer绑定回0号，才能上屏。 渲染了一个不正确的纹理 例如我们希望对一个纹理做一些处理然后渲染出来，但如果这个纹理本身是不正确的，例如前面的步骤出了一些错，导致给过来的纹理id不正确，比如是0，或者纹理id是正确的，但这个纹理是全黑的或者空的，也会导致黑屏。 glDrawXXX()方法传递的顶点数不正确 我们在调用glDrawXXX()，会设置顶点数组的开始位置和数量，如果设置不正确，导致传递的顶点是0个，也会导致渲染不出来任何东西。 顶点buffer的position不正确 这一点主要是针对java及kotlin，glVertexAttribPointer()接受数据时是通过一个buffer，而我们往buffer是put数据后，buffer的position会相应地往后移动，因此在调用glVertexAttribPointer()之前，记得将position设回到0，否则它将从末尾开始取数据，当然就取不到了。 面剔除的原因 如果开启了cull face，那么会按你指定的cull方式来剔除指定顶点旋转顺序的三角面片，如果视线方向看过去的刚好被剔除了，自然就看不见了。 未开启颜色混合渲染了有透明度的纹理 OpenGL默认是不开启颜色混合的，这会导致透明的部分通常会被渲染成黑色，而不是透出下面的颜色，具体可以参数我的一篇文章：《OpenGL ES 高级进阶：颜色混合》。 转载者新增【主要面向Android】 eglCreateWindowSurface 创建 EGLSurface 时机不正确 传递对应的 surface 参数的时候，需要 TextureView onSurfaceTextureAvailable 方法被调用过，才能使用 TextureView 的 surface 执行 eglCreateWindowSurface 原文作者：程序员kenney 原文链接：https://juejin.cn/post/6844903910742687751 来源：稀土掘金","categories":[{"name":"技术文章","slug":"technology","permalink":"http://vompom.github.com/categories/technology/"}],"tags":[{"name":"音视频","slug":"音视频","permalink":"http://vompom.github.com/tags/%E9%9F%B3%E8%A7%86%E9%A2%91/"},{"name":"OpenGL","slug":"OpenGL","permalink":"http://vompom.github.com/tags/OpenGL/"}],"author":"落叶挽歌"},{"title":"FFmpeg.so 编译总结","slug":"FFmpeg-so-编译整理","date":"2023-01-09T02:36:00.000Z","updated":"2025-05-20T11:46:57.000Z","comments":true,"path":"2023/01/09/FFmpeg-so-编译整理/","permalink":"http://vompom.github.com/2023/01/09/FFmpeg-so-%E7%BC%96%E8%AF%91%E6%95%B4%E7%90%86/","excerpt":"","text":"此前项目一直使用的 FFmpeg.so 是我从其他团队项目中直接复制过来的，但原来的项目团队不再维护这个库，其中 x264 模块由于一些版权问题需要剔除，所以需要自己重新编译。在编译的过程中踩了很多坑，以及编译 congfigure 有太多的配置，如何减少整体编译出来的大小也是需要花点精力的，本文主要记录编译流程以及相关配置介绍。 编译介绍自己编译主要参考《一键编译32_64位FFmpeg.4.2.2》-%E4%B8%80%E9%94%AE%E7%BC%96%E8%AF%91-32-64-%E4%BD%8D-FFmpeg-4-2-2.md)，最开始的时候自己一直在 Mac M1 上编译，各种流程也是一比一复刻，但是仍然会有各种问题出现，最常见的就是： aarch64-linux-android21-clang is unable to create an executable file.C compiler test failed. 我反复检查了自己的 NDK 的配置，确保是正确的，文章也有提及处理方式，但是尝试下来都无效，在网上搜了一大篇解决方式，也都无效。不过我看他们很多都是用 Linux 系统进行的编译，遂改为使用 Linux 编译，再重新尝试，似乎没有那些个奇奇怪怪的错误了，也打出了最终的包，最后的 so 大小也符合要求。 编译环境 CentOS 7 ffmpeg-4.2.2 android-ndk-r20b-linux-x86_64.zip 编译脚本这是我的一份编译脚本，我的需求是进行本地视频抽帧，所以不需要像滤镜、编码、音频相关的配置，只需要视频解码相关的配置，具体配置在下一节有讲解。 #!/bin/bashexport NDK=.../android-ndk-r20bTOOLCHAIN=$NDK/toolchains/llvm/prebuilt/linux-x86_64function build_android&#123;./configure \\ --prefix=$PREFIX \\ --enable-neon \\ --disable-x86asm \\ --disable-hwaccels \\ --disable-gpl \\ --disable-nonfree \\ --disable-version3 \\ --disable-postproc \\ --disable-bsfs \\ --disable-protocols \\ --enable-protocol=file \\ --disable-indevs \\ --disable-outdevs \\ --disable-debug \\ --enable-small \\ --enable-jni \\ --disable-mediacodec \\ --disable-decoder=h264_mediacodec \\ --enable-swscale \\ --enable-static \\ --disable-shared \\ --disable-filters \\ --disable-avfilter \\ --disable-encoders \\ --disable-muxers \\ --disable-demuxers \\ --enable-demuxer=avi \\ --enable-demuxer=flv \\ --enable-demuxer=h261 \\ --enable-demuxer=h263 \\ --enable-demuxer=h264 \\ --enable-demuxer=hevc \\ --enable-demuxer=mov \\ --enable-demuxer=m4v \\ --disable-decoders \\ --enable-decoder=h263 \\ --enable-decoder=h263i \\ --enable-decoder=h263p \\ --enable-decoder=h264 \\ --enable-decoder=hevc \\ --enable-decoder=flv \\ --enable-decoder=mpeg4 \\ --disable-parsers \\ --enable-parser=h264 \\ --enable-parser=h261 \\ --enable-parser=h263 \\ --enable-parser=mpeg4video \\ --enable-parser=mpegvideo \\ --disable-htmlpages \\ --disable-manpages \\ --disable-podpages \\ --disable-txtpages \\ --disable-vaapi \\ --disable-v4l2-m2m \\ --disable-nvdec \\ --disable-nvenc \\ --disable-ffnvcodec \\ --disable-dxva2 \\ --disable-d3d11va \\ --disable-cuvid \\ --disable-cuda-llvm \\ --disable-cuda-nvcc \\ --disable-audiotoolbox \\ --disable-amf \\ --disable-iconv \\ --disable-libxcb \\ --disable-libxcb-shm \\ --disable-libxcb-xfixes \\ --disable-libxcb-shape \\ --disable-lzma \\ --disable-sdl2 \\ --disable-securetransport \\ --disable-xlib \\ --disable-zlib \\ --disable-programs \\ --disable-ffmpeg \\ --disable-ffplay \\ --disable-ffprobe \\ --disable-avdevice \\ --disable-symver \\ --cross-prefix=$CROSS_PREFIX \\ --target-os=android \\ --arch=$ARCH \\ --cpu=$CPU \\ --cc=$CC \\ --cxx=$CXX \\ --enable-cross-compile \\ --sysroot=$SYSROOT \\ --extra-cflags=&quot;-Os -fpic $OPTIMIZE_CFLAGS&quot; \\ --extra-ldflags=&quot;$ADDI_LDFLAGS&quot;make cleanmake -j16make install&#125;#arm64-v8aARCH=arm64CPU=armv8-aAPI=21CC=$TOOLCHAIN/bin/aarch64-linux-android$API-clangCXX=$TOOLCHAIN/bin/aarch64-linux-android$API-clang++SYSROOT=$NDK/toolchains/llvm/prebuilt/linux-x86_64/sysrootCROSS_PREFIX=$TOOLCHAIN/bin/aarch64-linux-android-PREFIX=$(pwd)/android/$CPUOPTIMIZE_CFLAGS=&quot;-march=$CPU&quot;build_android#armv7-aARCH=armCPU=armv7-aAPI=21CC=$TOOLCHAIN/bin/armv7a-linux-androideabi$API-clangCXX=$TOOLCHAIN/bin/armv7a-linux-androideabi$API-clang++SYSROOT=$NDK/toolchains/llvm/prebuilt/linux-x86_64/sysrootCROSS_PREFIX=$TOOLCHAIN/bin/arm-linux-androideabi-PREFIX=$(pwd)/android/$CPUOPTIMIZE_CFLAGS=&quot;-mfloat-abi=softfp -mfpu=vfp -marm -march=$CPU &quot;build_android 配置介绍通过执行 ./configure --help 能得到所有的配置选项，整个配置也非常好理解，通过 list-xxx 可以知道有哪些子选项，然后再通过 --disable-xxx,或者 --enable-xxx 进行关闭或者打开。以解码为例： --disable-decoders # 先关闭所有的解码器--enable-decoder=flv # 然后只打开flv、mpeg4 的支持--enable-decoder=mpeg4 对于--enable-decoder=xxx中的xxx可以通过 ./configure --list-decoders 进行查看，同理 encoders demuxers muxers 等都是类似的处理，通过 --help 可以通过 list--xxx 查看不同功能的可以支持的配置，主要有以下： --list-decoders show all available decoders--list-encoders show all available encoders--list-hwaccels show all available hardware accelerators--list-demuxers show all available demuxers--list-muxers show all available muxers--list-parsers show all available parsers--list-protocols show all available protocols--list-bsfs show all available bitstream filters--list-indevs show all available input devices--list-outdevs show all available output devices--list-filters show all available filters 其他的配置就是一些实际性的开关配置，列一些常用的配置： 配置产物为静态库(.a)或者动态库(.so) --enable-static do not build static libraries [no]--enable-shared build shared libraries [no] 配置减少包大小--enable-small optimize for size instead of speed --enable-small 的配置项，其实是在config.h里声称了CONFIG_SMALL选项，然后代码内根据CONFIG_SMALL做了一些调整，比如某些string类型就被省掉了，还有一些内置生成的table, 体积也被裁减掉了，用速度换体积。比如这里：#if CONFIG_SMALL#define CRC_TABLE_SIZE 257#else#define CRC_TABLE_SIZE 1024#endif 配置FFmpeg协议，由于我们使用本地文件，需要再加一个： --enable-protocol=file，要不然解码会报协议相关错误 --disable-protocols disable all protocols 我们只需要在代码中使用 FFmpeg，所以直接禁用命令行工具--disable-programs do not build command line programs--disable-ffmpeg disable ffmpeg build--disable-ffplay disable ffplay build--disable-ffprobe disable ffprobe build 还有几个比较重要的就是，主要是--disable-avdevice disable libavdevice build--disable-swresample disable libswresample build--disable-swscale disable libswscale build--disable-postproc disable libpostproc build--disable-avfilter disable libavfilter build 编译遇见的坑1、aarch64-linux-android21-clang is unable to create an executable file.C compiler test failed. 这个问题是困扰我最久的，按照解决方法：原因 1： FFmpeg 4.2.2 版本默认使用了 clang 进行编译解决： //1\\. 修改 configure 文件vim configure//2\\. 把 默认的 clang 修改为 gccif test &quot;$target_os&quot; = android; then # cc_default=&quot;clang&quot; cc_default=&quot;gcc&quot;fi 原因2，检查路径是否正确，主要是 NDK 的位置，以及不同 NDK 相关库可能存在一定的丢失。 这个问题我在 macOS 上未解决，换用 CentOS 没有出现过这个编译问题。 2、 编译包大小一直不变 最开始我正常编译的时候发现怎么改配置，最后的包大小都没有发生变化，但是命令行里面各种流程又是在走，最终也有产物。这里一定要关注在执行了编译脚本之后，查看最开始的日志，看看具体是一些什么错，这里日志会刷得很快，如果包大小一直没有发生变化的话，可以执行完之后快速停止，看看是什么错。一般就是C compiler test failed. 或者找不到你的配置，改对即可。正常编译，会在开始后列出你的编译配置。 3、x86asm 相关的问题 编译的时候遇到一些 x86asm 的错，按照文章所说即可","categories":[],"tags":[{"name":"FFmpeg","slug":"FFmpeg","permalink":"http://vompom.github.com/tags/FFmpeg/"}],"author":"落叶挽歌"},{"title":"3D LUT 滤镜 shader 源码分析","slug":"LUT-Shader-源码分析","date":"2022-11-24T03:36:00.000Z","updated":"2025-09-15T13:11:04.747Z","comments":true,"path":"2022/11/24/LUT-Shader-源码分析/","permalink":"http://vompom.github.com/2022/11/24/LUT-Shader-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/","excerpt":"","text":"最近在做滤镜相关的渲染学习，目前大部分 LUT 滤镜代码实现都是参考由 GPUImage 提供的 LookupFilter 的逻辑，整个代码实现不多。参考网上的博文也有各种解释，参考了大量博文之后终于理解了，所以自己重新整理了一份，方便以后阅读理解，对整体代码的实现过程结合LUT的原理进行一个简单整理。 GPUImageLookupFilter shader 源码varying highp vec2 textureCoordinate; varying highp vec2 textureCoordinate2;uniform sampler2D inputImageTexture; // 目标纹理，对应原始资源uniform sampler2D inputImageTexture2; // 查找表纹理，对应LUT图片uniform lowp float intensity;void main()&#123; //获取原始图层颜色 highp vec4 textureColor = texture2D(inputImageTexture, textureCoordinate); //获取蓝色通道颜色，textureColor.b 的范围为(0,1)，blueColor 范围为(0,63) highp float blueColor = textureColor.b * 63.0; //quad1为查找颜色所在左边位置的小正方形 highp vec2 quad1; quad1.y = floor(floor(blueColor) / 8.0); quad1.x = floor(blueColor) - (quad1.y * 8.0); //quad2为查找颜色所在右边位置的小正方形 highp vec2 quad2; quad2.y = floor(ceil(blueColor) / 8.0); quad2.x = ceil(blueColor) - (quad2.y * 8.0); //获取到左边小方形里面的颜色值 highp vec2 texPos1; texPos1.x = (quad1.x * 0.125) + 0.5/512.0 + ((0.125 - 1.0/512.0) * textureColor.r); texPos1.y = (quad1.y * 0.125) + 0.5/512.0 + ((0.125 - 1.0/512.0) * textureColor.g); //获取到右边小方形里面的颜色值 highp vec2 texPos2; texPos2.x = (quad2.x * 0.125) + 0.5/512.0 + ((0.125 - 1.0/512.0) * textureColor.r); texPos2.y = (quad2.y * 0.125) + 0.5/512.0 + ((0.125 - 1.0/512.0) * textureColor.g); //获取对应位置纹理的颜色 RGBA 值 lowp vec4 newColor1 = texture2D(inputImageTexture2, texPos1); lowp vec4 newColor2 = texture2D(inputImageTexture2, texPos2); //真正的颜色是 newColor1 和 newColor2 的混合 lowp vec4 newColor = mix(newColor1, newColor2, fract(blueColor)); gl_FragColor = mix(textureColor, vec4(newColor.rgb, textureColor.w), intensity);&#125; 整个源码的主要逻辑为：查找颜色所在位置的小正方形、查找小正方形内的具体颜色、颜色混合。上面注释已将具体的实现过程描述清楚，但与我们的 LUT 图片割裂，接下来结合 LUT 的实现原理以及具体的数据来形象地描述整个实现流程。 假设我们输入的参数为：textureColor = ver4(.0, .0, 0.5, 1.0) 查找颜色所在位置的小正方形我们知道LUT有64个小正方形，目标是为了找到对应小正方形里面的对应的颜色，我们需要先确认是第几个小正方形，正是通过 textureColor.b * 63 查找 带入blueColor -&gt; textureColor.b = 0.5对 textureColor.b * 63.0 = 31.5 也就是说我们需要第 [31.5] 位置小正方形，但是索引(从0-63共64个)都是正数，对于 31.5 索引 我们该怎么确定是 31 还是第 32 个呢？GPUImage给出的一种插值方式就是两个都要，然后进行一次混合，从而使得值能够俊均匀的在两个小正方形色块中。 具体逻辑为： quad1.y = floor(floor(blueColor) / 8.0) = 3，确定为小方块在纵坐标索引3，也就是第4行。 quad1.x = floor(blueColor) - (quad1.y * 8.0) = 31 - 24 = 7 也就确定了小方块为(3,7) 也就是第4排第8个。 同理，对于第2个小方块确定的位置为(4,0) 也就是第5排第1个。 quad2.y = floor(ceil(blueColor) / 8.0) = 4 quad2.x = ceil(blueColor) - (quad2.y * 8.0)= 0 查找小正方形内的具体颜色已经获取到对应的方块了，接下来需要确定方块内的像素的位置了。一般一个LUT的大小为 512x512，由8x8小方块构成，也就是每个方块的的像素为64x64，如下图所示： 计算x坐标的逻辑为： texPos1.x = (quad1.x * 0.125) + 0.5/512.0 + ((0.125 - 1.0/512.0) * textureColor.r) 这一段是相对比较难理解的，我们可以分几部分进行理解： 第一部分：(quad1.x * 0.125) 我们得到 quad1.x = 7，也就是第8列，*0.125将坐标转化在(0,1)之间，也就是得到在01坐标系内如图红线的位置。 第二部分：((0.125 - 1.0/512.0) * textureColor.r) 我们可以把它当成 (63.0/512.0)* textureColor.r , 63.0/512.0代表着一个512x512中每个小方块的64份数据（为什么是63？别忘了0的存在），textureColor.r 数据在 0-1之间，这样就能确认在第一部分结果基础之上的偏移值。 第三部分：0.5/512.0 这一部分主要是 +0.5 做四舍五入运算，为保证第512行取到的是511.5/512，第1行取到的是 0.5/512.0。 同理，计算y的坐标，以及计算另一个小正方形内的位置是一样的。 最后在通过对从两个小正方形获取到的颜色进行 mix，并返回给着色器，GPU再对原始图像进行每一个像素点绘制，从而实现滤镜的效果。 总结LUT 对应的 Shader 执行过程主要为：查找颜色所在位置的小正方形、查找小正方形内的具体颜色、颜色混合，整个流程都比较好理解，但代码相对而言比较难理解，网上看了很多其他的大佬写的一些文章，最开始自己看的时候也是很难理解的，后面终于悟了，所以想通过自己的理解，尽力更形象地解释（虽然可能也没有很形象），如果还有什么疑问，欢迎一起交流学习。","categories":[{"name":"技术文章","slug":"technology","permalink":"http://vompom.github.com/categories/technology/"}],"tags":[{"name":"音视频","slug":"音视频","permalink":"http://vompom.github.com/tags/%E9%9F%B3%E8%A7%86%E9%A2%91/"}],"author":"落叶挽歌"},{"title":"Unity 实现利用 Andorid 能力进行视频渲染播放","slug":"Unity-实现利用-Andorid-能力进行视频渲染播放","date":"2022-10-25T02:00:00.000Z","updated":"2025-09-15T13:10:48.829Z","comments":true,"path":"2022/10/25/Unity-实现利用-Andorid-能力进行视频渲染播放/","permalink":"http://vompom.github.com/2022/10/25/Unity-%E5%AE%9E%E7%8E%B0%E5%88%A9%E7%94%A8-Andorid-%E8%83%BD%E5%8A%9B%E8%BF%9B%E8%A1%8C%E8%A7%86%E9%A2%91%E6%B8%B2%E6%9F%93%E6%92%AD%E6%94%BE/","excerpt":"","text":"在 Unity 中使用 Android 侧提供的视频渲染相关的能力，有两种方案可选： 第一种是将渲染播放页单独做一个页面，在 Unity事件交互的时候打开对应 Activity 页面，或者获取到 Unity 创建的 Acitivity 动态添加 View。 第二种是只借助 Android 的渲染能力，将数据渲染到 Unity 的控件上。 两种方案各有优劣，第一种大大地减少了播放器相关的开发工作量，整个页面逻辑可以实现复用，但是交互页面的话 iOS/Android 需要写两套。第二种实现成本相对较高，但是交互可以由 Unity 侧进行，只是播放器使用封装好的 plugin 进行，能达到交互相对较统一，本文也主要是讲述该方案的实现。 Android 平台基本播放逻辑在正式开发改造之前，对 Android 侧的一个播放器渲染流程进行简单的介绍，以 MediaPlayer 为例，利用 MediaPlayer 进行视频解码渲染，并将视频最后输出到 SurfaceView 上,一次播放器视频渲染到View上的的主要代码流程为： public void initPlayer() &#123; MediaPlayer mediaPlayer = new MediaPlayer(); SurfaceView surfaceView = new SurfaceView(activity); surfaceHolder = surfaceView.getHolder(); surfaceHolder.addCallback(^ &#123; @Override public void surfaceCreated(SurfaceHolder holder) &#123; Surface surface = holder.getSurface(); mediaPlayer.setSurface(surface); mediaPlayer.prepareAsync(); &#125; …… &#125;); mediaPlayer.setDataSource(URI...); mediaPlayer.setOnPreparedListener(mp -&gt; mp.start()); &#125; 对于渲染 mediaPlayer.setSurface(surface) 设为播放器解码数据的接受器，Surface 来自于 SurfaceView。 播放器是将数据图形绘制在 Surface 对象上，Surface中会关联一个 BufferQueue 用于提供图像数据缓存，SurfaceFlinger 会把 Surface 对应的图像层混合在一起，将其输出到 FrameBuffer 中（Framebuffer就是一块内存区域，它通常是显示驱动的内部缓冲区在内存中的映射），最后在屏幕上看到合成的图像。 整个流程引入外部大佬的一张图所示： Unity 中的一些改造上面的流程最终是通过播放器解码渲染到 SurfaceView 上，当然，你可以通过获取到 UnityPlayer 对应的 Acitivity 将这个 SurfaceView 动态添加到当前界面，实现“在 Unity 中利用 Android 能力进行视频渲染”。 所以需要对其进行改造，我们的目的是实现 Android 播放器数据渲染到 Untiy 的组件中。实现这一过程需要借助 FBO(Frame Buffer Object) 的能力。 （一）FBO在 OpenGL 渲染管线中几何数据和纹理经过变换和一些测试处理，最后以二维像素的形式显示在屏幕上。OpenGL管线的最终渲染目的地被称作帧缓存(framebuffer)，OpenGL渲染管线的最终位置是在帧缓冲区中，默认情况下 OpenGL 使用的是窗口系统提供的帧缓冲区。 但有些场景是不想要直接渲染到窗口上的(例如加视频特效)，于是 OpenGL 提供了一种方式来创建额外的帧缓冲区对象(FBO)。使用帧缓冲区对象，OpenGL 可以将原先绘制到窗口提供的帧缓冲区重定向到 FBO 之中。FBO本身不是一块内存，没有空间，真正存储东西，可实际读写的是依附于FBO的东西：纹理(texture)和渲染缓存(renderbuffer)，依附的方式，是一个二维数组来管理，结构如图所示： （二）具体实现使用 FBO 我们可以将渲染目标渲染到其他的空间，我们目的是将播放器解码后的数据渲染到 Unity 控件的纹理空间中。渲染播放器将输出到 FBO 中，FBO 指向 Unity 控件数据的输入，从而实现：Android 的播放器输出数据显示到 Unity 的控件中。 （三）从渲染输出数据到外部纹理由于 mediaPlayer.setSurface(surface) 对应的 Surface 来源于 SurafaceView，会直接渲染到屏幕上，这里我们需要使用 构造一个新的 SurfaceTexture 以将图像流式传输到给定的 OpenGL 纹理; 要获取到播放器渲染得数据，需要借助 SurfaceTexture ，SurfaceTexture 是Surface 和 OpenGL ES 纹理的结合，其对图像流的处理并不直接显示，而是从图像流中捕获帧作为 OpenGL 的外部纹理，图像流来自相机预览和视频解码。 SurfaceTexture 创建的 Surface 是数据的生产者，而 SurfaceTexture 是对应的消费者，Surface 接收媒体数据并将数据发送到 SurfaceTexture，当调用 updateTexImage 的时候，创建SurfaceTexture 的纹理对象相应的内容将更新为最新图像帧，也就是会将图像帧转换为 GL 纹理，并将该纹理绑定到 GL_TEXTURE_EXTERNAL_OES 纹理对象上。具体实现逻辑参考：Android Opengl OES 纹理渲染到 GL_TEXTURE_2D SurfaceTexture surfaceTexture = new SurfaceTexture(videoTextureId);player.setUpSurface(new Surface(surfaceTexture), width, height);surfaceTexture.setDefaultBufferSize(width, height);surfaceTexture.setOnFrameAvailableListener(surfaceTexture -&gt; &#123;……&#125;);; 其中 videoTextureId 来源于创建的 OES 纹理： public static int createOESTextureID() &#123; int[] texture = new int[1]; // 创建纹理对象，一个容器对象，保存渲染所需要的纹理数据，例如：图像数据 //在OpenGL 中纹理对象是一个无符号整数，是一个纹理对象的句柄 GLES30.glGenTextures(texture.length, texture, 0); // 绑定纹理ID到纹理单元的纹理目标上 GLES30.glBindTexture(GLES11Ext.GL_TEXTURE_EXTERNAL_OES, texture[0]); // 设置纹理参数 …… GLES30.glGenerateMipmap(GLES11Ext.GL_TEXTURE_EXTERNAL_OES); return texture[0]; &#125; （四）FBO纹理数据到 Unity 的纹理数据学习了解到Unity中可以使用 RawImage 或者 quad 等相关控件可以显示纹理，这里以 RawImage 为例。在 Unity 脚本编写初始化的逻辑，构造一个 Texture2D 对象，将句柄传递到 Android，并赋值给 RawImage，并将texture id 传递到 Android 平台，完成一次渲染的重定向。 void InitPlayer() &#123; Texture2D texture2D = new Texture2D(width, height, TextureFormat.RGB24, false, false); androidObj.Call(&quot;init&quot;, (int)texture2D.GetNativeTexturePtr(), width, height); RawImage.texture = texture2D;&#125; 创建FBOpublic static int createFBO() &#123; int[] fbo = new int[1]; GLES30.glGenFramebuffers(fbo.length, fbo, 0); return fbo[0];&#125; 为SurfaceTexture 设置了 OnFrameAvailableListener 后，当有新的图形流数据生成之后，就可以通过 mSurfaceTexture.updateTexImage() 将当前图片流更新到纹理所关联的OpenGLES中纹理，并绘制 FBO. publc void draw() &#123; //1. 绑定 FrameBuffer 到当前的绘制环境上， 后续 GL 绘制都会到这个 framebuffer GLES20.glBindFramebuffer(GLES20.GL_FRAMEBUFFER, fbo[0]); //2.把一个2D纹理作为帧缓冲区附着 //即所有渲染操作的结果将会被储存在 unityTextureId 对应的纹理图像中 GLES20.glFramebufferTexture2D(GLES20.GL_FRAMEBUFFER, GLES20.GL_COLOR_ATTACHMENT0, GLES20.GL_TEXTURE_2D, unityTextureId, 0); //绑定指定纹理到当前激活的纹理单元 GLES20.glBindTexture(GLES11Ext.GL_TEXTURE_EXTERNAL_OES, videoTextureId); //…… 省略 Opengl 绘制的常规流程&#125; 这一步是最关键的，实现了将 FBO 的输出指向 Unity 里面创建的纹理，也就实现了 Android 渲染与 Unity 之间的数据打通。 这里的 unityTextureId 来源于在 Unity 中初始化的 (int)texture2D.GetNativeTexturePtr()值。 整体的流程为： 效果图： 图中播放视频区域为 Unity 的 RawImage 控件，渲染的视频通过 Pag 等相关素材由渲染SDK合成。 如图所示，视频画面正常地进行渲染，图中有两个区域展示了视频画面，上面的使用的 Quad 组件，下面是用的 RawImage，流程都一直，只是在 Unity 使用 Texture2D 的时候通过 Quad.mainTexture = texture2D 赋值。 总结本文主要讲了 Unity 利用 Android 提供的能力进行视频相关的特效渲染的方案，总体正常运行。还需要一些优化，例如对 Multithreaded Rendering配置还未支持，以及一些逻辑可能受限于游戏侧的配置，例如图形渲染的配置使用的 OpenGL3.0，如果使用 OpenGL2.0 或者 Vulkan，还需要单独调整相关逻辑。","categories":[{"name":"技术文章","slug":"technology","permalink":"http://vompom.github.com/categories/technology/"}],"tags":[{"name":"音视频","slug":"音视频","permalink":"http://vompom.github.com/tags/%E9%9F%B3%E8%A7%86%E9%A2%91/"},{"name":"Unity","slug":"Unity","permalink":"http://vompom.github.com/tags/Unity/"}],"author":"落叶挽歌"},{"title":"我写了一个场所码小工具（上海实用）","slug":"写了一个场所码小工具","date":"2022-07-03T15:14:00.000Z","updated":"2025-05-20T11:46:57.000Z","comments":true,"path":"2022/07/03/写了一个场所码小工具/","permalink":"http://vompom.github.com/2022/07/03/%E5%86%99%E4%BA%86%E4%B8%80%E4%B8%AA%E5%9C%BA%E6%89%80%E7%A0%81%E5%B0%8F%E5%B7%A5%E5%85%B7/","excerpt":"","text":"随着新冠疫情的常态化，以上海为例，出示健康码、扫码场所码已经成了每天进出地铁、公司必备操作。对于上班工作，每天的场所码都是同一个地点，对应的场所码图片也不会发生变化，每次扫场所码的时候要不就是前面有很多人一起挤着，或者遇到下雨天不方便等情况。对于我自己而言，我会把场所码保存下来，方便下一次“扫场所码”，但由于存在图库，每次依然需要打开支付宝或者微信选择对应的图片进行扫描，所以就做了个工具，实现：一键打开健康码、自动保存场所码、一键打开存储的场所码。 小工具使用 如图所示提供两个按钮： 扫一扫 扫一扫主要是为了扫场所码，它会扫码对应的二维码图片进行扫描（或者从相册进行读取），识别到对应的场所码信息会自动跳转到支付宝（当前只支持打开支付宝的场所码），并将这一次的结果保存到数据库中。如果下次需要同一个场所码，可以从列表中选择对应的场所码数据并点击直接跳转到场所码，不需要再进行手动扫描。 健康码 主要是实现一键打开健康码功能 对于场所码的信息，在第一次添加的过程中会弹出提示框提示修改场所码的信息进行备注，当然也可以在对应的类目左滑进行编辑操作。 下载整个实现是使用Flutter写的，能实现跨平台，但由于iOS需要开发者证书相关上架AppStore较为麻烦，暂时没法进行分发。 Android 同学可以扫描下面的二维码进行体验使用，或者点击 场所码小助手去该页面下载","categories":[],"tags":[],"author":"落叶挽歌"},{"title":"FFmpeg之AVFrame转Android Bitmap","slug":"FFmpeg之AVFrame转Android-Bitmap","date":"2022-05-22T13:03:00.000Z","updated":"2025-09-15T13:06:47.170Z","comments":true,"path":"2022/05/22/FFmpeg之AVFrame转Android-Bitmap/","permalink":"http://vompom.github.com/2022/05/22/FFmpeg%E4%B9%8BAVFrame%E8%BD%ACAndroid-Bitmap/","excerpt":"","text":"此前很多工作都设计到使用 FFmpeg 对视频帧进行获取，在 FFmpeg 解码视频文件获取到帧数据结构是 AVFrame, 对于应用层我们没有办法直接拿到进行数据处理，需要转换为 Android 平台特有的处理结构。而我是需要对应的帧图片数据，那么在 Android 侧需要将其转化为 Bitmap ,之前整理的过程中发现了这篇《Android音视频开发】从AVFrame到MediaFrame数组(二)》博客文章 ，觉得写得很不错，非常精简，适合我的需求，于是对齐进行整理，并标注一下自己在过程中遇到的一些坑点。 Native层创建BitmapBitmap 是对 SkBitmap 的包装。具体说来， Bitmap 的实现包括 Java 层和 JNI 层，JNI 层依赖 Skia，SkBitmap 本质上可简单理解为内存中的一个字节数组 想要生成 Bitmap, 我们首先需要构造一个 Bitmap 对象，Java层有很多种方式可以生成Bitmap对象，最简单的方式如下： Bitmap.createBitmap(width,height,new Bitmap.Config.ARGB_8888) 由于整个 FFmpeg的操作在 JNI 侧进行，对应的操作需要使用 JNIEnv 进行相关的调用，主要逻辑如下： jobject create_bitmap(JNIEnv *env, int width, int height) &#123; // 找到 Bitmap.class 和 该类中的 createBitmap 方法 jclass clz_bitmap = env-&gt;FindClass(&quot;android/graphics/Bitmap&quot;); jmethodID mtd_bitmap = env-&gt;GetStaticMethodID( clz_bitmap, &quot;createBitmap&quot;, &quot;(IILandroid/graphics/Bitmap$Config;)Landroid/graphics/Bitmap;&quot;); // 配置 Bitmap jstring str_config = env-&gt;NewStringUTF(&quot;ARGB_8888&quot;); jclass clz_config = env-&gt;FindClass(&quot;android/graphics/Bitmap$Config&quot;); jmethodID mtd_config = env-&gt;GetStaticMethodID( clz_config, &quot;valueOf&quot;, &quot;(Ljava/lang/String;)Landroid/graphics/Bitmap$Config;&quot;); jobject obj_config = env-&gt;CallStaticObjectMethod(clz_config, mtd_config, str_config); // 创建 Bitmap 对象 jobject bitmap = env-&gt;CallStaticObjectMethod( clz_bitmap, mtd_bitmap, width, height, obj_config); return bitmap;&#125; 获取Bitmap像素数据地址，并锁定void *addr_pixels;AndroidBitmap_lockPixels(env, bitmap, &amp;addr_pixels); 解释一下这两句话： 第一句的作用声明并定义一个指向任意类型的指针变量，名称是addr_pixels。我们定义它的目的，是让它指向bitmap像素数据(即:addr_pixels的值为bitmap像素数据的地址)。注意哦，这时候，addr_pixels的值是一个随机的值(假定此时为：0x01)，由系统分配，它还不指向bitmap像素数据。第二句话的作用就是将bitmap的像素数据地址赋值给addr_pixels，此时它的值被修改(假定为：0x002)。并且锁定该地址，保证不会被移动。【注：地址不会被移动这里我也不太懂什么意思，有兴趣的可以去查看该方法的API文档】【注：】此时的bitmap由像素数据的地址，但是该地址内还没有任何像素数据哦，或者说它的像素数据为\\0 到这里，我们已经有了源像素数据在AVFrame中，有了目的像素数据地址addr_pixels，那么接下来的任务就是将AVFrame中的像素数据写入到addr_pixels指向的那片内存中去。 向Bitmap中写入像素数据这里要说一下，我们获取到的AVFrame的像素格式通常是YUV格式的，而Bitmap的像素格式通常是RGB格式的。因此我们需要将YUV格式的像素数据转换成RGB格式进行存储。而RGB的存储空间Bitmap不是已经给我门提供好了吗？嘿嘿，直接用就OK了，那现在问题就是YUV如何转换成RGB呢？关于YUV和RGB之间的转换，我知道的有三种方式： 通过公式换算 FFmpeg提供的libswscale Google提供的libyuv这里我们选择libyuv因为它的性能好、使用简单。 说它使用简单，到底有多简单，嘿，一个函数就够了！！ libyuv::I420ToABGR(frame-&gt;data[0], frame-&gt;linesize[0], // Y frame-&gt;data[1], frame-&gt;linesize[1], // U frame-&gt;data[2], frame-&gt;linesize[2], // V (uint8_t *) addr_pixels, linesize, // RGBA frame-&gt;width, frame-&gt;height); 解释一下这个函数： I420ToABGR: I420表示的是YUV420P格式，ABGR表示的RGBA格式(execuse me?? 是的，你没看错，Google说RGBA格式的数据在底层的存储方式是ABGR，顺序反过来，看下libyuv源码的函数注释就知道了) frame-&gt;data&amp;linesize: 这些个参数表示的是源YUV数据，上面有标注 (uint8_t *) addr_pixels: 嘿，这个就是说往这块空间里写入像素数据啦 linesize: 这个表示的是该图片一行数据的字节大小，Bitmap按照RBGA格式存储，也就是说一个像素是4个字节，那么一行共有：frame-&gt;width 个像素，所以：linesize = frame-&gt; width * 4 【注：】关于这一小块功能的实现，可能其他地方你会看到这样的写法，他们用了如下接口： // 思路 是：新建一个AVFrame(RGB格式)，通过av_image_fill_arrays来实现AVFrame(RGB)中像素数据和Bitmap像素数据的关联，也就是让AVFrame(RGB)像素数据指针等于addr_pixelspRGBFrame = av_frame_alloc() av_image_get_buffer_size()av_image_fill_arrays() /我也是写到这里的时候，才想到这个问题，为什么要这样用呢，直接使用addr_pixels不是也一样可以么？不过大家都这么用，应该是有它不可替代的使用场景的。因此这里也说一下av_image_fill_arrays这个函数。 / // TODO: 解释下这个函数的作用 av_image_fill_arrays(dst_data, dst_linesize,src_data, pix_fmt, width, height, align); 它的作用就是 根据src_data，设置dst_data，事实上根据现象或者自己去调试，可以发现dst_data的值就是src_data的值(我印象中好像值是相同的，这会我忘了，后面我再验证下) 根据pix_fmt, width, height设置linesize的值，其实linesize的计算就和我上面给出的那个公式是一样子的值 OK, 函数执行完毕，我们Bitmap就有了像素数据，下面就是把Bitmap上传给Java层 Native回调Java接口说下Java层 有一个MainActivity.java用于界面的显示有一个JNIHelper.java用于Java层和Native层的沟通 public class JNIHelper &#123; public void onReceived(Bitmap bitmap)&#123; // TODO: Java层接收到Bitmap后，可以开始搞事情了 &#125;&#125; Native层的回调代码如下： jclass clz = env-&gt;FindClass(&quot;me/oogh/xplayer/JNIHelper&quot;);jmethodID method = env-&gt;GetMethodID(clz, &quot;onReceived&quot;, &quot;(Landroid/graphics/Bitmap;)V&quot;);env-&gt;CallVoidMethod(obj, method, bitmap); AndroidBitmap_lockPixels 方法以上就是整个文章的内容，使用起来也是 no problem! 但使用过程中遇到的问题就是内存回收的问题，最开始使用的时候并没有过多关注JNI层 AndroidBitmap_lockPixels这个方法，以至于后来我在处理Bitmap内存回收上遇到了一些问题。 AndroidBitmap_lockPixels 与之对应还有一个 AndroidBitmap_unlockPixels AndroidBitmap_lockPixels “函数作用锁定了像素缓存以确保像素的内存不会被移动”，这句话看起来好像挺难理解，但是我们在 Java层面有与之类似的操作，那就是 SurfaceHolder.lockCanvas()，还记得我们在绘制的过程中需要先使用 lockCanvas 锁定画布，返回的画布对象Canvas然后使用 unlockCanvasAndPost(Canvas canvas) 结束锁定画布，并提交改变。AndroidBitmap_lockPixels 与 AndroidBitmap_unlockPixels做的是类似的事情，都是锁住一块内存区域，保证其安全。 回到上面说的内存回收的问题，由于自己使用失误，流程大概是这样： AndroidBitmap_lockPixels(env, bitmap, &amp;addr_pixels);//在两者之间，将生成好的 Bitmap Obj 回调到Java层AndroidBitmap_unlockPixels(env, bitmap); 然后在Java层有这样的逻辑： public void onReceived(Bitmap bitmap)&#123; //……一些业务逻辑 //我们习惯性对bitmap使用recycle对其数据进行回收…… bitmap.recycle()&#125; 但是我发现使用了 bitmap.recycle()与不使用，内存中 Native区域仍然占了一大部分，后来在AndroidBitmap_lockPixels的注释才发现不对的地方： /** * Given a java bitmap object, attempt to lock the pixel address. * Locking will ensure that the memory for the pixels will not move * until the unlockPixels call, and ensure that, if the pixels had been * previously purged, they will have been restored. * * If this call succeeds, it must be balanced by a call to * AndroidBitmap_unlockPixels, after which time the address of the pixels should * no longer be used. * * If this succeeds, *addrPtr will be set to the pixel address. If the call * fails, addrPtr will be ignored. */int AndroidBitmap_lockPixels(JNIEnv* env, jobject jbitmap, void** addrPtr); 其中： if the pixels had been previously purged, they will have been restored. 也就是说在AndroidBitmap_unlockPixels 调用之前，如果像素数据被销毁了，他们会被恢复！至于为什么会被恢复，这个就需要之后再进行研究了。 后来对逻辑进行更改，将 Bitmap.recycle()的逻辑移动到 AndroidBitmap_unlockPixels之后。","categories":[{"name":"技术文章","slug":"technology","permalink":"http://vompom.github.com/categories/technology/"}],"tags":[{"name":"FFmpeg","slug":"FFmpeg","permalink":"http://vompom.github.com/tags/FFmpeg/"},{"name":"音视频","slug":"音视频","permalink":"http://vompom.github.com/tags/%E9%9F%B3%E8%A7%86%E9%A2%91/"}],"author":"落叶挽歌"},{"title":"记一次Android依赖库版本不兼容的问题处理过程","slug":"记一次Android依赖-wire-低版本与高版本不兼容的处理过程","date":"2022-03-31T02:47:00.000Z","updated":"2025-05-20T11:46:57.000Z","comments":true,"path":"2022/03/31/记一次Android依赖-wire-低版本与高版本不兼容的处理过程/","permalink":"http://vompom.github.com/2022/03/31/%E8%AE%B0%E4%B8%80%E6%AC%A1Android%E4%BE%9D%E8%B5%96-wire-%E4%BD%8E%E7%89%88%E6%9C%AC%E4%B8%8E%E9%AB%98%E7%89%88%E6%9C%AC%E4%B8%8D%E5%85%BC%E5%AE%B9%E7%9A%84%E5%A4%84%E7%90%86%E8%BF%87%E7%A8%8B/","excerpt":"","text":"此前我们项目组开发了相关 SDK 并集成到 App 工程中进行测试，发现业务App中的 wire (一个与 protobuf 相关的库)，版本为1.5.1，而 SDK 中所依赖的版本为3.7.0，两者之间相互不兼容。如果要让业务升级到高版本的库的话，初步排查低版本中使用的某个类而高版本中已废除，单纯的就这一个类涉及100多个文件，工程量太大了，SDK中亦然。所以不能通过简单地更改版本号来解决版本冲突问题，最后经过一系列的尝试，终于解决了该问题。 分析和处理最初集成 SDK 到 App 运行时发现报错：java.lang.NoClassDefFoundError: Failed resolution of: Lcom/squareup/wire/ProtoEnum;检查代码发现 ProtoEnum位于wire 1.5.1中，打印依赖树发现App中的库被SDK所依赖的库给覆盖掉了，自动升级到新的版本，但新的版本又不存在该类。 | | | \\--- com.squareup.wire:wire-runtime:1.5.1 -&gt; 3.7.0 以为只是简单的版本冲突的问题，尝试解冲突，我们知道处理Android版本冲突主要使用 exclude``transitive force gralde 处理依赖的关键字解决依赖冲突，但我无论使用什么操作整个项目中所打出来的Apk只存在一个版本：要么1.5.1要么3.7.0，对比两个库：发现高版本相比于低版本多了太多的类，以及一部分类进行了改名，至此我们可以得出一个结论：wire库高版本(3.7.1)与低版本(1.5.1)完全不兼容。 现在摆在我面前有两条路可以走： 一、手动升级App中的低版本 二、手动降级SDK中的高版本 对于第一种，发现到App中大量文件使用 Wire 中的 Message 类，虽然两个版本都有Message类，但是两者“今非昔比”，涉及到太多的方法改动，而 Message 类在App有100+文件使用，如果一个个改过去，可能XXXXXXXX了。 两个库之间有这么大的差异，甚至1.X版本不支持kotlin，而SDK中大量代码都是使用的 Kotlin，那么第二种降低SDK的高版本也自然变得不太现实。 向大佬们请教，有被指点到：是否可以通过 ffat-aar+混淆的方式将 wire库跟SDK合并打包到一起？ ！！大佬毕竟大佬，我的脑子瞬间有一种叮咚的感觉，其实这种方式也就是将SDK变向的重命名，将两个不同的版本库进行“共存”，现在要做的就是：将 SDK 中的高版本的库包名给改掉，以达到两个不同版本库之间的兼容。 说干就干，打好了库之后运行发现： java.lang.RuntimeException: Duplicate class a.a.a.a found in modulesetified-target-SDK-0.0.1.11-SNAPSHOT-runtime.jarand ctlogin-0.4.23.04_lol_47-runtime.jar(clogin-sso.clogin:0.4.23.04_lol_47) 我当时内心就是这个表情,心想：难道wtlogin 大佬们也是想采用这种方式来避免一些库的兼容问题？这问题不大，因为混淆默认从a-z进行命名，只要给混淆再配一些参数就能避免掉这个问题，于是加上以下参数-obfuscationdictionary obfucationdictionary.txt-classobfuscationdictionary obfucationdictionary.txt-packageobfuscationdictionary obfucationdictionary.txt当再次运行的时候，发现又报错了： java.lang.NoClassDefFoundError: Failed resolution of: Lcom/squareup/wire/ProtoAdapter; ？？？ProtoAdapter 是属于3.7.0高版本的类，不是已经被混淆了么？为什么还会报这个错？难道是使用混淆的方式是不行的？于是继续搜寻解决方案，了解到使用 jarjar.jar可以对包重新命名打包，尝试了一下运行，依然报错java.lang.NoClassDefFoundError: Failed resolution of: Lcom/squareup/wire/ProtoAdapter; 到底哪里还有 使用 com/squareup/wire/ProtoAdapter呢？使用jd-gui对重新打好的 jar 包的内容进行搜索.果然有搜到相应的内容，这是一个字符串，第一反应就是反射。我瞬间明白了，这是一串字符串并且是写死的，回到App中来，如下图所示：wire库的作用是将 .proto 文件生成咱们通常所说的 Model 类，下图的 AudioEffect就是通过 .proto 文件中定义好的属性生成的。那该怎么办呢？就一个依赖库版本冲突的问题，常规的方法就这些呀，难道真的要肝一波了么？到这里我们大概知道是怎么回事了，我们的目标很简单，就是改一个包名，但是包又在 wire-gradle-plugin 插件中，所以改wire的运行库当然是不行的…… 那还有一个终极办法：改源码。 说干就干，直接拉 wire 源码 ，主要关注以下几个目录：wire-gradle-plugin: wire-gradle 插件的主要源码wire-compiler: wire编译.proto相关的操作wire-runtime: wire运行时所需要的类接下来要做的就是 右键+rename,重新编译打包，也……就1000多处改动 打完包之后发现整个插件生成出来类的包还是包含&quot;com.squareup.wire.ProtoAdapter&quot;，我的目标是生成：&quot;com.squareup.xxxx_.ProtoAdapter&quot;，跟wire-plguin-gradle的源码，发现有这么一处： 它回在运行中重新从仓库中拉取com.squareup.wire:wire-runtime:3.7.0，于是需要对整个wire-runtime也重新打包，最终生成了一系列jar包如下所示：然后将其作为 plugin classpath files(&#x27;wire-profiles-3.7.0.jar&#x27;)classpath files(&#x27;wire-compiler-3.7.0.jar&#x27;)classpath files(&#x27;wire-kotlin-generator-3.7.0.jar&#x27;)classpath files(&#x27;wire-gradle-plugin-3.7.0.jar&#x27;)classpath files(&#x27;wire-schema-jvm-3.7.0.jar&#x27;) 然后再将运行时所需要的类跟随SDK一起打包 implementation files(&#x27;src/libs/wire-runtime-jvm-3.7.0.jar&#x27;) 重新编译打包，run、install 成功运行！ 总结1、整个一系列操作，让我又学到了很多平时没有接触过的东西，比如：jarjar.jar，这个库对一些比较小的库存，或者说轻量级的库重新命名会比较快速的解决。本文中所述的 wire 库实在是太复杂，只能从源码层面进行操作了。还有就是在看 wire工程源码的时候又发现了一个shadowJar(利用gradle shadowjar构建包含依赖的JAR包)，之前一直用 ffat-aar打入的依赖，不知道这个插件怎么样，后面学习学习试试。 2、在改整个源码之前，其实内心是比较抗拒的，因为一般改源码这种操作都是比较危险，或者更耗时，有可能就算改完了，也不一定能正常运行，一度想放弃，但实在是不想去改业务中那100+的文件，既然一条路走到黑，还是走下去吧，让我明白一定要坚持下去，不要放弃。","categories":[],"tags":[{"name":"技术文章","slug":"technology","permalink":"http://vompom.github.com/tags/technology/"}],"author":"落叶挽歌"},{"title":"Android 视频抽帧","slug":"Android-视频抽帧相关","date":"2022-02-22T08:11:00.000Z","updated":"2025-05-20T11:46:57.000Z","comments":true,"path":"2022/02/22/Android-视频抽帧相关/","permalink":"http://vompom.github.com/2022/02/22/Android-%E8%A7%86%E9%A2%91%E6%8A%BD%E5%B8%A7%E7%9B%B8%E5%85%B3/","excerpt":"","text":"要对移动端的抽帧，对于 iOS 来说，有 AVFoundation 这样一个神奇的库，开箱即用，已经支持了抽帧并且效率非常的高。而 Android 就不那么乐观了，Android 自带的 MediaMetadataRetriever 也能实现抽帧并将帧数据转化为 Bitmap，但效率非常低，平均抽取一帧需要 200ms-300ms，这当然满足不了我们的需求。无独有偶，Android 还提供了另一个类 MediaCodec-用于对音视频进行编解码的类，它通过访问底层的 codec 来实现编解码的功能，我们能对解码的数据进行定制化处理，本文也主要讲解利用 MediaCodec 进行抽帧。 一、MediaCodec为什么选择 MediaCodec? 项目的前期做了比较多的调研，在 Android 平台上除了 MediaCodec 还可以实现抽帧的方案有：MediaMetadataRetriever、OpenCV、FFmpeg，对于前两者实现效率非常的低，获取成本也比较大，对于 FFmpeg方案有进行了一定的尝试，ffmpeg是软解码抽帧(当然ffmpeg也可以 ffmpeg+mediaCodec 进行硬解码)，在设置 AVCodecContext-&gt;thread_count=8 速度提升了很多个档次，但对于 CPU 的使用率非常的高，消耗资源比较严重，不利于手机的流畅度，这里不再赘述。 如上图所示 ffmpeg 软解 CPU 的使用率，维持在80%左右。 MediaCodec 实现抽帧主要是参考 bigflake 网站提供的抽帧 Demo:ExtractMpegFramesTest 主要方案流程如下图所示： 方案使用 MediaExtractor 获取 Codec-specific Data(对于H.264来说，”csd-0”和”csd-1”分别对应sps和pps；对于AAC来说，”csd-0”对应ADTS)发送给 MediaCodec 进行解码，将解码后的数据存放在 Surface，由于不需要将解码后的帧进行播放展示，我们进行离屏渲染(Pbuffer)，通过 glReadPixels() 将 GPU 渲染完存在显存数据，回传内存。获取到对应帧 Buffer 数据之后，再利用Bitmap.copyPixelsFromBuffer 创建 Android 平台 Bitmap 对象。 但整个方案尝试下来之后发现：使用 glReadPixels 将显存数据回传，以及保存 Bitmap 是比较耗时以及消耗内存的操作。 那么我们可以将数据不进行回传也不保存为 Bitmap，而直接使用 GPU 上的数据进行识别么？ 二、GPU Buffer 生成流程在创建GPU Buffer之前我们需要简单介绍一下 SurfaceTexture，SurfaceTexture 是离屏渲染,内部包含了一个BufferQueue，可以把 Surface 生成的图像流，转换为纹理，供进一步加工使用。那么 SurfaceTexture 与前面的 MediaCodec 结合起来 我们的目的是为了将 GPU 上的图片 buffer 传递给算法侧进行识别，来自 SurfaceTexture 只支持外部 GLES 纹理GL_TEXTURE_EXTERNAL_OES，而算法一般都是基于 OpenGL使用 GL_TEXTURE_2D , 所以需要客户端这边做一个转换工作。 外部纹理 GL_TEXTURE_EXTERNAL_OES 的主要优势是它们能够直接从 BufferQueue 数据进行渲染。 整体流程如下图所示： 在拿到了 GPU Buffer 之后，就可以与算法愉快的进行相关的识别了，并且使用硬解抽帧之后对于 CPU 的使用率降到了15%左右。 三、总结使用 MediaCodec 抽帧最大的优点就是能够使用硬件进行解码，降低 CPU 的使用率，并且整个帧数据可以存在于 GPU 上，算法侧也能直接拿取数据进行进行识别，能比较好的提升 “抽帧-识别” 的效率。但由于硬解码在不同的硬件上表现的性能有一定的差异，以及在不同的视频与FFmpeg上也有存在不同的性能差异，各有优劣，所以在后续的方案上，针对于不同的视频可能会采取不同的方案进行抽帧。 参考： 1.ExtractMpegFramesTest.java 2.SurfaceTexture 3.Android Opengl OES 纹理渲染到 GL_TEXTURE_2D","categories":[{"name":"技术文章","slug":"technology","permalink":"http://vompom.github.com/categories/technology/"}],"tags":[{"name":"FFmpeg","slug":"FFmpeg","permalink":"http://vompom.github.com/tags/FFmpeg/"},{"name":"MediaCodec","slug":"MediaCodec","permalink":"http://vompom.github.com/tags/MediaCodec/"}],"author":"落叶挽歌"},{"title":"快捷-Mac桌面adb push小工具","slug":"快捷-Mac桌面adb-push小工具","date":"2022-01-15T15:43:00.000Z","updated":"2025-09-15T13:12:07.867Z","comments":true,"path":"2022/01/15/快捷-Mac桌面adb-push小工具/","permalink":"http://vompom.github.com/2022/01/15/%E5%BF%AB%E6%8D%B7-Mac%E6%A1%8C%E9%9D%A2adb-push%E5%B0%8F%E5%B7%A5%E5%85%B7/","excerpt":"","text":"最近在Android开发过程中会遇到很多传文件的操作，市面上也有比较多的“文件管理器”，例如锤子的HandShaker，或者谷歌官方的filetransfer,但他们都需要打开“传输文件”这个行为，个人感觉比较繁琐。作为Android开发，使用adb命令行去传输文件是不错的，但每次输入adb push xxx还是挺麻烦，而且必须打开 Terminal 才能运行。为了让所有操作更简化，我做了一个简单的桌面工具，只需要连上手机，正常打开adb，拖到文件到对应区域，则可以实现文件传输。 Macos Adb Helper由于自己主要是从事Android相关的开发，对于Mac桌面端的开发不太熟悉，但是 Flutter 这个神奇的跨平台框架可以让你稍微消除这个平衡。 实现一键拖拽文件发送到Android手机，主要需要实现的功能有两个： 1、文件拖动功能 2、发送功能 文件拖动功能拖动功能也不需要自己去写，已经有现成的库 desktop_drop 实现好了该功能。看了下源码与大多数 plugin 一样，通过methed channel进行mac os进行通信，对桌面开发相关Api不太熟，实现原理没有太深究。 发送功能发送功能主要使用 adb 功能提供的 push命令实现。不过要在 Flutter 上面实现执行命令的功能还是比较简单，只要使用 Process.start(&#39;adb&#39;, [&#39;push&#39;, ...])即可，但是中间会遇到权限不足的问题，报错：ProcessException (ProcessException: Operation not permitted)需要关闭沙盒权限才行，将com.apple.security.app-sandbox之设为false。 那咱们这个程序就不太安全咯?不知道还有没有更好的办法?个人感觉不大行…… 在这里还遇到个比较蛋疼的问题，对于实现大文件的发送，通常时间比较久，使用Process.start没有找到相关的api能够直接拿到进度，不过也就简单实用，问题不大 ^_^#。 效果展示 项目地址：macos_adb_helper","categories":[{"name":"思考总结","slug":"thinking","permalink":"http://vompom.github.com/categories/thinking/"}],"tags":[{"name":"Flutter","slug":"Flutter","permalink":"http://vompom.github.com/tags/Flutter/"},{"name":"工具","slug":"工具","permalink":"http://vompom.github.com/tags/%E5%B7%A5%E5%85%B7/"}],"author":"落叶挽歌"},{"title":"Android音视频-初识FFmpeg","slug":"音视频-初识FFmpeg","date":"2021-11-14T01:49:00.000Z","updated":"2025-09-15T13:07:56.100Z","comments":true,"path":"2021/11/14/音视频-初识FFmpeg/","permalink":"http://vompom.github.com/2021/11/14/%E9%9F%B3%E8%A7%86%E9%A2%91-%E5%88%9D%E8%AF%86FFmpeg/","excerpt":"","text":"已经很久没有写过技术博客了，这段时间加入了新公司，主要时间花在熟悉新业务的技术上。而新的业务主要跟音视频相关，关于音视频的尝试在加入新公司之前，自己有做相关demo的尝试与学习，可以参看音视频相关学习demo。当然，那都是自己“想当然”学习的一些东西，虽然实际工作中并没有派上太大的用处，但让我对音视频相关的基础知识有了一定的概念，对后面的技术尝试做了铺垫。第一个技术挑战比较大的就是进行：视频抽帧，关于视频抽帧网上有很多很多文章进行讲解，但……我始终没有找到一个效率很高的解决方案。直到我遇见了 ffmpeg，仿佛打开了新世界的大门…… 关于FFmpeg刚接触 ffmpeg 时，我一脸懵逼，完全不知道该怎么做，也不知道在哪里开始进行学习，后来在雷霄骅大神的博客中渐渐找到了感觉，膜拜！不过雷神的博客代码是基于老版本的 ffmpeg api，推荐搭配官方example，先跑通雷声的博客，再对照官方的例子对进行api相关接口的修改。 当然，想要使用 ffmpeg编写代码之前，我们首先要做的是对 FFmpeg 进行so库编译，这一步也是难倒了众多的英雄好汉，引用FFmpeg so库编译作者的话： 为什么FFmpeg让人觉得很难搞？我想主要是因为迈出第一步就很困难，连so库都编译不出来，后面的都是扯淡了。 参考FFmpeg so库编译文章能成功地打包出 ffmpeg.so，接下来就是添加在项目中运行。 踏上 FFmpeg 音视频之路关于音视频等开发，无论是做特效渲染还是做视频播放，那么最重要也是最基本的步骤就是：音视频解码 众所周知的是视频是由一帧帧视频帧(图片)/音频帧编码组合而成 视频解码要做的就是解码出视频文件中的每一帧，我们以:将视频转化为一帧帧的图片作为例进行学习。 FFmpeg 提取视频每一帧图像在学习之前，我们思考一个问题：抛开 ffmpeg，如果让你去设计一个提取的代码，n你会怎么设计？ 因为视频是以文件流的形式存在，我相信很多人一上来就能想到这样的结构： while (!EOF) &#123; //当文件流没有结束 Stream stream = getStream(); //获取一定区域的stream Frame steam = getFrame(stream); //Stream转化为视频帧 Picture picture = decodeFrame(steam); //将视频帧转化为 .jpeg等格式图片&#125; 的确是这样的，这里是给出一份ffmpeg提取视频帧图片的核心逻辑： AVFrame frame = av_frame_alloc(); while (true) &#123; if (av_read_frame(fmt_ctx, &amp;avpkt) &gt;= 0) &#123; // Return the next frame of a stream. if (avpkt.stream_index == video_stream_index) &#123; //标识该AVPacket所属的视频/音频流。 avcodec_send_packet(codeCtx, &amp;avpkt); //Supply raw packet data as input to a decoder. while (avcodec_receive_frame(codeCtx, frame) == 0) &#123; //Return decoded output data from a decoder. snprintf(buf, sizeof(buf), &quot;%s/frame-%d.jpg&quot;, out_filename, frame_count); saveJpg(frame, buf); &#125; frame_count++; &#125; av_packet_unref(&amp;avpkt); &#125; else &#123; LOGE(&quot;//Exit&quot;); break; &#125;&#125; 上面的代码块就是 ffmpeg 进行视频解码最核心的逻辑了，主要的注释也贴在了代码上，完整代码请查看video_to_jpeg.cpp，查看完整的代码后，会感觉到很惊讶：为什么这么复杂？特别是前面的初始化操作。放心，ffmpeg就像一套组合拳，有固定不变的套路，写一次就足够了，了解了其中的流程，之后理解起来就会很容易了。 上面的代码我们还可以做一些其他处理，比如只获取关键帧、查找指定时间戳位置的帧、视频按2s一帧进行抽取、视频不保存为jpeg文件转化为Java的bitmap？ 这些实现需求也都是基于上述核心模块进行修改： 如果想只获取关键帧，可以利用AVFrame对象的属性AVFrame-&gt;key_frame进行判断。 查找指定时间戳位置的帧：利用 av_seek_frame查找到指定帧时间最近的关键帧，然后依次进行编码，直到pts与目标时间相近 视频按2s一帧进行抽取：简单的操作可以去获取视频fps，比如视频25fps，可以使用一个计数器判断if(frame_count%25==0),这时候则是刚好1s。当然这样子性能不太好。如果需要追求性能，那么也可以利用av_seek_frame，查找目标时间附近，然后循环进行解码直到目标时间。 视频不保存为jpeg文件转化为Java的Bitmap：只需要对最终获取的 AVFrame做不一样的操作进行了，获取到对应的buffer，再利用jni调用构造 Java 的 bitmap 对象。 可以做的还有很多…… 总结提取视频图片这个功能只是 FFmpeg 强大功能的九牛一毛，需要探究的还有很多很多…… 如果能跑起来 FFmpeg 最简单的例子，已经迈出了很大一步了，但如果要理解其中的原理，还需要更多的基础知识，以及像AVPacket、AVFrame、 AVCodec ……每一个类的数据结构，以及实现都需要仔细研究。 自己在网上找到的 FFmpeg 相关的教程，以及自己想要去实现的功能的资源太少，很多东西都需要自己去摸索。有时候我总在怀疑：为什么这么基础且很实用的功能没有现成的轮子？ 这可能也是现在音视频相关开发的现状吧，成熟可用的轮子相对而言较少，以及相关技术的分享可能不太好做。既然没有，那就靠自己一点点积累吧。 学习之路，任重而道远呐。","categories":[{"name":"技术文章","slug":"technology","permalink":"http://vompom.github.com/categories/technology/"}],"tags":[{"name":"FFmpeg","slug":"FFmpeg","permalink":"http://vompom.github.com/tags/FFmpeg/"},{"name":"音视频","slug":"音视频","permalink":"http://vompom.github.com/tags/%E9%9F%B3%E8%A7%86%E9%A2%91/"}],"author":"落叶挽歌"},{"title":"记一段 Android 面试时光","slug":"记一段-Android-面试时光","date":"2021-07-06T14:56:00.000Z","updated":"2025-05-20T11:46:57.000Z","comments":true,"path":"2021/07/06/记一段-Android-面试时光/","permalink":"http://vompom.github.com/2021/07/06/%E8%AE%B0%E4%B8%80%E6%AE%B5-Android-%E9%9D%A2%E8%AF%95%E6%97%B6%E5%85%89/","excerpt":"","text":"今晚已到下班时间，我又如往常一样，背着自己的包来到了楼下的会议室。不过与前些天的日子不太一样，今天我已经放下了诸多包袱，剩下的是一个轻松的自己，历经一个月的面试时光，终于可以在这会议室惬然地写下一些东西。 准备面试以及参加面试都是一个高度紧张的过程，为了面试，我放弃了一些时间，也让自己每天变得很疲惫，因而有更少的精力去干一些其他事情。在六月，我还未完成一本书的阅读，时间忙碌所占去，或者那个疲惫的身体没有能静得下心来阅读一本书籍，我好希望能够有一个轻轻松松的时间，能够做自己想做的事\b。但在诸多现实面前，不得不低下头吧，好在现在收获的Offer也能对得起自己的付出，遂想记录一下这一个月来自己的面试经历。 在五月初便有想跳槽的想法，原因也很简单：现在的日子太舒服，想找到一个更大的平台来提升自己。在五月下旬开始行动了起来，自己当然有想要去的厂，也通过一些相关的流程约到了面试的时间。那么接下来就是准备吧，准备的过程包括：算法(视公司而定)、基础知识(常见面试问题等)、项目(项目本身以及相关的深度知识)。当然还包括了面试经验，在面之前需要找一些中型公司来锻炼锻炼自己的表达能力，以及对问到的一些知识盲区进行一些补缺，于是面试之路开始了。 记得第一家面的某快递公司，很久没有面试过了，发现面试的感觉还是有点差，被问了一些 Android 相关的基础知识，我知道那件事，但是我回忆不起来了，也讲不太出来了。理所应当挂了，不过无所谓吧，问题不大，回去之后把他问了的一些基础点再准备了看看。 大概也就是第二天吧，是某买菜公司的面试，这次面试让我哭笑不得。我也本着找面经的态度来面试的，我希望他能多问点有深度的知识，然后我能知道我该去准备些什么。结果他一直不停地问我所做的项目，全程没有技术问题。大概问了我20分钟项目经历，他说：我问完了，你有什么要问的么？我一脸懵逼？？？？我（你特么）都不问点技术问题？他：我……感觉你好强啊（还有点支支吾吾的感觉）……不太敢问，怕暴露了…… 不过登了很久也没有见他们约二面（难道是怕我太强了？？哈哈哈😂）。 第三次面试是杭州某中厂，在经过两次面试的时间之后，我觉得我的基础知识准备还行，这一次的面试，全程问得还是比较轻松，技术深度也不是特别大，很轻松的过去了。后面相互交流时间，我问了一些他们在做什么东西，面试官倒是很热情地给我讲了一大堆，但我并不是很感兴趣，出于礼貌，还是耐心地听了下去。他问我现在的工资是怎样，我如实回答后他说：我们可能还要低些。后面又讲了他们的业务(企图用爱来发电)，不过我依然没有表现出多大的兴趣，后面也没有再约面试了吧。 第四次面试我投了某能便宜买东西电商公司，这个公司算是我拿到的第一个Offer的公司，记得清楚是5.30号，因为当天下午面完，赶去苏州看国足世界杯预选赛的比赛了。一面的小哥还是很nice的，问的问题比较有深度，答得还行吧，在后面跟我讨论了起来 Flutter 的发展，聊得还是比较惬意，最后又是一道算法题（记不太清是什么题了，应该是easy难度），然后约我去现场进行下一面，也就是5.30号。去现场跟HR聊了好一会儿，才来一个看着很资深的大佬，问了我一些也不算事太难的问题，甚至感觉他没有仔细看我简历，一直看我简历，看一会儿问一会儿，最后又是一道算法题：求两个View的最近公共View，叫我直接在纸上写，那桌子太低，弯着个腰，写着太难受了，那字也写得跟个啥一样，不过他还是看懂了，后面也没有问个啥，然后就直接HRBP面了，问我期望工资，我说了一个期望，她当然会砍价，因为这时候没有其他 Offer ，她给我给得很低，然后 pua 我了一下，说什么你前两年浪费了呀，你要来的话，得赶紧过来之类的……然后没过几天就让我提交工资流水了。 在后面是某手机大厂，这个厂流程也真的是一个之复杂。简历通过后，一上来就有个在线笔试，三道算法题，三个小时，三个题我应该都做出来了，难度中等吧，不过他的测试用例不知道怎么设计的，我的测试用例通过率每道题都没有超过百分之五十，可是我实在是找不到可以再加的逻辑了，忐忑的心情提交了上去。结果第二天跟我说通过了，刚好过。然后又给我发了一份职业问卷测评的链接，好嘛，点开一个看，woc 几百道题……也真的是做着累，问题也就是一些不痛不痒的问题。在做做之前，HR有给我发一份“高分教程”，大概总结一下就是你得选一些符合他们公司价值观的选项，总体的感觉就是：他们喜欢加班的人、能吃苦耐劳不计较报酬、不能有自己的个性……行吧……有的选项真的有点打击我三观，不过我还是坚持地做完了。 第二天HR跟我说通过了，不过“XX值”有点偏高，到时候可能需要跟leader解释一下，我…… 然后到了第一面技术面，一上来又是一道算法题，还行吧，这道理大概完成了，后面去leetcode上面看了一下，也是个medium。不过面试官是真的很强的感觉，把我问得不要不要的，对于系统底层的问题问了很多，我甚至很佩服该厂的技术人员，怎么可以这么强？中间我有好几个问题没有答上来，但是大佬还是很耐心的给我讲解了一下，这次面试的收获也是蛮大的。 后来居然先是HR面试，很神奇哟。不过这次HR面试让我很不爽很不爽，体验极差。跟HR聊着，真的是“痛不欲生”，她搁这里戴个有线耳机，只挂了一个在耳朵上（记不太清了，应该是挂的没有话筒的那一边）导致交流起来我能听到她的声音很不清楚，我得很仔细听她讲话。然而反过来呢？我在讲话的时候，她一边玩着自己的手指甲，中间时不时还有几个哈欠出来……后面聊到薪资一块，问了我期望薪资，我说了一个数（在我现在拿到了其他公司的offer之后，再看的话，真的算是一个比较低的数字了），她跟我说：你去看其他厂，除了某厂，其他不可能给你这么多的（现在看就呵呵了），然后还特别的高傲的把我pua了一顿……总之体验不太好。又过了一段时间跟我说要二轮技术面，我拒绝了。 第二个Offer是曾经的XYZ的X，一面技术面居然是个姐姐，问的问题还算可以，不难，但是有一些个“坑”，我跳进去过几次，给我贴了好几段代码，让我找哪里有问题，不得不说这一波面试让我学到了很多知识点，让我对 Android 的 HandlerThread 有了更多了解。二面去的现场，去现场我还是挺感慨，这么大一块园区都是他们公司的，整个logo放大楼前面，真的是气派！在前台等了一会儿有面试官下来接待，天呐！又是一个姐姐！娘子军大作战？单独找了个会议室，跟这个面试官聊起来，感觉压力还是蛮大的，各种问我“架构设计”方面的事儿，让我画项目架构图在黑板上之类的。以及被诸多的技术灵魂拷问，总体聊了一个半小时，压力还是蛮大。后来是要他们主管过来面，我看这主管样子就是大佬样，应该有四十多岁了，有一种职场气质的技术主管。问我也是一些通用型的问题，架构、思维、方法论等，压力更多来自于他给我一种资历压迫感（我感觉我说的东西都太幼稚在他看来），因为我跟他说了我等会儿要赶飞机，所以跟他只聊了半个小时，后面的HR面也只聊了十几分钟，我就匆匆跑路了，然后第二周叫提交薪资流水。 前面的面试还算是比较顺利，没有怎么失败过，我以为我能以“全胜出线”，结果现实并不是这样。再后来面了某视频网站和XYZ的Y。这两次失败是连在一起的，Y已经是最后一面的技术面，大佬面，应该问题不大了，可是，意外总是会出现。事情是这样子的，当天晚上七点约了视频网站的二面，八点是Y公司的最后一轮技术面了（只要没有什么幺蛾子事情发生，后续应该就是HR了）。当时前者公司正视频面试着，又是个女面试官，全程问了我一些问题莫名奇妙，我一开始还以为她是HR，问了我好几个非技术问题，以及一些有的得没得问题（比如：我们为什么招你？害～ 你能为我们带来什么？害～），但在七点四十多的时候收到了Y公司的电话，想立马面试，我跟他解释现在有事，并推迟到了八点之后。结果就是因为这一推，给大佬造成了不好的影响……据后来内推的同事说，很大的一部分原因就是这个。然后在面试过程中还接电话，结果两边都没有个好结果，害～ 这事儿整得，让我明白了：面试时间安排太紧凑比较危险。 最后拿到的两个offer，也是我最终纠结选择取哪里的offer，两个公司都比较好吧。一个在上海，一个在杭州，原本想拒绝上海这个公司的，因为杭州的公司有我诸多前同事，以及杭州相比上海而言有更好的生活舒适度，所以选择了杭州的公司，但是拒绝真的很难。上海的公司算事行业的佼佼者了，为了能更好的拒绝，我甚至写了一份“千字长文拒绝信”给对应HR，来表达我不能去其公司歉意（那内容我作为旁观者，看着都要给感动哭了），但HR也并没有回我什么（可能是见惯了这种场景），没过多久我收到了其公司的同事的关怀，但我还是对他表示拒绝的想法。又过了不久，我收到电话，貌似是之前去公司面试的时候，“我的直属leader”打过来的，向我阐述了大平台的重要，以及杭州公司的业务发展没有这边好。后来又被拉群，加入到了含有部门总监的群，他加了我微信，表示晚上要跟我谈一谈，并附言几句，大概意思翻译就是：你去杭州的不是一个明智之举，来我们这里才是最正确的选择。一下午就因为这些事“舌战群儒”，不过我很强烈地感受到了他们对人才的追求和肯定，让我感觉到：我何德何能？能让这么多陌生的人来劝我回去，让我很感动， 这或许就是大公司每个人都以人才来看待吧。 此时我开始陷入了更深的纠结与迷茫：到底该怎么选？对于上海的公司体量是N个杭州公司那么大的，工作室是在做一些比较前沿的东西(视频特效渲染、移动端深度学习、音视频合成等)，很多东西我都没有接触过，要重新开始学习，会比较肝。对于杭州公司，在那里有我诸多的前同事，包括 leader 都是我之前公司的，公司位于滨江河畔，离钱塘江也不远，钱塘夜景让我久久不能忘怀。加之杭州的物价与房价都低于上海，不得不说杭州更适合生活。但做的东西比较与业务相关，需要与产品-测试等相关人员对接，相对而言所接触到的知识点没有上海这边深入。所以，我是否要去选择在上海再拼一拼呢？有那么些纠结，到底要选择相对轻松舒适的杭州，还是更有拼搏感的上海公司？最终吧，还是选择了上海，最近在读《草莓人生》，有一句话让我又更坚定了这个选择：“其实没有一种工作是轻松的，正因为不轻松，所以才叫工作啊”，学吧，学吧，肝吧肝吧，在上海再干几年，祝我有朝一日成大佬😂昨日，已点击“接受本Offer”至此，结束一段面试时光。","categories":[{"name":"思考总结","slug":"thinking","permalink":"http://vompom.github.com/categories/thinking/"}],"tags":[{"name":"面试","slug":"面试","permalink":"http://vompom.github.com/tags/%E9%9D%A2%E8%AF%95/"}],"author":"落叶挽歌"},{"title":"逆向相关经验总结","slug":"逆向相关经验总结","date":"2021-07-06T06:47:00.000Z","updated":"2025-12-22T03:23:22.456Z","comments":true,"path":"2021/07/06/逆向相关经验总结/","permalink":"http://vompom.github.com/2021/07/06/%E9%80%86%E5%90%91%E7%9B%B8%E5%85%B3%E7%BB%8F%E9%AA%8C%E6%80%BB%E7%BB%93/","excerpt":"","text":"在离开 YW 之前很长的一段时间都在做逆向相关，从最初只需要反编译 .apk 文件就能“摸清”应用内部相关逻辑，到后来需要对App文件进行脱壳，到需要动态调试。花了很大的精力，这中间也走了很多弯路。在换了工作之后，不知还会不会再有接触逆向相关的开发，但过去的探索也是我技术的宝贵经验吧，遂将此前的学习的一些经验进行整理。 逆向相关原理与流程参考资料安卓打包流程 反编译流程 加固原理 脱壳教程 不root怎么将FDex2反编译的dex文件拷出来 Xposed之Hook方法 Xposed Hook混淆且加固后的APP 最方便快捷的脱壳软件（不需要Root、也不需要Xposed 关于脱壳、破解逆向等资源工具最好的网站是—-&gt; www.52pojie.cn 整理一份相关破解工具集：https://github.com/VomPom/Hack/tree/master/apk_reverse 个人一些经验总结：1、 App抓包尽量使用Android 低版本（Android 7以下）7之后有些新版本系统的安全限制 2、 能进行静态代码就直接进行静态代码分析，在万不得已的时候再利用 hook以及动态调试（相关收益率以及成功率比较低） 3、 利用BlackDex之类的软件脱壳之后，从手机复制过来到一个文件夹，利用apk2dex2jar2class2java.sh 执行 sh apk2dex2jar2class2java.sh /xx/xx (对应的脱壳后的dex文件夹) 得到jar/java文件夹可方便进行静态代码分析 4、 如何找到请求接口加解密的地方？这个只有靠个人经验，对于很多普通加密利用了标准加密库，可以尝试搜索“Cipher.getInstance”之类的标准代码（注意第三方相关sdk也会使用），或者搜搜“Response”相关的字段，或者 请求过程中相关的具体字段或者域名等，不过这部分代码一般都是被混淆的，需要耐心慢慢摸索。 5、 有时候代码会有找不到相关的类的情况，这是由于脱壳相关机制导致的，需要对其进行修复，或者尝试使用其他脱壳软件进行脱壳。","categories":[],"tags":[],"author":"落叶挽歌"},{"title":"Android 逆向-反编译","slug":"Android-逆向-反编译","date":"2021-05-14T06:45:00.000Z","updated":"2025-12-22T03:27:00.920Z","comments":true,"path":"2021/05/14/Android-逆向-反编译/","permalink":"http://vompom.github.com/2021/05/14/Android-%E9%80%86%E5%90%91-%E5%8F%8D%E7%BC%96%E8%AF%91/","excerpt":"","text":"最近由于机缘巧合接触到了 Android 逆向相关的事情，经过一番探索，对其有了更深刻地认识，过程中遇到了了一些坑，或者一些有用的经验，分享并记录分析一下。在整个过程中使用的工具有： 反编译：dex2jar、CFR、jd-gui、 脱壳：VirtualApp、Xposed installer、FDex2 其他：IDA、VSCode、Total commander 接下来咱们以两个具体情景，讲解整个逆向（静态代码分析）的流程，去分析两个 Apk 中相关页面的加密算法。 在开发安卓应用的过程中，我们平时写得最多的代码就是 Java(以及Kotlin)，我们的逻辑也都在这一块，如果我们需要对应 apk 中代码逻辑，能直接看到这样的代码当然是最好不过的。要对相关 apk 中的代码逻辑进行分析，那么第一步便是需要对 apk 进行反编译，从而得到可以进行阅读理解的代码。 Apk的打包流程我们先对 安卓的打包流程进行一个简单的了解，从而明白.java文件 是一步步\b成为 apk中的一部分的，在生成 apk 的过程中主要包含以下流程，括号中代表使用的工具： 1、打包资源文件，生成R.java文件 (aapt) 2、处理aidl文件，生成相应的.java文件 (aidl) 3、编译项目源代码，生成class文件 (javac) 4、转换所有的class文件，生成classes.dex文件 (dx) 5、编译过的资源和.dex文件都会被apkbuilder工具打包到最终的.apk文件中。 (apkbuilder) 6、对APK文件进行签名 (jarsigner) 7、对签名后的APK文件进行对齐处理 (zipalign) 主要流程参考这张图： 反编译流程在 apk的打包流程的步骤为：*(资源/aidl等)-&gt; .java-&gt;.calss-&gt;.dex-&gt;.apk，反编译只需要对每个步骤反向进行。 .apk-&gt;.dex安卓安装包本质上是一个压缩文件，只需要对齐进行解压即可(Mac上直接将后缀apk，改成 zip 再使用自带解压软件即可)解压获得以下文件： ├── AndroidManifest.xml├── META-INF├── assets├── classes.dex ├── classes2.dex├── lib├── okhttp3├── org├── r└── resources.arsc 从目录结构得到两个.dex文件，这是由于在单个dex文件引用的方法总数不能超过65536（为什么？因为dex文件中的方法个数采用原生类型short来索引，而short是4个字节，4个字节最大数据存储量是65536），多数 app 超过了这一限制。 .dex-&gt;.class这里我们需要利用工具 dex2jar d2j-dex2jar: Convert .dex file to .class files (zipped as jar) 执行： sh /XXX/dex2jar-2.0/d2j-dex2jar.sh classes.dex 生成 classes-dex2jar.jar, 这个 jar 就是从classes.dex反编译出来的 .class集合。得到了这份 .jar我们已经可以开始使用 jd-gui进行查看了，这里吐槽一下jd-gui的搜索功能，搜索功能有限，纯字符串搜索是有问题的（或许是我版本不对），可以在 File/Save all sources 将所有反编译好的文件进行保存，然后利用其他工具（例如VsCode）进行搜索。 再看上面的代码，有一部分是 字节码，工具未能将它正常反编译，为什么呢？相关解释在https://www.zhihu.com/question/50140866 这里推荐使用 CFR,执行： java -jar /xxx/cfr-0.151.jar /xxx/classes-dex2jar.jar --outputdir /xxx/java CFR对于 jd-gui 有更好的支持，那还要 jd-gui 干什么呢？在我看来 jd-gui 有一个最大的好处就是能像IDE那样可以点进进入方法内部，所以推荐两则结合起来使用。 .so 反编译在追溯逻辑的过程中，可能会遇到有 native 方法，如下： public native int dataFromNative(byte[] param, int paramInt1, int paramInt2); 相关逻辑写在 c/c++文件中，最终把打在.so库中，这时候就需要宇宙第一反汇编分析工具 IDA了，我们在 apk 解压后的 lib 中找到对应的 .so 文件（这里可能需要一点耐心，lib中大多是第三方的，可以很好通过 so 文件名找到开发者的 so文件）,利用 IDA F5 插件查看 汇编代码的伪代码。以字节某 SDK中的某段代码为例： 可以看到对应的逻辑，这时候就考验水平的时候了……当然，IDA 是一个强大的工具，关于IDA的使用绝对不是通过查看一两篇博文就能熟练使用的，可以去查看《IDA Pro权威指南》 总结1、当然上述流程只针对”正常App”，但在实际的 App 不会这样轻易的被反编译，App 可能还进行了加固，那我需要对其进行脱壳才能实现正确的反编译，这一内容放在另一章节再进行讲解。2、反编译整个流程，如果没有加固，一般操作是：解压-&gt;class2jar 进行转jar-&gt;CFR/jx-gui 反编译class，如果对逆向还有更多的操作还可以使用 apk_tool。相关流程已经在github 有开源的脚本了TTDeDroid，有兴趣的同学可以去看看，但是我感觉有些复杂，我自己也写了一个脚本apk2dex2jar2class2java.sh","categories":[{"name":"技术文章","slug":"technology","permalink":"http://vompom.github.com/categories/technology/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://vompom.github.com/tags/Android/"},{"name":"逆向","slug":"逆向","permalink":"http://vompom.github.com/tags/%E9%80%86%E5%90%91/"}],"author":"落叶挽歌"},{"title":"Flutter FFI实践","slug":"FlutterFFI实践","date":"2021-04-18T02:34:00.000Z","updated":"2025-05-20T11:46:57.000Z","comments":true,"path":"2021/04/18/FlutterFFI实践/","permalink":"http://vompom.github.com/2021/04/18/FlutterFFI%E5%AE%9E%E8%B7%B5/","excerpt":"","text":"在 Android的开发中，我们有 JNI 使得 Java可以调用本地应用或库。Flutter 在前不久发布了 Flutter2，更新了 FFI (我们是否可以把它叫做DNI呢？)进入了稳定状态,开发者可以更安心的使用其功能。但是相关的文档依然很欠缺，导致使用起来有诸多的疑问，以及相关原理性的介绍比较少，所以整理记录一下。 一、Dart 同步调用 Native 方法我们以最简单的demo为例,请求一个有参无返回值的C方法在 C/C++中有如下函数： extern &quot;C&quot; __attribute__((visibility(&quot;default&quot;))) __attribute__((used))void c_with_out_return_value(int value) &#123; LOG_D(&quot;Got invoke value: %d&quot;, value);&#125; Dart: final DynamicLibrary ffiLib = Platform.isAndroid ? DynamicLibrary.open(&#x27;lib_invoke.so&#x27;) : DynamicLibrary.process();final cMethod = ffiLib.lookupFunction&lt;Void Function(Int32 value), void Function(int value)&gt;(&#x27;c_with_out_return_value&#x27;);cMethod(123); 这样一次调用就完成了一次调用，传递了123到Native并执行了一次打印，同理相关有参有返回值的请求也都是这样做到的，那 Dart 和 Native内部具体怎样实现的呢？ DynamicLibrary.open() 最终执行的逻辑如下, 源码位于ffi_dynamic_library.cc： static void* LoadExtensionLibrary(const char* library_file) &#123;#if defined(HOST_OS_LINUX) || defined(HOST_OS_MACOS) || \\ defined(HOST_OS_ANDROID) || defined(HOST_OS_FUCHSIA) void* handle = dlopen(library_file, RTLD_LAZY); if (handle == nullptr) &#123; char* error = dlerror(); const String&amp; msg = String::Handle( String::NewFormatted(&quot;Failed to load dynamic library (%s)&quot;, error)); Exceptions::ThrowArgumentError(msg); &#125; return handle; …… 可以看到最终使用 dlopen 加载动态链接库，并返回句柄。 拿到对应的动态链接库的句柄之后，就能使用相关方法进行操作了。句柄主要包含以下两个方法： //在内存中查找对应符号名的地址，与dlsym()功能相同external Pointer&lt;T&gt; lookup&lt;T extends NativeType&gt;(String symbolName);//1、去动态库中查找对应名称的函数 //2、将 Native 类型的 C/C++ 函数转化为 Dart 的 Function 类型external F lookupFunction&lt;T extends Function, F extends Function&gt;(String symbolName); 其中lookup()的最终实现主要使用了 dlsym static void* ResolveSymbol(void* handle, const char* symbol) &#123;#if defined(HOST_OS_LINUX) || defined(HOST_OS_MACOS) || defined(HOST_OS_ANDROID) || defined(HOST_OS_FUCHSIA) dlerror(); // Clear any errors. void* pointer = dlsym(handle, symbol); if (pointer == nullptr) &#123; char* error = dlerror(); const String&amp; msg = String::Handle( String::NewFormatted(&quot;Failed to lookup symbol (%s)&quot;, error)); Exceptions::ThrowArgumentError(msg); &#125; return pointer; 二、Dart 异步调用 Native 方法在很多场景我们不能像上述同步方法那样，dart 进行一次请求之后立马得到结果，可能会有一些耗时操作，为了不让 Flutter 的UI线程卡住，我们进行异步请求。那如何实现异步请求呢？对于异步实现，官方并没有很明确的文档，都得靠自己琢磨，在官方的讨论中 https://github.com/dart-lang/sdk/issues/37022 以及 https://github.com/flutter/flutter/issues/63255 提到一些解决方案: 1.In your C++ code include include/dart_api_dl.h and include/dart_api_dl.cc from here https://github.com/dart-lang/sdk/blob/master/runtime/include/ (they also depend on include/internal/*). 2.From Dart call Dart_InitializeApiDL passing NativeApi.initializeApiDLData as an argument. 3.On Dart side create a ReceivePort and pass port number of the corresponding SendPort to the native side (port.sendPort.nativePort). 4.Now on C++ side you can use Dart_PostCObject_DL to send messages back to Dart side from any thread. 按上述的操作进行实现，接下来具体分析一些里面的逻辑原理。1、导入include/dart_api_dl.h include/dart_api_dl.cc 相关的文件并在 CMakeList.txt进行相关配置2、从dart中 调用Native中 Dart_InitializeApiDL Dart: void main() &#123; initializeApi(NativeApi.initializeApiDLData); runApp(MyApp());&#125; C++: // Initialize `dart_api_dl.h`DART_EXPORT intptr_t InitDartApiDL(void *data) &#123; LOG_D(&quot;InitDartApiDL&quot;); return Dart_InitializeApiDL(data);&#125; 在 initializeApi(NativeApi.initializeApiDLData) 中 initializeApi 向 Native请求 DART_EXPORT intptr_t InitDartApiDL(void *data)方法，传入的参数就是在 dart_api_dl.h DART_NATIVE_API_DL_SYMBOLS 以及 DART_API_DL_SYMBOLS 中的方法。 NativeApi.initializeApiDLData 逻辑： static const DartApiEntry dart_api_entries[] = &#123;#define ENTRY(name, R, A) \\ DartApiEntry&#123;#name, reinterpret_cast&lt;void (*)()&gt;(name)&#125;, DART_API_ALL_DL_SYMBOLS(ENTRY)#undef ENTRY DartApiEntry&#123;nullptr, nullptr&#125;&#125;;static const DartApi dart_api_data = &#123; DART_API_DL_MAJOR_VERSION, DART_API_DL_MINOR_VERSION, dart_api_entries&#125;;DEFINE_NATIVE_ENTRY(DartApiDLInitializeData, 0, 0) &#123; return Integer::New(reinterpret_cast&lt;intptr_t&gt;(&amp;dart_api_data));&#125; dart_api_dl中定义的方法： #define DART_NATIVE_API_DL_SYMBOLS(F) \\ /***** dart_native_api.h *****/ \\ /* Dart_Port */ \\ F(Dart_PostCObject, bool, (Dart_Port_DL port_id, Dart_CObject * message)) \\ F(Dart_PostInteger, bool, (Dart_Port_DL port_id, int64_t message)) \\ .....// dart_api.h symbols can only be called on Dart threads.#define DART_API_DL_SYMBOLS(F) \\ /***** dart_api.h *****/ \\ /* Errors */ \\ F(Dart_IsError, bool, (Dart_Handle handle)) \\ F(Dart_IsApiError, bool, (Dart_Handle handle)) \\ ..... 其实这上面的逻辑很简单，主要是为了让业务中的代码能够进行动态链接，从而调用到 Flutter SDK 中相关方法。 3、第三步添加 ReceivePort 监听 class Work extends Opaque &#123;&#125;void requestExecuteCallback(dynamic message) &#123; final int workAddress = message as int; final Pointer&lt;Work&gt; work = Pointer&lt;Work&gt;.fromAddress(workAddress); executeCallback(work);&#125;final ReceivePort interactiveCppRequests = ReceivePort()..listen(requestExecuteCallback); 向 Native 发送带有 interactiveCppRequests.sendPort.nativePort 的数据，为native异步回调做准备。 Future&lt;int&gt; platformAsync(int value1, int value2) &#123; final Completer&lt;int&gt; completer = Completer&lt;int&gt;(); final String cid = uuid.v1(); final Pointer&lt;Utf8&gt; cidPtr = cid.toNativeUtf8(); completerMapping[cid] = completer; //生成一个nativePort，为native异步回调做准备 final int nativePort = interactiveCppRequests.sendPort.nativePort; final cMethod = ffiLib.lookupFunction&lt; Int32 Function(Pointer&lt;Utf8&gt; cId, Int64 sendPort, Int32 value1, Int32 value2, Pointer&lt;NativeFunction&lt;callback_type&gt;&gt; callbackBlock), int Function(Pointer&lt;Utf8&gt; cId, int sendPort, int value1, int value2, Pointer&lt;NativeFunction&lt;callback_type&gt;&gt; callbackBlock)&gt;(&#x27;platform_async&#x27;); cMethod(cidPtr, nativePort, value1, value2, Pointer.fromFunction&lt;callback_type&gt;(_callbackBlocking)); return completer.future;&#125; 4、当异步执行完成之后，在 Native 执行 Dart_PostCObject_DL 通知 Dart 已经得到结果对于代码如下： void response(jint result) &#123; Work work = [_callback,result] &#123; if (_callback != nullptr) &#123; _callback( result); &#125; else &#123; LOG_E(&quot;_callback == null&quot;); &#125; &#125;; // Copy to heap to make it outlive the function scope. const Work *work_ptr = new Work(work); NotifyDart(send_port, work_ptr);&#125;void NotifyDart(Dart_Port send_port, const Work *work) &#123; const auto work_address = reinterpret_cast&lt;intptr_t&gt;(work); Dart_CObject dart_object; dart_object.type = Dart_CObject_kInt64; dart_object.value.as_int64 = work_address; const bool result = Dart_PostCObject_DL(send_port, &amp;dart_object); if (!result) &#123; LOG_D(&quot;FFI C : Posting message to port failed.&quot;); &#125;&#125; 上面的代码最核心的就是Dart_PostCObject_DL()这里真正调用的还是，Dart_PostCObject()，加_DL()表示动态链接的方法，为了防止与原先符号冲突。 All symbols are postfixed with _DL to indicate that they are dynamically linked and to prevent conflicts with the original symbol. 我们继续看看 Dart_PostCObject()真正做了什么，Dart_PostCObject()最终调用的方法如下： static bool PostCObjectHelper(Dart_Port port_id, Dart_CObject* message) &#123; ApiMessageWriter writer; std::unique_ptr&lt;Message&gt; msg = writer.WriteCMessage(message, port_id, Message::kNormalPriority); if (msg == nullptr) &#123; return false; &#125; // Post the message at the given port. return PortMap::PostMessage(std::move(msg));&#125; 这里在向 Service Isolate发送事件,最终 Dart 成功接受到异步消息的回调。关于 Isolate 这一块的处理可以参考：Async Coding With Dart: Isolates 三、Native 调用 Dart方法 ?对于 JNI 里面，我们需要调用 Java的方法，利用Java反射机制调用即可，如下所示： _env-&gt;CallStaticVoidMethod(j_class, j_method, arg1, arg2); 如果 Native 想要调用 Dart代码有类似的代码可以用么？翻遍了 Flutter相关的文档，都没有找到对应的方法可以直接去调用 Dart的方法，Dart Engine内部有 dart_api.h提供了Dart_invoke()方法，但单纯的导入 .h文件在项目中是无法链接到对应的方法的，这也就是为什么需要导入ffi_runtime_lib相关的文件并执行 Dart_InitializeApiDL()，通过动态链接使得代码能够去调用 Dart 封装的相关方法。 所以参考 Dart中 InitDartApiDL的方法，我们先对 Dart 中的函数进行注册，传递对应方法的指针，然后在 Native 中即可调用，理论上可行，后续会补上相关 demo。当然这只是一种骚操作，如果有更好的方法能够用 Native 调用 Dart 欢迎讨论。 四、总结文章记录了 Dart 同步和异步调用 Native 相关的使用，异步具体的使用比上述的代码复杂，因为需要一个中介记录异步相关的回调方法，当得到真正的结果之后，利用id查找到对应的方法再执行回调方法。FFI 在 Native中执行 dart 方法，暂时没有比较好的解决方案FFI 调用可查看 Demo flutter_ffi_tutorial","categories":[{"name":"技术文章","slug":"technology","permalink":"http://vompom.github.com/categories/technology/"}],"tags":[{"name":"Flutter","slug":"Flutter","permalink":"http://vompom.github.com/tags/Flutter/"}],"author":"落叶挽歌"},{"title":"（转）JNI内存管理及优化","slug":"JNI内存管理及优化","date":"2021-03-10T12:08:00.000Z","updated":"2025-05-20T11:46:57.000Z","comments":true,"path":"2021/03/10/JNI内存管理及优化/","permalink":"http://vompom.github.com/2021/03/10/JNI%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%8F%8A%E4%BC%98%E5%8C%96/","excerpt":"","text":"最近接触JNI相关的项目遇到一些与内存相关到问题，JNI或者说是C/C++开发与平时的Java开发相比，总会给人更多的“惊喜”，因为不熟悉native开发，所以有很多知识都不太清楚，一点一点地记录。在掘金相关搜索到下面这篇，个人感觉还不错。以下内容转载自： https://juejin.cn/post/6844903743352209422 上面这张图大家都应该很熟了，下面只讲下和JNI有关的部分 程序计数器记录正在执行的虚拟机字节码指令的地址（如果正在执行的是本地方法则为空）。 本地方法栈本地方法栈与 Java 虚拟机栈类似，它们之间的区别只不过是本地方法栈为本地方法服务。 本地方法一般是用其它语言（C、C++ 或汇编语言等）编写的，并且被编译为基于本机硬件和操作系统的程序，对待这些方法需要特别处理。 堆(Java-Heap)所有对象都在这里分配内存，是垃圾收集的主要区域（”GC 堆”）。 堆不需要连续内存，并且可以动态增加其内存，增加失败会抛出 OutOfMemoryError 异常。 可以通过 -Xms 和 -Xmx 两个虚拟机参数来指定一个程序的堆内存大小，第一个参数设置初始值，第二个参数设置最大值。 java -Xmx1024m -Xms1024m//-Xmx1024m：设置JVM最大可用内存为1024M。//-Xms1024m：设置JVM初始内存为1024m。此值可与-Xmx相同，以避免每次垃圾回收完成后JVM重新分配内存。 在Android系统对于每个应用都有内存使用的限制，机器的内存限制，在/system/build.prop文件中配置的。可以在manifest文件application节点加入 android:largeHeap=&quot;true&quot;来让Dalvik/ART虚拟机分配更大的堆内存空间 直接内存（native堆）也称为C-Heap，供Java Runtime进程使用的，没有相应的参数来控制其大小，其大小依赖于操作系统进程的最大值。 Java应用程序都是在Java Runtime Environment（JRE）中运行，而Runtime本身就是由Native语言（如：C/C++）编写程序。Native Memory就是操作系统分配给Runtime进程的可用内存，它与Heap Memory不同，Java Heap 是Java应用程序的内存。。Native Memory的主要作用如下： 管理java heap的状态数据（用于GC）; JNI调用，也就是Native Stack； JIT（即使编译器）编译时使用Native Memory，并且JIT的输入（Java字节码）和输出（可执行代码）也都是保存在Native Memory； NIO direct buffer； Threads； 类加载器和类信息都是保存在Native Memory中的。 JNI内存在Java代码中，Java对象被存放在JVM的Java Heap，由垃圾回收器（Garbage Collector，即GC）自动回收就可以。 在Native代码中，内存是从Native Memory中分配的，需要根据Native编程规范去操作内存。如：C/C++使用malloc()/new分配内存，需要手动使用free()/delete回收内存。 然而，JNI和上面两者又有些区别。 JNI提供了与Java相对应的引用类型（如：jobject、jstring、jclass、jarray、jintArray等），以便Native代码可以通过JNI函数访问到Java对象。引用所指向的Java对象通常就是存放在Java Heap，而Native代码持有的引用是存放在Native Memory中。 举个例子，如下代码： jstring jstr = env-&gt;NewStringUTF(&quot;Hello World!&quot;); jstring类型是JNI提供的，对应于Java的String类型 JNI函数NewStringUTF()用于构造一个String对象，该对象存放在Java Heap中，同时返回了一个jstring类型的引用。 String对象的引用保存在jstr中，jstr是Native的一个局部变量，存放在Native Memory中。 开发人员都应该遇到过OOM（Out of Memory）异常，在JNI开发中，该异常可能发生在Java Heap中，也可能发生在Native Memory中。 string类型是JNI提供的，对应于Java的String类型 JNI函数NewStringUTF()用于构造一个String对象，该对象存放在Java Heap中，同时返回了一个jstring类型的引用。 String对象的引用保存在jstr中，jstr是Native的一个局部变量，存放在Native Memory中。 开发人员都应该遇到过OOM（Out of Memory）异常，在JNI开发中，该异常可能发生在Java Heap中，也可能发生在Native Memory中。 java.lang.OutOfMemoryError: Java heap spacejava.lang.OutOfMemoryError: native memory exhausted Java Heap 中出现 Out of Memory异常的原因有两种： 1）程序过于庞大，致使过多 Java 对象的同时存在；2）程序编写的错误导致 Java Heap 内存泄漏。 Native Memory中出现 Out of Memory异常的原因： 1）程序申请过多资源，系统未能满足，比如说大量线程资源；2）程序编写的错误导致Native Memory内存泄漏。 JNI引用JNI引用有三种：Local Reference、Global Reference、Weak Global Reference。下面分别来介绍一下这三种引用内存分配和管理。 Local Reference 只在Native Method执行时存在，只在创建它的线程有效，不能跨线程使用。它的生命期是在Native Method的执行期开始创建（从Java代码切换到Native代码环境时，或者在Native Method执行时调用JNI函数时），在Native Method执行完毕切换回Java代码时，所有Local Reference被删除（GC会回收其内存），生命期结束（调用DeleteLocalRef()可以提前回收内存，结束其生命期）。 实际上，每当线程从Java环境切换到Native代码环境时，JVM 会分配一块内存用于创建一个Local Reference Table，这个Table用来存放本次Native Method 执行中创建的所有Local Reference。每当在 Native代码中引用到一个Java对象时，JVM 就会在这个Table中创建一个Local Reference。比如，我们调用 NewStringUTF() 在 Java Heap 中创建一个 String 对象后，在 Local Reference Table 中就会相应新增一个 Local Reference。 Local Reference 表、Local Reference 和 Java 对象的关系 接下来举个简单例子说明一下： jstring jstr = env-&gt;NewStringUTF(&quot;Hello World!&quot;); jstr存放在Native Method Stack中，是一个局部变量 对于开发者来说，Local Reference Table是不可见的 Local Reference Table的内存不大，所能存放的Local Reference数量也是有限的（在Android中默认最大容量是512个），使用不当就会引起溢出异常 Local Reference并不是Native里面的局部变量，局部变量存放在堆栈中，其引用存放在Local Reference Table中。 在Native Method结束时，JVM会自动释放Local Reference，但Local Reference Table是有大小限制的，在开发中应该及时使用DeleteLocalRef()删除不必要的Local Reference，不然可能会出现溢出错误： JNI ERROR (app bug): local reference table overflow (max=512) 在C/C++中实例化的JNI对象，如果不返回java，必须用release掉或delete，否则内存泄露。包括NewStringUTF，NewObject。对于一般的基本数据类型（如：jint，jdouble等），是没必要调用该函数删除掉的。如果返回java不必delete，java会自己回收。 Global Reference Local Reference是在Native Method执行的时候出现的，而Global Reference是通过JNI函数NewGlobalRef()和DeleteGlobalRef()来创建和删除的。 Global Reference具有全局性，可以在多个Native Method调用过程和多线程中使用，在主动调用DeleteGlobalRef之前，它是一直有效的（GC不会回收其内存）。 /** * 创建obj参数所引用对象的新全局引用。obj参数既可以是全局引用，也可以是局部引用。全局引用通过调用DeleteGlobalRef()来显式撤消。 * @param obj 全局或局部引用。 * @return 返回全局引用。如果系统内存不足则返回 NULL。*/jobject NewGlobalRef(jobject obj);/** * 删除globalRef所指向的全局引用 * @param globalRef 全局引用*/void DeleteGlobalRef(jobject globalRef); 使用 Global reference时，当 native code 不再需要访问Global reference 时，应当调用 JNI 函数 DeleteGlobalRef() 删除 Global reference和它引用的 Java 对象。否则Global Reference引用的 Java 对象将永远停留在 Java Heap 中，从而导致 Java Heap 的内存泄漏。 Weak Global Reference 用NewWeakGlobalRef()和DeleteWeakGlobalRef()进行创建和删除，它与Global Reference的区别在于该类型的引用随时都可能被GC回收。 对于Weak Global Reference而言，可以通过isSameObject()将其与NULL比较，看看是否已经被回收了。如果返回JNI_TRUE，则表示已经被回收了，需要重新初始化弱全局引用。Weak Global Reference的回收时机是不确定的，有可能在前一行代码判断它是可用的，后一行代码就被GC回收掉了。为了避免这事事情发生，JNI官方给出了正确的做法，通过NewLocalRef()获取Weak Global Reference，避免被GC回收。 注意点Local Reference 不是 native code 的局部变量很多人会误将 JNI 中的 Local Reference 理解为 Native Code 的局部变量。这是错误的。 Native Code 的局部变量和 Local Reference 是完全不同的，区别可以总结为： ⑴局部变量存储在线程堆栈中，而 Local Reference 存储在 Local Ref 表中。 ⑵局部变量在函数退栈后被删除，而 Local Reference 在调用 DeleteLocalRef() 后才会从 Local Ref 表中删除，并且失效，或者在整个 Native Method 执行结束后被删除。 ⑶可以在代码中直接访问局部变量，而 Local Reference 的内容无法在代码中直接访问，必须通过 JNI function 间接访问。JNI function 实现了对 Local Reference 的间接访问，JNI function 的内部实现依赖于具体 JVM。 注意释放所有对jobject的引用：extern &quot;C&quot;JNIEXPORT jstring JNICALLJava_com_test_application_MainActivity_init(JNIEnv *env, jobject instance, jstring data, jbyteArray array) &#123; int len = env-&gt;GetArrayLength(array); const char *utfChars = env-&gt;GetStringUTFChars(data, 0); jbyte *arrayElements = env-&gt;GetByteArrayElements(array, NULL); jstring pJstring = env-&gt;NewStringUTF(utfChars); jbyteArray jpicArray = env-&gt;NewByteArray(len); env-&gt;SetByteArrayRegion(jpicArray, 0, len, arrayElements); // TODO env-&gt;DeleteLocalRef(pJstring); env-&gt;DeleteLocalRef(jpicArray); env-&gt;ReleaseStringUTFChars(data, utfChars); env-&gt;ReleaseByteArrayElements(array, arrayElements, 0); std::string hello = &quot;Hello from C++&quot;; jstring result = env-&gt;NewStringUTF(hello.c_str()); return result;&#125; 其它的还有： jclass ref= (env)-&gt;FindClass(&quot;java/lang/String&quot;); env-&gt;DeleteLocalRef(ref);复制代码 因为根据jni.h里的定义： typedef jobject jclass; jclass也是jobject。而jmethodID/jfielID和jobject没有继承关系，它们不是object,只是个整数，不存在被释放与否的问题。 局部引用和全局引用的转换注意Local Reference的生命周期，如果在Native中需要长时间持有一个Java对象，就不能使用将jobject存储在Native，否则在下次使用的时候，即使同一个线程调用，也将会无法使用。下面是错误的做法： jstring global;extern &quot;C&quot; JNIEXPORT jstring JNICALLJava_org_hik_libyuv_MainActivity_stringFromJNI( JNIEnv *env, jobject /* this */) &#123; std::string hello = &quot;Hello from C++&quot;; jstring local = env-&gt;NewStringUTF(hello.c_str()); global = local; return local;&#125; 正确的做法是使用Global Reference，如下： jstring global;extern &quot;C&quot; JNIEXPORT jstring JNICALLJava_org_hik_libyuv_MainActivity_stringFromJNI( JNIEnv *env, jobject /* this */) &#123; std::string hello = &quot;Hello from C++&quot;; jstring local = env-&gt;NewStringUTF(hello.c_str()); global = static_cast&lt;jstring&gt;(env-&gt;NewGlobalRef(global)); return local;&#125; 多线程JNIEnv和jobject对象都不能跨线程使用。 对于jobject，解决办法是 a、m_obj = env-&gt;NewGlobalRef(obj);//创建一个全局变量 b、jobject obj = env-&gt;AllocObject(m_cls);//在每个线程中都生成一个对象 对于JNIEnv，解决办法是在每个线程中都重新生成一个env JavaVM *gJavaVM;//声明全局变量(*env)-&gt;GetJavaVM(env, &amp;gJavaVM);//在JNI方法的中赋值JNIEnv *env;//在其它线程中获取当前线程的env m_jvm-&gt;AttachCurrentThread((void **)&amp;env, NULL); 当在一个线程里面调用AttachCurrentThr","categories":[{"name":"技术文章","slug":"technology","permalink":"http://vompom.github.com/categories/technology/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://vompom.github.com/tags/Android/"},{"name":"JNI","slug":"JNI","permalink":"http://vompom.github.com/tags/JNI/"}],"author":"落叶挽歌"},{"title":"{已开源} 阅文 Flutter 混合开发利器 MixStack","slug":"MixStack","date":"2021-02-26T12:56:00.000Z","updated":"2025-05-20T11:46:57.000Z","comments":true,"path":"2021/02/26/MixStack/","permalink":"http://vompom.github.com/2021/02/26/MixStack/","excerpt":"","text":"原文发表于 阅文技术公众号 《{已开源} 阅文 Flutter 混合开发利器 MixStack》 Github开源地址：MixStack MixStack混合栈是我当时刚进入公司不久参与的该项目，对于混合栈的开发说起来很简单，但踩了无数的坑，经常被各种神奇的bug和场景折腾得睡不好觉。还好，最终都挺过来了，项目从启动到开源最后再到文章，不知道被老大哥喷了多少遍，可以说这是我工作生涯中，灰暗而又有收获，非常有意义的一段时间，遂记录该文章于博客。 一、前言Flutter 是一款谷歌的移动 UI 框架，可以快速在 iOS 和 Android 上构建高质量的原生用户界面。Flutter 可以与现有的代码一起工作，相比于其他跨平台的框架，如 React Native、Weex 等，Flutter 具有如下的优势：跨平台表现一致 谷歌直接在 iOS/Android 等平台直接建立了独立的渲染引擎，保证了界面渲染的高效且多端有接近原生性能的表现。快速开发 开发过程中提供了高效的热重载，开发便捷。已有工具链已经比较强大。 二、随之而来的问题当我们尝试将 Flutter 集成到项目中的时候，却发现现实比想象骨感许多，这里我们以 Android 平台的探索为例进行说明。 对于 Android 平台，官方封装了 FlutterAcitivity 以及 FlutterFragment 两种 Flutter 原生容器，当我们直接使用时，能正常打开 Flutter 页面，但是表现却并不如我们所期待。 其中最明显的就是，官方会为每个 FlutterAcitivity 和 FlutterFragment 生成一个新的 FlutterEngine 实例。每个 FlutterEngine 拥有不同的 Isolate，也就是说不同的 Dart 运行环境完全独立，其内存状态不进行共享。对于大多数 App 来说，多数页面有一些全局状态（例如登录态）。如果基于 Flutter 默认的设计，两个不同容器里的 Flutter 页面通信将变得异常复杂。另外每个 FlutterEngine 实例的内存开销本身就非常大，例如同一张图片由于内存状态不共享，在 n 个 Engine 中会存在 n 份，这显然是不可接受的。 这就是当我们想把 Flutter 与现有业务代码混合使用时会遇到的 问题1：多 FlutterEngine 实例间内存状态不共享 对于多 FlutterEngine 实例带来的问题远不止这些，官方提供给了我们一种解决方案：共享 FlutterEngine，全局只有一个 FlutterEngine 实例，将其放入缓存管理中。当我们尝试使用这种方案连续打开两个 FlutterActivity，页面却会冻住，停止渲染. 问题2：Flutter 原生容器在共享 FlutterEngine 情况下渲染生命周期错误 另外，在业务场景中，常有类似这样的页面跳转情况：Native Activity-&gt;Flutter Activity-&gt;Native Activity-&gt;Flutter Activity-&gt;Native Activity ，其中 Flutter Activity 中拥有几个不同的 Flutter Page，如下图所示： 对于 FlutteActivity 或者 FlutterFragment 中的 Flutter 页面来说我们需要将其与原生页面对齐，页面栈变成下图会更容理解： 当我们处于 FlutterActivity A 中页面时，对于一些业务场景有顶部 NavigationBar、Back 按键以及手势返回的时候，用户基于常见的栈“先进后出”的原则，对于 FlutterActivity A 中的页面，期望的是先关闭掉其最上层的 Flutter 页面，再依次关闭f3、f2、f1。最终关闭掉该 FlutterActivity 展示 Natvie Activity A。然而实际的情况是：如果不修改相关逻辑，会直接 finish 掉整个 Activity，那么f1、f2、f3……会被同时关闭。 问题3：Flutter 原生容器中 Flutter 页面栈管理与预期不符 在每个 FlutterActivity 中存在一个 FlutterView，FlutterView 承载了不同的 Flutter 页面也就是不同的 FlutterWidget，其Flutter 内部不同的 Widget 可以通过Navigator控制，我们需要将其做到与原生对齐，形成一套用户无感，开发者较浅感知的页面栈管理方案。 随着深入了解会发现更多的问题，页面切换闪屏、App 启动白屏、Flutter Dialog 展示底部白屏、状态栏高度颜色不正确等等等等。 三、解决方案业内 Flutter 混合栈的研究已经开始很久了，但仍没有一款真正的完美解决方案，我们希望这次推出的 MixStack 是这样的方案。经过一系列的探索，我们解决了上述问题，并在实际上线的 App 红袖中进行了验证，取得了较好的效果。 接下来具体讲解MixStack的实现 1.共享FlutterEngine 为了解决问题1：多 FlutterEngine 实例间内存状态不共享，我们选择对 FlutterEngine 进行共享，保持全局只有一个 FlutterEngine。 这样使得所有相关操作都在同一个Isolate，对于之前所说的全局状态（例如登录态）以及类似同一份图片缓存存在多份的问题也就迎刃而解了。 2.正确的渲染生命周期 关于问题2：Flutter 原生容器在共享 FlutterEngine 情况下渲染生命周期错误。默认的 FlutterActivity 和 FlutterFragment 对于共享 FlutterEngine 的支持不太好，我们对其进行了相关修改。基于任何时候只能看到一个 Flutter 原生容器的假设，且 FlutterEngine 同一时刻也只能渲染一个 FlutterView，因此我们约定：对每一个 FlutterView 在可见的时候对其进行渲染相关的准备，在即将不可见的时候使其从渲染上脱离。那该如何实现 Flutter 原生容器顺畅交互呢？我们先看两个容器间切换的生命周期，通常情况下 Activity A 启动 Activity B 生命周期如下图所示： FlutterEngine 在原生层面定义了LifecycleChannel，主要作用是向 Flutter 发送渲染生命周期相关的事件。LifecycleChannel主要发送了四种状态事件： AppLifecycleState.resumed、 AppLifecycleState.inactive、 AppLifecycleState.paused、 AppLifecycleState.detached。 阅读源码后可知，FlutterEngine 在 AppLifecycleState.resumed 执行了启动渲染的操作。 而 AppLifecycleState.paused、 AppLifecycleState.detached停止了渲染操作，也就是说处于这两个生命周期中，页面内的内容不会被重绘。 那么我们可知要使 FlutterEngine 渲染交互正常需要满足以下要求： (1) FlutterEngine 生命周期处于 AppLifecycleState.resumed (2) FlutterEngine attach 在当前可见的 FlutterView 那么对于 FlutterActivity，只需在 FlutterActivity onResume() 的时候执行以上操作，使得 FlutterEngine 能够渲染当前页面。当 FlutterActivity 需要启动另一个 FlutterActivity 时，FlutterEngine 需要将其从当前 FlutterView detach 并停止渲染。整个流程如下图所示： 同理，FlutterActivity 打开原生的 Activity 的时候，我们依然需要在 onPause() 的时候，对 FlutterView 进行 detach 操作，保证在新打开原生 Activity 之后，如有再打开的其他的 FlutterActivity 也能够维护正常生命周期。 在多数 App 中都有 Tab 类的界面，一般都是：NavigationBar 加 Fragment 的组合，那当这种场景中混合了多个 FlutterFragment，我们又该如何做呢，Fragment组合如下图所示： 我们同样基于之前的假设，在 FlutterFragment onResume() 的时候，attach 到FlutterEngine，使得 FlutterEngine 能够渲染当前页面，onPause 的时候 detach。 对于多个 Tab 之间 FlutterFragment 的切换，只多了一步操作，在 onHiddenChanged() 的时候，对 FlutterEngine 进行相应的操作，需要留意的是，在 onPause() 或者 onResume() 操作的时候需要添加 isHidden() 判断，保证当前渲染的是可见的那个 FlutterFragment。 FlutterFragment 的渲染流程如下图所示： 至此我们成功地解决了问题2：原生 Flutter 容器在共享 FlutterEngine 情况下渲染生命周期错误 (3) Flutter 页面相关的约定 前面两点的实现，使我们能够成功让 Flutter 原生容器如正常原生页面一般使用，但依然有问题3：原生 Flutter 容器中 Flutter 页面栈管理与预期不符 未解决。为了解决问题3, 我们需要额外增加一些约定，将每一个原生栈中的 Flutter 原生容器映射为 Flutter 中的一个容器，我们称为 PageContainer。 如下图所示： 每个 PageContainer 有以下特性： 1、包含独立 Navigator，PageContainer 间互不影响 2、有一个根页面，通过根路径（rootRoute）形式传入 在每个 Flutter 原生容器实现接口传入 rootRoute 属性，在页面可见的时候，MixStack 会向 Flutter 通信，告知即将显示的页面。 3、默认对于原生环境的 Inset 无感，通过额外 API 传入（降低性能开销） Flutter 对于渲染画布的尺寸变化非常敏感，某些情况下会导致 Widget 状态异常，例如 Tab 滑动位置丢失等等问题，所以 MixStack 默认为 Flutter View 尺寸不变化，推荐将影响 View 内 Flutter 组件排版的 inset 变化通过 API 传入。 MixStack 基于 Channel 通信告知 Flutter 当前所有页面信息 (pages) 及当前需要显示 Flutter 页面 (currentPage)，Flutter 基于信息更新 Widget。每个 PageContainer 与 Flutter 原生容器的 hashCode 有唯一映射关系，从而保证页面状态持久化。 另外我们在 iOS 和 Android 上接管了返回指令，并与 Flutter 端进行同步，满足返回预期。 最后的效果就如我们所期望的： 四、总结至此我们解决了上述三大问题，构建出了一套能够正确维护原生⻚面与 Flutter ⻚面交互的完整解决方案。 当然关于项目中集成使用 Flutter 所带来的麻烦并不局限于上述问题，Flutter 本身也存在一些 Bug，MixStack 已经将相关的问题在库内解决或者提交官方补丁。经过线上 App 的实际验证，对首⻚多FlutterFragment 、 Flutter 各种弹窗 、各种 Flutter 容器与原生之间的切换等情况均表现正常。 目前 MixStack 已经全量在阅文旗下红袖 App 上使用，他们在极短时间内借助 MixStack 能力平滑移除了对 RN 的依赖，同时仍正常交付日常功能需求。 一款成熟的 App 将现有的⻚面完全转化为 Flutter ⻚面，改造的成本太大，周期太⻓，或者有一些业务场景⻚面需要 Native 的能力，需要一个能方便管理原生与 Flutter 混合⻚面的管理工具，那么 MixStack 将是一个非常好的选择。","categories":[{"name":"技术文章","slug":"technology","permalink":"http://vompom.github.com/categories/technology/"}],"tags":[{"name":"Flutter","slug":"Flutter","permalink":"http://vompom.github.com/tags/Flutter/"}],"author":"落叶挽歌"},{"title":"Flutter坑之FlutterFragment中SafeArea失效的问题","slug":"Flutter坑之FlutterFragment中SafeArea失效的问题","date":"2020-10-31T06:40:00.000Z","updated":"2025-05-20T11:46:57.000Z","comments":true,"path":"2020/10/31/Flutter坑之FlutterFragment中SafeArea失效的问题/","permalink":"http://vompom.github.com/2020/10/31/Flutter%E5%9D%91%E4%B9%8BFlutterFragment%E4%B8%ADSafeArea%E5%A4%B1%E6%95%88%E7%9A%84%E9%97%AE%E9%A2%98/","excerpt":"","text":"最近有在做关于Android底部多tab下，对应多个Flutter Fragment的操作。又遇到一个比较坑的问题:FlutterFragment中的flutter页面的SafeArea失效（关于safeArea具体介绍参考官方SafeArea class），简单举例说一下SafeArea的作用：如果你有一刘海屏的手机，如果你的flutter内容为全屏，假如你的内容在全屏最顶部，那么所谓的刘海将会盖住你所想要的内容，如下图所示：这当然不是我们想要的，于是Flutter官方推出：SafeArea这个属性，在dart语言中只需要在你的widget最外层包裹SafeArea就好了。 @overrideWidget build(BuildContext context) &#123; return Scaffold( body: SafeArea( child: TabBarView( controller: mController, children: &lt;Widget&gt;[] );&#125; 于是得到了正确的展示效果，如下图所示： 你以为这样就完了么？在多个Flutter Fragment中SafeArea的作用失效，尽管我在flutter中设置了SafeArea，但依然存在刘海盖住flutter content的情况。 原因分析：这真的是一件很头疼的事情，对应的Flutter page在Flutter Activity中能够正常work，但是偏偏在Fluttter Fragment中就出问题了呢？于是又去看FlutterView源码，果然有收获！发现一个方法：onApplyWindowInsets()这里面有一大堆逻辑，很多都是关于处理 statusBar以及navigationBar，更惊喜地还发现了处理DisplayCutout的逻辑，这不就是刘海屏相关的类么！以下是部分代码逻辑： public final WindowInsets onApplyWindowInsets(WindowInsets insets) &#123; ... if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.R) &#123; int mask = 0; if (navigationBarVisible) &#123; mask = mask | android.view.WindowInsets.Type.navigationBars(); &#125; if (statusBarVisible) &#123; mask = mask | android.view.WindowInsets.Type.statusBars(); &#125; ... // TODO(garyq): Expose the full rects of the display cutout. // Take the max of the display cutout insets and existing padding to merge them DisplayCutout cutout = insets.getDisplayCutout(); if (cutout != null) &#123; Insets waterfallInsets = cutout.getWaterfallInsets(); mMetrics.physicalPaddingTop = Math.max( Math.max(mMetrics.physicalPaddingTop, waterfallInsets.top), cutout.getSafeInsetTop()); ... &#125; &#125; else &#123; // Status bar (top) and left/right system insets should partially obscure the content // (padding). ... &#125; updateViewportMetrics(); return super.onApplyWindowInsets(insets); &#125; 很明显这一块逻辑是处理刘海屏以及StatusBar相关的逻辑，于是进行相关的断点调试，发现FlutterFragment中的FlutterView的确是没有执行这个方法，对比同样在FlutterActivity中的FlutterView正常work并执行了这一串代码。 ！那这不就神奇了么？这一下子又让人头秃了，这一定又是跟Fragment的相关机制导致的，自己对Fragment的具体处理逻辑不太熟，于是各种Google，找到两篇有点类似的答案：1、fitsSystemWindows effect gone for fragments added via FragmentTransaction2、一个Activity中添加多个Fragment导致fitsSystemWindows无效的问题 引入上面的解释说： 当第一个Fragment添加到Activity中的时候，Activity寻找出有fitsSystemWindows的子布局为其预留出状态栏的空间，其实就是设置一个padding，而其他Fragment添加到Activity中的时候，因为状态栏空间的适配已经被消费过一次了，Activity并不会再次去添加这个padding 虽然这里在进行fitsSystemWindows的操作，但是我们明确了一件事情：添加多个Fragment的时候，Activity对于padding相关操作只在第一个Fragment进行了相关处理逻辑。那么对应我们的FlutterFragment是否是同样的问题呢？？ 于是我进行了尝试，将Flutter Fragment放在Acitvity第一个需要展示的Fragment，经过尝试发现第一个FlutterFragment能正常work了！但之后的Flutter Fragment问题依然存在，那么我们可以肯定也就是说：在多FlutterFragment中的FlutterView，只有在作为Acitivty添加为第一个Fragment的情况下才会去调用 onApplyWindowInsets(WindowInsets insets) 方法去处理一些statusBar相关的操作逻辑。的确事实如此，经过尝试之后发现的确只会调用一次，那么如何解决呢？ 解决方案：参照上面的解决方案，可以写一个WindowInsetsFrameLayout继承FrameLayout，并setOnHierarchyChangeListener()监听Fragment的添加操作，在添加的时候执行 view的requestApplyInsets(); 当然对于我们的问题并没有这么麻烦，我们在自己的FlutterFragment中手动去执行flutterView.requestApplyInsets();只需要执行时机保证在flutter渲染之前执行（Safe Area通过获去Native端onApplyWindowInsets()中传过去的params来执行相关渲染） 但还有一个问题：flutterView.requestApplyInsets();只能在Api大于20中使用，那么低于20呢？与其说低于20，不如直接说，19中怎么处理（Android 4.4 api 19引入的透明状态栏 、沉浸式相关），我们可以看到，在onApplyWindowInsets() 中最终是发送一个事件到flutter端，如下代码所示。 private void sendViewportMetricsToFlutter() &#123; if (!isAttachedToFlutterEngine()) &#123; Log.w( TAG, &quot;Tried to send viewport metrics from Android to Flutter but this &quot; + &quot;FlutterView was not attached to a FlutterEngine.&quot;); return; &#125; viewportMetrics.devicePixelRatio = getResources().getDisplayMetrics().density; flutterEngine.getRenderer().setViewportMetrics(viewportMetrics);&#125; 那么对于Api 19就可以对相关数据进行反射调用，之后再讲数据发送到flutter端即可，那么大致逻辑如下所示： public void onViewCreated(@NonNull View view, @Nullable Bundle savedInstanceState) &#123; super.onViewCreated(view, savedInstanceState); if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.KITKAT_WATCH) &#123; flutterView.requestApplyInsets(); &#125; else &#123; adapterStatusBarBelowApi20(); &#125; &#125; 总结：1、这个问题在官方的FlutterFragment中也存在，但不知道为什么没有修复，可能他们真的不太重视混合开发吧，一心在纯flutter开发中。2、关于为什么Fragment 相关操作逻辑只在第一个被Fragment被添加，这里涉及到了太多底层的东西，这里没有赘述，打算深入研究，写一篇新到blog中去介绍。3、Flutter坑实在是太多了，很多问题都与Android原生机制相关，这不得不让人对原生系统机制进行深入学习。","categories":[{"name":"技术文章","slug":"technology","permalink":"http://vompom.github.com/categories/technology/"}],"tags":[{"name":"Flutter","slug":"Flutter","permalink":"http://vompom.github.com/tags/Flutter/"}],"author":"落叶挽歌"},{"title":"Flutter坑之共享FlutterEngine页面切换无法点击","slug":"Flutter坑之共享FlutterEngine页面切换无法点击","date":"2020-09-21T11:22:00.000Z","updated":"2025-05-20T11:46:57.000Z","comments":true,"path":"2020/09/21/Flutter坑之共享FlutterEngine页面切换无法点击/","permalink":"http://vompom.github.com/2020/09/21/Flutter%E5%9D%91%E4%B9%8B%E5%85%B1%E4%BA%ABFlutterEngine%E9%A1%B5%E9%9D%A2%E5%88%87%E6%8D%A2%E6%97%A0%E6%B3%95%E7%82%B9%E5%87%BB/","excerpt":"","text":"最近在研究做Flutter一块相关的内容，方案上采用的是单FlutterEngine，全局Flutter元素共用一个FlutterEngine，对于使用单Engine遇到一个很大的坑，页面切换之后无法点击，页面就像卡死了一样，以下三种情况都会发生： 第一种：两个FlutterFragment在tab中进行切换，假如AB代表两个FlutterFragment，当A切换到B，再从B切换到A的时候，页面就无法点击。 第二种：在FlutterActivity中打开新的FlutterActivity，新的FlutterActivity页面跟上述的情况一样，也是无法点击。 第三种：在Tab中打开FlutterFragment之后再打开FlutterActivity，情况一样，依然无法点击。 如下动图所示： （来自issue https://github.com/flutter/flutter/issues/49950） 但他们有一个共同的特点：当页面卡死的时候，手动进入后台（打开任务管理或者home键退出）再回到前台，页面就会“刷新”，一切又变得正常了。那么推测：多半与跟页面Fragment和Activity的生命周期有关。我尝试了在进入页面后,再手动模拟“页面退出再回来的周期”，也就是先调用一次onPause()再调用一次onResume()，然而并没有什么卵用…… 可这是为什么呢？？太坑了……踏遍了千山万水也没有找到有人有解决方案，很多人都说别用共享引擎，但是想到 闲鱼Flutter_boost 和HelloBike的thrio框架也都是用的共享引擎啊，他们为什么没有问题？找了很久的解决方法，两天，甚至晚上做梦都梦在关于这个问题。真的是……难受。加了各种各样的群，也没有人能解答这个问题。终于……我去打印了两个Activity的生命周期，才发现事情的端倪。 关于Activity与Fragment的切换的生命周期这里向大家在简单介绍一下Activity和Fragment切换生命周期，相信大家都有被面试问过：现在有两个Activity A和B，在A打开B这一段时间Activity的生命周期变化情况： A.onPause() -&gt;B.onCreate()-&gt; B.onStart() -&gt;B.onResume() -&gt;A.onStop()A的onStop() 的调用情况分为两种：当设置Activity A的主题windowIsTranslucent属性为true，A Activity并不会调用onStop方法，只会调用onPause()方法。 ok说完了Activity再说说Fragment，对于我们的问题：Fragment生命周期考虑tab间切换（也就是两个FlutterFragment之间的切换），两个Fragment的切换，并不会导致Fragment的onPause()和onStop()调用，只会调用onHiddenChanged(boolean hidden)，hiden为true表示该Fragment被隐藏了，false表示当前Fragment可见。 关于Flutter单Engine方案现在关于讲解Flutter单Engine方案也比较多，推荐去看这篇—&gt; 为追求高性能，我必须告诉你Flutter引擎线程的事实… 关于对单Engine的讲解，单Engine方案，我们可以简单理解为：所有应用中的FlutterView都是由同一个FlutterEngine来渲染的。当然这看起来是废话，但这就是问题的关键，那么对于所有的FlutterView都是用的同一个FlutterEngine渲染，那么FlutterEngine是怎么去控制的呢？如果让你去设计，你会怎么设计呢？ 这篇博客—&gt;flutter单引擎方案讲解了一种单Engine的实现方案，可以参考，不过其中也需要对Engine进行多次new，不过这并不是最重要的，我们需要明白的是：当FlutterEngine去渲染FlutterView B的时候，它需要attach再在B上，从FlutterView A detach掉，再返回FlutterView A的时候，它需要从FlutterView B上detach掉，再attach到A上。 Flutter坑！现在我们明白了生命周期的变化，我们接下来去看FlutterActivity中响应生命周期中的源码。对于FlutterActivity A打开FlutterActivity B，他们依次会调用： A.onPause() -&gt;B.onCreate()-&gt; B.onStart() -&gt;B.onResume() -&gt;A.onStop()我们来看看FlutterActivity在对应的生命周期里面做了什么, 对于A.onPause() @Overrideprotected void onPause() &#123; super.onPause(); delegate.onPause(); lifecycle.handleLifecycleEvent(Lifecycle.Event.ON_PAUSE);&#125; 我们知道：FlutterActivity和Fragment主要由FlutterActivityAndFragmentDelegate来进行管理，这里我们主要关注delegate里面的内容 void onPause() &#123; Log.v(TAG, &quot;onPause()&quot;); ensureAlive(); flutterEngine.getLifecycleChannel().appIsInactive();&#125; 这里是关键我们看到了flutterEngine与生命周期相关的代码，接下来我们看其他几个生命周期里面对于flutterEngine的Lifecycle管理情况 对于B.onCreate()只进行了相关的view创建工作. 对于B.onStart()中有执行doInitialFlutterViewRun();，其中比较关键的一句就是： if (host.getInitialRoute() != null) &#123; flutterEngine.getNavigationChannel().setInitialRoute(host.getInitialRoute());&#125; 对于B.onResume() void onResume() &#123; Log.v(TAG, &quot;onResume()&quot;); ensureAlive(); flutterEngine.getLifecycleChannel().appIsResumed();&#125; 最后是A.onStop() void onStop() &#123; Log.v(TAG, &quot;onStop()&quot;); ensureAlive(); flutterEngine.getLifecycleChannel().appIsPaused();&#125; 看到了A.onStop()，聪明的人应该都看出来问题了，我们重新整理一下从Activity A启动到B，flutterEngine相关的生命周期主要执行了以下流程： A.onPause() -&gt; flutterEngine.getLifecycleChannel().appIsInactive()B.onCreate()-&gt; nothing.B.onStart() -&gt; flutterEngine.getNavigationChannel().setInitialRoute(host.getInitialRoute());B.onResume() -&gt; flutterEngine.getLifecycleChannel().appIsResumed();A.onStop()-&gt; flutterEngine.getLifecycleChannel().appIsPaused(); 其实问题已经出来了：由于我们使用的是单FlutterEngine方案，那么上面生命周期中的flutterEngine为同一实例！，由于Activity的生命周期机制，前一个Activity的生命周期的onStop是在最后调用的，也就是这时候告诉了FlutterEngine: 这时候appIsPaused，你不用在渲染了，那么这时页面就会成一种“卡死”的状态！正常的生命周期这时候FlutterEngine应该是appIsResumed()。这也就能解释为什么退出到后台（调用了onPause()）再回来（调用onResume()）最终的FlutterEngine是调用了.appIsResumed();显示正常。 于是找到问题了，那么如何解决呢？这还不简单，当然是去绕过不用去调用A.onStop()呀！怎么可能不用调用A.onStop() 呢？错了，不用去调用其中的delegate中的flutterEngine.getLifecycleChannel().appIsPaused();就好了，我这边的方案与Flutter_boost的方案一样，也对FlutterActivty的代码进行了重写，所以能比较灵活的去改动FlutterActivityAndFragmentDelegate。 void onStop() &#123; Log.v(TAG, &quot;onStop()&quot;); ensureAlive(); // flutterEngine.getLifecycleChannel().appIsPaused();&#125; 对于Fragment的切换也是同样一个思路，就留着大家想一下吧。 总结1、Activity A切换到B的生命周期（A不透明的情况下）：A.onPause() -&gt;B.onCreate()-&gt; B.onStart() -&gt;B.onResume() -&gt;A.onStop() 2、至于flutterEngine.getLifecycleChannel().appIsPaused();内部具体做了什么事，还得具体去研究一下，字面上理解就是。 3、Flutter混合原生做开发坑实在是太多了，官方也没有做相应的解决方案，有什么问题，一定要大胆的想，大胆的去尝试！","categories":[{"name":"技术文章","slug":"technology","permalink":"http://vompom.github.com/categories/technology/"}],"tags":[{"name":"Flutter","slug":"Flutter","permalink":"http://vompom.github.com/tags/Flutter/"}],"author":"落叶挽歌"},{"title":"从Android返回键退出和直接杀死进程退出说起","slug":"从Android返回键退出和直接杀死进程退出说起","date":"2020-09-09T01:31:00.000Z","updated":"2025-05-20T11:46:57.000Z","comments":true,"path":"2020/09/09/从Android返回键退出和直接杀死进程退出说起/","permalink":"http://vompom.github.com/2020/09/09/%E4%BB%8EAndroid%E8%BF%94%E5%9B%9E%E9%94%AE%E9%80%80%E5%87%BA%E5%92%8C%E7%9B%B4%E6%8E%A5%E6%9D%80%E6%AD%BB%E8%BF%9B%E7%A8%8B%E9%80%80%E5%87%BA%E8%AF%B4%E8%B5%B7/","excerpt":"","text":"最近开发的时候，使用了一个单例模式，当我返回键退出App，再重新启动，发现App的确是从首页启动，但还没有执行为单例类设置数值的位置。可是！断点调试的时候发现这时候已经有了一个数据，并且是上一次运行留下的数据，当时觉得很神奇，明明根Activity已经执行了OnDestroy()，而且再启动的确是从首页过来的，讲道理应该是“everything will be new”，但是单例里面的数据仍然存在，这可是为什么呢？ Google搜了一下，噢！恍然大悟，看到这一块的知识很久没有用就忘掉了，或者说对运行机制相关还不太熟悉吧，所以在此重新整理总结一份。 返回键退出和直接杀死进程退出的区别？直接杀死退出：所有的内存都会被回收，重新启动应用程序时，会重新调用Application的OnCreate()方法，会调用onSaveInstanceState方法。 返回键退出程序：退出程序后，一些加载过的静态变量并没有被回收，重新启动也不需要调用Application的OnCreate()方法。 于是我们就知道，静态变量并没有被回收，而我们的单例模式实例就是静态变量，没有被回收，于是我们就知道为什么单例模式数据还存在了，于是在响应的位置对其数据进行释放。可是 why？这两者的差异究竟是什么导致的？我们要知其然，也要知其所以然。 关于直接杀死进程这里我们应该很好去理解，Android中的每一个App都是运行在自己VM实例之中(沙盒)。每一个VM实例在linux中又是一个单独的进程，通过任务管理杀掉一个进程，那么对应进程里面的数据全部被回收掉。 关于返回键退出通过对源码的追溯，如果不对onBackPressed()做特殊的处理，无论是AppCompatActivity还是android.app.Activity，发现都会通过执行onBackPressed(),最后到Activity的finish()方法，也就是说当App退出到根的时候，最终只是执行的是当前App根Activity的finish()方法，整个App“依然在运行”，只是看不到界面了，那么也就是说，如果在App中运行的Service之类的后台任务并没结束，仍然在运行。 那为什么单例模里面的静态变量没有回收呢？如果问你的话，你怎么答？emmmmm……因为……它没有被销毁嘛，所以它还在。当然不能这么回答了，需要用理论依据来解释。 关于方法区与静态变量我们知道静态变量存在与JVM的方法区中，静态变量在类被加载的时候分配内存，Java虚拟机规范中说过可以不要求虚拟机在方法区实现垃圾收集，如下图所示： 那么我们是不是可以理解为方法区中不会进行垃圾回收？查到来自《深入理解Java虚拟机》中的解释： 很多人以为方法区（或者HotSopt 虚拟机中的永久代）是没有垃圾收集的，Java虚拟机规范中确实说过可以不要求虚拟机在方法区实现垃圾收集，而且性价比一般较低，在对的新生代生一般能回收70%~95%的空间，而永久代远低于此。 永久代的垃圾手机主要回收两部分内容：废弃常量和无用的类。 回收废弃常量与回收Java堆中的对象非常相似。以常量池中字面量的回收为例，若字符串“abc”已经进入常量池中，但当前系统没有任何String对象引用常量池中的“abc”常量，也没有其他地方引用该字面量，若发生内存回收，且必要的话，该“abc”就会被系统清理出常量池。常量池中其他的类（接口）、方法、字段的符号引用与此类似。 无用的类需要满足3个条件： （1）该类所有的实例都已经被回收，即Java堆中不存在该类的任何实例；（2）加载该类的ClassLoader已经被回收；（3）该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。 那么对于我们的静态变量来说，如果不是我们手动处理的话设置实例为null的话，或其他操作的话，那么就不会满足上面的条件。那么静态变量会在什么时候被销毁呢？答案很简单了就：静态变量在类被卸载的时候销毁，类在什么时候被卸载？在进程结束的时候。那么这也自然能解释我最开始遇到的情况了，返回键返回结束App后进程并没有结束，当下一次再启动App的时候，进程并没有销毁而，因是同一个进程，所以单例中的数据依然存在。","categories":[{"name":"技术文章","slug":"technology","permalink":"http://vompom.github.com/categories/technology/"}],"tags":[{"name":"安卓","slug":"Android","permalink":"http://vompom.github.com/tags/Android/"}],"author":"落叶挽歌"},{"title":"扇形等分-突然想到的一个数学问题","slug":"扇形等分-突然想到的一个数学问题","date":"2020-09-01T07:13:00.000Z","updated":"2025-11-08T03:27:40.918Z","comments":true,"path":"2020/09/01/扇形等分-突然想到的一个数学问题/","permalink":"http://vompom.github.com/2020/09/01/%E6%89%87%E5%BD%A2%E7%AD%89%E5%88%86-%E7%AA%81%E7%84%B6%E6%83%B3%E5%88%B0%E7%9A%84%E4%B8%80%E4%B8%AA%E6%95%B0%E5%AD%A6%E9%97%AE%E9%A2%98/","excerpt":"","text":"ps:博客有可能会因为一些 markdown 兼容性不支持，可以查看：https://www.douban.com/note/776327336/","categories":[{"name":"算法研究","slug":"算法研究","permalink":"http://vompom.github.com/categories/%E7%AE%97%E6%B3%95%E7%A0%94%E7%A9%B6/"}],"tags":[{"name":"数学","slug":"数学","permalink":"http://vompom.github.com/tags/%E6%95%B0%E5%AD%A6/"}],"author":"落叶挽歌"},{"title":"《头发--一部趣味人类史》 ","slug":"《头发-一部趣味人类史》","date":"2020-08-20T14:14:00.000Z","updated":"2025-05-20T11:46:57.000Z","comments":true,"path":"2020/08/20/《头发-一部趣味人类史》/","permalink":"http://vompom.github.com/2020/08/20/%E3%80%8A%E5%A4%B4%E5%8F%91-%E4%B8%80%E9%83%A8%E8%B6%A3%E5%91%B3%E4%BA%BA%E7%B1%BB%E5%8F%B2%E3%80%8B/","excerpt":"","text":"作为程序员，经常听到与“秃头”这个词相结合起来，其实我是不太相信的，毕竟身边秃头的是极少的，可谁秃头跟程序员这个职业有必然联系么？如果有有必然联系那是为什么呢？ 一直都有着好奇的心，可一直没有进行相关的了解查询，巧的之前在江西省图书馆发现了这本有趣的书，当时没有看完，后来直接在当当买了一本，真的是非常值的，大力推荐这本书。豆瓣编辑推荐语： 本书是一部关于毛发的趣味文化史，行文轻松有趣，信息量庞大。它以头发为切入点，通过一段段有趣的故事，从历史、艺术、文化、社会、工业、科学等角度，勾勒了毛发在人类历史进程中扮演的种种角色：从头发起源的生物演变、令人困扰的毛发疾病，到毛发在人类社交过程中蕴含的丰富的政治、社会信息；从理发的历史到制造、使用假发的种种幕后故事，再到以获取毛发（皮）为动机，驱动贪婪的商人开辟新航路、改变世界历史。 由于书中涉及的头发的知识面比较太广，细小的毛发居然有这么多我们不知道的事情，其中最有意思的莫过于理发师与外科手术的联系吧。 我们都曾在理发店门口，见到过这样的东西，一根旋转的光柱，含有三种颜色：红、白、蓝。 理发店为什么会放这个东西呢？本书则就这一事情就有很详细地进行了讲解：在古代人眼里，理发与外科手术是一类事情，都是医治人的身体，在某种程度上来说，两者的意义是一样的。在一次会议之后，形成了一个新的职业—理发师兼外科医生。英国国王为表彰他们的重要贡献，专门成立了一个理发师公会，作为行业的典范，授予公会成员在伦敦拥有理发和外科手术的垄断权。但有一群专门的外科医生不满这个垄断权（因为外科医生觉得自己做手术能力是比理发修建更有技术些），于是他们无视垄断，又重新成立了一个公会叫：外科医生联合会。这两个公会之间就因为争夺生意而纠纷不断。最终两者的矛盾无法调和，最终在1745年，分道扬镳：分别创立了外科联合会与理发师联合会。 对于理发师联合会，他们对于原本的“理发师兼外科医生”中的“外科医生”残留痕迹可能就是理发店外面的旋转柱了，代表着常见的放血术。为排出那些有毒的血液，理发师兼外科医生会切开血脉放血，然后用绷带包扎。在平时，理发师兼外科医生会把干净的白色绷带缠在杆子上，然后把杆子放在店前作为提供服务的标志。 在最初，门口摆放这种柱子代表这家店，后来，他们不再摆放真的杆子和绷带，而是用仿照实物造型喷上油漆的柱子来代替：柱子有时会涂成红色和白色（代表动脉和绷带），有时会涂成红色、白色和蓝色（象征静脉），这根柱子便成为了能表明提供理发服务的标志。","categories":[{"name":"读书电影","slug":"movie","permalink":"http://vompom.github.com/categories/movie/"}],"tags":[{"name":"读书","slug":"读书","permalink":"http://vompom.github.com/tags/%E8%AF%BB%E4%B9%A6/"}],"author":"落叶挽歌"},{"title":"诗歌-《你是天上的星星》","slug":"诗歌-你是天上的星星","date":"2020-08-12T10:20:00.000Z","updated":"2025-08-25T14:11:48.421Z","comments":true,"path":"2020/08/12/诗歌-你是天上的星星/","permalink":"http://vompom.github.com/2020/08/12/%E8%AF%97%E6%AD%8C-%E4%BD%A0%E6%98%AF%E5%A4%A9%E4%B8%8A%E7%9A%84%E6%98%9F%E6%98%9F/","excerpt":"","text":"","categories":[{"name":"生活感想","slug":"life","permalink":"http://vompom.github.com/categories/life/"}],"tags":[{"name":"诗歌","slug":"诗歌","permalink":"http://vompom.github.com/tags/%E8%AF%97%E6%AD%8C/"}],"author":"落叶挽歌"},{"title":"《美丽的数学》-有趣的数学","slug":"《美丽的数学》-有趣的数学","date":"2020-07-25T15:07:00.000Z","updated":"2025-11-04T14:33:11.552Z","comments":true,"path":"2020/07/25/《美丽的数学》-有趣的数学/","permalink":"http://vompom.github.com/2020/07/25/%E3%80%8A%E7%BE%8E%E4%B8%BD%E7%9A%84%E6%95%B0%E5%AD%A6%E3%80%8B-%E6%9C%89%E8%B6%A3%E7%9A%84%E6%95%B0%E5%AD%A6/","excerpt":"","text":"数学有趣而美妙。书名《美丽的数学》，封面设计得非常的棒，简单优美的线条组合组成了这一蜗牛壳形状，让我们还没有翻开书就已经看到了数学的美丽。这本书看的时间不太长，因为有很多内容已经比较熟悉了，比如斐波那契数列、费马、概率相关。不过更很多内容，让人很着迷。 一个奇迹般的等式我们都知道数学中有这样几个数字： \\pi \\ \\ \\ e \\ \\ i但你可知道他们之间也有一个等式关系： e^{i\\pi} + 1 = 0这个方程真的很震撼，有一种得到“统一”的感觉，就像麦克斯韦电磁理论建立以后，光学也变成了电磁学的一个分支了，电学、磁学和光学得到了统一。看似没有关联的数字，但他们之间存在着这样的联系，就这一个简单的公式就能把数学中最常用的五个数学符号给统一起来了，不得不服气。 阶乘阶乘我们都很熟悉，也都知道该怎么去计算阶乘，公式很简单： N!=1×2×3×...×(N-1)×N如果我们想计算1000！的阶乘呢？对于程序员来说，总是想到用代码去实习，代码大致这样： int factorial(int n){ for (i = 1; i &lt;= n; i++) { j *= i; } return j;} 但是对于1000！这样一个很大数，最终得到的结果是很大的，对于这样的代码的话，int绝对已经满足不了了，哪怕是long,long long int,但是暂且不考虑数据类型的容量。计算机在计算的时候，过程中会进行大量的运算，消耗了大量的性能，但我们最终只是需要一个结果值，而过程中的数据就变得不那么重要了，那么有没有简单的计算方式呢？当然有！又是一个神奇的公式： N!\\approx \\sqrt{2\\pi N} ( \\frac N e)^N代码变成： ans=(int)(log10((2*PI*n))/2+n*log10((n/e))+1); 这样的代码相对而言计算的性能会小很多，虽然公式只是取到一个近似值，误差值在N越大的时候误差越小，在N=1000的时候与真实数据的误差已经小于0.01%了，这对于进行大数据很有帮助。 对于0的阶乘等于1的疑问书中关于0的阶乘的证明有个疑问，通过公式: N!=N*(N-1)!N为自然数大于等于0 因为1！=1，根据公式有: 1!=1*0!推出0！=1，这样看似乎没有问题 然而将N=0再带入公式: 0!= 0*(-1)!左边等于1，右边由于0乘以任何数都为0的情况下那么右边为0,左右则矛盾冲突了，那么利用N!=N*(N-1)!来推导0！就有一定的局限性。 非传递性骰子对于上面的内容的话，都是一些比较纯数学公式的，但这一节的内容好像与我们的生活有那么一些关系的，说实话这一节真的有点出人意料的，让我有一种怀疑人生的感觉。现在有三颗骰子A B C，每颗骰子上面的数字并不是 1 2 3 4 5 6，而是一些特定的数字比如我们定义这样三个骰子，有六面，每一面有不同的数字，三个骰子的数字都不一样，如下图 骰子 一 二 三 四 五 六 A 2 3 4 12 16 17 B 5 6 7 8 9 18 C 1 10 12 13 14 15 如果让你选这三个骰子中的一个去参与“赌博”，你会选哪一个呢？对于A骰子和B骰子，通过列表格我们可以知道： 2 3 4 12 16 17 5 B B B A A A 6 B B B A A A 7 B B B A A A 8 B B B A A A 9 B B B A A A 18 B B B B B B 可以知道A获胜的概率也就是 15/36 约等于 42%，B赢的概率会是：58%。 那么你肯定会选择B，因为它赢的概率会大一点。我们用相同的手段处理骰子B和C得到的的数据：B赢的概率是 11/36 约等于 31%，C赢的概率是25/36约等于 百分之69。那么你肯定会选择骰子C。 好像在这样的三个骰子里面，A“最差”，C“最好”，然而对于A和C，C赢的概率真的会高一些么？！如果你继续通过上面列表格的方式你会发现，A和C比较的话，A赢的概率是 21/36约等于 58%，C赢的概率是15/36约等于42%。 相信你如果不是有对概率论有学习过的话，一上来肯定是不相信的，然而事实就是这样的。这是因为A与B、B与C、A与C相互之间的比较产生的基本事件空间是不一样的，比如A和B比较是(2,5)(2,6)等36个基本事件，A和C又是另外36个基本事件，所以这个概率大小也不具有传递性。 最后对于这本书，我本以为会介绍这个的方程： r =a( 1 - sin θ)因为这个方程有一个美丽的图形，而方程背后又有一个美丽的故事，感觉内容太适合这本书了，不知道为什么没有加入进去。 总之这本书大部分内容都是初等数学相关的知识，看起来并不是特别的费劲，但是很多平常有经常用过的数或者公式都有其深深的内涵所在，当你对其中的原理证明进行了相关的了解之后，你会发出感叹，原来数学是如此的有趣美丽。","categories":[{"name":"读书电影","slug":"movie","permalink":"http://vompom.github.com/categories/movie/"}],"tags":[{"name":"数学","slug":"数学","permalink":"http://vompom.github.com/tags/%E6%95%B0%E5%AD%A6/"}],"author":"落叶挽歌"},{"title":"基于AndroidVideoCache的预加载","slug":"基于AndroidVideoCache的预加载","date":"2020-07-06T11:09:00.000Z","updated":"2025-09-15T13:07:12.918Z","comments":true,"path":"2020/07/06/基于AndroidVideoCache的预加载/","permalink":"http://vompom.github.com/2020/07/06/%E5%9F%BA%E4%BA%8EAndroidVideoCache%E7%9A%84%E9%A2%84%E5%8A%A0%E8%BD%BD/","excerpt":"","text":"最近有做需求关于视频缓存，了解到相关的开源库AndroidVideoCache，\b一款市面上相对比较流行的视频缓存框架，而我想利用该框架进行视频缓存的处理，并且希望能够支持预加载。然而该框架作者在18年就已经停止了维护，所以留下了无限的编程空间给其他程序员，对于视频预加载，只搜到一篇《AndroidVideoCache源码详解以及改造系列-源码篇》，然而点进该作者的博客列表，说好的预加载呢？？？后面也没有了下文，搜遍全网好像没有做AndroidVideoCache的预加载相关的事情，那么这样子的话……自己干吧。 首先需要明白AndroidVideoCache的实现原理，推荐查看《AndroidVideoCache-视频边播放边缓存的代理策略》这里不再赘述。 其实预加载的思路很简单，在进行一个播放视频后，再返回接下来需要预加载的视频url，启用后台线程去请求下载数据，不过中间涉及的细节逻辑比较多。 一、实现方案主要逻辑为： 1、后台开启一个线程去请求并预加载一部分的数据 2、可能需要预加载的数据大于&gt;1，利用队列先进入的先进行加载，加上前面的条件 使用HandlerThread再适合不过了。 我们首先定义好需要去处理的任务情况： private void preload( String method，Call call) &#123; switch (method) &#123; case &quot;addPreloadURL&quot;: addPreloadURL(call); //添加url到预加载队列 break; case &quot;cancelPreloadURLIfNeeded&quot;: cancelPreloadURLIfNeeded(call); //取消对应的url预加载（因为可能是立马需要播放这个视频，那么就不需要预加载了） break; case &quot;cancelAnyPreloads&quot;: cancelAnyPreLoads();//取消所有的预加载，主要是方便管理任务 break; default: &#125; &#125; 那么对于每次的预加载逻辑基本上是这样的方法执行顺序： cancelPreloadURLIfNeeded()-&gt;addPreloadURL(); //取消对应url加载的任务，因为有可能该url不需要再进行预加载了（参考抖音，当用户瞬间下滑几个视频，那么很多视频就需要跳过了不需要再进行预加载） cancelAnyPreLoads()-&gt;addPreloadURL(); //取消对应url加载的任务（这时候需要立马播放最新的视频，那么就应该让出网速给该视频），之后再添加新一轮的预加载url。 接下来具体的处理逻辑VideoPreLoader类，我直接放上所有的代码逻辑吧,为方便观察删除了一部分不太重要的逻辑，其实总体流程也比较简单。 public class VideoPreLoader &#123; private Handler handler; private HandlerThread handlerThread; private List&lt;String&gt; cancelList = new ArrayList&lt;&gt;(); private VideoPreLoader() &#123; handlerThread = new HandlerThread(&quot;VideoPreLoaderThread&quot;); handlerThread.start(); handler = new Handler(handlerThread.getLooper()) &#123; @Override public void handleMessage(Message msg) &#123; super.handleMessage(msg); &#125; &#125;; &#125; void addPreloadURL(final VideoPreLoadModel data) &#123; handler.post(new Runnable() &#123; @Override public void run() &#123; realPreload(data); &#125; &#125;); &#125; void cancelPreloadURLIfNeeded(String url) &#123; cancelList.add(url); &#125; void cancelAnyPreLoads() &#123; handler.removeCallbacksAndMessages(null); cancelList.clear(); &#125; private void realPreload(VideoPreLoadModel data) &#123; if (data == null || isCancel(data.originalUrl)) &#123; return; &#125; HttpURLConnection conn = null; try &#123; URL myURL = new URL(data.proxyUrl); conn = (HttpURLConnection) myURL.openConnection(); conn.connect(); InputStream is = conn.getInputStream(); byte[] buf = new byte[1024]; int downLoadedSize = 0; do &#123; int numRead = is.read(buf); downLoadedSize += numRead; if (downLoadedSize &gt;= data.preLoadBytes || numRead == -1) &#123; //Reached preload range or end of Input stream. break; &#125; &#125; while (true); is.close(); &#125; .... &#125; private boolean isCancel(String url) &#123; if (TextUtils.isEmpty(url)) &#123; return true; &#125; for (String cancelUrl : cancelList) &#123; if (cancelUrl.equals(url)) &#123; return true; &#125; &#125; return false; &#125;&#125; 对于这段代码中其实有“两个”队列，一个是HandlerThread中的队列，熟悉消息机制的同学应该都能明白，内部是一个looper在不断地循环获取消息，当一个消息处理完毕之后才会处理下一个消息。我还定义了一个就是取消队列，因为HandlerThread中的任务我们不太好控制取消具体的任务，所以设置了一个取消队列，当之后的消息再需要执行的时候会首先判断是否是在取消队列里面，这样子就能做到对预加载队列逻辑的控制。 二、关于一些细节问题这样子我们在播放一个视频的时候，只需要传给我们接下来将会播放的视频的URL，我们就能对其预加载并缓存下来，但是会存在其他条件： 预加载的长度？对于视频加载长度，我们很容易想到在视频url请求加入Range在header上面，比如 conn.addRequestProperty(&quot;Range&quot;, &quot;0-102400&quot;); 我们只获取前102400 bytes，不用将整个视频全部进行预加载，我有进行这样的尝试，但是实际发现是有坑的。我做了很多尝试，发现不论怎么请求，拿到的 responseCode 虽然是206，但是 还是把数据给全部下载完了，这就有点不科学了！！ 最终去源码中才发现：源码有对range做正则匹配 private static final Pattern RANGE_HEADER_PATTERN = Pattern.compile(&quot;[R,r]ange:[ ]?bytes=(\\\\d*)-&quot;);private long findRangeOffset(String request) &#123; Matcher matcher = RANGE_HEADER_PATTERN.matcher(request); if (matcher.find()) &#123; String rangeValue = matcher.group(1); return Long.parseLong(rangeValue); &#125; return -1;&#125; 看清楚了 “[R,r]ange:[ ]?bytes=(\\\\d)-“* 它只去匹配了前面的的，也就是说 我传入了 0-102400 它最终只当作是：Range：0- 来处理，导致addRequestProperty设置的range实现。坑！不过能理解作者为什么这么做，后面总结会讲到。没有办法只有使用最原始的方法进行判断了：在每次获取inputStream的时候进行判断是否达到预加载的大小，虽然有一定的性能开销，但是不去改源码的话也没有 办法了。 do &#123; int numRead = is.read(buf); downLoadedSize += numRead; if (downLoadedSize &gt;= data.preLoadBytes || numRead == -1) &#123; //Reached preload range or end of Input stream. break; &#125; &#125; while (true); is.close(); 三、总结本文主要讲了基于AndroidVideoCache的预加载具体实现原理，以及其中遇到的坑 1、预加载主要通过HandlerThread去实现后台网络的访问以及缓存的处理逻辑 2、加入取消队列去控制对应需要取消的任务 3、对于预加载的size只能通过读取的时候进行判断，没有办法使用range去判断。其实很容易理解作者为什么正则要这样写，因为它只是一个视频缓存框架，主要是用来做“边播边存”，所以每次去进行请求的时候应该都是在原有的缓存之上去进行缓存数据处理，而缓存最终需要处理完的就是 content-size，不需要再去管Range中的结束范围了。","categories":[{"name":"技术文章","slug":"technology","permalink":"http://vompom.github.com/categories/technology/"}],"tags":[{"name":"音视频","slug":"音视频","permalink":"http://vompom.github.com/tags/%E9%9F%B3%E8%A7%86%E9%A2%91/"}],"author":"落叶挽歌"},{"title":"《82年生的金智英》","slug":"《82年生的金智英》","date":"2020-06-26T10:49:00.000Z","updated":"2025-05-20T11:46:57.000Z","comments":true,"path":"2020/06/26/《82年生的金智英》/","permalink":"http://vompom.github.com/2020/06/26/%E3%80%8A82%E5%B9%B4%E7%94%9F%E7%9A%84%E9%87%91%E6%99%BA%E8%8B%B1%E3%80%8B/","excerpt":"","text":"今天一口气把《82年生的金智英》书和电影都看完了，电影的节奏是很压抑的，又是韩国一种“生病”的故事套路，因为有看过书，所以整部电影是带着期待感下去的，想去看看电影的结局到底是怎么样，和书中的结局有什么区别（书中其实没有结局，只是平淡地讲整个故事给叙述了一遍）。当第一次看到这书名的时候，以为这是一本以“金智英”为主体的个人成长奋斗故事。然而并没有那么简单……与其这是一部关于“金智英”的小说，倒不如说是一部关于韩国现实女性的纪录片。 整本书按照时间顺序讲述金智英从一九八二年出生开始到二〇一五，故事按时分为几个章节：小学初中、高中大学、职场、婚后。在人生故事的每一个阶段，都充斥着对女性的不公，每个阶段讲述的故事大抵也是很普通的故事，没有十恶不赦的大恶人，让她受到伤害的是整个社会文化风气，这才是最揪心的。书以二〇一六最新的“治疗”结果结尾，也并没有说明‘病“好了，并叙述了作者自己周围女性的境遇，你我身边都有很多“金智英”。 为什么主角叫“金智英”？因为在一九八二年出生的女性中，“金智英”是一个很常见的名字，在韩国“金智英”是一个很常见的名字，她代表了一众女性群体。然而书中的金智英在韩国，过得并不是最辛苦的，她有受到过良好的高等教育，她还有支持她的妈妈、赏识她的上司、关心她的老公、理解她的朋友，但她依然在社会中因为是“女性”，而艰难地挣扎着。 看完整部书和电影，我一直有一种对生活在韩国的女性的遭遇的同情，也为生活在中国的女性而感到幸运。然而细想，真的是这样子么？也许自己不是女性，所以对很多都不太了解，但是自己也能感受到一些。举一个例子，曾在脉脉动态上有看到这样的简历介绍:结婚了，孩子两岁了，不打算要二胎。 简历介绍其实也透露出社会的现状，具体就不再细谈，懂的人自然懂。我们应该感激自己周围的女性，她们真的很不容易，也许是一些固化的思维，我们感受不到其中的细节罢了。 但可悲的是，这本书被贴上了女性主义的标签，甚至女q主义者拿这本书当做“资本”，借用书中最后的译后记中 艾玛·沃特森在国际妇女节中说的话，她重申自己的核心理念：“争取的是不是女权，而是两性的自由”。本书希望的是能够让更多的那行对于女性的处境有所了解，相互体谅，帮助彼此。希望世界变得更加美好，女生不再成为某些事件的筛选条件；而这需要女人的自觉与男人的换位思考。","categories":[{"name":"读书电影","slug":"movie","permalink":"http://vompom.github.com/categories/movie/"}],"tags":[{"name":"读书","slug":"读书","permalink":"http://vompom.github.com/tags/%E8%AF%BB%E4%B9%A6/"}],"author":"落叶挽歌"},{"title":"WeakHashMap与Java引用相关","slug":"WeakHashMap与Java引用相关","date":"2020-06-22T03:19:00.000Z","updated":"2025-05-20T11:46:57.000Z","comments":true,"path":"2020/06/22/WeakHashMap与Java引用相关/","permalink":"http://vompom.github.com/2020/06/22/WeakHashMap%E4%B8%8EJava%E5%BC%95%E7%94%A8%E7%9B%B8%E5%85%B3/","excerpt":"","text":"记得在很久之前有写过一篇《Java中的Reference解析》，主要讲的是Java中的四种引用方式与引用队列，不过这些都是基础的理论知识，最近开发项目中有使用到WeakHashMap，对于Java的引用以及引用队列有了更深的了解，在此做个相关总结。 一、WeakHashMap的实现方式总体来说，WeakHashMap的底层数据结构与HashMap的实现差不多，都是用“拉链法”来实现，主要区别在于WeakHashMap的Entry 继承于WeakReference，并维护一个ReferenceQueue，使其具有了“弱引用的特性”，其构造方法可以看出： Entry(Object key, V value,ReferenceQueue&lt;Object&gt; queue,int hash, Entry&lt;K,V&gt; next) &#123; super(key, queue); //这里比较关键 …… &#125; 其中的super父类的代码实现为： public WeakReference(T referent, ReferenceQueue&lt;? super T&gt; q) &#123; super(referent, q); &#125; 通过对父类的构造方法可以知道，WeakMap的key值为弱引用类型，回顾一下弱引用的特点：垃圾收集器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。 于是WeakHashMap的作用就凸显出来了：对于数据中Key-value，key因为使用的弱引用会被回收，而value也会得到对应的释放。以我这次的需求为例：key为Webview页面或者Flutter/RN页面，value为调用native方法相关存储的对象。当页面需要关闭调webivew的时候，Webview应该要被释放，要不然会产生内存泄漏，当其被释放之后，对应的value也没有意义了，所以也需要被释放掉。 那么WeakHashMap是如何让value释放的呢？ 二、WeakHashMap如何释放无用的Value要回收无用的Value，那么引用队列（ReferenceQueue）就派上用场了，回顾一下引用队列的作用：当一个引用（软引用、弱引用）关联到了一个引用队列后，当这个引用所引用的对象要被垃圾回收时，就会将它加入到所关联的引用队列中。所以判断一个引用对象是否已经被回收的一个现象就是，这个对象的引用是否被加入到了它所关联的引用队列。那么对于WeakHashMap也是利用这一点特性，在其代码中put\\get等方法都有执行对应等检查 public V put(K key, V value) &#123; Object k = maskNull(key); int h = hash(k); Entry&lt;K,V&gt;[] tab = getTable(); //具体实现在getTable执行的expungeStaleEntries里面 …… public V get(Object key) &#123; Object k = maskNull(key); int h = hash(k); Entry&lt;K,V&gt;[] tab = getTable(); …… /** * Expunges stale entries from the table. */private void expungeStaleEntries() &#123; for (Object x; (x = queue.poll()) != null; ) &#123; //这里的queue就是引用队列 synchronized (queue) &#123; @SuppressWarnings(&quot;unchecked&quot;) Entry&lt;K,V&gt; e = (Entry&lt;K,V&gt;) x; int i = indexFor(e.hash, table.length); Entry&lt;K,V&gt; prev = table[i]; Entry&lt;K,V&gt; p = prev; while (p != null) &#123; Entry&lt;K,V&gt; next = p.next; if (p == e) &#123; if (prev == e) table[i] = next; else prev.next = next; // Must not null out e.next; // stale entries may be in use by a HashIterator e.value = null; // Help GC size--; break; &#125; prev = p; p = next; &#125; &#125; &#125;&#125; 从上面的代码逻辑可以很清楚的知道：WeakHashMap通过对引用队列的数据进行检查，对key被回收对象的对应Value进行了回收。 三、总结1、WeakHashMap的Entry 继承于WeakReference，并维护一个ReferenceQueue2、在执行get\\put等相关数据操作的时候 会对数据进行相关处理，主要是清除掉无用对象对","categories":[{"name":"技术文章","slug":"technology","permalink":"http://vompom.github.com/categories/technology/"}],"tags":[{"name":"Java","slug":"java","permalink":"http://vompom.github.com/tags/java/"}],"author":"落叶挽歌"},{"title":"关于朋友","slug":"关于朋友","date":"2020-06-15T08:11:00.000Z","updated":"2025-05-20T11:46:57.000Z","comments":true,"path":"2020/06/15/关于朋友/","permalink":"http://vompom.github.com/2020/06/15/%E5%85%B3%E4%BA%8E%E6%9C%8B%E5%8F%8B/","excerpt":"","text":"2020年6月15日，我最好的初高中朋友ZR（女）和XBC（男）在今天拿到了结婚证了，结束了快十年的爱情长跑。我和他们都是在初中的时候认识的，后来在一个高中，大学便分别了。虽然每年只会在过年的时候才会见面，但是那种友情却不因时间和距离而减。对于他们拿到结婚证，今天也是突然有感于其中。 我与XBC是初中是最好的朋友了，那时候我们正值青春懵懂时期，我与他干了不少“坏事”，上课调皮捣蛋，晚上就寝与老师斗智斗勇。班主任罚检讨、被挨打、被体罚不知道有多少次，那时候正值青春叛逆时期，懵懂无知，做了很多有趣的事情，现在回想起来都是一串串难忘的记忆。 还记得初中时候跟他聊的特别多，上课也是聊天，我们总会产生各种鬼主意。我们聊着那时候玩过的游戏DOTA、重装机兵，我们都追着Justin Bieber、Taylor Swift并哼唱着他们的歌，以及追着当时正火的《火影忍者》与《死神》。 感谢有你，让我初中的三年是过得如此的充实。 我与ZR直到初三的时候才因为座位离得近，才有更好的认识，渐渐地也了解多了，我发现和她是能比较聊得来的人。直到高中后，我才发现我有这样一个异性朋友是多么的值得。高中时，每一次的情感挫折都向她倾述，我现在已经有点模糊记忆了，高中时不知道跟她讲了多少我的故事给她。 我清晰地记得高二时，我的爷爷在凌晨两点去世，那时候我感觉全世界都塌了，我发了几条短信给她，我想告诉她我当时真的很难受，后来在她的安慰下，我慢慢地走了出来。她成了我倾述的对象，不开心的时候，跟她聊聊，总会好起来。每年的生日，她总是会记得，也会送我礼物，当然也记得她的生日，我记得曾经做过几个视频给她，是她十七岁的时候，收集她的照片，最终做成了一个MV，现在再回头看看当时的视频，也是蛮有回忆感的。我家里仍然还保留着我十七八岁时她送我的礼物，以及信件。 感谢有你，让我高中的三年是过得如此的充实。 ZR与XBC是我十年的老朋友了，十年的朋友，实在是太难得了，我不知道这是一种如何的缘分，你们是我最好的朋友，也是我现在在外漂泊，愿哪天能回到故乡时的动力。你们作为我朋友中的情侣模范，实在是竖立了榜样给我们，让我再一次感受到爱情的存在。感谢有你们，让我生活充满生机。 此时我打开网易云播放一首张宇的《给你们》，在遥远的上海默默地祝福你们，很喜欢一首民国时期的结婚证书上的誓词送给你们： 喜今日两姓联姻，一堂缔约，良缘永结，匹配同称。 看此日桃花灼灼，宜室宜家，卜他年瓜瓞绵绵，尔昌尔炽。谨以白头之约，书向鸿笺，好将红叶之盟，载明鸳谱。","categories":[{"name":"生活感想","slug":"life","permalink":"http://vompom.github.com/categories/life/"}],"tags":[{"name":"省","slug":"thinking","permalink":"http://vompom.github.com/tags/thinking/"}],"author":"落叶挽歌"},{"title":"《费马大定理》","slug":"《费马大定理》","date":"2020-06-09T14:32:00.000Z","updated":"2025-05-20T11:46:57.000Z","comments":true,"path":"2020/06/09/《费马大定理》/","permalink":"http://vompom.github.com/2020/06/09/%E3%80%8A%E8%B4%B9%E9%A9%AC%E5%A4%A7%E5%AE%9A%E7%90%86%E3%80%8B/","excerpt":"","text":"大约在1637年左右，法国学者费马在阅读丢番图《算术》拉丁文译本时，曾在第11卷第8命题旁写道： 将一个立方数分成两个立方数之和，或一个四次幂分成两个四次幂之和，或者一般地将一个高于二次的幂分成两个同次幂之和，这是不可能的。关于此，我确信已发现了一种美妙的证法，可惜这里空白的地方太小，写不下。 其中的条件用数学表达语言则： 当整数n >2时，关于x, y, z的方程 x^n + y^n = z^n 没有正整数解。这个数学理论简单明了，初中生都能看懂的理论，但是没有被得到最终的证明，费马自己提出来，没有得到完全的证明，他只证明了n=4的情况，后来欧拉沿着费马“无穷递降法”的思路，再向前迈出小小的一步，将n=4延伸到n=3的情形。但是大于4的情况呢？ 费马的一段话，让数学界开始了长达300年的数学接力，有高斯、欧拉等诸多著名数学家都有尝试去彻底解决这个问题，但都无果。甚至后来开始推断出这是一个不能被证明的理论，在证明路上数学家们一直因证明失败而被打击，但这并不不能阻碍数学家们对这个问题的证明。最终，358年后，由英国数学家安德鲁.怀尔斯在1994成功完成了证明。看似轻描淡写，但有多少数学家在他证明的路上铺上了砖石呢？从费马提出到欧拉解决了n=3的情况，中途诸多数学家的猜想与推论，最后谷山与志村提出的“谷山-志村猜想”，只要能证明“谷山-志村猜想”就能自动证明费马大定理。就这样，一个大问题被一点点地解决了，但时间长达300多年。 《费马大定理》是是一部数学史，整本书以时间为基线，讲从费马提出这个问题开始，到最终怀尔斯完全证明费马大定理的过程。自己虽然对于数学没有很深入的了解，但是整本书看下来也是十分的吸引人，像我们熟知的毕达哥拉斯定理（勾股定理）与费马大定理联系起来（n=2的情况是有正数解的），$\\sqrt{2}$ 是无理数的欧几里得证明等，就算对数学不太了解的人，也会为其中的证明技巧所感叹。 当然本书中所有的数学家的故事都是一个振奋人心的角色，为证明费马大定理前赴后继，铸就了数学史诗，关于他们奋斗的故事，可以去仔细了解。除此之外，这本书给人最大的感触就是：站在巨人的肩膀上。 如果说怀尔斯证明出来费马大定理是他一个人的功劳，那肯定很多人不会服了。如果说怀尔斯是站在了巨人的肩膀上，那么前面那么多的数学家共同组成了这个巨人。对于怀尔斯之前的谷山与志村则站在了“模形式”巨人上。对于怀尔斯证明完成之后，要直接使用费马大定理，那么怀尔斯又与前面那么多的数学家一起组成了更大的巨人。之后的数学学科利用费马大定理做一些更深入的研究后，那么这个巨人便变得更大了。 为了证明费马大定理，产生了许多数学成果，拓宽了数学的领域，促进了数学的发展，数学家们将数学这个巨人变得越来越大。现代学科研究，利用数学，将物理学科的巨人变大，将计算机学科巨人变大……最终使整个科技巨人变大。而我们只需要站在巨人的肩膀上，只需要鼠标一点，这些巨人便开始奔跑。虽然说积跬步虽也能成千里，但远不如坐上高铁走四方，这便是站在巨人的肩膀上，而巨人是一代代人前赴后继的结果。 最后补充一个：为什么费马大定理在数学史上的地位如此重要？有人答道 丢番图、毕达哥拉斯、费马、热尔曼、柯西、欧拉、希尔伯特、哥德尔、图灵、伽罗瓦、谷山丰、志村五郎、沃尔夫斯凯尔、怀尔斯……这些数学史上最伟大的名字，在整个「费马定理大戏」上轮番登场。他们有的奠定了数论基础、有的为提出费马定理铺平道路，有的提出问题却不给解答，有的人尝试了却失败，有的人只能证明部分结论，有的人没有想过证明这个定理却因为自己另一个数学理论创新而成为整个解答的关键，而这个解答却一度被学界不能理解而弃如敝履，有的人在攀登数学高峰的途中逝世，也有的人在面对人生失意决心自尽却因死前无聊看到了这个费马定理而心生兴趣尝试解答最后放弃自杀，设立巨额奖金奖励解答者！ 这是一部数学史诗，也是人类智慧最伟大的故事之一。","categories":[{"name":"读书电影","slug":"movie","permalink":"http://vompom.github.com/categories/movie/"}],"tags":[{"name":"数学","slug":"数学","permalink":"http://vompom.github.com/tags/%E6%95%B0%E5%AD%A6/"}],"author":"落叶挽歌"},{"title":"Http缓存机制","slug":"Http缓存机制","date":"2020-04-20T03:45:00.000Z","updated":"2025-05-20T11:46:57.000Z","comments":true,"path":"2020/04/20/Http缓存机制/","permalink":"http://vompom.github.com/2020/04/20/Http%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/","excerpt":"","text":"最近有接触到Http缓存机制的问题，自己进行一个总结。 浏览器加载一个页面的缓存流程如下：1. 浏览器先根据Http Header信息来判断是否命中强缓存。如果命中则直接加载本地缓存中的资源，并不会将请求发送到服务器。 如果未命中强缓存，则浏览器会将资源加载请求发送到服务器。服务器来判断浏览器本地缓存是否失效。若可以使用，则服务器并不会返回资源信息，浏览器继续从缓存加载资源，虽然与强缓存加载的是“同一份缓存”，但是由于流程与性质不一样，我们把它叫做协商缓存。 如果未命中协商缓存，则服务器会将完整的资源返回给浏览器，浏览器加载新资源，并更新缓存。 强缓存：不会向服务器发送请求,直接从本地缓存中读取资源返回200的状态码。 from memory cache一般脚本、字体、图片会存在内存当中 from disk cache一般非脚本会存在磁盘当中，如css等 协商缓存：向服务器发送请求,服务器根据请求中的Header的字段判断是否命中协商缓存,如果命中,则返回304状态码并带上新的响应头通知浏览器从缓存中读取资源 与之相关的字段为：强缓存：cache-control、expires协商缓存：Last-Modified/if-Modified-Since、Etag/if-None-Match. 其实整个缓存机制也就是围绕着这几个字段所展开 二、强缓存流程强缓存是由Http的Response Header中的Expires或者Cache-Control两个字段来控制的，用来表示资源的缓存时间。如果Cache-control与expires同时存在的话，Cache-control的优先级高于expires。 Expires是一个http1.0提出的概念，它描述的是一个绝对时间，由服务端返回 expires: Mon, 11 Jun 2029 08:34:12 GMT Cache-ControlCatche-control是http1.1提出的概念，优先级高于expires，描述的是一个相对时间cache-control: max-age=315360000 除了max-age外，cache-control还有其他几个参数：-no-cache：不使用本地缓存。需要使用缓存协商，先与服务器确认返回的响应是否被更改，如果之前的响应中存在ETag，那么请求的时候会与服务端验证，如果资源未被更改，则可以避免重新下载。-no-store：直接禁止浏览器缓存数据，每次用户请求该资源，都会向服务器发送一个请求，每次都会下载完整的资源。-public：可以被所有的用户缓存，包括终端用户和CDN等中间代理服务器。-private：只能被终端用户的浏览器缓存，不允许CDN等中继缓存服务器对其缓存。 如过Cache-Control和Expires条件都不满足，也就是说：像cache-control的字段为-no-cache和-no-store以及max-age不满足条件或者当前时间大于Expires的时间的时候，那么强缓存是没有被命中的，接下来要继续进行协商缓存的流程。 三、协商缓存流程协商缓存相对于强缓存流程就复杂一点了，主要通过：Last-Modified/If-Modified-Since和ETag/If-None-Match来控制。Etag是服务器自动生成或者由开发者生成的对应资源在服务器端的唯一标识符，能够更加准确的控制缓存。Last-Modified与ETag是可以一起使用的，服务器会优先验证ETag，一致的情况下，才会继续比对Last-Modified，最后才决定是否返回304。 Last-Modified/If-Modified-SinceLast-Modified 表示本地文件最后修改日期，浏览器会在Request Header加上If-Modified-Since（上次返回的Last-Modified的值），询问服务器在该日期后资源是否有更新，有更新的话就会将新的资源发送回来。 但是单纯使用Last-Modified 会有以下问题： Last-Modified标注的最后修改只能精确到秒级，如果某些文件在1秒钟以内，被修改多次的话，它将不能准确标注文件的修改时间 如果某些文件会被定期生成，当有时内容并没有任何变化，但Last-Modified却改变了，导致文件没法使用缓存 有可能存在服务器没有准确获取文件修改时间，或者与代理服务器时间不一致等情形 所以在HTTP/1.1的时候加入了ETag/If-None-Match来解决这些问题，因而ETag的优先级高于Last-Modified。 ETag/If-None-MatchETag可以保证每一个资源是唯一的，资源变化都会导致ETag变化。ETag值的变更则说明资源状态已经被修改。服务器根据浏览器上发送的If-None-Match值来判断是否命中缓存。 If-None-Match的header会将上次返回的Etag发送给服务器，询问该资源的Etag是否有更新，有变动就会发送新的资源回来. Etag是服务器自动生成或者由开发者生成的对应资源在服务器端的唯一标识符，能够更加准确的控制缓存。Last-Modified与ETag是可以一起使用的，服务器会优先验证ETag，一致的情况下，才会继续比对Last-Modified，最后才决定是否返回304。 四、总结一、由于HTTP一直在发展，所以对于HTTP的缓存字段也变得越来越复杂，其实我们很清晰的可以知道Expires与Last-Modified/If-Modified-Since是Http/1.0时代的产物。 Cache-Control与ETag/If-None-Match是HTTP/1.1为解决HTTP/1.0新增出来的字段，这样对比去记忆理解起来，其实缓存机制也就变得很好理解了。 二、对于第一次请求（肯定是没有任何缓存的），那么直接向服务器请求资源并将下载好的资源进行缓存，为下一次请求做缓存准备。 三、对于第二次之后的请求，那么本地是有缓存的，那么先通过cache-control的规则判断（对于Http1.0还是Expires）来判断本地缓存是否过期，如果没过期，那么直接使用。如果过期了，就再判断Etag（具体流程可以参考：Etag与HTTP缓存机制），通过发送If-None-Match（也就是上次存入的Tag的值），服务器进行一个决策判断返回200还是304。之前有说到，Last-Modified与ETag是可以一起使用的，服务器会优先验证ETag，也就是Etag不存在或者其他情况那么会使用Last-Modified来进行判断，通过向服务器发送If-Modified-Since，然后服务器进行一次决策。 看流程图可能一下子就明白了： 参考： https://www.cnblogs.com/ranyonsue/p/8918908.htmlhttps://www.jianshu.com/p/19c2e397e22a","categories":[{"name":"技术文章","slug":"technology","permalink":"http://vompom.github.com/categories/technology/"}],"tags":[{"name":"Http","slug":"Http","permalink":"http://vompom.github.com/tags/Http/"}],"author":"落叶挽歌"},{"title":"诗歌-《再见》","slug":"诗歌-《再见》","date":"2020-03-29T11:43:00.000Z","updated":"2025-05-20T11:46:57.000Z","comments":true,"path":"2020/03/29/诗歌-《再见》/","permalink":"http://vompom.github.com/2020/03/29/%E8%AF%97%E6%AD%8C-%E3%80%8A%E5%86%8D%E8%A7%81%E3%80%8B/","excerpt":"","text":"再见是离时的伤感静静地来了悄悄地离开伤感的是那来时的晴天白云离时的栉风沐雨 再见是离时的不舍多少日夜兼程多少风雨无阻不舍的是那专研执著的精神是那昔时的人儿 再见是对君的怀念念与君时的如沐春风怀与君时的意气风发看烛烬月半沉听蛩噪院已深心悦君兮君可知？ 再见只是为了下次更好的见 あなたに会えて嬉しい私の名前はジュルリス NICE TO MEET U.I AM JU1IS.","categories":[{"name":"生活感想","slug":"life","permalink":"http://vompom.github.com/categories/life/"}],"tags":[{"name":"诗歌","slug":"诗歌","permalink":"http://vompom.github.com/tags/%E8%AF%97%E6%AD%8C/"}],"author":"落叶挽歌"},{"title":"哈夫曼树与编码","slug":"数据结构-哈夫曼Huffman树","date":"2020-03-24T01:38:00.000Z","updated":"2025-05-20T11:46:57.000Z","comments":true,"path":"2020/03/24/数据结构-哈夫曼Huffman树/","permalink":"http://vompom.github.com/2020/03/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%93%88%E5%A4%AB%E6%9B%BCHuffman%E6%A0%91/","excerpt":"","text":"哈夫曼树定义： 给定N个权值作为N个叶子结点，构造一棵二叉树，若该树的带权路径长度达到最小，称这样的二叉树为最优二叉树，也称为哈夫曼树(HuffmanTree)。哈夫曼树是带权路径长度最短的树，权值较大的结点离根较近。 例：在数据通信中，需要将传送的文字转换成二进制的字符串，用0，1码的不同排列来表示字符。例如，需传送的报文为“AFTER DATA EAR ARE ART AREA”，这里用到的字符集为“A，E，R，T，F，D”，各字母出现的次数为{8，4，5，3，1，1}。现要求为这些字母设计编码。要区别6个字母，最简单的二进制编码方式是等长编码，固定采用3位二进制，可分别用000、001、010、011、100、101对“A，E，R，T，F，D”进行编码发送，当对方接收报文时再按照三位一分进行译码。显然编码的长度取决报文中不同字符的个数。 哈夫曼树创建方法摘自：《详细图解哈夫曼Huffman编码树》 2.1 初始队列 我们按出现频率高低将其放入一个优先级队列中，从左到右依次为频率逐渐增加。 下面我们需要将这个队列转换成哈夫曼二叉树，哈夫曼二叉树是一颗带权重的二叉树，权重是由队列中每个字符出现的次数所决定的。并且哈夫曼二叉树始终保证权重越大的字符出现在越高的地方。 2.2 第一步合并 首先我们从左到右进行合并，依次构建二叉树。第一步取前两个字符u和r来构造初始二叉树，第一个字符作为左节点，第二个元素作为右节点，然后两个元素相加作为新空元素，并且两者权重相加作为新元素的权重。 同理，新元素可以和字符i再合并，如下： 2.3 重新调整队列 上图新元素权重相加后结果是变大了，需要对权重进行重新排序。 然后再依次从左到右合并，每合并一次则进行一次队列重新排序调整。如下： 经过多步操作之后，得到以下的哈夫曼二叉树结构，也就是一个带有权重的二叉树： 2.4 哈夫曼编码 有了上面带权重的二叉树之后，我们就可以进行编码了。我们把二叉树分支中左边的支路编码为0，右边分支表示为1，如下图： 这样依次遍历这颗二叉树就可以获取得到所有字符的编码了。例如：‘ ’的编码为10，‘l’的编码为00，‘u’的编码为11100等等。经过这个编码设置之后我们可以发现，出现频率越高的字符越会在上层，这样它的编码越短；出现频率越低的字符越会在下层，编码越短。经过这样的设计，最终整个文本存储空间才会最大化的缩减。 最终我们可以得到下面这张编码表： 2.5 字符串编码 有了上面的编码表之后，”we will we will r u”这句重新进行编码就可以得到很大的压缩，编码表示为：01 110 10 01 1111 00 00 10 01 110 10 01 1111 00 00 10 11101 10 11100。这样最终我们只需50位内存，比原ASCII码表示节约了2/3空间，效果还是很理想的。当然现实中不是简单这样表示的，还需要考虑很多问题。 三、哈夫曼编码的压缩与解压1、使用IO流逐字节读取文档。用一个数组（0~255,下标表示ASCII码）来保存不同字符出现的次数2、建一个节点类，保存节点对象的信息。将数组每一位表示的字符和出现频次存入创建的节点，把所有节点存入一个链表。3、根据节点存储的频次值，对链表进行从小到大排序4、从链表中取出并删除最小的两个节点，创建一个他们的父节点，父节点不存字符，值为那两个节点的和，把那两个节点分别作为其左子节点和右子节点，最后把这个父节点存入链表。再次排序，取出并删除最小的两个节点，生成父节点，再存入…以此类推，最终生成一棵哈夫曼树。5、对哈夫曼树进行遍历，使得叶子结点获得相应编码，同时把字符和它对应的哈夫曼编码存入HashMap 四、疑问4.1对于字符频率相等的情况我们在构建哈夫曼树的时候在想，如果我们的字符出现的频率相等的情况，那哈夫曼树岂不是很糟？我们假设原来字符串长度为N，那么对于普通的ASCII编码得到的长度为8N，如果利用哈夫曼编码，对于每一个字符，最大的长度不会超过8层树因为ASCII编码总共只有2^8个字符，也就是说最极端的情况：一个文件中所有字符串中出现256个字符且重复次数是一样的，但这仍然对原来的文本有进行过压缩（毕竟出现次数相等的话，构造的哈夫曼树在8层之前还是有数据的，那些数据的位数&lt;8）最终的编码数一定是会&lt;8N 4.2解码冲突问题我们在解压遍历哈夫曼的时候，最终的编码不会冲突么？举例：上面我们得到得最终的编码是01 110 10 01 1111 00 00 10 01 110 10 01 1111 00 00 10 11101 10 11100但是在实际的压缩中我们不会有分隔符最终的情况将会是：0111010 0111110000100111010011111000010111011011100于是我们怎么知道：前面的01是一个编码，为什那么0111就是一个编码呢？也就是说01是0111的前缀 。其实我们从这张图就能看出来：对于上述的字符串一定不会存在一个叫0111的编码，因为“w”字母代表的01已经没有子节点。其实中也可以看出一些区域是空着的比如：11、111、111、1110 没有数据，其实这都是满足了哈夫曼树的 左起字串不冲突原则","categories":[{"name":"算法研究","slug":"算法研究","permalink":"http://vompom.github.com/categories/%E7%AE%97%E6%B3%95%E7%A0%94%E7%A9%B6/"}],"tags":[{"name":"技术文章","slug":"technology","permalink":"http://vompom.github.com/tags/technology/"}],"author":"落叶挽歌"},{"title":"《寄生虫》观后感","slug":"《寄生虫》观后感","date":"2020-03-22T13:22:00.000Z","updated":"2025-05-20T11:46:57.000Z","comments":true,"path":"2020/03/22/《寄生虫》观后感/","permalink":"http://vompom.github.com/2020/03/22/%E3%80%8A%E5%AF%84%E7%94%9F%E8%99%AB%E3%80%8B%E8%A7%82%E5%90%8E%E6%84%9F/","excerpt":"","text":"这个周末总共看了三部电影：《无人生还》《吹哨人》《寄生虫》，前两部看完之后并没有太多的触动，倒是寄生虫看得人实在是过瘾，整个电影的剧情发展，以及想要表达出来镜头语音都做到了极致，以及让人能够思索很久很久的电影余味，配得上所获得的无数奖项。 电影最后以欢乐的party变为残忍的凶案为结局，很多电影中过场看得人是瞠目结舌。极力推荐大家去欣赏一下这部电影，剧作节奏，镜头语言，剧本钩子绝对不会让你失望。 整部电影都围绕着电影名“寄生虫”展开，我们来看一下什么是“寄生虫”。“寄生虫”百科解释道：寄生虫（parasite）指具有致病性的低等真核生物，可作为病原体，也可作为媒介传播疾病。寄生虫特征为在宿主或寄主（host）体内或附着于体外以获取维持其生存、发育或者繁殖所需的营养或者庇护的一切生物。在这一段的解释中: 低等、寄生、生存 是其中的关键词，也是整部电影的关键词。 电影中何为“低等”？或者说是相对而言的低等，电影中的低等则是活在社会底层的一家人-不大的屋子住在一家四口人，靠着折叠披萨盒子生存，上网需要到脏乱差的厕所最里面去蹭别人家的网。而高等则是富豪社长所在的家庭-著名建筑家设计的别墅里的家庭，专门的司机、保姆等。 电影中的“寄生”，有两种情况：一是主角家庭利用一系列的欺骗手段，从而“寄生”在富豪家里，他们一家人虽然也生活在别墅里，吃一样的食物，睡一样的床，但是他们就像是房间里的蟑螂，一旦主人回来了，就立马躲起来，但蟑螂并不是每次都能藏得那么好的，一旦被发现后果不堪设想。二是原本看起来一切正常的“前保姆”与丈夫偷偷居住在别墅地下道四年，在主角家庭一家人到来之前，虽然他丈夫住在很阴暗的地下室里，但是他们过得很知足。 那么生存呢？一切的生物活动都是为了生存和繁衍，这就将上述两个关键词结合在了一起，三者：两者低等寄生，一者高等宿主体。三者的关系则构成了：高等对低等、低等对低等。在影片的高潮部分表现得淋漓尽致：在富有家庭为儿子举办的生日宴上，意外再次发生。后来的低等“寄生”为了斩草除根掉以前的“寄生”，巩固自己一家的“寄生虫”地位，便决心要下到地下室里面斩草除根，但是却因为意外，而将原来的寄生虫家庭的男方放了出来，基宇被自己带的谋杀凶器砸得头破血流，失去理智的男人冲向了草坪，将刀子插进了基婷的胸口，场面再度混乱。而这时候富豪的儿子只是吓晕了过去，而贫穷的父亲的儿子头破血流，女儿已经中刀血流不止，经过一波血拼，都倒下了。富人真正关心的并不是贫穷人子女的生死，只是一味地关注着自己晕倒的儿子，并且表现出对低等的嫌弃，父亲最后一丝自尊心被打破，一刀扎进了富人的身体…… 再回到电影最初看，一家人生活在简简单单地家庭里靠着手工过生活，但是日子过得很开心，一起围坐在桌子旁喝啤酒，他们不用去担心明天，只考虑活在当下。当儿子得到那一份还不错的家教，后来女儿也去家教，都有一部分很不错的收入，有一定的能力开始开始下馆子，渐渐地一家人都想要更“好”的生活，开始依附于富人家里，从而一步步铤而走险，时时提心吊胆，当到最后深陷泥潭的时候，儿子问：我们下一步的计划是什么？父亲答：没有计划的计划是最安全的。或许这时候他们想要过得是安心的生活吧，但已经回不去了，欲望以及使他们沉沦。 引用评论：欲望本身是没有错误的，适度的欲望甚至可以让你变得积极向上，但是过度的欲望则会将你拖进地狱。天堂和地狱之间，大概也就是一念之隔。寄生虫如果能够安守本分过好自己的“寄生”生活，或许影片就会是另外的结局，但因为欲望，寄生虫往往都想要做主人，但殊不知，寄生虫失去了主人，便也离死亡不远了。 明天又是新的一周，加油吧！咱们的生活还是很美好的，敲敲代码、喝喝茶、打打麻将还是挺舒服的哈","categories":[{"name":"读书电影","slug":"movie","permalink":"http://vompom.github.com/categories/movie/"}],"tags":[{"name":"省","slug":"thinking","permalink":"http://vompom.github.com/tags/thinking/"}],"author":"落叶挽歌"},{"title":"（转）Https之HTTPS 的证书","slug":"Https之HTTPS-的证书","date":"2020-03-04T02:44:00.000Z","updated":"2025-05-20T11:46:57.000Z","comments":true,"path":"2020/03/04/Https之HTTPS-的证书/","permalink":"http://vompom.github.com/2020/03/04/Https%E4%B9%8BHTTPS-%E7%9A%84%E8%AF%81%E4%B9%A6/","excerpt":"","text":"转自：https://mp.weixin.qq.com/s/ibwNtDc2zd2tdhMN7iROJw作者：腾讯优图实验室 来源：腾讯技术工程 1、 证书是什么？解释这个问题之前，先看几个关键词：CA，CA 机构，数字证书，数字签名，（证书）指纹，(CA)证书，HTTPS 证书，SSL/TLS 证书。 理一理上面这些关键词之间的关系： CA，CA 机构：机构/组织概念。 数字证书，(CA)证书，HTTPS 证书，SSL/TLS 证书：CA 签发的数字证书。 数字签名，（证书）指纹：CA 签发的证书的内容之一，一段加密的密文。 智库百科对数字证书的解释是： 数字证书也称公开密钥证书，是指用于电子信息活动中电子文件行为主体的验证和证明，并可实现电子文件保密性和完整性的电子数据。数字证书是一个经证书认证中心（CertificationAuthority，简称 CA）发行的文件。 数字证书包含有行为主体信息和证书认证机构的数字签名。数字签名是指以电子形式存在，可依附在电子文件中用于辨识电子文件的签署者及表示对该电子文件内容负责所使用的电子数字标识。 抓重点：数字证书用于主体身份验证。 首先，数字证书=主体信息+数字签名。 Windows 下，我们可以在 Chrome 浏览器上点击地址栏的“锁”标记后会出现下拉框，接着点击“证书”即可看到通过 HTTPS 访问该服务器时的数字证书。具体操作如下： 证书“常规”页面，是关于该证书的一个笼统介绍，包括签发该证书的 CA 机构、该证书绑定的域名（颁发给）、证书有效期。 证书“详细信息”页面，以键值对形式展示了这张证书的完整内容。（后文将详细介绍证书内容） 证书的“证书路径”，以层级结构展示了从该证书绑定的域名一直到根证书的路径，这就是证书链。（后文会展开介绍证书链） 主体的必要信息：版本(version)、序列号(serialNumber)、签名算法(signatureAlgorithm)、颁发者(issuer)、有效期(validity)、使用者(subject)、公钥信息(subjectPublicKeyInfo) 主体的扩展信息(extension)：如密钥标识符、证书策略等 数字签名(signature)，也称指纹 抽象为下图： 2、 为什么是数字证书呢？HTTPS 已经对通信数据进行了加密，为什么还要验证身份？说好的“人与人之间最基本的信任呢？” 这还不是因为各路黑客、骇客们总是在制造各种攻击吗？其中一个大名鼎鼎的中间人攻击（Man-In-The-Middle Attack，MITM 攻击），简单的讲，“中间人”在客户端和服务端都不知情的情况下，夹在双方之间窃听甚至篡改通信信息，过程见下图（图引自《HTTPS 中间人攻击实践（原理·实践）》）： 在 HTTPS 的握手阶段，一端向对端发送请求，对端返回自己的公钥；而一端未验证对方的身份和公钥，直接协商密钥。“中间人”看到了这个漏洞，夹在中间截获了对端的公钥，替换成了自己的公钥。正是这步“拿错了公钥”或者说“信错了对端”，使得 HTTPS 为加密（密钥协商的非对称加密和通信数据的对称加密）所做的努力全部泡汤。 可见，在 HTTPS 中，“确保对端身份正确”即“确保拿到的公钥正确”，而在网络通信中所谓的“身份”，一般指的是通信一端的域名、IP 地址甚至是Mac 地址。所以，数字证书同时包含了通信一端的身份信息和公钥信息。 但是数字证书会在网络中传输（由被要求验证身份的一端通过网络传给另一端），这就意味着证书也可能会被窃取篡改。这个时候权威的 CA 机构就出马了，他想了个办法：加了一个“防伪标识”— 数字签名。具体做法如下： signature = RSA(PriKey_CA, Hash(message)) 这里啰嗦几句：数字签名生成过程是首先对原文作哈希，把一段不定长的文本映射成固定长度的字符空间，接着再用 CA 机构的私钥对这段定长字符做加密。大大提高了整体的运算效率。 3 证书是怎么工作的？要了解证书是怎么做“身份验证”，即“防冒充”，得从 2 个角度来说明： 申请证书，即需要被验证身份的一端，需要申请一份能够验证自己身份的证书验证证书，即需要验证对方身份的一端，拿到证书后验证对端的身份 请注意，这里有一个前提：这张证书必须是由权威 CA 机构颁发的，且尚在有效期内；或者是一张信任的私人证书。 申请证书 CA 机构和证书的分类本文不讨论，推荐阅读《细说 CA 和证书》，这里我们讨论正规权威 CA 机构签发的证书，至于是 DV、OV 还是 EV，只是安全强度问题，工作原理是一样的。 总结申请证书的过程：用户向 CA 机构提交自己的信息（如域名）和公钥（用户自己生成的非对称加密公钥，用于 TLS 握手阶段和另一端协商密钥用），CA 机构生成数字证书，如下图： 验证证书 收到对端发过来的证书，执行证书申请的“逆过程”即可，总结如下图： 接受证书的一端先对除数签名的其他部分做一次相同的哈希算法（证书中指明了哈希算法），得到这段文本的哈希映射，记作 H1；获取 CA 机构的公钥对数字签名属性做解码，得到了 CA 机构计算出的哈希映射，记作 H2。对比 H1 和 H2 两个字符串是否严格相等，若是，代表该证书的信息未被篡改，证书有效；否则，证书内容被篡改，证书无效。 若证书有效，接受端会再进行对端的身份校验（验证域名），若身份验证通过，接收端会拿证书上的公钥（也是对端自己生产的非对称加密公钥）加密接下来整个 TLS 握手阶段的信息之后，发送给对端。 这个过程中有一个问题：CA 机构的公钥怎么获取？ 回答：提前内置。 众所周知，操作系统和浏览器在软件安装阶段会在其特定目录下放置一堆的证书。如 Windows 的根证书管理在 certmgr 下： 这些证书都有个特点：权威 CA 机构发布的根证书（Root Certificate）。根证书有几个特点： 没有上层机构再为其本身作数字签名 证书上的公钥即为 CA 机构发布的公钥 权威 CA 机构的自签证书 而这些根证书会跟很多软件，包括操作系统、浏览器一起被安装到用户设备上。即使没有被提前安装好，这些根证书也可以在 CA 机构的官网上获取得到。 目前全球大型权威 CA 机构有 Symantec、GeoTrust、Comodo 以及 RapidSSL 等，并且这些机构颁发的 SSL 数字证书，在市场的占有率是非常的高。（节选自《SSL 证书颁发机构有哪些》） 本地被内置了这么多的根证书，那要怎么知道我这份证书应该要用哪一个根证书来验证呢？ 回答：证书信任链。 在信任链上有 3 类证书：根证书，中介证书和用户证书。根证书前文已有说明，用户证书就是对端发过来的证书，或者说是用户向权威 CA 机构绑定了自己身份（主要指域名）和自己公钥的证书。中介证书可以理解由权威 CA 机构委派的代理机构签发的数字证书，推荐阅读《What is an intermediate certificate?》。中介证书或者说是中介机构的存在是为了保证根证书的密钥的安全性。 细心的同学仔细看一看 certmgr 会发现有一个分类是“中间证书颁发机构”，这里存放的就是中介证书。用户证书绝大多数是通过权威的 CA 机构的代理中介机构颁发。 这么来说，根据对端发来的用户证书寻找对应的根证书岂不是更困难了？ 自问自答：这是一个在树形数据结构中，从叶子节点搜索根节点的过程，直接一个最原始的深搜（DFS）不就可以了嘛？举例说明，如下图（引自Wikipedia-Chain of trust）： 从用户证书开始。 记“Issuer”字段的值为 i1，搜索本地证书，寻找由“Subject”为 i1 的证书。 若没有找到，结束返回证书无效；否则，跳到步骤 4)。 判断该证书的 Issuer 值是否等于 Subject 值。 若是，则该证书是根证书，结束返回该证书；否则跳到步骤 6)。 以该证书开始，跳转 2)（继续搜索）。 更多关于信任链的知识点，推荐阅读《What is the SSL Certificate Chain?》 4、证书怎么样？相信不少同学或多或少接触过证书文件，比如.pem、.crt、.cer、.key 等，于是问题就来了： “为什么有这么多不同后缀名的证书啊？他们有什么联系和区别？” 回答这个问题要从 3 个层面来分析： 证书标准 证书编码格式 文件扩展名 证书标准 数字证书的格式普遍采用的是 X.509 国际标准，维基百科对于 X.509 解释如下： X.509 是密码学里公钥证书的格式标准。X.509 证书已应用在包括 TLS/SSL在内的众多网络协议里，同时它也用在很多非在线应用场景里，比如电子签名服务。X.509证书里含有公钥、身份信息（比如网络主机名，组织的名称或个体名称等）和签名信息（可以是证书签发机构 CA的签名，也可以是自签名）。对于一份经由可信的证书签发机构签名或者可以通过其它方式验证的证书，证书的拥有者就可以用证书及相应的私钥来创建安全的通信，对文档进行数字签名。 X.509 是 ITU-T 标准化部门基于他们之前的 ASN.1 定义的一套证书标准。 证书的编码格式 X.509 标准的证书文件具有不同的编码格式：PEM 和 DER。 PEM PEM，全称 Privacy Enhanced Mail，以文本格式存储，以 ——-BEGINXXX——-开头、——-END XXX——-结尾，中间内容是 BASE64 编码数据。其文本内容大概如下： html ——-BEGIN CERTIFICATE——- Base64编码过的证书数据 ——-END CERTIFICATE——- 通常，PEM 格式可以存储公钥、私钥、证书签名请求等数据。查看 PEM 格式证书的信息一般采用如下命令： openssl x509 -in xxx.pem -text -nooutApache 和 Nginx 服务器偏向于使用这种编码格式. DER DER，全称 Distinguished Encoding Rules，以二进制存储，因此文件结构无法直接预览，只能通过如下命令查看： html openssl x509 -in xxx.der -inform der -text -noout DER 格式也可以存储公钥、私钥、证书签名请求等数据。Java 和 Windows 应用偏向于使用这种编码格式。 当然同一 X.509 证书的不同编码之间可以互相转换： PEM 转为 DER： openssl x509 -in xxx.pem -outform der -out xxx.der DER 转为 PEM： openssl x509 -in xxx.der -inform der -outform pem -out xxx.pem 文件扩展名 不同的扩展名可以分为以下几类： 证书： 存放数字证书，X.509 标准，格式可能是 PEM 或 DER。.crt、.cer 密钥： 用来存放一个 RSA 公钥或私钥，这类文件不是 X.509 标准，但是是 PEM 或 DER 格式。后缀名有.key。 证书+密钥： 可同时存放证书和 RSA 公钥/.pem、.der、.p12 证书请求： 并不是证书，而是证书签名请求。csr","categories":[],"tags":[{"name":"Https","slug":"Https","permalink":"http://vompom.github.com/tags/Https/"}],"author":"落叶挽歌"},{"title":"想统计自己总共提交了多少行代码？","slug":"想统计自己总共提交了多少行代码？","date":"2020-03-02T03:01:00.000Z","updated":"2025-05-20T11:46:57.000Z","comments":true,"path":"2020/03/02/想统计自己总共提交了多少行代码？/","permalink":"http://vompom.github.com/2020/03/02/%E6%83%B3%E7%BB%9F%E8%AE%A1%E8%87%AA%E5%B7%B1%E6%80%BB%E5%85%B1%E6%8F%90%E4%BA%A4%E4%BA%86%E5%A4%9A%E5%B0%91%E8%A1%8C%E4%BB%A3%E7%A0%81%EF%BC%9F/","excerpt":"","text":"作为一名程序员，我们很想知道自己到底提交了多少行代码到远程仓库，有没有什么工具能够帮我们统计自己写过的代码行数呢？答案是有的。 这是本次实现的最终效果: 统计代码行数的方式对于代码提交行数统计，通过git 的系统命令就能做到，如下代码所示 git log --author=&#x27;username&#x27; --pretty=tformat: --numstat | awk &#x27; &#123;add += $1; subs += $2; loc += $1 - $2 &#125; END &#123; printf &quot;添加了%s,删除了%s,合计%s\\n&quot;, add, subs, loc &#125;&#x27; - 只需要在如下命令输入自己的username就行了，效果如图所示· 但是有的人由于环境原因，为了区分一些环境，比如办公司叫：username.office 在家的电脑上叫做: user.home 诸如此类，难道得手动一个一个统计么？当然不行了。 众所周知，由于工程项目变得更越来越大，拆库也说见不鲜，于是自己的代码分布不同的项目工程，我们想要利用git的统计命令的话就有点吃力了，需要一个一个地进入相应目录进行命令输入？当然不行了。 今天自己写了一份脚本主要用于统计分布在某个文件夹下所有的代码提交行数，git开源地址：https://github.com/VomPom/ForFun源码如下 如何使用？ 0、将自己需要统计的项目文件目录整理到一个文件夹 1、讲users_name换成自己的的用户名 2、由于文件夹下可能有一些例外的不需要统计，添加该文件夹名 3、讲该shell脚本移动到某个名录下 4、最后利用 sh codeLine.sh 执行命令 ########################################################## Created by https://julis.wang on 2020/02/28## Description : 统计代码提交行数##########################################################!/bin/bash#这里添加你的git常用用户名。考虑到每个人的账号可能有很多个，所以定义成数组users_name=(&quot;julis&quot; &quot;julis.wang&quot; &quot;julis.wang.hp&quot;) #过滤一些不需要去遍历的文件夹filter_path=(&quot;Backend&quot; &quot;test&quot; &quot;sdk&quot; &quot;fork&quot; &quot;ArProject&quot;) ######################################################### 以下代码不需动 ########################################################export index=0 #记录当前的位置export add_line_count=0 #添加的line总行数export remove_line_count=0 #删除的总行数export array_git_repositories=() #用于记录仓库名export add_code=() #记录所有用户对某个库的添加的行数export remove_code=() #记录所有用户对某个库的删除的行数#判断是否需要过滤该目录function is_fileter_dir() &#123; for i in &quot;$&#123;!filter_path[@]&#125;&quot;; do if [ $1 == &quot;$&#123;filter_path[$i]&#125;&quot; ]; then return 1 fi done return 0&#125;#对命令执行的返回值进行数据切割function get_add_remove_count() &#123; string=$1 array=($&#123;string//,/ &#125;) if [ ! $&#123;array[0]&#125; ]; then add_line=0 else add_line=$&#123;array[0]&#125; fi if [ ! $&#123;array[1]&#125; ]; then remove_line=0 else remove_line=$&#123;array[1]&#125; fi if [ ! $&#123;add_code[$index]&#125; ]; then add_code[$index]=0 fi if [ ! $&#123;remove_code[$index]&#125; ]; then remove_code[$index]=0 fi remove_code[$index]=`expr $&#123;remove_code[$index]&#125; + $remove_line` add_code[$index]=`expr $&#123;add_code[$index]&#125; + $add_line` echo &quot;用户&quot;$2&quot;添加了=&quot;$add_line&quot;行 删除了&quot;$add_line&quot;行&quot; &#125;#获取该用户在该文件夹下的提交代码数function get_user_line() &#123; # output分别去接收 该文件夹下的提交以及删除行数 output=$(git log --author=$&#123;1&#125; --pretty=tformat: --numstat | awk &#x27; &#123;add += $1; subs += $2; loc += $1 - $2 &#125; END &#123; printf &quot;添加了%s,删除了%s,合计%s\\n&quot;, add, subs, loc &#125;&#x27; -) get_add_remove_count $output $&#123;1&#125;&#125;#遍历每个用户名function trans_every_user() &#123; for i in &quot;$&#123;!users_name[@]&#125;&quot;; do get_user_line &quot;$&#123;users_name[$i]&#125;&quot; done cd ..&#125;# 整体流程，从文件夹出发for path in `ls -l $(dirname $0)|awk -F &quot; &quot; &#x27;&#123;print $9&#125;&#x27;`do if [ -d $path ] then is_fileter_dir $path if [ $? == 1 ] then echo &quot;&lt;=========过滤了【&quot;$path&quot;】======&gt;&quot; else echo &quot;&lt;=========获取【&quot;$path&quot;】的Git代码提交数据======&gt;&quot; index=$&#123;#array_git_repositories[@]&#125; #用于记录当前在第几个文件夹下处理 array_git_repositories=($&#123;array_git_repositories[@]&#125; $path) cd $path trans_every_user fi fidoneall_add_line=0all_remove_line=0echo &#x27;===============================================================================&#x27;echo &quot; 本次共统计了【&quot;$&#123;#array_git_repositories[@]&#125;&quot;】个仓库 by julis.wang &quot;echo &#x27;===============================================================================&#x27;printf &quot;%-30s %10s %10s %10s\\n&quot; &quot;Folder&quot; &quot;Add&quot; &quot;Remove&quot; &quot;All&quot;echo &#x27;-------------------------------------------------------------------------------&#x27;for ((i=0;i&lt;$&#123;#array_git_repositories[@]&#125;;i++))do all_add_line=`expr $all_add_line + $&#123;add_code[$i]&#125;` all_remove_line=`expr $all_remove_line + $&#123;remove_code[$i]&#125;` printf &quot;%-30s %10s %10s %10s\\n&quot; $&#123;array_git_repositories[$i]&#125; $&#123;add_code[$i]&#125; $&#123;remove_code[$i]&#125; `expr $&#123;add_code[$i]&#125; - $&#123;remove_code[$i]&#125;`doneecho &#x27;-------------------------------------------------------------------------------&#x27;printf &quot;%-30s %10s %10s %10s\\n&quot; &quot;Total&quot; $all_add_line $all_remove_line `expr $all_add_line - $all_remove_line`echo &#x27;===============================================================================&#x27; 写在最后：由于本人不太擅长编写shell脚本，所有其中的代码实现方式可能比较粗糙，望理解。","categories":[{"name":"技术文章","slug":"technology","permalink":"http://vompom.github.com/categories/technology/"}],"tags":[{"name":"Shell","slug":"Shell","permalink":"http://vompom.github.com/tags/Shell/"}],"author":"落叶挽歌"},{"title":"致二零一九","slug":"致二零一九","date":"2019-12-31T15:59:00.000Z","updated":"2025-05-20T11:46:57.000Z","comments":true,"path":"2019/12/31/致二零一九/","permalink":"http://vompom.github.com/2019/12/31/%E8%87%B4%E4%BA%8C%E9%9B%B6%E4%B8%80%E4%B9%9D/","excerpt":"","text":"告别了二零一九，迎来了二零二零，”二零二零”真的是一个很陌生的词，邓小平在四十年前提出的口号：“全面建设成小康社会”，而如今已经到了这个节点，我与大多数人一样，其实都对“小康”没有一个很明确的理解，亦不知道现在是否可以定义为“小康社会”。然而这并不重要，这并不是我该去研究探索的实物，毕竟人人都有自己的“小康”目标。 已经挥手告别了二零一九，在此做一个年度的总结吧。 二零一九或许给人最大的改变，那就是身份的改变吧，结束了长达十六年的学校学生的身份，成为了一名社会人，也拥有了自己的职业称呼—Android开发工程师。很荣幸，我选择了我自己所感兴趣的行业进行了就业，在初高中就萌发出来的对于编程相关的兴趣，是我从事此行业的动力，我并不感到厌倦；也很荣幸，我加入了一家很不错的的公司，并没有像其他互联网公司进行压榨的“996”，也没有无休止地加班，跟随了一个很不错的师傅，教会了我很多很多……我很感激；也很荣幸，我不再是一名学生，但是我也并没有忘记学习，今年学习了很多，也读了很多书： 二零一九我完成了一次毕业旅行，至今依然还能记得青岛“静听海浪拍岸，坐看海天一色”，烟台那种天际辽阔无垠感。也与朋友去了趟武汉，感受到了武汉的生机活力。望明年能够去更多的城市去体会更多的不同。 二零一九我依然完成了很多自己的年初设置的目标： 1、坚持写日记 2、去现场看五场足球比赛 3、学习一门外语（日语） 4、技术博客数不少于10篇 5、体重控制在70kg以内 6、看至少十部电影 …… 时间的流逝带来了很多的东西，也让人丢掉了很多东西。几个月前，我买了一个ps4游戏机，希望找回童年那时的那种快乐，可是很难……我并不能静下心来去做这样一件事，也没有那种儿时花大精力去探索去钻研游戏的各个细节，一个游戏能重复玩个很多遍也不腻味。儿时面对着黑白电视机，像素点十分明显的游戏能够没日没夜的玩着，甚至到了吃饭也不愿意去，即便现在拥有了更华丽更丰富的画面，更好的游戏体验，可是它也并没有一局短暂的Dota游戏带来快感更划算。难道是说游戏不好玩么？不是的，是那颗心已经没有了吧…… 二零一九，一直是一个人，发现自己变得更自卑些了，亦或是害怕了。害怕去打破那样的宁静，害怕自己不够优秀。总是低着头，甚至不敢抬头看一眼，可我也很想抬起头来，也期待着”只愿君心似我心，定不负相思意”。 然而生活总是要继续的吧，还有很多很多的美好等着自己。 二零二零，又是一个新的年代，望向远方吧！","categories":[{"name":"生活感想","slug":"life","permalink":"http://vompom.github.com/categories/life/"}],"tags":[{"name":"省","slug":"thinking","permalink":"http://vompom.github.com/tags/thinking/"}],"author":"落叶挽歌"},{"title":"从奶酪夹心饼干生产中来学习Android 中的gradle构建","slug":"从奶酪夹心饼干生产中来学习Android-中的gradle","date":"2019-12-18T11:48:00.000Z","updated":"2025-05-20T11:46:57.000Z","comments":true,"path":"2019/12/18/从奶酪夹心饼干生产中来学习Android-中的gradle/","permalink":"http://vompom.github.com/2019/12/18/%E4%BB%8E%E5%A5%B6%E9%85%AA%E5%A4%B9%E5%BF%83%E9%A5%BC%E5%B9%B2%E7%94%9F%E4%BA%A7%E4%B8%AD%E6%9D%A5%E5%AD%A6%E4%B9%A0Android-%E4%B8%AD%E7%9A%84gradle/","excerpt":"","text":"最近终于有机会做一些关于Android plugin相关的东西，之前虽然有学习过《Android 权威指南》一书，但是并没有进行一个实战操作，都是一些理论相关的学习。最近做了一个plugin主要是为了提取class文件里面的注解信息然后讲起搜集并上传。在实践中回过头发现很多知识都已经遗忘，所以本文对相关一些比较核心的知识进行一个回顾与梳理。 一、Gradle概述 在Android开发中，Gradle是每个开发者都会接触的，Gradle 是一个非常优秀的项目构建工具。这是大家都知道的，但是又有啥用呢？ 最开始的时候很难理解gradle到底是干什么的，相关知识都比较离散，所以很多东西没有串起来，从而导致理解起来比较困难。 我自己总结就是：Gradle是一个构建工具，它存在的目的是产生一套“流水线”，对于安卓开发而言这个流水线就是从本地的编写代码以及资源整合到最终生成的产品过程。 用一个很形象的例子举例，我们现在要生产一包奶酪夹心饼干，于是我们得定义一个生产顺序：先让有的地方去生成饼干，有的地方生成出来奶酪，之后再让两块饼干夹着一块奶酪，最后再将它们装进一个小包装袋里面。 另一种情况：如果我想在奶酪中加一点果酱，那么我们不需要重新建立一套生产线，只需要在两块饼干与奶酪结合的过程中修改一下加入果酱的流程。 再另一种情况：如果我生产出来的奶酪夹心饼干不需要包装，那只需要在最后一个步骤让它另外走一条线路，毕竟没有包装的又不是不能吃，对吧？如上图所示，我们定义了三种流程，每种流程最后的产出物是不一样的，因为流程的“初始化”的东西是不一样的以及过程中的“配置”，所以“执行”的时候就不一样。 对比我们安卓开发：本地的Java文件以及资源文件就是对应的饼干以及奶酪，最终生成的面向用户的apk文件就是包装好的奶酪夹心饼干。 如果我们想打Debug包，那么就像是一个散装的饼干，我们能自己用用，但是还不能面向用户，如果想打Release包那么就是最终的产品形态能直接面向用户。 上面的例子讲得比较长，其实主要想让更多人能够更好地去理解gradle的用处。 当我们每次点击Android Studio的 run运行按钮之后，会看到控制台输出一大堆相关日志，例如下图所示： 其实这些都是系统为我们封装好的一些task点击 run 按钮，就相当于执行了一次 Gradle Task，一般来说，是Task assembleDebug或者Task assembleRelease Gradle是目前Android主流的构建工具，无论通过命令行还是通过AndroidStudio来build，最终都是通过Gradle来实现的。以及Android领域的探索已经越来越深，不少技术领域如插件化、热修复、构建系统等都对Gradle有相关的需要。 二、Groovy知道了Gradle的用处之后，我们很形象的知道Gradle是为了去产生一个流水线。那这个流水线是利用什么做到的呢？对于奶酪饼干生产的工厂他们是不同的车间机械工具直接的逻辑组装。而对于Gradle则是利用groovy语言编写出来的相关脚本从而来进行一个编译相关的配置。这里不再具体描述groovy语言的具体用法，这里我列举出来几个自己认为比较重要的几个技术点。 1、Closure（闭包）闭包是的groovy语言具有，而Java语言不具有的特性，有人说Lambda表达式就是闭包，但是两则还是有一定的差异的，有兴趣的同学可以去看看这篇Java中Lambda表达式解析 定义闭的语意 ： { [closureParameters -&gt; ] statements } 其中[closureParameters-&gt;]代表参数，多参数用逗号分割，用-&gt;隔开参数与内容，没有参数可以不写-&gt;例如我们精彩在.gradle文件里面看到这样的内容： 其中projcet就是[closureParameters-&gt;]，-&gt;之后的respositories就是statements，对于这段代码而言，statements里面又是一个闭包，如果改写成Java的样子就更形象了： void subprojercts(Project projct) &#123; doSomething....&#125; 2、方法的输入参数优化groovy中定义的函数，如果至少有一个参数，在调用的时候可以省略括号。比如这样 def func(String a)&#123; println(a)&#125; func &#x27;hello&#x27; 在gradle有大量省略括号调用函数的例子，比如 defaultConfig &#123; minSdkVersion rootProject.ext.minSdkVersion targetSdkVersion rootProject.targetSdkVersion&#125; 比如这里minSdkVersion 和 targetSdkVersion 其实就是调用了两个函数,传入了不同的参数，在AndroidStudio里面可以点进去查看函数实现 当然如果某个函数没有参数，那就不能省略括号，否则会当成一个变量使用 3、类的Property 如果类的成员变量没有加任何权限访问，则称为Property, 否则是Field，filed和Java中的成员变量相同，但是Property的话，它是一个private field和getter setter的集合，也就是说groovy会自动生成getter setter方法，因此在类外面的代码，都是会透明的调用getter和setter方法。 4、Trait 特性使用关键字 trait 声明，可以拥有普通成员和抽象成员。例如：trait MessageHandler &#123; // 属性 int minLenght // 方法 // 普通方法 void echo(String msg) &#123; println(msg) &#125; // 抽象方法 abstract void show(String msg)&#125;trait AnotherMessageHandler &#123; // 抽象方法 abstract void show(String msg)&#125;class Message implements AnotherMessageHandler, MessageHandler &#123;.......&#125;Groovy 中特质本质上是运行时对接口的实现，所以其方法的访问控制符只支持 public 和 private。从代码的书写可以看出来trait又像java中的abstract类又像interface。说他像interface是因为从编写上看就是使用了implements关键字，但是接口又不能使用普通方法。说他像抽象类，因为其内部使用了abstract定义抽象方法。但是它又能implements多个，而达到“多继承”的特性。因此它不是接口，也不是抽象类，它是 trait。 三、Gradle的依赖我们继续回到上面奶酪夹心饼干的生产上面，在产出奶酪夹心饼干之前，我们需要分别生产好单独的饼干与奶酪。假如我们的饼干原料有很多种，姑且我们叫他饼干v1，饼干v2……饼干vn ，奶酪也有很多种，我们叫它奶酪v1，奶酪v2……奶酪vn。那这么多种具体生产起来就应该有相关的选择，在Android开发中各种库都被单独抽了出来，只需要单独声明出来需要用哪个库即可。 我们平时看的的dependencies如下所示 dependencies &#123; implementation fileTree(dir: &#x27;libs&#x27;, include: [&#x27;*.jar&#x27;]) implementation &#x27;com.android.support:appcompat-v7:28.0.0&#x27; implementation &#x27;com.victor:lib:1.0.4&#x27; api &#x27;com.android.support:recyclerview-v7:28.0.0&#x27; implementation &#x27;com.google.code.gson:gson:2.8.6&#x27; implementation(&#x27;com.wanjian:sak:0.1.0&#x27;) &#123; exclude group: &#x27;com.android.support&#x27;, module: &#x27;appcompat-v7&#x27; &#125;&#125; 1、依赖配置Gradle依赖的配置中主要使用以下关键字，摘自谷歌官方Gradle文档-&gt;添加编译依赖项 implementationGradle 会将依赖项添加到编译类路径，并将依赖项打包到编译输出。不过，当您的模块配置 implementation 依赖项时，会让 Gradle 了解您不希望该模块在编译时将该依赖项泄露给其他模块。也就是说，其他模块只有在运行时才能使用该依赖项。 apiGradle 会将依赖项添加到编译类路径和编译输出。当一个模块包含 api 依赖项时，会让 Gradle 了解该模块要以传递方式将该依赖项导出到其他模块，以便这些模块在运行时和编译时都可以使用该依赖项 annotationProcessor要添加对作为注解处理器的库的依赖关系，您必须使用 annotationProcessor 配置将其添加到注解处理器类路径。这是因为，使用此配置可以将编译类路径与注解处理器类路径分开，从而提高编译性能。如果 Gradle 在编译类路径上找到注解处理器，则会禁用避免编译功能，这样会对编译时间产生负面影响（Gradle 5.0 及更高版本会忽略在编译类路径上找到的注解处理器）。 2、依赖的传递与冲突 在Maven仓库中，构件通过POM（一种XML文件）来描述相关信息以及传递性依赖。Gradle 可以通过分析该文件获取获取所以依赖以及依赖的依赖和依赖的依赖的依赖，为了更加直观的表述，可以通过下面的输出结果了解。 +--- com.github.hotchemi:permissionsdispatcher:2.2.0| \\--- com.android.support:support-v4:23.1.1 -&gt; 28.0.0| +--- com.android.support:support-compat:28.0.0| | +--- com.android.support:support-annotations:28.0.0| | +--- com.android.support:collections:28.0.0| | | \\--- com.android.support:support-annotations:28.0.0| | +--- android.arch.lifecycle:runtime:1.1.1| | | +--- android.arch.lifecycle:common:1.1.1| | | | \\--- com.android.support:support-annotations:26.1.0 -&gt; 28.0.0| | | +--- android.arch.core:common:1.1.1| | | | \\--- com.android.support:support-annotations:26.1.0 -&gt; 28.0.0 我依赖hotchemi:permissionsdispatcher这个库，而它内部又陆陆续续地依赖了后面的一大堆。借助Gradle的传递性依赖特性，你无需再你的脚本中把这些依赖都声明一遍，你只需要简单的一行，Gradle便会帮你将传递性依赖一起下载下来。 然而问题来了这里面依赖了：android.arch.core:common:1.1.1 而我本地其他地方又使用了android.arch.core:common:1.0.0老版本。那我该如何去做这件事呢？ 于是便有了如下关键词：excludeforcetransitive 具体作用如下代码所示 implementation (&#x27;com.google.code.gson:gson:2.8.6&#x27;) &#123; force = true //强制使用这个版本的库&#125;implementation (&#x27;de.hdodenhof:circleimageview:3.0.1&#x27;) &#123; transitive = true //防止向外暴露&#125;implementation(&#x27;com.wanjian:sak:0.1.0&#x27;) &#123; exclude group: &#x27;com.android.support&#x27;, module: &#x27;appcompat-v7&#x27; //排除里面不需要的库&#125; 四、Gradle的Task构建与执行再回到生产饼干的例子上面来，最开始我们定义了一些流程，然后再让机器以该流程去执行。 比如先准备两块饼干再与奶酪进行加工生成夹心饼干，最后再加入包装。这是一条正确的流水，我们不可能让加入包装在加工生成夹心饼干之前。于是我们得定义一些约束，让其有正确的执行顺序。或者我们像加入果酱，那么就应该对原始的流程进行一些添加。 对于Gradle中，我们以Task为单位，类比生产奶酪饼干，生成饼干是一个专门的Task，生成奶酪也是一个专门的Task，加工成夹心也是一个Task……对于Android开发，将java文件编译为class，再到最后的dex生成都是Task 在Task的构建与执行中主要分为三个流程： 初始化（Initialization）settings.gradle确定参与构建的module为每个module创建Project对象实例 配置（Configuration ）build.gradle脚本执行，配置对应project实例创建有向无环图通过finalizedBy指定后续通过must/shouldRunAfter约束执行顺序 执行（Execution ）根据关系图执行task监听器 主要流程如图所示（图片摘自https://www.jianshu.com/p/0acdb31eef2d）： 五、Gradle插件继续奶酪夹心饼干的故事，如果夹心饼干模样规规矩矩没有花纹，岂不是很low？于是工厂专门研发了一款能让饼干产生纹路的机器，并在加工成夹心饼干之前将纹路印到饼干上面去，假如这台机器我们把它叫做“印花纹机”，是一个能从整个生产流程中独立的出来的机器，这台“印花纹机”也能用在生产其他的饼干上。 对应在我们的Android开发中，在构建流程中我们抽离出来一些功能，将其独立开来，这就是plugin，这里不再讲解plugin的编写相关操作，可以参考Gradle 自定义 plugin 1、插件分类 脚本插件顾名思义，如下图所示我们将对应的插件脚本中加入相关插件的逻辑，如下图所示，“other.gradle”便是一个插件 apply from: &#x27;other.gradle&#x27; 二进制插件二进制插件就是实现了 org.gradle.api.Plugin 接口的插件，每个 Java Gradle 插件都有一个 plugin id，可以通过如下方式使用一个 Java 插件： apply plugin : &#x27;maven&#x27; 通过上述代码就将 Java 插件应用到我们的项目中了，其中 maven 是 Java 插件的 plugin id，对于 Gradle 自带的核心插件都有唯一的 plugin id 2、打包方式 build script在插件分类中我们提到有apply from: &#39;other.gradle&#39; 其中other.gradle就是一个打包好的build script buildSrc将插件写在工程根目录下的buildSrc目录下，这样可以在多个模块之间复用该插件。buildSrc是Gradle在项目中配置自定义插件的默认目录，但它并不是标准的Android工程目录，所以使用这种方式需要我们事先手动创建一个buildSrc目录 独立项目创建独立的插件项目具有更强的灵活性，能让更多的工程使用这个插件，但流程也会相对复杂一点.这里不再具体讲解，可以参考Gradle 自定义 plugin 参考资料： https://www.jianshu.com/p/6dc2074480b8https://www.jianshu.com/p/bcaf9a269d96https://juejin.im/entry/59918304518825489151732dhttps://www.jianshu.com/p/0acdb31eef2dhttps://juejin.im/post/5cc5929bf265da036706b350https://doc.yonyoucloud.com/doc/wiki/project/GradleUserGuide-Wiki/gradle_plugins/binary_plugins.html","categories":[{"name":"技术文章","slug":"technology","permalink":"http://vompom.github.com/categories/technology/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://vompom.github.com/tags/Android/"}],"author":"落叶挽歌"},{"title":"一款快速生成安卓shape的插件--NoCodeShape","slug":"一款快速生成Android-shape的插件-NoCodeShape","date":"2019-11-27T08:06:00.000Z","updated":"2025-05-20T11:46:57.000Z","comments":true,"path":"2019/11/27/一款快速生成Android-shape的插件-NoCodeShape/","permalink":"http://vompom.github.com/2019/11/27/%E4%B8%80%E6%AC%BE%E5%BF%AB%E9%80%9F%E7%94%9F%E6%88%90Android-shape%E7%9A%84%E6%8F%92%E4%BB%B6-NoCodeShape/","excerpt":"","text":"NoCodeShape 是一个能可视化界面操作生成Android中Shape.xml的Android Studio插件。对于新手能更好的去接受Android中相对应的属性，对于资深程序员则能简化操作，快速生成shape.xml。项目已经开源 NoCodeShape 二、NoCodeShape使用方法1. 下载和安装同一般的Android Studio插件下载一样，可以直接Preferences-&gt;Plugins 搜索 NoCodeShape搜索出来结果直接安装再重启即可。也可以去jetbrains插件管理的官网下载各个版本的插件https://plugins.jetbrains.com/plugin/13325-nocodeshape/versions然后Preferences-&gt;Plugins 再Install plugins from disk从本地安装 2. 如何使用在新建一个shape.xml文件后，右键选择NoCodeShape或者直接按快捷键Common+U 然后选择自己想要的属性，随着点击事件的进行会生成相关xml代码，并在Android Studio右边有对应的shape形状的展示。如果对应shape.xml有相关属性，NoCodeShape也会生成对应shape.xml属性的操作界面，非常方便。示例： 三、实现原理实现原理总体来说并不复杂，主要是界面相关操作逻辑比较繁琐。 对于新生成的一个shape.xml来说只需要弹出一个新的操作界面，用户只需要点击对应模块的属性即可。项目使用了单例模式+Bulider建造者模式去管理各个Shape属性，分别生成 Shape、Solid、Corners、Stroke、Gradient的单例，其内部拥有一个Builder用来去承各类型的具体属性。 通过界面的操作，对其内部的Builder进行数据的填充，最后在完成各类操作后，将各类型中的Builder中的所有属性提取出并生成一份完整的xml字符串并将其粘贴到Android Studio的操作界面上。 实现主要分为两大类： 1. 拼接生成xml字符串字符串拼接算是其中最复杂的部分，一是各shape的类型拥有较多数据，其中一些属性有逻辑存在性，二是生成最终Android Studio的xml字符串的时候格式存在比较多的处理。对于各类属性都继承于BaseXml，其内部拥有一个静态内部Builder类，以相对简单的Solid类来举例，如下所示： public class Solid extends BaseXml &#123; private static Builder builder; private static Solid instance = null; public static Solid getInstance() &#123; if (instance == null) &#123; builder = new Builder(); instance = new Solid(); &#125; return instance; &#125; public static class Builder extends BaseBuilder &#123; String color; String colorValue; public void setColor(String color) &#123; this.colorValue = color; this.color = getAttrWithOutUnitStr(&quot;color&quot;, color); &#125; @Override public String getBuilderString() &#123; return StringUtils.getString(color); &#125; @Override public void clearData() &#123; StringUtils.clearObjectData(this); &#125; @Override public void analysisAttribute(Attributes attributes) &#123; Solid.getInstance().setChecked(true); setColor(attributes.getValue(&quot;android:color&quot;)); &#125; &#125; 其类继承于抽象类BaseXml，代码如下所示：public abstract class BaseXml &#123; private boolean isChecked = false; public String getCloser() &#123; return &quot; /&gt;&quot;; &#125; public String getStartTag() &#123; return &quot;&quot;; &#125; public String generateXmlString() &#123; return &quot;&quot;; &#125; protected String getLineFeedString() &#123; return &quot;\\n&quot;; &#125; public boolean isChecked() &#123; return isChecked; &#125; public BaseXml setChecked(boolean checked) &#123; isChecked = checked; return this; &#125;&#125;抽象类提取出来在字符串拼接阶段，各类型常用的基本操作，例如：返回“&lt;solid”这类的开始标签，” /&gt;”结束标签等 其内部BaseXml拥有对应类拥有的所有属性的常用操作，其继承与抽象类BaseBuilder，代码如下所示 public abstract class BaseBuilder &#123; public abstract String getBuilderString(); public abstract void clearData(); public abstract void analysisAttribute(Attributes attributes); protected final String getAttrWithUnitStr(String attributeType, String value) &#123; String unit; if (TextUtils.isEmpty(value)) &#123; return &quot;&quot;; &#125; if (value.contains(&quot;px&quot;) || value.contains(&quot;dp&quot;)) &#123; unit = &quot;&quot;; &#125; else &#123; unit = DefaultData.UNIT; &#125; return &quot;android:&quot; + attributeType + &quot;=\\&quot;&quot; + value + unit + &quot;\\&quot;&quot;; &#125; protected final String getAttrWithOutUnitStr(String attributeType, String value) &#123; if (TextUtils.isEmpty(value)) &#123; return &quot;&quot;; &#125; return &quot;android:&quot; + attributeType + &quot;=\\&quot;&quot; + value + &quot;\\&quot;&quot;; &#125; protected final String getValueOutUnit(String value) &#123; if (TextUtils.isEmpty(value)) &#123; return value; &#125; return value.replace(&quot;dp&quot;, &quot;&quot;).replace(&quot;px&quot;, &quot;&quot;); &#125;&#125; BaseBuilder内部封装了一些属性的常用操作，例如生成：android:color=&quot;#FFFFFF&quot;这样的字符串，获取是否带有单位的字串等。并提供三个抽象方法： public abstract String getBuilderString(); //获取Builder中所有属性拼接好的字符串public abstract void clearData(); //清空Builder内部属性值public abstract void analysisAttribute(Attributes attributes); //分析xml数据中的值，这个在第二大点“将原有shape.xml字符串转化为对应操作界面”中将会讲到 以上是基本数据的构造，在最后在控件交互的地方会调用CommonAction类的refreshAndWriteData： abstract class CommonAction &#123; JComponent component; NoShapeDialog noShapeDialog; void refreshAndWriteData() &#123; NoCodeShapeAction.callWriteData(); &#125;&#125; 最后会调用基本的Action中的writeData()方法，其具体逻辑为/** * 数据写入xml文件 */ private static void writeData() &#123; final Document document = FileDocumentManager.getInstance().getDocument(file); if (document == null) &#123; try &#123; throw new Exception(&quot;Document对象为空&quot;); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return; &#125; new WriteCommandAction.Simple(project) &#123; @Override protected void run() &#123; document.setText(XMLString.getInstance().generateXmlString()); //formatCode(); &#125; &#125;.execute(); &#125;利用XMLString.getInstance().generateXmlString()获取各操作类型的所有属性将其拼接为一份完整的shape.xml文件的字段，最后调用插件系统的相关命令将字符串粘贴在系统对应的输入框中。 2. 将原有shape.xml字符串转化为对应操作界面上面已经讲述类如何拼接生成xml字符串并将其粘贴到Android Studio界面上，此外NoCodeShape不仅支持新生成的shape.xml，同样也支持对旧shape.xml进行修改的能力。与第一步相比较主要多了一步读取Android Studio xml文档并将其转化为对应操作界面的过程。其主要是在操作界面初始化之前执行了如下方法： private void initSax() &#123; String text = FileDocumentManager.getInstance().getDocument(file).getText(); ShapeSaxHandler handler = new ShapeSaxHandler(); try &#123; handler.createViewList(text); &#125; catch (ParserConfigurationException e) &#123; e.printStackTrace(); &#125; catch (SAXException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; 利用ShapeSaxHandler去解析xml里面的元素，参考了FindViewByMe的解析原理。 具体操作逻辑如下： public void createViewList(String string) throws ParserConfigurationException, SAXException, IOException &#123; InputStream xmlStream = new ByteArrayInputStream(string.getBytes(&quot;UTF-8&quot;)); SAXParserFactory factory = SAXParserFactory.newInstance(); SAXParser parser = factory.newSAXParser(); parser.parse(xmlStream, this); &#125; @Override public void startDocument() throws SAXException &#123; if (shapePartList == null) &#123; shapePartList = new ArrayList&lt;ShapePart&gt;(); &#125; &#125; @Override public void startElement(String uri, String localName, String qName, Attributes attributes) throws SAXException &#123; switch (qName) &#123; case &quot;shape&quot;: Shape.getInstance().getBuilder().analysisAttribute(attributes); break; case &quot;stroke&quot;: Stroke.getInstance().getBuilder().analysisAttribute(attributes); break; case &quot;solid&quot;: Solid.getInstance().getBuilder().analysisAttribute(attributes); break; case &quot;gradient&quot;: Gradient.getInstance().getBuilder().analysisAttribute(attributes); break; case &quot;corners&quot;: Corners.getInstance().getBuilder().analysisAttribute(attributes); break; default: break; &#125; 逻辑其实很清楚，主要对startTag的判断，然后通过调用 public abstract void analysisAttribute(Attributes attributes);的方法对相应的 类型的Buidler进行一个赋值操作。 以Stroke为例： @Override public void analysisAttribute(Attributes attributes) &#123; Stroke.getInstance().setChecked(true); setColor(attributes.getValue(&quot;android:color&quot;)); setDashGap(attributes.getValue(&quot;android:dashGap&quot;)); setWidth(attributes.getValue(&quot;android:width&quot;)); setDashWidth(attributes.getValue(&quot;android:dashWidth&quot;)); &#125; 主要是获取到其中的属性，并对初始化的界面进行一些操作(例如选中或者赋值相关操作)。 四、总结这个插件算是自己第一次做一个相对较实用的插件，都是利用工作的空闲事件进行编写，前前后后进行了将近一个月，其中收获颇多，但也踩过了各种各样的坑。在开发过程中由于相关文档较少，通过阅读官方文档还是有点小吃力，不过一步步还是走了下来，自己也得到了成长。其中坑也都添平了，但由于一些基础技术的欠缺，比如对Java GUI界面编程不太熟悉，导致开发过程中有很大一段时间都在跟界面作对，因此后面有机会将去深入了解Java的界面编程，争取能够将页面交互能够做到更好。 另外由于自身开发精力的原因，不能将插件做到完美，目前插件中还有如下几个问题： 1、Gradient中对应相关逻辑还需要再优化2、还未支持Size跟Pading（从自身所处环境考虑用得较少，所以暂未支持）3、对于颜色选择器默认打开后不支持对本地颜色字符串处理4、存在大量的界面操作逻辑代码，需要优化 最后，希望大家能在使用过程中提出相关的意见或建议，也欢迎能一起加入到开发中，从而能将该插件做得更加完美。 项目地址： https://github.com/VomPom/NoCodeShape","categories":[{"name":"技术文章","slug":"technology","permalink":"http://vompom.github.com/categories/technology/"}],"tags":[{"name":"插件","slug":"插件","permalink":"http://vompom.github.com/tags/%E6%8F%92%E4%BB%B6/"}],"author":"落叶挽歌"},{"title":"Java中的Reference解析","slug":"Java四种引用","date":"2019-10-30T11:45:00.000Z","updated":"2025-05-20T11:46:57.000Z","comments":true,"path":"2019/10/30/Java四种引用/","permalink":"http://vompom.github.com/2019/10/30/Java%E5%9B%9B%E7%A7%8D%E5%BC%95%E7%94%A8/","excerpt":"","text":"Java执行GC判断对象是否存活有两种方式其中一种是引用计数。 引用计数：Java堆中每一个对象都有一个引用计数属性，引用每新增1次计数加1，引用每释放1次计数减1。 在JDK 1.2以前的版本中，若一个对象不被任何变量引用，那么程序就无法再使用这个对象。也就是说，只有对象处于(reachable)可达状态，程序才能使用它。 从JDK 1.2版本开始，对象的引用被划分为4种级别，从而使程序能更加灵活地控制对象的生命周期。这4种级别由高到低依次为：强引用、软引用、弱引用和虚引用，本文主要讲解各个引用的用途以及引用队列的作用。 1、强引用（StrongReference）强引用指的是程序代码中普遍存在的，类似如下代码Object object = new Object();当内存空间不足时，只要强引用还在，Java虚拟机会抛出OutOfMemoryError错误，使程序异常终止，也不会靠回收强引用的对象来解决内存不足的问题。 如果强引用对象不使用时，需要弱化从而使GC能够回收，如下所示：object = null; 2、软引用（SoftReference）软引用是用来描述一些有用但并不是必需的对象。对于软引用关联着的对象，在系统将要发生内存溢出异常之前，将会把这些对象列进回首范围之中进行第二次回收。如果这次回收还没有足够的内存，才会抛出内存溢出异常。 这一点可以很好地用来解决OOM的问题，并且这个特性很适合用来实现缓存：比如网页缓存、图片缓存等，软引用可用来实现内存敏感的高速缓存。 // 强引用String strongReference = new String(&quot;abc&quot;);// 软引用String str = new String(&quot;abc&quot;);SoftReference&lt;String&gt; softReference = new SoftReference&lt;String&gt;(str); 软引用可以和一个引用队列(ReferenceQueue)联合使用。如果软引用所引用对象被垃圾回收，JAVA虚拟机就会把这个软引用加入到与之关联的引用队列中。 ReferenceQueue&lt;String&gt; referenceQueue = new ReferenceQueue&lt;&gt;();String str = new String(&quot;abc&quot;);SoftReference&lt;String&gt; softReference = new SoftReference&lt;&gt;(str, referenceQueue);str = null;// Notify GCSystem.gc();System.out.println(softReference.get()); // abcReference&lt;? extends String&gt; reference = referenceQueue.poll();System.out.println(reference); //null 注意：软引用对象是在jvm内存不够的时候才会被回收，我们调用System.gc()方法只是起通知作用，JVM什么时候扫描回收对象是JVM自己的状态决定的。就算扫描到软引用对象也不一定会回收它，只有内存不够的时候才会回收。 当内存不足时，JVM首先将软引用中的对象引用置为null，然后通知垃圾回收器进行回收：if(JVM内存不足) &#123; // 将软引用中的对象引用置为null str = null; // 通知垃圾回收器进行回收 System.gc(); &#125;也就是说，垃圾收集线程会在虚拟机抛出OutOfMemoryError之前回收软引用对象，而且虚拟机会尽可能优先回收长时间闲置不用的软引用对象。对那些刚构建的或刚使用过的较新的软对象会被虚拟机尽可能保留，这就是引入引用队列ReferenceQueue的原因，后面会具体讲解。 3、弱引用（WeakReference）弱引用也是用来描述非必需对象的，但是它的强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发生之前。当垃圾收集器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。 String str = new String(&quot;abc&quot;);WeakReference&lt;String&gt; weakReference = new WeakReference&lt;&gt;(str);str = null; 复制代码JVM首先将软引用中的对象引用置为null，然后通知垃圾回收器进行回收：str = null;System.gc(); 注意：如果一个对象是偶尔(很少)的使用，并且希望在使用时随时就能获取到，但又不想影响此对象的垃圾收集，那么你应该用Weak Reference来记住此对象。 下面的代码会让一个弱引用再次变为一个强引用： String str = new String(&quot;abc&quot;);WeakReference&lt;String&gt; weakReference = new WeakReference&lt;&gt;(str);// 弱引用转强引用String strongReference = weakReference.get(); 同样，弱引用可以和一个引用队列(ReferenceQueue)联合使用，如果弱引用所引用的对象被垃圾回收，Java虚拟机就会把这个弱引用加入到与之关联的引用队列中。 4、虚引用（PhantomReference）虚引用也称为幽灵引用或者幻影引用，它是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生命周期构成影响，也无法通过虚引用获得一个对象实例。 虚引用主要用来跟踪对象被垃圾回收器回收的活动，虚引用与软引用和弱引用的一个区别在于： 虚引用必须和引用队列(ReferenceQueue)联合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。 String str = new String(&quot;abc&quot;);ReferenceQueue queue = new ReferenceQueue();// 创建虚引用，要求必须与一个引用队列关联PhantomReference pr = new PhantomReference(str, queue); 程序可以通过判断引用队列中是否已经加入了虚引用，来了解被引用的对象是否将要进行垃圾回收。如果程序发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动。 5、引用队列（ReferenceQueue）在前面软引用、弱引用和虚引用都有讲到引用队列，那引用队列具体是做什么的呢？官方对于引用队列类的注释是： Reference queues, to which registered reference objects are appended by the garbage collector after the appropriate reachability changes are detected. 译为：引用队列是将垃圾收集器在监测到适当的可达性更改后将已注册的引用对象添加到该队列。 对于软引用和弱引用和虚引用，我们希望当一个对象被gc掉的时候通知用户线程，进行额外的处理时，就需要使用引用队列了。ReferenceQueue即这样的一个对象，当一个obj被gc掉之后，其相应的包装类，即ref对象会被放入queue中。我们可以从queue中获取到相应的对象信息，同时进行额外的处理。比如反向操作，数据清理等。 查看源码发现ReferenceQueue的代码结构并不复杂，从源码上看，实际上ReferenceQueue只是名义上的引用队列，它只保存了Reference链表的头(head)节点，并且提供了队列出队入队删除操作，而Reference实际上本身提供单向链表的功能，也就是说Reference通过成员属性next构建单向链表，而链表的操作是委托给ReferenceQueue完成。详细参考：深入理解JDK中的Reference原理和源码实现 6、总结1、Java中四种引用的级别和强度由高到低依次为：强引用 -&gt; 软引用 -&gt; 弱引用 -&gt; 虚引用 2、ReferenceQueue引用队列用来记录被回收的引用为用户线程做额外操作作铺垫 3、对各种引用回收时间、用途、生成时间作总结：参考： 1、《深入理解Java虚拟机》 2、深入理解JDK中的Reference原理和源码实现 3、理解Java的强引用、软引用、弱引用和虚引用","categories":[{"name":"技术文章","slug":"technology","permalink":"http://vompom.github.com/categories/technology/"}],"tags":[{"name":"Java","slug":"java","permalink":"http://vompom.github.com/tags/java/"}],"author":"落叶挽歌"},{"title":"(转)算法之优先队列 PriorityQueue解决Top K 问题","slug":"算法之优先队列-PriorityQueue解决Top-K-问题","date":"2019-10-10T01:51:00.000Z","updated":"2025-05-20T11:46:57.000Z","comments":true,"path":"2019/10/10/算法之优先队列-PriorityQueue解决Top-K-问题/","permalink":"http://vompom.github.com/2019/10/10/%E7%AE%97%E6%B3%95%E4%B9%8B%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97-PriorityQueue%E8%A7%A3%E5%86%B3Top-K-%E9%97%AE%E9%A2%98/","excerpt":"","text":"转自：https://www.jianshu.com/p/a4a1984fc4ff 解决方法：维护一个大小为 K 的小顶堆，依次将数据放入堆中，当堆的大小满了的时候，只需要将堆顶元素与下一个数比较：如果大于堆顶元素，则将当前的堆顶元素抛弃，并将该元素插入堆中。遍历完全部数据，Top K 的元素也自然都在堆里面了。 当然，如果是求前 K 个最小的数，只需要改为大顶堆即可 将数据插入堆 95 大于 20，进行替换 95 下沉，维持小顶堆对于海量数据，我们不需要一次性将全部数据取出来，可以一次只取一部分，因为我们只需要将数据一个个拿来与堆顶比较。 另外还有一个优势就是对于动态数组，我们可以一直都维护一个 K 大小的小顶堆，当有数据被添加到集合中时，我们就直接拿它与堆顶的元素对比。这样，无论任何时候需要查询当前的前 K 大数据，我们都可以里立刻返回给他。 整个操作中，遍历数组需要 O(n) 的时间复杂度，一次堆化操作需要 O(logK)，加起来就是 O(nlogK) 的复杂度，换个角度来看，如果 K 远小于 n 的话， O(nlogK) 其实就接近于 O(n) 了，甚至会更快，因此也是十分高效的。 最后，对于 Java，我们可以直接使用优先队列 PriorityQueue 来实现一个小顶堆，这里给个代码： public static List&lt;Integer&gt; solutionByHeap(int[] input, int k) &#123; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); if (k &gt; input.length || k == 0) &#123; return list; &#125; Queue&lt;Integer&gt; queue = new PriorityQueue&lt;&gt;(); for (int num : input) &#123; if (queue.size() &lt; k) &#123; queue.add(num); &#125; else if (queue.peek() &lt; num) &#123; queue.poll(); queue.add(num); &#125; &#125; while (k-- &gt; 0) &#123; list.add(queue.poll()); &#125; return list; &#125;","categories":[{"name":"算法研究","slug":"算法研究","permalink":"http://vompom.github.com/categories/%E7%AE%97%E6%B3%95%E7%A0%94%E7%A9%B6/"}],"tags":[{"name":"算法","slug":"algorithm","permalink":"http://vompom.github.com/tags/algorithm/"}],"author":"落叶挽歌"},{"title":"Java中Lambda表达式解析","slug":"Java中Lambda表达式解析","date":"2019-10-09T10:55:00.000Z","updated":"2025-05-20T11:46:57.000Z","comments":true,"path":"2019/10/09/Java中Lambda表达式解析/","permalink":"http://vompom.github.com/2019/10/09/Java%E4%B8%ADLambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%A7%A3%E6%9E%90/","excerpt":"","text":"在大部分开发者看来，Lambda 表达式只是一种语法糖，简化了书写匿名内部类的写法。实际上Lambda表达式并不仅仅是匿名内部类的语法糖，JVM内部是通过invokedynamic指令来实现Lambda表达式的，与内部类的实现有很大的差异。本文主要记录lambda的实现原理。 一、函数式接口众所周知Javascript具有一个强大的特性：闭包。Java中最接近闭包概念的东西就是lambda表达式了，而Lambda为Java添加了缺失函数式编程的特点。所以什么是函数是接口呢？ 函数式接口需满足以下两个条件： 它是接口 这个接口有且仅有一个抽象方法 例如我们常用的：Runnable、View.OnClickListener、Comparable等都是函数式接口，因为它们都只有一个方法，而且都是抽象的。虽然只有一个抽象方法，是不是就意味着只能有一个方法呢？实际并不是，虽然有且仅有一个抽象方法，但是可以有多个非抽象方法的接口。 嗯？！Java接口中难道还可以定义非抽象方法么？平时我们的接口大概长这样：public interface IdiomSubmitListener &#123; void verifyResult(String result); void onSuceess();&#125;那接口的非抽象方法是啥？原来在JDK 1.8 对于接口而言具有以下新特性：接口可以定义非抽象方法，但必须使用default或者staic关键字来修饰具体细节点可以参考 JAVA 8新特性 允许接口定义非抽象方法 快速入门案例 如果一个接口符合函数式接口的定义，那么我们就可以在该接口上面声明FunctionalInterface注解，用来表示该接口是一个函数式接口，并按照函数式接口的规范在编译的时候对该接口进行检查。 当然如果某个接口只有一个抽象方法，但我们并没有给该接口声明FunctionalInterface注解，那么编译器依旧会将该接口看做是函数式接口。 那Lambda表达式跟函数式接口又有什么关联呢？在JDK 1.8中，Lambda表达式是对象，而不是函数，它们必须依附于一类特别的对象类型—函数式接口。 因此可以说 在JDK 1.8中，Lambda表达式就是一个函数式接口的实例。所以如果一个实例是函数式接口的实例，那么该对象就可以用Lambda表达式来表示 二、Lambda表达式与匿名内部类我们知道代码IDE如果是在JDK1.8的环境下，使用匿名内部类作为一个参数传入到方法中，编译器会提示我们：Anonymous new Runnable() can be replaced with lambda，匿名内部类XXX可以替换为lambda表达式。 如下所示，匿名内部类 Runnable是一个函数式接口的实例，所以我们可以用lambda表达式来将之替换，从而将代码变得更加简洁。 那么我们是否就认为：Lambda表达式只是为匿名内部类中提供的一种语法糖，他们有什么区别呢？底层原理是完全一样的呢？ 他们主要区别如下： 1、关键字this。匿名内部类的this指向匿名类，而Lambda表达式的this指向被Lambda包围的外部类 2、编译方式。Java编译器将Lambda表达式编译成类的私有方法，使用Java7的invokedynamic字节码动态绑定这个方法。而匿名内部类将编译成外部类$数字编号的新类。这也造成第1点关键字this指向不同地方的原因。 三、Lambda实现原理我们知道如果使用匿名内部类，编译期间会生成一个外部类$数字编号的类，如图所示： 而如果使用Lambda表达式进行编译后并没有生成新类。 我们对Lambda表达式生成的class文件使用：javap -p -v Test.class 进行反编译生成如下内容，为便于观察，删除了一些无用内容public class wang.julis.jwbase.basecompact.TestConstant pool: #1 = Methodref #9.#18 // java/lang/Object.&quot;&lt;init&gt;&quot;:()V&#123; public wang.julis.jwbase.basecompact.Test(); descriptor: ()V flags: (0x0001) ACC_PUBLIC Code: stack=1, locals=1, args_size=1 0: aload_0 1: invokespecial #1 // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V 4: return LineNumberTable: line 12: 0 private void testLambda(); descriptor: ()V flags: (0x0002) ACC_PRIVATE Code: stack=3, locals=1, args_size=1 0: new #2 // class java/lang/Thread 3: dup 4: invokedynamic #3, 0 // InvokeDynamic #0:run:()Ljava/lang/Runnable; 9: invokespecial #4 // Method java/lang/Thread.&quot;&lt;init&gt;&quot;:(Ljava/lang/Runnable;)V 12: pop 13: return LineNumberTable: line 14: 0 line 18: 13 private static void lambda$testLambda$0(); descriptor: ()V flags: (0x100a) ACC_PRIVATE, ACC_STATIC, ACC_SYNTHETIC Code: stack=2, locals=0, args_size=0 0: getstatic #5 // Field java/lang/System.out:Ljava/io/PrintStream; 3: ldc #6 // String lambda 5: invokevirtual #7 // Method java/io/PrintStream.println:(Ljava/lang/String;)V 8: return LineNumberTable: line 15: 0 line 16: 8&#125;SourceFile: &quot;Test.java&quot;InnerClasses: public static final #50= #49 of #53; // Lookup=class java/lang/invoke/MethodHandles$Lookup of class java/lang/invoke/MethodHandlesBootstrapMethods: 0: #21 REF_invokeStatic java/lang/invoke/LambdaMetafactory.metafactory:(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite; Method arguments: #22 ()V #23 REF_invokeStatic wang/julis/jwbase/basecompact/Test.lambda$testLambda$0:()V #22 ()V从反编译的结果我们可以看到： 1、编译期间自动生成私有静态类lambda$testLambda$0而这里面就就是lambda的具体实现逻辑 2、使用invokedynamic去执行lambda表达式 关于invokedynamic命令具体细节可以参考： 08 | JVM是怎么实现invokedynamic的？（上） 3、lambda表达式编译后并没有生成外部类$数字编号的类 总结：1、函数式接口：有且仅有一个抽象方法，可以用非抽象方法1.8后支持 2、匿名内部类的this指向匿名类，而Lambda表达式的this指向被Lambda包围的外部类 3、lambda表达式编译后不会生成外部类$数字编号的类 4、Java编译器将Lambda表达式编译成类的私有方法，使用Java7的invokedynamic字节码动态绑定这个方法。 参考：1、《深入探索Android热修复技术原理》2.3.8章节2、Java8 lambda表达式、函数式接口、方法引用","categories":[{"name":"技术文章","slug":"technology","permalink":"http://vompom.github.com/categories/technology/"}],"tags":[{"name":"Java","slug":"java","permalink":"http://vompom.github.com/tags/java/"}],"author":"落叶挽歌"},{"title":"观《百鸟朝凤》有感","slug":"观《百鸟朝凤》有感","date":"2019-09-07T18:16:00.000Z","updated":"2025-05-20T11:46:57.000Z","comments":true,"path":"2019/09/08/观《百鸟朝凤》有感/","permalink":"http://vompom.github.com/2019/09/08/%E8%A7%82%E3%80%8A%E7%99%BE%E9%B8%9F%E6%9C%9D%E5%87%A4%E3%80%8B%E6%9C%89%E6%84%9F/","excerpt":"","text":"此刻子时，在朋友的推荐下看完了整部《百鸟朝凤》，看完之后我立马起身来打开电脑，心中思绪万千，准备写下来记录下来。自我观看了这么多电影以来，头一次是如此的触动，头一次留下来这样的眼泪，记得上一次很有感触还是因为《忠犬八公的故事》，那次泪水到了眼角，我忍住了，没有掉下来。这部电影实在是让我太感动了，我的泪水憋不下去了，源源不断地从眼眶里面流出来。我捂着自己的嘴巴，我怕自己嚎啕大哭起来，不停地抽泣。对一代匠人的崇敬之情，当然也让我想起来那个人…… 他已经离我六年之余，从离开他之后，我的梦大部分都是关于他，梦中的情节很多都是让我感觉他躲起来了，然后又出现再了我的面前。每次梦醒，思前想后，万端交集，竟不能复寐，他便是我的爷爷-兴武老大人。 关于他的记忆开始慢慢变得模糊，有很多事情都已经忘记，但又有很多我根本不能忘记。影片中的焦师傅，爷爷的形象简直和他一模一样，都一样抽着大烟，瘦弱的身躯，头顶的中间光秃秃的，走路总是半佝偻着腰，但是眼神又是那么的坚毅。他们都对传统文化有着独特的情感，我的爷爷也算是一个匠人，他是一名竹匠（“四川话叫 mie匠”），他只告诉过我，那个年代他们靠卖竹制的东西（大抵是一些席子、竹帘、晒席之类的东西）过日子，每天都帮着各种编织，才养活了包括我爸在内的五个子女。家中很多东西，也都是竹子做的。在我小的时候，我记得基本上我们整个村，每家每户都有一片属于自家的竹林，它不仅能提供我们编制各种东西的原材料，也能提供做饭生火的材料。在我现在看来，它更能提供那种接近大自然的方式。每当夜里，如果有阵阵微风，竹林中便会的竹叶洒洒作响的声音，我也很久没有听到这种声音了。 如果我看到我的爷爷拿着一把弯刀去后院，那我一定知道他应该是要去砍竹子，只听哐哐哐一阵声，竹子便倒了下来，他会剔除掉竹子的枝丫，以及顶部较为脆弱细小的部分。然后用取当中的一节，再用刀将其剖开，根据所做的东西的不同，会将竹子的圆分成不同的等分。然后会做一个比较难得的操作，具体用文字表达我也不知道该用什么术语去说，就是将竹子外层坚韧的部分与内部相分离，分离后的竹条厚度均匀。这便是编制前的准备阶段，对于编制一些特殊的物品，竹条可能还会经过一些其他一些操作才能继续编制。 为了编一个撮箕或者簸箕，爷爷可能会花上一整天的时间，弯腰在地一点一点的编织着。我经常在旁边看着，我可能也想去尝试，但一不下心手就会因为竹子的锋利而流血。而爷爷的手并不一样，我记得他的手上有很多老茧，手指头也特别的硬，我感觉他的手就像带了一个硬皮手套一样，这都是岁月留下来的痕迹吧。他总是给我讲他们过去的故事，也会给我讲解人生大道理。他给我讲梁山伯与祝英台的故事，他也给我讲毛泽东，他也讲以前文化大革命的故事……讲以前生活是多么的不容易，他们遭受了多少苦，我都还记得。爷爷编织好的竹制品真的很精致耐用，家里现在也还留着一些当时他编好的东西。我觉得那都是艺术品，都是源于一个人对生活的热爱以及对匠人的诠释吧。 后来搬家了，原先家里的那片竹林离我们有一些距离，我爸想把它们都挖了卖掉，因为现在我们不需要那么多竹子了。我爷爷当然不允许啊！卖掉？直接就跟我爸翻脸。在我看来，那片竹林可能承载了太多爷爷的记忆吧，太多的舍不得。但爷爷去世之后，那片竹林还是被移除掉了，实在痛惜。我后悔没有跟我的爷爷学这些编制技术，我爸会一些，但是我认为他只是一个半吊子，和爷爷做的东西比起来实在是差太多了。我爸曾说：“现在谁还做那些啊？有钱我们可以买。”，对于他的话我有反驳过。买来的那些都是些没有被注入感情的废铜烂铁吧，与爷爷的东西差太远了。或许真的因为时代的发展吧，这些东西渐渐地都被淘汰掉了，但我认为这些都是才是真正应该被传承下来的，不仅仅是因为这一门技术，更多的那一份精神吧。是用钱买不来的，机器造不来的。 《百鸟朝凤》这部电影令人肃然起敬，质朴的人物形象，体现出来了当代中国传统文化的潦倒与窘境，传承不是说说而已，是每一个中国人应该有的责任。在现代多元文化的冲击下，更多人的失去了对精神的追求和向往，取而代之的是短暂的愉悦刺激以及碎片化的东西。我们的生活其实可以更有内涵…… 困了，就写这么多吧，讲了一些乱七八糟的东西，懂得人自然懂吧。 晚安~","categories":[{"name":"读书电影","slug":"movie","permalink":"http://vompom.github.com/categories/movie/"}],"tags":[{"name":"省","slug":"thinking","permalink":"http://vompom.github.com/tags/thinking/"}],"author":"落叶挽歌"},{"title":"Android骨架屏效果的实现与原理解析","slug":"Android骨架屏效果的实现与原理解析","date":"2019-09-04T09:50:00.000Z","updated":"2025-05-20T11:46:57.000Z","comments":true,"path":"2019/09/04/Android骨架屏效果的实现与原理解析/","permalink":"http://vompom.github.com/2019/09/04/Android%E9%AA%A8%E6%9E%B6%E5%B1%8F%E6%95%88%E6%9E%9C%E7%9A%84%E5%AE%9E%E7%8E%B0%E4%B8%8E%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/","excerpt":"","text":"大家在使用淘宝的时候，如下图所示有遇到这样的效果，其会只展示一部分骨架大致图，等数据加载完毕之后再展示真正的页面数据。与菊花图相比起来，这样的实现能更好的提升用户的体验，这种效果称做：Skeleton Screen Loading，中文叫做骨架屏，本文主要记录其实现过程。 1、骨架屏的实现方式 在现在主流的骨架屏实现效果中有两种方式： 通过View或者Adapter的替换来实现骨架屏效果。可以参考ShimmerRecyclerView、Skeleton及spruce-android。 自定义一个View来对布局中的View进行一层包裹，当加载数据时则根据View来绘制骨架，否则显示正常UI，参考Skeleton Android。 这些开源库中，自己比较喜欢今天Skeleton这个开源库，总结了有如下一些优缺点： 优点： 代码方案实现及使用方式简单，通过替换View和Adapter实现效果，使用Builder设计模式来构造。 代码耦合程度不高。没有复杂的设计模式，使得代码结构清晰明了。 骨架屏的效果使用相对于较灵活，可以对整个布局实现骨架屏效果，也可以对单一View实现骨架屏效果。 缺点： 需要对每个骨架屏效果单独写一套xml布局。 使用的removeView和addView对 原有布局的view进行替换，存在一定的风险性 必须清晰的知道所bind的View类型，存在一定的类型转化问题。 依赖了shimmerlayout第三方库 2、Skeleton解读一、Skeleton的使用方式 展示骨架屏效果：View rootView = findViewById(R.id.rootView);skeletonScreen = Skeleton.bind(rootView) .load(R.layout.activity_view_skeleton)//骨架屏UI .duration(1000)//动画时间，以毫秒为单位 .shimmer(true)//是否开启动画 .color(R.color.shimmer_color)//shimmer的颜色 .angle(30)//shimmer的倾斜角度 .show();关闭骨架屏效果并展示原有View：skeletonScreen.hide() 流程： **1. 选择需要替换的目标view 将骨架效果xml与目标view进行绑定 添加一些效果属性，比如：动画时间、是否开启展示动画、动画颜色等 在合适的实际关闭骨架屏效果** 二、Skeleton源码实现 Skeleton提供两个绑定方法，分别绑定普通View与RecyclerView，分别返回对应的Builderpublic class Skeleton &#123; public static RecyclerViewSkeletonScreen.Builder bind(RecyclerView recyclerView) &#123; return new RecyclerViewSkeletonScreen.Builder(recyclerView); &#125; public static ViewSkeletonScreen.Builder bind(View view) &#123; return new ViewSkeletonScreen.Builder(view); &#125;&#125;我们首先来看看如何实现与普通View绑定，构造方法中传入目标View，并对shimmer动画效果设置默认的颜色，在Builder里面我们可以看到各种相关参数的设定。public Builder(View view) &#123; this.mView = view; this.mShimmerColor = ContextCompat.getColor(mView.getContext(), R.color.shimmer_color); &#125;接下来再到show的步骤，主要实现还是由ViewSkeletonScreen来实现public ViewSkeletonScreen show() &#123; ViewSkeletonScreen skeletonScreen = new ViewSkeletonScreen(this); skeletonScreen.show(); return skeletonScreen;&#125;其中ViewSkeletonScreen与绑定的RecyclerViewSkeletonScreen都实现了SkeletonScreen接口，SkeletonScreen有两个接口方法分别是 void show(); void hide(); 对于ViewSkeletonScreen.show()进入源码，这里出现一个比较重要的类ViewReplacer，等下再进行解析，通过show的源码清楚的知道逻辑：1、生成骨架效果View2、利用生成的View替换目标View。其中生成骨架效果View阶段主要还是通过LayoutInflater去加载传入mSkeletonResID @Overridepublic void show() &#123; View skeletonLoadingView = generateSkeletonLoadingView(); if (skeletonLoadingView != null) &#123; mViewReplacer.replace(skeletonLoadingView); &#125; &#125; 接下来主要讲解ViewReplacer类，其构造方法传入目标View public ViewReplacer(View sourceView) &#123; mSourceView = sourceView; mSourceViewLayoutParams = mSourceView.getLayoutParams(); mCurrentView = mSourceView; mSourceViewId = mSourceView.getId(); &#125; 其比较重要的方法有两个：replace() 和 restore() 这两个方法分别为SkeletonScreen 的show()和hide()的最终实现，首先看replace()方法，有两个方法重载，分别传入targetViewResID或者targetView，最终还是会走到replace(View targetView)中。其主要逻辑为： **1. 判断所替换的View和骨架屏效果View是否为同一个View remove掉在父布局中的目标View 将骨架屏效果View添加到目标View的父布局中** public void replace(int targetViewResID) &#123; if (mTargetViewResID == targetViewResID) &#123; return; &#125; if (init()) &#123; mTargetViewResID = targetViewResID; replace(LayoutInflater.from(mSourceView.getContext()).inflate(mTargetViewResID, mSourceParentView, false)); &#125; &#125; public void replace(View targetView) &#123; if (mCurrentView == targetView) &#123; return; &#125; if (targetView.getParent() != null) &#123; ((ViewGroup) targetView.getParent()).removeView(targetView); &#125; if (init()) &#123; mTargetView = targetView; mSourceParentView.removeView(mCurrentView); mTargetView.setId(mSourceViewId); mSourceParentView.addView(mTargetView, mSourceViewIndexInParent, mSourceViewLayoutParams); mCurrentView = mTargetView; &#125; &#125; 在执行添加到目标View的父布局中，有执行一个init方法，主要做两件事： **1. 获取目标View的父View 找到目标View在父View 中的位置索引，为之后添加骨架屏View到父View中做铺垫** private boolean init() &#123; if (mSourceParentView == null) &#123; mSourceParentView = (ViewGroup) mSourceView.getParent(); if (mSourceParentView == null) &#123; Log.e(TAG, &quot;the source view have not attach to any view&quot;); return false; &#125; int count = mSourceParentView.getChildCount(); for (int index = 0; index &lt; count; index++) &#123; if (mSourceView == mSourceParentView.getChildAt(index)) &#123; mSourceViewIndexInParent = index; break; &#125; &#125; &#125; return true; &#125; 至此对普通View的骨架屏效果实现流程已经完全梳理完成，那对于RecyclerView呢？其实两者实现逻辑差不多，主要有两个差异： 在RecyclerViewSkeletonScreen的Builder中，相比ViewSkeletonScreen多了一个adapter()方法，传入目标RecyclerView的Adapter 在show的时候对目标RecyclerView的adapter进行替换，使用骨架屏效果的adapter。hide的时候恢复为原先的Adapter 3、总结 Skeleton的原理主要是通过替换目标View和RecyclerView的Adapter 在Skeleton的使用过程中最需要关心的两个问题是：show()和hide()的时机 对于整个页面的骨架屏效果实现，个人推荐在布局中添加一个全屏的空View盖在原先内容上 注意一些异常情况下的hide()，要不然整个页面就“假死”状态了。 参考：https://juejin.im/post/5c789a4ce51d457c042d3b31","categories":[{"name":"技术文章","slug":"technology","permalink":"http://vompom.github.com/categories/technology/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://vompom.github.com/tags/Android/"}],"author":"落叶挽歌"},{"title":"Android 插件化之ClassLoader","slug":"Android-插件化之ClassLoader","date":"2019-08-26T08:47:00.000Z","updated":"2025-05-20T11:46:57.000Z","comments":true,"path":"2019/08/26/Android-插件化之ClassLoader/","permalink":"http://vompom.github.com/2019/08/26/Android-%E6%8F%92%E4%BB%B6%E5%8C%96%E4%B9%8BClassLoader/","excerpt":"","text":"插件化要解决的三个核心问题：类加载、资源加载、组件生命周期管理。 在Android插件化中其原理实际是 Java ClassLoader的原理，此博文主要对Android插件化中类加载中的DexClassLoader做总结，便于之后对Android插件化的理解学习。 Android的Dalvik虚拟机和Java虚拟机的运行原理相同都是将对应的java类加载在内存中运行。而Java虚拟机是加载class文件，也可以将一段二进制流通过defineClass方法生产Class进行加载。Dalvik虚拟机加载的dex文件。dex文件是Android对与Class文件做的优化，以便于提高手机的性能。可以想象dex为class文件的一个压缩文件。dex在Android中的加载和class在jvm中的相同都是基于双亲委派模型，都是调用ClassLoader的loadClass方法加载类。 1、DexClassLoader和PathClassLoader区别Android 也有自己的 ClassLoader，分为 DexClassLoader和PathClassLoader，这两者有什么区别和关联呢？ 阅读源码可以看到两者的构造方法分别为： public class PathClassLoader extends BaseDexClassLoader &#123; public PathClassLoader(String dexPath, ClassLoader parent) &#123; super(dexPath, null, null, parent); &#125; public PathClassLoader(String dexPath, String libraryPath, ClassLoader parent) &#123; super(dexPath, null, libraryPath, parent); &#125; &#125; public class DexClassLoader extends BaseDexClassLoader &#123; public DexClassLoader(String dexPath, String optimizedDirectory, String libraryPath, ClassLoader parent) &#123; super(dexPath, new File(optimizedDirectory), libraryPath, parent); &#125; &#125; 可以发现DexClassLoader 比 PathClassLoader 多一个参数String optimizedDirectory，那这个参数具体做什么的呢？继续查看源码我们可以知道optimizedDirectory是用来缓存我们需要加载的dex文件的，并创建一个DexFile对象，如果它为null，那么会直接使用dex文件原有的路径来创建DexFile 对象，其具体体现在如下代码区域： private static DexFile loadDexFile(File file, File optimizedDirectory) throws IOException &#123; if (optimizedDirectory == null) &#123; return new DexFile(file); &#125; else &#123; String optimizedPath = optimizedPathFor(file, optimizedDirectory); return DexFile.loadDex(file.getPath(), optimizedPath, 0); &#125; &#125; 因此两者区别在于 PathClassLoader 不能直接从 zip 包中得到 dex，因此只支持直接操作 dex 文件或者已经安装过的 apk。而 DexClassLoader 可以加载外部的 apk、jar 或 dex文件，并且会在指定的 outpath 路径存放其 dex 文件。所以在插件化中我们使用DexClassLoader来加载class的，接下来讲解DexClassLoader的用法。 2、DexClassLoader用法其构造方法为： DexClassLoader( String dexPath, String optimizedDirectory, String librarySearchPath, ClassLoader parent) dexPath:被解压的apk路径，不能为空。optimizedDirectory：解压后的.dex文件的存储路径，不能为空。这个路径强烈建议使用应用程序的私有路径，不要放到sdcard上，否则代码容易被注入攻击。libraryPath：os库的存放路径，可以为空，若有os库，必须填写。parent：父亲加载器，一般为context.getClassLoader(),使用当前上下文的类加载器。 接下来讲解具体使用流程： 1、新建一个名为plugin的project，其中新建一个Bean类，只有一个方法getName()返回一个字符串“My App”，然后对plugin这个工程打包为apk，将apk放在主工程的asser目录中。 2、构造Classloader File extractFile = getFileStreamPath(&quot;app-debug.apk&quot;); String dexPath = extractFile.getPath(); File fileRelease = getDir(&quot;dex&quot;, 0); ClassLoader classLoader = new DexClassLoader(dexPath, fileRelease.getAbsolutePath(), null, getClassLoader()); 3、利用构造好的Classloader反射调用插件类中的方法 Class mLoadClassBean; try &#123; mLoadClassBean = classLoader.loadClass(&quot;com.example.plugin.Bean&quot;); Object beanObject = mLoadClassBean.newInstance(); Method getNameMethod = mLoadClassBean.getMethod(&quot;getName&quot;); getNameMethod.setAccessible(true); String name = (String) getNameMethod.invoke(beanObject); Log.e(&quot;julis&quot;, name); &#125; catch(Exception e) &#123; e.printStackTrace(); &#125; 成功打印出结果： 参考： https://www.jianshu.com/p/4b4f1fa6633c https://www.jianshu.com/p/53aa2de20cf8 https://cloud.tencent.com/developer/article/1071815","categories":[{"name":"技术文章","slug":"technology","permalink":"http://vompom.github.com/categories/technology/"}],"tags":[{"name":"插件化","slug":"plugins","permalink":"http://vompom.github.com/tags/plugins/"}],"author":"落叶挽歌"},{"title":"忙碌中求生活-记录23岁生日","slug":"★省★忙碌中求生活","date":"2019-07-13T11:36:00.000Z","updated":"2025-05-20T11:46:57.000Z","comments":true,"path":"2019/07/13/★省★忙碌中求生活/","permalink":"http://vompom.github.com/2019/07/13/%E2%98%85%E7%9C%81%E2%98%85%E5%BF%99%E7%A2%8C%E4%B8%AD%E6%B1%82%E7%94%9F%E6%B4%BB/","excerpt":"","text":"此时周六晚七点半，刚吃了一碗自己做的番茄鸡蛋面，将浸泡了很久的银耳原料装入了电饭煲内，静待熟时。回到自己的房间，窗外不断传来来往的车轱辘声，好像在告诉我他们很忙吧。看到书桌上的日历，还沉浸在六月份，我可能也很忙吧，都忘记将它带入七月份。 来杭州一年有余，从一名大三学生暑假实习，到大四学生实习，再到应届毕业生签订转正合同，从而成为一名正式的“社会人儿”。时间过得真的很快吧，一周周一下子就没有了。进入了七月份，明显感觉比之前更忙了，或者说是因为自己身份的转变，导致肩上的责任变得不太一样了吧。因为工作节奏的改变，有时候也变得有些麻木吧，日记有时候总会忘记写，写字这件事感觉也变得有些奢侈起来，日语学习的节奏好像变得慢了起来。但是时间的脚步并不因为你的忙碌而停下来。 我最近在读《时间简史》，讲述了从认知革命到农业革命再到人类文化的融合统一再到科学革命，作者用通俗的话语讲完了整个人类历史，真的很值得阅读。其中有一章节引发了我的思考，作者认为：农业革命是史上最大的骗局。因为在长达250万里里人类都靠狩猎或者采集果实为生，而到大约一万年前全然改变，从日升到日落，人类忙着对植物的培育，一心认为这样就能得到更多的水果、谷物和肉类，使得人类生活能够变得更加容易。然而事实上是人变得越来越辛苦。人类每次决定多做一点事情（比如用锄头来耕地，而不是直接将种子撒在地里面），我们认为这样没错，这样会使我们的收成更好一点，有了更好的收成，就不用更多地去担心荒年的问题了，不用挨饿了。工作努力一点，生活也能过得好一点。不过这都是理想的状态。 人们确实工作得更努力也更辛苦，但没想到大家的孩子也更多了，人口慢慢地增加了，所得到的食物也就变得少了，生存压力也就更大了，资源也开始变得稀缺，而引发各种低问题。可是为什么他们不赶快放弃农耕回到原始的采集社会？原因在于，所有的改变都是必须点滴积累，经过许多代，才能改变社会，等到那个时候，已经没有人记得过去的生活方式和现在有什么不一样了，也没得选了。采用了农耕生活，村落的人口从100人到了110人，难道会有10个人自愿挨饿，好让其他人回到过去的美好时光？但这已经无法回头。于是人类付出了更多，但得到的却变得没有以前那样多。 我们都各自为生活变得轻松而努力，但是事实上我们过得并不轻松。人的欲望永远也满足不了，今天拥有了这个，明天还想拥有更好的。现在，我们随手可以发送一条信息，传到地球另一方，而他立马能够回你。我们确实省下了很多时间和麻烦，但生活真的更轻松了么？我们以为省了时间，然而我们其实是把生活的步调调成了过去的10倍，于是我们整天忙忙碌碌、焦躁不安。 这是原书作者对农业革命是史上最大的骗局的论证吧，我再赞同不过了。每每与我的爸妈打电话，我都会有很大的感触，他们总是在忙碌，他们每天都在拼命的挣钱，可是日子真的好起来了么？生活真的轻松了么？不久前，在家族微信群里面，我妈拍了一张我爸的照片放在群里，我爸双手背后，露出一脸笑意，背景好像是他们住那里的一个普通的建筑吧。想表现出: 你看我和你妈在玩，我们多开心啊。 当我看到这张照片的时候，我心里五谷杂粮。 一方面是 我看到我爸的头发，愈发的白了，白了大多半了。记得上一次有这感触的时候，还是我大二的时候，那次我从学校回家，他到车站来接我，我坐他后面，我发现他的白头已经有很多很多了，那时我差点哭了出来。爸妈真的老了，可我还没有给他们带来好的生活，我曾告诉他们说：等我实习你们就回家吧，不要工作了，我能养活我自己，以后也能养活你们。可是他们并不，他们还是在工作，烈日下，每每打电话跟我说太阳是有多么多大温度是有多么高，我心里都很难受。可是他们总会说一句话：“这都是为了你以后更轻松一点”。此时我却不知道该说些什么。 另一方面是 我看着我妈拍的那张照片，真的很糊，不是我妈不会拍照，也不是她眼神不好，真的是她的手机像素不好。我的爸妈，辛苦了大半辈子，其实也有很多积蓄了，虽然没有大城市里的那样多，但在老家里也算是稍微有一些钱的，可是他们却舍不得给自己多花一分钱，能将就用则用。每次电话，我都给他们讲让他们对自己好一点，我说 你们到底挣钱是为了做什么？给他们讲了很多道理，可是他们也总是会一句：“这都是为了你以后更轻松一点”。而我也只能强忍着，因为我现在还没有足够的能力，心里暗暗发誓：我会让他们过上轻松地日子。 我其实一直都在思考一个问题：人到底活在这个世界上是为了什么？科学家无法解释，这是一个哲学问题，没有人知道正确的答案。我们只是沧海中的一粟，如果掀不起波浪，那么就好好感受海的浩瀚吧。忙忙碌碌，短视频以及直播的崛起，可能真的是因为都市生活节奏变得太快，于是都在夹缝中去寻找那一丝丝快感，其实可以做的很多吧，摘自网上“试着每天自己为自己做美味的饭菜，试着经常联络一下家人好友，试着拾起丢下很久的小说，试着用心养一颗植物，试着在空气清新的清晨去跑步，试着约一下自己暗恋已久的女孩…”。看看足球比赛，看看电影，多出去走走，再忙也不要忘记生活吧。 快九点了，删删写写，也不道该放一些什么在日志上，那就这样吧。祝自己二十三岁生日快乐 记录两张此时自己二十三岁的照片，没出门没刮胡子没收拾，一张沧桑一张微笑，生活亦如此吧。 xxx.jpg ——二零一九年六月十一","categories":[{"name":"生活感想","slug":"life","permalink":"http://vompom.github.com/categories/life/"}],"tags":[{"name":"生活","slug":"life","permalink":"http://vompom.github.com/tags/life/"}],"author":"落叶挽歌"},{"title":"单例模式的设计","slug":"单例模式的设计","date":"2019-07-09T01:56:00.000Z","updated":"2025-05-20T11:46:57.000Z","comments":true,"path":"2019/07/09/单例模式的设计/","permalink":"http://vompom.github.com/2019/07/09/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%AE%BE%E8%AE%A1/","excerpt":"","text":"原文回答于知乎(如何把一段简单的代码变复杂？ - 落叶挽歌的回答) 我们都知道单例模式很简单，大概是这样： //单线程单例模式实现public class Singleton &#123; private static Singleton instance=null; public static Singleton getInstance() &#123; if(null==instance)&#123; instance = new Singleton(); &#125; return instance; &#125;&#125; 但是呢，在多线程条件下getInstance()并不是一个原子操作。由于代码没有使用任何同步机制，因此该线程可能会出现线程交错的情形：在instance还是null的时候，如果两个线程同时执行到 if(null==instance)那么会创建两个实例，从而违背了初衷。于是通过简单加锁来解决这种问题：//简单加锁实现单例模式public class Singleton &#123; private static Singleton instance=null; public static Singleton getInstance() &#123; synchronized (Singleton.class)&#123;//加入synchronized同步 if(null==instance)&#123; instance = new Singleton(); &#125; return instance; &#125; &#125;&#125;这种方式实现单例模式固然安全，但意味着每次调用 getInstance()都会申请锁，为了避免开销，我们想到了另一种办法：//基于双重检查锁定的错误单例模式实现public class Singleton &#123; private static Singleton instance=null; public static Singleton getInstance() &#123; if(null==instance)&#123;//先检查是否为null，再执行之上的代码 synchronized (Singleton.class)&#123; if(null==instance)&#123; instance = new Singleton(); &#125; &#125; &#125; return instance; &#125;&#125;通过这种方法，虽然第一次检查对变量instance的访问没有加锁从而使竞态仍然可能存在，它似乎避免了锁的开销又保障了线程的安全。然后对 instance = new Singleton();进行伪代码独立子操作：obj=allocate(Singleton.class);//1、分配对象所需的存储空间invokeConstructor(obj);//2、初始化obj的引用对象instance=obj;//3、将对象引用写入共享变量由于重排序的规则，临界区内的操作可以再临界区内重排序，因此JIT编译器可能将上述子操作重排序为：1-&gt;3-&gt;2，即在初始化对象之前将对象引用写入实例变量instace。由于锁对有序性的保障是有条件的，而操作1读取intance变量的时候并没有加锁，因此重排序是对1操作是有影响的：该线程可能看到一个未初始化（或者为初始化完毕）的实例，即intance不为null。于是该线程直接就直接返回这个instance变量所引用的实例，而实例可能是未初始化完毕的，这就是可能导致程序出错。明白问题的原因之后，解决方法也不难想到了：只需将instance变量加入volatile修饰则可。于是代码变成：//基于双重检查锁定的正确单例模式实现public class Singleton &#123; private static volatile Singleton instance=null;//加入volatile修饰 public static Singleton getInstance() &#123; if(null==instance)&#123; synchronized (Singleton.class)&#123; if(null==instance)&#123; instance = new Singleton(); &#125; &#125; &#125; return instance; &#125;&#125;到此为止，才正确实现安全的“单例模式”。 参考：《黄文海-Java多线程编程实战指南（核心篇）》","categories":[{"name":"技术文章","slug":"technology","permalink":"http://vompom.github.com/categories/technology/"}],"tags":[{"name":"设计模式","slug":"design","permalink":"http://vompom.github.com/tags/design/"}],"author":"落叶挽歌"},{"title":"Android监听截屏事件之媒体读取的探索","slug":"Android监听截屏事件之媒体读取的探索","date":"2019-07-02T09:58:00.000Z","updated":"2025-05-20T11:46:57.000Z","comments":true,"path":"2019/07/02/Android监听截屏事件之媒体读取的探索/","permalink":"http://vompom.github.com/2019/07/02/Android%E7%9B%91%E5%90%AC%E6%88%AA%E5%B1%8F%E4%BA%8B%E4%BB%B6%E4%B9%8B%E5%AA%92%E4%BD%93%E8%AF%BB%E5%8F%96%E7%9A%84%E6%8E%A2%E7%B4%A2/","excerpt":"","text":"最近做了一个需求：监听用户截屏，然后生成相关海报。参考了Android 截屏事件监听的文章，大致思路是： 1、利用ContentObserver用来监听指定Uri的所有资源变化,当媒体库中有相关图片新增的时候，则发送相关的通知。 2、得到回调的Uri后，借助ContentResolver在媒体数据库中查询最后一条数据 3、对数据做一些过滤。比如短时间重复截屏的情况以及其他App也插入了媒体文件等情况做处理。 不过有一些适配性的问题： 1、截屏后读取文件数据库后获取到件的绝对路径后，利用“screenshot”等关键字判断是否是截屏图片，并不能适配所有手机截屏的命名规则，以及其他应用同时间产生带有“screenshot”等关键词的文件也会有问题。 2、在某些型号手机中(现遇到Vivo)从数据库中读取的文件并不是获取到的最新的截屏文件，而且其他目录的文件，这里就有些难以理解了，所以今天取探究一下媒体数据库的读取。 其中ContentObserver如下代码所示：/** * 媒体内容观察者(观察媒体数据库的改变) */ private class MediaContentObserver extends ContentObserver &#123; private Uri mContentUri; public MediaContentObserver(Uri contentUri, Handler handler) &#123; super(handler); mContentUri = contentUri; &#125; [@Override](https://my.oschina.net/u/1162528) public void onChange(boolean selfChange) &#123; super.onChange(selfChange); handleMediaContentChange(mContentUri); &#125; &#125; 其中获取最后一次更新的媒体文件时的代码(为便于查看 删除了判空处理代码)： /** * 处理媒体数据库的内容改变 */ private void handleMediaContentChange(Uri contentUri) &#123; Cursor cursor = null; /** 读取媒体数据库时需要读取的列 */ private static final String[] MEDIA_PROJECTIONS = &#123; MediaStore.Images.ImageColumns.DATA, MediaStore.Images.ImageColumns.DATE_TAKEN &#125;; try &#123; // 数据改变时查询数据库中最后加入的一条数据 cursor = mContext.getContentResolver().query( contentUri, MEDIA_PROJECTIONS, null, null, MediaStore.Images.ImageColumns.DATE_ADDED + &quot; desc limit 1&quot; ); // 获取各列的索引 int dataIndex = cursor.getColumnIndex(MediaStore.Images.ImageColumns.DATA); int dateTakenIndex = cursor.getColumnIndex(MediaStore.Images.ImageColumns.DATE_TAKEN); // 获取行数据 String data = cursor.getString(dataIndex); long dateTaken = cursor.getLong(dateTakenIndex); // 处理获取到的第一行数据 handleMediaRowData(data, dateTaken);&#125;这次的目的主要探究的是从数据库获取相关信息的过程 1、Android 的多媒体如何存储？ Android的多媒体文件主要存储在 /data/data/com.android.providers.media/databases 目录下，该目录下有连个db文件： 内部存储数据库文件：internal.db 存储卡数据库：external-XXXX.db 媒体文件的操作主要是围绕着这两个数据库来进行，这两个数据库的结构是一样的。 这两个数据库包含这些表：album_art 、audio 、search 、album_info 、audio_genres、 searchhelpertitle、albums、 audio_genres_map、 thumbnails、android_metadata、 audio_meta、 video、artist_info 、audio_playlists 、videothumbnails、artists 、audio_playlists_map、artists_albums_map 、images 2、表的结构对于Images表：主要存储images信息。表结构如下：CREATE TABLE images ( _id INTEGER PRIMARY KEY, _data TEXT, _size INTEGER, _display_name TEXT, mime_type TEXT, title TEXT, date_added INTEGER, date_modified INTEGER, description TEXT, picasa_id TEXT, isprivate INTEGER, latitude DOUBLE, longitude DOUBLE, datetaken INTEGER, orientation INTEGER, mini_thumb_magic INTEGER, bucket_id TEXT, bucket_display_name TEXT ); 各字段所表示意思，如图所示： 图片来自：Android MediaProvider数据库模式说明 所以在截屏监听数据的时候所读取的数据库返回值，分别为： _data :图片据对路径 datetaken：取子EXIF照片拍摄事件，空的话为文件修改时间 private static final String[] MEDIA_PROJECTIONS = &#123; MediaStore.Images.ImageColumns.DATA, MediaStore.Images.ImageColumns.DATE_TAKEN &#125;; 在查询过程中构造的数据库代码为： public final Cursor query (Uri uri, String[] projection, String selection, String[] selectionArgs, String sortOrder) `其中对应的构造参数官方解释为： uri The URI, using the content:// scheme, for the content to retrieve. projection A list of which columns to return. Passing null will return all columns, which is inefficient. selection A filter declaring which rows to return, formatted as an SQL WHERE clause (excluding the WHERE itself). Passing null will return all rows for the given URI. selectionArgs You may include ?s in selection, which will be replaced by the values from selectionArgs, in the order that they appear in the selection. The values will be bound as Strings. sortOrder How to order the rows, formatted as an SQL ORDER BY clause (excluding the ORDER BY itself). Passing null will use the default sort order, which may be unordered. 所以参数依次为：所要查找的目标、所要的返回值、条件限制(类似sql中where)、匹配项、排序规则 所以这里的查询就显而易见了：获取最新图片数据库下data和datatoken列的数据cursor = mContext.getContentResolver().query( contentUri, MEDIA_PROJECTIONS, null, null, MediaStore.Images.ImageColumns.DATE_ADDED + &quot; desc limit 1&quot; );然而…并不能解释vivo手机为什么查找出来不是最新截图的图片的问题","categories":[{"name":"技术文章","slug":"technology","permalink":"http://vompom.github.com/categories/technology/"}],"tags":[{"name":"安卓","slug":"Android","permalink":"http://vompom.github.com/tags/Android/"}],"author":"落叶挽歌"},{"title":"Android在子线程中创建Handler为什么会抛出异常？","slug":"Android在子线程中创建Handler为什么会抛出异常？","date":"2019-06-24T09:27:00.000Z","updated":"2025-05-20T11:46:57.000Z","comments":true,"path":"2019/06/24/Android在子线程中创建Handler为什么会抛出异常？/","permalink":"http://vompom.github.com/2019/06/24/Android%E5%9C%A8%E5%AD%90%E7%BA%BF%E7%A8%8B%E4%B8%AD%E5%88%9B%E5%BB%BAHandler%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E6%8A%9B%E5%87%BA%E5%BC%82%E5%B8%B8%EF%BC%9F/","excerpt":"","text":"复习一下消息机制，如下代码：new Thread() &#123; Handler handler = null; [@Override](https://my.oschina.net/u/1162528) public void run() &#123; handler = new Handler(); &#125; &#125;.start();如果执行会抛出异常： Can’t create handler inside thread Thread.currentThread() that has not called Looper.prepare() 这是为什么呢？ 我们进入Handler的构造方法 public Handler(Callback callback, boolean async) &#123; if (FIND_POTENTIAL_LEAKS) &#123; final Class&lt;? extends Handler&gt; klass = getClass(); if ((klass.isAnonymousClass() || klass.isMemberClass() || klass.isLocalClass()) &amp;&amp; (klass.getModifiers() &amp; Modifier.STATIC) == 0) &#123; Log.w(TAG, &quot;The following Handler class should be static or leaks might occur: &quot; + klass.getCanonicalName()); &#125; &#125; mLooper = Looper.myLooper(); if (mLooper == null) &#123; throw new RuntimeException( &quot;Can&#x27;t create handler inside thread &quot; + Thread.currentThread() + &quot; that has not called Looper.prepare()&quot;); &#125; mQueue = mLooper.mQueue; mCallback = callback; mAsynchronous = async;&#125;从上面的代码我们很清新的可以知道mLooper 为null,那么就会抛出这样的异常，那么mLooper 为什么会为空呢？这是因为在线程中的Looper还未被创建，所以在Looper.myLooper()中sThreadLocal.get()就会返回null。 我们知道 Handler的作用是处理消息，将消息传递给MessageQueue，而MessageQueue存在于Looper中，如果没有Looper那么就没有MessageQueue，所以创建Handler时，Looper不能够为空。 所以以上代码可以进行一个修改： private void test() &#123; new Thread() &#123; Handler handler = null; [@Override](https://my.oschina.net/u/1162528) public void run() &#123; Looper.prepare(); handler = new Handler(); Looper.loop(); &#125; &#125;.start();&#125; 其中 Looper.prepare();为当前线程创建Looper并绑定在ThreadLocal中 Looper.loop();执行消息循环，这样子 Handler就能够正常工作了。","categories":[{"name":"技术文章","slug":"technology","permalink":"http://vompom.github.com/categories/technology/"}],"tags":[{"name":"安卓","slug":"Android","permalink":"http://vompom.github.com/tags/Android/"}],"author":"落叶挽歌"},{"title":"写在我即将毕业旅行前","slug":"写在毕业之际旅行前","date":"2019-06-04T11:24:00.000Z","updated":"2025-05-20T11:46:57.000Z","comments":true,"path":"2019/06/04/写在毕业之际旅行前/","permalink":"http://vompom.github.com/2019/06/04/%E5%86%99%E5%9C%A8%E6%AF%95%E4%B8%9A%E4%B9%8B%E9%99%85%E6%97%85%E8%A1%8C%E5%89%8D/","excerpt":"","text":"忙碌的一天，又要到下班的时候了，一天好似很忙，其实回过头来仔细想想，一天好像并没有做太多的事情，然而确实是这样子度过一天了，就像我们的青春岁月，看样子并没有经历什么，但它就这样匆匆过去了，亦忧伤，亦憧憬。 还有两周就要回校参加毕业典礼了，向公司请了十天假，算上端午以及周末，大概有半个多月属于自己的日子吧，也算是大学最后一点还是以学生身份存在的时间了。早在几个月前我都在筹划这次出去游玩了，因为我想出去走走，想出去看看。纵观整个大学生涯，自己也算是去了不少地方了，屋子里车票、机票已经收纳了一沓了。看着每一张车票的起点与终点以及行程时间，还能想起那时候发生过的事，或许有些事还在记忆里面，或许可能存在我的日记里面，或许我什么也记不得了。 2015年8月15日 绵阳-上海：距离大学开学还有一个月了，父亲陪我度过了整个高三，待我拿到通知书后，我与父亲来到上海。父亲是一个节俭的人，买了绿皮车，将近两千多公里的路程，三十多个小时的行程，脚没有办法舒展开，时间长了别的难受。当看到那些没有座位的那些人要不停地给过路人让路的时候，我觉得自己也挺幸运的，至少我还有一个属于自己的位置，不需要为别人让路。在这煎熬的行程中，我并没有去抱怨，我只是一直在想，我以后一定要努力，一定不会让我和我父亲再受这样的遭遇。 2015年9月14日 上海-温州：马上就要大学开学了。离开了父母，将一个人去面对新的生活了，路过杭州的时候，车窗外一片开阔的平原，让我看到极具江南特色的景象：鳞次栉比的房屋伴着小河流，来来往往的车辆川流不息，很憧憬那样“小桥流水人家”的生活，这大概是对杭州的第一印象吧。 2016年1月22日 温州-成都：大学寒假第一次回家，运气很好，我和同学抢到了卧铺票，有了一个较舒服的乘车环境。与我通行的还有很多大学川籍同学，因此一路上也变得并不孤独，时而和他们“摆龙门阵”，累了就回床铺上面去休息一下，我记得我当时带了一本《浪潮之巅》。 2017年7月18日 温州-太原：第一次坐飞机，带着许多憧憬出发，但让人失望的是我错过了那一天的飞机，原本安排的好好的行程，一下子把我的计划打乱了。这时候我真的很迷茫，我不知道该去哪里，我也不知道该做什么，整个脑子是一片空白，在街上走走，最后回学校见到了精神支柱。然后去了太原平遥古城，喜欢太原老大爷那种街边悠然下着象棋的生活。 2017年7月10日 嘉兴-福州：又是一次暑假，我去嘉兴看望我爸，然后我爸他们提议去福州找我的大姑爷家玩，这一次我和我的父亲快吵了一架，因为我想让他买一张动车票，可父亲执着的只买绿皮车票，他觉得能节约钱，可是我觉得时间才是最重要的，那时候我没有一点收入，我说服不了他，绿皮车从晚上八点开到第二天早上八点，整个一晚我没有怎么睡，感慨太多，我也告诉我自己要努力。当时也写过一篇随笔：2017年710随笔 于嘉兴-福州列车 2017年9月02日 温州-杭州：这一次算是第一次以异地恋的身份去见了那时喜欢的人，一路忐忑。记得那时候带的是一本《小王子》，但是感觉没有看太懂，好像过了天真的年纪，已经看不太明白小王子的天真了。 2018年8月23日 杭州-太原： 或许真的是和太原有缘分，时隔一年再次去太原，这次我并没有错过，过了一年，变得成熟些了，这时候我已经在参加实习了。这次是代表整个学校唯一一只队伍进电子商务全国总决赛，压力与动力并存吧。 2019年2月14日 德阳-成都：这是最近一次从家出发去杭州在成都中转，在德阳站中因为高铁晚点，我遇到了一个女孩子，或许这是读大学以后认识的第一个非本大学的四川女孩子吧，或许是缘分，我和她是同一辆车，在德阳到成都只有短短半个小时的行车时间，居然车晚点将近两个小时，于是和她就聊啊、聊啊，从小学说到初中高中，从高中说到大学，再从大学说到实习。原来她也和我一样是大四的学生，原来我和她大学同学是初中高中同学，真的是缘分吧。第一次是多么的希望列车晚点的时间能够再长一点。只可惜，我本将心照明月，奈何明月照沟渠。 …… 2019年6月10日 杭州-青岛、烟台、威海、大连？ 或许是在被公司同事的鼓励下：现在有时间多出去玩玩吧，实习一天也没有多少钱，等以后正式工作了，有钱也没有时间了，趁现在，多出去走走吧。感谢芳姐姐对我的支助，让我有机会去计划这次旅行。 这一次，我是第一次一个人的旅行，我想在这炎热的夏天里，走出屋子，踏上行程。去坐一次轮渡、我还想再使用学生证享受一次学生特权、然后去看看海、去吹吹风、去看看更多的天空、去认识的人并说：“很高兴认识你”。也算是对整个大学青春岁月画上一个句号吧。那接下来的一路上又会发生什么故事呢？ 最后以王小波的《黄金时代》结尾吧：那一天我二十一岁，在我一生的黄金时代，我有好多奢望。我想爱，想吃，还想在一瞬间变成天上半明半暗的云，后来我才知道，生活就是个缓慢受锤的过程，人一天天老下去，奢望也一天天消逝，最后变得像挨了锤的牛一样。可是我过二十一岁生日时没有预见到这一点。我觉得自己会永远生猛下去，什么也锤不了我。 我还年轻，我还可以到处走走，我还有很多想要去憧憬的、盼望的…… —于2019.06.04 7:24 即将下班回家","categories":[{"name":"生活感想","slug":"life","permalink":"http://vompom.github.com/categories/life/"}],"tags":[{"name":"旅行","slug":"travel","permalink":"http://vompom.github.com/tags/travel/"}],"author":"落叶挽歌"},{"title":"95后，毕业半年，你过得好吗？","slug":"95后的你们毕业半年过得还好么？","date":"2019-05-20T01:42:00.000Z","updated":"2025-05-20T11:46:57.000Z","comments":true,"path":"2019/05/20/95后的你们毕业半年过得还好么？/","permalink":"http://vompom.github.com/2019/05/20/95%E5%90%8E%E7%9A%84%E4%BD%A0%E4%BB%AC%E6%AF%95%E4%B8%9A%E5%8D%8A%E5%B9%B4%E8%BF%87%E5%BE%97%E8%BF%98%E5%A5%BD%E4%B9%88%EF%BC%9F/","excerpt":"","text":"原帖：https://www.zhihu.com/question/307640916/answer/68674849395后，毕业半年，你过得好吗？亲爱的95后，毕业两年，你过得怎么样了？充实或是空虚，甜蜜还是苦涩，热爱生活还是生无可恋，期待写下你的故事。 96年 刚参加完学校的毕业答辩回来，离毕业也不远了吧。从去年暑假开始就在杭州实习了，最开始是做php后端，后来转到了安卓开发。实习了差不多快一年了，就要成“资深实习生”了。说实话我感觉我过得很充实吧，依然热爱生活。实习期间租房+伙食费+路费，如果不干别的什么事，一个月请假天数在两三天的话，每个月的生活是过得还算是比较舒服的，不太愁。实习之后就第一个月问家里要了一下房租和押金，以及驾校的学费。可以说完全独立了吧。拿到公司的offer是10几k，还是蛮期待拿毕业证转正的时候吧：96年 刚参加完学校的毕业答辩回来，离毕业也不远了吧。从去年暑假开始就在杭州实习了，最开始是做php后端，后来转到了安卓开发。实习了差不多快一年了，就要成“资深实习生”了。说实话我感觉我过得很充实吧，依然热爱生活。实习期间租房+伙食费+路费，如果不干别的什么事，一个月请假天数在两三天的话，每个月的生活是过得还算是比较舒服的，不太愁。实习之后就第一个月问家里要了一下房租和押金，以及驾校的学费。可以说完全独立了吧。拿到公司的offer是10几k，还是蛮期待拿毕业证转正的时候吧。 在这里我好想讲讲近一年的实习生活，过得日子也算是充满酸甜苦辣吧。从刚开始从公司实习开始讲吧：当时的我好像什么都会，php也会、python、java、安卓啥都会一样，经过被阿里面试打击后，可以看此帖子：https://www.zhihu.com/question/268713348/answer/352195054 我稍微收敛了一点了吧，最后进入了杭州一家互联网公司，刚开始是干php的，干了一个多月一点，感觉并没有学到多少东西，做的业务比较多，因为我属于“实习”的状态吧，安排的任务也比较少，所以每天的日子过得也很“悠闲”，每天干完就回家了，大概下午六点多就走了……这前面的php实习期间算是伏笔吧。之后由于刚好公司内部有个安卓实习的位置，好像是没有招到合适的吧，最开始面试的时候说了我什么都会，所以有幸被调到了安卓组里面。我发现好像每天的需求做起来还是那么简单，所以每天依然走得特别早吧，还有点沾沾自喜的样子，然而回到家并没有继续学习相关知识，要不就和女朋友（ broken up.）漫步钱塘江边，要么就是回到家里写写字看看其他类型的书，反正过得很舒服吧。 直到有一天我被“伤自尊”了，一度自我感觉良好的我被组内的同事叫去看一个问题，我看了很久也看不出来，因为很多Java基础我都有些快忘了吧，基础不太扎实，我对代码的深度理解也有问题，我只停留在用的阶段，我不懂其原理，我只会使用，我连他们的源码都没有看过。 后来被他鞭策道：你现在确实很厉害，比我当时刚出大学的时候厉害多了，但是我觉得我一点比你做的好，那就是我一直坚持在学习。你每天回去那么早没有学习，你在做什么？你现在对你自己的定位有些问题，现在你虽然觉得这些需求能做，但是你知道这些需求都是最简单的，工作难度都是最低的，我们为什么不把那些高难的任务给你？是因为你现在能力还不够，现在给你简单任务就是想让你多一些时间去学习，让你尽早能够跟上团队的步伐。实话给你说：你很菜！你真的很菜……你师傅可能不太好给你讲所以我才给你讲这些，如果你现在的状态，你永远只能做那些最简单的任务，可能连之后的校招offer都拿不到，就算侥幸8月份能拿到校招offer，也许你之后能侥幸转正，但是你不坚持学习的话迟早会被行业淘汰…… 这位前辈的话一直在我脑海里面印象深刻，我是一个不服输的人，在被鞭策后，我真的不服气，我也不认输，当时他叫我周末会去看一看”EventBus”的源码，然后周一向他汇报一下看的结果。周末连续两天都在看其源码，说实话看起来真的很痛苦，因为自己以前都是直接用，不会去关心它内部的逻辑，但是依然坚持看了两天，做了很多笔记，把它内部实现逻辑也搞明白了。忐忑不安地等到了周一，我向他汇报，我给他讲述了内部原理以及源码解读，他给我提了几个问题，我答上了一半多一点，我正沾沾自喜时，他给我说：如果给你这次评价满分一百分的话，我最多给你打20分。 ！！！！20分，我的天！我当时一下子整个人就不好了，甚至都想去反驳他了，可是他之后给我讲得东西，让我打消了这个念头，我确实菜。我确实认识到了自己的不足，对源代码的解读真的还不够，Java基础也不太扎实，包括我的师傅也这样认为，我是一个不服输的人，不服气。我向我师傅请教了，大概给自己定了一个短期的学习计划：先把Java基础过一遍，再过一遍Android基础过一把，再开始去理解安卓深度的东西。从此开始，我感觉我开始暴走了。 我每天都背一两本书回去学习，在地铁上有时候位置空我也会拿出来继续学习，偶尔还是会找女朋友去玩，但是当我11点钟回到家，我还是会拿出书来继续学习。然后第二天我会和我的师傅讲我昨天学了什么，然后讲出我的疑问。我的师傅真的是一个很耐心的人，他会给我仔细地讲解，包括平时的问题，如果我向组内请教问：1+1等于几？ 他们会告诉我等于2。然而我的师傅会告诉我 加法口诀表，甚至是乘法口诀表。那时候我每天都不曾忘记学习，每天都会去研究，那一段时间我真的压力很大，经常性的失眠，心跳特别快，后面也去看过一次医生说是“心悸”。当然那也是在压力下人做出的一些极端反应，所幸的是我坚持了过来。八月中，HR把我叫了过去，我还以为她又要批判我了，因为最开始被团队的人给鞭策了之后，她也找过我谈话了：你如果还继续现在的状态，可能之后的校招offer都不会发给你。这一次不一样了，她给我讲了我转正后的待遇，什么期权还要公积金啥啥啥的，然后讲了工资多少多少，其实工资是有点超乎我预期的。她讲完之后，我真的笑了，真的开心了，我忍不住笑了起来。她问：开心吗？我一直点头。或许这是对努力之后最好的回报吧！那一刻真的，心里有太多说不出来，打心地的开心。 拿到校招offer我还是坚持学习吧，只是强度没有之前那样强了，但是依然坚持每天要学习。现在我觉得每天每周过得生活都特别的充实吧，我们不是996。公司9点上班，弹性打卡9个小时，也就是说早上9点钟打卡，下午6点钟就可以走了，但是大部分人并不是6点钟走。现在自己每天早上都会比较期盼去公司，因为每次做需求，我都并不把他当做我的“工作”在做，而我认为那是我的兴趣爱好。我喜欢敲代码的感觉，我喜欢那种自己去设计思路想法，最后打磨出来产品的过程。而我们做出的成果会是被几百万用户所使用，肩上也有一种责任感吧。然后也带来了成就感，比如公司的宣传片或者展示公告大牌上面印着app的应用界面图，会看到里面有一部分是我做得，我是多么的开心呀。一次室友的朋友过来了，我们聊着天，后来聊到它妈妈也在用我们做得app，它给我说它妈妈怎么怎么这个App，我说啊，这里就是我做的呀。哇！厉害咯。我对工作保持乐观态度，因为我可以向厉害的前辈们请教问题，向他们学习，我每天都感觉自己有收获，所以在公司让我感觉过得很开心，没有太大的压力，每天都在进步。 当然回到家了，我也有该做的事，我也有我的兴趣，大概每天7.30左右下班回家，回到家快8.30了。我也有自己追求，我在学日语，打算能在明年去一趟日本，感受一下不同的文化。日语学累了，我会继续学习相关专业的书籍，或者写写字，我比较喜欢写字，虽然没有很飘逸炫酷，但是我觉得写完之后看起来特别的舒服，这也算是一种成就感把，大概学到10.30收拾洗漱，大概11点左右上床了，我会继续看一些相关的书籍，比如最近在看《红楼梦》，厚厚的一本，渐渐地书签也跑到了中间的位置吧。 至于周末，我可能比较放松吧，周末我会学着去做做菜，不再想吃外卖了，真的难吃且贵。 有时候也会去绿城主场看看绿城踢球吧，虽然心里支持的四川队，但是远在他乡没有办法了。 最后附上自己毕业答辩后拍的照片，算是对自己充实的大学生活的怀念吧。 总之，我觉得自己每天都过得很充实吧，很热爱自己的生活。 愿每一个你们的生活都过得幸福。","categories":[{"name":"思考总结","slug":"thinking","permalink":"http://vompom.github.com/categories/thinking/"}],"tags":[{"name":"知乎","slug":"zhihu","permalink":"http://vompom.github.com/tags/zhihu/"}],"author":"落叶挽歌"},{"title":"基于Volley框架的返回数据的范型处理","slug":"基于Volley框架的返回数据的范型处理","date":"2019-05-13T06:56:00.000Z","updated":"2025-05-20T11:46:57.000Z","comments":true,"path":"2019/05/13/基于Volley框架的返回数据的范型处理/","permalink":"http://vompom.github.com/2019/05/13/%E5%9F%BA%E4%BA%8EVolley%E6%A1%86%E6%9E%B6%E7%9A%84%E8%BF%94%E5%9B%9E%E6%95%B0%E6%8D%AE%E7%9A%84%E8%8C%83%E5%9E%8B%E5%A4%84%E7%90%86/","excerpt":"","text":"在平时最普通的Volley的网络请求中，我们StringRequest是这样请求网络数据的：StringRequest stringRequest = new StringRequest(&quot;http://www.baidu.com&quot;, new Response.Listener&lt;String&gt;() &#123; @Override public void onResponse(String response) &#123; Log.d(&quot;TAG&quot;, response); &#125; &#125;, new Response.ErrorListener() &#123; @Override public void onErrorResponse(VolleyError error) &#123; Log.e(&quot;TAG&quot;, error.getMessage(), error); &#125;注意在onResponse的时候是拿到的string类型，拿到string后对其再进行相关的解析，我们是否是可以对其直接封装然后拿到具体想要类型的model数据结构呢？所以对其网络请求架构进行一次封装，到达如下效果：GetGoodDetailByGidRequest getGoodDetailByGidRequest = new GetGoodDetailByGidRequest(mCouponId, new RequestListener&lt;List&lt;CouponModel&gt;&gt;() &#123; @Override public void onSuccess(List&lt;CouponModel&gt; result) &#123; &#125; @Override public void onError(Exception e) &#123; e.printStackTrace(); stopLoadingDialog(); &#125; &#125;);这里我们在构造Request的时候指定了返回数据的类型，这样的话就方便了我们在写业务的时候直接使用解析好的数据结构，具体如何做到的呢？ 一、让每个Request基于一个带有范型请求类public abstract class BaseApiRequest&lt;T&gt; 这里的T就是目标请求期望的model类在具体实现的时候继承基类，并指定返回类型，下面是一个例子：public class GetGoodDetailByGidRequest extends BaseApiRequest&lt;List&lt;CouponModel&gt;&gt; &#123; public static final String url = CURL.GoodDetailURL; public GetGoodDetailByGidRequest(String goodId, RequestListener&lt;List&lt;CouponModel&gt;&gt; requestListener) &#123; super(requestListener); this.mUrlParams.put(&quot;id&quot;, goodId); &#125; @Override public String getBaseUrl() &#123; return url; &#125;&#125;二、在基类中构造网络请求protected StringRequest getStringRequest() &#123; return new StringRequest(requestMethod, getRequestUrl(), response -&gt; parseJson(response), error -&gt; requestListener.onError(error)) &#123; @Override protected Map&lt;String, String&gt; getParams() &#123; return mEntityParams; &#125; &#125;; &#125;在此处实现可以看到Request在基类中进行，然后分别处理返回结果 三、对返回结果进行解析private void parseJson(String response) &#123; int responseCode = 0; int errorCode = 400; try &#123; JSONObject jsonObject = new JSONObject(response); String resultString = jsonObject.getString(&quot;data&quot;); if (jsonObject.has(&quot;code&quot;)) &#123; responseCode = jsonObject.getInt(&quot;code&quot;); &#125; if (jsonObject.has(&quot;error&quot;)) &#123; errorCode = jsonObject.getInt(&quot;error&quot;); &#125; if (responseCode == 200 || errorCode == 0) &#123; if (!TextUtils.isEmpty(response)) &#123; Type type = getTType(requestListener.getClass()); //泛型是实体或者List等类型 T t = JsonUtils.fromJson(resultString, type); requestListener.onSuccess(t); return; &#125; ToastUtils.showToast(&quot;Data is empty!&quot;); &#125; ToastUtils.showToast(&quot;Response code is error.&quot;); requestListener.onError(new ParseError()); &#125; catch (JSONException e) &#123; ToastUtils.showToast(e.toString()); e.printStackTrace(); &#125; &#125;这里是最关键的一步，由于和后端约定好相关返回字段，那么只需要解析字段中目标model的数据，其中比较重要的是这段代码 Type type = getTType(requestListener.getClass()); //泛型是实体或者List等类型 T t = JsonUtils.fromJson(resultString, type); requestListener.onSuccess(t);``` 通过封装好的 JsonUtils将String转化为对应的model类型，我们知道json转实体对象的时候，需要指明其类type，那这里的type是如何获取到的呢？其中getTType ()的具体实现为： ```java public static Type getTType(Class&lt;?&gt; clazz) &#123; //以Type的形式返回本类直接实现的接口. Type[] types = clazz.getGenericInterfaces(); clazz.getInterfaces(); if (types.length &gt; 0) &#123; //返回表示此类型实际类型参数的 Type 对象的数组 Type[] interfacesTypes = ((ParameterizedType) types[0]).getActualTypeArguments(); return interfacesTypes[0]; &#125; return null; &#125;通过次方法能够获取到请求实现中所指明的请求类型，其中getGenericInterfaces等相关原理可以阅读：https://my.oschina.net/617669559/blog/3012228 所以对于public class GetGoodDetailByGidRequest extends BaseApiRequest&lt;List&lt;CouponModel&gt;&gt;那么获取到的就是List类型 四、通过Listener回调相关解析结果 拿到解析好的result并回调给构造Request方法中的listener使用T t = JsonUtils.fromJson(resultString, type);requestListener.onSuccess(t); 这样对整个网络请求后的返回数据直接进行解析方便多了。 总结： 1、本文最主要是对基本Request类进行改造，以达到不需要每次重复写解析返回的String数据 2、在获取目标的类的类型的时候，主要是去获取基类中的“T”类型 3、设计不仅适用用Volley同样适用于其他类似的网络请求框架","categories":[{"name":"技术文章","slug":"technology","permalink":"http://vompom.github.com/categories/technology/"}],"tags":[{"name":"安卓","slug":"Android","permalink":"http://vompom.github.com/tags/Android/"}],"author":"落叶挽歌"},{"title":"Java反射中getGenericInterfaces和getInterfaces的解读","slug":"My-Java反射中getGenericInterfaces和getInterfaces的解读","date":"2019-05-05T11:12:00.000Z","updated":"2025-05-20T11:46:57.000Z","comments":true,"path":"2019/05/05/My-Java反射中getGenericInterfaces和getInterfaces的解读/","permalink":"http://vompom.github.com/2019/05/05/My-Java%E5%8F%8D%E5%B0%84%E4%B8%ADgetGenericInterfaces%E5%92%8CgetInterfaces%E7%9A%84%E8%A7%A3%E8%AF%BB/","excerpt":"","text":"今天在做解析网络请求后得到的数据的转化的时候用到了：getGenericInterfaces这个方法。 /** * 获取回调接口中 T 的具体类型 * * @param clazz * @return */ public static Type getTType(Class clazz) &#123; //以Type的形式返回本类直接实现的接口. Type[] types = clazz.getGenericInterfaces(); if (types.length &gt; 0) &#123; //返回表示此类型实际类型参数的 Type 对象的数组 Type[] interfacesTypes = ((ParameterizedType) types[0]).getActualTypeArguments(); return interfacesTypes[0]; &#125; return null;&#125; 其中回调接口为：new RequestListener &lt;&gt; () &#123; @Override public void onSuccess (List result)&#123; &#125; //在解析数据的时候这样操作，目的是为了对所有返回的数据进行数据转化为所指定的类型： Type type = getTType(requestListener.getClass()); //泛型是实体或者List等类型 T t = JsonUtils.fromJson(resultString, type); requestListener.onSuccess(t);&#125;类RequestListener为：public interface RequestListener &#123; void onSuccess(T result); void onError(Exception e);&#125;使用Gson进行json的解析，T fromJson(String json, Type typeOfT);那么怎么才能获取到RequestListener中的的类型呢？于是我们从接口获取参数化类型处理。 官方文档解释 getGenericInterfaces： Returns the {@code Type}s representing the interfaces directly implemented by the class or interface represented by this object.释意：返回表示由此对象表示的类或接口直接实现的接口的{@code Type}。 getInterfaces： Determines the interfaces implemented by the class or interface represented by this object. 释意：返回由此对象表示的类或接口实现的接口。 从解释上面来看出来了，差异在于“接口实现的接口的Type”，接下来用具体示例来解释区别private class Food&#123; String foodName;&#125;private interface Eat&#123; void eat(String things);&#125;private interface Run&#123; void run();&#125;private class Dog implements Eat,Run&#123; @Override public void run() &#123; &#125; @Override public void eat(String things) &#123; &#125;&#125;private void main() &#123; Class clazz = Dog.class; Type[] genericInterfaces = clazz.getGenericInterfaces(); Class[] interfaces = clazz.getInterfaces();&#125; 运行结果 我们可以看到，clazz.getGenericInterfaces()与clazz.getInterfaces()并没有任何差异。因为 并没有：“实现的接口的Type” 接下来看另一段代码,我们对Eat接口改造一下，增加一个参数化类型 private class Food&#123; String foodName; &#125; private interface Eat&#123; void eat(T things); &#125; private interface Run&#123; void run(); &#125; private class Dog implements Eat,Run&#123; @Override public void run() &#123; &#125; @Override public void eat(Food things) &#123; &#125; &#125; private void main() &#123; Class clazz = Dog.class; Type[] genericInterfaces = clazz.getGenericInterfaces(); Class[] interfaces = clazz.getInterfaces(); &#125; 运行结果：","categories":[{"name":"技术文章","slug":"technology","permalink":"http://vompom.github.com/categories/technology/"}],"tags":[{"name":"网络","slug":"网络","permalink":"http://vompom.github.com/tags/%E7%BD%91%E7%BB%9C/"}]},{"title":"关于大学生活总结","slug":"关于大学生活总结","date":"2019-04-30T02:23:05.000Z","updated":"2025-08-25T14:08:00.224Z","comments":true,"path":"2019/04/30/关于大学生活总结/","permalink":"http://vompom.github.com/2019/04/30/%E5%85%B3%E4%BA%8E%E5%A4%A7%E5%AD%A6%E7%94%9F%E6%B4%BB%E6%80%BB%E7%BB%93/","excerpt":"","text":"这篇文章原发布于知乎，原问题为：如何看待 B 站用户「—刃舞—」大学退学在家自学编程？,当时毕业刚不久，有感而发，写了很多关于大学生活的事。主要是想告诉大家，大学并不是只有学习这一件事，还可以做很多很多有意思的事。 原文看到 @刃舞 了经历，彷佛看到了自己当初的自己。以一个 学长的身份来回答这个问题吧，也算是对自己大学四年生活的一个总结吧。曾几何时，我也向像他一样，满腔热情，不可一世，感觉自己很牛逼了，好像学校教的东西太少了，不能满足自己对编程技术的追求，我想学东西，我想搞出个牛逼的东西出来。于是大一开始接触Linux+php+Mysql来,这篇文章讲了自己的一些相关真实经历。感觉真的成就感爆棚，做一个论坛什么之类的，数据库的增删改查用得6得不得了。自己做了各种各样花里胡哨的东西，把什么Thinkphp、Bootstrap、Jquery、Foundation……之类的名字听起来很高端的框架都用了起来。我也不满足于这些东西，于是啥都学，学了C\\C++\\C#、php、又Java、后来听说爬虫这玩意儿，又接触了python,反正就是花里胡哨的东西就是一顿学！、我当时也认为大学所教授课程效率低下而且没有实际用处，但是我并没有选择退学课呀什么的，老师讲得都是啥啊，于是就逃课咯，我也给一些老师说了（比如在上Java课，而那时候我已经开始接触安卓相关了，我说这门课我能不能不用去，老师说：学校有免修，你牛逼，你去提前考试了通过了就可以不用修了。当然老师不是这么说的，大概就是这种意思吧，可是傻傻的我并没有去走免修这条路，因为我感觉自己能拿到60分，但是拿不到80分才通过的分。）但我还是没有去上课，老师也知道我不去上课也都知道我在干嘛，虽然早上没有课，但我也会保证每天是最早到学院的人，都会去工作室待在电脑面前，基本上都很晚才会回去。这样一直持续了两三年，直到大三下，我才开始慌了起来，我感觉自己好像什么都懂，但是又懂得不是特别深，在大三下的时候投了简历，在下面回答有讲过相关经历:经历过种种面试，大三下暑假终于进入了一家公司开始实习，以PHP开发岗位进去的，在这里有很多牛逼的人，也有各个方面的专家。我的工位就在安卓开发团队旁边，因为之前有花很多心思去做了一个安卓App,于是在闲暇时间向其中一个大哥请教：你觉得我这App怎么样？ 他稍微滑了几滑说道：这不就是大学里面期末课程设计的么？ 我瞬间就懵逼了，也被打击了，我连续搞了大半年的App，多少个日夜搞出来的，就被他这样一句话给怼了…… 之后我才渐渐知道 闭门造车，出门而不能合辙。 自己虽造了很多车，但是车拿出去之后压根就跑步太起来。在公司实习后，在导师的指导下，我知道了该学习的东西和方向，每天下班回家后也都会坚持学习，我发现我收获到的东西是在学校里面的很多倍，可能这些东西更加的实用了，因为都在面向平时所会接触到的问题靠近。我有动力，一方面是来自于实力与前辈们的差距，另一方面也是来源于内心，我想过更好的生活。难道 我的大学的价值就没有太大用了么？当然不是。反而充实的大学生活让我收获到了更多，也让我在那里留下了一段美好的青葱岁月。收获到的并不是金钱那么简单，大学对我的心智得到了锻炼，养成了各种良好的品行，以及各种经历让我生活更加的有趣。生活在这个地球上，工作与学习只是其中的一小小部分。我们可以结交很多志同道合的朋友，我们可以在仅有的青春岁月里做一些年轻时大胆去尝试的事，我们可以做的还有很多很多…… 在大学里曾经和这些小伙伴们一起踢过足球 在大学里曾经和这些小伙伴们代表学院参加排球赛![]https://pic1.zhimg.com/80/v2-96a34d0bd4d1c42d52b13fc0ed7367b2_1440w.jpg 在大学里曾在学生会“浪里白条”，从干事到部长 在大学里曾带着“五元”到城中“生存挑战”一天 在大学里曾与小伙伴们游西湖并与互联网企业CEO谈话 在大学里曾意气风发 在大学里曾组织拍摄了一部微电影 在大学里曾与室友“醉生梦死” 在大学里曾给大一的学弟妹们上课，教C与网页编程相关 在大学里曾上台表演小品，一口“川普”的效果引得大家哈哈大笑 在大学里也曾与大学的川籍老乡畅叙幽情在大学里也曾和我的班级同学们团结向上 在大学里曾与本地企业管理层一起学习 在大学里曾与那群“黑哥们儿” Did something interesting 在大学里也曾和我的“战友”一起战斗 在大学里也曾在创业尝试xxx 在大学里也曾“到处奔波” 添加图片注释，不超过 140 字（可选）在大学里也曾… 在大学里我见到了各式各样的人，我也去了各种各样的地方，也结交了各种各样的朋友，做了各式各样的事，真的没有什么遗憾的了。 感谢大学，不仅教授了知识，也让我四年的青春没有虚度，把这些美好都永远留在了我得青春岁月里了吧。 加油吧！相信自己的选择，每个人都有每个人的努力方向，只要自己不会后悔。 祝成功。 当时的评论存档 坠入苦海销尘垢认出了好多一起踢过球的同学，好像是野球社？我记得我也在的😂 坠入苦海销尘垢关注我的人看傻了，这不是我学校吗😂题主是19届的么2020-04-07 刃舞…… 并没有不可一世，也没觉得自己牛 x，我只想说题主描述有虚假煽动成分，自己分辨吧2019-04-23落叶挽歌&gt;这里或许是我表达错误吧，觉得自己牛X啥啥的，但是你这样表现出来的确实是这样的。也不清楚为什么知乎这里开始议论你了，如果你真心想做些东西或者研究什么，那就自己悄悄摸摸地做吧，不需要让所有人知道，也不用去反驳别人，当你真正“出山”了，再告诉我们吧，不需要把你一阶段一阶段的东西告诉我们。我没有针对你的意思，也不认为有什么虚假煽动信息。2019-04-23刃舞&gt;落叶挽歌我说的是题主 ……哈皮做游戏&gt;落叶挽歌单纯享受快乐多好。除非家里很穷，穷得交不起学费。落叶挽歌&gt;哈皮做游戏享受就有点过了吧，还是要正能量积极一点哈[调皮]哈皮做游戏&gt;落叶挽歌以前也想学知识，学东西，出去好找工作。以后工作大把学习东西的时间，就缺谈恋爱的时间。落叶挽歌&gt;哈皮做游戏那你工作很忙哈，我还好的。 知乎用户IZr076真的是良心回答。答主的大学，没有遗憾了。","categories":[{"name":"技术文章","slug":"technology","permalink":"http://vompom.github.com/categories/technology/"}],"tags":[{"name":"大学","slug":"大学","permalink":"http://vompom.github.com/tags/%E5%A4%A7%E5%AD%A6/"}],"author":"落叶挽歌"},{"title":"关于位运算和HashMap中一个求最小2次幂的算法","slug":"关于位运算和HashMap中一个求最小2次幂的算法","date":"2019-04-13T01:36:00.000Z","updated":"2025-05-20T11:46:57.000Z","comments":true,"path":"2019/04/13/关于位运算和HashMap中一个求最小2次幂的算法/","permalink":"http://vompom.github.com/2019/04/13/%E5%85%B3%E4%BA%8E%E4%BD%8D%E8%BF%90%E7%AE%97%E5%92%8CHashMap%E4%B8%AD%E4%B8%80%E4%B8%AA%E6%B1%82%E6%9C%80%E5%B0%8F2%E6%AC%A1%E5%B9%82%E7%9A%84%E7%AE%97%E6%B3%95/","excerpt":"","text":"今天在HashMap的内部源码的时候，看到这样一个算法： /** * Returns a power of two size for the given target capacity.* 返回大于或等于 cap 的最小2次幂 */ static final int tableSizeFor(int cap) &#123; int n = cap - 1; n |= n &gt;&gt;&gt; 1; n |= n &gt;&gt;&gt; 2; n |= n &gt;&gt;&gt; 4; n |= n &gt;&gt;&gt; 8; n |= n &gt;&gt;&gt; 16; return (n &lt; 0) ? 1 : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1; &#125;第一眼看起来确实是一脸懵逼，通过只知道这是一个获取该数的大于或等于 cap 的最小2次幂，这么厉害，咋实现的呀？ 1、数据在内存中如何存储？ 我们知道”&lt;&lt;” 和 “&gt;&gt;” 分别代表 左移和右移位运算符号，表示 乘以2 和除以2（大多数时候适用），”&gt;&gt;&gt;”还是第一次见，这是代表什么意思呢？说到这里我们不得不去了解一下数据是如何存储在内存中的： 在32位的计算机系统中，int型数据占几个字节？ 4字节。其中每个字节有8个比特位，表示二进制位，位是计算机内部数据储存的最小单位。这是所有编程语言学习者都知道的。也就是说 int类型在内存中有4*8 == 32个比特为 所以如果以整形数10为例，那么它在内存中完整存储的形式为： 00000000 00000000 00000000 00001010 -&gt;对应 1x2^3+0x2^2+1x2^1+0x2^0 =10 那么int类型表示最大的数是不是就是: 11111111 11111111 11111111 11111111 -&gt;对应 1x2^31+1x2^30…1x2^1+1x2^0 但为我们知道int类型的最大值为：2^31-1,显然上面的答案不是正确的。 这是因为在所有被int类型占用的比特位中，左起第一个位（即最高位）就是符号位。int类型的符号位上，0表示正数，1表示负数。在32位操作系统下，其余后面31位是数值位。也就是说： 11111111 11111111 11111111 11111111 所代表的数字为：1x2^30+1x2^29…1x2^1+1x2^0 的相反数为：-(2^31-1) 这里需要注意的是，按原先的逻辑去理解的话 00000000 00000000 00000000 00000000 为+0 10000000 00000000 00000000 00000000 为-0 那他们表示的意义是一样的么？实际上，在32位系统下int类型中，我们计算机已经强行规定了这种情况，数字0采用“+0”的表示方法，即 00000000 00000000 00000000 00000000；而“-0”这个特殊的数字被定义为了-2^31。 因此我们看到32位系统下int类型的取值范围中，负数部分比正数部分多了一个数字，正数的最大取值是2^31-1，而负数的最小取值是-2^31。正数部分之所以要减去1，是因为被数字0占用了“+0”，而负数部分不需要用来表示0，因此原本的“-0”就用来表示-2^31这个数字。 2、位运算如何进行？ 至此我们明白了数据在计算机中的存储形式，那位运算具体怎么运行的呢？以10和-10为例，其二进制完整表示为：00000000 00000000 00000000 00001010 和 10000000 00000000 00000000 00001010 为了便于观察，我们取后面8位：00001010 对于符号位移 例如将10的二进制向左移1位：那么变成 0001010 0 == 20 原先二进制数的第一位被移除，而最后一位被舍弃。将10的二进制向右移1位 原先二进制数最后一位被移除，第一位补0，则变成 000101 ==5 如将-10的二进制向左移1位， 10000000 00000000 00000000 00001010则变成： 10000000 00000000 00000000 0010100 为-20 如将-10的二进制向右移1位， 10000000 00000000 00000000 00001010则变成 ： 注意这里多了一个0-&gt; 1 00000000 00000000 00000000 0000101 &lt;-注意这里少了位 也就是说符号移动，会保留原来的符号位，不会因为右移左移而带走符号位。 对于无符号位移 相反无符号位移会不关注符号位。例如将-10向右无符号右移就会变成： 010000000 00000000 00000000 0000101 变成了一个很大的正数了！！ 如果将-10无符号左移，则变成： 00000000 00000000 00000000 00001010 = 20 但是！！并没有无符号左移动这样一件事情！跟右移运算不同的是，无符号左移和左移是一样的。因此java没有无符号左移运算。(&lt;&lt;&lt;和&lt;&lt;&lt;=将报错) 因为无符号右移运算需要考虑符号位的右移，而符号位只存在于二进制表示的最左边，最右边没有。所以不用区分无符号左移和左移运算。 3、关于返回大于或等于 cap 的最小2次幂的算法 我们以传入10为例子 由这张图看起来，算法很容易懂了，其实最主要的是为了去让各个位从高到低 从0变成1或者维持1不变，这样就能找到该数最小的2次幂 另外，需要注意一下的是，第一步 int n = cap - 1; 这个操作，执行这个操作的主要原因是为了防止在cap已经是2的n次幂的情况下，经过运算后得到的结果是cap的二倍的结果，例如如果n为l6，经过一系列运算之后，得到的结果是0001 1111，此时最后一步n+1 执行之后，就会返回32，有兴趣的可以自己进行尝试； 参考来源： https://blog.csdn.net/c10WTiybQ1Ye3/article/details/89411471https://www.jianshu.com/p/927009730809","categories":[{"name":"技术文章","slug":"technology","permalink":"http://vompom.github.com/categories/technology/"}],"tags":[{"name":"算法","slug":"algorithm","permalink":"http://vompom.github.com/tags/algorithm/"}],"author":"落叶挽歌"},{"title":"Java虚拟机类的加载机制","slug":"Java虚拟机类的加载机制","date":"2019-03-21T01:35:00.000Z","updated":"2025-05-20T11:46:57.000Z","comments":true,"path":"2019/03/21/Java虚拟机类的加载机制/","permalink":"http://vompom.github.com/2019/03/21/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/","excerpt":"","text":"什么是虚拟机类的加载机制？ 虚拟机把描述类的数据从class文件加载到内存，并对数据进行校验，转换，解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这就是虚拟机的类加载机制。 类从加载到虚拟机的内存中开始，直到卸载出内存为止，整个生命周期为： 加载（loading） 验证（verification） 准备(preparation) 解析(resolution) 初始化(initialization) 使用(using) 卸载（unloading） 其中 验证、准备、解析部分统称为连接 接下来依次讲解，各个步骤所做的事 第一部分 加载 “加载”是“类加载”的一个阶段，注意区分概念。类的加载由类加载器（后面介绍）加载主要完成三件事情： 1、通过一个类的全限定名来获取其定义的二进制字节流。 2、将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。 3、在Java堆中生成一个代表这个类的java.lang.Class对象，作为对方法区中这些数据的访问入口。 加载阶段完成后，虚拟机外部的二进制字节流将按照虚拟机所需的格式存储在方法区中，同时在内存中实例化一个java.lang.Class的实例对象。相对于HotSpot，这个实例对象比较特殊，虽然是一个对象，但并没有放置在堆中，而是放置在方法区中。这个对象将作为程序访问方法区中这些类数据的外部接口。 第二部分 验证 这一步主要是确保Class文件的字节流符合虚拟机的规范 主要验证以下几个部分： 1、文件格式验证验证是否以魔数开头、主次版本号是否在当前虚拟机处理范围内… 这一验证阶段主要是保证输入的字节流能正确地解析并存储与方法区内，格式上符合Java类型信息的要求。只有通过这个阶段，字节流才会进入内存的方法区中存储，后面的三个验证方式也都是给予方法区中的数据验证，不再会操作字节流。 2、元数据验证 验证这个类是否有父类、这个类是否继承了不允许继承的类… 该阶段主要对类的元数据进行语义校验，保证符合java语言规范的元数据信息。 3、字节码验证 最复杂的一个阶段，主要目的是通过数据流和控制流分析，确定程序语义是否合法、符合逻辑。 4、符号引用验证 这个阶段的校验发生在虚拟机将符号引用转化为直接引用的时候，这个转化动作发生在连接的解析阶段。目的是确保解析动作正常执行，如果无法通过验证，将抛出 IllegalAccessError、NoSuchFieldError、NoSuchMethodError等异常。 第三部分 准备 准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些变量所实用的内存将在方法区中进行分配。 这时候的分配仅仅是类变量(staic修饰的变量)，而实例变量将会在对象实例化时随对象一起分配在Java对中。 假设一个类变量为：public static int count = 10;这时候会分配0，而不是10，分配10是在程序编译后。 第四部分 解析 解析阶段是虚拟机将常量池的符号引用替换为直接引用的阶段 1、类或者接口的的解析 2、字段解析 3、类方法解析 4、接口方法解析 符号引用与虚拟机实现的布局无关，引用的目标并不一定要已经加载到内存中。各种虚拟机实现的内存布局可以各不相同，但是它们能接受的符号引用必须是一致的，因为符号引用的字面量形式明确定义在Java虚拟机规范的Class文件格式中。 直接引用可以是指向目标的指针，相对偏移量或是一个能间接定位到目标的句柄。如果有了直接引用，那引用的目标必定已经在内存中存在。 第五部分 初始化 在准备阶段，变量已经被分配赋值过初始值，在初始化阶段根据代码的逻辑初始化真实的变量和其他资源。 关于类加载器 什么是类加载器？ 在“加载”阶段中，通过一个类的全限定名来获取其定义的二进制字节流。这一动作是放到了Java虚拟机外部去实现的，是为了方便让应用自己去决定如何获取所需要的类，实现这个动作的功能是常说的“类加载器（ClassLoader）” 类加载器主要有三种： 1.启动类加载器(Bootstrap ClassLoader) 负责加载&lt;JAVA_HOME&gt;\\lib 2.扩展类加载器(Exension ClassLoader) 负责加载&lt;JAVA_HOME&gt;\\lib\\ext 3.应用程序类加载器(Applicaion ClassLoader) 负责加载ClassPath上指定的类库 类加载器工作原理 介绍类加载器原理之前，必须得了解双亲委派模型(Parents Delegation Model) 双亲委派模式的工作原理的是：如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行，如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器，如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载。 如图所示，这种层次结构关系被称为双亲委派模型以下为其实现代码，集中在java.lang.ClassLoader中的loadClass()方法中protected Class&lt;?&gt; loadClass(String name, boolean resolve) throws ClassNotFoundException &#123; synchronized (getClassLoadingLock(name)) &#123; // First, check if the class has already been loaded//首先检查类是否被加载 Class&lt;?&gt; c = findLoadedClass(name); if (c == null) &#123; long t0 = System.nanoTime(); try &#123; if (parent != null) &#123; //如果有父加载器，则先委托父加载，否则由启动类加载器加载，如果启动类加载器没有找到，则返回null c = parent.loadClass(name, false); &#125; else &#123; c = findBootstrapClassOrNull(name); &#125; &#125; catch (ClassNotFoundException e) &#123; // ClassNotFoundException thrown if class not found // from the non-null parent class loader //这里的ClassNotFoundException来自父加载器 &#125; if (c == null) &#123; // If still not found, then invoke findClass in order // to find the class. //在父类Classloader还没办法加载的时候 //再调用本身的findclass方法来加载类 long t1 = System.nanoTime(); c = findClass(name); &#125; &#125; if (resolve) &#123; resolveClass(c); &#125; return c; &#125; &#125;代码的逻辑很清楚： 先加载类是否已经被加载过，若没有则调用父的loadClass()方法，如果父 类加载器为空，则使用启动类加载器作为父加载器，如果父 类加载器加载失败，再调用自己的findClass()方法进行加载","categories":[{"name":"技术文章","slug":"technology","permalink":"http://vompom.github.com/categories/technology/"}],"tags":[{"name":"Java","slug":"java","permalink":"http://vompom.github.com/tags/java/"}],"author":"落叶挽歌"},{"title":" Android中Handler使用导致的内存泄漏","slug":"Android中Handler使用导致的内存泄漏","date":"2019-03-18T01:37:00.000Z","updated":"2025-05-20T11:46:57.000Z","comments":true,"path":"2019/03/18/Android中Handler使用导致的内存泄漏/","permalink":"http://vompom.github.com/2019/03/18/Android%E4%B8%ADHandler%E4%BD%BF%E7%94%A8%E5%AF%BC%E8%87%B4%E7%9A%84%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/","excerpt":"","text":"1.什么是内存泄漏 用动态存储分配函数动态开辟的空间，在使用完毕后未被得到释放，结果一直占据该用内存单元，直到程序结束，即所谓的内存泄漏。 2.是内存泄漏与内存溢出的区别 内存溢出 Out of Memory，是指程序在申请内存时，没有足够的内存空间供其使用，出现out of memory；比如申请了一个integer,但给它存了long才能存下的数，那就是内存溢出。 内存泄露 Memory Leak，是指程序在申请内存后，无法释放已申请的内存空间，一次内存泄露危害可以忽略，但内存泄露堆积后果很严重，无论多少内存,迟早会被占光。 用一个很形象的例子来说明：一个仓库，被无用的物资所占据，而得不到管理员的清理，这里的无用货物占用仓库空间的行为被叫做”内存泄漏“，而某一天仓库由于所存储的物品太多，而无法继续存放物资，这个时候就被叫做“内存溢出”。 3.内存泄漏导致的问题 相关内存无法被系统给回收，随着程序运行可以用的内存会越来越少，机子越来越卡，直到内存溢出。（这也是为什么手机电脑很卡之后重启一下后会好很多，主要是相关未被系统回收的内存被回收） 4、安卓中的内存泄漏 典型的可能产生内存泄漏的代码：public class MemoryLeakActivity extends MyActivity &#123; //可能会导致内存泄漏的代码 private Handler handler = new Handler() &#123; [@Override](https://my.oschina.net/u/1162528) public void handleMessage(Message msg) &#123; super.handleMessage(msg); &#125; &#125;;&#125;产生内存泄漏可能的原因：Handler的工作机制中Handler与Looper以及MessageQueue一起工作的，App启动之后，系统会默认创建一个为主线程服务的Looper对象，负责处理主线程中所有的Message对象，它的生命周期则为整个应用的生命周期。在主线程使用Handler都会默认绑定到这个Looper上面，主线程创建Handler对象，会立即关联Looper对象的MessageQueue，这时发送MessageQueue重的Message会持有Handler的引用， 这样在Looper处理Message时候才会回调到Handler的handleMessage方法。因此，如果Message没有被处理完成，那么Handler对象就不会被垃圾回收。上面的代码，将Handler的实例声明为MemoryLeakActivity类的内部类，在Java中：非静态内部匿名类会持有外部类的一个隐式引用，这样就可能导致外部类无法被垃圾回收。 最终由于MessageQueue中的Message 没有处理完成，就会持有Handler对象的引用，而非静态的Handler对象会持有外部类Activity的引用，这个activity无法被回收，从而导致内存泄漏。 5、解决方案 1、将Handler声明为静态内部类，这样就不会持有对外部类的引用。 2、创建一个Looper与一般Java对象一样的生命周期 private static InnerHandler extends Handler&#123; // 声明一个静态Handler类，并持有外部类引用 private final WeakReference&lt;MemoryLeakActivity&gt; mActivity; public InnerHandler(MemoryLeakActivity activity)&#123; this.mActivity = new WeakReference&lt;MemoryLeakActivity&gt;(activity); &#125; &#125;","categories":[{"name":"技术文章","slug":"technology","permalink":"http://vompom.github.com/categories/technology/"}],"tags":[{"name":"安卓","slug":"Android","permalink":"http://vompom.github.com/tags/Android/"}],"author":"落叶挽歌"},{"title":"Android开发 LayoutInflater源码解析","slug":"LayoutInflater源码解析","date":"2019-03-03T06:40:00.000Z","updated":"2025-05-20T11:46:57.000Z","comments":true,"path":"2019/03/03/LayoutInflater源码解析/","permalink":"http://vompom.github.com/2019/03/03/LayoutInflater%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/","excerpt":"","text":"本文主要是自己对LayoutInflater 使用的相关总结 我们经常实用的LayoutInflater这样用： View view = LayoutInflater.from(context).inflate(R.layout.resource,root,flase); 进入inflate进行源码解析 public View inflate(int resource, ViewGroup root, boolean attachToRoot) &#123; final Resources res = getContext().getResources(); if (DEBUG) &#123; Log.d(TAG, &quot;INFLATING from resource: \\&quot;&quot; + res.getResourceName(resource) + &quot;\\&quot; (&quot; + Integer.toHexString(resource) + &quot;)&quot;); &#125; final XmlResourceParser parser = res.getLayout(resource); try &#123; return inflate(parser, root, attachToRoot); &#125; finally &#123; parser.close(); &#125;&#125; 主要做了一件事：建立XmlResourceParser为后面解析xml文件做准备XmlResourceParser的解析原理可以去这里看看 继续进入inflate(为方便阅读删除一些调试代码和异常捕获代码，只保留了核心代码)public View inflate(XmlPullParser parser, ViewGroup root, boolean attachToRoot) &#123; synchronized (mConstructorArgs) &#123; final Context inflaterContext = mContext; final AttributeSet attrs = Xml.asAttributeSet(parser); Context lastContext = (Context) mConstructorArgs[0]; mConstructorArgs[0] = inflaterContext; View result = root; try &#123; if (TAG_MERGE.equals(name)) &#123; if (root == null || !attachToRoot) &#123; throw new InflateException(&quot;&lt;merge /&gt; can be used only with a valid &quot; + &quot;ViewGroup root and attachToRoot=true&quot;); &#125; rInflate(parser, root, inflaterContext, attrs, false); &#125; else &#123; // Temp is the root view that was found in the xml final View temp = createViewFromTag(root, name, inflaterContext, attrs); ViewGroup.LayoutParams params = null; if (root != null) &#123; // Create layout params that match root, if supplied params = root.generateLayoutParams(attrs); if (!attachToRoot) &#123; // Set the layout params for temp if we are not // attaching. (If we are, we use addView, below) temp.setLayoutParams(params); &#125; &#125; rInflateChildren(parser, temp, attrs, true); // We are supposed to attach all the views we found (int temp) // to root. Do that now. if (root != null &amp;&amp; attachToRoot) &#123; root.addView(temp, params); &#125; // Decide whether to return the root that was passed in or the // top view found in xml. if (root == null || !attachToRoot) &#123; result = temp; &#125; &#125; &#125; catch (XmlPullParserException e) &#123;...&#125; 这段源码中看出主要逻辑为： 1、判断xml局中标签是否为merge,如果是则走rInflate直接去遍历创建xml所有的View对象 2、进入非merge的逻辑里面，会创建根View，主要的过程在createViewFromTag创建View 3、rInflateChildren创建子View 3、接下来如果传入的root不为null,并且attachToRoot==false，则对创建好的View的ViewGroup.LayoutParams是通过generateLayoutParams生成的。 4、如果root不为null,attachToRoot==true，那么则将整个View作为一个子View加入到父布局中，否则直接返回这个View 继续进入createViewFromTag源码（为方便理解去除异常彩蛋和ignoreThemeAttr属性的代码）View createViewFromTag(View parent, String name, Context context, AttributeSet attrs, boolean ignoreThemeAttr) &#123; if (name.equals(&quot;view&quot;)) &#123; name = attrs.getAttributeValue(null, &quot;class&quot;); &#125; try &#123; View view; if (mFactory2 != null) &#123; view = mFactory2.onCreateView(parent, name, context, attrs); &#125; else if (mFactory != null) &#123; view = mFactory.onCreateView(name, context, attrs); &#125; else &#123; view = null; &#125; if (view == null &amp;&amp; mPrivateFactory != null) &#123; view = mPrivateFactory.onCreateView(parent, name, context, attrs); &#125; if (view == null) &#123; final Object lastContext = mConstructorArgs[0]; mConstructorArgs[0] = context; try &#123; if (-1 == name.indexOf(&#x27;.&#x27;)) &#123; view = onCreateView(parent, name, attrs); &#125; else &#123; view = createView(name, null, attrs); &#125; &#125; finally &#123; mConstructorArgs[0] = lastContext; &#125; &#125; …… 这段源码中看出主要逻辑为： 1、标签为view时获取view的class属性作为要创建的View的name(注意View和view的区别) 2、主要通过不同的Factory通过createView() 去创建View 3、其中有个逻辑需要在onCreateView执行之前判断是否存在“.”，存在点则表示不是系统的View,需要单独处理，在后面createView的代码可以看到有这样一段加入了“android.view.”，后面会讲这句的用途。protected View onCreateView(String name, AttributeSet attrs) throws ClassNotFoundException &#123; return createView(name, &quot;android.view.&quot;, attrs);&#125;继续进入onCreateView源码public final View createView(String name, String prefix, AttributeSet attrs) throws ClassNotFoundException, InflateException &#123; Constructor&lt;? extends View&gt; constructor = sConstructorMap.get(name); if (constructor != null &amp;&amp; !verifyClassLoader(constructor)) &#123; constructor = null; sConstructorMap.remove(name); &#125; Class&lt;? extends View&gt; clazz = null; try &#123; if (constructor == null) &#123; // Class not found in the cache, see if it&#x27;s real, and try to add it clazz = mContext.getClassLoader().loadClass( prefix != null ? (prefix + name) : name).asSubclass(View.class); if (mFilter != null &amp;&amp; clazz != null) &#123; boolean allowed = mFilter.onLoadClass(clazz); if (!allowed) &#123; failNotAllowed(name, prefix, attrs); &#125; &#125; constructor = clazz.getConstructor(mConstructorSignature); constructor.setAccessible(true); sConstructorMap.put(name, constructor); &#125; else &#123; // If we have a filter, apply it to cached constructor if (mFilter != null) &#123; // Have we seen this name before? Boolean allowedState = mFilterMap.get(name); if (allowedState == null) &#123; // New class -- remember whether it is allowed clazz = mContext.getClassLoader().loadClass( prefix != null ? (prefix + name) : name).asSubclass(View.class); boolean allowed = clazz != null &amp;&amp; mFilter.onLoadClass(clazz); mFilterMap.put(name, allowed); if (!allowed) &#123; failNotAllowed(name, prefix, attrs); &#125; &#125; else if (allowedState.equals(Boolean.FALSE)) &#123; failNotAllowed(name, prefix, attrs); &#125; &#125; &#125; Object lastContext = mConstructorArgs[0]; if (mConstructorArgs[0] == null) &#123; // Fill in the context if not already within inflation. mConstructorArgs[0] = mContext; &#125; Object[] args = mConstructorArgs; args[1] = attrs; final View view = constructor.newInstance(args); if (view instanceof ViewStub) &#123; // Use the same context when inflating ViewStub later. final ViewStub viewStub = (ViewStub) view; viewStub.setLayoutInflater(cloneInContext((Context) args[0])); &#125; mConstructorArgs[0] = lastContext; return view; &#125; ​这段源码虽然很复杂，但主要做的事就是 通过反射的方式去加载一个View类 这段代码就能解释上面为什么要加“android.view.”，这段代码会将系统的View的路径拼起来，把类加载进来；clazz = mContext.getClassLoader().loadClass(prefix != null ? (prefix + name) : name).asSubclass(View.class) 到现在，我们讲完了对于xml根view的创建逻辑，还有个很重要的流程没有讲： 子View创建 的逻辑在inflate中的rInflateChildren 进入rInflateChildren，这里依然会进入到rInflate() void rInflate(XmlPullParser parser, View parent, Context context, AttributeSet attrs, boolean finishInflate) throws XmlPullParserException, IOException &#123; final int depth = parser.getDepth(); int type; boolean pendingRequestFocus = false; while (((type = parser.next()) != XmlPullParser.END_TAG || parser.getDepth() &gt; depth) &amp;&amp; type != XmlPullParser.END_DOCUMENT) &#123; if (type != XmlPullParser.START_TAG) &#123; continue; &#125; final String name = parser.getName(); if (TAG_REQUEST_FOCUS.equals(name)) &#123; pendingRequestFocus = true; consumeChildElements(parser); &#125; else if (TAG_TAG.equals(name)) &#123; parseViewTag(parser, parent, attrs); &#125; else if (TAG_INCLUDE.equals(name)) &#123; if (parser.getDepth() == 0) &#123; throw new InflateException(&quot;&lt;include /&gt; cannot be the root element&quot;); &#125; parseInclude(parser, context, parent, attrs); &#125; else if (TAG_MERGE.equals(name)) &#123; throw new InflateException(&quot;&lt;merge /&gt; must be the root element&quot;); &#125; else &#123; final View view = createViewFromTag(parent, name, context, attrs); final ViewGroup viewGroup = (ViewGroup) parent; final ViewGroup.LayoutParams params = viewGroup.generateLayoutParams(attrs); rInflateChildren(parser, view, attrs, true); viewGroup.addView(view, params); &#125; &#125; if (pendingRequestFocus) &#123; parent.restoreDefaultFocus(); &#125; if (finishInflate) &#123; parent.onFinishInflate(); &#125;&#125;这段源码的大致可以总结为： 1、总的逻辑为获取xml文档的层级数，解析每一层级的数据 2、解析过程首先进行View的合理性校验，include、merge等标签； 3、最后还是会走到createViewFromTag 创建出 View 对象，如果是 ViewGroup则递归调用rInflateChildren 到这里基本上所有的流程讲完了，这里总结一下加载流程： 1、拿到Xml解析对象，为后续解析做准备 2、对整个Xml中的布局控制处理由 root、attachToRoot这两个参数控制 3、解析子View，通过createViewFromTag创建实例对象**","categories":[{"name":"技术文章","slug":"technology","permalink":"http://vompom.github.com/categories/technology/"}],"tags":[{"name":"Java","slug":"java","permalink":"http://vompom.github.com/tags/java/"}],"author":"落叶挽歌"},{"title":"从一则知乎看到的一段视频说起","slug":"从一则知乎看到的一段视频说起","date":"2018-08-25T17:35:00.000Z","updated":"2025-05-20T11:46:57.000Z","comments":true,"path":"2018/08/26/从一则知乎看到的一段视频说起/","permalink":"http://vompom.github.com/2018/08/26/%E4%BB%8E%E4%B8%80%E5%88%99%E7%9F%A5%E4%B9%8E%E7%9C%8B%E5%88%B0%E7%9A%84%E4%B8%80%E6%AE%B5%E8%A7%86%E9%A2%91%E8%AF%B4%E8%B5%B7/","excerpt":"","text":"这篇文章来自于自己写的知乎 今晚躺在床上，刷刷知乎，看到一则知乎：该回答已被删除,很可惜这篇已经找不到了。里面主要是一个视频：一位大叔在饭局里面饱含深情地唱了一首《假行僧》，最后把自己给唱哭了…… 思考让我陷入一些深思回答中中有这样一段视频，自己反复看了几遍，每一遍好像都有不同的感触。第一遍，感受到大叔打着的节拍是多么的有节奏感，让人听了之后恨不得跟着他一起拍起来。第二遍，我发现大叔后面的节奏相比于紧促了起来，大叔内心有了更多的投入，而且貌似最后还有不好听的字眼，貌似在发泄了。第三遍，大叔一定是一个有故事的人，大叔右手旁边的朋友都已经湿了眼角。。。 《假行僧》一首能把人唱得热泪盈眶的歌曲，我在想大叔是不是想起了他自己的过去，亦或是有太多的不满此刻想要发泄出来。我想前者会更多一点的吧。 是呀，生活在这样一个忙忙碌碌的人心浮躁社会里，人的压力自然而然就增加了，再也没有儿时那样的无牵无挂。今天和好朋友去了一趟西塘古镇，主要还是因为周末了，最近在一些地方也遇到了小挫折，周末了没有任何人来打扰自己，比起待在家里更想的还是出去走走比较好。 今天的西塘下着雨，没有了燥热的天气，人心还是挺平静的，或许是因为雨的缘故，景区并不是人满为患，自然也有了更多的空间去慢慢欣赏“江南水乡”。 因为最近刚看完《边城》，脑子里总是将其场景带入西塘，可是看着被商业气息冲刺着的古镇，自然也带入不了了。 走在河边的烟雨长廊上，朋友说道 十年后再来这里。啊！到现在这个年龄，自己真的对于时间太敏感了，真的有点害怕了！消逝的是那时间，留下的却是那一串串回忆。 那时间 永远不再回来。自己上个月刚过了二十二周岁的生日，还记得以前Taylor有一首歌叫做《22》，有一句：But i am feeling 22,evething will be alright（我感觉我回到了22岁,所有事都如此美好），所以我现在就处在这样一个霉霉很想回到的一个年龄？可是她回不到了，我自然也回不到了我的18了。 那回忆 有美好的不美好的。回忆里面有对酒当歌，有秉烛夜游，也有蒲苇磐石，也有来日方长，当然还有曲终人散。还记得那本《挪威的森林》，或许现在它还在某处静静的躺着吧，因为它回忆里也多了好多的故事。也还记得那一回因为一些压力，在酒吧里和朋友唱了首《挪威的森林》。 一切都已经过去了，也许明天就回来了，也许不会再回来。 就这样吧，晚安。2018/08/26 01:35","categories":[{"name":"生活感想","slug":"life","permalink":"http://vompom.github.com/categories/life/"}],"tags":[{"name":"省","slug":"thinking","permalink":"http://vompom.github.com/tags/thinking/"}],"author":"落叶挽歌"},{"title":"十年祭·512汶川大地震","slug":"十年祭·512汶川大地震","date":"2018-05-11T16:28:00.000Z","updated":"2025-05-20T11:46:57.000Z","comments":true,"path":"2018/05/12/十年祭·512汶川大地震/","permalink":"http://vompom.github.com/2018/05/12/%E5%8D%81%E5%B9%B4%E7%A5%AD%C2%B7512%E6%B1%B6%E5%B7%9D%E5%A4%A7%E5%9C%B0%E9%9C%87/","excerpt":"","text":"今晚不知在哪突然看到有关512汶川地震的相关报道，汶川地震已发生了十年了。十年呀！人们总是对于十年、二十之类的整数年比较在意，当然我也不例外。作为一个在外漂泊对人来说，提起故乡往事也总是诸多感慨与回忆。 还记得在十年前自己还是一副稚嫩对模样，一米五不到，留着一个乖乖头的小孩子。记得那天在发生地震之前一切都很普通，普通得我都忘了那之前有发生过什么事情。那时候我们正趴在课桌上睡午觉，突然桌子一阵摇晃，我也不知道发生了什么。我只是抬头一看天花板上面的风扇在摇晃，那时候的天真我以为外面吹大风了，把风扇吹摇晃起来了，把房子吹摇晃起来了。可是十几秒钟之后，整个楼层嘈杂了起来，我也不知道发生了什么，只看到外面一群人都在往外边跑，我也跟着往外边跑，我们的教室在三楼，从三楼走到操场上，我感觉整个地面像是海绵做的一样，踩上去特别特别的软（现在想起来，当时房屋震动起伏的高度应该有个二三十厘米），整个人走在上面都在摇摇晃晃，依稀的听得一些窗户玻璃碎了的声音。不一会全校的人都站在了操场上面，此时地面依然在震动，当时大家都不知道发生了什么，可是脚都在不由自主地颤抖，可能是先天的一种对大自然的畏惧吧，站在操场上地面震动的时间持续了二三十秒钟，到后来渐渐的停止了震动，大家也才反应了过来。 有老师在大吼大喊组织大家在操场上站着，不让大家再回教室，地面停止震动了，其中我印象很深的一个情节：班上一个人由于刚睡了午觉口很渴，想回教室去拿水，校长看到他向教室里面走去了，直接过去就是两耳光，然后一顿骂。同学很是不开心，还暗地里骂校长，现在想想真的能理解当时校长的心情。从那之后“地震”这个词才深深的印在我们的脑海里，原来呀，这就是地震。 全校都站在操场上无目的等（现在想来当时应该在等上级的通知，是否是叫我们放假吧），也不记得等了多久，然后学校突然说放假了！！！当时那叫一个兴奋（现在去查了查日历，当时是星期一）这可了得，刚放完周末又马上要回去了，我记得好多人都高兴得跺脚了。。。可是大家往家走的路上，看到有些东西有点不对劲了，路上有一些比较老一点的房子直接全部垮塌了，然后途中遇到一个学生他妈来接他，我也不知道具体说了些什么了，大致记得“余震”这个事，说的是之后还会有余震，当时那叫一个怕，以为余震和刚才的大地震一样，还会再来一次，真的是很害怕了。 越往家走心里越害怕，万一自己家的房子垮了怎么办呢？带着担心回到了家，发现还好还好，房子还没有垮，悬着的心一下子放松了下来。作为小孩子的我们，又聚集了一堆小伙伴玩呀，好像一切都与我们无关。记得当时已经停电了，电视没法看了，也没有手机电脑，家里的电话也大不出去了，不知道谁弄来了一个小随身听，听广播播报说：2008年5月12日啥啥啥一大堆的。现在想想当时有个很搞笑的场景：我们从新闻里面听说了7.8级，也听到了8.0级之类的，大家以为是 成都还是哪里发生了8.0级地震，某某地方发生了7.8级地震。于是有个人赶紧问在听FM的小伙伴说：“绵阳多少级？” 我们小孩子依然像往常一样，在整个村里面到处蹿，发现整个村都在忙，从家里搬重要的东西、搭帐篷等等，甚是热闹，小孩子好像就喜欢热闹的场景，记得我们那天玩到了比平时晚很久很久才回家。晚上一家人住在了帐篷里面，当时我也不知道为什么不住家里呀，房子应该够结实的呀？一家人都围在一个小小的帐篷里面，我拿着我小小的手电筒躲在被窝里，好像还有自己的一些小玩意儿，然后又把手电筒挂在帐篷最上面，照着我们，那时候真的一点都不害怕，甚至是感觉到自己是有多么的幸福。 晚上，下起了大雨，很大的雨听到了雨水和帐篷上一直发出哒哒哒的声音，外面的大雨并没有破坏帐篷内的宁静。现在想想爷爷真是伟大，帐篷是他搭的，我还记得他在下午的时候，就已经在帐篷周围挖好了排水道，这样使得帐篷周围不会有积水，也使帐篷内地面保持干燥。我就安然地睡着了，睡得很香，啥事没有一样。记得半夜，大概两三点的时候吧，整个村又吵起来了，原来是在刚刚发生了一场余震，而我全然不知。记得爷爷当时给我们讲了下当年唐山大地震的一些事，我也记不清楚太多了，只记得唐山离我们很远，但是好像这边震感还是很强烈（没有汶川这次强烈），但是每家每户也都搭起了帐篷，然后讲了很多，我记不清了。。。 第二天，好像消息很多很多就传来了，我也是听爷爷给我讲的，他在茶馆听谁谁谁说了啥啥啥，大家都在讨论啥啥啥。现在想想当时镇上的茶馆里面大家都讨论这些的时候是有多热闹，等我到初中的时候，我甚至将想象中爷爷当时在茶馆的场景和老舍的三幕剧《茶馆》做对比，《茶馆》里写着“莫谈国事”的标语，一大群人都安安静静地端着茶杯各个喝着自己的茶，而爷爷的“茶馆”这边却是大家对“国事”各抒己见的热闹场景，想想真的是有趣。 记得过了一两天来电了，终于能看到电视了，打开电视发现所有的频道都放的是一个画面！！里面的场景记得大多与担架、救援人员、救灾物质、废墟等等相关。我清晰的记得有个场景是一位父亲举着一叠奖状向镜头展示，然后哭着说道：全是三好学生。。。父亲一边哭一边看着已经永远离开了自己的女儿。还有那位母亲的那条短信：“亲爱的宝贝，如果你能活着，一定要记住我爱你”。看惯了生离死别的医生却在这一刻落泪了，手机传递着，每个看到短信的人都落泪了。。。看到了太多太多的感动，在感动的同时，也感慨生命的脆弱。活着真好。 太多太多的感动一时间无法全部诉说。。。 这次地震无疑给自己留下了很多阴影，初中的时候一台压路机从教室外边路过，整个房子微微颤抖都特别特别的害怕、有时候谁在桌子边抖抖腿也感觉特别的害怕。自己从来不敢去做 类似蹦极、过山车之类的事，上次去走玻璃栈道也是战战兢兢的。有的同学说我怕死呀？我并不怕死，只是对生命敬畏。 十年过去了，岁月变迁太快，爷爷和他撑起了家庭的帐篷已不再，心里留下的只有诸多的怀念。上天很眷顾我，我也很珍惜，珍惜自己的家人，珍惜每一份情。 最后也感谢各位以前对我们四川人民的帮助，滴水之恩，永远铭记！ 愿逝者安息，生者如斯🙏 愿逝者安息，生者如斯 ---2018/05/12 00:28","categories":[{"name":"生活感想","slug":"life","permalink":"http://vompom.github.com/categories/life/"}],"tags":[{"name":"省","slug":"thinking","permalink":"http://vompom.github.com/tags/thinking/"}],"author":"落叶挽歌"},{"title":"程序员学习之路--小白成长记(网站网页篇)","slug":"程序员学习之路-小白成长记-网站网页篇","date":"2018-05-08T02:58:00.000Z","updated":"2025-05-20T11:46:57.000Z","comments":true,"path":"2018/05/08/程序员学习之路-小白成长记-网站网页篇/","permalink":"http://vompom.github.com/2018/05/08/%E7%A8%8B%E5%BA%8F%E5%91%98%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%B0%8F%E7%99%BD%E6%88%90%E9%95%BF%E8%AE%B0-%E7%BD%91%E7%AB%99%E7%BD%91%E9%A1%B5%E7%AF%87/","excerpt":"","text":"时间飞逝，一名程序员已经由一脸茫然渐渐地懂得了很多东西。 在很久很久以前，一名少年正思索着一些东西，他发现他对网站很有兴趣，可是他不知道该怎么做，于是百度了起来，开始慢慢地了解了起来。 开始渐渐地明白了网页原来是用html代码写出来的，去搜了很多教程，都是从最简单的显示Hello World开始，他发现很多教程老师总是用记事本或者Notepad++新建一个txt文件，然后把后缀改成html，然后点击一下这个html文件，哇！浏览器就显示出来HelloWorld，至于是为什么，也不知道。 再后来，学了很多标签像 input\\div\\span等等，他这时候发现就这样输出的效果好单调啊，于是他后来又知道了CSS,CSS属性就像是一罐罐彩色原料，它能让之前写的html变得绚丽起来。再后来他有一天想做一个表单，在一个input框里输入一个名字，然后想要在页面上显示：XX天下无敌，啊。。。这可怎么做啊，之前的html只能写什么输出什么，没有一点交互作用，于是在这样的情况下，他认识到了JavaScript，他学会了js的一些小语法，alert(‘XX天下无敌’);js就像是一个个灵活的小部件，他能让页面转动起来。他好像开始对编程有兴趣了。 他一如既往的用记事本一个一个字母瞧着html css js代码，总感觉这样子太慢了，去百度搜了一下：网页编辑器。于是Dreamweaver 进入了它的世界，它发现这个编辑器真是爽，打一个“,这简直是大大的节省了敲代码的时间啊，他开始在怀疑为什么老师之前要叫我们一个一个字母的敲，有这样的一个编辑器不是很爽么？只用打首字母就出来了，这件事在后来的后来他才明白。他发现Dreamweaver还可以不用写代码—只需要拖拖控件就能生成一堆代码出来，啊！那简直是好啊，我们直接拖控件就OK了？为什么我们要写代码？少年乐此不疲地拖拖玩玩，发现挺有意思的。 某一天，他有点很生气，因为他发现Dreamweaver拖的代码，页面布局总是不是他想象的那样子，界面总是乱动，做一些简单的东西，拖一拖还行，稍微复杂一点的就哭了，这并不能满足他。他又开始去学习，怎么才能做一个好网站，那时他还没有能够理解到网站和网页的区别。他开始稍微系统一点的去学学前端了，他认识到了Bootstrap,CSS是一罐罐彩色原料的话，它需要对原料色进行调色才能到达最好的效果，然后一笔一笔地去涂好html。Bootstrap更像是一只只彩色笔，它把颜色已经调好了，只需要直接去使用，大大地节约了书写代码的时间。他也认识了JQuery这个打着“write Less，Do More”旗号的库，这个库也真的是申请了，简简单单的一两行代码可以做好多好多的事。 现在它的界面逐渐变得漂亮了起来，它发现页面感觉太枯燥了，界面连个动的东西都没有，他说我要做个动态网站，我要让页面有绚丽的动画起来。傻傻的少年，天真的认为动态网站就是网页有动画的效果那就是动态，于是他去学了学HTML5、CSS3,一下子页面炫酷多了。他开始迷上了网页编程。 他开始对同学说：我最近做了个网页，同学们：哇，可以给我们看看么？他：啊？怎么给你看看？把你的网址给我呗。。。他回到家又开始琢磨了起来，怎么才能把自己的网页通过网址给别人看呢？噢。需要一个服务器，于是他稀里糊涂地去在腾讯云租了个几十块钱一个月的服务器，最开始的他一脸懵逼啊，这个怎么玩，一大堆乱七八糟的东西。东搞西搞，他了解到了Linux操作系统，懂得了一些操作命令，终于配置好了一个Centos 6.5系统的服务器系统，用FlashXP将自己做的网页传了上去，他访问一下服务器的IP地址 123.2XX.24.1XX，啊哈，看到了自己做的页面展示在了网页上，但是他发现，为什么别人都是什么http://www.xxx.com 进去呀，我的为什么是数字，于是他明白了要去租个域名，将域名解析到服务器上。。。几经周转，当他输入 http://www.xxxxx.com 弹出了他的网页，并将这个网址分享给朋友，他心里成就感满满。 他的网页是在页面上显示一些小笑话，但是久而久之，他发现每次要录入一个新笑话都得把同样的代码复制一遍，然后把域里面的数据再替换成新的内容。这样下去可怎么了得，万一以后录入了上百上千个笑话，那这个html文件岂不是有上千上万行咯？那才是真正的笑话呢。于是引入了数据库，得把内容录入到数据库，然后再利用后台文件将数据库的内容读取出来。对于数据库，他学了MySQL以及和MySQL天生是一对的PHP！！！ 因为开始用PHP写后台脚本了，他发现Dreamweaver体验真的不太好，于是接触到了宇宙最强 IDE公司JetBrains的产品—Phpstrom。要运行php文件那得搭建个php运行环境呢，MAMP(Mac Apach Mysql Php)简直不能太好用，就下载一个这个安装好就好了，不用单独去安装其他什么的，在Windows 系统上装个WAMP，在Linux系统上装个LAMP就OK了。万事俱全，只欠开始敲代码。 他开始在html文件中加入了php脚本，将原来的重复的代码使用foreach循环将读出来的数据打印出来，这下页面精致了很多，不过页面由html改成了php，他似乎能理解动态页面和静态页面的区别了，动态页面原来是指数据的动态。就这样，他利用数据库的CRUD(Create Read Update Delete)貌似好像能做很多很多事情了，他学会提交表单到数据库，并且他知道了每次数据提交都是通过GET或者POST提交到一个后缀为php的后台文件里面，然后后台获取到GET或者POST请求数据，再做一些处理最后再返回处理结果。他发现每次提交一次数据之后页面都会跑到php处理文件里面去，然后再在里面写返回之前提交页面的代码，这样感觉实在是太不友好了，它开始接触到了一个新的技术—Ajax，再利用利用json数据格式进行前后端交互，使得异步操作这东西说起来就那么高大上，放JQuery里面就几行代码都事情。她似乎对这门技术越来越热爱。 他某一天发现自己的数据库被人更改了，这是为什么呀？没人知道我的密码呀？被黑客攻击了？几经周折，他在网站安全一块进行了相关探索，原来啊自己被SQL注入了，自己写的简单语句被人类似于“select * from admin where user=’’or ‘a’=’a’ and passwd=’’or ‘a’=’a’”最简单的SQL注入了，他开始想办法将SQL语句写得更安全一点，利用面向对象的思想将查询语句封装起来。除此之外他又顺带了解了XSS、CSRF攻击以及HTTP和HTTPS的区别，这样使得页面安全性提高了起来。 他写的网页文件越来越多了，但都是写小项目，就几个php文件搞定了。他看到了网上有个叫翁天信少年写了他自己的个人博客，那博客真的是棒不，幻想自己也能做一个，说干就干。他从网上找了个模板，解压出来，惊呆了！！怎么这么多html文件！这样一个一个去还去写，简直要哭啊！在这种情况下，他学习到了MVC三层分离思想，将数据与视图通过控制器结合起来。又引入了基于MVC的ThinkPHP框架，加上thinkphp模块化的设计让整个项目逻辑思路特别的清晰明了，程序的耦合性大大降低，因为框架的封装性也使前面的安全问题减少了不少。 通过git命令安装好了Thinkphp框架，然后自己写了个后台管理系统，管理自己的博客文章以及留言，他发现每次进自己的管理系统都要输入用户名和密码实在是有点麻烦，于是又去了解到了Session和Cookie机制，将数据保存在浏览器以及服务器上，这样使得服务器能够认识他，就不需要每次再输入密码和用户名了。 于是他沉浸在Thinkphp的世界里，过了没多久个人博客终于搭建完了。网上有人对他的代码设计很感兴趣问能不能分享一下他的源代码，最初他直接把代码拷贝发送给别人，可是问的人多了，总是这样做实在是太麻烦。于是他认识了Github这个新朋友，将代码托管上去，本地又配置好了其版本控制，通过Commit Pull Push使得代码管理似乎更容易一些了。","categories":[{"name":"技术文章","slug":"technology","permalink":"http://vompom.github.com/categories/technology/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://vompom.github.com/tags/%E5%89%8D%E7%AB%AF/"}],"author":"落叶挽歌"},{"title":"MacOs  JAVA调用R语言环境配置","slug":"MacOs-JAVA调用R语言配置","date":"2017-08-07T02:44:00.000Z","updated":"2025-05-20T11:46:57.000Z","comments":true,"path":"2017/08/07/MacOs-JAVA调用R语言配置/","permalink":"http://vompom.github.com/2017/08/07/MacOs-JAVA%E8%B0%83%E7%94%A8R%E8%AF%AD%E8%A8%80%E9%85%8D%E7%BD%AE/","excerpt":"","text":"最近接收一个项目做R语言的接口调用，网上做java调用R语言的大多是关于windows系统的，今天给大家介绍一下mac系统下如何配置调用R语言 流程首先下载三个必须要的文件：JRI JRIEngine REngine添加依赖 配置VM option和Enviroment 其中VM option为你的rJava的jri的路径： 这里一定要写“-Djava.library.path＝XX”我的参数为：-Djava.library.path＝/Library/Frameworks/R.framework/Versions/3.4/Resources/library/rJava/jriEnviroment为R_HOME的路径我的环境变量为：R_HOME＝/Library/Frameworks/R.framework/Resources 最后写个例子调用测试是否成功","categories":[{"name":"思考总结","slug":"thinking","permalink":"http://vompom.github.com/categories/thinking/"}],"tags":[],"author":"落叶挽歌"},{"title":"2017年710随笔 于嘉兴-福州列车","slug":"2018年710随笔-于嘉兴-福州列车","date":"2017-07-09T19:16:00.000Z","updated":"2025-05-20T11:46:57.000Z","comments":true,"path":"2017/07/10/2018年710随笔-于嘉兴-福州列车/","permalink":"http://vompom.github.com/2017/07/10/2018%E5%B9%B4710%E9%9A%8F%E7%AC%94-%E4%BA%8E%E5%98%89%E5%85%B4-%E7%A6%8F%E5%B7%9E%E5%88%97%E8%BD%A6/","excerpt":"","text":"此刻正在前往福州的火车上，在长达十五个小时的绿皮车时间里，真的让人很难受。想睡觉，可是又不能好好地睡，现在很累很困，却睡不着，所以在这漫长的夜里面陷入深深地思考。 站在窗前，看到窗外的风景变幻多端，偶尔点点灯光、偶尔路灯透亮、偶尔通过窗户看到的只是自己的面孔。看着玻璃里面阴影的自己，头前已经有一两根白头发了，索性拔掉，因为我觉得我还很年轻，这种东西与我无关。 二十一年走过来了，想想多么的可怕，二十一年了呀！这是一个多么吓人的时间。或许是长大了，对于一些实物关注的东西也不一样了，二十一年父母也从一两根白头发过度到了半头白发，貌似就只是发生在这几年，父母老的速度感觉已经比之前更快了。现在每次再见到父母，再也没有以前那种憧憬与期盼了，更多的是对他们的心疼与内心的愧疚。 还有一年多就要出去工作了，既憧憬，又彷徨。憧憬的是能够走出学校了，能自己挣钱了，自己挣的钱再怎么花也没有像现在这样心疼，或许可以做更多以前因为没有足够的钱可以做到的事，只是怕再也没有以前那样的心；彷徨于自己要像个大人一样活着了，有些事再也不会因为你是小孩，因为你是学生而同情你可怜你；彷徨于要为自己的以后的人生想办法了，面对工作、对象、父母，又该如果去处理这些问题呢？ 工作，用兴趣去劳动。如何选择？喜欢编程这个东西，因为当看到自己一行行写出来的代码转化为想要的效果的时候，是一种多么有成就感的事情。用代码去解决一些问题，也是一种乐事。可是…难道要敲一辈子代码么？难道要给别人打一辈子的工么？ 对象，以后要陪一辈子的人。何去寻觅？她可以什么都不做，但是他能在我最苦闷的时候来安慰我；能在我得意的时候，和我一起分享；不管我有多穷，而不会看不起我不管我我做什么事，她都能支持；不管发生什么，她都能陪在我身边。这样的女人，我宁愿累死也愿意会为她努力。一个人，一辈子。炊烟起了，我在门口等你；夕阳下了，我在山边等你；叶子黄了，我在树下等你；月儿弯了，我在十五等你；细雨来了，我在伞下等你；流水冻了，我在河畔等你；生命累了，我在天堂等你；我们老了，我在来生等你。无论如何我和她，她和我都能够一直在一起。 父母，一直支持我们的人。如何回报？或许一个好一点的工作，不错的对象，是对他们最大的回报。父母最大的期盼就是希望子女能够过得好，拼命地去挣钱，可却苦了自己。处处节约，只希望子女能过得好。对于我们，他们付出太多了。也许他们经常说我们这不行那不行，可是心里却很是因为我们而自豪。 此刻好冷，一件T恤加衬衫伴随一条阳光牛仔小短裤完全抵挡不住半夜这咄咄逼人的寒气，让人冷得发抖，可却并没有多余的衣服了，只能默默地扛着。生活，不也如此么？回家的火车因为天气原因而晚点了，在听到这则通知时，你也只能发一下牢骚，也只能去默默接受这个事实；心爱的球队这场比赛输了，在终场哨声响起时，你也只能作几声叹息，也只能去默默接受这个结果。期待已久的电影让你失望了，在荧幕开始呈现演员表的时候，你也只能扫兴而归，也只能默默接受这样的一个故事情节。 有些事情无法被我们所改变，但唯一可以改变的是心态。心态好，或许可以让一个人活得并不那么累。回家的火车因为天气而晚点了，我们或许可以这样想：还好还好只是晚点一小时，并不是晚点两个小时；心爱的球队这场比赛输了，或许我们可以这样想：实力很对面差距本来就很大的，不过比分是0:1不是0:3还是。能接受的；期待已久的电影让你失望了，或许我们可以这样想：和女朋友出来看电影的，能和她在一起这样一两个小时，我已经很开心了。 想起那句烂大街的话：生活不止眼前的苟且，还有诗和远方的田野。放这里再适合不过了。能够：”宠辱不惊，看庭前花开花落；去留无意，望天上云卷云舒”的人，我想应该也过得很幸福。 2017年07月10日 03:13","categories":[{"name":"生活感想","slug":"life","permalink":"http://vompom.github.com/categories/life/"}],"tags":[{"name":"旅行","slug":"travel","permalink":"http://vompom.github.com/tags/travel/"}],"author":"落叶挽歌"},{"title":"黑客可以厉害到什么程度？","slug":"黑客可以厉害到什么程度？","date":"2017-05-20T02:00:00.000Z","updated":"2025-05-20T11:46:57.000Z","comments":true,"path":"2017/05/20/黑客可以厉害到什么程度？/","permalink":"http://vompom.github.com/2017/05/20/%E9%BB%91%E5%AE%A2%E5%8F%AF%E4%BB%A5%E5%8E%89%E5%AE%B3%E5%88%B0%E4%BB%80%E4%B9%88%E7%A8%8B%E5%BA%A6%EF%BC%9F/","excerpt":"","text":"原帖发布于知乎:《黑客可以厉害到什么程度？》 原文一个黑客很厉害，那一群黑客呢？这里给大家讲下一个组织—中国红客联盟。接下来给大家讲一下中国红客联盟的几次重大事件 第一次： 1998 年 5 月反击印尼网络原因：印度尼西亚发生动乱。在此期间，大批华人受到迫害，华人妇女遭到令人发指的强暴。 1998 年 5 月，印度尼西亚发生动乱。在此期间，大批华人受到迫害，华人妇女遭到令人发指的强暴。至 7 、 8 月，事件真相才通过互联网陆续透漏出来。在国内新闻媒体不报道此事的情况下，中国网民通过互联网陆续获得了相关信息。 8 月初，全球华人社会形成抗议高潮， 8 月 7 日 ，世界各地华人更同步举行抗议示威。印尼暴徒的行为激怒了刚刚学会蹒跚走步的中国黑客们，他们不约而同聚集在聊天室（ IRC ）中，讨论并决定对向印尼网站攻击。这是中国黑客的第一次对外群体性攻击行动，其表现出的团结与协调成为今后类似攻击行动的典范。8 月 7 日 ， ChinaByte 责任编辑在网站论坛中发现一个新帖。这一“帖子”声称中国黑客袭击了印尼站点，同时附上了尚未恢复原貌的站点网址。编辑印证后当即决定立即在每日发送给订户的新闻邮件中，首次增发“号外”。“号外”中只有简单两句话及一个网址，但包含了这一新闻事件的核心信息。全文为：“你的站点已被来自中国的‘黑客’所‘黑’，印尼的暴徒你们的暴行是会有报应的！！！（中文）’‘停止屠杀华人！！！’（英文）这是印尼一个‘ to kobudi.co.id ’的站点上日前出现的文字。这一站点目前被中国黑客小组所‘黑’。这一“号外”几分钟里就发送到数万订户的邮箱中。 8 月 10 日 ， ChinaByte 更将相关新闻上了主页头条。标题赫然为：印尼排华暴行激怒中国黑客。副题为：网上怒潮连天起。实际上，早在 8月7日之前，中国黑客已对印尼网站和电子邮箱展开攻击行动。他们通过破解密码而拥有了系统管理员的权利，将“苦难的同胞，我为你悲愤哭泣！”、“严惩暴徒！严惩凶手！血债血还！”等口号写在了印尼网站的首页上。他们同时还提供大量印尼重要部门的电子信箱，并向网友提供如何“轰炸”这些电子信箱的方法。 8 月 17 日 是印尼国庆日，这一天众多印尼网站再次遭到黑客的攻击，被黑网站首页都留有黑客们用不太连贯的英文以及中文声讨印尼排华暴行的词句。其中一名署名“ Warning From Chinese ”的黑客，在被黑的页面上留言道，他这样做只是提醒人们不要忘记５月间发生的惨案，此举并不会造成该 网站数据的丢失，但警告系统管理员必须将被黑页面保留 48 小时。这名黑客显然是为了让大家记住那场持续了 48 小时的排华暴乱。中国黑客的攻击引起印尼政府强烈的反应，他们将中国民间黑客的行为指责为中国政府的怂恿，并指出是中国谋求地区霸权的强烈信号。据当时“美国之音” 8 月 9 日 报道，印尼一名政府官员今日抗议“中国黑客”的“暴行”，据他说在 8 月 7 日 以来，印尼至少有十余个互联网站，被自称“中国黑客”的组织摧毁，少数被贴上各种恐怖的图片，大部分被彻底破坏。另外 8 月 7 日 几乎所有的印尼政府公用邮箱均遭到了邮件炸弹的疯狂轰炸。该官员竟说：“我们希望中国人保持理智，因为前一阶段的事情是我们自己的事情！如果中国人不想分清华人和中国人的区别，那就说明中国是一个充满威胁的国家，中国不能把有华人的地方都看作他的领土。五十年代中国派来了军舰，我们可以理解，因为他们接走的是自己国家的人，今天中国黑客来了，我们迷惑，因为他们对我们自己的事情横加干涉。谁都知道，没有中国政府的授意，中国妇联是不会抗议的，中国政府不仅干涉我们的内政，而且挑唆国内黑客对我们的攻击。我们十分不满！” 8 月 11 日 ，印尼政府电子技术主管官员就中国黑客行为再度发言。他说：“虽然黑客攻击给印尼造成了很大的损失，但他表示对民间的激愤他表示理解。但，印尼的问题是否象宣传的那样严重，大可不必听信过于危言耸听的报道。印尼政府会把自己的问题处理好。在被问及黑客攻击的损失时，他说有上百个个网站被攻击，其中十几个被侵入，大部分遭到破坏，有黑客试图攻击金融系统，造成了一定损失。另外 8 月 7 日 当天，印尼的网络异常拥挤，当天的政府邮件系统几乎瘫痪，给印尼的正常社会秩序造成了一定影响。但这位发言人话题一转，再次耸人听闻地说道：“完全有把握说，中国的大量 ISP 凭借带宽的优势对我们进行了长达 30 个小时的邮件轰炸，我们很难说这不是有组织的行动。如果不是防空警报没响，我一定以为中国对我们宣战了。不过，谁的网络都有漏洞，任何民族都有黑客，我们不希望这是两个伟大民族仇恨的开端。我过去不相信中国威胁，现在我知道了不该听信中国政府口头上的什么政策，仅仅是他的十亿公民在政府偷偷怂恿下发泄一下不满，就是一种可怕的力量。”他最后说：“我敢打赌，黑客事件仅仅是中国人对他们地区称霸的一个信号，当他们踏上我们的国土，开始说三道四时，大家就会觉得‘中国威胁’多么贴切，东盟的朋友，应该首先记住！” 第二次： 1999 年 5 月反击美国网络原因：以美国为首的北约空军用导弹袭击中国驻南联盟大使馆并造成三名中国记者死亡。 1998年的牛刀小试为1999年的第一次中美黑客大战埋下伏笔。1999年美军误炸中国驻南使馆后，一大批网民开始思考要行动起来，大量只懂简单电脑知识的网民自学了一点黑客常识后便参与到了黑客大战中来(他们被蔑称为脚本小孩)，中国的人海战术正式形成。1999年5月8日，以美国为首的北约悍然用5枚导弹袭击了我驻南斯拉夫联盟共和国大使馆，记者邵云环、许杏虎、朱颖遇难，另有20多人受伤。消息传来，国人震惊。5月8日，“红客”们首次黑掉了美国驻华使馆的网页；5月8日晚11点左右，“红客”们又成功突破白宫的防线，更改了白宫的主页；5月10日，中国网民自发地在同一时间内向北约网站发出ping指令，北约服务器（http://www.nato.org）过载，一度瘫痪。5.10日夜间，上述中国黑客网站攻击了www.capweb.net，一个美国国会的相关站点，并且用大约5分钟时间在上面公布了国外将近250个站点的密码,导致国外将近800多个站点被换上了全都自称是“中国黑客”的主页。到了北京时间12日白天，这些站点全部关闭。5月11日，成功侵入美国海军计算机与通讯华盛顿中心网站（www.nctsw.navy.mil）。这是黑客攻击以来首次攻击美国军方站点。5月17日，中国黑客紧急会议中心网站发出号召先致力于国内网络安全的改善，并着手为为国内大站义诊，以防止国外黑客对我国门户网站的攻击。中国红客联盟、中国鹰派联盟、中国黑客联盟三大黑客组织成为这场中美黑客大战的主力军。一时间，红盟的lion、鹰派的万涛成为中国黑客英雄。前者宣扬红客精神，给自己起了个独特的名字——“红客”(Honker)，希望以政治立场的正义性来证实自己攻击行为的合法性。以文化或者爱国的名义，在1999年前后，一大批脚本小孩挑战黑客的进入门槛。那个时候，黑客技术就像今天的blog一样流行，中国城市街头的书摊上，到处可见匆忙印刷出来的黑客入门，五花八门的黑客杂志匆匆出炉。中国的网民听到关于黑客的传说，也许就是在这个时候。1999年5月，即美国轰炸中国驻南联盟大使馆事件发生以后，当时中国的红客们袭击了美国的一些政府网站，包括能源部、内政部在内，这些网站的首页上一度高高飘扬着五星红旗。有一次大规模的攻击，还致使白宫的网站失灵三天。中国黑客攻击事件成了当时美国各大报纸的头条新闻 第三次： 1999 年 8 月反击台湾网络原因：1999 年 7 月 9 日 ， 李登辉在接受“德国之声”专访时，所提出了所谓“两国论”。 1999 年 7 月 9 日 ，李登辉在接受“德国之声”专访时，所提出了所谓“两国论”。公然宣称，台湾当局将两岸关系定位在“国家与国家，至少是特殊的国与国的关系”。台湾当局有关负责人也随声附和，说两岸关系已从“两个对等政治实体”走到“两个国家”，两岸会谈就是“国与国的会谈”等等。台湾当局这些分裂祖国的言论将他们一贯蓄意分裂中国领土和主权、制造“两个中国”、“一中一台”、“台湾独立”的意图暴露无遗。“两国论”顿时导致两岸局势紧张。大陆黑客依靠刚刚对美网络攻击战中总结出的经验，从 8 月 7 日 开始攻击台湾十多个政府网站，台湾黑客随即于 8 月 8 日 展开反击，大陆黑客贴“世界上只有一个中国，世界只需要一个中国”，台湾黑客贴“台湾是中国永远分割的一部分”、“你们敢打，我们敢独；大陆黑客贴五星红旗，台湾黑客贴青天白日旗，一时间“山雨欲来风满楼”。香港、台湾报刊纷纷以“两岸黑客狂掀网络战”、“网络大战方兴未艾”、“网络开战：免不了的一场战争”为题，大肆进行报道：“台海两岸军队尚在隔海威吓，按兵观望，民间却已经先行拉开电脑资讯大战的序幕，双方电脑黑客互相攻击对方网站并张贴政治口号，展现实力。”在大陆黑客的攻击中，台湾“行政院”、“国安局”、“新闻局”、“监察院”、“国民大会”等网站均被攻克。台湾方面指，仅对“国安局”的攻击 3 天内就达 7200 次。大陆黑客除删改网页外，还给许多台湾服务器安装了木马程序，导致不少网站服务器长时间瘫痪。值得一提的是，此次安装的木马程序由美国的 BO 首次改为了大陆黑客自己研发的“冰河”与 NetSpy ，而“木马冰河”也成了大陆黑客最为钟爱的木马程序。 8 月 11 日 ，台湾“国民大会”网站报警称，网站软、硬件疑遭黑客攻击造成严重毁损，即使是重灌系统也无法恢复。而警方对黑客仅利用软件就可破坏硬件，大感惊讶。在台湾黑客的第一波的反击下，铁道部、中国证监会、陕西科技信息网、浙江平阳国税局网站等篡改网页。随着两岸黑客对攻战规模的发展，大量的非政府网站开始被殃及。参与者非理性的成分越来越大，只要是“黑”下一个对方网站，就被视为胜利战果。这种情况是出于政治目的而实施的黑客攻击最普遍的现象，已超出少数真正意义上的黑客的行径。一直到八月底，两岸的黑客战才暂告一段。后来，台湾黑客扬言要在 十月一日 当天大举进攻大陆网站，而大陆黑客则针锋相对地表示，如果这样，将在是 十月十日 坚决反击。中国大陆黑客与台湾黑客的互攻是一场“持久战”，但凡碰到刺激事件就会引发攻击。如 2000 年 3 月 18 日 台湾“大选”结束陈水扁上台的当晚，一些大陆黑客当即进行攻击行动。以下是名叫“天语”的一名黑客的自白：“本人天语，浙江人氏，现外出打工，月薪 800 元人民币，虽不穷困也不不富有，刚好穿暖吃饱，平民 - 草民 - 贱民一个，连正规的高中都还尚未读过！此次对台湾的几个站点页面修改纯属发自一时气愤！要分裂我中国，我想每一个中国人对这个观点上的态度和我都该是一样的！尔等现正对我中国站点进攻，昨天竟还有一个“可爱的”所谓的“黑客”竟对我的个人电脑挂带的 HTTPD 产生了兴趣。呵呵。。其 IP 来自 140.123.107.78 。在此想也不用本人来说尔等对我方的进攻之密集！本人现警告之！本人原已停止对台主机的破解，但听闻尔等竟然反攻，并破坏我国几个站点。本人忍耐有限，于昨晚进入尔等国防部的主机。本打算来个 deltree/y c: 但想此举必将引起黑客大战！顾及大家皆无利可图，本人最后退出 TELNET 进程并关闭端口，可能也顺手关了 80 端口 , （纯属水平太差！：））现公布屏捕图！望尔等也能息事宁人！！”正是这名“天语”和其他黑客攻陷了台湾“国防部”等多个网站。2004 年台湾“大选”后，台湾情治部门透露， 3 · 20 “大选”刚结束不久，大陆黑客竟突破重重防火墙，侵入“总统府”和“国安会”内部网络系统，窃取并下载机密文件。近年来，台湾媒体屡屡报道“大陆网军入侵台湾”。两岸长期僵持的局面，决定了两岸黑客互相攻击的长期态势。 第四次： 2000 年 1~2月反击日本网络原因：2000 年 1 月 21 日 ，日本最高法院无视历史事实，悍然判决参加过当年南京大屠杀的老兵东史郎见证大屠杀的诉讼败诉； 由于日本厚颜否认南京大屠杀这一历史事实，从2000年1月24日下午，中国“红客”再次集体出击，先后有多个日本官方站点被入侵。1月24日5时45分日本科技厅网站被袭，主页上用英文写有“日本人是丧家之犬”，并与美国杂志《花花公子》链接，25日再次被攻入。2000年年初，零星骚扰演变为一场争夺网站控制权的黑客战，有人称之为互联网上的“新抗日战争”。当年1月21日，日本最高法院驳回因揭露南京大屠杀而被告损害他人名誉的东史郎等人的上诉，并对其判处50万日元的罚款。两天后，日本右翼势力在大阪国际和平中心举行“二十世纪最大谎言——南京大屠杀彻底验证”集会，公然否认南京大屠杀的史实。这两次事件直接引发了中国黑客对日本网站的大规模攻击，被替换的日本网页上，出现了“不肯正视历史真相的日本人是亚洲之耻”等抨击和谩骂的文字。这次攻击中，一个自称“中国极右翼抗日联盟”的黑客组织最为抢眼。1月24日至2月13日，该组织对30多家日本政府机构及新闻网站发动攻击，包括科学技术厅、总务厅、每日新闻社、NHK等。该组织还在网站上发布《致日本政府的公开信》，称其成员是“一切具有强烈爱国心的中国网虫”，宗旨是“对日本少数疯狗在网络里进行猛烈的打击”，并公布了300多个日本政府部门的网址、100多名日本议员的电子邮箱地址，以及十多种黑客攻击工具和网站攻击方法的说明。 再补充一下：同年九月中国黑客进攻日本反动网站，纪念“九.一八”2000年9月18日是一个特殊的日子，历史上的今天，是中华民族蒙受耻辱，永远无法忘却的日子。“九.一八”是国耻、国痛，但也是沈阳人、中国人的光荣，因为从这一天起一直到抗日战争的胜利，东北人民、中国人民同日本军国主义进行了不屈不挠的斗争。就在这样一个特殊的日子里，中国的黑客再一次以自己的方式纪念“9.18”事变。昨晚19时31分，Chinaren新闻中心接到网友报料说有中国黑客于2000年9月18日下午19时30分左右成功地对日本的右翼反动网站www.since918.com.jp进行了攻击。向日本右翼表达了他们愤怒的声音。受到攻击的这个网站是臭名昭著的日本右翼反动派的大站点。该站点一直在狡辩和否认“9.18”事件，为日本军国主义招魂。此次中国黑客是使用DDOS方式黑掉了该网站，将整个信道堵住，从而无法登陆该网站。这是中国黑客为捍卫中国尊严，不忘“9.18”事件付诸的又一强有力的行动。此次攻击导致该网站系统瘫痪。所以无法访问到该主页。 第五次： 2001 年反击日本网络原因：2001年前后，跨入新的世纪后之后，三菱车事件、日航事件、教科书事件、《台湾论》事件，令两国关系持续紧张，黑客攻击也趋于频繁。 据日本政府官员称，2000年日本共发生63起以政治为目的的黑客攻击事件，而2001年，前五个月已发生650起。日本警方曾通过国际刑警机构向中国索取资料，以协助调查。2001年8月13日，日本首相小泉纯一郎参拜靖国神社，中国黑客再次发动猛烈攻势。当日下午4时，日本气象厅网站服务器首先遭到攻击，主页被更改为带有英文字母和中文文字的页面。紧随其后，日本消防厅、防卫设施厅、通讯研究实验室，以及日本议员等网站相继沦陷，被贴上抗议文字及中国国旗。在小泉参拜靖国神社后， 8 月的攻击波来得更为猛烈。中国的黑客在获悉新闻后，即刻采取行动，更换了部分日本政府站点的主页内容，以示抗议。中国黑客组织在声明中表示：小泉参拜靖国神社的举动严重伤害了亚洲各国人民尤其是中国人民的感情，加之此前的教科书事件等，令他们非常愤怒，为此，决定用攻击日本政府网站的方式，表达他们的强烈不满。其实，中国红客大联盟早已讨论，一旦 8 月 15 日 小泉参拜，将对日本网络采取何种攻击行动，没想到小泉提早参拜，因此红客大联盟成员也提前行动。8 月 13 日 当天下午 4 时许，日本气象厅网站服务器首先受到中国黑客的攻击，其后，日本物质评估研究机构、日本战略物质研究中心、日本防御系统研究会、日本情报大会服务中心、日本消防厅、日本防卫设施厅、日本通讯研究实验室、日本议员网站等大批政府站点也受到攻击。 8 月 14 日 凌晨，红客大联盟发出了《对日本采取网络打击的声明》，内中写道：“日本首相小泉不顾全亚洲人民的抗议和日本国内祈求和平的声音，于昨日下午公然参拜了象征日本军国主义的靖国神社。日本领导人的这一错误举动严重地伤害了亚洲各国人民，尤其是受害最深的中国人民的感受。加之教科书事件等斑斑劣迹更是体现出日本当局对当年的错误毫无悔改之意。红客大联盟在得到此消息的的第一时间便召集了部分成员对此突发事件商讨对策。最终决定在我国政府还没有对日本提出抗议之前用我们所擅长的，表达我们网络时代青年一群对日本新政府的严正抗议和日本领导人的强烈不满。红客大联盟 (www.RedHacker.org) 在此次紧急行动中对以下的日本政府站点进行了主页替换。这和我们致力于推行的红客精神并不矛盾。红客大联盟对此件事情的发生表示遗憾，并将对以下所列举的受到的攻击的站点负责。历史不容忽视，事实岂能篡改，反击方能赢尊重，发展才是硬道理！” 第六次： 2001 年 4 月~5月反击 美国网络原因：2001 年 4 月 1 日 ，美国军用侦察机将中国战机撞毁，导致飞行员王伟坠海死亡。 2001 年 4 月 1 日 ，美国军用侦察机将中国战机撞毁，导致飞行员王伟坠海死亡。这一事件在中国国内引起民众极大的愤慨，而在中美之间立刻造成布什新政府与中国关系紧张的局面。尽管 4 月 11 日 ，中国方面已同意美方机组人员先行返国，但事件尚未得到完全解决，两国间的气氛依旧剑拔弩张。从 4 月初开始，中美两国的黑客已经展开相互攻击。如美国黑客组织 poizonB0x 便是攻击中国网站的主力，而一个名为 pr0phet 的黑客则更是明确地说：“我一开始只是随机挑选一些网站作为攻击目标，不过现在我则主要攻击以 .edu.cn 和 ac.cn 结尾的网站，或者只是以 .cn 结尾的网站，都会成为我的攻击目标。”在这种气氛和情况下（ 5 月 8 日 又逢中国驻南使馆被炸两周年），中国黑客在 4 月 30 日 至 5 月 8 日 打响了大规模的“第六次卫国网络战”。对于这次中美黑客大战的“战绩”，不同媒体的报道有很大出入，据“中国红客联盟”负责人称，真正被攻破的美国网站到 5 月 7 日 为止有 1600 多个，其中主要的网站 ( 包括政府和军方的网站 ) 有 900 多个。而中国被攻破的网站有 1100 多个，主要网站有 600 多个。实际上，任何一次黑客战争既不可能事先公开“宣战”，更不可能有“终战”的截止日期。这次中美黑客大战有以下特点： 1 、中国黑客的攻击事出有因在中国黑客的这次行动中，“中国红客网络安全技术联盟”（简称“中国红客联盟”， HUC ）是最瞩目的攻击主力，它使“红客”这一称谓再次叫响。其负责人 Lion 在 2000 年 12 月 1 日 就提出建议：“统一“红客”一词的英文名称（ honker ）。“红客”一词若能在英文中占有一席之地，这将具有非同寻常的意义！这样红客在世界范围内的交流与应用将变得更加方便；更重要的是，这样做能扩大影响力，增强凝聚力，促进红客文化的形成和进一步的发展！”也就是说中国黑客试图通过“红客”名称的确认，来赋予自己在一种特定情况下所作所为的正面形象。中国黑客涂改美国网页尽管也有以谩骂方式来泄愤，但主流是中国国旗、中国国歌和“伟大的中华民族万岁！”、“美国必须对撞机事件负完全责任”、“抗议美国向台湾出售武器，破坏世界和平！”等口号，实践着“维护祖国统一、捍卫国家主权、一致抵抗外辱、打击反华气焰”的行动宗旨。2 、中国黑客的攻击具有群体规模“中国红客联盟”、“中华黑客联盟”和“中国鹰派联盟”是攻击美国网站的主力，由于以往通过各种形式奠定的组织基础，因此得以在这次攻击行动中发挥群体力量，并带动了一大批临时参战的“菜鸟”（即技术生疏的新手）。如 4 月 30 日晚 7 点 ，“中国红客联盟”召开了“攻击美国网络动员大会”，并提供了更换美国网页的专用数据包；再如 5 月 4 日晚 ，中国黑客集中力量攻击白宫网站，据称参与人数有 8 万之众，事后白宫网站的新闻负责人吉米承认“大量数据同时涌入，堵塞了白宫与其互联网服务提供商的连接通道”。中国黑客万众一心的行动并且其间的出色协调，使得美国方面怀疑这次中国政府如果说没有背后支持，至少也是默许的。加拿大军事评论家、汉和情报评论高级分析员平可夫在香港《亚洲周刊》（第 19 期， 5 月 13 日 ）撰文称此次中国黑客的攻击为一场“新人民战争”，而这场战争的主体往往是可以称为“信息战网络战民兵”的庞大群体，武器是计算机、杀伤性火力构成是知识和技能，战场便是信息网络。3 、中国黑客群体由年轻人组成据媒体报道，“中国鹰派联盟”负责人老鹰今年 30 岁，而“中国红客联盟”负责人 lion 今年仅 21 岁，该组织发言人 bkbll 也年仅 21 岁，是在校大学生，其专业还不是计算机。 Bkbll 称“中国红客联盟”成员的平均年龄并不是媒体报道的 23 岁，而是更年轻，同时注册成员的 65% 是在校大学生。中国互联网信息中心（ CNNIC ）历次调查显示， 30 岁以下的青少年占全体网民的绝大多数。如最近一次调查显示（截止日期为 2000 年 12 月 31 日 ）， 8 个年龄段中， 18 至 24 岁占 41.18% ， 25 至 30 岁占 18.8% ， 18 岁以下占 14.93% ，也就是说， 18 至 30 岁年龄段的用户占到 2250 万总体的 75% 。今年中国网络用户预计将突破 3500 万， 2005 年将达到 2 亿，占全体国民的 15% 。从发展看，如此规模巨大的中国青年网络用户群体的网络行为，今后不论是对内还是对外，都将产生更大的效应。 完～～注：本文大部分内容来自 中国社会科学院新闻与传播研究所网络与数字传媒研究室主任闵大洪在博客中国于2005年02月12日 所发表的《告别中国黑客的激情年代——写在“中国红客联盟”解散之际》一文，本文中如有错误，欢迎指证。推荐阅读：","categories":[{"name":"思考总结","slug":"thinking","permalink":"http://vompom.github.com/categories/thinking/"}],"tags":[{"name":"知乎","slug":"zhihu","permalink":"http://vompom.github.com/tags/zhihu/"}],"author":"落叶挽歌"},{"title":"高考毕业后：《红盟：一个喜欢电脑孩子的心声！求围观》","slug":"高考毕业后：《红盟：一个喜欢电脑孩子的心声！求围观》","date":"2015-07-08T02:54:00.000Z","updated":"2025-06-18T07:07:33.313Z","comments":true,"path":"2015/07/08/高考毕业后：《红盟：一个喜欢电脑孩子的心声！求围观》/","permalink":"http://vompom.github.com/2015/07/08/%E9%AB%98%E8%80%83%E6%AF%95%E4%B8%9A%E5%90%8E%EF%BC%9A%E3%80%8A%E7%BA%A2%E7%9B%9F%EF%BC%9A%E4%B8%80%E4%B8%AA%E5%96%9C%E6%AC%A2%E7%94%B5%E8%84%91%E5%AD%A9%E5%AD%90%E7%9A%84%E5%BF%83%E5%A3%B0%EF%BC%81%E6%B1%82%E5%9B%B4%E8%A7%82%E3%80%8B/","excerpt":"","text":"这篇写于 2015年高考后的暑假中，当时发表于红盟的论坛里面(可惜我现在找不到了)。现在已大学毕业好几年，回看当时的想法还是蛮有感触的，那时的自己还是很有想法，充满了求知欲，随着工作时间的增加，发现这一点正渐渐被磨灭。 原文高中终于毕业了，追求了三年梦寐以求的大学终于要来了，在大学我就可以和很多具有相同爱好的人一起研究电脑技术了，这个我等了很久很久。。。现在，暑假中。不知道为啥今晚特别有感慨，写下了这些，也许是对过去的叹息吧。 最初接触网络，是在初中，那时候觉得这东西特别的神奇，由于当时都是国产的“板板机”，搭载的MTK系统，还有那个熟知的：“冒泡社区”，似乎还记得有那个经典的代码：*#220807#（不知道是不是这个），那时候的qq，在同学之间玩的很热闹，那时候qq 没有复制 后台等等的功能，直到后来我在 一个mrpyx的网站，学习到可以从那里下载那些可以后台的软件，还有一些很有意思的软件，当时被这些深深的着迷，并研究这些，在当时同学看来 我似乎懂得挺多的。 从初中以来，我就被班上的人封为手机、计算机大神，而“大神”这个称呼在我自己看来，都是唬那些小白的。高中我买了很多书看(java c vb photoshop dreamweaver flash 黑客功房等等的书籍)，但是很多都没有看完，都是粗略的了解。 我会简单的C语言编程，我对同学讲一个简单的Hello word程序，他们听得目瞪口呆，其实呢？我也不会多少，最多只学了一个多月，由于高中学习紧，总是在中午休息的时候看这些，把看《电脑报》《电脑爱好者》这类书当放松的方式，在课下拿出那本厚厚的《c语言编程》拿出来看，上课无聊时在本子上写写c代码，高三了，没有时间去搞这些，现在看来似乎完了很多很多。记得有一次我主持班会，为了活跃班会气氛，我在网上找了一款“抽奖软件”（就是将班上同学们的名单输入进去，通过随机的选择，会有一名同学“中奖”，然后让他起来发言），同学们都惊呆了！更有很多人认为那个程序是我自己编写的（因为我在背景添加的是我的qq头像，大家都认了出来。）我也知道那个程序很简单，分为几个结构弄出来的，代码最多100多行，是用vb做出来的，但是我不懂vb。我自己也根本写不出来那样的程序。 我会简单的视频处理，曾经在班上家长会来临之际，老师知道我是班上的计算机“大神”，他叫我用电脑做一个ppt（主要是展现同学们在学校的生活情况），我想呢？还不如做一个视频，我之前有了解过 Adobe Premiere 但是那个操作起来有点麻烦，我记得和我都喜欢计算机技术的同学之前用“绘声绘影”做过视频，说的“绘声绘影”有很多模版，很简单，我抱着试试的态度。。。果然很简单。有prmiere的基础，操作起来完全无压力。就这样我用 “绘声绘影”通过模版添加同学们的照片，合成一个视频。虽然只是简单的8分钟，但是那一周为制作这个视频，我每天下午没有去吃饭，啃着个面包，为的是能在家长会之前做出这个视频，最后。。。成功了。看着同学们惊异的表情，看得出他们对我的赞叹，家长也曾发问：这是哪个学生做的？？其实在我看来，在那些行家看来，那只不过是简简单单的处理，基本上没有加什么，技术含量并不是很高。在最近我看到有个叫 “醉清风”的专门搞“绘声绘影”的高手，我有看过他做出来的视频模版，我当时真的。。。真的震惊了！做得这么好！让人赞叹！这就是专业的和非专业的差距。我想向高手那样，但有种：无从下手的感觉。 我会网站建设，早在初中在耍手机的时候有个wap.ai免费建站的，当时好奇玩玩，我学到了UBB的一些简单代码，觉得很有趣。直到后来我了解到了除了 UBB还有html jsp php asp这些东东，但都不是很精通，只会最简单的。我也向同学们“炫耀”，但有些时候遇到“高手”，他会问：你的服务器、解析、备案…我真的不知道。直到后来我买了自己的第一个域名、第一个空间。才懂得了这些。原来搞个网站这么复杂，还要给钱。后来我知道了lofter这个，可以将域名免费解析到这上面，而且发帖子更简单了。远远比用 DREAMWEAVER那些简单，我知道网站肯定会和Dreamweaver挂钩，但是、、、真的真的不懂，而且麻烦，根本学不下去。 我羡慕那些天才，佩服他们。想想凯文。米特尼克，只有15岁的米特闯入了“北美空中防护指挥系统”的计算机主机；还有 扎克伯格、莫里斯。。。那些 神一般的人物、、、 我会很多，但是都不精通，想学很多，但又耐不住寂寞，我该何去何从？where should i go？也许要等到 那个所谓的大学？","categories":[{"name":"生活感想","slug":"life","permalink":"http://vompom.github.com/categories/life/"}],"tags":[{"name":"高中","slug":"middle","permalink":"http://vompom.github.com/tags/middle/"}],"author":"落叶挽歌"}],"categories":[{"name":"思考总结","slug":"thinking","permalink":"http://vompom.github.com/categories/thinking/"},{"name":"算法研究","slug":"算法研究","permalink":"http://vompom.github.com/categories/%E7%AE%97%E6%B3%95%E7%A0%94%E7%A9%B6/"},{"name":"技术文章","slug":"technology","permalink":"http://vompom.github.com/categories/technology/"},{"name":"读书电影","slug":"movie","permalink":"http://vompom.github.com/categories/movie/"},{"name":"生活感想","slug":"life","permalink":"http://vompom.github.com/categories/life/"}],"tags":[{"name":"SDK","slug":"SDK","permalink":"http://vompom.github.com/tags/SDK/"},{"name":"数学","slug":"数学","permalink":"http://vompom.github.com/tags/%E6%95%B0%E5%AD%A6/"},{"name":"音视频","slug":"音视频","permalink":"http://vompom.github.com/tags/%E9%9F%B3%E8%A7%86%E9%A2%91/"},{"name":"koin","slug":"koin","permalink":"http://vompom.github.com/tags/koin/"},{"name":"KMP","slug":"KMP","permalink":"http://vompom.github.com/tags/KMP/"},{"name":"鸿蒙","slug":"鸿蒙","permalink":"http://vompom.github.com/tags/%E9%B8%BF%E8%92%99/"},{"name":"mmap","slug":"mmap","permalink":"http://vompom.github.com/tags/mmap/"},{"name":"Android","slug":"Android","permalink":"http://vompom.github.com/tags/Android/"},{"name":"安卓","slug":"Android","permalink":"http://vompom.github.com/tags/Android/"},{"name":"UTF-8","slug":"UTF-8","permalink":"http://vompom.github.com/tags/UTF-8/"},{"name":"FFmpeg","slug":"FFmpeg","permalink":"http://vompom.github.com/tags/FFmpeg/"},{"name":"技术文章","slug":"technology","permalink":"http://vompom.github.com/tags/technology/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://vompom.github.com/tags/JavaScript/"},{"name":"OpenGL","slug":"OpenGL","permalink":"http://vompom.github.com/tags/OpenGL/"},{"name":"Unity","slug":"Unity","permalink":"http://vompom.github.com/tags/Unity/"},{"name":"MediaCodec","slug":"MediaCodec","permalink":"http://vompom.github.com/tags/MediaCodec/"},{"name":"Flutter","slug":"Flutter","permalink":"http://vompom.github.com/tags/Flutter/"},{"name":"工具","slug":"工具","permalink":"http://vompom.github.com/tags/%E5%B7%A5%E5%85%B7/"},{"name":"面试","slug":"面试","permalink":"http://vompom.github.com/tags/%E9%9D%A2%E8%AF%95/"},{"name":"逆向","slug":"逆向","permalink":"http://vompom.github.com/tags/%E9%80%86%E5%90%91/"},{"name":"JNI","slug":"JNI","permalink":"http://vompom.github.com/tags/JNI/"},{"name":"读书","slug":"读书","permalink":"http://vompom.github.com/tags/%E8%AF%BB%E4%B9%A6/"},{"name":"诗歌","slug":"诗歌","permalink":"http://vompom.github.com/tags/%E8%AF%97%E6%AD%8C/"},{"name":"Java","slug":"java","permalink":"http://vompom.github.com/tags/java/"},{"name":"省","slug":"thinking","permalink":"http://vompom.github.com/tags/thinking/"},{"name":"Http","slug":"Http","permalink":"http://vompom.github.com/tags/Http/"},{"name":"Https","slug":"Https","permalink":"http://vompom.github.com/tags/Https/"},{"name":"Shell","slug":"Shell","permalink":"http://vompom.github.com/tags/Shell/"},{"name":"插件","slug":"插件","permalink":"http://vompom.github.com/tags/%E6%8F%92%E4%BB%B6/"},{"name":"算法","slug":"algorithm","permalink":"http://vompom.github.com/tags/algorithm/"},{"name":"插件化","slug":"plugins","permalink":"http://vompom.github.com/tags/plugins/"},{"name":"生活","slug":"life","permalink":"http://vompom.github.com/tags/life/"},{"name":"设计模式","slug":"design","permalink":"http://vompom.github.com/tags/design/"},{"name":"旅行","slug":"travel","permalink":"http://vompom.github.com/tags/travel/"},{"name":"知乎","slug":"zhihu","permalink":"http://vompom.github.com/tags/zhihu/"},{"name":"网络","slug":"网络","permalink":"http://vompom.github.com/tags/%E7%BD%91%E7%BB%9C/"},{"name":"大学","slug":"大学","permalink":"http://vompom.github.com/tags/%E5%A4%A7%E5%AD%A6/"},{"name":"前端","slug":"前端","permalink":"http://vompom.github.com/tags/%E5%89%8D%E7%AB%AF/"},{"name":"高中","slug":"middle","permalink":"http://vompom.github.com/tags/middle/"}]}