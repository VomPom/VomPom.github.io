<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="落叶挽歌"><title>Android屏幕刷新机制 | 落叶挽歌</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=1.0.0"><link rel="stylesheet" type="text/css" href="https://unpkg.com/normalize.css"><link rel="stylesheet" type="text/css" href="https://unpkg.com/purecss/build/pure-min.css"><link rel="stylesheet" type="text/css" href="https://unpkg.com/purecss/build/grids-responsive-min.css"><link rel="stylesheet" href="https://unpkg.com/font-awesome@4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="https://unpkg.com/jquery/dist/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement('script');
  hm.src = 'https://hm.baidu.com/hm.js?' + 'a642bfb7c75afbc4fe68fd942180298b';
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
  })();</script><script type="text/javascript" src="https://unpkg.com/clipboard/dist/clipboard.min.js"></script><script type="text/javascript" src="https://unpkg.com/toastr/build/toastr.min.js"></script><link rel="stylesheet" href="https://unpkg.com/toastr/build/toastr.min.css"><div class="darkmode-toggle">🌓</div><script>var prefersDarkMode = window.matchMedia('(prefers-color-scheme: dark)');
var toggle = document.querySelector('.darkmode-toggle');
var html = document.querySelector('html');

html.dataset.dark = localStorage.dark || prefersDarkMode.matches;

toggle.addEventListener('click', () => {
localStorage.dark = !(html.dataset.dark == 'true');
html.dataset.dark = localStorage.dark;
});</script><meta name="generator" content="Hexo 7.3.0"><link rel="stylesheet" href="/css/prism.css" type="text/css"><script src="/js/prism.js"></script></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Android屏幕刷新机制</h1><a id="logo" href="/.">落叶挽歌</a><p class="description">juliswang's 博客</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Android屏幕刷新机制</h1><div class="post-meta">2025年02月24日<span> | </span><span class="category"><a href="/categories/technology/">技术文章</a></span><script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> 阅读</span></span><span class="post-time"><span class="post-meta-item-text"> | </span><span class="post-meta-item-icon"><i class="fa fa-keyboard-o"></i><span class="post-count"> 7k</span><span class="post-meta-item-text"> 字</span></span></span><span class="post-time"> | <span class="post-meta-item-icon"><i class="fa fa-clock-o"></i><span class="post-count"> 28</span><span class="post-meta-item-text"> 分钟</span></span></span></div><div class="post-content"><p>最近在研究 Android 屏幕显示与渲染相关的内容，平时经常看到这些类 <code>ViewRootImpl</code>、<code>Choreographer</code>、<code>Surface</code> 、 <code>SurfaceFlinger</code>等，知道它们都用于屏幕渲染相关，但对它们细节了解较少，相关的文章也比较多，不需要自己完全重新再编写一份，于是对相关内容进行一个总结,<br>主要来源：<a href="https://juejin.cn/post/6863756420380196877">《Android屏幕刷新机制—VSyncChoreographer 全面理解》</a>，这篇博客是我认为是目前看到过最好的一篇，文章由浅入深比较好理解。不过文章里面图片链接资源已经失效，为以后复习相关知识点，在此将其整理删除冗余内容，并对图片资源进行更新。</p>
<h2 id="一、背景和疑问"><a href="#一、背景和疑问" class="headerlink" title="一、背景和疑问"></a><strong>一、背景和疑问</strong></h2><p>在Android中，当我们谈到 <strong>布局优化</strong>、<strong>卡顿优化</strong> 时，通常都知道 需要减少布局层级、减少主线程耗时操作，这样可以减少<strong>丢帧</strong>。如果丢帧比较严重，那么界面可能会有明显的卡顿感。我们知道 通常手机刷新是每秒60次，即每隔16.6ms刷新一次。 问题来了：</p>
<ol>
<li><strong>丢帧</strong>(掉帧) ，是说 这一帧延迟显示 还是丢弃不再显示 ？</li>
<li>布局层级较多&#x2F;主线程耗时 是如何造成 丢帧的呢？</li>
<li>16.6ms刷新一次 是啥意思？是每16.6ms都走一次 measure&#x2F;layout&#x2F;draw ？</li>
<li>measure&#x2F;layout&#x2F;draw 走完，界面就立刻刷新了吗?</li>
<li>如果界面没动静止了，还会刷新吗？</li>
<li>可能你知道<strong>VSYNC</strong>，这个具体指啥？在屏幕刷新中如何工作的？</li>
<li>可能你还听过屏幕刷新使用 <strong>双缓存</strong>、<strong>三缓存</strong>，这又是啥意思呢？</li>
<li>可能你还听过神秘的<strong>Choreographer</strong>，这又是干啥的？</li>
</ol>
<h2 id="二、显示系统基础知识"><a href="#二、显示系统基础知识" class="headerlink" title="二、显示系统基础知识"></a><strong>二、显示系统基础知识</strong></h2><p>在一个典型的显示系统中，一般包括CPU、GPU、Display三个部分， CPU负责计算帧数据，把计算好的数据交给GPU，GPU会对图形数据进行渲染，渲染好后放到buffer(图像缓冲区)里存起来，然后Display（屏幕或显示器）负责把buffer里的数据呈现到屏幕上。如下图：</p>
<img src="https://cdn.julis.wang/blog/img/0nq54q5jtq.jpeg">

<p>单缓存，从缓存映射到屏幕。</p>
<h3 id="2-1-基础概念"><a href="#2-1-基础概念" class="headerlink" title="2.1 基础概念"></a><strong>2.1 基础概念</strong></h3><ul>
<li><strong>屏幕刷新频率</strong> 一秒内屏幕刷新的次数（一秒内显示了多少帧的图像），单位 Hz（赫兹），如常见的 60 Hz。<strong>刷新频率取决于硬件的固定参数</strong>（不会变的）。</li>
<li><strong>逐行扫描</strong> 显示器并不是一次性将画面显示到屏幕上，而是从左到右边，从上到下逐行扫描，顺序显示整屏的一个个像素点，不过这一过程快到人眼无法察觉到变化。以 60 Hz 刷新率的屏幕为例，这一过程即 1000 &#x2F; 60 ≈ 16ms。</li>
<li><strong>帧率</strong> （Frame Rate） 表示 <strong>GPU 在一秒内绘制操作的帧数</strong>，单位 fps。例如在电影界采用 24 帧的速度足够使画面运行的非常流畅。而 Android 系统则采用更加流程的 60 fps，即每秒钟GPU最多绘制 60 帧画面。帧率是动态变化的，例如当画面静止时，GPU 是没有绘制操作的，屏幕刷新的还是buffer中的数据，即GPU最后操作的帧数据。</li>
<li><strong>画面撕裂</strong>（tearing） 一个屏幕内的数据来自2个不同的帧，画面会出现撕裂感，如下图</li>
</ul>
<img src="https://cdn.julis.wang/blog/img/xxm0lvzypa.jpeg">

<p>明显看出画面错位的位置，这就是画面撕裂。</p>
<h3 id="2-2-双缓存"><a href="#2-2-双缓存" class="headerlink" title="2.2 双缓存"></a><strong>2.2 双缓存</strong></h3><h5 id="2-2-1-画面撕裂-原因"><a href="#2-2-1-画面撕裂-原因" class="headerlink" title="2.2.1  画面撕裂 原因"></a><strong>2.2.1  画面撕裂 原因</strong></h5><p>屏幕刷新频是固定的，比如每16.6ms从buffer取数据显示完一帧，理想情况下帧率和刷新频率保持一致，即每绘制完成一帧，显示器显示一帧。但是CPU&#x2F;GPU写数据是不可控的，所以会出现buffer里有些数据根本没显示出来就被重写了，即buffer里的数据可能是来自不同的帧的， 当屏幕刷新时，此时它并不知道buffer的状态，因此从buffer抓取的帧并不是完整的一帧画面，即出现画面撕裂。</p>
<p>简单说就是Display在显示的过程中，buffer内数据被CPU&#x2F;GPU修改，导致画面撕裂。</p>
<h5 id="2-2-2-双缓存"><a href="#2-2-2-双缓存" class="headerlink" title="2.2.2  双缓存"></a><strong>2.2.2  双缓存</strong></h5><p>那咋解决画面撕裂呢？答案是使用 双缓存。</p>
<p>由于图像绘制和屏幕读取 使用的是同个buffer，所以屏幕刷新时可能读取到的是不完整的一帧画面。</p>
<p><strong>双缓存</strong>，让绘制和显示器拥有各自的buffer：GPU 始终将完成的一帧图像数据写入到 <strong>Back Buffer</strong>，而显示器使用 <strong>Frame Buffer</strong>，当屏幕刷新时，Frame Buffer 并不会发生变化，当Back buffer准备就绪后，它们才进行交换。如下图：</p>
<img src="https://cdn.julis.wang/blog/img/q2vukxpyvq.jpeg">

<p>双缓存，CPU&#x2F;GPU写数据到Back Buffer，显示器从Frame Buffer取数据</p>
<h5 id="2-2-3-VSync"><a href="#2-2-3-VSync" class="headerlink" title="2.2.3  VSync"></a><strong>2.2.3  VSync</strong></h5><p>问题又来了：什么时候进行两个buffer的交换呢？</p>
<p>假如是 Back buffer准备完成一帧数据以后就进行，那么如果此时屏幕还没有完整显示上一帧内容的话，肯定是会出问题的。看来只能是等到屏幕处理完一帧数据后，才可以执行这一操作了。</p>
<p>当扫描完一个屏幕后，设备需要重新回到第一行以进入下一次的循环，此时有一段时间空隙，称为VerticalBlanking Interval(VBI)。那，这个时间点就是我们进行缓冲区交换的最佳时间。因为此时屏幕没有在刷新，也就避免了交换过程中出现 screen tearing的状况。</p>
<p><strong>VSync</strong>(垂直同步)是VerticalSynchronization的简写，它利用VBI时期出现的vertical sync pulse（垂直同步脉冲）来保证双缓冲在最佳时间点才进行交换。另外，交换是指各自的内存地址，可以认为该操作是瞬间完成。</p>
<p>所以说V-sync这个概念并不是Google首创的，它在早年的PC机领域就已经出现了。</p>
<h2 id="三、Android屏幕刷新机制"><a href="#三、Android屏幕刷新机制" class="headerlink" title="三、Android屏幕刷新机制"></a><strong>三、Android屏幕刷新机制</strong></h2><h3 id="3-1-Android4-1之前的问题"><a href="#3-1-Android4-1之前的问题" class="headerlink" title="3.1 Android4.1之前的问题"></a><strong>3.1 Android4.1之前的问题</strong></h3><p>具体到Android中，在Android4.1之前，屏幕刷新也遵循 上面介绍的 双缓存+VSync 机制。如下图：</p>
<img src="https://cdn.julis.wang/blog/img/1ax0mz0nu1.jpeg">

<p>双缓存会在VSync脉冲时交换，但CPU&#x2F;GPU绘制是随机的</p>
<p>以时间的顺序来看下将会发生的过程：</p>
<ol>
<li>Display显示第0帧数据，此时CPU和<a href="https://cloud.tencent.com/solution/render?from_column=20065&from=20065">GPU渲染</a>第1帧画面，且在Display显示下一帧前完成</li>
<li>因为渲染及时，Display在第0帧显示完成后，也就是第1个VSync后，缓存进行交换，然后正常显示第1帧</li>
<li>接着第2帧开始处理，是直到第2个VSync快来前才开始处理的。</li>
<li>第2个VSync来时，由于第2帧数据还没有准备就绪，缓存没有交换，显示的还是第1帧。这种情况被Android开发组命名为“Jank”，即发生了<strong>丢帧</strong>。</li>
<li>当第2帧数据准备完成后，它并不会马上被显示，而是要等待下一个VSync 进行缓存交换再显示。</li>
</ol>
<p>所以总的来说，就是屏幕平白无故地多显示了一次第1帧。</p>
<p>原因是 第2帧的CPU&#x2F;GPU计算 没能在VSync信号到来前完成 。</p>
<p>我们知道，<strong>双缓存的交换 是在Vsyn到来时进行，交换后屏幕会取Frame buffer内的新数据，而实际 此时的Back buffer 就可以供GPU准备下一帧数据了。如果 Vsyn到来时  CPU&#x2F;GPU就开始操作的话，是有完整的16.6ms的，这样应该会基本避免jank的出现了</strong>（除非CPU&#x2F;GPU计算超过了16.6ms）。  那如何让 CPU&#x2F;GPU计算在 Vsyn到来时进行呢？</p>
<h3 id="3-2-drawing-with-VSync"><a href="#3-2-drawing-with-VSync" class="headerlink" title="3.2 drawing with VSync"></a><strong>3.2 drawing with VSync</strong></h3><p>为了优化显示性能，Google在Android 4.1系统中对Android Display系统进行了重构，实现了Project Butter（黄油工程）：系统在收到VSync pulse后，将马上开始下一帧的渲染。即<strong>一旦收到VSync通知（16ms触发一次），CPU和GPU 才立刻开始计算然后把数据写入buffer</strong>。如下图：</p>
<img src="https://cdn.julis.wang/blog/img/uuqflxwo53.jpeg">

<p>VSync脉冲到来：双缓存交换，且开始CPU&#x2F;GPU绘制 CPU&#x2F;GPU根据VSYNC信号同步处理数据，可以让CPU&#x2F;GPU有完整的16ms时间来处理数据，减少了jank。</p>
<p>一句话总结，<strong>VSync同步使得CPU&#x2F;GPU充分利用了16.6ms时间，减少jank。</strong></p>
<p>问题又来了，如果界面比较复杂，CPU&#x2F;GPU的处理时间较长 超过了16.6ms呢？如下图：</p>
<img src="https://cdn.julis.wang/blog/img/po2jd1h7u8.jpeg">

<p>虽然CPU&#x2F;GPU开始在VSync，但超过16.6ms</p>
<ol>
<li>在第二个时间段内，但却因 GPU 还在处理 B 帧，缓存没能交换，导致 A 帧被重复显示。</li>
<li>而B完成后，又因为缺乏VSync pulse信号，它只能等待下一个signal的来临。于是在这一过程中，有一大段时间是被浪费的。</li>
<li>当下一个VSync出现时，CPU&#x2F;GPU马上执行操作（A帧），且缓存交换，相应的显示屏对应的就是B。这时看起来就是正常的。只不过由于执行时间仍然超过16ms，导致下一次应该执行的缓冲区交换又被推迟了——如此循环反复，便出现了越来越多的“Jank”。</li>
</ol>
<p><strong>为什么 CPU 不能在第二个 16ms 处理绘制工作呢？</strong></p>
<p>原因是只有两个 buffer，Back buffer正在被GPU用来处理B帧的数据， Frame buffer的内容用于Display的显示，这样两个buffer都被占用，CPU 则无法准备下一帧的数据。那么，如果再提供一个buffer，CPU、GPU 和显示设备都能使用各自的buffer工作，互不影响。</p>
<h3 id="3-3-三缓存"><a href="#3-3-三缓存" class="headerlink" title="3.3 三缓存"></a><strong>3.3 三缓存</strong></h3><p><strong>三缓存</strong>就是在双缓冲机制基础上增加了一个 Graphic Buffer 缓冲区，这样可以最大限度的利用空闲时间，带来的坏处是多使用的一个 Graphic Buffer 所占用的内存。</p>
<img src="https://cdn.julis.wang/blog/img/ldq7oda57p.jpeg">

<p>三缓存</p>
<ol>
<li>第一个Jank，是不可避免的。但是在第二个 16ms 时间段，CPU&#x2F;GPU 使用 <strong>第三个 Buffer</strong> 完成C帧的计算，虽然还是会多显示一次 A 帧，但后续显示就比较顺畅了，有效避免 Jank 的进一步加剧。</li>
<li>注意在第3段中，A帧的计算已完成，但是在第4个vsync来的时候才显示，如果是双缓冲，那在第三个vynsc就可以显示了。</li>
</ol>
<p><strong>三缓冲有效利用了等待vysnc的时间，减少了jank，但是带来了延迟。</strong> 所以，是不是 Buffer 越多越好呢？这个是否定的，Buffer 正常还是两个，当出现 Jank 后三个足以。</p>
<p>以上就是Android屏幕刷新的原理了。</p>
<h2 id="四、Choreographer"><a href="#四、Choreographer" class="headerlink" title="四、Choreographer"></a><strong>四、Choreographer</strong></h2><h3 id="4-1-概述"><a href="#4-1-概述" class="headerlink" title="4.1 概述"></a><strong>4.1 概述</strong></h3><p>上面讲到，Google在Android 4.1系统中对Android Display系统进行了优化：在收到VSync pulse后，将马上开始下一帧的渲染。即<strong>一旦收到VSync通知，CPU和GPU就立刻开始计算然后把数据写入buffer</strong>。本节就来讲 “drawing with VSync” 的实现——<strong>Choreographer</strong>。</p>
<ul>
<li>Choreographer，意为 舞蹈编导、编舞者。在这里就是指 对CPU&#x2F;GPU绘制的指导—— 收到VSync信号 才开始绘制，保证绘制拥有完整的16.6ms，避免绘制的随机性。</li>
<li>Choreographer，是一个Java类，包路径android.view.Choreographer。类注释是“协调动画、输入和绘图的计时”。</li>
<li>通常 应用层不会直接使用Choreographer，而是使用更高级的API，例如动画和View绘制相关的ValueAnimator.start()、View.invalidate()等。</li>
<li>业界一般通过Choreographer来监控应用的帧率。</li>
</ul>
<h3 id="4-2-源码分析"><a href="#4-2-源码分析" class="headerlink" title="4.2 源码分析"></a><strong>4.2 源码分析</strong></h3><p>学习 Choreographer 可以帮助理解 每帧运行的原理，也可加深对 Handler机制、View绘制流程的理解，这样再去做UI优化、卡顿优化，思路会更清晰。</p>
<p>好了，下面开始源码分析了~</p>
<h5 id="4-2-1-入口-和-实例创建"><a href="#4-2-1-入口-和-实例创建" class="headerlink" title="4.2.1 入口 和 实例创建"></a><strong>4.2.1 入口 和 实例创建</strong></h5><p>在<a href="https://juejin.cn/post/7076274407416528909">《Window和WindowManager》</a>、<a href="https://blog.csdn.net/allen_xu_2012_new/article/details/131167564">《Activity的启动过程详解》</a>中介绍过，Activity启动 走完onResume方法后，会进行<strong>window的添加</strong>。window添加过程会 调用ViewRootImpl的setView()方法，setView()方法会调用requestLayout()方法来请求绘制布局，requestLayout()方法内部又会走到scheduleTraversals()方法，最后会走到performTraversals()方法，接着到了我们熟知的测量、布局、绘制三大流程了。</p>
<p>另外，查看源码发现，当我们使用 ValueAnimator.start()、View.invalidate()时，最后也是走到ViewRootImpl的scheduleTraversals()方法。（View.invalidate()内部会循环获取ViewParent直到ViewRootImpl的invalidateChildInParent()方法，然后走到scheduleTraversals()，可自行查看源码 ）</p>
<p>即 <strong>所有UI的变化都是走到ViewRootImpl的scheduleTraversals()方法。</strong></p>
<p>那么问题又来了，scheduleTraversals() 到 performTraversals() 中间 经历了什么呢？是立刻执行吗？答案很显然是否定的，根据我们上面的介绍，在VSync信号到来时才会执行绘制，即performTraversals()方法。下面来瞅瞅这是如何实现的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//ViewRootImpl.java</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">scheduleTraversals</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!mTraversalScheduled) &#123;</span><br><span class="line">        <span class="comment">//此字段保证同时间多次更改只会刷新一次，例如TextView连续两次setText(),也只会走一次绘制流程</span></span><br><span class="line">        mTraversalScheduled = <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">//添加同步屏障，屏蔽同步消息，保证VSync到来立即执行绘制</span></span><br><span class="line">        mTraversalBarrier = mHandler.getLooper().getQueue().postSyncBarrier();</span><br><span class="line">        <span class="comment">//mTraversalRunnable是TraversalRunnable实例，最终走到run()，也即doTraversal();</span></span><br><span class="line">        mChoreographer.postCallback(</span><br><span class="line">                Choreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, <span class="literal">null</span>);</span><br><span class="line">        <span class="keyword">if</span> (!mUnbufferedInputDispatch) &#123;</span><br><span class="line">            scheduleConsumeBatchedInput();</span><br><span class="line">        &#125;</span><br><span class="line">        notifyRendererOfFramePending();</span><br><span class="line">        pokeDrawLockIfNeeded();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">TraversalRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        doTraversal();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">final</span> <span class="type">TraversalRunnable</span> <span class="variable">mTraversalRunnable</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TraversalRunnable</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">doTraversal</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (mTraversalScheduled) &#123;</span><br><span class="line">        mTraversalScheduled = <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">//移除同步屏障</span></span><br><span class="line">        mHandler.getLooper().getQueue().removeSyncBarrier(mTraversalBarrier);</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">//开始三大绘制流程</span></span><br><span class="line">        performTraversals();</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主要有以下逻辑：</p>
<ol>
<li>首先使用mTraversalScheduled字段保证同时间多次更改只会刷新一次，例如TextView连续两次setText()，也只会走一次绘制流程。</li>
<li>然后把当前线程的<a href="https://cloud.tencent.com/product/message-queue-catalog?from_column=20065&from=20065">消息队列</a>Queue添加了<strong>同步屏障</strong>，这样就屏蔽了正常的同步消息，保证VSync到来后立即执行绘制，而不是要等前面的同步消息。后面会具体分析同步屏障和异步消息的代码逻辑。</li>
<li>调用了mChoreographer.postCallback()方法，发送一个会在下一帧执行的回调，即<strong>在下一个VSync到来时会执行TraversalRunnable–&gt;doTraversal()—&gt;performTraversals()–&gt;绘制流程</strong>。</li>
</ol>
<p>接下来，就是分析的重点——Choreographer。我们先看它的实例mChoreographer，是在ViewRootImpl的构造方法内使用Choreographer.getInstance()创建：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Choreographer mChoreographer;</span><br><span class="line"></span><br><span class="line"><span class="comment">//ViewRootImpl实例是在添加window时创建</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ViewRootImpl</span><span class="params">(Context context, Display display)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    mChoreographer = Choreographer.getInstance();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们先来看看Choreographer.getInstance()：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Choreographer <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> sThreadInstance.get();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Choreographer&gt; sThreadInstance =</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;Choreographer&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Choreographer <span class="title function_">initialValue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Looper</span> <span class="variable">looper</span> <span class="operator">=</span> Looper.myLooper();</span><br><span class="line">        <span class="keyword">if</span> (looper == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//当前线程要有looper，Choreographer实例需要传入</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;The current thread must have a looper!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Choreographer</span> <span class="variable">choreographer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Choreographer</span>(looper, VSYNC_SOURCE_APP);</span><br><span class="line">        <span class="keyword">if</span> (looper == Looper.getMainLooper()) &#123;</span><br><span class="line">            mMainInstance = choreographer;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> choreographer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>看到这里 如你对Handler机制中looper比较熟悉的话，应该知道 Choreographer和Looper一样 是线程单例的。且当前线程要有looper，Choreographer实例需要传入。接着看看Choreographer构造方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="title function_">Choreographer</span><span class="params">(Looper looper, <span class="type">int</span> vsyncSource)</span> &#123;</span><br><span class="line">    mLooper = looper;</span><br><span class="line">    <span class="comment">//使用当前线程looper创建 mHandler</span></span><br><span class="line">    mHandler = <span class="keyword">new</span> <span class="title class_">FrameHandler</span>(looper);</span><br><span class="line">    <span class="comment">//USE_VSYNC 4.1以上默认是true，表示 具备接受VSync的能力，这个接受能力就是FrameDisplayEventReceiver</span></span><br><span class="line">    mDisplayEventReceiver = USE_VSYNC</span><br><span class="line">            ? <span class="keyword">new</span> <span class="title class_">FrameDisplayEventReceiver</span>(looper, vsyncSource)</span><br><span class="line">            : <span class="literal">null</span>;</span><br><span class="line">    mLastFrameTimeNanos = Long.MIN_VALUE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算一帧的时间，Android手机屏幕是60Hz的刷新频率，就是16ms</span></span><br><span class="line">    mFrameIntervalNanos = (<span class="type">long</span>)(<span class="number">1000000000</span> / getRefreshRate());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个链表类型CallbackQueue的数组，大小为5，</span></span><br><span class="line">    <span class="comment">//也就是数组中有五个链表，每个链表存相同类型的任务：输入、动画、遍历绘制等任务（CALLBACK_INPUT、CALLBACK_ANIMATION、CALLBACK_TRAVERSAL）</span></span><br><span class="line">    mCallbackQueues = <span class="keyword">new</span> <span class="title class_">CallbackQueue</span>[CALLBACK_LAST + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= CALLBACK_LAST; i++) &#123;</span><br><span class="line">        mCallbackQueues[i] = <span class="keyword">new</span> <span class="title class_">CallbackQueue</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// b/68769804: For low FPS experiments.</span></span><br><span class="line">    setFPSDivisor(SystemProperties.getInt(ThreadedRenderer.DEBUG_FPS_DIVISOR, <span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码中都有注释，创建了一个mHandler、VSync事件接收器mDisplayEventReceiver、任务链表数组mCallbackQueues。FrameHandler、FrameDisplayEventReceiver、CallbackQueue后面会一一说明。</p>
<h5 id="4-2-2-安排任务—postCallback"><a href="#4-2-2-安排任务—postCallback" class="headerlink" title="4.2.2 安排任务—postCallback"></a><strong>4.2.2 安排任务—postCallback</strong></h5><p>回头看mChoreographer.postCallback(Choreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, null)方法，注意到第一个参数是CALLBACK_TRAVERSAL，表示回调任务的类型，共有以下5种类型：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//输入事件，首先执行</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">CALLBACK_INPUT</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="comment">//动画，第二执行</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">CALLBACK_ANIMATION</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="comment">//插入更新的动画，第三执行</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">CALLBACK_INSETS_ANIMATION</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line"><span class="comment">//绘制，第四执行</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">CALLBACK_TRAVERSAL</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line"><span class="comment">//提交，最后执行，</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">CALLBACK_COMMIT</span> <span class="operator">=</span> <span class="number">4</span>;</span><br></pre></td></tr></table></figure>

<p>五种类型任务对应存入对应的CallbackQueue中，每当收到 VSYNC 信号时，Choreographer 将首先处理 INPUT 类型的任务，然后是 ANIMATION 类型，最后才是 TRAVERSAL 类型。</p>
<p>postCallback()内部调用postCallbackDelayed()，接着又调用postCallbackDelayedInternal()，来瞅瞅：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">postCallbackDelayedInternal</span><span class="params">(<span class="type">int</span> callbackType,</span></span><br><span class="line"><span class="params">        Object action, Object token, <span class="type">long</span> delayMillis)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">        <span class="comment">// 当前时间</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">long</span> <span class="variable">now</span> <span class="operator">=</span> SystemClock.uptimeMillis();</span><br><span class="line">        <span class="comment">// 加上延迟时间</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">long</span> <span class="variable">dueTime</span> <span class="operator">=</span> now + delayMillis;</span><br><span class="line">        <span class="comment">//取对应类型的CallbackQueue添加任务</span></span><br><span class="line">        mCallbackQueues[callbackType].addCallbackLocked(dueTime, action, token);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (dueTime &lt;= now) &#123;</span><br><span class="line">            <span class="comment">//立即执行</span></span><br><span class="line">            scheduleFrameLocked(now);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//延迟运行，最终也会走到scheduleFrameLocked()</span></span><br><span class="line">            <span class="type">Message</span> <span class="variable">msg</span> <span class="operator">=</span> mHandler.obtainMessage(MSG_DO_SCHEDULE_CALLBACK, action);</span><br><span class="line">            msg.arg1 = callbackType;</span><br><span class="line">            msg.setAsynchronous(<span class="literal">true</span>);</span><br><span class="line">            mHandler.sendMessageAtTime(msg, dueTime);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先取对应类型的CallbackQueue添加任务，action就是mTraversalRunnable，token是null。<strong>CallbackQueue的addCallbackLocked()就是把 dueTime、action、token组装成CallbackRecord后 存入CallbackQueue的下一个节点</strong>，具体代码比较简单，不再跟进。</p>
<p>然后注意到如果没有延迟会执行scheduleFrameLocked()方法，有延迟就会使用 mHandler发送MSG_DO_SCHEDULE_CALLBACK消息，并且注意到 <strong>使用msg.setAsynchronous(true)把消息设置成异步</strong>，这是因为前面设置了同步屏障，只有异步消息才会执行。我们看下mHandler的对这个消息的处理：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">FrameHandler</span> <span class="keyword">extends</span> <span class="title class_">Handler</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">FrameHandler</span><span class="params">(Looper looper)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(looper);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleMessage</span><span class="params">(Message msg)</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> (msg.what) &#123;</span><br><span class="line">            <span class="keyword">case</span> MSG_DO_FRAME:</span><br><span class="line">                <span class="comment">// 执行doFrame,即绘制过程</span></span><br><span class="line">                doFrame(System.nanoTime(), <span class="number">0</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> MSG_DO_SCHEDULE_VSYNC:</span><br><span class="line">                <span class="comment">//申请VSYNC信号，例如当前需要绘制任务时</span></span><br><span class="line">                doScheduleVsync();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> MSG_DO_SCHEDULE_CALLBACK:</span><br><span class="line">                <span class="comment">//需要延迟的任务，最终还是执行上述两个事件</span></span><br><span class="line">                doScheduleCallback(msg.arg1);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>直接使用doScheduleCallback方法，看看：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">doScheduleCallback</span><span class="params">(<span class="type">int</span> callbackType)</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!mFrameScheduled) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">long</span> <span class="variable">now</span> <span class="operator">=</span> SystemClock.uptimeMillis();</span><br><span class="line">            <span class="keyword">if</span> (mCallbackQueues[callbackType].hasDueCallbacksLocked(now)) &#123;</span><br><span class="line">                scheduleFrameLocked(now);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>发现也是走到这里，即延迟运行最终也会走到scheduleFrameLocked()，跟进看看：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">scheduleFrameLocked</span><span class="params">(<span class="type">long</span> now)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!mFrameScheduled) &#123;</span><br><span class="line">        mFrameScheduled = <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">//开启了VSYNC</span></span><br><span class="line">        <span class="keyword">if</span> (USE_VSYNC) &#123;</span><br><span class="line">            <span class="keyword">if</span> (DEBUG_FRAMES) &#123;</span><br><span class="line">                Log.d(TAG, <span class="string">&quot;Scheduling next frame on vsync.&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//当前执行的线程，是否是mLooper所在线程</span></span><br><span class="line">            <span class="keyword">if</span> (isRunningOnLooperThreadLocked()) &#123;</span><br><span class="line">                <span class="comment">//申请 VSYNC 信号</span></span><br><span class="line">                scheduleVsyncLocked();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 若不在，就用mHandler发送消息到原线程，最后还是调用scheduleVsyncLocked方法</span></span><br><span class="line">                <span class="type">Message</span> <span class="variable">msg</span> <span class="operator">=</span> mHandler.obtainMessage(MSG_DO_SCHEDULE_VSYNC);</span><br><span class="line">                msg.setAsynchronous(<span class="literal">true</span>);<span class="comment">//异步</span></span><br><span class="line">                mHandler.sendMessageAtFrontOfQueue(msg);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果未开启VSYNC则直接doFrame方法（4.1后默认开启）</span></span><br><span class="line">            <span class="keyword">final</span> <span class="type">long</span> <span class="variable">nextFrameTime</span> <span class="operator">=</span> Math.max(</span><br><span class="line">                    mLastFrameTimeNanos / TimeUtils.NANOS_PER_MS + sFrameDelay, now);</span><br><span class="line">            <span class="keyword">if</span> (DEBUG_FRAMES) &#123;</span><br><span class="line">                Log.d(TAG, <span class="string">&quot;Scheduling next frame in &quot;</span> + (nextFrameTime - now) + <span class="string">&quot; ms.&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">Message</span> <span class="variable">msg</span> <span class="operator">=</span> mHandler.obtainMessage(MSG_DO_FRAME);</span><br><span class="line">            msg.setAsynchronous(<span class="literal">true</span>);<span class="comment">//异步</span></span><br><span class="line">            mHandler.sendMessageAtTime(msg, nextFrameTime);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>如果系统未开启 VSYNC 机制，此时直接发送 MSG_DO_FRAME 消息到 FrameHandler。注意查看上面贴出的 FrameHandler 代码，此时直接执行 doFrame 方法。</li>
<li>Android 4.1 之后系统默认开启 VSYNC，在 Choreographer 的构造方法会创建一个 FrameDisplayEventReceiver，scheduleVsyncLocked 方法将会通过它申请 VSYNC 信号。</li>
<li>isRunningOnLooperThreadLocked 方法，其内部根据 Looper 判断是否在原线程，否则发送消息到 FrameHandler。最终还是会调用 scheduleVsyncLocked 方法申请 VSYNC 信号。</li>
</ol>
<p>到这里，<strong>FrameHandler的作用很明显里了：发送异步消息（因为前面设置了同步屏障）。有延迟的任务发延迟消息、不在原线程的发到原线程、没开启VSYNC的直接走 doFrame 方法取执行绘制。</strong></p>
<h5 id="4-2-3-申请和接受VSync"><a href="#4-2-3-申请和接受VSync" class="headerlink" title="4.2.3 申请和接受VSync"></a><strong>4.2.3 申请和接受VSync</strong></h5><p>好了， 接着就看 scheduleVsyncLocked 方法是如何申请 VSYNC 信号的。猜测肯定申请 VSYNC 信号后，信号到来时也是走doFrame() 方法，doFrame()后面再看。先跟进scheduleVsyncLocked():</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">scheduleVsyncLocked</span><span class="params">()</span> &#123;</span><br><span class="line">    mDisplayEventReceiver.scheduleVsync();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>很简单，调用mDisplayEventReceiver的scheduleVsync()方法，mDisplayEventReceiver是Choreographer构造方法中创建，是FrameDisplayEventReceiver 的实例。FrameDisplayEventReceiver是 DisplayEventReceiver 的子类，DisplayEventReceiver 是一个 abstract class：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">DisplayEventReceiver</span><span class="params">(Looper looper, <span class="type">int</span> vsyncSource)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (looper == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;looper must not be null&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mMessageQueue = looper.getQueue();</span><br><span class="line">    <span class="comment">// 注册VSYNC信号监听者</span></span><br><span class="line">    mReceiverPtr = nativeInit(<span class="keyword">new</span> <span class="title class_">WeakReference</span>&lt;DisplayEventReceiver&gt;(<span class="built_in">this</span>), mMessageQueue,</span><br><span class="line">            vsyncSource);</span><br><span class="line"></span><br><span class="line">    mCloseGuard.open(<span class="string">&quot;dispose&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 DisplayEventReceiver 的构造方法会通过 JNI 创建一个 IDisplayEventConnection 的 VSYNC 的监听者。</p>
<p>FrameDisplayEventReceiver的scheduleVsync()就是在 DisplayEventReceiver中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">scheduleVsync</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (mReceiverPtr == <span class="number">0</span>) &#123;</span><br><span class="line">        Log.w(TAG, <span class="string">&quot;Attempted to schedule a vertical sync pulse but the display event &quot;</span></span><br><span class="line">                + <span class="string">&quot;receiver has already been disposed.&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 申请VSYNC中断信号，会回调onVsync方法</span></span><br><span class="line">        nativeScheduleVsync(mReceiverPtr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么scheduleVsync()就是使用native方法nativeScheduleVsync()去申请VSYNC信号。这个native方法就看不了了，只需要知道<strong>VSYNC信号的接受回调是onVsync()</strong>，我们直接看onVsync()：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 接收到VSync脉冲时 回调</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> timestampNanos VSync脉冲的时间戳</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> physicalDisplayId Stable display ID that uniquely describes a (display, port) pair.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> frame 帧号码，自增</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@UnsupportedAppUsage</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onVsync</span><span class="params">(<span class="type">long</span> timestampNanos, <span class="type">long</span> physicalDisplayId, <span class="type">int</span> frame)</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>具体实现是在FrameDisplayEventReceiver中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">FrameDisplayEventReceiver</span> <span class="keyword">extends</span> <span class="title class_">DisplayEventReceiver</span></span><br><span class="line">        <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> mHavePendingVsync;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> mTimestampNanos;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> mFrame;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">FrameDisplayEventReceiver</span><span class="params">(Looper looper, <span class="type">int</span> vsyncSource)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(looper, vsyncSource);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onVsync</span><span class="params">(<span class="type">long</span> timestampNanos, <span class="type">long</span> physicalDisplayId, <span class="type">int</span> frame)</span> &#123;</span><br><span class="line">        <span class="comment">// Post the vsync event to the Handler.</span></span><br><span class="line">        <span class="comment">// The idea is to prevent incoming vsync events from completely starving</span></span><br><span class="line">        <span class="comment">// the message queue.  If there are no messages in the queue with timestamps</span></span><br><span class="line">        <span class="comment">// earlier than the frame time, then the vsync event will be processed immediately.</span></span><br><span class="line">        <span class="comment">// Otherwise, messages that predate the vsync event will be handled first.</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">now</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">        <span class="keyword">if</span> (timestampNanos &gt; now) &#123;</span><br><span class="line">            Log.w(TAG, <span class="string">&quot;Frame time is &quot;</span> + ((timestampNanos - now) * <span class="number">0.000001f</span>)</span><br><span class="line">                    + <span class="string">&quot; ms in the future!  Check that graphics HAL is generating vsync &quot;</span></span><br><span class="line">                    + <span class="string">&quot;timestamps using the correct timebase.&quot;</span>);</span><br><span class="line">            timestampNanos = now;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mHavePendingVsync) &#123;</span><br><span class="line">            Log.w(TAG, <span class="string">&quot;Already have a pending vsync event.  There should only be &quot;</span></span><br><span class="line">                    + <span class="string">&quot;one at a time.&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            mHavePendingVsync = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mTimestampNanos = timestampNanos;</span><br><span class="line">        mFrame = frame;</span><br><span class="line">        <span class="comment">//将本身作为runnable传入msg， 发消息后 会走run()，即doFrame()，也是异步消息</span></span><br><span class="line">        <span class="type">Message</span> <span class="variable">msg</span> <span class="operator">=</span> Message.obtain(mHandler, <span class="built_in">this</span>);</span><br><span class="line">        msg.setAsynchronous(<span class="literal">true</span>);</span><br><span class="line">        mHandler.sendMessageAtTime(msg, timestampNanos / TimeUtils.NANOS_PER_MS);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        mHavePendingVsync = <span class="literal">false</span>;</span><br><span class="line">        doFrame(mTimestampNanos, mFrame);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>onVsync()中，将接收器本身作为runnable传入异步消息msg，并使用mHandler发送msg，最终执行的就是doFrame()方法了。</p>
<p>注意一点是，<strong>onVsync()方法中只是使用mHandler发送消息到MessageQueue中，不一定是立刻执行，如何MessageQueue中前面有较为耗时的操作，那么就要等完成，才会执行本次的doFrame()</strong>。</p>
<h5 id="4-2-4-doFrame"><a href="#4-2-4-doFrame" class="headerlink" title="4.2.4 doFrame"></a><strong>4.2.4 doFrame</strong></h5><p>和上面猜测一样，申请VSync信号接收到后确实是走 doFrame()方法，那么就来看看Choreographer的doFrame()：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">doFrame</span><span class="params">(<span class="type">long</span> frameTimeNanos, <span class="type">int</span> frame)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">long</span> startNanos;</span><br><span class="line">    <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!mFrameScheduled) &#123;</span><br><span class="line">            <span class="keyword">return</span>; <span class="comment">// no work to do</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">// 预期执行时间</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">intendedFrameTimeNanos</span> <span class="operator">=</span> frameTimeNanos;</span><br><span class="line">        startNanos = System.nanoTime();</span><br><span class="line">        <span class="comment">// 超时时间是否超过一帧的时间（这是因为MessageQueue虽然添加了同步屏障，但是还是有正在执行的同步任务，导致doFrame延迟执行了）</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">long</span> <span class="variable">jitterNanos</span> <span class="operator">=</span> startNanos - frameTimeNanos;</span><br><span class="line">        <span class="keyword">if</span> (jitterNanos &gt;= mFrameIntervalNanos) &#123;</span><br><span class="line">            <span class="comment">// 计算掉帧数</span></span><br><span class="line">            <span class="keyword">final</span> <span class="type">long</span> <span class="variable">skippedFrames</span> <span class="operator">=</span> jitterNanos / mFrameIntervalNanos;</span><br><span class="line">            <span class="keyword">if</span> (skippedFrames &gt;= SKIPPED_FRAME_WARNING_LIMIT) &#123;</span><br><span class="line">                <span class="comment">// 掉帧超过30帧打印Log提示</span></span><br><span class="line">                Log.i(TAG, <span class="string">&quot;Skipped &quot;</span> + skippedFrames + <span class="string">&quot; frames!  &quot;</span></span><br><span class="line">                        + <span class="string">&quot;The application may be doing too much work on its main thread.&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">long</span> <span class="variable">lastFrameOffset</span> <span class="operator">=</span> jitterNanos % mFrameIntervalNanos;</span><br><span class="line">            ...</span><br><span class="line">            frameTimeNanos = startNanos - lastFrameOffset;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        mFrameInfo.setVsync(intendedFrameTimeNanos, frameTimeNanos);</span><br><span class="line">        <span class="comment">// Frame标志位恢复</span></span><br><span class="line">        mFrameScheduled = <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// 记录最后一帧时间</span></span><br><span class="line">        mLastFrameTimeNanos = frameTimeNanos;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 按类型顺序 执行任务</span></span><br><span class="line">        Trace.traceBegin(Trace.TRACE_TAG_VIEW, <span class="string">&quot;Choreographer#doFrame&quot;</span>);</span><br><span class="line">        AnimationUtils.lockAnimationClock(frameTimeNanos / TimeUtils.NANOS_PER_MS);</span><br><span class="line"></span><br><span class="line">        mFrameInfo.markInputHandlingStart();</span><br><span class="line">        doCallbacks(Choreographer.CALLBACK_INPUT, frameTimeNanos);</span><br><span class="line"></span><br><span class="line">        mFrameInfo.markAnimationsStart();</span><br><span class="line">        doCallbacks(Choreographer.CALLBACK_ANIMATION, frameTimeNanos);</span><br><span class="line">        doCallbacks(Choreographer.CALLBACK_INSETS_ANIMATION, frameTimeNanos);</span><br><span class="line"></span><br><span class="line">        mFrameInfo.markPerformTraversalsStart();</span><br><span class="line">        doCallbacks(Choreographer.CALLBACK_TRAVERSAL, frameTimeNanos);</span><br><span class="line"></span><br><span class="line">        doCallbacks(Choreographer.CALLBACK_COMMIT, frameTimeNanos);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        AnimationUtils.unlockAnimationClock();</span><br><span class="line">        Trace.traceEnd(Trace.TRACE_TAG_VIEW);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面都有注释了很好理解，接着看任务的具体执行doCallbacks 方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">doCallbacks</span><span class="params">(<span class="type">int</span> callbackType, <span class="type">long</span> frameTimeNanos)</span> &#123;</span><br><span class="line">    CallbackRecord callbacks;</span><br><span class="line">    <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="type">long</span> <span class="variable">now</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">        <span class="comment">// 根据指定的类型CallbackkQueue中查找到达执行时间的CallbackRecord</span></span><br><span class="line">        callbacks = mCallbackQueues[callbackType].extractDueCallbacksLocked(now / TimeUtils.NANOS_PER_MS);</span><br><span class="line">        <span class="keyword">if</span> (callbacks == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        mCallbacksRunning = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//提交任务类型</span></span><br><span class="line">        <span class="keyword">if</span> (callbackType == Choreographer.CALLBACK_COMMIT) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">long</span> <span class="variable">jitterNanos</span> <span class="operator">=</span> now - frameTimeNanos;</span><br><span class="line">            <span class="keyword">if</span> (jitterNanos &gt;= <span class="number">2</span> * mFrameIntervalNanos) &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="type">long</span> <span class="variable">lastFrameOffset</span> <span class="operator">=</span> jitterNanos % mFrameIntervalNanos</span><br><span class="line">                        + mFrameIntervalNanos;</span><br><span class="line">                <span class="keyword">if</span> (DEBUG_JANK) &#123;</span><br><span class="line">                    Log.d(TAG, <span class="string">&quot;Commit callback delayed by &quot;</span> + (jitterNanos * <span class="number">0.000001f</span>)</span><br><span class="line">                            + <span class="string">&quot; ms which is more than twice the frame interval of &quot;</span></span><br><span class="line">                            + (mFrameIntervalNanos * <span class="number">0.000001f</span>) + <span class="string">&quot; ms!  &quot;</span></span><br><span class="line">                            + <span class="string">&quot;Setting frame time to &quot;</span> + (lastFrameOffset * <span class="number">0.000001f</span>)</span><br><span class="line">                            + <span class="string">&quot; ms in the past.&quot;</span>);</span><br><span class="line">                    mDebugPrintNextFrameTimeDelta = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                frameTimeNanos = now - lastFrameOffset;</span><br><span class="line">                mLastFrameTimeNanos = frameTimeNanos;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 迭代执行队列所有任务</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">CallbackRecord</span> <span class="variable">c</span> <span class="operator">=</span> callbacks; c != <span class="literal">null</span>; c = c.next) &#123;</span><br><span class="line">            <span class="comment">// 回调CallbackRecord的run，其内部回调Callback的run</span></span><br><span class="line">            c.run(frameTimeNanos);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">            mCallbacksRunning = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="type">CallbackRecord</span> <span class="variable">next</span> <span class="operator">=</span> callbacks.next;</span><br><span class="line">                <span class="comment">//回收CallbackRecord</span></span><br><span class="line">                recycleCallbackLocked(callbacks);</span><br><span class="line">                callbacks = next;</span><br><span class="line">            &#125; <span class="keyword">while</span> (callbacks != <span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主要内容就是取对应任务类型的队列，遍历队列执行所有任务，执行任务是 CallbackRecord的 run 方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">CallbackRecord</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> CallbackRecord next;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> dueTime;</span><br><span class="line">    <span class="keyword">public</span> Object action; <span class="comment">// Runnable or FrameCallback</span></span><br><span class="line">    <span class="keyword">public</span> Object token;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@UnsupportedAppUsage</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">(<span class="type">long</span> frameTimeNanos)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (token == FRAME_CALLBACK_TOKEN) &#123;</span><br><span class="line">            <span class="comment">// 通过postFrameCallback 或 postFrameCallbackDelayed，会执行这里</span></span><br><span class="line">            ((FrameCallback)action).doFrame(frameTimeNanos);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//取出Runnable执行run()</span></span><br><span class="line">            ((Runnable)action).run();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>前面看到mChoreographer.postCallback传的token是null，所以取出action，就是Runnable，执行run()，这里的action就是 ViewRootImpl 发起的绘制任务mTraversalRunnable了，那么<strong>这样整个逻辑就闭环了</strong>。</p>
<p>那么 啥时候 token &#x3D;&#x3D; FRAME_CALLBACK_TOKEN 呢？答案是Choreographer的postFrameCallback()方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postFrameCallback</span><span class="params">(FrameCallback callback)</span> &#123;</span><br><span class="line">    postFrameCallbackDelayed(callback, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postFrameCallbackDelayed</span><span class="params">(FrameCallback callback, <span class="type">long</span> delayMillis)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (callback == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;callback must not be null&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//也是走到是postCallbackDelayedInternal，并且注意是CALLBACK_ANIMATION类型，</span></span><br><span class="line">    <span class="comment">//token是FRAME_CALLBACK_TOKEN，action就是FrameCallback</span></span><br><span class="line">    postCallbackDelayedInternal(CALLBACK_ANIMATION,</span><br><span class="line">            callback, FRAME_CALLBACK_TOKEN, delayMillis);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">FrameCallback</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFrame</span><span class="params">(<span class="type">long</span> frameTimeNanos)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到postFrameCallback()传入的是FrameCallback实例，接口FrameCallback只有一个doFrame()方法。并且也是走到postCallbackDelayedInternal，FrameCallback实例作为action传入，token则是FRAME_CALLBACK_TOKEN，并且任务是CALLBACK_ANIMATION类型。</p>
<p><strong>Choreographer的postFrameCallback()通常用来计算丢帧情况</strong>，使用方式如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">      <span class="comment">//Application.java</span></span><br><span class="line">       <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">()</span> &#123;</span><br><span class="line">           <span class="built_in">super</span>.onCreate();</span><br><span class="line">           <span class="comment">//在Application中使用postFrameCallback</span></span><br><span class="line">           Choreographer.getInstance().postFrameCallback(<span class="keyword">new</span> <span class="title class_">FPSFrameCallback</span>(System.nanoTime()));</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FPSFrameCallback</span> <span class="keyword">implements</span> <span class="title class_">Choreographer</span>.FrameCallback &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">TAG</span> <span class="operator">=</span> <span class="string">&quot;FPS_TEST&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> <span class="variable">mLastFrameTimeNanos</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> mFrameIntervalNanos;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">FPSFrameCallback</span><span class="params">(<span class="type">long</span> lastFrameTimeNanos)</span> &#123;</span><br><span class="line">        mLastFrameTimeNanos = lastFrameTimeNanos;</span><br><span class="line">        mFrameIntervalNanos = (<span class="type">long</span>)(<span class="number">1000000000</span> / <span class="number">60.0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFrame</span><span class="params">(<span class="type">long</span> frameTimeNanos)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//初始化时间</span></span><br><span class="line">        <span class="keyword">if</span> (mLastFrameTimeNanos == <span class="number">0</span>) &#123;</span><br><span class="line">            mLastFrameTimeNanos = frameTimeNanos;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">long</span> <span class="variable">jitterNanos</span> <span class="operator">=</span> frameTimeNanos - mLastFrameTimeNanos;</span><br><span class="line">        <span class="keyword">if</span> (jitterNanos &gt;= mFrameIntervalNanos) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">long</span> <span class="variable">skippedFrames</span> <span class="operator">=</span> jitterNanos / mFrameIntervalNanos;</span><br><span class="line">            <span class="keyword">if</span>(skippedFrames&gt;<span class="number">30</span>)&#123;</span><br><span class="line">                <span class="comment">//丢帧30以上打印日志</span></span><br><span class="line">                Log.i(TAG, <span class="string">&quot;Skipped &quot;</span> + skippedFrames + <span class="string">&quot; frames!  &quot;</span></span><br><span class="line">                        + <span class="string">&quot;The application may be doing too much work on its main thread.&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        mLastFrameTimeNanos=frameTimeNanos;</span><br><span class="line">        <span class="comment">//注册下一帧回调</span></span><br><span class="line">        Choreographer.getInstance().postFrameCallback(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="4-2-5-小结"><a href="#4-2-5-小结" class="headerlink" title="4.2.5 小结"></a><strong>4.2.5 小结</strong></h5><p>使用Choreographer的postCallback()、postFrameCallback() 作用理解：发送任务 存队列中，监听VSync信号，当前VSync到来时 会使用mHandler发送异步message，这个message的Runnable就是队列中的所有任务。</p>
<p>好了，Choreographer整个代码逻辑都讲完了，引用《Android 之 Choreographer 详细分析》的流程图：</p>
<p>原文流程图为：<a href="https://i-blog.csdnimg.cn/blog_migrate/5ff22e98afde4ff780f8a291d1081619.png">Android 之 Choreographer</a>，但并不是很形象，引用另一张流程图：</p>
<img src="https://cdn.julis.wang/blog/img/aab4273a0af898dcc9bb0fdcc0447b5a.png">
<h2 id="六、疑问解答"><a href="#六、疑问解答" class="headerlink" title="六、疑问解答"></a><strong>六、疑问解答</strong></h2><ol>
<li><strong>丢帧</strong>(掉帧) ，是说 这一帧延迟显示 还是丢弃不再显示 ？ 答：延迟显示，因为缓存交换的时机只能等下一个VSync了。</li>
<li>布局层级较多&#x2F;主线程耗时 是如何造成 丢帧的呢？ 答：布局层级较多&#x2F;主线程耗时 会影响CPU&#x2F;GPU的执行时间，大于16.6ms时只能等下一个VSync了。</li>
<li>16.6ms刷新一次 是啥意思？是每16.6ms都走一次 measure&#x2F;layout&#x2F;draw ？ 答：屏幕的固定刷新频率是60Hz，即16.6ms。不是每16.6ms都走一次 measure&#x2F;layout&#x2F;draw，而是有绘制任务才会走，并且绘制时间间隔是取决于布局复杂度及主线程耗时。</li>
<li>measure&#x2F;layout&#x2F;draw 走完，界面就立刻刷新了吗? 答：不是。measure&#x2F;layout&#x2F;draw 走完后 会在VSync到来时进行缓存交换和刷新。</li>
<li>如果界面没动静止了，还会刷新吗？ 答：屏幕会固定没16.6ms刷新，但CPU&#x2F;GPU不走绘制流程。见下面的SysTrace图。</li>
<li>可能你知道<strong>VSYNC</strong>，这个具体指啥？在屏幕刷新中如何工作的？ 答：当扫描完一个屏幕后，设备需要重新回到第一行以进入下一次的循环，此时会出现的vertical sync pulse（垂直同步脉冲）来保证双缓冲在最佳时间点才进行交换。并且Android4.1后 CPU&#x2F;GPU的绘制是在VSYNC到来时开始。</li>
<li>可能你还听过屏幕刷新使用 <strong>双缓存</strong>、<strong>三缓存</strong>，这又是啥意思呢？ 答：双缓存是Back buffer、Frame buffer，用于解决画面撕裂。三缓存增加一个Back buffer，用于减少Jank。</li>
<li>可能你还听过神秘的<strong>Choreographer</strong>，这又是干啥的？ 答：用于实现——“CPU&#x2F;GPU的绘制是在VSYNC到来时开始”。</li>
</ol>
</div><div id="donate"><link rel="stylesheet" type="text/css" href="/css/donate.css?v=1.0.0"><script type="text/javascript" src="/js/donate.js?v=1.0.0" successtext="复制成功！"></script><a class="pos-f tr3" id="github" href="https://github.com/Kaiyuan/donate-page" target="_blank" title="Github"></a><div id="DonateText">Donate</div><ul class="list pos-f" id="donateBox"><li id="AliPay" qr="https://cdn.julis.wang/blog/img/ali_pay.jpeg"></li><li id="WeChat" qr="https://cdn.julis.wang/blog/img/wechat_pay.png"></li></ul><div class="pos-f left-100" id="QRBox"><div id="MainBox"></div></div></div><div class="tags"><ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android/" rel="tag">安卓</a></li></ul></div><div class="post-nav"><a class="pre" href="/2025/03/17/Learn-from-RetroFit/">RetroFit2 源码学习相关</a><a class="next" href="/2024/11/10/%E5%85%B3%E4%BA%8E-pthread-key-t-%E5%AF%BC%E8%87%B4%E7%9A%84-Android-Crash-%E7%9A%84%E6%8E%A2%E7%B4%A2/">关于 pthread_key_t 导致的 Android Crash 的探索</a></div></div></div></div><div class="pure-u-1 pure-u-md-1-4"><div id="sidebar"><div class="widget"><div class="search-form"><input id="local-search-input" placeholder="Search" type="text" name="q" results="0"/><div id="local-search-result"></div></div></div><div class="widget"><div class="author-info"><a class="info-avatar" href="/about/" title="关于"><img class="nofancybox" src="/img/avatar.png"/></a><p>For a better life.</p><a class="info-icon" href="mailto:admin@domain.com" title="Email" target="_blank" style="margin-inline:5px"> <i class="fa fa-envelope-square" style="margin-inline:5px"></i></a><a class="info-icon" href="https://github.com/vompom" title="Github" target="_blank" style="margin-inline:5px"> <i class="fa fa-github-square" style="margin-inline:5px"></i></a><a class="info-icon" href="/atom.xml" title="RSS" target="_blank" style="margin-inline:5px"> <i class="fa fa-rss-square" style="margin-inline:5px"></i></a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/thinking/">思考总结</a><span class="category-list-count">7</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/technology/">技术文章</a><span class="category-list-count">38</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/life/">生活感想</a><span class="category-list-count">9</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%AE%97%E6%B3%95%E7%A0%94%E7%A9%B6/">算法研究</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/movie/">读书电影</a><span class="category-list-count">6</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/travel/" style="font-size: 15px;">旅行</a> <a href="/tags/zhihu/" style="font-size: 15px;">知乎</a> <a href="/tags/JavaScript/" style="font-size: 15px;">JavaScript</a> <a href="/tags/plugins/" style="font-size: 15px;">插件化</a> <a href="/tags/Android/" style="font-size: 15px;">Android</a> <a href="/tags/%E9%80%86%E5%90%91/" style="font-size: 15px;">逆向</a> <a href="/tags/FFmpeg/" style="font-size: 15px;">FFmpeg</a> <a href="/tags/MediaCodec/" style="font-size: 15px;">MediaCodec</a> <a href="/tags/Android/" style="font-size: 15px;">安卓</a> <a href="/tags/KMP/" style="font-size: 15px;">KMP</a> <a href="/tags/Flutter/" style="font-size: 15px;">Flutter</a> <a href="/tags/Http/" style="font-size: 15px;">Http</a> <a href="/tags/Https/" style="font-size: 15px;">Https</a> <a href="/tags/JNI/" style="font-size: 15px;">JNI</a> <a href="/tags/java/" style="font-size: 15px;">Java</a> <a href="/tags/mmap/" style="font-size: 15px;">mmap</a> <a href="/tags/koin/" style="font-size: 15px;">koin</a> <a href="/tags/%E7%BD%91%E7%BB%9C/" style="font-size: 15px;">网络</a> <a href="/tags/Unity/" style="font-size: 15px;">Unity</a> <a href="/tags/%E8%AF%BB%E4%B9%A6/" style="font-size: 15px;">读书</a> <a href="/tags/life/" style="font-size: 15px;">生活</a> <a href="/tags/thinking/" style="font-size: 15px;">省</a> <a href="/tags/%E6%95%B0%E5%AD%A6/" style="font-size: 15px;">数学</a> <a href="/tags/%E6%8F%92%E4%BB%B6/" style="font-size: 15px;">插件</a> <a href="/tags/UTF-8/" style="font-size: 15px;">UTF-8</a> <a href="/tags/algorithm/" style="font-size: 15px;">算法</a> <a href="/tags/design/" style="font-size: 15px;">设计模式</a> <a href="/tags/%E8%A7%86%E9%A2%91/" style="font-size: 15px;">视频</a> <a href="/tags/flutter/" style="font-size: 15px;">flutter</a> <a href="/tags/mac/" style="font-size: 15px;">mac</a> <a href="/tags/%E5%B7%A5%E5%85%B7/" style="font-size: 15px;">工具</a> <a href="/tags/Shell/" style="font-size: 15px;">Shell</a> <a href="/tags/technology/" style="font-size: 15px;">技术文章</a> <a href="/tags/%E5%89%8D%E7%AB%AF/" style="font-size: 15px;">前端</a> <a href="/tags/%E9%9D%A2%E8%AF%95/" style="font-size: 15px;">面试</a> <a href="/tags/%E8%AF%97%E6%AD%8C/" style="font-size: 15px;">诗歌</a> <a href="/tags/middle/" style="font-size: 15px;">高中</a> <a href="/tags/%E9%B8%BF%E8%92%99/" style="font-size: 15px;">鸿蒙</a> <a href="/tags/OpenGL/" style="font-size: 15px;">OpenGL</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2025/08/25/Koin-%E6%BA%90%E7%A0%81%E7%90%86%E8%A7%A3%E7%9B%B8%E5%85%B3/">手写一个精简版Koin：深入理解依赖注入核心原理</a></li><li class="post-list-item"><a class="post-list-link" href="/2025/07/28/Compose-Multiplatform-%E8%B7%A8%E5%B9%B3%E5%8F%B0%E5%8D%9A%E5%AE%A2%E5%BA%94%E7%94%A8%E5%AE%9E%E8%B7%B5/">[Compose Multiplatform]跨平台博客应用实践</a></li><li class="post-list-item"><a class="post-list-link" href="/2025/05/16/%E9%B8%BF%E8%92%99-%E5%86%99%E4%BA%86%E4%B8%AA%E5%9F%BA%E4%BA%8EHexo%E5%8D%9A%E5%AE%A2%E7%9A%84%E9%B8%BF%E8%92%99App/">[鸿蒙]写了个基于Hexo博客的鸿蒙App</a></li><li class="post-list-item"><a class="post-list-link" href="/2025/03/30/KV-%E5%AD%98%E5%82%A8%E4%B9%8Bmmkv/">KV-存储之mmkv</a></li><li class="post-list-item"><a class="post-list-link" href="/2025/03/17/Learn-from-RetroFit/">RetroFit2 源码学习相关</a></li><li class="post-list-item"><a class="post-list-link" href="/2025/02/24/Android%E5%B1%8F%E5%B9%95%E5%88%B7%E6%96%B0%E6%9C%BA%E5%88%B6/">Android屏幕刷新机制</a></li><li class="post-list-item"><a class="post-list-link" href="/2024/11/10/%E5%85%B3%E4%BA%8E-pthread-key-t-%E5%AF%BC%E8%87%B4%E7%9A%84-Android-Crash-%E7%9A%84%E6%8E%A2%E7%B4%A2/">关于 pthread_key_t 导致的 Android Crash 的探索</a></li><li class="post-list-item"><a class="post-list-link" href="/2024/08/25/%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95-Hexo-TypeError-isDate-is-not-a-function/">[问题记录]Hexo TypeError: isDate is not a function</a></li><li class="post-list-item"><a class="post-list-link" href="/2024/07/09/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E4%BA%BA%E5%91%98%E7%9A%84%E5%B8%B8%E9%9D%92%E6%8A%80%E8%83%BD/">[译]软件开发人员的常青技能</a></li><li class="post-list-item"><a class="post-list-link" href="/2024/04/11/%E5%85%B3%E4%BA%8EWindows%E4%B8%AD%E6%96%87%E5%AD%97%E7%AC%A6%E4%B9%B1%E7%A0%81/">UTF-8字符编码相关</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="https://github.com/VomPom" title="Github" target="_blank">Github</a><ul></ul><a href="https://www.douban.com/people/vompom/" title="豆瓣" target="_blank">豆瓣</a><ul></ul><a href="mailto:1607637473@qq.com" title="邮箱" target="_blank">邮箱</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2025 <a href="/." rel="nofollow">落叶挽歌.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.<p></a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=1.0.0" async></script><script type="text/javascript" src="https://unpkg.com/@fancyapps/fancybox/dist/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=1.0.0" async></script><link rel="stylesheet" type="text/css" href="https://unpkg.com/@fancyapps/fancybox/dist/jquery.fancybox.min.css"><link rel="stylesheet" type="text/css" href="/css/search.css?v=1.0.0"><script type="text/javascript" src="/js/search.js?v=1.0.0"></script><script>var search_path = 'search.xml';
if (search_path.length == 0) {
  search_path = 'search.xml';
}
var path = '/' + search_path;
searchFunc(path, 'local-search-input', 'local-search-result');
</script><script type="text/javascript" src="/js/copycode.js?v=1.0.0" successtext="复制成功！"></script><link rel="stylesheet" type="text/css" href="/css/copycode.css?v=1.0.0"><script type="text/javascript" src="/js/codeblock-resizer.js?v=1.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=1.0.0"></script></div></body></html>